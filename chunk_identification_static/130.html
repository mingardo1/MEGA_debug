<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>130</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    130
                    <a href="129.html">prev</a>
                    <a href="131.html">next</a>
                    <a href="130_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_af265461f1c56e3a7adc42f34032f45b8522722a_src/com/android/launcher3/LauncherBackupHelper.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;af265461f1c56e3a7adc42f34032f45b8522722a:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;af265461f1c56e3a7adc42f34032f45b8522722a^1:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;af265461f1c56e3a7adc42f34032f45b8522722a^2:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;d848ca4869b4f0ae1ddc0ee7abe00984d6162cc1:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b]], subset: [[b], [b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.app.backup.BackupDataInputStream;
  19 import android.app.backup.BackupDataOutput;
  20 import android.app.backup.BackupHelper;
  21 import android.app.backup.BackupManager;
  22 import android.content.ComponentName;
  23 import android.content.ContentResolver;
  24 import android.content.ContentValues;
  25 import android.content.Context;
  26 import android.content.Intent;
  27 import android.content.pm.ActivityInfo;
  28 import android.content.pm.PackageManager;
  29 import android.content.pm.PackageManager.NameNotFoundException;
  30 import android.content.pm.ResolveInfo;
  31 import android.content.res.XmlResourceParser;
  32 import android.database.Cursor;
  33 import android.graphics.Bitmap;
  34 import android.graphics.BitmapFactory;
  35 import android.graphics.Point;
  36 import android.graphics.drawable.Drawable;
  37 import android.os.ParcelFileDescriptor;
  38 import android.text.TextUtils;
  39 import android.util.Base64;
  40 import android.util.Log;
  41 
  42 import com.android.launcher3.LauncherSettings.Favorites;
  43 import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  44 import com.android.launcher3.backup.BackupProtos;
  45 import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  46 import com.android.launcher3.backup.BackupProtos.DeviceProfieData;
  47 import com.android.launcher3.backup.BackupProtos.Favorite;
  48 import com.android.launcher3.backup.BackupProtos.Journal;
  49 import com.android.launcher3.backup.BackupProtos.Key;
  50 import com.android.launcher3.backup.BackupProtos.Resource;
  51 import com.android.launcher3.backup.BackupProtos.Screen;
  52 import com.android.launcher3.backup.BackupProtos.Widget;
  53 import com.android.launcher3.compat.UserHandleCompat;
  54 import com.android.launcher3.compat.UserManagerCompat;
  55 import com.android.launcher3.model.MigrateFromRestoreTask;
  56 import com.android.launcher3.util.Thunk;
  57 import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  58 import com.google.protobuf.nano.MessageNano;
  59 
  60 import org.xmlpull.v1.XmlPullParser;
  61 import org.xmlpull.v1.XmlPullParserException;
  62 
  63 import java.io.FileInputStream;
  64 import java.io.FileOutputStream;
  65 import java.io.IOException;
  66 import java.net.URISyntaxException;
  67 import java.util.ArrayList;
  68 import java.util.Arrays;
  69 import java.util.HashSet;
  70 import java.util.zip.CRC32;
  71 
  72 /**
  73  * Persist the launcher home state across calamities.
  74  */
  75 public class LauncherBackupHelper implements BackupHelper {
  76     private static final String TAG = &quot;LauncherBackupHelper&quot;;
  77     private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  78     private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  79 
  80     private static final int BACKUP_VERSION = 4;
  81     private static final int MAX_JOURNAL_SIZE = 1000000;
  82 
  83     // Journal key is such that it is always smaller than any dynamically generated
  84     // key (any Base64 encoded string).
  85     private static final String JOURNAL_KEY = &quot;#&quot;;
  86 
  87     /** icons are large, dribble them out */
  88     private static final int MAX_ICONS_PER_PASS = 10;
  89 
  90     /** widgets contain previews, which are very large, dribble them out */
  91     private static final int MAX_WIDGETS_PER_PASS = 5;
  92 
  93     private static final String[] FAVORITE_PROJECTION = {
  94         Favorites._ID,                     // 0
  95         Favorites.MODIFIED,                // 1
  96         Favorites.INTENT,                  // 2
  97         Favorites.APPWIDGET_PROVIDER,      // 3
  98         Favorites.APPWIDGET_ID,            // 4
  99         Favorites.CELLX,                   // 5
 100         Favorites.CELLY,                   // 6
 101         Favorites.CONTAINER,               // 7
 102         Favorites.ICON,                    // 8
 103         Favorites.ICON_PACKAGE,            // 9
 104         Favorites.ICON_RESOURCE,           // 10
 105         Favorites.ICON_TYPE,               // 11
 106         Favorites.ITEM_TYPE,               // 12
 107         Favorites.SCREEN,                  // 13
 108         Favorites.SPANX,                   // 14
 109         Favorites.SPANY,                   // 15
 110         Favorites.TITLE,                   // 16
 111         Favorites.PROFILE_ID,              // 17
 112         Favorites.RANK,                    // 18
 113     };
 114 
 115     private static final int ID_INDEX = 0;
 116     private static final int ID_MODIFIED = 1;
 117     private static final int INTENT_INDEX = 2;
 118     private static final int APPWIDGET_PROVIDER_INDEX = 3;
 119     private static final int APPWIDGET_ID_INDEX = 4;
 120     private static final int CELLX_INDEX = 5;
 121     private static final int CELLY_INDEX = 6;
 122     private static final int CONTAINER_INDEX = 7;
 123     private static final int ICON_INDEX = 8;
 124     private static final int ICON_PACKAGE_INDEX = 9;
 125     private static final int ICON_RESOURCE_INDEX = 10;
 126     private static final int ICON_TYPE_INDEX = 11;
 127     private static final int ITEM_TYPE_INDEX = 12;
 128     private static final int SCREEN_INDEX = 13;
 129     private static final int SPANX_INDEX = 14;
 130     private static final int SPANY_INDEX = 15;
 131     private static final int TITLE_INDEX = 16;
 132     private static final int RANK_INDEX = 18;
 133 
 134     private static final String[] SCREEN_PROJECTION = {
 135         WorkspaceScreens._ID,              // 0
 136         WorkspaceScreens.MODIFIED,         // 1
 137         WorkspaceScreens.SCREEN_RANK       // 2
 138     };
 139 
 140     private static final int SCREEN_RANK_INDEX = 2;
 141 
 142     @Thunk final Context mContext;
 143     private final HashSet&lt;String&gt; mExistingKeys;
 144     private final ArrayList&lt;Key&gt; mKeys;
 145     private final ItemTypeMatcher[] mItemTypeMatchers;
 146     private final long mUserSerial;
 147 
 148     private BackupManager mBackupManager;
 149     private byte[] mBuffer = new byte[512];
 150     private long mLastBackupRestoreTime;
 151     private boolean mBackupDataWasUpdated;
 152 
 153     private IconCache mIconCache;
 154     private DeviceProfieData mDeviceProfileData;
 155     private InvariantDeviceProfile mIdp;
 156 
 157     DeviceProfieData migrationCompatibleProfileData;
 158     HashSet&lt;String&gt; widgetSizes = new HashSet&lt;&gt;();
 159 
 160     boolean restoreSuccessful;
 161     int restoredBackupVersion = 1;
 162 
 163     // When migrating from a device which different hotseat configuration, the icons are shifted
 164     // to center along the new all-apps icon.
 165     private int mHotseatShift = 0;
 166 
 167     public LauncherBackupHelper(Context context) {
 168         mContext = context;
 169         mExistingKeys = new HashSet&lt;String&gt;();
 170         mKeys = new ArrayList&lt;Key&gt;();
 171         restoreSuccessful = true;
 172         mItemTypeMatchers = new ItemTypeMatcher[CommonAppTypeParser.SUPPORTED_TYPE_COUNT];
 173 
 174         UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 175         mUserSerial = userManager.getSerialNumberForUser(UserHandleCompat.myUserHandle());
 176     }
 177 
 178     private void dataChanged() {
 179         if (mBackupManager == null) {
 180             mBackupManager = new BackupManager(mContext);
 181         }
 182         mBackupManager.dataChanged();
 183     }
 184 
 185     private void applyJournal(Journal journal) {
 186         mLastBackupRestoreTime = journal.t;
 187         mExistingKeys.clear();
 188         if (journal.key != null) {
 189             for (Key key : journal.key) {
 190                 mExistingKeys.add(keyToBackupKey(key));
 191             }
 192         }
 193         restoredBackupVersion = journal.backupVersion;
 194     }
 195 
 196     /**
 197      * Back up launcher data so we can restore the user&#x27;s state on a new device.
 198      *
 199      * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 200      *
 201      * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 202      *
 203      * @param oldState notes from the last backup
 204      * @param data incremental key/value pairs to persist off-device
 205      * @param newState notes for the next backup
 206      */
 207     @Override
 208     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 209             ParcelFileDescriptor newState) {
 210         if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 211 
 212         Journal in = readJournal(oldState);
 213         if (!launcherIsReady()) {
 214             dataChanged();
 215             // Perform backup later.
 216             writeJournal(newState, in);
 217             return;
 218         }
 219 
 220         if (mDeviceProfileData == null) {
 221             LauncherAppState app = LauncherAppState.getInstance();
 222             mIdp = app.getInvariantDeviceProfile();
 223             mDeviceProfileData = initDeviceProfileData(mIdp);
 224             mIconCache = app.getIconCache();
 225         }
 226 
 227         Log.v(TAG, &quot;lastBackupTime = &quot; + in.t);
 228         mKeys.clear();
 229         applyJournal(in);
 230 
 231         // Record the time before performing backup so that entries edited while the backup
 232         // was going on, do not get missed in next backup.
 233         long newBackupTime = System.currentTimeMillis();
 234         mBackupDataWasUpdated = false;
 235         try {
 236             backupFavorites(data);
 237             backupScreens(data);
 238             backupIcons(data);
 239             backupWidgets(data);
 240 
 241             // Delete any key which still exist in the old backup, but is not valid anymore.
 242             HashSet&lt;String&gt; validKeys = new HashSet&lt;String&gt;();
 243             for (Key key : mKeys) {
 244                 validKeys.add(keyToBackupKey(key));
 245             }
 246             mExistingKeys.removeAll(validKeys);
 247 
 248             // Delete anything left in the existing keys.
 249             for (String deleted: mExistingKeys) {
 250                 if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
 251                 data.writeEntityHeader(deleted, -1);
 252                 mBackupDataWasUpdated = true;
 253             }
 254 
 255             mExistingKeys.clear();
 256             if (!mBackupDataWasUpdated) {
 257                 // Check if any metadata has changed
 258                 mBackupDataWasUpdated = (in.profile == null)
 259                         || !Arrays.equals(DeviceProfieData.toByteArray(in.profile),
 260                             DeviceProfieData.toByteArray(mDeviceProfileData))
 261                         || (in.backupVersion != BACKUP_VERSION)
 262                         || (in.appVersion != getAppVersion());
 263             }
 264 
 265             if (mBackupDataWasUpdated) {
 266                 mLastBackupRestoreTime = newBackupTime;
 267 
 268                 // We store the journal at two places.
 269                 //   1) Storing it in newState allows us to do partial backups by comparing old state
 270                 //   2) Storing it in backup data allows us to validate keys during restore
 271                 Journal state = getCurrentStateJournal();
 272                 writeRowToBackup(JOURNAL_KEY, state, data);
 273             } else {
 274                 if (DEBUG) Log.d(TAG, &quot;Nothing was written during backup&quot;);
 275             }
 276         } catch (IOException e) {
 277             Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 278         }
 279 
 280         writeNewStateDescription(newState);
 281     }
 282 
 283     /**
 284      * @return true if the backup corresponding to oldstate can be successfully applied
 285      * to this device.
 286      */
 287     private boolean isBackupCompatible(Journal oldState) {
 288         DeviceProfieData currentProfile = mDeviceProfileData;
 289         DeviceProfieData oldProfile = oldState.profile;
 290 
 291         if (oldProfile == null || oldProfile.desktopCols == 0) {
 292             // Profile info is not valid, ignore the check.
 293             return true;
 294         }
 295 
 296         boolean isHotseatCompatible = false;
 297         if (currentProfile.allappsRank &gt;= oldProfile.hotseatCount) {
 298             isHotseatCompatible = true;
 299             mHotseatShift = 0;
 300         }
 301 
 302 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 303         if ((currentProfile.allappsRank &gt;= oldProfile.allappsRank)</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 304                 &amp;&amp; ((currentProfile.hotseatCount - currentProfile.allappsRank) &gt;=</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 305                         (oldProfile.hotseatCount - oldProfile.allappsRank))) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 306             // There is enough space on both sides of the hotseat.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 307             isHotseatCompatible = true;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 308             mHotseatShift = currentProfile.allappsRank - oldProfile.allappsRank;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 309         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 310 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 311         if (!isHotseatCompatible) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 312             return false;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 313         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 314         if ((currentProfile.desktopCols &gt;= oldProfile.desktopCols)</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 315                 &amp;&amp; (currentProfile.desktopRows &gt;= oldProfile.desktopRows)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 316             return true;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 317         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 318 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 319         if (MigrateFromRestoreTask.ENABLED &amp;&amp;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 320                 (oldProfile.desktopCols - currentProfile.desktopCols &lt;= 1) &amp;&amp;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 321                 (oldProfile.desktopRows - currentProfile.desktopRows &lt;= 1)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 322             // Allow desktop migration when row and/or column count contracts by 1.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 323 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 324             migrationCompatibleProfileData = initDeviceProfileData(mIdp);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 325             migrationCompatibleProfileData.desktopCols = oldProfile.desktopCols;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 326             migrationCompatibleProfileData.desktopRows = oldProfile.desktopRows;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 327             return true;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 328         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 329         return false;</span>
 330 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 331 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 332         return isHotsetCompatible &amp;&amp; (currentProfile.desktopCols &gt;= oldProfile.desktopCols)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 333                 &amp;&amp; (currentProfile.desktopRows &gt;= oldProfile.desktopRows);</span>
 334 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 335         out.key = keys.toArray(BackupProtos.Key.emptyArray());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 336         writeJournal(newState, out);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 337         Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);</span>
 338 &gt;&gt;&gt;&gt;&gt;&gt;&gt; THEIRS
 339     }
 340 
 341     /**
 342      * Restore launcher configuration from the restored data stream.
 343      * It assumes that the keys will arrive in lexical order. So if the journal was present in the
 344      * backup, it should arrive first.
 345      *
 346      * @param data the key/value pair from the server
 347      */
 348     @Override
 349     public void restoreEntity(BackupDataInputStream data) {
 350         if (!restoreSuccessful) {
 351             return;
 352         }
 353 
 354         int dataSize = data.size();
 355         if (mBuffer.length &lt; dataSize) {
 356             mBuffer = new byte[dataSize];
 357         }
 358         try {
 359             int bytesRead = data.read(mBuffer, 0, dataSize);
 360             if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 361             String backupKey = data.getKey();
 362 
 363             if (JOURNAL_KEY.equals(backupKey)) {
 364                 if (VERBOSE) Log.v(TAG, &quot;Journal entry restored&quot;);
 365                 if (!mKeys.isEmpty()) {
 366                     // We received the journal key after a restore key.
 367                     Log.wtf(TAG, keyToBackupKey(mKeys.get(0)) + &quot; received after &quot; + JOURNAL_KEY);
 368                     restoreSuccessful = false;
 369                     return;
 370                 }
 371 
 372                 Journal journal = new Journal();
 373                 MessageNano.mergeFrom(journal, readCheckedBytes(mBuffer, dataSize));
 374                 applyJournal(journal);
 375                 restoreSuccessful = isBackupCompatible(journal);
 376                 return;
 377             }
 378 
 379             if (!mExistingKeys.isEmpty() &amp;&amp; !mExistingKeys.contains(backupKey)) {
 380                 if (DEBUG) Log.e(TAG, &quot;Ignoring key not present in the backup state &quot; + backupKey);
 381                 return;
 382             }
 383             Key key = backupKeyToKey(backupKey);
 384             mKeys.add(key);
 385             switch (key.type) {
 386                 case Key.FAVORITE:
 387                     restoreFavorite(key, mBuffer, dataSize);
 388                     break;
 389 
 390                 case Key.SCREEN:
 391                     restoreScreen(key, mBuffer, dataSize);
 392                     break;
 393 
 394                 case Key.ICON:
 395                     restoreIcon(key, mBuffer, dataSize);
 396                     break;
 397 =======
 398         return isHotsetCompatible &amp;&amp; (currentProfile.desktopCols &gt;= oldProfile.desktopCols)
 399                 &amp;&amp; (currentProfile.desktopRows &gt;= oldProfile.desktopRows);
 400 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 401     }
 402 
 403     /**
 404      * Restore launcher configuration from the restored data stream.
 405      * It assumes that the keys will arrive in lexical order. So if the journal was present in the
 406      * backup, it should arrive first.
 407      *
 408      * @param data the key/value pair from the server
 409      */
 410     @Override
 411     public void restoreEntity(BackupDataInputStream data) {
 412         if (!restoreSuccessful) {
 413             return;
 414         }
 415 
 416         if (mDeviceProfileData == null) {
 417             // This call does not happen on a looper thread. So LauncherAppState
 418             // can&#x27;t be created . Instead initialize required dependencies directly.
 419             mIdp = new InvariantDeviceProfile(mContext);
 420             mDeviceProfileData = initDeviceProfileData(mIdp);
 421             mIconCache = new IconCache(mContext, mIdp);
 422         }
 423 
 424         int dataSize = data.size();
 425         if (mBuffer.length &lt; dataSize) {
 426             mBuffer = new byte[dataSize];
 427         }
 428         try {
 429             int bytesRead = data.read(mBuffer, 0, dataSize);
 430             if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 431             String backupKey = data.getKey();
 432 
 433             if (JOURNAL_KEY.equals(backupKey)) {
 434                 if (VERBOSE) Log.v(TAG, &quot;Journal entry restored&quot;);
 435                 if (!mKeys.isEmpty()) {
 436                     // We received the journal key after a restore key.
 437                     Log.wtf(TAG, keyToBackupKey(mKeys.get(0)) + &quot; received after &quot; + JOURNAL_KEY);
 438                     restoreSuccessful = false;
 439                     return;
 440                 }
 441 
 442                 Journal journal = new Journal();
 443                 MessageNano.mergeFrom(journal, readCheckedBytes(mBuffer, dataSize));
 444                 applyJournal(journal);
 445                 restoreSuccessful = isBackupCompatible(journal);
 446                 return;
 447             }
 448 
 449             if (!mExistingKeys.isEmpty() &amp;&amp; !mExistingKeys.contains(backupKey)) {
 450                 if (DEBUG) Log.e(TAG, &quot;Ignoring key not present in the backup state &quot; + backupKey);
 451                 return;
 452             }
 453             Key key = backupKeyToKey(backupKey);
 454             mKeys.add(key);
 455             switch (key.type) {
 456                 case Key.FAVORITE:
 457                     restoreFavorite(key, mBuffer, dataSize);
 458                     break;
 459 
 460                 case Key.SCREEN:
 461                     restoreScreen(key, mBuffer, dataSize);
 462                     break;
 463 
 464                 case Key.ICON:
 465                     restoreIcon(key, mBuffer, dataSize);
 466                     break;
 467 
 468                 case Key.WIDGET:
 469                     restoreWidget(key, mBuffer, dataSize);
 470                     break;
 471 
 472                 default:
 473                     Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 474                     mKeys.remove(key);
 475                     break;
 476             }
 477         } catch (IOException e) {
 478             Log.w(TAG, &quot;ignoring unparsable backup entry&quot;, e);
 479         }
 480     }
 481 
 482     /**
 483      * Record the restore state for the next backup.
 484      *
 485      * @param newState notes about the backup state after restore.
 486      */
 487     @Override
 488     public void writeNewStateDescription(ParcelFileDescriptor newState) {
 489         writeJournal(newState, getCurrentStateJournal());
 490     }
 491 
 492     private Journal getCurrentStateJournal() {
 493         Journal journal = new Journal();
 494         journal.t = mLastBackupRestoreTime;
 495         journal.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);
 496         journal.appVersion = getAppVersion();
 497         journal.backupVersion = BACKUP_VERSION;
 498         journal.profile = mDeviceProfileData;
 499         return journal;
 500     }
 501 
 502     private int getAppVersion() {
 503         try {
 504             return mContext.getPackageManager()
 505                     .getPackageInfo(mContext.getPackageName(), 0).versionCode;
 506         } catch (NameNotFoundException e) {
 507             return 0;
 508         }
 509     }
 510 
 511 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 512     private DeviceProfieData initDeviceProfileData(InvariantDeviceProfile profile) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 513         DeviceProfieData data = new DeviceProfieData();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 514         data.desktopRows = profile.numRows;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 515         data.desktopCols = profile.numColumns;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 516         data.hotseatCount = profile.numHotseatIcons;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 517         data.allappsRank = profile.hotseatAllAppsRank;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 518         return data;</span>
 519 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 520             return mContext.getPackageManager()</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 521                     .getPackageInfo(mContext.getPackageName(), 0).versionCode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 522         } catch (NameNotFoundException e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 523             return 0;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 524         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 525     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 526 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 527     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 528      * @return the current device profile information.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 529      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 530     private DeviceProfieData getDeviceProfieData() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 531         if (mCurrentProfile != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 532             return mCurrentProfile;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 533         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 534         final Context applicationContext = mContext.getApplicationContext();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 535         DeviceProfile profile = LauncherAppState.createDynamicGrid(applicationContext, null)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 536                 .getDeviceProfile();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 537 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 538         mCurrentProfile = new DeviceProfieData();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 539         mCurrentProfile.desktopRows = profile.numRows;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 540         mCurrentProfile.desktopCols = profile.numColumns;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 541         mCurrentProfile.hotseatCount = profile.numHotseatIcons;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 542         mCurrentProfile.allappsRank = profile.hotseatAllAppsRank;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 543         return mCurrentProfile;</span>
 544 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 545         // clear the output journal time, to force a full backup to</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 546         // will catch any changes the restore process might have made</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 547         Journal out = new Journal();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 548         out.t = 0;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 549         out.key = mKeys.toArray(BackupProtos.Key.emptyArray());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 550         writeJournal(newState, out);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 551         Log.v(TAG, &quot;onRestore: read &quot; + mKeys.size() + &quot; rows&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 552         mKeys.clear();</span>
 553 &gt;&gt;&gt;&gt;&gt;&gt;&gt; THEIRS
 554     }
 555 
 556     /**
 557      * Write all modified favorites to the data stream.
 558      *
 559      * @param data output stream for key/value pairs
 560      * @throws IOException
 561      */
 562     private void backupFavorites(BackupDataOutput data) throws IOException {
 563         // persist things that have changed since the last backup
 564         ContentResolver cr = mContext.getContentResolver();
 565         // Don&#x27;t backup apps in other profiles for now.
 566         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 567                 getUserSelectionArg(), null, null);
 568         try {
 569             cursor.moveToPosition(-1);
 570             while(cursor.moveToNext()) {
 571                 final long id = cursor.getLong(ID_INDEX);
 572                 final long updateTime = cursor.getLong(ID_MODIFIED);
 573                 Key key = getKey(Key.FAVORITE, id);
 574                 mKeys.add(key);
 575                 final String backupKey = keyToBackupKey(key);
 576                 if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 577                     writeRowToBackup(key, packFavorite(cursor), data);
 578                 } else {
 579                     if (DEBUG) Log.d(TAG, &quot;favorite already backup up: &quot; + id);
 580                 }
 581             }
 582         } finally {
 583             cursor.close();
 584         }
 585     }
 586 
 587     /**
 588      * Read a favorite from the stream.
 589      *
 590      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 591      *
 592      * @param key identifier for the row
 593      * @param buffer the serialized proto from the stream, may be larger than dataSize
 594      * @param dataSize the size of the proto from the stream
 595      */
 596     private void restoreFavorite(Key key, byte[] buffer, int dataSize) throws IOException {
 597         if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 598         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 599 =======
 600     /**
 601      * @return the current device profile information.
 602      */
 603     private DeviceProfieData getDeviceProfieData() {
 604         if (mCurrentProfile != null) {
 605             return mCurrentProfile;
 606         }
 607         final Context applicationContext = mContext.getApplicationContext();
 608         DeviceProfile profile = LauncherAppState.createDynamicGrid(applicationContext, null)
 609                 .getDeviceProfile();
 610 
 611         mCurrentProfile = new DeviceProfieData();
 612         mCurrentProfile.desktopRows = profile.numRows;
 613         mCurrentProfile.desktopCols = profile.numColumns;
 614         mCurrentProfile.hotseatCount = profile.numHotseatIcons;
 615         mCurrentProfile.allappsRank = profile.hotseatAllAppsRank;
 616         return mCurrentProfile;
 617 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 618     }
 619 
 620     /**
 621      * Write all modified favorites to the data stream.
 622      *
 623      * @param data output stream for key/value pairs
 624      * @throws IOException
 625      */
 626     private void backupFavorites(BackupDataOutput data) throws IOException {
 627         // persist things that have changed since the last backup
 628         ContentResolver cr = mContext.getContentResolver();
 629         // Don&#x27;t backup apps in other profiles for now.
 630         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 631                 getUserSelectionArg(), null, null);
 632         try {
 633             cursor.moveToPosition(-1);
 634             while(cursor.moveToNext()) {
 635                 final long id = cursor.getLong(ID_INDEX);
 636                 final long updateTime = cursor.getLong(ID_MODIFIED);
 637                 Key key = getKey(Key.FAVORITE, id);
 638                 mKeys.add(key);
 639                 final String backupKey = keyToBackupKey(key);
 640 
 641                 // Favorite proto changed in v4. Backup again if the version is old.
 642                 if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime
 643                         || restoredBackupVersion &lt; 4) {
 644                     writeRowToBackup(key, packFavorite(cursor), data);
 645                 } else {
 646                     if (DEBUG) Log.d(TAG, &quot;favorite already backup up: &quot; + id);
 647                 }
 648             }
 649         } finally {
 650             cursor.close();
 651         }
 652     }
 653 
 654     /**
 655      * Read a favorite from the stream.
 656      *
 657      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 658      *
 659      * @param key identifier for the row
 660      * @param buffer the serialized proto from the stream, may be larger than dataSize
 661      * @param dataSize the size of the proto from the stream
 662      */
 663     private void restoreFavorite(Key key, byte[] buffer, int dataSize) throws IOException {
 664         if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 665         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 666                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 667 
 668         ContentResolver cr = mContext.getContentResolver();
 669         ContentValues values = unpackFavorite(buffer, dataSize);
 670         cr.insert(Favorites.CONTENT_URI, values);
 671     }
 672 
 673     /**
 674      * Write all modified screens to the data stream.
 675      *
 676      * @param data output stream for key/value pairs
 677      * @throws IOException
 678      */
 679     private void backupScreens(BackupDataOutput data) throws IOException {
 680         // persist things that have changed since the last backup
 681         ContentResolver cr = mContext.getContentResolver();
 682         Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 683                 null, null, null);
 684         try {
 685             cursor.moveToPosition(-1);
 686             if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + mLastBackupRestoreTime);
 687             while(cursor.moveToNext()) {
 688                 final long id = cursor.getLong(ID_INDEX);
 689                 final long updateTime = cursor.getLong(ID_MODIFIED);
 690                 Key key = getKey(Key.SCREEN, id);
 691                 mKeys.add(key);
 692                 final String backupKey = keyToBackupKey(key);
 693                 if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 694                     writeRowToBackup(key, packScreen(cursor), data);
 695                 } else {
 696                     if (VERBOSE) Log.v(TAG, &quot;screen already backup up &quot; + id);
 697                 }
 698             }
 699         } finally {
 700             cursor.close();
 701         }
 702     }
 703 
 704     /**
 705      * Read a screen from the stream.
 706      *
 707      * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 708      *
 709      * @param key identifier for the row
 710      * @param buffer the serialized proto from the stream, may be larger than dataSize
 711      * @param dataSize the size of the proto from the stream
 712      */
 713     private void restoreScreen(Key key, byte[] buffer, int dataSize) throws IOException {
 714         if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 715         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 716                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 717 
 718         ContentResolver cr = mContext.getContentResolver();
 719         ContentValues values = unpackScreen(buffer, dataSize);
 720         cr.insert(WorkspaceScreens.CONTENT_URI, values);
 721     }
 722 
 723     /**
 724      * Write all the static icon resources we need to render placeholders
 725      * for a package that is not installed.
 726      *
 727      * @param data output stream for key/value pairs
 728      */
 729     private void backupIcons(BackupDataOutput data) throws IOException {
 730         // persist icons that haven&#x27;t been persisted yet
 731         final ContentResolver cr = mContext.getContentResolver();
 732         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 733         final UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 734         int backupUpIconCount = 0;
 735 
 736         // Don&#x27;t backup apps in other profiles for now.
 737         String where = &quot;(&quot; + Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION + &quot; OR &quot; +
 738                 Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_SHORTCUT + &quot;) AND &quot; +
 739                 getUserSelectionArg();
 740         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 741                 where, null, null);
 742         try {
 743             cursor.moveToPosition(-1);
 744             while(cursor.moveToNext()) {
 745                 final long id = cursor.getLong(ID_INDEX);
 746                 final String intentDescription = cursor.getString(INTENT_INDEX);
 747                 try {
 748                     Intent intent = Intent.parseUri(intentDescription, 0);
 749                     ComponentName cn = intent.getComponent();
 750                     Key key = null;
 751                     String backupKey = null;
 752                     if (cn != null) {
 753                         key = getKey(Key.ICON, cn.flattenToShortString());
 754                         backupKey = keyToBackupKey(key);
 755                     } else {
 756                         Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 757                     }
 758                     if (mExistingKeys.contains(backupKey)) {
 759                         if (DEBUG) Log.d(TAG, &quot;already saved icon &quot; + backupKey);
 760 
 761                         // remember that we already backed this up previously
 762                         mKeys.add(key);
 763                     } else if (backupKey != null) {
 764                         if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + backupUpIconCount);
 765                         if (backupUpIconCount &lt; MAX_ICONS_PER_PASS) {
 766                             if (DEBUG) Log.d(TAG, &quot;saving icon &quot; + backupKey);
 767                             Bitmap icon = mIconCache.getIcon(intent, myUserHandle);
 768                             if (icon != null &amp;&amp; !mIconCache.isDefaultIcon(icon, myUserHandle)) {
 769                                 writeRowToBackup(key, packIcon(dpi, icon), data);
 770                                 mKeys.add(key);
 771                                 backupUpIconCount ++;
 772                             }
 773                         } else {
 774                             if (VERBOSE) Log.v(TAG, &quot;deferring icon backup &quot; + backupKey);
 775                             // too many icons for this pass, request another.
 776                             dataChanged();
 777                         }
 778                     }
 779                 } catch (URISyntaxException e) {
 780                     Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 781                 } catch (IOException e) {
 782                     Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 783                 }
 784 
 785             }
 786         } finally {
 787             cursor.close();
 788         }
 789     }
 790 
 791     /**
 792      * Read an icon from the stream.
 793      *
 794      * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 795      *
 796      * @param key identifier for the row
 797      * @param buffer the serialized proto from the stream, may be larger than dataSize
 798      * @param dataSize the size of the proto from the stream
 799      */
 800     private void restoreIcon(Key key, byte[] buffer, int dataSize) throws IOException {
 801         if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 802         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 803                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 804 
 805         Resource res = unpackProto(new Resource(), buffer, dataSize);
 806         if (DEBUG) {
 807             Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 808         }
 809         Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 810         if (icon == null) {
 811             Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 812         } else {
 813             if (VERBOSE) Log.v(TAG, &quot;saving restored icon as: &quot; + key.name);
 814             mIconCache.preloadIcon(ComponentName.unflattenFromString(key.name), icon, res.dpi,
 815                     &quot;&quot; /* label */, mUserSerial, mIdp);
 816         }
 817     }
 818 
 819     /**
 820      * Write all the static widget resources we need to render placeholders
 821      * for a package that is not installed.
 822      *
 823      * @param data output stream for key/value pairs
 824      * @throws IOException
 825      */
 826     private void backupWidgets(BackupDataOutput data) throws IOException {
 827         // persist static widget info that hasn&#x27;t been persisted yet
 828         final ContentResolver cr = mContext.getContentResolver();
 829         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 830         int backupWidgetCount = 0;
 831 
 832         String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET + &quot; AND &quot;
 833                 + getUserSelectionArg();
 834         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 835                 where, null, null);
 836         try {
 837             cursor.moveToPosition(-1);
 838             while(cursor.moveToNext()) {
 839                 final long id = cursor.getLong(ID_INDEX);
 840                 final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 841                 final ComponentName provider = ComponentName.unflattenFromString(providerName);
 842                 Key key = null;
 843                 String backupKey = null;
 844                 if (provider != null) {
 845                     key = getKey(Key.WIDGET, providerName);
 846                     backupKey = keyToBackupKey(key);
 847                 } else {
 848                     Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 849                 }
 850 
 851                 // Widget backup proto changed in v3. So add it again if the original backup is old.
 852                 if (mExistingKeys.contains(backupKey) &amp;&amp; restoredBackupVersion &gt;= 3) {
 853                     if (DEBUG) Log.d(TAG, &quot;already saved widget &quot; + backupKey);
 854 
 855                     // remember that we already backed this up previously
 856                     mKeys.add(key);
 857                 } else if (backupKey != null) {
 858                     if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + backupWidgetCount);
 859                     if (backupWidgetCount &lt; MAX_WIDGETS_PER_PASS) {
 860                         if (DEBUG) Log.d(TAG, &quot;saving widget &quot; + backupKey);
 861                         UserHandleCompat user = UserHandleCompat.myUserHandle();
 862                         writeRowToBackup(key, packWidget(dpi, provider, user), data);
 863                         mKeys.add(key);
 864                         backupWidgetCount ++;
 865                     } else {
 866                         if (VERBOSE) Log.v(TAG, &quot;deferring widget backup &quot; + backupKey);
 867                         // too many widgets for this pass, request another.
 868                         dataChanged();
 869                     }
 870                 }
 871             }
 872         } finally {
 873             cursor.close();
 874         }
 875     }
 876 
 877     /**
 878      * Read a widget from the stream.
 879      *
 880      * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 881      *
 882      * @param key identifier for the row
 883      * @param buffer the serialized proto from the stream, may be larger than dataSize
 884      * @param dataSize the size of the proto from the stream
 885      */
 886     private void restoreWidget(Key key, byte[] buffer, int dataSize) throws IOException {
 887         if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 888         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 889                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 890         Widget widget = unpackProto(new Widget(), buffer, dataSize);
 891         if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 892         if (widget.icon.data != null)  {
 893             Bitmap icon = BitmapFactory
 894                     .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 895             if (icon == null) {
 896                 Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 897             } else {
 898                 mIconCache.preloadIcon(ComponentName.unflattenFromString(widget.provider),
 899                         icon, widget.icon.dpi, widget.label, mUserSerial, mIdp);
 900             }
 901         }
 902 
 903         // Cache widget min sizes incase migration is required.
 904         widgetSizes.add(widget.provider + &quot;#&quot; + widget.minSpanX + &quot;,&quot; + widget.minSpanY);
 905     }
 906 
 907     /** create a new key, with an integer ID.
 908      *
 909      * &lt;P&gt; Keys contain their own checksum instead of using
 910      * the heavy-weight CheckedMessage wrapper.
 911      */
 912     private Key getKey(int type, long id) {
 913         Key key = new Key();
 914         key.type = type;
 915         key.id = id;
 916         key.checksum = checkKey(key);
 917         return key;
 918     }
 919 
 920     /** create a new key for a named object.
 921      *
 922      * &lt;P&gt; Keys contain their own checksum instead of using
 923      * the heavy-weight CheckedMessage wrapper.
 924      */
 925     private Key getKey(int type, String name) {
 926         Key key = new Key();
 927         key.type = type;
 928         key.name = name;
 929         key.checksum = checkKey(key);
 930         return key;
 931     }
 932 
 933     /** keys need to be strings, serialize and encode. */
 934     private String keyToBackupKey(Key key) {
 935         return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 936     }
 937 
 938     /** keys need to be strings, decode and parse. */
 939     private Key backupKeyToKey(String backupKey) throws InvalidBackupException {
 940         try {
 941             Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 942             if (key.checksum != checkKey(key)) {
 943                 key = null;
 944                 throw new InvalidBackupException(&quot;invalid key read from stream&quot; + backupKey);
 945             }
 946             return key;
 947         } catch (InvalidProtocolBufferNanoException e) {
 948             throw new InvalidBackupException(e);
 949         } catch (IllegalArgumentException e) {
 950             throw new InvalidBackupException(e);
 951         }
 952     }
 953 
 954     /** Compute the checksum over the important bits of a key. */
 955     private long checkKey(Key key) {
 956         CRC32 checksum = new CRC32();
 957         checksum.update(key.type);
 958         checksum.update((int) (key.id &amp; 0xffff));
 959         checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 960         if (!TextUtils.isEmpty(key.name)) {
 961             checksum.update(key.name.getBytes());
 962         }
 963         return checksum.getValue();
 964     }
 965 
 966     /**
 967      * @return true if its an hotseat item, that can be replaced during restore.
 968      * TODO: Extend check for folders in hotseat.
 969      */
 970     private boolean isReplaceableHotseatItem(Favorite favorite) {
 971         return favorite.container == Favorites.CONTAINER_HOTSEAT
 972                 &amp;&amp; favorite.intent != null
 973                 &amp;&amp; (favorite.itemType == Favorites.ITEM_TYPE_APPLICATION
 974                 || favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT);
 975     }
 976 
 977     /** Serialize a Favorite for persistence, including a checksum wrapper. */
 978     private Favorite packFavorite(Cursor c) {
 979         Favorite favorite = new Favorite();
 980         favorite.id = c.getLong(ID_INDEX);
 981         favorite.screen = c.getInt(SCREEN_INDEX);
 982         favorite.container = c.getInt(CONTAINER_INDEX);
 983         favorite.cellX = c.getInt(CELLX_INDEX);
 984         favorite.cellY = c.getInt(CELLY_INDEX);
 985         favorite.spanX = c.getInt(SPANX_INDEX);
 986         favorite.spanY = c.getInt(SPANY_INDEX);
 987         favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 988         favorite.rank = c.getInt(RANK_INDEX);
 989 
 990         String title = c.getString(TITLE_INDEX);
 991         if (!TextUtils.isEmpty(title)) {
 992             favorite.title = title;
 993         }
 994         String intentDescription = c.getString(INTENT_INDEX);
 995         Intent intent = null;
 996         if (!TextUtils.isEmpty(intentDescription)) {
 997             try {
 998                 intent = Intent.parseUri(intentDescription, 0);
 999                 intent.removeExtra(ItemInfo.EXTRA_PROFILE);
1000                 favorite.intent = intent.toUri(0);
1001             } catch (URISyntaxException e) {
1002                 Log.e(TAG, &quot;Invalid intent&quot;, e);
1003             }
1004         }
1005         favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
1006         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
1007             favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
1008             String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
1009             if (!TextUtils.isEmpty(appWidgetProvider)) {
1010                 favorite.appWidgetProvider = appWidgetProvider;
1011             }
1012         } else if (favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT) {
1013             if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
1014                 String iconPackage = c.getString(ICON_PACKAGE_INDEX);
1015                 if (!TextUtils.isEmpty(iconPackage)) {
1016                     favorite.iconPackage = iconPackage;
1017                 }
1018                 String iconResource = c.getString(ICON_RESOURCE_INDEX);
1019                 if (!TextUtils.isEmpty(iconResource)) {
1020                     favorite.iconResource = iconResource;
1021                 }
1022             }
1023 
1024             byte[] blob = c.getBlob(ICON_INDEX);
1025             if (blob != null &amp;&amp; blob.length &gt; 0) {
1026                 favorite.icon = blob;
1027             }
1028         }
1029 
1030         if (isReplaceableHotseatItem(favorite)) {
1031             if (intent != null &amp;&amp; intent.getComponent() != null) {
1032                 PackageManager pm = mContext.getPackageManager();
1033                 ActivityInfo activity = null;;
1034                 try {
1035                     activity = pm.getActivityInfo(intent.getComponent(), 0);
1036                 } catch (NameNotFoundException e) {
1037                     Log.e(TAG, &quot;Target not found&quot;, e);
1038                 }
1039                 if (activity == null) {
1040                     return favorite;
1041                 }
1042                 for (int i = 0; i &lt; mItemTypeMatchers.length; i++) {
1043                     if (mItemTypeMatchers[i] == null) {
1044                         mItemTypeMatchers[i] = new ItemTypeMatcher(
1045                                 CommonAppTypeParser.getResourceForItemType(i));
1046                     }
1047                     if (mItemTypeMatchers[i].matches(activity, pm)) {
1048                         favorite.targetType = i;
1049                         break;
1050                     }
1051                 }
1052             }
1053         }
1054 
1055         return favorite;
1056     }
1057 
1058     /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
1059     private ContentValues unpackFavorite(byte[] buffer, int dataSize)
1060             throws IOException {
1061         Favorite favorite = unpackProto(new Favorite(), buffer, dataSize);
1062 
1063         // If it is a hotseat item, move it accordingly.
1064         if (favorite.container == Favorites.CONTAINER_HOTSEAT) {
1065             favorite.screen += mHotseatShift;
1066         }
1067 
1068         ContentValues values = new ContentValues();
1069         values.put(Favorites._ID, favorite.id);
1070         values.put(Favorites.SCREEN, favorite.screen);
1071         values.put(Favorites.CONTAINER, favorite.container);
1072         values.put(Favorites.CELLX, favorite.cellX);
1073         values.put(Favorites.CELLY, favorite.cellY);
1074         values.put(Favorites.SPANX, favorite.spanX);
1075         values.put(Favorites.SPANY, favorite.spanY);
1076         values.put(Favorites.RANK, favorite.rank);
1077 
1078         if (favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT) {
1079             values.put(Favorites.ICON_TYPE, favorite.iconType);
1080             if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
1081                 values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
1082                 values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
1083             }
1084             values.put(Favorites.ICON, favorite.icon);
1085         }
1086 
1087         if (!TextUtils.isEmpty(favorite.title)) {
1088             values.put(Favorites.TITLE, favorite.title);
1089         } else {
1090             values.put(Favorites.TITLE, &quot;&quot;);
1091         }
1092         if (!TextUtils.isEmpty(favorite.intent)) {
1093             values.put(Favorites.INTENT, favorite.intent);
1094         }
1095         values.put(Favorites.ITEM_TYPE, favorite.itemType);
1096 
1097         UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
1098         long userSerialNumber =
1099                 UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHandle);
1100         values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
1101 
1102         // If we will attempt grid resize, use the original profile to validate grid size, as
1103         // anything which fits in the original grid should fit in the current grid after
1104         // grid migration.
1105         DeviceProfieData currentProfile = migrationCompatibleProfileData == null
1106                 ? mDeviceProfileData : migrationCompatibleProfileData;
1107 
1108         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
1109             if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
1110                 values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
1111             }
1112             values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
1113             values.put(LauncherSettings.Favorites.RESTORED,
1114                     LauncherAppWidgetInfo.FLAG_ID_NOT_VALID |
1115                     LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY |
1116                     LauncherAppWidgetInfo.FLAG_UI_NOT_READY);
1117 
1118             // Verify placement
1119             if (((favorite.cellX + favorite.spanX) &gt; currentProfile.desktopCols)
1120                     || ((favorite.cellY + favorite.spanY) &gt; currentProfile.desktopRows)) {
1121                 restoreSuccessful = false;
1122                 throw new InvalidBackupException(&quot;Widget not in screen bounds, aborting restore&quot;);
1123             }
1124         } else {
1125             // Check if it is an hotseat item, that can be replaced.
1126             if (isReplaceableHotseatItem(favorite)
1127                     &amp;&amp; favorite.targetType != Favorite.TARGET_NONE
1128                     &amp;&amp; favorite.targetType &lt; CommonAppTypeParser.SUPPORTED_TYPE_COUNT) {
1129                 Log.e(TAG, &quot;Added item type flag&quot;);
1130                 values.put(LauncherSettings.Favorites.RESTORED,
1131                         1 | CommonAppTypeParser.encodeItemTypeToFlag(favorite.targetType));
1132             } else {
1133                 // Let LauncherModel know we&#x27;ve been here.
1134                 values.put(LauncherSettings.Favorites.RESTORED, 1);
1135             }
1136 
1137             // Verify placement
1138             if (favorite.container == Favorites.CONTAINER_HOTSEAT) {
1139                 if ((favorite.screen &gt;= currentProfile.hotseatCount)
1140                         || (favorite.screen == currentProfile.allappsRank)) {
1141                     restoreSuccessful = false;
1142                     throw new InvalidBackupException(&quot;Item not in hotseat bounds, aborting restore&quot;);
1143                 }
1144             } else {
1145                 if ((favorite.cellX &gt;= currentProfile.desktopCols)
1146                         || (favorite.cellY &gt;= currentProfile.desktopRows)) {
1147                     restoreSuccessful = false;
1148                     throw new InvalidBackupException(&quot;Item not in desktop bounds, aborting restore&quot;);
1149                 }
1150             }
1151         }
1152 
1153         return values;
1154     }
1155 
1156     /** Serialize a Screen for persistence, including a checksum wrapper. */
1157     private Screen packScreen(Cursor c) {
1158         Screen screen = new Screen();
1159         screen.id = c.getLong(ID_INDEX);
1160         screen.rank = c.getInt(SCREEN_RANK_INDEX);
1161         return screen;
1162     }
1163 
1164     /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
1165     private ContentValues unpackScreen(byte[] buffer, int dataSize)
1166             throws InvalidProtocolBufferNanoException {
1167         Screen screen = unpackProto(new Screen(), buffer, dataSize);
1168         ContentValues values = new ContentValues();
1169         values.put(WorkspaceScreens._ID, screen.id);
1170         values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
1171         return values;
1172     }
1173 
1174     /** Serialize an icon Resource for persistence, including a checksum wrapper. */
1175     private Resource packIcon(int dpi, Bitmap icon) {
1176         Resource res = new Resource();
1177         res.dpi = dpi;
1178         res.data = Utilities.flattenBitmap(icon);
1179         return res;
1180     }
1181 
1182     /** Serialize a widget for persistence, including a checksum wrapper. */
1183     private Widget packWidget(int dpi, ComponentName provider, UserHandleCompat user) {
1184         final LauncherAppWidgetProviderInfo info =
1185                 LauncherModel.getProviderInfo(mContext, provider, user);
1186         Widget widget = new Widget();
1187         widget.provider = provider.flattenToShortString();
1188         widget.label = info.label;
1189         widget.configure = info.configure != null;
1190         if (info.icon != 0) {
1191             widget.icon = new Resource();
1192             Drawable fullResIcon = mIconCache.getFullResIcon(provider.getPackageName(), info.icon);
1193             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
1194             widget.icon.data = Utilities.flattenBitmap(icon);
1195             widget.icon.dpi = dpi;
1196         }
1197 
1198         Point spans = info.getMinSpans(mIdp, mContext);
1199         widget.minSpanX = spans.x;
1200         widget.minSpanY = spans.y;
1201 
1202         return widget;
1203     }
1204 
1205     /**
1206      * Deserialize a proto after verifying checksum wrapper.
1207      */
1208     private &lt;T extends MessageNano&gt; T unpackProto(T proto, byte[] buffer, int dataSize)
1209             throws InvalidProtocolBufferNanoException {
1210         MessageNano.mergeFrom(proto, readCheckedBytes(buffer, dataSize));
1211         if (DEBUG) Log.d(TAG, &quot;unpacked proto &quot; + proto);
1212         return proto;
1213     }
1214 
1215     /**
1216      * Read the old journal from the input file.
1217      *
1218      * In the event of any error, just pretend we didn&#x27;t have a journal,
1219      * in that case, do a full backup.
1220      *
1221      * @param oldState the read-0only file descriptor pointing to the old journal
1222      * @return a Journal protocol buffer
1223      */
1224     private Journal readJournal(ParcelFileDescriptor oldState) {
1225         Journal journal = new Journal();
1226         if (oldState == null) {
1227             return journal;
1228         }
1229         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
1230         try {
1231             int availableBytes = inStream.available();
1232             if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
1233             if (availableBytes &lt; MAX_JOURNAL_SIZE) {
1234                 byte[] buffer = new byte[availableBytes];
1235                 int bytesRead = 0;
1236                 boolean valid = false;
1237                 InvalidProtocolBufferNanoException lastProtoException = null;
1238                 while (availableBytes &gt; 0) {
1239                     try {
1240                         // OMG what are you doing? This is crazy inefficient!
1241                         // If we read a byte that is not ours, we will cause trouble: b/12491813
1242                         // However, we don&#x27;t know how many bytes to expect (oops).
1243                         // So we have to step through *slowly*, watching for the end.
1244                         int result = inStream.read(buffer, bytesRead, 1);
1245                         if (result &gt; 0) {
1246                             availableBytes -= result;
1247                             bytesRead += result;
1248                         } else {
1249                             Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1250                             // stop reading and see what there is to parse
1251                             availableBytes = 0;
1252                         }
1253                     } catch (IOException e) {
1254                         buffer = null;
1255                         availableBytes = 0;
1256                     }
1257 
1258                     // check the buffer to see if we have a valid journal
1259                     try {
1260                         MessageNano.mergeFrom(journal, readCheckedBytes(buffer, bytesRead));
1261                         // if we are here, then we have read a valid, checksum-verified journal
1262                         valid = true;
1263                         availableBytes = 0;
1264                         if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1265                     } catch (InvalidProtocolBufferNanoException e) {
1266                         // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1267                         lastProtoException = e;
1268                         journal.clear();
1269                     }
1270                 }
1271                 if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1272                 if (!valid) {
1273                     Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1274                 }
1275             }
1276         } catch (IOException e) {
1277             Log.w(TAG, &quot;failed to close the journal&quot;, e);
1278         } finally {
1279             try {
1280                 inStream.close();
1281             } catch (IOException e) {
1282                 Log.w(TAG, &quot;failed to close the journal&quot;, e);
1283             }
1284         }
1285         return journal;
1286     }
1287 
1288     private void writeRowToBackup(Key key, MessageNano proto, BackupDataOutput data)
1289             throws IOException {
1290         writeRowToBackup(keyToBackupKey(key), proto, data);
1291     }
1292 
1293     private void writeRowToBackup(String backupKey, MessageNano proto,
1294             BackupDataOutput data) throws IOException {
1295         byte[] blob = writeCheckedBytes(proto);
1296         data.writeEntityHeader(backupKey, blob.length);
1297         data.writeEntityData(blob, blob.length);
1298         mBackupDataWasUpdated = true;
1299         if (VERBOSE) Log.v(TAG, &quot;Writing New entry &quot; + backupKey);
1300     }
1301 
1302     /**
1303      * Write the new journal to the output file.
1304      *
1305      * In the event of any error, just pretend we didn&#x27;t have a journal,
1306      * in that case, do a full backup.
1307 
1308      * @param newState the write-only file descriptor pointing to the new journal
1309      * @param journal a Journal protocol buffer
1310      */
1311     private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1312         FileOutputStream outStream = null;
1313         try {
1314             outStream = new FileOutputStream(newState.getFileDescriptor());
1315             final byte[] journalBytes = writeCheckedBytes(journal);
1316             outStream.write(journalBytes);
1317             outStream.close();
1318             if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1319         } catch (IOException e) {
1320             Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1321         }
1322     }
1323 
1324     /** Wrap a proto in a CheckedMessage and compute the checksum. */
1325     private byte[] writeCheckedBytes(MessageNano proto) {
1326         CheckedMessage wrapper = new CheckedMessage();
1327         wrapper.payload = MessageNano.toByteArray(proto);
1328         CRC32 checksum = new CRC32();
1329         checksum.update(wrapper.payload);
1330         wrapper.checksum = checksum.getValue();
1331         return MessageNano.toByteArray(wrapper);
1332     }
1333 
1334     /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1335     private static byte[] readCheckedBytes(byte[] buffer, int dataSize)
1336             throws InvalidProtocolBufferNanoException {
1337         CheckedMessage wrapper = new CheckedMessage();
1338         MessageNano.mergeFrom(wrapper, buffer, 0, dataSize);
1339         CRC32 checksum = new CRC32();
1340         checksum.update(wrapper.payload);
1341         if (wrapper.checksum != checksum.getValue()) {
1342             throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1343         }
1344         return wrapper.payload;
1345     }
1346 
1347     /**
1348      * @return true if the launcher is in a state to support backup
1349      */
1350     private boolean launcherIsReady() {
1351         ContentResolver cr = mContext.getContentResolver();
1352         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);
1353         if (cursor == null) {
1354             // launcher data has been wiped, do nothing
1355             return false;
1356         }
1357         cursor.close();
1358 
1359         if (LauncherAppState.getInstanceNoCreate() == null) {
1360             // launcher services are unavailable, try again later
1361             return false;
1362         }
1363 
1364         return true;
1365     }
1366 
1367     private String getUserSelectionArg() {
1368         return Favorites.PROFILE_ID + &#x27;=&#x27; + UserManagerCompat.getInstance(mContext)
1369                 .getSerialNumberForUser(UserHandleCompat.myUserHandle());
1370     }
1371 
1372     @Thunk class InvalidBackupException extends IOException {
1373 
1374         private static final long serialVersionUID = 8931456637211665082L;
1375 
1376         @Thunk InvalidBackupException(Throwable cause) {
1377             super(cause);
1378         }
1379 
1380         @Thunk InvalidBackupException(String reason) {
1381             super(reason);
1382         }
1383     }
1384 
1385     public boolean shouldAttemptWorkspaceMigration() {
1386         return migrationCompatibleProfileData != null;
1387     }
1388 
1389     /**
1390      * A class to check if an activity can handle one of the intents from a list of
1391      * predefined intents.
1392      */
1393     private class ItemTypeMatcher {
1394 
1395         private final ArrayList&lt;Intent&gt; mIntents;
1396 
1397         ItemTypeMatcher(int xml_res) {
1398             mIntents = xml_res == 0 ? new ArrayList&lt;Intent&gt;() : parseIntents(xml_res);
1399         }
1400 
1401         private ArrayList&lt;Intent&gt; parseIntents(int xml_res) {
1402             ArrayList&lt;Intent&gt; intents = new ArrayList&lt;Intent&gt;();
1403             XmlResourceParser parser = mContext.getResources().getXml(xml_res);
1404             try {
1405                 DefaultLayoutParser.beginDocument(parser, DefaultLayoutParser.TAG_RESOLVE);
1406                 final int depth = parser.getDepth();
1407                 int type;
1408                 while (((type = parser.next()) != XmlPullParser.END_TAG ||
1409                         parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {
1410                     if (type != XmlPullParser.START_TAG) {
1411                         continue;
1412                     } else if (DefaultLayoutParser.TAG_FAVORITE.equals(parser.getName())) {
1413                         final String uri = DefaultLayoutParser.getAttributeValue(
1414                                 parser, DefaultLayoutParser.ATTR_URI);
1415                         intents.add(Intent.parseUri(uri, 0));
1416                     }
1417                 }
1418             } catch (URISyntaxException | XmlPullParserException | IOException e) {
1419                 Log.e(TAG, &quot;Unable to parse &quot; + xml_res, e);
1420             } finally {
1421                 parser.close();
1422             }
1423             return intents;
1424         }
1425 
1426         public boolean matches(ActivityInfo activity, PackageManager pm) {
1427             for (Intent intent : mIntents) {
1428                 intent.setPackage(activity.packageName);
1429                 ResolveInfo info = pm.resolveActivity(intent, 0);
1430                 if (info != null &amp;&amp; (info.activityInfo.name.equals(activity.name)
1431                         || info.activityInfo.name.equals(activity.targetActivity))) {
1432                     return true;
1433                 }
1434             }
1435             return false;
1436         }
1437     }
1438 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.app.backup.BackupDataInputStream;
  19 import android.app.backup.BackupDataOutput;
  20 import android.app.backup.BackupHelper;
  21 import android.app.backup.BackupManager;
  22 import android.content.ComponentName;
  23 import android.content.ContentResolver;
  24 import android.content.ContentValues;
  25 import android.content.Context;
  26 import android.content.Intent;
  27 import android.content.pm.ActivityInfo;
  28 import android.content.pm.PackageManager;
  29 import android.content.pm.PackageManager.NameNotFoundException;
  30 import android.content.pm.ResolveInfo;
  31 import android.content.res.XmlResourceParser;
  32 import android.database.Cursor;
  33 import android.graphics.Bitmap;
  34 import android.graphics.BitmapFactory;
  35 import android.graphics.Point;
  36 import android.graphics.drawable.Drawable;
  37 import android.os.ParcelFileDescriptor;
  38 import android.text.TextUtils;
  39 import android.util.Base64;
  40 import android.util.Log;
  41 
  42 import com.android.launcher3.LauncherSettings.Favorites;
  43 import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  44 import com.android.launcher3.backup.BackupProtos;
  45 import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  46 import com.android.launcher3.backup.BackupProtos.DeviceProfieData;
  47 import com.android.launcher3.backup.BackupProtos.Favorite;
  48 import com.android.launcher3.backup.BackupProtos.Journal;
  49 import com.android.launcher3.backup.BackupProtos.Key;
  50 import com.android.launcher3.backup.BackupProtos.Resource;
  51 import com.android.launcher3.backup.BackupProtos.Screen;
  52 import com.android.launcher3.backup.BackupProtos.Widget;
  53 import com.android.launcher3.compat.UserHandleCompat;
  54 import com.android.launcher3.compat.UserManagerCompat;
  55 import com.android.launcher3.model.MigrateFromRestoreTask;
  56 import com.android.launcher3.util.Thunk;
  57 import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  58 import com.google.protobuf.nano.MessageNano;
  59 
  60 import org.xmlpull.v1.XmlPullParser;
  61 import org.xmlpull.v1.XmlPullParserException;
  62 
  63 import java.io.FileInputStream;
  64 import java.io.FileOutputStream;
  65 import java.io.IOException;
  66 import java.net.URISyntaxException;
  67 import java.util.ArrayList;
  68 import java.util.Arrays;
  69 import java.util.HashSet;
  70 import java.util.zip.CRC32;
  71 
  72 /**
  73  * Persist the launcher home state across calamities.
  74  */
  75 public class LauncherBackupHelper implements BackupHelper {
  76     private static final String TAG = &quot;LauncherBackupHelper&quot;;
  77     private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  78     private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  79 
  80     private static final int BACKUP_VERSION = 4;
  81     private static final int MAX_JOURNAL_SIZE = 1000000;
  82 
  83     // Journal key is such that it is always smaller than any dynamically generated
  84     // key (any Base64 encoded string).
  85     private static final String JOURNAL_KEY = &quot;#&quot;;
  86 
  87     /** icons are large, dribble them out */
  88     private static final int MAX_ICONS_PER_PASS = 10;
  89 
  90     /** widgets contain previews, which are very large, dribble them out */
  91     private static final int MAX_WIDGETS_PER_PASS = 5;
  92 
  93     private static final String[] FAVORITE_PROJECTION = {
  94         Favorites._ID,                     // 0
  95         Favorites.MODIFIED,                // 1
  96         Favorites.INTENT,                  // 2
  97         Favorites.APPWIDGET_PROVIDER,      // 3
  98         Favorites.APPWIDGET_ID,            // 4
  99         Favorites.CELLX,                   // 5
 100         Favorites.CELLY,                   // 6
 101         Favorites.CONTAINER,               // 7
 102         Favorites.ICON,                    // 8
 103         Favorites.ICON_PACKAGE,            // 9
 104         Favorites.ICON_RESOURCE,           // 10
 105         Favorites.ICON_TYPE,               // 11
 106         Favorites.ITEM_TYPE,               // 12
 107         Favorites.SCREEN,                  // 13
 108         Favorites.SPANX,                   // 14
 109         Favorites.SPANY,                   // 15
 110         Favorites.TITLE,                   // 16
 111         Favorites.PROFILE_ID,              // 17
 112         Favorites.RANK,                    // 18
 113     };
 114 
 115     private static final int ID_INDEX = 0;
 116     private static final int ID_MODIFIED = 1;
 117     private static final int INTENT_INDEX = 2;
 118     private static final int APPWIDGET_PROVIDER_INDEX = 3;
 119     private static final int APPWIDGET_ID_INDEX = 4;
 120     private static final int CELLX_INDEX = 5;
 121     private static final int CELLY_INDEX = 6;
 122     private static final int CONTAINER_INDEX = 7;
 123     private static final int ICON_INDEX = 8;
 124     private static final int ICON_PACKAGE_INDEX = 9;
 125     private static final int ICON_RESOURCE_INDEX = 10;
 126     private static final int ICON_TYPE_INDEX = 11;
 127     private static final int ITEM_TYPE_INDEX = 12;
 128     private static final int SCREEN_INDEX = 13;
 129     private static final int SPANX_INDEX = 14;
 130     private static final int SPANY_INDEX = 15;
 131     private static final int TITLE_INDEX = 16;
 132     private static final int RANK_INDEX = 18;
 133 
 134     private static final String[] SCREEN_PROJECTION = {
 135         WorkspaceScreens._ID,              // 0
 136         WorkspaceScreens.MODIFIED,         // 1
 137         WorkspaceScreens.SCREEN_RANK       // 2
 138     };
 139 
 140     private static final int SCREEN_RANK_INDEX = 2;
 141 
 142     @Thunk final Context mContext;
 143     private final HashSet&lt;String&gt; mExistingKeys;
 144     private final ArrayList&lt;Key&gt; mKeys;
 145     private final ItemTypeMatcher[] mItemTypeMatchers;
 146     private final long mUserSerial;
 147 
 148     private BackupManager mBackupManager;
 149     private byte[] mBuffer = new byte[512];
 150     private long mLastBackupRestoreTime;
 151     private boolean mBackupDataWasUpdated;
 152 
 153     private IconCache mIconCache;
 154     private DeviceProfieData mDeviceProfileData;
 155     private InvariantDeviceProfile mIdp;
 156 
 157     DeviceProfieData migrationCompatibleProfileData;
 158     HashSet&lt;String&gt; widgetSizes = new HashSet&lt;&gt;();
 159 
 160     boolean restoreSuccessful;
 161     int restoredBackupVersion = 1;
 162 
 163     // When migrating from a device which different hotseat configuration, the icons are shifted
 164     // to center along the new all-apps icon.
 165     private int mHotseatShift = 0;
 166 
 167     public LauncherBackupHelper(Context context) {
 168         mContext = context;
 169         mExistingKeys = new HashSet&lt;String&gt;();
 170         mKeys = new ArrayList&lt;Key&gt;();
 171         restoreSuccessful = true;
 172         mItemTypeMatchers = new ItemTypeMatcher[CommonAppTypeParser.SUPPORTED_TYPE_COUNT];
 173 
 174         UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 175         mUserSerial = userManager.getSerialNumberForUser(UserHandleCompat.myUserHandle());
 176     }
 177 
 178     private void dataChanged() {
 179         if (mBackupManager == null) {
 180             mBackupManager = new BackupManager(mContext);
 181         }
 182         mBackupManager.dataChanged();
 183     }
 184 
 185     private void applyJournal(Journal journal) {
 186         mLastBackupRestoreTime = journal.t;
 187         mExistingKeys.clear();
 188         if (journal.key != null) {
 189             for (Key key : journal.key) {
 190                 mExistingKeys.add(keyToBackupKey(key));
 191             }
 192         }
 193         restoredBackupVersion = journal.backupVersion;
 194     }
 195 
 196     /**
 197      * Back up launcher data so we can restore the user&#x27;s state on a new device.
 198      *
 199      * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 200      *
 201      * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 202      *
 203      * @param oldState notes from the last backup
 204      * @param data incremental key/value pairs to persist off-device
 205      * @param newState notes for the next backup
 206      */
 207     @Override
 208     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 209             ParcelFileDescriptor newState) {
 210         if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 211 
 212         Journal in = readJournal(oldState);
 213         if (!launcherIsReady()) {
 214             dataChanged();
 215             // Perform backup later.
 216             writeJournal(newState, in);
 217             return;
 218         }
 219 
 220         if (mDeviceProfileData == null) {
 221             LauncherAppState app = LauncherAppState.getInstance();
 222             mIdp = app.getInvariantDeviceProfile();
 223             mDeviceProfileData = initDeviceProfileData(mIdp);
 224             mIconCache = app.getIconCache();
 225         }
 226 
 227         Log.v(TAG, &quot;lastBackupTime = &quot; + in.t);
 228         mKeys.clear();
 229         applyJournal(in);
 230 
 231         // Record the time before performing backup so that entries edited while the backup
 232         // was going on, do not get missed in next backup.
 233         long newBackupTime = System.currentTimeMillis();
 234         mBackupDataWasUpdated = false;
 235         try {
 236             backupFavorites(data);
 237             backupScreens(data);
 238             backupIcons(data);
 239             backupWidgets(data);
 240 
 241             // Delete any key which still exist in the old backup, but is not valid anymore.
 242             HashSet&lt;String&gt; validKeys = new HashSet&lt;String&gt;();
 243             for (Key key : mKeys) {
 244                 validKeys.add(keyToBackupKey(key));
 245             }
 246             mExistingKeys.removeAll(validKeys);
 247 
 248             // Delete anything left in the existing keys.
 249             for (String deleted: mExistingKeys) {
 250                 if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
 251                 data.writeEntityHeader(deleted, -1);
 252                 mBackupDataWasUpdated = true;
 253             }
 254 
 255             mExistingKeys.clear();
 256             if (!mBackupDataWasUpdated) {
 257                 // Check if any metadata has changed
 258                 mBackupDataWasUpdated = (in.profile == null)
 259                         || !Arrays.equals(DeviceProfieData.toByteArray(in.profile),
 260                             DeviceProfieData.toByteArray(mDeviceProfileData))
 261                         || (in.backupVersion != BACKUP_VERSION)
 262                         || (in.appVersion != getAppVersion());
 263             }
 264 
 265             if (mBackupDataWasUpdated) {
 266                 mLastBackupRestoreTime = newBackupTime;
 267 
 268                 // We store the journal at two places.
 269                 //   1) Storing it in newState allows us to do partial backups by comparing old state
 270                 //   2) Storing it in backup data allows us to validate keys during restore
 271                 Journal state = getCurrentStateJournal();
 272                 writeRowToBackup(JOURNAL_KEY, state, data);
 273             } else {
 274                 if (DEBUG) Log.d(TAG, &quot;Nothing was written during backup&quot;);
 275             }
 276         } catch (IOException e) {
 277             Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 278         }
 279 
 280         writeNewStateDescription(newState);
 281     }
 282 
 283     /**
 284      * @return true if the backup corresponding to oldstate can be successfully applied
 285      * to this device.
 286      */
 287     private boolean isBackupCompatible(Journal oldState) {
 288         DeviceProfieData currentProfile = mDeviceProfileData;
 289         DeviceProfieData oldProfile = oldState.profile;
 290 
 291         if (oldProfile == null || oldProfile.desktopCols == 0) {
 292             // Profile info is not valid, ignore the check.
 293             return true;
 294         }
 295 
 296         boolean isHotseatCompatible = false;
 297         if (currentProfile.allappsRank &gt;= oldProfile.hotseatCount) {
 298             isHotseatCompatible = true;
 299             mHotseatShift = 0;
 300         }
 301 
 302         if ((currentProfile.allappsRank &gt;= oldProfile.allappsRank)
 303                 &amp;&amp; ((currentProfile.hotseatCount - currentProfile.allappsRank) &gt;=
 304                         (oldProfile.hotseatCount - oldProfile.allappsRank))) {
 305             // There is enough space on both sides of the hotseat.
 306             isHotseatCompatible = true;
 307             mHotseatShift = currentProfile.allappsRank - oldProfile.allappsRank;
 308         }
 309 
 310         if (!isHotseatCompatible) {
 311             return false;
 312         }
 313         if ((currentProfile.desktopCols &gt;= oldProfile.desktopCols)
 314                 &amp;&amp; (currentProfile.desktopRows &gt;= oldProfile.desktopRows)) {
 315             return true;
 316         }
 317 
 318         if (MigrateFromRestoreTask.ENABLED &amp;&amp;
 319                 (oldProfile.desktopCols - currentProfile.desktopCols &lt;= 1) &amp;&amp;
 320                 (oldProfile.desktopRows - currentProfile.desktopRows &lt;= 1)) {
 321             // Allow desktop migration when row and/or column count contracts by 1.
 322 
 323             migrationCompatibleProfileData = initDeviceProfileData(mIdp);
 324             migrationCompatibleProfileData.desktopCols = oldProfile.desktopCols;
 325             migrationCompatibleProfileData.desktopRows = oldProfile.desktopRows;
 326             return true;
 327         }
 328         return false;
 329     }
 330 
 331     /**
 332      * Restore launcher configuration from the restored data stream.
 333      * It assumes that the keys will arrive in lexical order. So if the journal was present in the
 334      * backup, it should arrive first.
 335      *
 336      * @param data the key/value pair from the server
 337      */
 338     @Override
 339     public void restoreEntity(BackupDataInputStream data) {
 340         if (!restoreSuccessful) {
 341             return;
 342         }
 343 
 344         if (mDeviceProfileData == null) {
 345             // This call does not happen on a looper thread. So LauncherAppState
 346             // can&#x27;t be created . Instead initialize required dependencies directly.
 347             mIdp = new InvariantDeviceProfile(mContext);
 348             mDeviceProfileData = initDeviceProfileData(mIdp);
 349             mIconCache = new IconCache(mContext, mIdp);
 350         }
 351 
 352         int dataSize = data.size();
 353         if (mBuffer.length &lt; dataSize) {
 354             mBuffer = new byte[dataSize];
 355         }
 356         try {
 357             int bytesRead = data.read(mBuffer, 0, dataSize);
 358             if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 359             String backupKey = data.getKey();
 360 
 361             if (JOURNAL_KEY.equals(backupKey)) {
 362                 if (VERBOSE) Log.v(TAG, &quot;Journal entry restored&quot;);
 363                 if (!mKeys.isEmpty()) {
 364                     // We received the journal key after a restore key.
 365                     Log.wtf(TAG, keyToBackupKey(mKeys.get(0)) + &quot; received after &quot; + JOURNAL_KEY);
 366                     restoreSuccessful = false;
 367                     return;
 368                 }
 369 
 370                 Journal journal = new Journal();
 371                 MessageNano.mergeFrom(journal, readCheckedBytes(mBuffer, dataSize));
 372                 applyJournal(journal);
 373                 restoreSuccessful = isBackupCompatible(journal);
 374                 return;
 375             }
 376 
 377             if (!mExistingKeys.isEmpty() &amp;&amp; !mExistingKeys.contains(backupKey)) {
 378                 if (DEBUG) Log.e(TAG, &quot;Ignoring key not present in the backup state &quot; + backupKey);
 379                 return;
 380             }
 381             Key key = backupKeyToKey(backupKey);
 382             mKeys.add(key);
 383             switch (key.type) {
 384                 case Key.FAVORITE:
 385                     restoreFavorite(key, mBuffer, dataSize);
 386                     break;
 387 
 388                 case Key.SCREEN:
 389                     restoreScreen(key, mBuffer, dataSize);
 390                     break;
 391 
 392                 case Key.ICON:
 393                     restoreIcon(key, mBuffer, dataSize);
 394                     break;
 395 
 396                 case Key.WIDGET:
 397                     restoreWidget(key, mBuffer, dataSize);
 398                     break;
 399 
 400                 default:
 401                     Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 402                     mKeys.remove(key);
 403                     break;
 404             }
 405         } catch (IOException e) {
 406             Log.w(TAG, &quot;ignoring unparsable backup entry&quot;, e);
 407         }
 408     }
 409 
 410     /**
 411      * Record the restore state for the next backup.
 412      *
 413      * @param newState notes about the backup state after restore.
 414      */
 415     @Override
 416     public void writeNewStateDescription(ParcelFileDescriptor newState) {
 417         writeJournal(newState, getCurrentStateJournal());
 418     }
 419 
 420     private Journal getCurrentStateJournal() {
 421         Journal journal = new Journal();
 422         journal.t = mLastBackupRestoreTime;
 423         journal.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);
 424         journal.appVersion = getAppVersion();
 425         journal.backupVersion = BACKUP_VERSION;
 426         journal.profile = mDeviceProfileData;
 427         return journal;
 428     }
 429 
 430     private int getAppVersion() {
 431         try {
 432             return mContext.getPackageManager()
 433                     .getPackageInfo(mContext.getPackageName(), 0).versionCode;
 434         } catch (NameNotFoundException e) {
 435             return 0;
 436         }
 437     }
 438 
 439     private DeviceProfieData initDeviceProfileData(InvariantDeviceProfile profile) {
 440         DeviceProfieData data = new DeviceProfieData();
 441         data.desktopRows = profile.numRows;
 442         data.desktopCols = profile.numColumns;
 443         data.hotseatCount = profile.numHotseatIcons;
 444         data.allappsRank = profile.hotseatAllAppsRank;
 445         return data;
 446     }
 447 
 448     /**
 449      * Write all modified favorites to the data stream.
 450      *
 451      * @param data output stream for key/value pairs
 452      * @throws IOException
 453      */
 454     private void backupFavorites(BackupDataOutput data) throws IOException {
 455         // persist things that have changed since the last backup
 456         ContentResolver cr = mContext.getContentResolver();
 457         // Don&#x27;t backup apps in other profiles for now.
 458         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 459                 getUserSelectionArg(), null, null);
 460         try {
 461             cursor.moveToPosition(-1);
 462             while(cursor.moveToNext()) {
 463                 final long id = cursor.getLong(ID_INDEX);
 464                 final long updateTime = cursor.getLong(ID_MODIFIED);
 465                 Key key = getKey(Key.FAVORITE, id);
 466                 mKeys.add(key);
 467                 final String backupKey = keyToBackupKey(key);
 468 
 469                 // Favorite proto changed in v4. Backup again if the version is old.
 470                 if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime
 471                         || restoredBackupVersion &lt; 4) {
 472                     writeRowToBackup(key, packFavorite(cursor), data);
 473                 } else {
 474                     if (DEBUG) Log.d(TAG, &quot;favorite already backup up: &quot; + id);
 475                 }
 476             }
 477         } finally {
 478             cursor.close();
 479         }
 480     }
 481 
 482     /**
 483      * Read a favorite from the stream.
 484      *
 485      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 486      *
 487      * @param key identifier for the row
 488      * @param buffer the serialized proto from the stream, may be larger than dataSize
 489      * @param dataSize the size of the proto from the stream
 490      */
 491     private void restoreFavorite(Key key, byte[] buffer, int dataSize) throws IOException {
 492         if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 493         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 494                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 495 
 496         ContentResolver cr = mContext.getContentResolver();
 497         ContentValues values = unpackFavorite(buffer, dataSize);
 498         cr.insert(Favorites.CONTENT_URI, values);
 499     }
 500 
 501     /**
 502      * Write all modified screens to the data stream.
 503      *
 504      * @param data output stream for key/value pairs
 505      * @throws IOException
 506      */
 507     private void backupScreens(BackupDataOutput data) throws IOException {
 508         // persist things that have changed since the last backup
 509         ContentResolver cr = mContext.getContentResolver();
 510         Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 511                 null, null, null);
 512         try {
 513             cursor.moveToPosition(-1);
 514             if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + mLastBackupRestoreTime);
 515             while(cursor.moveToNext()) {
 516                 final long id = cursor.getLong(ID_INDEX);
 517                 final long updateTime = cursor.getLong(ID_MODIFIED);
 518                 Key key = getKey(Key.SCREEN, id);
 519                 mKeys.add(key);
 520                 final String backupKey = keyToBackupKey(key);
 521                 if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 522                     writeRowToBackup(key, packScreen(cursor), data);
 523                 } else {
 524                     if (VERBOSE) Log.v(TAG, &quot;screen already backup up &quot; + id);
 525                 }
 526             }
 527         } finally {
 528             cursor.close();
 529         }
 530     }
 531 
 532     /**
 533      * Read a screen from the stream.
 534      *
 535      * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 536      *
 537      * @param key identifier for the row
 538      * @param buffer the serialized proto from the stream, may be larger than dataSize
 539      * @param dataSize the size of the proto from the stream
 540      */
 541     private void restoreScreen(Key key, byte[] buffer, int dataSize) throws IOException {
 542         if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 543         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 544                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 545 
 546         ContentResolver cr = mContext.getContentResolver();
 547         ContentValues values = unpackScreen(buffer, dataSize);
 548         cr.insert(WorkspaceScreens.CONTENT_URI, values);
 549     }
 550 
 551     /**
 552      * Write all the static icon resources we need to render placeholders
 553      * for a package that is not installed.
 554      *
 555      * @param data output stream for key/value pairs
 556      */
 557     private void backupIcons(BackupDataOutput data) throws IOException {
 558         // persist icons that haven&#x27;t been persisted yet
 559         final ContentResolver cr = mContext.getContentResolver();
 560         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 561         final UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 562         int backupUpIconCount = 0;
 563 
 564         // Don&#x27;t backup apps in other profiles for now.
 565         String where = &quot;(&quot; + Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION + &quot; OR &quot; +
 566                 Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_SHORTCUT + &quot;) AND &quot; +
 567                 getUserSelectionArg();
 568         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 569                 where, null, null);
 570         try {
 571             cursor.moveToPosition(-1);
 572             while(cursor.moveToNext()) {
 573                 final long id = cursor.getLong(ID_INDEX);
 574                 final String intentDescription = cursor.getString(INTENT_INDEX);
 575                 try {
 576                     Intent intent = Intent.parseUri(intentDescription, 0);
 577                     ComponentName cn = intent.getComponent();
 578                     Key key = null;
 579                     String backupKey = null;
 580                     if (cn != null) {
 581                         key = getKey(Key.ICON, cn.flattenToShortString());
 582                         backupKey = keyToBackupKey(key);
 583                     } else {
 584                         Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 585                     }
 586                     if (mExistingKeys.contains(backupKey)) {
 587                         if (DEBUG) Log.d(TAG, &quot;already saved icon &quot; + backupKey);
 588 
 589                         // remember that we already backed this up previously
 590                         mKeys.add(key);
 591                     } else if (backupKey != null) {
 592                         if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + backupUpIconCount);
 593                         if (backupUpIconCount &lt; MAX_ICONS_PER_PASS) {
 594                             if (DEBUG) Log.d(TAG, &quot;saving icon &quot; + backupKey);
 595                             Bitmap icon = mIconCache.getIcon(intent, myUserHandle);
 596                             if (icon != null &amp;&amp; !mIconCache.isDefaultIcon(icon, myUserHandle)) {
 597                                 writeRowToBackup(key, packIcon(dpi, icon), data);
 598                                 mKeys.add(key);
 599                                 backupUpIconCount ++;
 600                             }
 601                         } else {
 602                             if (VERBOSE) Log.v(TAG, &quot;deferring icon backup &quot; + backupKey);
 603                             // too many icons for this pass, request another.
 604                             dataChanged();
 605                         }
 606                     }
 607                 } catch (URISyntaxException e) {
 608                     Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 609                 } catch (IOException e) {
 610                     Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 611                 }
 612 
 613             }
 614         } finally {
 615             cursor.close();
 616         }
 617     }
 618 
 619     /**
 620      * Read an icon from the stream.
 621      *
 622      * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 623      *
 624      * @param key identifier for the row
 625      * @param buffer the serialized proto from the stream, may be larger than dataSize
 626      * @param dataSize the size of the proto from the stream
 627      */
 628     private void restoreIcon(Key key, byte[] buffer, int dataSize) throws IOException {
 629         if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 630         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 631                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 632 
 633         Resource res = unpackProto(new Resource(), buffer, dataSize);
 634         if (DEBUG) {
 635             Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 636         }
 637         Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 638         if (icon == null) {
 639             Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 640         } else {
 641             if (VERBOSE) Log.v(TAG, &quot;saving restored icon as: &quot; + key.name);
 642             mIconCache.preloadIcon(ComponentName.unflattenFromString(key.name), icon, res.dpi,
 643                     &quot;&quot; /* label */, mUserSerial, mIdp);
 644         }
 645     }
 646 
 647     /**
 648      * Write all the static widget resources we need to render placeholders
 649      * for a package that is not installed.
 650      *
 651      * @param data output stream for key/value pairs
 652      * @throws IOException
 653      */
 654     private void backupWidgets(BackupDataOutput data) throws IOException {
 655         // persist static widget info that hasn&#x27;t been persisted yet
 656         final ContentResolver cr = mContext.getContentResolver();
 657         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 658         int backupWidgetCount = 0;
 659 
 660         String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET + &quot; AND &quot;
 661                 + getUserSelectionArg();
 662         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 663                 where, null, null);
 664         try {
 665             cursor.moveToPosition(-1);
 666             while(cursor.moveToNext()) {
 667                 final long id = cursor.getLong(ID_INDEX);
 668                 final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 669                 final ComponentName provider = ComponentName.unflattenFromString(providerName);
 670                 Key key = null;
 671                 String backupKey = null;
 672                 if (provider != null) {
 673                     key = getKey(Key.WIDGET, providerName);
 674                     backupKey = keyToBackupKey(key);
 675                 } else {
 676                     Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 677                 }
 678 
 679                 // Widget backup proto changed in v3. So add it again if the original backup is old.
 680                 if (mExistingKeys.contains(backupKey) &amp;&amp; restoredBackupVersion &gt;= 3) {
 681                     if (DEBUG) Log.d(TAG, &quot;already saved widget &quot; + backupKey);
 682 
 683                     // remember that we already backed this up previously
 684                     mKeys.add(key);
 685                 } else if (backupKey != null) {
 686                     if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + backupWidgetCount);
 687                     if (backupWidgetCount &lt; MAX_WIDGETS_PER_PASS) {
 688                         if (DEBUG) Log.d(TAG, &quot;saving widget &quot; + backupKey);
 689                         UserHandleCompat user = UserHandleCompat.myUserHandle();
 690                         writeRowToBackup(key, packWidget(dpi, provider, user), data);
 691                         mKeys.add(key);
 692                         backupWidgetCount ++;
 693                     } else {
 694                         if (VERBOSE) Log.v(TAG, &quot;deferring widget backup &quot; + backupKey);
 695                         // too many widgets for this pass, request another.
 696                         dataChanged();
 697                     }
 698                 }
 699             }
 700         } finally {
 701             cursor.close();
 702         }
 703     }
 704 
 705     /**
 706      * Read a widget from the stream.
 707      *
 708      * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 709      *
 710      * @param key identifier for the row
 711      * @param buffer the serialized proto from the stream, may be larger than dataSize
 712      * @param dataSize the size of the proto from the stream
 713      */
 714     private void restoreWidget(Key key, byte[] buffer, int dataSize) throws IOException {
 715         if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 716         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 717                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 718         Widget widget = unpackProto(new Widget(), buffer, dataSize);
 719         if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 720         if (widget.icon.data != null)  {
 721             Bitmap icon = BitmapFactory
 722                     .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 723             if (icon == null) {
 724                 Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 725             } else {
 726                 mIconCache.preloadIcon(ComponentName.unflattenFromString(widget.provider),
 727                         icon, widget.icon.dpi, widget.label, mUserSerial, mIdp);
 728             }
 729         }
 730 
 731         // Cache widget min sizes incase migration is required.
 732         widgetSizes.add(widget.provider + &quot;#&quot; + widget.minSpanX + &quot;,&quot; + widget.minSpanY);
 733     }
 734 
 735     /** create a new key, with an integer ID.
 736      *
 737      * &lt;P&gt; Keys contain their own checksum instead of using
 738      * the heavy-weight CheckedMessage wrapper.
 739      */
 740     private Key getKey(int type, long id) {
 741         Key key = new Key();
 742         key.type = type;
 743         key.id = id;
 744         key.checksum = checkKey(key);
 745         return key;
 746     }
 747 
 748     /** create a new key for a named object.
 749      *
 750      * &lt;P&gt; Keys contain their own checksum instead of using
 751      * the heavy-weight CheckedMessage wrapper.
 752      */
 753     private Key getKey(int type, String name) {
 754         Key key = new Key();
 755         key.type = type;
 756         key.name = name;
 757         key.checksum = checkKey(key);
 758         return key;
 759     }
 760 
 761     /** keys need to be strings, serialize and encode. */
 762     private String keyToBackupKey(Key key) {
 763         return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 764     }
 765 
 766     /** keys need to be strings, decode and parse. */
 767     private Key backupKeyToKey(String backupKey) throws InvalidBackupException {
 768         try {
 769             Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 770             if (key.checksum != checkKey(key)) {
 771                 key = null;
 772                 throw new InvalidBackupException(&quot;invalid key read from stream&quot; + backupKey);
 773             }
 774             return key;
 775         } catch (InvalidProtocolBufferNanoException e) {
 776             throw new InvalidBackupException(e);
 777         } catch (IllegalArgumentException e) {
 778             throw new InvalidBackupException(e);
 779         }
 780     }
 781 
 782     /** Compute the checksum over the important bits of a key. */
 783     private long checkKey(Key key) {
 784         CRC32 checksum = new CRC32();
 785         checksum.update(key.type);
 786         checksum.update((int) (key.id &amp; 0xffff));
 787         checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 788         if (!TextUtils.isEmpty(key.name)) {
 789             checksum.update(key.name.getBytes());
 790         }
 791         return checksum.getValue();
 792     }
 793 
 794     /**
 795      * @return true if its an hotseat item, that can be replaced during restore.
 796      * TODO: Extend check for folders in hotseat.
 797      */
 798     private boolean isReplaceableHotseatItem(Favorite favorite) {
 799         return favorite.container == Favorites.CONTAINER_HOTSEAT
 800                 &amp;&amp; favorite.intent != null
 801                 &amp;&amp; (favorite.itemType == Favorites.ITEM_TYPE_APPLICATION
 802                 || favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT);
 803     }
 804 
 805     /** Serialize a Favorite for persistence, including a checksum wrapper. */
 806     private Favorite packFavorite(Cursor c) {
 807         Favorite favorite = new Favorite();
 808         favorite.id = c.getLong(ID_INDEX);
 809         favorite.screen = c.getInt(SCREEN_INDEX);
 810         favorite.container = c.getInt(CONTAINER_INDEX);
 811         favorite.cellX = c.getInt(CELLX_INDEX);
 812         favorite.cellY = c.getInt(CELLY_INDEX);
 813         favorite.spanX = c.getInt(SPANX_INDEX);
 814         favorite.spanY = c.getInt(SPANY_INDEX);
 815         favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 816         favorite.rank = c.getInt(RANK_INDEX);
 817 
 818         String title = c.getString(TITLE_INDEX);
 819         if (!TextUtils.isEmpty(title)) {
 820             favorite.title = title;
 821         }
 822         String intentDescription = c.getString(INTENT_INDEX);
 823         Intent intent = null;
 824         if (!TextUtils.isEmpty(intentDescription)) {
 825             try {
 826                 intent = Intent.parseUri(intentDescription, 0);
 827                 intent.removeExtra(ItemInfo.EXTRA_PROFILE);
 828                 favorite.intent = intent.toUri(0);
 829             } catch (URISyntaxException e) {
 830                 Log.e(TAG, &quot;Invalid intent&quot;, e);
 831             }
 832         }
 833         favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 834         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 835             favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 836             String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 837             if (!TextUtils.isEmpty(appWidgetProvider)) {
 838                 favorite.appWidgetProvider = appWidgetProvider;
 839             }
 840         } else if (favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT) {
 841             if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 842                 String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 843                 if (!TextUtils.isEmpty(iconPackage)) {
 844                     favorite.iconPackage = iconPackage;
 845                 }
 846                 String iconResource = c.getString(ICON_RESOURCE_INDEX);
 847                 if (!TextUtils.isEmpty(iconResource)) {
 848                     favorite.iconResource = iconResource;
 849                 }
 850             }
 851 
 852             byte[] blob = c.getBlob(ICON_INDEX);
 853             if (blob != null &amp;&amp; blob.length &gt; 0) {
 854                 favorite.icon = blob;
 855             }
 856         }
 857 
 858         if (isReplaceableHotseatItem(favorite)) {
 859             if (intent != null &amp;&amp; intent.getComponent() != null) {
 860                 PackageManager pm = mContext.getPackageManager();
 861                 ActivityInfo activity = null;;
 862                 try {
 863                     activity = pm.getActivityInfo(intent.getComponent(), 0);
 864                 } catch (NameNotFoundException e) {
 865                     Log.e(TAG, &quot;Target not found&quot;, e);
 866                 }
 867                 if (activity == null) {
 868                     return favorite;
 869                 }
 870                 for (int i = 0; i &lt; mItemTypeMatchers.length; i++) {
 871                     if (mItemTypeMatchers[i] == null) {
 872                         mItemTypeMatchers[i] = new ItemTypeMatcher(
 873                                 CommonAppTypeParser.getResourceForItemType(i));
 874                     }
 875                     if (mItemTypeMatchers[i].matches(activity, pm)) {
 876                         favorite.targetType = i;
 877                         break;
 878                     }
 879                 }
 880             }
 881         }
 882 
 883         return favorite;
 884     }
 885 
 886     /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 887     private ContentValues unpackFavorite(byte[] buffer, int dataSize)
 888             throws IOException {
 889         Favorite favorite = unpackProto(new Favorite(), buffer, dataSize);
 890 
 891         // If it is a hotseat item, move it accordingly.
 892         if (favorite.container == Favorites.CONTAINER_HOTSEAT) {
 893             favorite.screen += mHotseatShift;
 894         }
 895 
 896         ContentValues values = new ContentValues();
 897         values.put(Favorites._ID, favorite.id);
 898         values.put(Favorites.SCREEN, favorite.screen);
 899         values.put(Favorites.CONTAINER, favorite.container);
 900         values.put(Favorites.CELLX, favorite.cellX);
 901         values.put(Favorites.CELLY, favorite.cellY);
 902         values.put(Favorites.SPANX, favorite.spanX);
 903         values.put(Favorites.SPANY, favorite.spanY);
 904         values.put(Favorites.RANK, favorite.rank);
 905 
 906         if (favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT) {
 907             values.put(Favorites.ICON_TYPE, favorite.iconType);
 908             if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 909                 values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 910                 values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 911             }
 912             values.put(Favorites.ICON, favorite.icon);
 913         }
 914 
 915         if (!TextUtils.isEmpty(favorite.title)) {
 916             values.put(Favorites.TITLE, favorite.title);
 917         } else {
 918             values.put(Favorites.TITLE, &quot;&quot;);
 919         }
 920         if (!TextUtils.isEmpty(favorite.intent)) {
 921             values.put(Favorites.INTENT, favorite.intent);
 922         }
 923         values.put(Favorites.ITEM_TYPE, favorite.itemType);
 924 
 925         UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 926         long userSerialNumber =
 927                 UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHandle);
 928         values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
 929 
 930         // If we will attempt grid resize, use the original profile to validate grid size, as
 931         // anything which fits in the original grid should fit in the current grid after
 932         // grid migration.
 933         DeviceProfieData currentProfile = migrationCompatibleProfileData == null
 934                 ? mDeviceProfileData : migrationCompatibleProfileData;
 935 
 936         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 937             if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 938                 values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 939             }
 940             values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 941             values.put(LauncherSettings.Favorites.RESTORED,
 942                     LauncherAppWidgetInfo.FLAG_ID_NOT_VALID |
 943                     LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY |
 944                     LauncherAppWidgetInfo.FLAG_UI_NOT_READY);
 945 
 946             // Verify placement
 947             if (((favorite.cellX + favorite.spanX) &gt; currentProfile.desktopCols)
 948                     || ((favorite.cellY + favorite.spanY) &gt; currentProfile.desktopRows)) {
 949                 restoreSuccessful = false;
 950                 throw new InvalidBackupException(&quot;Widget not in screen bounds, aborting restore&quot;);
 951             }
 952         } else {
 953             // Check if it is an hotseat item, that can be replaced.
 954             if (isReplaceableHotseatItem(favorite)
 955                     &amp;&amp; favorite.targetType != Favorite.TARGET_NONE
 956                     &amp;&amp; favorite.targetType &lt; CommonAppTypeParser.SUPPORTED_TYPE_COUNT) {
 957                 Log.e(TAG, &quot;Added item type flag&quot;);
 958                 values.put(LauncherSettings.Favorites.RESTORED,
 959                         1 | CommonAppTypeParser.encodeItemTypeToFlag(favorite.targetType));
 960             } else {
 961                 // Let LauncherModel know we&#x27;ve been here.
 962                 values.put(LauncherSettings.Favorites.RESTORED, 1);
 963             }
 964 
 965             // Verify placement
 966             if (favorite.container == Favorites.CONTAINER_HOTSEAT) {
 967                 if ((favorite.screen &gt;= currentProfile.hotseatCount)
 968                         || (favorite.screen == currentProfile.allappsRank)) {
 969                     restoreSuccessful = false;
 970                     throw new InvalidBackupException(&quot;Item not in hotseat bounds, aborting restore&quot;);
 971                 }
 972             } else {
 973                 if ((favorite.cellX &gt;= currentProfile.desktopCols)
 974                         || (favorite.cellY &gt;= currentProfile.desktopRows)) {
 975                     restoreSuccessful = false;
 976                     throw new InvalidBackupException(&quot;Item not in desktop bounds, aborting restore&quot;);
 977                 }
 978             }
 979         }
 980 
 981         return values;
 982     }
 983 
 984     /** Serialize a Screen for persistence, including a checksum wrapper. */
 985     private Screen packScreen(Cursor c) {
 986         Screen screen = new Screen();
 987         screen.id = c.getLong(ID_INDEX);
 988         screen.rank = c.getInt(SCREEN_RANK_INDEX);
 989         return screen;
 990     }
 991 
 992     /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 993     private ContentValues unpackScreen(byte[] buffer, int dataSize)
 994             throws InvalidProtocolBufferNanoException {
 995         Screen screen = unpackProto(new Screen(), buffer, dataSize);
 996         ContentValues values = new ContentValues();
 997         values.put(WorkspaceScreens._ID, screen.id);
 998         values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 999         return values;
1000     }
1001 
1002     /** Serialize an icon Resource for persistence, including a checksum wrapper. */
1003     private Resource packIcon(int dpi, Bitmap icon) {
1004         Resource res = new Resource();
1005         res.dpi = dpi;
1006         res.data = Utilities.flattenBitmap(icon);
1007         return res;
1008     }
1009 
1010     /** Serialize a widget for persistence, including a checksum wrapper. */
1011     private Widget packWidget(int dpi, ComponentName provider, UserHandleCompat user) {
1012         final LauncherAppWidgetProviderInfo info =
1013                 LauncherModel.getProviderInfo(mContext, provider, user);
1014         Widget widget = new Widget();
1015         widget.provider = provider.flattenToShortString();
1016         widget.label = info.label;
1017         widget.configure = info.configure != null;
1018         if (info.icon != 0) {
1019             widget.icon = new Resource();
1020             Drawable fullResIcon = mIconCache.getFullResIcon(provider.getPackageName(), info.icon);
1021             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
1022             widget.icon.data = Utilities.flattenBitmap(icon);
1023             widget.icon.dpi = dpi;
1024         }
1025 
1026         Point spans = info.getMinSpans(mIdp, mContext);
1027         widget.minSpanX = spans.x;
1028         widget.minSpanY = spans.y;
1029 
1030         return widget;
1031     }
1032 
1033     /**
1034      * Deserialize a proto after verifying checksum wrapper.
1035      */
1036     private &lt;T extends MessageNano&gt; T unpackProto(T proto, byte[] buffer, int dataSize)
1037             throws InvalidProtocolBufferNanoException {
1038         MessageNano.mergeFrom(proto, readCheckedBytes(buffer, dataSize));
1039         if (DEBUG) Log.d(TAG, &quot;unpacked proto &quot; + proto);
1040         return proto;
1041     }
1042 
1043     /**
1044      * Read the old journal from the input file.
1045      *
1046      * In the event of any error, just pretend we didn&#x27;t have a journal,
1047      * in that case, do a full backup.
1048      *
1049      * @param oldState the read-0only file descriptor pointing to the old journal
1050      * @return a Journal protocol buffer
1051      */
1052     private Journal readJournal(ParcelFileDescriptor oldState) {
1053         Journal journal = new Journal();
1054         if (oldState == null) {
1055             return journal;
1056         }
1057         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
1058         try {
1059             int availableBytes = inStream.available();
1060             if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
1061             if (availableBytes &lt; MAX_JOURNAL_SIZE) {
1062                 byte[] buffer = new byte[availableBytes];
1063                 int bytesRead = 0;
1064                 boolean valid = false;
1065                 InvalidProtocolBufferNanoException lastProtoException = null;
1066                 while (availableBytes &gt; 0) {
1067                     try {
1068                         // OMG what are you doing? This is crazy inefficient!
1069                         // If we read a byte that is not ours, we will cause trouble: b/12491813
1070                         // However, we don&#x27;t know how many bytes to expect (oops).
1071                         // So we have to step through *slowly*, watching for the end.
1072                         int result = inStream.read(buffer, bytesRead, 1);
1073                         if (result &gt; 0) {
1074                             availableBytes -= result;
1075                             bytesRead += result;
1076                         } else {
1077                             Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1078                             // stop reading and see what there is to parse
1079                             availableBytes = 0;
1080                         }
1081                     } catch (IOException e) {
1082                         buffer = null;
1083                         availableBytes = 0;
1084                     }
1085 
1086                     // check the buffer to see if we have a valid journal
1087                     try {
1088                         MessageNano.mergeFrom(journal, readCheckedBytes(buffer, bytesRead));
1089                         // if we are here, then we have read a valid, checksum-verified journal
1090                         valid = true;
1091                         availableBytes = 0;
1092                         if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1093                     } catch (InvalidProtocolBufferNanoException e) {
1094                         // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1095                         lastProtoException = e;
1096                         journal.clear();
1097                     }
1098                 }
1099                 if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1100                 if (!valid) {
1101                     Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1102                 }
1103             }
1104         } catch (IOException e) {
1105             Log.w(TAG, &quot;failed to close the journal&quot;, e);
1106         } finally {
1107             try {
1108                 inStream.close();
1109             } catch (IOException e) {
1110                 Log.w(TAG, &quot;failed to close the journal&quot;, e);
1111             }
1112         }
1113         return journal;
1114     }
1115 
1116     private void writeRowToBackup(Key key, MessageNano proto, BackupDataOutput data)
1117             throws IOException {
1118         writeRowToBackup(keyToBackupKey(key), proto, data);
1119     }
1120 
1121     private void writeRowToBackup(String backupKey, MessageNano proto,
1122             BackupDataOutput data) throws IOException {
1123         byte[] blob = writeCheckedBytes(proto);
1124         data.writeEntityHeader(backupKey, blob.length);
1125         data.writeEntityData(blob, blob.length);
1126         mBackupDataWasUpdated = true;
1127         if (VERBOSE) Log.v(TAG, &quot;Writing New entry &quot; + backupKey);
1128     }
1129 
1130     /**
1131      * Write the new journal to the output file.
1132      *
1133      * In the event of any error, just pretend we didn&#x27;t have a journal,
1134      * in that case, do a full backup.
1135 
1136      * @param newState the write-only file descriptor pointing to the new journal
1137      * @param journal a Journal protocol buffer
1138      */
1139     private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1140         FileOutputStream outStream = null;
1141         try {
1142             outStream = new FileOutputStream(newState.getFileDescriptor());
1143             final byte[] journalBytes = writeCheckedBytes(journal);
1144             outStream.write(journalBytes);
1145             outStream.close();
1146             if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1147         } catch (IOException e) {
1148             Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1149         }
1150     }
1151 
1152     /** Wrap a proto in a CheckedMessage and compute the checksum. */
1153     private byte[] writeCheckedBytes(MessageNano proto) {
1154         CheckedMessage wrapper = new CheckedMessage();
1155         wrapper.payload = MessageNano.toByteArray(proto);
1156         CRC32 checksum = new CRC32();
1157         checksum.update(wrapper.payload);
1158         wrapper.checksum = checksum.getValue();
1159         return MessageNano.toByteArray(wrapper);
1160     }
1161 
1162     /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1163     private static byte[] readCheckedBytes(byte[] buffer, int dataSize)
1164             throws InvalidProtocolBufferNanoException {
1165         CheckedMessage wrapper = new CheckedMessage();
1166         MessageNano.mergeFrom(wrapper, buffer, 0, dataSize);
1167         CRC32 checksum = new CRC32();
1168         checksum.update(wrapper.payload);
1169         if (wrapper.checksum != checksum.getValue()) {
1170             throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1171         }
1172         return wrapper.payload;
1173     }
1174 
1175     /**
1176      * @return true if the launcher is in a state to support backup
1177      */
1178     private boolean launcherIsReady() {
1179         ContentResolver cr = mContext.getContentResolver();
1180         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);
1181         if (cursor == null) {
1182             // launcher data has been wiped, do nothing
1183             return false;
1184         }
1185         cursor.close();
1186 
1187         if (LauncherAppState.getInstanceNoCreate() == null) {
1188             // launcher services are unavailable, try again later
1189             return false;
1190         }
1191 
1192         return true;
1193     }
1194 
1195     private String getUserSelectionArg() {
1196         return Favorites.PROFILE_ID + &#x27;=&#x27; + UserManagerCompat.getInstance(mContext)
1197                 .getSerialNumberForUser(UserHandleCompat.myUserHandle());
1198     }
1199 
1200     @Thunk class InvalidBackupException extends IOException {
1201 
1202         private static final long serialVersionUID = 8931456637211665082L;
1203 
1204         @Thunk InvalidBackupException(Throwable cause) {
1205             super(cause);
1206         }
1207 
1208         @Thunk InvalidBackupException(String reason) {
1209             super(reason);
1210         }
1211     }
1212 
1213     public boolean shouldAttemptWorkspaceMigration() {
1214         return migrationCompatibleProfileData != null;
1215     }
1216 
1217     /**
1218      * A class to check if an activity can handle one of the intents from a list of
1219      * predefined intents.
1220      */
1221     private class ItemTypeMatcher {
1222 
1223         private final ArrayList&lt;Intent&gt; mIntents;
1224 
1225         ItemTypeMatcher(int xml_res) {
1226             mIntents = xml_res == 0 ? new ArrayList&lt;Intent&gt;() : parseIntents(xml_res);
1227         }
1228 
1229         private ArrayList&lt;Intent&gt; parseIntents(int xml_res) {
1230             ArrayList&lt;Intent&gt; intents = new ArrayList&lt;Intent&gt;();
1231             XmlResourceParser parser = mContext.getResources().getXml(xml_res);
1232             try {
1233                 DefaultLayoutParser.beginDocument(parser, DefaultLayoutParser.TAG_RESOLVE);
1234                 final int depth = parser.getDepth();
1235                 int type;
1236                 while (((type = parser.next()) != XmlPullParser.END_TAG ||
1237                         parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {
1238                     if (type != XmlPullParser.START_TAG) {
1239                         continue;
1240                     } else if (DefaultLayoutParser.TAG_FAVORITE.equals(parser.getName())) {
1241                         final String uri = DefaultLayoutParser.getAttributeValue(
1242                                 parser, DefaultLayoutParser.ATTR_URI);
1243                         intents.add(Intent.parseUri(uri, 0));
1244                     }
1245                 }
1246             } catch (URISyntaxException | XmlPullParserException | IOException e) {
1247                 Log.e(TAG, &quot;Unable to parse &quot; + xml_res, e);
1248             } finally {
1249                 parser.close();
1250             }
1251             return intents;
1252         }
1253 
1254         public boolean matches(ActivityInfo activity, PackageManager pm) {
1255             for (Intent intent : mIntents) {
1256                 intent.setPackage(activity.packageName);
1257                 ResolveInfo info = pm.resolveActivity(intent, 0);
1258                 if (info != null &amp;&amp; (info.activityInfo.name.equals(activity.name)
1259                         || info.activityInfo.name.equals(activity.targetActivity))) {
1260                     return true;
1261                 }
1262             }
1263             return false;
1264         }
1265     }
1266 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.app.backup.BackupDataInputStream;
  19 import android.app.backup.BackupDataOutput;
  20 import android.app.backup.BackupHelper;
  21 import android.app.backup.BackupManager;
  22 import android.content.ComponentName;
  23 import android.content.ContentResolver;
  24 import android.content.ContentValues;
  25 import android.content.Context;
  26 import android.content.Intent;
  27 import android.content.pm.ActivityInfo;
  28 import android.content.pm.PackageManager.NameNotFoundException;
  29 import android.content.pm.PackageManager;
  30 import android.content.pm.ResolveInfo;
  31 import android.content.res.XmlResourceParser;
  32 import android.database.Cursor;
  33 import android.graphics.Bitmap;
  34 import android.graphics.BitmapFactory;
  35 import android.graphics.Point;
  36 import android.graphics.drawable.Drawable;
  37 import android.os.ParcelFileDescriptor;
  38 import android.text.TextUtils;
  39 import android.util.Base64;
  40 import android.util.Log;
  41 import com.android.launcher3.LauncherSettings.Favorites;
  42 import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  43 import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  44 import com.android.launcher3.backup.BackupProtos.DeviceProfieData;
  45 import com.android.launcher3.backup.BackupProtos.Favorite;
  46 import com.android.launcher3.backup.BackupProtos.Journal;
  47 import com.android.launcher3.backup.BackupProtos.Key;
  48 import com.android.launcher3.backup.BackupProtos.Resource;
  49 import com.android.launcher3.backup.BackupProtos.Screen;
  50 import com.android.launcher3.backup.BackupProtos.Widget;
  51 import com.android.launcher3.backup.BackupProtos;
  52 import com.android.launcher3.compat.UserHandleCompat;
  53 import com.android.launcher3.compat.UserManagerCompat;
  54 import com.android.launcher3.model.MigrateFromRestoreTask;
  55 import com.android.launcher3.util.Thunk;
  56 import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  57 import com.google.protobuf.nano.MessageNano;
  58 import java.io.FileInputStream;
  59 import java.io.FileOutputStream;
  60 import java.io.IOException;
  61 import java.net.URISyntaxException;
  62 import java.util.ArrayList;
  63 import java.util.Arrays;
  64 import java.util.HashSet;
  65 import java.util.zip.CRC32;
  66 import org.xmlpull.v1.XmlPullParser;
  67 import org.xmlpull.v1.XmlPullParserException;
  68 
  69 
  70 /**
  71  * Persist the launcher home state across calamities.
  72  */
  73 public class LauncherBackupHelper implements BackupHelper {
  74     private static final String TAG = &quot;LauncherBackupHelper&quot;;
  75 
  76     private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  77 
  78     private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  79 
  80     private static final int BACKUP_VERSION = 4;
  81 
  82     private static final int MAX_JOURNAL_SIZE = 1000000;
  83 
  84     // Journal key is such that it is always smaller than any dynamically generated
  85     // key (any Base64 encoded string).
  86     // Journal key is such that it is always smaller than any dynamically generated
  87     // key (any Base64 encoded string).
  88     private static final String JOURNAL_KEY = &quot;#&quot;;
  89 
  90     /**
  91      * icons are large, dribble them out
  92      */
  93     private static final int MAX_ICONS_PER_PASS = 10;
  94 
  95     /**
  96      * widgets contain previews, which are very large, dribble them out
  97      */
  98     private static final int MAX_WIDGETS_PER_PASS = 5;
  99 
 100     private static final String[] FAVORITE_PROJECTION = new java.lang.String[]{ Favorites._ID, // 0
 101     Favorites.MODIFIED, // 1
 102     Favorites.INTENT, // 2
 103     Favorites.APPWIDGET_PROVIDER// 3
 104     , Favorites.APPWIDGET_ID, // 4
 105     Favorites.CELLX, // 5
 106     Favorites.CELLY, // 6
 107     Favorites.CONTAINER, // 7
 108     Favorites.ICON, // 8
 109     Favorites.ICON_PACKAGE, // 9
 110     Favorites.ICON_RESOURCE, // 10
 111     Favorites.ICON_TYPE, // 11
 112     Favorites.ITEM_TYPE, // 12
 113     Favorites.SCREEN, // 13
 114     Favorites.SPANX, // 14
 115     Favorites.SPANY, // 15
 116     Favorites.TITLE, // 16
 117     Favorites.PROFILE_ID, // 17
 118         // 18
 119     Favorites.RANK };
 120 
 121     private static final int ID_INDEX = 0;
 122 
 123     private static final int ID_MODIFIED = 1;
 124 
 125     private static final int INTENT_INDEX = 2;
 126 
 127     private static final int APPWIDGET_PROVIDER_INDEX = 3;
 128 
 129     private static final int APPWIDGET_ID_INDEX = 4;
 130 
 131     private static final int CELLX_INDEX = 5;
 132 
 133     private static final int CELLY_INDEX = 6;
 134 
 135     private static final int CONTAINER_INDEX = 7;
 136 
 137     private static final int ICON_INDEX = 8;
 138 
 139     private static final int ICON_PACKAGE_INDEX = 9;
 140 
 141     private static final int ICON_RESOURCE_INDEX = 10;
 142 
 143     private static final int ICON_TYPE_INDEX = 11;
 144 
 145     private static final int ITEM_TYPE_INDEX = 12;
 146 
 147     private static final int SCREEN_INDEX = 13;
 148 
 149     private static final int SPANX_INDEX = 14;
 150 
 151     private static final int SPANY_INDEX = 15;
 152 
 153     private static final int TITLE_INDEX = 16;
 154 
 155     private static final int RANK_INDEX = 18;
 156 
 157     private static final String[] SCREEN_PROJECTION = new java.lang.String[]{ WorkspaceScreens._ID, // 0
 158     WorkspaceScreens.MODIFIED, // 1
 159     WorkspaceScreens.SCREEN_RANK// 2
 160      };
 161 
 162     private static final int SCREEN_RANK_INDEX = 2;
 163 
 164     @Thunk
 165     final Context mContext;
 166 
 167     private final HashSet&lt;String&gt; mExistingKeys;
 168 
 169     private final ArrayList&lt;Key&gt; mKeys;
 170 
 171     private final ItemTypeMatcher[] mItemTypeMatchers;
 172 
 173     private final long mUserSerial;
 174 
 175     private BackupManager mBackupManager;
 176 
 177     private byte[] mBuffer = new byte[512];
 178 
 179     private long mLastBackupRestoreTime;
 180 
 181     private boolean mBackupDataWasUpdated;
 182 
 183     private IconCache mIconCache;
 184 
 185     private DeviceProfieData mDeviceProfileData;
 186 
 187     private InvariantDeviceProfile mIdp;
 188 
 189     DeviceProfieData migrationCompatibleProfileData;
 190 
 191     HashSet&lt;String&gt; widgetSizes = new HashSet&lt;&gt;();
 192 
 193     boolean restoreSuccessful;
 194 
 195     int restoredBackupVersion = 1;
 196 
 197     // When migrating from a device which different hotseat configuration, the icons are shifted
 198     // to center along the new all-apps icon.
 199     private int mHotseatShift = 0;
 200 
 201     public LauncherBackupHelper(Context context) {
 202         mContext = context;
 203         mExistingKeys = new HashSet&lt;String&gt;();
 204         mKeys = new ArrayList&lt;Key&gt;();
 205         restoreSuccessful = true;
 206         mItemTypeMatchers = new ItemTypeMatcher[CommonAppTypeParser.SUPPORTED_TYPE_COUNT];
 207         UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 208         mUserSerial = userManager.getSerialNumberForUser(UserHandleCompat.myUserHandle());
 209     }
 210 
 211     private void dataChanged() {
 212         if (mBackupManager == null) {
 213             mBackupManager = new BackupManager(mContext);
 214         }
 215         mBackupManager.dataChanged();
 216     }
 217 
 218     private void applyJournal(Journal journal) {
 219         mLastBackupRestoreTime = journal.t;
 220         mExistingKeys.clear();
 221         if (journal.key != null) {
 222             for (Key key : journal.key) {
 223                 mExistingKeys.add(keyToBackupKey(key));
 224             }
 225         }
 226         restoredBackupVersion = journal.backupVersion;
 227     }
 228 
 229     /**
 230      * Back up launcher data so we can restore the user&#x27;s state on a new device.
 231      *
 232      * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 233      *
 234      * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 235      *
 236      * @param oldState notes from the last backup
 237      * @param data incremental key/value pairs to persist off-device
 238      * @param newState notes for the next backup
 239      */
 240     @Override
<abbr title=" 241     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data, ParcelFileDescriptor newState) {"> 241     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data, ParcelFileDescriptor </abbr>
 242         if (VERBOSE) {
 243             Log.v(TAG, &quot;onBackup&quot;);
 244         }
 245         Journal in = readJournal(oldState);
 246         if (!launcherIsReady()) {
 247             dataChanged();
 248             // Perform backup later.
 249             writeJournal(newState, in);
 250             return;
 251         }
 252         if (mDeviceProfileData == null) {
 253             LauncherAppState app = LauncherAppState.getInstance();
 254             mIdp = app.getInvariantDeviceProfile();
 255             mDeviceProfileData = initDeviceProfileData(mIdp);
 256             mIconCache = app.getIconCache();
 257         }
 258         Log.v(TAG, &quot;lastBackupTime = &quot; + in.t);
 259         mKeys.clear();
 260         applyJournal(in);
 261         // Record the time before performing backup so that entries edited while the backup
 262         // was going on, do not get missed in next backup.
 263         long newBackupTime = System.currentTimeMillis();
 264         mBackupDataWasUpdated = false;
 265         try {
 266             backupFavorites(data);
 267             backupScreens(data);
 268             backupIcons(data);
 269             backupWidgets(data);
 270             // Delete any key which still exist in the old backup, but is not valid anymore.
 271             HashSet&lt;String&gt; validKeys = new HashSet&lt;String&gt;();
 272             for (Key key : mKeys) {
 273                 validKeys.add(keyToBackupKey(key));
 274             }
 275             mExistingKeys.removeAll(validKeys);
 276             // Delete anything left in the existing keys.
 277             for (String deleted : mExistingKeys) {
 278                 if (VERBOSE) {
 279                     Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
 280                 }
 281                 data.writeEntityHeader(deleted, -1);
 282                 mBackupDataWasUpdated = true;
 283             }
 284             mExistingKeys.clear();
 285             if (!mBackupDataWasUpdated) {
 286                 // Check if any metadata has changed
<abbr title=" 287                 mBackupDataWasUpdated = (((in.profile == null) || (!Arrays.equals(DeviceProfieData.toByteArray(in.profile), DeviceProfieData.toByteArray(mDeviceProfileData)))) || (in.backupVersion != BACKUP_VERSION)) || (in.appVersion != getAppVersion());"> 287                 mBackupDataWasUpdated = (((in.profile == null) || (!Arrays.equals(DeviceProfieData.toByte</abbr>
 288             }
 289             if (mBackupDataWasUpdated) {
 290                 mLastBackupRestoreTime = newBackupTime;
 291                 // We store the journal at two places.
 292                 // 1) Storing it in newState allows us to do partial backups by comparing old state
 293                 // 2) Storing it in backup data allows us to validate keys during restore
 294                 Journal state = getCurrentStateJournal();
 295                 writeRowToBackup(JOURNAL_KEY, state, data);
 296             } else if (DEBUG) {
 297                 Log.d(TAG, &quot;Nothing was written during backup&quot;);
 298             }
 299         } catch (IOException e) {
 300             Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 301         }
 302         writeNewStateDescription(newState);
 303     }
 304 
 305     /**
 306      * @return true if the backup corresponding to oldstate can be successfully applied
 307      * to this device.
 308      */
 309     private boolean isBackupCompatible(Journal oldState) {
 310         DeviceProfieData currentProfile = mDeviceProfileData;
 311         DeviceProfieData oldProfile = oldState.profile;
 312         if ((oldProfile == null) || (oldProfile.desktopCols == 0)) {
 313             // Profile info is not valid, ignore the check.
 314             return true;
 315         }
 316         boolean isHotseatCompatible = false;
 317         if (currentProfile.allappsRank &gt;= oldProfile.hotseatCount) {
 318             isHotseatCompatible = true;
 319             mHotseatShift = 0;
 320         }
<abbr title=" 321         if ((currentProfile.allappsRank &gt;= oldProfile.allappsRank) &amp;&amp; ((currentProfile.hotseatCount - currentProfile.allappsRank) &gt;= (oldProfile.hotseatCount - oldProfile.allappsRank))) {"> 321         if ((currentProfile.allappsRank &gt;= oldProfile.allappsRank) &amp;&amp; ((currentProfile.hotseatCount - cur</abbr>
 322             // There is enough space on both sides of the hotseat.
 323             isHotseatCompatible = true;
 324             mHotseatShift = currentProfile.allappsRank - oldProfile.allappsRank;
 325         }
 326         if (!isHotseatCompatible) {
 327             return false;
 328         }
<abbr title=" 329         if ((currentProfile.desktopCols &gt;= oldProfile.desktopCols) &amp;&amp; (currentProfile.desktopRows &gt;= oldProfile.desktopRows)) {"> 329         if ((currentProfile.desktopCols &gt;= oldProfile.desktopCols) &amp;&amp; (currentProfile.desktopRows &gt;= oldP</abbr>
 330             return true;
 331         }
<abbr title=" 332         if ((MigrateFromRestoreTask.ENABLED &amp;&amp; ((oldProfile.desktopCols - currentProfile.desktopCols) &lt;= 1)) &amp;&amp; ((oldProfile.desktopRows - currentProfile.desktopRows) &lt;= 1)) {"> 332         if ((MigrateFromRestoreTask.ENABLED &amp;&amp; ((oldProfile.desktopCols - currentProfile.desktopCols) &lt;= </abbr>
 333             // Allow desktop migration when row and/or column count contracts by 1.
 334             migrationCompatibleProfileData = initDeviceProfileData(mIdp);
 335             migrationCompatibleProfileData.desktopCols = oldProfile.desktopCols;
 336             migrationCompatibleProfileData.desktopRows = oldProfile.desktopRows;
 337             return true;
 338         }
 339         return false;
 340     }
 341 
 342     /**
 343      * Restore launcher configuration from the restored data stream.
 344      * It assumes that the keys will arrive in lexical order. So if the journal was present in the
 345      * backup, it should arrive first.
 346      *
 347      * @param data the key/value pair from the server
 348      */
 349     @Override
 350     public void restoreEntity(BackupDataInputStream data) {
 351         if (!restoreSuccessful) {
 352             return;
 353         }
 354         if (mDeviceProfileData == null) {
 355             // This call does not happen on a looper thread. So LauncherAppState
 356             // can&#x27;t be created . Instead initialize required dependencies directly.
 357             mIdp = new InvariantDeviceProfile(mContext);
 358             mDeviceProfileData = initDeviceProfileData(mIdp);
 359             mIconCache = new IconCache(mContext, mIdp);
 360         }
 361         int dataSize = data.size();
 362         if (mBuffer.length &lt; dataSize) {
 363             mBuffer = new byte[dataSize];
 364         }
 365         try {
 366             int bytesRead = data.read(mBuffer, 0, dataSize);
 367             if (DEBUG) {
 368                 Log.d(TAG, (((&quot;read &quot; + bytesRead) + &quot; of &quot;) + dataSize) + &quot; available&quot;);
 369             }
 370             String backupKey = data.getKey();
 371             if (JOURNAL_KEY.equals(backupKey)) {
 372                 if (VERBOSE) {
 373                     Log.v(TAG, &quot;Journal entry restored&quot;);
 374                 }
 375                 if (!mKeys.isEmpty()) {
 376                     // We received the journal key after a restore key.
 377                     Log.wtf(TAG, (keyToBackupKey(mKeys.get(0)) + &quot; received after &quot;) + JOURNAL_KEY);
 378                     restoreSuccessful = false;
 379                     return;
 380                 }
 381                 Journal journal = new Journal();
 382                 MessageNano.mergeFrom(journal, readCheckedBytes(mBuffer, dataSize));
 383                 applyJournal(journal);
 384                 restoreSuccessful = isBackupCompatible(journal);
 385                 return;
 386             }
 387             if ((!mExistingKeys.isEmpty()) &amp;&amp; (!mExistingKeys.contains(backupKey))) {
 388                 if (DEBUG) {
 389                     Log.e(TAG, &quot;Ignoring key not present in the backup state &quot; + backupKey);
 390                 }
 391                 return;
 392             }
 393             Key key = backupKeyToKey(backupKey);
 394             mKeys.add(key);
 395             switch (key.type) {
 396                 case Key.FAVORITE :
 397                     restoreFavorite(key, mBuffer, dataSize);
 398                     break;
 399                 case Key.SCREEN :
 400                     restoreScreen(key, mBuffer, dataSize);
 401                     break;
 402                 case Key.ICON :
 403                     restoreIcon(key, mBuffer, dataSize);
 404                     break;
 405                 case Key.WIDGET :
 406                     restoreWidget(key, mBuffer, dataSize);
 407                     break;
 408                 default :
 409                     Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 410                     mKeys.remove(key);
 411                     break;
 412             }
 413         } catch (IOException e) {
 414             Log.w(TAG, &quot;ignoring unparsable backup entry&quot;, e);
 415         }
 416     }
 417 
 418     /**
 419      * Record the restore state for the next backup.
 420      *
 421      * @param newState notes about the backup state after restore.
 422      */
 423     @Override
 424     public void writeNewStateDescription(ParcelFileDescriptor newState) {
 425         writeJournal(newState, getCurrentStateJournal());
 426     }
 427 
 428     private Journal getCurrentStateJournal() {
 429         Journal journal = new Journal();
 430         journal.t = mLastBackupRestoreTime;
 431         journal.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);
 432         journal.appVersion = getAppVersion();
 433         journal.backupVersion = BACKUP_VERSION;
 434         journal.profile = mDeviceProfileData;
 435         return journal;
 436     }
 437 
 438     private int getAppVersion() {
 439         try {
 440             return mContext.getPackageManager()
 441                     .getPackageInfo(mContext.getPackageName(), 0).versionCode;
 442         } catch (NameNotFoundException e) {
 443             return 0;
 444         }
 445     }
 446 
 447     private DeviceProfieData initDeviceProfileData(InvariantDeviceProfile profile) {
 448         DeviceProfieData data = new DeviceProfieData();
 449         data.desktopRows = profile.numRows;
 450         data.desktopCols = profile.numColumns;
 451         data.hotseatCount = profile.numHotseatIcons;
 452         data.allappsRank = profile.hotseatAllAppsRank;
 453         return data;
 454     }
 455 
 456     /**
 457      * Write all modified favorites to the data stream.
 458      *
 459      * @param data output stream for key/value pairs
 460      * @throws IOException
 461      */
 462     private void backupFavorites(BackupDataOutput data) throws IOException {
 463         // persist things that have changed since the last backup
 464         ContentResolver cr = mContext.getContentResolver();
 465         // Don&#x27;t backup apps in other profiles for now.
<abbr title=" 466         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, getUserSelectionArg(), null, null);"> 466         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, getUserSelectionArg(), null,</abbr>
 467         try {
 468             cursor.moveToPosition(-1);
 469             while (cursor.moveToNext()) {
 470                 final long id = cursor.getLong(ID_INDEX);
 471                 final long updateTime = cursor.getLong(ID_MODIFIED);
 472                 Key key = getKey(Key.FAVORITE, id);
 473                 mKeys.add(key);
 474                 final String backupKey = keyToBackupKey(key);
 475                 // Favorite proto changed in v4. Backup again if the version is old.
<abbr title=" 476                 if (((!mExistingKeys.contains(backupKey)) || (updateTime &gt;= mLastBackupRestoreTime)) || (restoredBackupVersion &lt; 4)) {"> 476                 if (((!mExistingKeys.contains(backupKey)) || (updateTime &gt;= mLastBackupRestoreTime)) || (</abbr>
 477                     writeRowToBackup(key, packFavorite(cursor), data);
 478                 } else if (DEBUG) {
 479                     Log.d(TAG, &quot;favorite already backup up: &quot; + id);
 480                 }
 481             }
 482         } finally {
 483             cursor.close();
 484         }
 485     }
 486 
 487     /**
 488      * Read a favorite from the stream.
 489      *
 490      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 491      *
 492      * @param key identifier for the row
 493      * @param buffer the serialized proto from the stream, may be larger than dataSize
 494      * @param dataSize the size of the proto from the stream
 495      */
 496     private void restoreFavorite(Key key, byte[] buffer, int dataSize) throws IOException {
 497         if (VERBOSE) {
 498             Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 499         }
 500         if (DEBUG) {
<abbr title=" 501             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));"> 501             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, </abbr>
 502         }
 503         ContentResolver cr = mContext.getContentResolver();
 504         ContentValues values = unpackFavorite(buffer, dataSize);
 505         cr.insert(Favorites.CONTENT_URI, values);
 506     }
 507 
 508     /**
 509      * Write all modified screens to the data stream.
 510      *
 511      * @param data output stream for key/value pairs
 512      * @throws IOException
 513      */
 514     private void backupScreens(BackupDataOutput data) throws IOException {
 515         // persist things that have changed since the last backup
 516         ContentResolver cr = mContext.getContentResolver();
 517         Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 518                 null, null, null);
 519         try {
 520             cursor.moveToPosition(-1);
 521             if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + mLastBackupRestoreTime);
 522             while(cursor.moveToNext()) {
 523                 final long id = cursor.getLong(ID_INDEX);
 524                 final long updateTime = cursor.getLong(ID_MODIFIED);
 525                 Key key = getKey(Key.SCREEN, id);
 526                 mKeys.add(key);
 527                 final String backupKey = keyToBackupKey(key);
 528                 if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 529                     writeRowToBackup(key, packScreen(cursor), data);
 530                 } else {
 531                     if (VERBOSE) Log.v(TAG, &quot;screen already backup up &quot; + id);
 532                 }
 533             }
 534         } finally {
 535             cursor.close();
 536         }
 537     }
 538 
 539     /**
 540      * Read a screen from the stream.
 541      *
 542      * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 543      *
 544      * @param key identifier for the row
 545      * @param buffer the serialized proto from the stream, may be larger than dataSize
 546      * @param dataSize the size of the proto from the stream
 547      */
 548     private void restoreScreen(Key key, byte[] buffer, int dataSize) throws IOException {
 549         if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 550         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 551                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 552 
 553         ContentResolver cr = mContext.getContentResolver();
 554         ContentValues values = unpackScreen(buffer, dataSize);
 555         cr.insert(WorkspaceScreens.CONTENT_URI, values);
 556     }
 557 
 558     /**
 559      * Write all the static icon resources we need to render placeholders
 560      * for a package that is not installed.
 561      *
 562      * @param data output stream for key/value pairs
 563      */
 564     private void backupIcons(BackupDataOutput data) throws IOException {
 565         // persist icons that haven&#x27;t been persisted yet
 566         final ContentResolver cr = mContext.getContentResolver();
 567         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 568         final UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 569         int backupUpIconCount = 0;
 570         // Don&#x27;t backup apps in other profiles for now.
<abbr title=" 571         String where = ((((((((&quot;(&quot; + Favorites.ITEM_TYPE) + &quot;=&quot;) + Favorites.ITEM_TYPE_APPLICATION) + &quot; OR &quot;) + Favorites.ITEM_TYPE) + &quot;=&quot;) + Favorites.ITEM_TYPE_SHORTCUT) + &quot;) AND &quot;) + getUserSelectionArg();"> 571         String where = ((((((((&quot;(&quot; + Favorites.ITEM_TYPE) + &quot;=&quot;) + Favorites.ITEM_TYPE_APPLICATION) + &quot; O</abbr>
 572         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, where, null, null);
 573         try {
 574             cursor.moveToPosition(-1);
 575             while (cursor.moveToNext()) {
 576                 final long id = cursor.getLong(ID_INDEX);
 577                 final String intentDescription = cursor.getString(INTENT_INDEX);
 578                 try {
 579                     Intent intent = Intent.parseUri(intentDescription, 0);
 580                     ComponentName cn = intent.getComponent();
 581                     Key key = null;
 582                     String backupKey = null;
 583                     if (cn != null) {
 584                         key = getKey(Key.ICON, cn.flattenToShortString());
 585                         backupKey = keyToBackupKey(key);
 586                     } else {
 587                         Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 588                     }
 589                     if (mExistingKeys.contains(backupKey)) {
 590                         if (DEBUG) {
 591                             Log.d(TAG, &quot;already saved icon &quot; + backupKey);
 592                         }
 593                         // remember that we already backed this up previously
 594                         mKeys.add(key);
 595                     } else if (backupKey != null) {
 596                         if (DEBUG) {
 597                             Log.d(TAG, &quot;I can count this high: &quot; + backupUpIconCount);
 598                         }
 599                         if (backupUpIconCount &lt; MAX_ICONS_PER_PASS) {
 600                             if (DEBUG) {
 601                                 Log.d(TAG, &quot;saving icon &quot; + backupKey);
 602                             }
 603                             Bitmap icon = mIconCache.getIcon(intent, myUserHandle);
 604                             if ((icon != null) &amp;&amp; (!mIconCache.isDefaultIcon(icon, myUserHandle))) {
 605                                 writeRowToBackup(key, packIcon(dpi, icon), data);
 606                                 mKeys.add(key);
 607                                 backupUpIconCount++;
 608                             }
 609                         } else {
 610                             if (VERBOSE) {
 611                                 Log.v(TAG, &quot;deferring icon backup &quot; + backupKey);
 612                             }
 613                             // too many icons for this pass, request another.
 614                             dataChanged();
 615                         }
 616                     }
 617                 } catch (URISyntaxException e) {
 618                     Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 619                 } catch (IOException e) {
 620                     Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 621                 }
 622             }
 623         } finally {
 624             cursor.close();
 625         }
 626     }
 627 
 628     /**
 629      * Read an icon from the stream.
 630      *
 631      * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 632      *
 633      * @param key identifier for the row
 634      * @param buffer the serialized proto from the stream, may be larger than dataSize
 635      * @param dataSize the size of the proto from the stream
 636      */
 637     private void restoreIcon(Key key, byte[] buffer, int dataSize) throws IOException {
 638         if (VERBOSE) {
 639             Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 640         }
 641         if (DEBUG) {
<abbr title=" 642             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));"> 642             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, </abbr>
 643         }
 644         Resource res = unpackProto(new Resource(), buffer, dataSize);
 645         if (DEBUG) {
 646             Log.d(TAG, (&quot;unpacked &quot; + res.dpi) + &quot; dpi icon&quot;);
 647         }
 648         Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 649         if (icon == null) {
 650             Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 651         } else {
 652             if (VERBOSE) {
 653                 Log.v(TAG, &quot;saving restored icon as: &quot; + key.name);
 654             }
 655                     /* label */
<abbr title=" 656             mIconCache.preloadIcon(ComponentName.unflattenFromString(key.name), icon, res.dpi, &quot;&quot;, mUserSerial, mIdp);"> 656             mIconCache.preloadIcon(ComponentName.unflattenFromString(key.name), icon, res.dpi, &quot;&quot;, mUserS</abbr>
 657         }
 658     }
 659 
 660     /**
 661      * Write all the static widget resources we need to render placeholders
 662      * for a package that is not installed.
 663      *
 664      * @param data output stream for key/value pairs
 665      * @throws IOException
 666      */
 667     private void backupWidgets(BackupDataOutput data) throws IOException {
 668         // persist static widget info that hasn&#x27;t been persisted yet
 669         final ContentResolver cr = mContext.getContentResolver();
 670         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 671         int backupWidgetCount = 0;
<abbr title=" 672         String where = (((Favorites.ITEM_TYPE + &quot;=&quot;) + Favorites.ITEM_TYPE_APPWIDGET) + &quot; AND &quot;) + getUserSelectionArg();"> 672         String where = (((Favorites.ITEM_TYPE + &quot;=&quot;) + Favorites.ITEM_TYPE_APPWIDGET) + &quot; AND &quot;) + getUse</abbr>
 673         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, where, null, null);
 674         try {
 675             cursor.moveToPosition(-1);
 676             while (cursor.moveToNext()) {
 677                 final long id = cursor.getLong(ID_INDEX);
 678                 final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 679                 final ComponentName provider = ComponentName.unflattenFromString(providerName);
 680                 Key key = null;
 681                 String backupKey = null;
 682                 if (provider != null) {
 683                     key = getKey(Key.WIDGET, providerName);
 684                     backupKey = keyToBackupKey(key);
 685                 } else {
 686                     Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 687                 }
 688                 // Widget backup proto changed in v3. So add it again if the original backup is old.
 689                 if (mExistingKeys.contains(backupKey) &amp;&amp; (restoredBackupVersion &gt;= 3)) {
 690                     if (DEBUG) {
 691                         Log.d(TAG, &quot;already saved widget &quot; + backupKey);
 692                     }
 693                     // remember that we already backed this up previously
 694                     mKeys.add(key);
 695                 } else if (backupKey != null) {
 696                     if (DEBUG) {
 697                         Log.d(TAG, &quot;I can count this high: &quot; + backupWidgetCount);
 698                     }
 699                     if (backupWidgetCount &lt; MAX_WIDGETS_PER_PASS) {
 700                         if (DEBUG) {
 701                             Log.d(TAG, &quot;saving widget &quot; + backupKey);
 702                         }
 703                         UserHandleCompat user = UserHandleCompat.myUserHandle();
 704                         writeRowToBackup(key, packWidget(dpi, provider, user), data);
 705                         mKeys.add(key);
 706                         backupWidgetCount++;
 707                     } else {
 708                         if (VERBOSE) {
 709                             Log.v(TAG, &quot;deferring widget backup &quot; + backupKey);
 710                         }
 711                         // too many widgets for this pass, request another.
 712                         dataChanged();
 713                     }
 714                 }
 715             }
 716         } finally {
 717             cursor.close();
 718         }
 719     }
 720 
 721     /**
 722      * Read a widget from the stream.
 723      *
 724      * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 725      *
 726      * @param key identifier for the row
 727      * @param buffer the serialized proto from the stream, may be larger than dataSize
 728      * @param dataSize the size of the proto from the stream
 729      */
 730     private void restoreWidget(Key key, byte[] buffer, int dataSize) throws IOException {
 731         if (VERBOSE) {
 732             Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 733         }
 734         if (DEBUG) {
<abbr title=" 735             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));"> 735             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, </abbr>
 736         }
 737         Widget widget = unpackProto(new Widget(), buffer, dataSize);
 738         if (DEBUG) {
 739             Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 740         }
 741         if (widget.icon.data != null) {
 742             Bitmap icon = BitmapFactory.decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 743             if (icon == null) {
 744                 Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 745             } else {
<abbr title=" 746                 mIconCache.preloadIcon(ComponentName.unflattenFromString(widget.provider), icon, widget.icon.dpi, widget.label, mUserSerial, mIdp);"> 746                 mIconCache.preloadIcon(ComponentName.unflattenFromString(widget.provider), icon, widget.i</abbr>
 747             }
 748         }
 749         // Cache widget min sizes incase migration is required.
 750         widgetSizes.add((((widget.provider + &quot;#&quot;) + widget.minSpanX) + &quot;,&quot;) + widget.minSpanY);
 751     }
 752 
 753     /** create a new key, with an integer ID.
 754      *
 755      * &lt;P&gt; Keys contain their own checksum instead of using
 756      * the heavy-weight CheckedMessage wrapper.
 757      */
 758     private Key getKey(int type, long id) {
 759         Key key = new Key();
 760         key.type = type;
 761         key.id = id;
 762         key.checksum = checkKey(key);
 763         return key;
 764     }
 765 
 766     /** create a new key for a named object.
 767      *
 768      * &lt;P&gt; Keys contain their own checksum instead of using
 769      * the heavy-weight CheckedMessage wrapper.
 770      */
 771     private Key getKey(int type, String name) {
 772         Key key = new Key();
 773         key.type = type;
 774         key.name = name;
 775         key.checksum = checkKey(key);
 776         return key;
 777     }
 778 
 779     /** keys need to be strings, serialize and encode. */
 780     private String keyToBackupKey(Key key) {
 781         return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 782     }
 783 
 784     /** keys need to be strings, decode and parse. */
 785     private Key backupKeyToKey(String backupKey) throws InvalidBackupException {
 786         try {
 787             Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 788             if (key.checksum != checkKey(key)) {
 789                 key = null;
 790                 throw new InvalidBackupException(&quot;invalid key read from stream&quot; + backupKey);
 791             }
 792             return key;
 793         } catch (InvalidProtocolBufferNanoException e) {
 794             throw new InvalidBackupException(e);
 795         } catch (IllegalArgumentException e) {
 796             throw new InvalidBackupException(e);
 797         }
 798     }
 799 
 800     /** Compute the checksum over the important bits of a key. */
 801     private long checkKey(Key key) {
 802         CRC32 checksum = new CRC32();
 803         checksum.update(key.type);
 804         checksum.update((int) (key.id &amp; 0xffff));
 805         checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 806         if (!TextUtils.isEmpty(key.name)) {
 807             checksum.update(key.name.getBytes());
 808         }
 809         return checksum.getValue();
 810     }
 811 
 812     /**
 813      * @return the current device profile information.
 814      */
 815     private boolean isReplaceableHotseatItem(Favorite favorite) {
<abbr title=" 816         return ((favorite.container == Favorites.CONTAINER_HOTSEAT) &amp;&amp; (favorite.intent != null)) &amp;&amp; ((favorite.itemType == Favorites.ITEM_TYPE_APPLICATION) || (favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT));"> 816         return ((favorite.container == Favorites.CONTAINER_HOTSEAT) &amp;&amp; (favorite.intent != null)) &amp;&amp; ((fa</abbr>
 817     }
 818 
 819     /** Serialize a Favorite for persistence, including a checksum wrapper. */
 820     private Favorite packFavorite(Cursor c) {
 821         Favorite favorite = new Favorite();
 822         favorite.id = c.getLong(ID_INDEX);
 823         favorite.screen = c.getInt(SCREEN_INDEX);
 824         favorite.container = c.getInt(CONTAINER_INDEX);
 825         favorite.cellX = c.getInt(CELLX_INDEX);
 826         favorite.cellY = c.getInt(CELLY_INDEX);
 827         favorite.spanX = c.getInt(SPANX_INDEX);
 828         favorite.spanY = c.getInt(SPANY_INDEX);
 829         favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 830         favorite.rank = c.getInt(RANK_INDEX);
 831         String title = c.getString(TITLE_INDEX);
 832         if (!TextUtils.isEmpty(title)) {
 833             favorite.title = title;
 834         }
 835         String intentDescription = c.getString(INTENT_INDEX);
 836         Intent intent = null;
 837         if (!TextUtils.isEmpty(intentDescription)) {
 838             try {
 839                 intent = Intent.parseUri(intentDescription, 0);
 840                 intent.removeExtra(ItemInfo.EXTRA_PROFILE);
 841                 favorite.intent = intent.toUri(0);
 842             } catch (URISyntaxException e) {
 843                 Log.e(TAG, &quot;Invalid intent&quot;, e);
 844             }
 845         }
 846         favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 847         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 848             favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 849             String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 850             if (!TextUtils.isEmpty(appWidgetProvider)) {
 851                 favorite.appWidgetProvider = appWidgetProvider;
 852             }
 853         } else if (favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT) {
 854             if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 855                 String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 856                 if (!TextUtils.isEmpty(iconPackage)) {
 857                     favorite.iconPackage = iconPackage;
 858                 }
 859                 String iconResource = c.getString(ICON_RESOURCE_INDEX);
 860                 if (!TextUtils.isEmpty(iconResource)) {
 861                     favorite.iconResource = iconResource;
 862                 }
 863             }
 864             byte[] blob = c.getBlob(ICON_INDEX);
 865             if ((blob != null) &amp;&amp; (blob.length &gt; 0)) {
 866                 favorite.icon = blob;
 867             }
 868         }
 869         if (isReplaceableHotseatItem(favorite)) {
 870             if ((intent != null) &amp;&amp; (intent.getComponent() != null)) {
 871                 PackageManager pm = mContext.getPackageManager();
 872                 ActivityInfo activity = null;
 873                 try {
 874                     activity = pm.getActivityInfo(intent.getComponent(), 0);
 875                 } catch (NameNotFoundException e) {
 876                     Log.e(TAG, &quot;Target not found&quot;, e);
 877                 }
 878                 if (activity == null) {
 879                     return favorite;
 880                 }
 881                 for (int i = 0; i &lt; mItemTypeMatchers.length; i++) {
 882                     if (mItemTypeMatchers[i] == null) {
<abbr title=" 883                         mItemTypeMatchers[i] = new ItemTypeMatcher(CommonAppTypeParser.getResourceForItemType(i));"> 883                         mItemTypeMatchers[i] = new ItemTypeMatcher(CommonAppTypeParser.getResourceForItem</abbr>
 884                     }
 885                     if (mItemTypeMatchers[i].matches(activity, pm)) {
 886                         favorite.targetType = i;
 887                         break;
 888                     }
 889                 }
 890             }
 891         }
 892         return favorite;
 893     }
 894 
 895     /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 896     private ContentValues unpackFavorite(byte[] buffer, int dataSize) throws IOException {
 897         Favorite favorite = unpackProto(new Favorite(), buffer, dataSize);
 898         // If it is a hotseat item, move it accordingly.
 899         if (favorite.container == Favorites.CONTAINER_HOTSEAT) {
 900             favorite.screen += mHotseatShift;
 901         }
 902         ContentValues values = new ContentValues();
 903         values.put(Favorites._ID, favorite.id);
 904         values.put(Favorites.SCREEN, favorite.screen);
 905         values.put(Favorites.CONTAINER, favorite.container);
 906         values.put(Favorites.CELLX, favorite.cellX);
 907         values.put(Favorites.CELLY, favorite.cellY);
 908         values.put(Favorites.SPANX, favorite.spanX);
 909         values.put(Favorites.SPANY, favorite.spanY);
 910         values.put(Favorites.RANK, favorite.rank);
 911         if (favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT) {
 912             values.put(Favorites.ICON_TYPE, favorite.iconType);
 913             if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 914                 values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 915                 values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 916             }
 917             values.put(Favorites.ICON, favorite.icon);
 918         }
 919         if (!TextUtils.isEmpty(favorite.title)) {
 920             values.put(Favorites.TITLE, favorite.title);
 921         } else {
 922             values.put(Favorites.TITLE, &quot;&quot;);
 923         }
 924         if (!TextUtils.isEmpty(favorite.intent)) {
 925             values.put(Favorites.INTENT, favorite.intent);
 926         }
 927         values.put(Favorites.ITEM_TYPE, favorite.itemType);
 928         UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
<abbr title=" 929         long userSerialNumber = UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHandle);"> 929         long userSerialNumber = UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHand</abbr>
 930         values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
 931         // If we will attempt grid resize, use the original profile to validate grid size, as
 932         // anything which fits in the original grid should fit in the current grid after
 933         // grid migration.
<abbr title=" 934         DeviceProfieData currentProfile = (migrationCompatibleProfileData == null) ? mDeviceProfileData : migrationCompatibleProfileData;"> 934         DeviceProfieData currentProfile = (migrationCompatibleProfileData == null) ? mDeviceProfileData :</abbr>
 935         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 936             if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 937                 values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 938             }
 939             values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
<abbr title=" 940             values.put(LauncherSettings.Favorites.RESTORED, (LauncherAppWidgetInfo.FLAG_ID_NOT_VALID | LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) | LauncherAppWidgetInfo.FLAG_UI_NOT_READY);"> 940             values.put(LauncherSettings.Favorites.RESTORED, (LauncherAppWidgetInfo.FLAG_ID_NOT_VALID | La</abbr>
 941             // Verify placement
<abbr title=" 942             if (((favorite.cellX + favorite.spanX) &gt; currentProfile.desktopCols) || ((favorite.cellY + favorite.spanY) &gt; currentProfile.desktopRows)) {"> 942             if (((favorite.cellX + favorite.spanX) &gt; currentProfile.desktopCols) || ((favorite.cellY + fa</abbr>
 943                 restoreSuccessful = false;
 944                 throw new InvalidBackupException(&quot;Widget not in screen bounds, aborting restore&quot;);
 945             }
 946         } else {
 947             // Check if it is an hotseat item, that can be replaced.
<abbr title=" 948             if ((isReplaceableHotseatItem(favorite) &amp;&amp; (favorite.targetType != Favorite.TARGET_NONE)) &amp;&amp; (favorite.targetType &lt; CommonAppTypeParser.SUPPORTED_TYPE_COUNT)) {"> 948             if ((isReplaceableHotseatItem(favorite) &amp;&amp; (favorite.targetType != Favorite.TARGET_NONE)) &amp;&amp; </abbr>
 949                 Log.e(TAG, &quot;Added item type flag&quot;);
<abbr title=" 950                 values.put(LauncherSettings.Favorites.RESTORED, 1 | CommonAppTypeParser.encodeItemTypeToFlag(favorite.targetType));"> 950                 values.put(LauncherSettings.Favorites.RESTORED, 1 | CommonAppTypeParser.encodeItemTypeToF</abbr>
 951             } else {
 952                 // Let LauncherModel know we&#x27;ve been here.
 953                 values.put(LauncherSettings.Favorites.RESTORED, 1);
 954             }
 955             // Verify placement
 956             if (favorite.container == Favorites.CONTAINER_HOTSEAT) {
<abbr title=" 957                 if ((favorite.screen &gt;= currentProfile.hotseatCount) || (favorite.screen == currentProfile.allappsRank)) {"> 957                 if ((favorite.screen &gt;= currentProfile.hotseatCount) || (favorite.screen == currentProfil</abbr>
 958                     restoreSuccessful = false;
 959                     throw new InvalidBackupException(&quot;Item not in hotseat bounds, aborting restore&quot;);
 960                 }
<abbr title=" 961             } else if ((favorite.cellX &gt;= currentProfile.desktopCols) || (favorite.cellY &gt;= currentProfile.desktopRows)) {"> 961             } else if ((favorite.cellX &gt;= currentProfile.desktopCols) || (favorite.cellY &gt;= currentProfil</abbr>
 962                 restoreSuccessful = false;
 963                 throw new InvalidBackupException(&quot;Item not in desktop bounds, aborting restore&quot;);
 964             }
 965         }
 966         return values;
 967     }
 968 
 969     /** Serialize a Screen for persistence, including a checksum wrapper. */
 970     private Screen packScreen(Cursor c) {
 971         Screen screen = new Screen();
 972         screen.id = c.getLong(ID_INDEX);
 973         screen.rank = c.getInt(SCREEN_RANK_INDEX);
 974         return screen;
 975     }
 976 
 977     /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 978     private ContentValues unpackScreen(byte[] buffer, int dataSize)
 979             throws InvalidProtocolBufferNanoException {
 980         Screen screen = unpackProto(new Screen(), buffer, dataSize);
 981         ContentValues values = new ContentValues();
 982         values.put(WorkspaceScreens._ID, screen.id);
 983         values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 984         return values;
 985     }
 986 
 987     /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 988     private Resource packIcon(int dpi, Bitmap icon) {
 989         Resource res = new Resource();
 990         res.dpi = dpi;
 991         res.data = Utilities.flattenBitmap(icon);
 992         return res;
 993     }
 994 
 995     /** Serialize a widget for persistence, including a checksum wrapper. */
 996     private Widget packWidget(int dpi, ComponentName provider, UserHandleCompat user) {
<abbr title=" 997         final LauncherAppWidgetProviderInfo info = LauncherModel.getProviderInfo(mContext, provider, user);"> 997         final LauncherAppWidgetProviderInfo info = LauncherModel.getProviderInfo(mContext, provider, user</abbr>
 998         Widget widget = new Widget();
 999         widget.provider = provider.flattenToShortString();
1000         widget.label = info.label;
1001         widget.configure = info.configure != null;
1002         if (info.icon != 0) {
1003             widget.icon = new Resource();
1004             Drawable fullResIcon = mIconCache.getFullResIcon(provider.getPackageName(), info.icon);
1005             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
1006             widget.icon.data = Utilities.flattenBitmap(icon);
1007             widget.icon.dpi = dpi;
1008         }
1009         Point spans = info.getMinSpans(mIdp, mContext);
1010         widget.minSpanX = spans.x;
1011         widget.minSpanY = spans.y;
1012         return widget;
1013     }
1014 
1015     /**
1016      * Deserialize a proto after verifying checksum wrapper.
1017      */
1018     private &lt;T extends MessageNano&gt; T unpackProto(T proto, byte[] buffer, int dataSize)
1019             throws InvalidProtocolBufferNanoException {
1020         MessageNano.mergeFrom(proto, readCheckedBytes(buffer, dataSize));
1021         if (DEBUG) Log.d(TAG, &quot;unpacked proto &quot; + proto);
1022         return proto;
1023     }
1024 
1025     /**
1026      * Read the old journal from the input file.
1027      *
1028      * In the event of any error, just pretend we didn&#x27;t have a journal,
1029      * in that case, do a full backup.
1030      *
1031      * @param oldState the read-0only file descriptor pointing to the old journal
1032      * @return a Journal protocol buffer
1033      */
1034     private Journal readJournal(ParcelFileDescriptor oldState) {
1035         Journal journal = new Journal();
1036         if (oldState == null) {
1037             return journal;
1038         }
1039         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
1040         try {
1041             int availableBytes = inStream.available();
1042             if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
1043             if (availableBytes &lt; MAX_JOURNAL_SIZE) {
1044                 byte[] buffer = new byte[availableBytes];
1045                 int bytesRead = 0;
1046                 boolean valid = false;
1047                 InvalidProtocolBufferNanoException lastProtoException = null;
1048                 while (availableBytes &gt; 0) {
1049                     try {
1050                         // OMG what are you doing? This is crazy inefficient!
1051                         // If we read a byte that is not ours, we will cause trouble: b/12491813
1052                         // However, we don&#x27;t know how many bytes to expect (oops).
1053                         // So we have to step through *slowly*, watching for the end.
1054                         int result = inStream.read(buffer, bytesRead, 1);
1055                         if (result &gt; 0) {
1056                             availableBytes -= result;
1057                             bytesRead += result;
1058                         } else {
1059                             Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1060                             // stop reading and see what there is to parse
1061                             availableBytes = 0;
1062                         }
1063                     } catch (IOException e) {
1064                         buffer = null;
1065                         availableBytes = 0;
1066                     }
1067 
1068                     // check the buffer to see if we have a valid journal
1069                     try {
1070                         MessageNano.mergeFrom(journal, readCheckedBytes(buffer, bytesRead));
1071                         // if we are here, then we have read a valid, checksum-verified journal
1072                         valid = true;
1073                         availableBytes = 0;
1074                         if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1075                     } catch (InvalidProtocolBufferNanoException e) {
1076                         // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1077                         lastProtoException = e;
1078                         journal.clear();
1079                     }
1080                 }
1081                 if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1082                 if (!valid) {
1083                     Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1084                 }
1085             }
1086         } catch (IOException e) {
1087             Log.w(TAG, &quot;failed to close the journal&quot;, e);
1088         } finally {
1089             try {
1090                 inStream.close();
1091             } catch (IOException e) {
1092                 Log.w(TAG, &quot;failed to close the journal&quot;, e);
1093             }
1094         }
1095         return journal;
1096     }
1097 
1098     private void writeRowToBackup(Key key, MessageNano proto, BackupDataOutput data)
1099             throws IOException {
1100         writeRowToBackup(keyToBackupKey(key), proto, data);
1101     }
1102 
<abbr title="1103     private void writeRowToBackup(String backupKey, MessageNano proto, BackupDataOutput data) throws IOException {">1103     private void writeRowToBackup(String backupKey, MessageNano proto, BackupDataOutput data) throws IOEx</abbr>
1104         byte[] blob = writeCheckedBytes(proto);
1105         data.writeEntityHeader(backupKey, blob.length);
1106         data.writeEntityData(blob, blob.length);
1107         mBackupDataWasUpdated = true;
1108         if (VERBOSE) {
1109             Log.v(TAG, &quot;Writing New entry &quot; + backupKey);
1110         }
1111     }
1112 
1113     /**
1114      * Write the new journal to the output file.
1115      *
1116      * In the event of any error, just pretend we didn&#x27;t have a journal,
1117      * in that case, do a full backup.
1118 
1119      * @param newState the write-only file descriptor pointing to the new journal
1120      * @param journal a Journal protocol buffer
1121      */
1122     private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1123         FileOutputStream outStream = null;
1124         try {
1125             outStream = new FileOutputStream(newState.getFileDescriptor());
1126             final byte[] journalBytes = writeCheckedBytes(journal);
1127             outStream.write(journalBytes);
1128             outStream.close();
1129             if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1130         } catch (IOException e) {
1131             Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1132         }
1133     }
1134 
1135     /** Wrap a proto in a CheckedMessage and compute the checksum. */
1136     private byte[] writeCheckedBytes(MessageNano proto) {
1137         CheckedMessage wrapper = new CheckedMessage();
1138         wrapper.payload = MessageNano.toByteArray(proto);
1139         CRC32 checksum = new CRC32();
1140         checksum.update(wrapper.payload);
1141         wrapper.checksum = checksum.getValue();
1142         return MessageNano.toByteArray(wrapper);
1143     }
1144 
1145     /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1146     private static byte[] readCheckedBytes(byte[] buffer, int dataSize)
1147             throws InvalidProtocolBufferNanoException {
1148         CheckedMessage wrapper = new CheckedMessage();
1149         MessageNano.mergeFrom(wrapper, buffer, 0, dataSize);
1150         CRC32 checksum = new CRC32();
1151         checksum.update(wrapper.payload);
1152         if (wrapper.checksum != checksum.getValue()) {
1153             throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1154         }
1155         return wrapper.payload;
1156     }
1157 
1158     /**
1159      * @return true if the launcher is in a state to support backup
1160      */
1161     private boolean launcherIsReady() {
1162         ContentResolver cr = mContext.getContentResolver();
1163         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);
1164         if (cursor == null) {
1165             // launcher data has been wiped, do nothing
1166             return false;
1167         }
1168         cursor.close();
1169         if (LauncherAppState.getInstanceNoCreate() == null) {
1170             // launcher services are unavailable, try again later
1171             return false;
1172         }
1173         return true;
1174     }
1175 
1176     private String getUserSelectionArg() {
1177         return Favorites.PROFILE_ID + &#x27;=&#x27; + UserManagerCompat.getInstance(mContext)
1178                 .getSerialNumberForUser(UserHandleCompat.myUserHandle());
1179     }
1180 
1181     @Thunk
1182     class InvalidBackupException extends IOException {
1183         private static final long serialVersionUID = 8931456637211665082L;
1184 
1185         @Thunk
1186         InvalidBackupException(Throwable cause) {
1187             super(cause);
1188         }
1189 
1190         @Thunk
1191         InvalidBackupException(String reason) {
1192             super(reason);
1193         }
1194     }
1195 
1196     public boolean shouldAttemptWorkspaceMigration() {
1197         return migrationCompatibleProfileData != null;
1198     }
1199 
1200     /**
1201      * A class to check if an activity can handle one of the intents from a list of
1202      * predefined intents.
1203      */
1204     private class ItemTypeMatcher {
1205         private final ArrayList&lt;Intent&gt; mIntents;
1206 
1207         ItemTypeMatcher(int xml_res) {
1208             mIntents = (xml_res == 0) ? new ArrayList&lt;Intent&gt;() : parseIntents(xml_res);
1209         }
1210 
1211         private ArrayList&lt;Intent&gt; parseIntents(int xml_res) {
1212             ArrayList&lt;Intent&gt; intents = new ArrayList&lt;Intent&gt;();
1213             XmlResourceParser parser = mContext.getResources().getXml(xml_res);
1214             try {
1215                 DefaultLayoutParser.beginDocument(parser, DefaultLayoutParser.TAG_RESOLVE);
1216                 final int depth = parser.getDepth();
1217                 int type;
<abbr title="1218                 while ((((type = parser.next()) != XmlPullParser.END_TAG) || (parser.getDepth() &gt; depth)) &amp;&amp; (type != XmlPullParser.END_DOCUMENT)) {">1218                 while ((((type = parser.next()) != XmlPullParser.END_TAG) || (parser.getDepth() &gt; depth))</abbr>
1219                     if (type != XmlPullParser.START_TAG) {
1220                         continue;
1221                     } else if (DefaultLayoutParser.TAG_FAVORITE.equals(parser.getName())) {
<abbr title="1222                         final String uri = DefaultLayoutParser.getAttributeValue(parser, DefaultLayoutParser.ATTR_URI);">1222                         final String uri = DefaultLayoutParser.getAttributeValue(parser, DefaultLayoutPar</abbr>
1223                         intents.add(Intent.parseUri(uri, 0));
1224                     }
1225                 }
1226             } catch (URISyntaxException | XmlPullParserException | IOException e) {
1227                 Log.e(TAG, &quot;Unable to parse &quot; + xml_res, e);
1228             } finally {
1229                 parser.close();
1230             }
1231             return intents;
1232         }
1233 
1234         public boolean matches(ActivityInfo activity, PackageManager pm) {
1235             for (Intent intent : mIntents) {
1236                 intent.setPackage(activity.packageName);
1237                 ResolveInfo info = pm.resolveActivity(intent, 0);
<abbr title="1238                 if ((info != null) &amp;&amp; (info.activityInfo.name.equals(activity.name) || info.activityInfo.name.equals(activity.targetActivity))) {">1238                 if ((info != null) &amp;&amp; (info.activityInfo.name.equals(activity.name) || info.activityInfo.</abbr>
1239                     return true;
1240                 }
1241             }
1242             return false;
1243         }
1244     }
1245 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2013 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  package com.android.launcher3;
  17  
  18  import android.app.backup.BackupDataInputStream;
  19  import android.app.backup.BackupDataOutput;
  20  import android.app.backup.BackupHelper;
  21  import android.app.backup.BackupManager;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  22 -import android.appwidget.AppWidgetManager;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  23 -import android.appwidget.AppWidgetProviderInfo;</span>
  24  import android.content.ComponentName;
  25  import android.content.ContentResolver;
  26  import android.content.ContentValues;
  27  import android.content.Context;
  28  import android.content.Intent;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 +import android.content.pm.ActivityInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  30 +import android.content.pm.PackageManager;</span>
  31  import android.content.pm.PackageManager.NameNotFoundException;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  32 +import android.content.pm.ResolveInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  33 +import android.content.res.XmlResourceParser;</span>
  34  import android.database.Cursor;
  35  import android.graphics.Bitmap;
  36  import android.graphics.BitmapFactory;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  37 +import android.graphics.Point;</span>
  38  import android.graphics.drawable.Drawable;
  39  import android.os.ParcelFileDescriptor;
  40  import android.text.TextUtils;
  41  import android.util.Base64;
  42  import android.util.Log;
  43  
  44  import com.android.launcher3.LauncherSettings.Favorites;
  45  import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  46  import com.android.launcher3.backup.BackupProtos;
  47  import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  48  import com.android.launcher3.backup.BackupProtos.DeviceProfieData;
  49  import com.android.launcher3.backup.BackupProtos.Favorite;
  50  import com.android.launcher3.backup.BackupProtos.Journal;
  51  import com.android.launcher3.backup.BackupProtos.Key;
  52  import com.android.launcher3.backup.BackupProtos.Resource;
  53  import com.android.launcher3.backup.BackupProtos.Screen;
  54  import com.android.launcher3.backup.BackupProtos.Widget;
  55  import com.android.launcher3.compat.UserHandleCompat;
  56  import com.android.launcher3.compat.UserManagerCompat;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  57 +import com.android.launcher3.model.MigrateFromRestoreTask;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  58 +import com.android.launcher3.util.Thunk;</span>
  59  import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  60  import com.google.protobuf.nano.MessageNano;
  61  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  62 -import java.io.ByteArrayOutputStream;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  63 +import org.xmlpull.v1.XmlPullParser;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  64 +import org.xmlpull.v1.XmlPullParserException;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  65 +</span>
  66  import java.io.FileInputStream;
  67  import java.io.FileOutputStream;
  68  import java.io.IOException;
  69  import java.net.URISyntaxException;
  70  import java.util.ArrayList;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  71 -import java.util.HashMap;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  72 +import java.util.Arrays;</span>
  73  import java.util.HashSet;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  74 -import java.util.List;</span>
  75  import java.util.zip.CRC32;
  76  
  77  /**
  78   * Persist the launcher home state across calamities.
  79   */
  80  public class LauncherBackupHelper implements BackupHelper {
  81      private static final String TAG = &quot;LauncherBackupHelper&quot;;
  82      private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  83      private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  84  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  85 -    private static final int BACKUP_VERSION = 2;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  86 +    private static final int BACKUP_VERSION = 4;</span>
  87      private static final int MAX_JOURNAL_SIZE = 1000000;
  88  
  89      // Journal key is such that it is always smaller than any dynamically generated
  90      // key (any Base64 encoded string).
  91      private static final String JOURNAL_KEY = &quot;#&quot;;
  92  
  93      /** icons are large, dribble them out */
  94      private static final int MAX_ICONS_PER_PASS = 10;
  95  
  96      /** widgets contain previews, which are very large, dribble them out */
  97      private static final int MAX_WIDGETS_PER_PASS = 5;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  98 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  99 -    private static final int IMAGE_COMPRESSION_QUALITY = 75;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 100 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 101 -    private static final Bitmap.CompressFormat IMAGE_FORMAT =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 102 -            android.graphics.Bitmap.CompressFormat.PNG;</span>
 103  
 104      private static final String[] FAVORITE_PROJECTION = {
 105          Favorites._ID,                     // 0
 106          Favorites.MODIFIED,                // 1
 107          Favorites.INTENT,                  // 2
 108          Favorites.APPWIDGET_PROVIDER,      // 3
 109          Favorites.APPWIDGET_ID,            // 4
 110          Favorites.CELLX,                   // 5
 111          Favorites.CELLY,                   // 6
 112          Favorites.CONTAINER,               // 7
 113          Favorites.ICON,                    // 8
 114          Favorites.ICON_PACKAGE,            // 9
 115          Favorites.ICON_RESOURCE,           // 10
 116          Favorites.ICON_TYPE,               // 11
 117          Favorites.ITEM_TYPE,               // 12
 118          Favorites.SCREEN,                  // 13
 119          Favorites.SPANX,                   // 14
 120          Favorites.SPANY,                   // 15
 121          Favorites.TITLE,                   // 16
 122          Favorites.PROFILE_ID,              // 17
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 123 +        Favorites.RANK,                    // 18</span>
 124      };
 125  
 126      private static final int ID_INDEX = 0;
 127      private static final int ID_MODIFIED = 1;
 128      private static final int INTENT_INDEX = 2;
 129      private static final int APPWIDGET_PROVIDER_INDEX = 3;
 130      private static final int APPWIDGET_ID_INDEX = 4;
 131      private static final int CELLX_INDEX = 5;
 132      private static final int CELLY_INDEX = 6;
 133      private static final int CONTAINER_INDEX = 7;
 134      private static final int ICON_INDEX = 8;
 135      private static final int ICON_PACKAGE_INDEX = 9;
 136      private static final int ICON_RESOURCE_INDEX = 10;
 137      private static final int ICON_TYPE_INDEX = 11;
 138      private static final int ITEM_TYPE_INDEX = 12;
 139      private static final int SCREEN_INDEX = 13;
 140      private static final int SPANX_INDEX = 14;
 141      private static final int SPANY_INDEX = 15;
 142      private static final int TITLE_INDEX = 16;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 143 +    private static final int RANK_INDEX = 18;</span>
 144  
 145      private static final String[] SCREEN_PROJECTION = {
 146          WorkspaceScreens._ID,              // 0
 147          WorkspaceScreens.MODIFIED,         // 1
 148          WorkspaceScreens.SCREEN_RANK       // 2
 149      };
 150  
 151      private static final int SCREEN_RANK_INDEX = 2;
 152  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 153 -    private final Context mContext;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 154 +    @Thunk final Context mContext;</span>
 155      private final HashSet&lt;String&gt; mExistingKeys;
 156      private final ArrayList&lt;Key&gt; mKeys;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 157 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 158 -    private IconCache mIconCache;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 159 +    private final ItemTypeMatcher[] mItemTypeMatchers;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 160 +    private final long mUserSerial;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 161 +</span>
 162      private BackupManager mBackupManager;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 163 -    private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;</span>
 164      private byte[] mBuffer = new byte[512];
 165      private long mLastBackupRestoreTime;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 166 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 167 -    private DeviceProfieData mCurrentProfile;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 168 +    private boolean mBackupDataWasUpdated;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 169 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 170 +    private IconCache mIconCache;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 171 +    private DeviceProfieData mDeviceProfileData;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 172 +    private InvariantDeviceProfile mIdp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 173 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 174 +    DeviceProfieData migrationCompatibleProfileData;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 175 +    HashSet&lt;String&gt; widgetSizes = new HashSet&lt;&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 176 +</span>
 177      boolean restoreSuccessful;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 178 +    int restoredBackupVersion = 1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 179 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 180 +    // When migrating from a device which different hotseat configuration, the icons are shifted</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 181 +    // to center along the new all-apps icon.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 182 +    private int mHotseatShift = 0;</span>
 183  
 184      public LauncherBackupHelper(Context context) {
 185          mContext = context;
 186          mExistingKeys = new HashSet&lt;String&gt;();
 187          mKeys = new ArrayList&lt;Key&gt;();
 188          restoreSuccessful = true;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 189 +        mItemTypeMatchers = new ItemTypeMatcher[CommonAppTypeParser.SUPPORTED_TYPE_COUNT];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 190 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 191 +        UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 192 +        mUserSerial = userManager.getSerialNumberForUser(UserHandleCompat.myUserHandle());</span>
 193      }
 194  
 195      private void dataChanged() {
 196          if (mBackupManager == null) {
 197              mBackupManager = new BackupManager(mContext);
 198          }
 199          mBackupManager.dataChanged();
 200      }
 201  
 202      private void applyJournal(Journal journal) {
 203          mLastBackupRestoreTime = journal.t;
 204          mExistingKeys.clear();
 205          if (journal.key != null) {
 206              for (Key key : journal.key) {
 207                  mExistingKeys.add(keyToBackupKey(key));
 208              }
 209          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 210 +        restoredBackupVersion = journal.backupVersion;</span>
 211      }
 212  
 213      /**
 214       * Back up launcher data so we can restore the user&#x27;s state on a new device.
 215       *
 216       * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 217       *
 218       * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 219       *
 220       * @param oldState notes from the last backup
 221       * @param data incremental key/value pairs to persist off-device
 222       * @param newState notes for the next backup
 223       */
 224      @Override
 225      public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 226              ParcelFileDescriptor newState) {
 227          if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 228  
 229          Journal in = readJournal(oldState);
 230          if (!launcherIsReady()) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 231 +            dataChanged();</span>
 232              // Perform backup later.
 233              writeJournal(newState, in);
 234              return;
 235          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 236 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 237 +        if (mDeviceProfileData == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 238 +            LauncherAppState app = LauncherAppState.getInstance();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 239 +            mIdp = app.getInvariantDeviceProfile();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 240 +            mDeviceProfileData = initDeviceProfileData(mIdp);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 241 +            mIconCache = app.getIconCache();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 242 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 243 +</span>
 244          Log.v(TAG, &quot;lastBackupTime = &quot; + in.t);
 245          mKeys.clear();
 246          applyJournal(in);
 247  
 248          // Record the time before performing backup so that entries edited while the backup
 249          // was going on, do not get missed in next backup.
 250          long newBackupTime = System.currentTimeMillis();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 251 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 252 +        mBackupDataWasUpdated = false;</span>
 253          try {
 254              backupFavorites(data);
 255              backupScreens(data);
 256              backupIcons(data);
 257              backupWidgets(data);
 258  
 259              // Delete any key which still exist in the old backup, but is not valid anymore.
 260              HashSet&lt;String&gt; validKeys = new HashSet&lt;String&gt;();
 261              for (Key key : mKeys) {
 262                  validKeys.add(keyToBackupKey(key));
 263              }
 264              mExistingKeys.removeAll(validKeys);
 265  
 266              // Delete anything left in the existing keys.
 267              for (String deleted: mExistingKeys) {
 268                  if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
 269                  data.writeEntityHeader(deleted, -1);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 270 +                mBackupDataWasUpdated = true;</span>
 271              }
 272  
 273              mExistingKeys.clear();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 274 -            mLastBackupRestoreTime = newBackupTime;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 275 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 276 -            // We store the journal at two places.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 277 -            //   1) Storing it in newState allows us to do partial backups by comparing old state</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 278 -            //   2) Storing it in backup data allows us to validate keys during restore</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 279 -            Journal state = getCurrentStateJournal();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 280 -            writeRowToBackup(JOURNAL_KEY, state, data);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 281 +            if (!mBackupDataWasUpdated) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 282 +                // Check if any metadata has changed</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 283 +                mBackupDataWasUpdated = (in.profile == null)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 284 +                        || !Arrays.equals(DeviceProfieData.toByteArray(in.profile),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 285 +                            DeviceProfieData.toByteArray(mDeviceProfileData))</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 286 +                        || (in.backupVersion != BACKUP_VERSION)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 287 +                        || (in.appVersion != getAppVersion());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 288 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 289 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 290 +            if (mBackupDataWasUpdated) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 291 +                mLastBackupRestoreTime = newBackupTime;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 292 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 293 +                // We store the journal at two places.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 294 +                //   1) Storing it in newState allows us to do partial backups by comparing old state</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 295 +                //   2) Storing it in backup data allows us to validate keys during restore</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 296 +                Journal state = getCurrentStateJournal();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 297 +                writeRowToBackup(JOURNAL_KEY, state, data);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 298 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 299 +                if (DEBUG) Log.d(TAG, &quot;Nothing was written during backup&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 300 +            }</span>
 301          } catch (IOException e) {
 302              Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 303          }
 304  
 305          writeNewStateDescription(newState);
 306      }
 307  
 308      /**
 309       * @return true if the backup corresponding to oldstate can be successfully applied
 310       * to this device.
 311       */
 312      private boolean isBackupCompatible(Journal oldState) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 313 -        DeviceProfieData currentProfile = getDeviceProfieData();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 314 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 315 +        DeviceProfieData currentProfile = mDeviceProfileData;</span>
 316          DeviceProfieData oldProfile = oldState.profile;
 317  
 318          if (oldProfile == null || oldProfile.desktopCols == 0) {
 319              // Profile info is not valid, ignore the check.
 320              return true;
 321          }
 322  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 323 -        boolean isHotsetCompatible = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 324 +        boolean isHotseatCompatible = false;</span>
 325          if (currentProfile.allappsRank &gt;= oldProfile.hotseatCount) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 326 -            isHotsetCompatible = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 327 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 328 -        if ((currentProfile.hotseatCount &gt;= oldProfile.hotseatCount) &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 329 -                (currentProfile.allappsRank == oldProfile.allappsRank)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 330 -            isHotsetCompatible = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 331 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 332 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 333 -        return isHotsetCompatible &amp;&amp; (currentProfile.desktopCols &gt;= oldProfile.desktopCols)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 334 -                &amp;&amp; (currentProfile.desktopRows &gt;= oldProfile.desktopRows);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 335 +            isHotseatCompatible = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 336 +            mHotseatShift = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 337 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 338 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 339 +        if ((currentProfile.allappsRank &gt;= oldProfile.allappsRank)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 340 +                &amp;&amp; ((currentProfile.hotseatCount - currentProfile.allappsRank) &gt;=</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 341 +                        (oldProfile.hotseatCount - oldProfile.allappsRank))) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 342 +            // There is enough space on both sides of the hotseat.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 343 +            isHotseatCompatible = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 344 +            mHotseatShift = currentProfile.allappsRank - oldProfile.allappsRank;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 345 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 346 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 347 +        if (!isHotseatCompatible) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 348 +            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 349 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 350 +        if ((currentProfile.desktopCols &gt;= oldProfile.desktopCols)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 351 +                &amp;&amp; (currentProfile.desktopRows &gt;= oldProfile.desktopRows)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 352 +            return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 353 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 354 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 355 +        if (MigrateFromRestoreTask.ENABLED &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 356 +                (oldProfile.desktopCols - currentProfile.desktopCols &lt;= 1) &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 357 +                (oldProfile.desktopRows - currentProfile.desktopRows &lt;= 1)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 358 +            // Allow desktop migration when row and/or column count contracts by 1.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 359 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 360 +            migrationCompatibleProfileData = initDeviceProfileData(mIdp);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 361 +            migrationCompatibleProfileData.desktopCols = oldProfile.desktopCols;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 362 +            migrationCompatibleProfileData.desktopRows = oldProfile.desktopRows;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 363 +            return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 364 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 365 +        return false;</span>
 366      }
 367  
 368      /**
 369       * Restore launcher configuration from the restored data stream.
 370       * It assumes that the keys will arrive in lexical order. So if the journal was present in the
 371       * backup, it should arrive first.
 372       *
 373       * @param data the key/value pair from the server
 374       */
 375      @Override
 376      public void restoreEntity(BackupDataInputStream data) {
 377          if (!restoreSuccessful) {
 378              return;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 379 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 380 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 381 +        if (mDeviceProfileData == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 382 +            // This call does not happen on a looper thread. So LauncherAppState</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 383 +            // can&#x27;t be created . Instead initialize required dependencies directly.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 384 +            mIdp = new InvariantDeviceProfile(mContext);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 385 +            mDeviceProfileData = initDeviceProfileData(mIdp);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 386 +            mIconCache = new IconCache(mContext, mIdp);</span>
 387          }
 388  
 389          int dataSize = data.size();
 390          if (mBuffer.length &lt; dataSize) {
 391              mBuffer = new byte[dataSize];
 392          }
 393          try {
 394              int bytesRead = data.read(mBuffer, 0, dataSize);
 395              if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 396              String backupKey = data.getKey();
 397  
 398              if (JOURNAL_KEY.equals(backupKey)) {
 399                  if (VERBOSE) Log.v(TAG, &quot;Journal entry restored&quot;);
 400                  if (!mKeys.isEmpty()) {
 401                      // We received the journal key after a restore key.
 402                      Log.wtf(TAG, keyToBackupKey(mKeys.get(0)) + &quot; received after &quot; + JOURNAL_KEY);
 403                      restoreSuccessful = false;
 404                      return;
 405                  }
 406  
 407                  Journal journal = new Journal();
 408                  MessageNano.mergeFrom(journal, readCheckedBytes(mBuffer, dataSize));
 409                  applyJournal(journal);
 410                  restoreSuccessful = isBackupCompatible(journal);
 411                  return;
 412              }
 413  
 414              if (!mExistingKeys.isEmpty() &amp;&amp; !mExistingKeys.contains(backupKey)) {
 415                  if (DEBUG) Log.e(TAG, &quot;Ignoring key not present in the backup state &quot; + backupKey);
 416                  return;
 417              }
 418              Key key = backupKeyToKey(backupKey);
 419              mKeys.add(key);
 420              switch (key.type) {
 421                  case Key.FAVORITE:
 422                      restoreFavorite(key, mBuffer, dataSize);
 423                      break;
 424  
 425                  case Key.SCREEN:
 426                      restoreScreen(key, mBuffer, dataSize);
 427                      break;
 428  
 429                  case Key.ICON:
 430                      restoreIcon(key, mBuffer, dataSize);
 431                      break;
 432  
 433                  case Key.WIDGET:
 434                      restoreWidget(key, mBuffer, dataSize);
 435                      break;
 436  
 437                  default:
 438                      Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 439                      mKeys.remove(key);
 440                      break;
 441              }
 442          } catch (IOException e) {
 443              Log.w(TAG, &quot;ignoring unparsable backup entry&quot;, e);
 444          }
 445      }
 446  
 447      /**
 448       * Record the restore state for the next backup.
 449       *
 450       * @param newState notes about the backup state after restore.
 451       */
 452      @Override
 453      public void writeNewStateDescription(ParcelFileDescriptor newState) {
 454          writeJournal(newState, getCurrentStateJournal());
 455      }
 456  
 457      private Journal getCurrentStateJournal() {
 458          Journal journal = new Journal();
 459          journal.t = mLastBackupRestoreTime;
 460          journal.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);
 461          journal.appVersion = getAppVersion();
 462          journal.backupVersion = BACKUP_VERSION;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 463 -        journal.profile = getDeviceProfieData();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 464 +        journal.profile = mDeviceProfileData;</span>
 465          return journal;
 466      }
 467  
 468      private int getAppVersion() {
 469          try {
 470              return mContext.getPackageManager()
 471                      .getPackageInfo(mContext.getPackageName(), 0).versionCode;
 472          } catch (NameNotFoundException e) {
 473              return 0;
 474          }
 475      }
 476  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 477 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 478 -     * @return the current device profile information.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 479 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 480 -    private DeviceProfieData getDeviceProfieData() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 481 -        if (mCurrentProfile != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 482 -            return mCurrentProfile;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 483 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 484 -        final Context applicationContext = mContext.getApplicationContext();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 485 -        DeviceProfile profile = LauncherAppState.createDynamicGrid(applicationContext, null)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 486 -                .getDeviceProfile();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 487 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 488 -        mCurrentProfile = new DeviceProfieData();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 489 -        mCurrentProfile.desktopRows = profile.numRows;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 490 -        mCurrentProfile.desktopCols = profile.numColumns;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 491 -        mCurrentProfile.hotseatCount = profile.numHotseatIcons;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 492 -        mCurrentProfile.allappsRank = profile.hotseatAllAppsRank;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 493 -        return mCurrentProfile;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 494 +    private DeviceProfieData initDeviceProfileData(InvariantDeviceProfile profile) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 495 +        DeviceProfieData data = new DeviceProfieData();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 496 +        data.desktopRows = profile.numRows;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 497 +        data.desktopCols = profile.numColumns;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 498 +        data.hotseatCount = profile.numHotseatIcons;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 499 +        data.allappsRank = profile.hotseatAllAppsRank;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 500 +        return data;</span>
 501      }
 502  
 503      /**
 504       * Write all modified favorites to the data stream.
 505       *
 506       * @param data output stream for key/value pairs
 507       * @throws IOException
 508       */
 509      private void backupFavorites(BackupDataOutput data) throws IOException {
 510          // persist things that have changed since the last backup
 511          ContentResolver cr = mContext.getContentResolver();
 512          // Don&#x27;t backup apps in other profiles for now.
 513          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 514                  getUserSelectionArg(), null, null);
 515          try {
 516              cursor.moveToPosition(-1);
 517              while(cursor.moveToNext()) {
 518                  final long id = cursor.getLong(ID_INDEX);
 519                  final long updateTime = cursor.getLong(ID_MODIFIED);
 520                  Key key = getKey(Key.FAVORITE, id);
 521                  mKeys.add(key);
 522                  final String backupKey = keyToBackupKey(key);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 523 -                if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 524 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 525 +                // Favorite proto changed in v4. Backup again if the version is old.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 526 +                if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 527 +                        || restoredBackupVersion &lt; 4) {</span>
 528                      writeRowToBackup(key, packFavorite(cursor), data);
 529                  } else {
 530                      if (DEBUG) Log.d(TAG, &quot;favorite already backup up: &quot; + id);
 531                  }
 532              }
 533          } finally {
 534              cursor.close();
 535          }
 536      }
 537  
 538      /**
 539       * Read a favorite from the stream.
 540       *
 541       * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 542       *
 543       * @param key identifier for the row
 544       * @param buffer the serialized proto from the stream, may be larger than dataSize
 545       * @param dataSize the size of the proto from the stream
 546       */
 547      private void restoreFavorite(Key key, byte[] buffer, int dataSize) throws IOException {
 548          if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 549          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 550                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 551  
 552          ContentResolver cr = mContext.getContentResolver();
 553          ContentValues values = unpackFavorite(buffer, dataSize);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 554 -        cr.insert(Favorites.CONTENT_URI_NO_NOTIFICATION, values);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 555 +        cr.insert(Favorites.CONTENT_URI, values);</span>
 556      }
 557  
 558      /**
 559       * Write all modified screens to the data stream.
 560       *
 561       * @param data output stream for key/value pairs
 562       * @throws IOException
 563       */
 564      private void backupScreens(BackupDataOutput data) throws IOException {
 565          // persist things that have changed since the last backup
 566          ContentResolver cr = mContext.getContentResolver();
 567          Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 568                  null, null, null);
 569          try {
 570              cursor.moveToPosition(-1);
 571              if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + mLastBackupRestoreTime);
 572              while(cursor.moveToNext()) {
 573                  final long id = cursor.getLong(ID_INDEX);
 574                  final long updateTime = cursor.getLong(ID_MODIFIED);
 575                  Key key = getKey(Key.SCREEN, id);
 576                  mKeys.add(key);
 577                  final String backupKey = keyToBackupKey(key);
 578                  if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 579                      writeRowToBackup(key, packScreen(cursor), data);
 580                  } else {
 581                      if (VERBOSE) Log.v(TAG, &quot;screen already backup up &quot; + id);
 582                  }
 583              }
 584          } finally {
 585              cursor.close();
 586          }
 587      }
 588  
 589      /**
 590       * Read a screen from the stream.
 591       *
 592       * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 593       *
 594       * @param key identifier for the row
 595       * @param buffer the serialized proto from the stream, may be larger than dataSize
 596       * @param dataSize the size of the proto from the stream
 597       */
 598      private void restoreScreen(Key key, byte[] buffer, int dataSize) throws IOException {
 599          if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 600          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 601                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 602  
 603          ContentResolver cr = mContext.getContentResolver();
 604          ContentValues values = unpackScreen(buffer, dataSize);
 605          cr.insert(WorkspaceScreens.CONTENT_URI, values);
 606      }
 607  
 608      /**
 609       * Write all the static icon resources we need to render placeholders
 610       * for a package that is not installed.
 611       *
 612       * @param data output stream for key/value pairs
 613       */
 614      private void backupIcons(BackupDataOutput data) throws IOException {
 615          // persist icons that haven&#x27;t been persisted yet
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 616 -        if (!initializeIconCache()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 617 -            dataChanged(); // try again later</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 618 -            if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 619 -            return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 620 -        }</span>
 621          final ContentResolver cr = mContext.getContentResolver();
 622          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 623          final UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 624          int backupUpIconCount = 0;
 625  
 626          // Don&#x27;t backup apps in other profiles for now.
 627          String where = &quot;(&quot; + Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION + &quot; OR &quot; +
 628                  Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_SHORTCUT + &quot;) AND &quot; +
 629                  getUserSelectionArg();
 630          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 631                  where, null, null);
 632          try {
 633              cursor.moveToPosition(-1);
 634              while(cursor.moveToNext()) {
 635                  final long id = cursor.getLong(ID_INDEX);
 636                  final String intentDescription = cursor.getString(INTENT_INDEX);
 637                  try {
 638                      Intent intent = Intent.parseUri(intentDescription, 0);
 639                      ComponentName cn = intent.getComponent();
 640                      Key key = null;
 641                      String backupKey = null;
 642                      if (cn != null) {
 643                          key = getKey(Key.ICON, cn.flattenToShortString());
 644                          backupKey = keyToBackupKey(key);
 645                      } else {
 646                          Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 647                      }
 648                      if (mExistingKeys.contains(backupKey)) {
 649                          if (DEBUG) Log.d(TAG, &quot;already saved icon &quot; + backupKey);
 650  
 651                          // remember that we already backed this up previously
 652                          mKeys.add(key);
 653                      } else if (backupKey != null) {
 654                          if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + backupUpIconCount);
 655                          if (backupUpIconCount &lt; MAX_ICONS_PER_PASS) {
 656                              if (DEBUG) Log.d(TAG, &quot;saving icon &quot; + backupKey);
 657                              Bitmap icon = mIconCache.getIcon(intent, myUserHandle);
 658                              if (icon != null &amp;&amp; !mIconCache.isDefaultIcon(icon, myUserHandle)) {
 659                                  writeRowToBackup(key, packIcon(dpi, icon), data);
 660                                  mKeys.add(key);
 661                                  backupUpIconCount ++;
 662                              }
 663                          } else {
 664                              if (VERBOSE) Log.v(TAG, &quot;deferring icon backup &quot; + backupKey);
 665                              // too many icons for this pass, request another.
 666                              dataChanged();
 667                          }
 668                      }
 669                  } catch (URISyntaxException e) {
 670                      Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 671                  } catch (IOException e) {
 672                      Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 673                  }
 674  
 675              }
 676          } finally {
 677              cursor.close();
 678          }
 679      }
 680  
 681      /**
 682       * Read an icon from the stream.
 683       *
 684       * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 685       *
 686       * @param key identifier for the row
 687       * @param buffer the serialized proto from the stream, may be larger than dataSize
 688       * @param dataSize the size of the proto from the stream
 689       */
 690      private void restoreIcon(Key key, byte[] buffer, int dataSize) throws IOException {
 691          if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 692          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 693                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 694  
 695          Resource res = unpackProto(new Resource(), buffer, dataSize);
 696          if (DEBUG) {
 697              Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 698          }
 699          Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 700          if (icon == null) {
 701              Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 702 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 703 -        if (VERBOSE) Log.v(TAG, &quot;saving restored icon as: &quot; + key.name);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 704 -        IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(key.name), icon, res.dpi);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 705 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 706 +            if (VERBOSE) Log.v(TAG, &quot;saving restored icon as: &quot; + key.name);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 707 +            mIconCache.preloadIcon(ComponentName.unflattenFromString(key.name), icon, res.dpi,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 708 +                    &quot;&quot; /* label */, mUserSerial, mIdp);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 709 +        }</span>
 710      }
 711  
 712      /**
 713       * Write all the static widget resources we need to render placeholders
 714       * for a package that is not installed.
 715       *
 716       * @param data output stream for key/value pairs
 717       * @throws IOException
 718       */
 719      private void backupWidgets(BackupDataOutput data) throws IOException {
 720          // persist static widget info that hasn&#x27;t been persisted yet
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 721 -        final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 722 -        if (appState == null || !initializeIconCache()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 723 -            Log.w(TAG, &quot;Failed to get icon cache during restore&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 724 -            return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 725 -        }</span>
 726          final ContentResolver cr = mContext.getContentResolver();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 727 -        final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 728 -        final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);</span>
 729          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 730 -        final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 731 -        if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);</span>
 732          int backupWidgetCount = 0;
 733  
 734          String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET + &quot; AND &quot;
 735                  + getUserSelectionArg();
 736          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 737                  where, null, null);
 738          try {
 739              cursor.moveToPosition(-1);
 740              while(cursor.moveToNext()) {
 741                  final long id = cursor.getLong(ID_INDEX);
 742                  final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 743 -                final int spanX = cursor.getInt(SPANX_INDEX);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 744 -                final int spanY = cursor.getInt(SPANY_INDEX);</span>
 745                  final ComponentName provider = ComponentName.unflattenFromString(providerName);
 746                  Key key = null;
 747                  String backupKey = null;
 748                  if (provider != null) {
 749                      key = getKey(Key.WIDGET, providerName);
 750                      backupKey = keyToBackupKey(key);
 751                  } else {
 752                      Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 753                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 754 -                if (mExistingKeys.contains(backupKey)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 755 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 756 +                // Widget backup proto changed in v3. So add it again if the original backup is old.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 757 +                if (mExistingKeys.contains(backupKey) &amp;&amp; restoredBackupVersion &gt;= 3) {</span>
 758                      if (DEBUG) Log.d(TAG, &quot;already saved widget &quot; + backupKey);
 759  
 760                      // remember that we already backed this up previously
 761                      mKeys.add(key);
 762                  } else if (backupKey != null) {
 763                      if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + backupWidgetCount);
 764                      if (backupWidgetCount &lt; MAX_WIDGETS_PER_PASS) {
 765                          if (DEBUG) Log.d(TAG, &quot;saving widget &quot; + backupKey);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 766 -                        previewLoader.setPreviewSize(spanX * profile.cellWidthPx,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 767 -                                spanY * profile.cellHeightPx, widgetSpacingLayout);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 768 -                        writeRowToBackup(key, packWidget(dpi, previewLoader, mIconCache, provider), data);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 769 +                        UserHandleCompat user = UserHandleCompat.myUserHandle();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 770 +                        writeRowToBackup(key, packWidget(dpi, provider, user), data);</span>
 771                          mKeys.add(key);
 772                          backupWidgetCount ++;
 773                      } else {
 774                          if (VERBOSE) Log.v(TAG, &quot;deferring widget backup &quot; + backupKey);
 775                          // too many widgets for this pass, request another.
 776                          dataChanged();
 777                      }
 778                  }
 779              }
 780          } finally {
 781              cursor.close();
 782          }
 783      }
 784  
 785      /**
 786       * Read a widget from the stream.
 787       *
 788       * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 789       *
 790       * @param key identifier for the row
 791       * @param buffer the serialized proto from the stream, may be larger than dataSize
 792       * @param dataSize the size of the proto from the stream
 793       */
 794      private void restoreWidget(Key key, byte[] buffer, int dataSize) throws IOException {
 795          if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 796          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 797                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 798          Widget widget = unpackProto(new Widget(), buffer, dataSize);
 799          if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 800          if (widget.icon.data != null)  {
 801              Bitmap icon = BitmapFactory
 802                      .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 803              if (icon == null) {
 804                  Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 805              } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 806 -                IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(widget.provider),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 807 -                        icon, widget.icon.dpi);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 808 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 809 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 810 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 811 -        // future site of widget table mutation</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 812 +                mIconCache.preloadIcon(ComponentName.unflattenFromString(widget.provider),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 813 +                        icon, widget.icon.dpi, widget.label, mUserSerial, mIdp);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 814 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 815 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 816 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 817 +        // Cache widget min sizes incase migration is required.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 818 +        widgetSizes.add(widget.provider + &quot;#&quot; + widget.minSpanX + &quot;,&quot; + widget.minSpanY);</span>
 819      }
 820  
 821      /** create a new key, with an integer ID.
 822       *
 823       * &lt;P&gt; Keys contain their own checksum instead of using
 824       * the heavy-weight CheckedMessage wrapper.
 825       */
 826      private Key getKey(int type, long id) {
 827          Key key = new Key();
 828          key.type = type;
 829          key.id = id;
 830          key.checksum = checkKey(key);
 831          return key;
 832      }
 833  
 834      /** create a new key for a named object.
 835       *
 836       * &lt;P&gt; Keys contain their own checksum instead of using
 837       * the heavy-weight CheckedMessage wrapper.
 838       */
 839      private Key getKey(int type, String name) {
 840          Key key = new Key();
 841          key.type = type;
 842          key.name = name;
 843          key.checksum = checkKey(key);
 844          return key;
 845      }
 846  
 847      /** keys need to be strings, serialize and encode. */
 848      private String keyToBackupKey(Key key) {
 849          return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 850      }
 851  
 852      /** keys need to be strings, decode and parse. */
 853      private Key backupKeyToKey(String backupKey) throws InvalidBackupException {
 854          try {
 855              Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 856              if (key.checksum != checkKey(key)) {
 857                  key = null;
 858                  throw new InvalidBackupException(&quot;invalid key read from stream&quot; + backupKey);
 859              }
 860              return key;
 861          } catch (InvalidProtocolBufferNanoException e) {
 862              throw new InvalidBackupException(e);
 863          } catch (IllegalArgumentException e) {
 864              throw new InvalidBackupException(e);
 865          }
 866      }
 867  
 868      /** Compute the checksum over the important bits of a key. */
 869      private long checkKey(Key key) {
 870          CRC32 checksum = new CRC32();
 871          checksum.update(key.type);
 872          checksum.update((int) (key.id &amp; 0xffff));
 873          checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 874          if (!TextUtils.isEmpty(key.name)) {
 875              checksum.update(key.name.getBytes());
 876          }
 877          return checksum.getValue();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 878 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 879 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 880 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 881 +     * @return true if its an hotseat item, that can be replaced during restore.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 882 +     * TODO: Extend check for folders in hotseat.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 883 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 884 +    private boolean isReplaceableHotseatItem(Favorite favorite) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 885 +        return favorite.container == Favorites.CONTAINER_HOTSEAT</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 886 +                &amp;&amp; favorite.intent != null</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 887 +                &amp;&amp; (favorite.itemType == Favorites.ITEM_TYPE_APPLICATION</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 888 +                || favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT);</span>
 889      }
 890  
 891      /** Serialize a Favorite for persistence, including a checksum wrapper. */
 892      private Favorite packFavorite(Cursor c) {
 893          Favorite favorite = new Favorite();
 894          favorite.id = c.getLong(ID_INDEX);
 895          favorite.screen = c.getInt(SCREEN_INDEX);
 896          favorite.container = c.getInt(CONTAINER_INDEX);
 897          favorite.cellX = c.getInt(CELLX_INDEX);
 898          favorite.cellY = c.getInt(CELLY_INDEX);
 899          favorite.spanX = c.getInt(SPANX_INDEX);
 900          favorite.spanY = c.getInt(SPANY_INDEX);
 901          favorite.iconType = c.getInt(ICON_TYPE_INDEX);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 902 -        if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 903 -            String iconPackage = c.getString(ICON_PACKAGE_INDEX);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 904 -            if (!TextUtils.isEmpty(iconPackage)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 905 -                favorite.iconPackage = iconPackage;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 906 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 907 -            String iconResource = c.getString(ICON_RESOURCE_INDEX);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 908 -            if (!TextUtils.isEmpty(iconResource)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 909 -                favorite.iconResource = iconResource;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 910 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 911 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 912 -        if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 913 -            byte[] blob = c.getBlob(ICON_INDEX);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 914 -            if (blob != null &amp;&amp; blob.length &gt; 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 915 -                favorite.icon = blob;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 916 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 917 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 918 +        favorite.rank = c.getInt(RANK_INDEX);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 919 +</span>
 920          String title = c.getString(TITLE_INDEX);
 921          if (!TextUtils.isEmpty(title)) {
 922              favorite.title = title;
 923          }
 924          String intentDescription = c.getString(INTENT_INDEX);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 925 +        Intent intent = null;</span>
 926          if (!TextUtils.isEmpty(intentDescription)) {
 927              try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 928 -                Intent intent = Intent.parseUri(intentDescription, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 929 +                intent = Intent.parseUri(intentDescription, 0);</span>
 930                  intent.removeExtra(ItemInfo.EXTRA_PROFILE);
 931                  favorite.intent = intent.toUri(0);
 932              } catch (URISyntaxException e) {
 933                  Log.e(TAG, &quot;Invalid intent&quot;, e);
 934              }
 935          }
 936          favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 937          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 938              favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 939              String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 940              if (!TextUtils.isEmpty(appWidgetProvider)) {
 941                  favorite.appWidgetProvider = appWidgetProvider;
 942              }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 943 +        } else if (favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 944 +            if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 945 +                String iconPackage = c.getString(ICON_PACKAGE_INDEX);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 946 +                if (!TextUtils.isEmpty(iconPackage)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 947 +                    favorite.iconPackage = iconPackage;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 948 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 949 +                String iconResource = c.getString(ICON_RESOURCE_INDEX);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 950 +                if (!TextUtils.isEmpty(iconResource)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 951 +                    favorite.iconResource = iconResource;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 952 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 953 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 954 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 955 +            byte[] blob = c.getBlob(ICON_INDEX);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 956 +            if (blob != null &amp;&amp; blob.length &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 957 +                favorite.icon = blob;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 958 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 959 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 960 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 961 +        if (isReplaceableHotseatItem(favorite)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 962 +            if (intent != null &amp;&amp; intent.getComponent() != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 963 +                PackageManager pm = mContext.getPackageManager();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 964 +                ActivityInfo activity = null;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 965 +                try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 966 +                    activity = pm.getActivityInfo(intent.getComponent(), 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 967 +                } catch (NameNotFoundException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 968 +                    Log.e(TAG, &quot;Target not found&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 969 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 970 +                if (activity == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 971 +                    return favorite;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 972 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 973 +                for (int i = 0; i &lt; mItemTypeMatchers.length; i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 974 +                    if (mItemTypeMatchers[i] == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 975 +                        mItemTypeMatchers[i] = new ItemTypeMatcher(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 976 +                                CommonAppTypeParser.getResourceForItemType(i));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 977 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 978 +                    if (mItemTypeMatchers[i].matches(activity, pm)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 979 +                        favorite.targetType = i;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 980 +                        break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 981 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 982 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 983 +            }</span>
 984          }
 985  
 986          return favorite;
 987      }
 988  
 989      /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 990      private ContentValues unpackFavorite(byte[] buffer, int dataSize)
 991              throws IOException {
 992          Favorite favorite = unpackProto(new Favorite(), buffer, dataSize);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 993 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 994 +        // If it is a hotseat item, move it accordingly.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 995 +        if (favorite.container == Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 996 +            favorite.screen += mHotseatShift;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 997 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 998 +</span>
 999          ContentValues values = new ContentValues();
1000          values.put(Favorites._ID, favorite.id);
1001          values.put(Favorites.SCREEN, favorite.screen);
1002          values.put(Favorites.CONTAINER, favorite.container);
1003          values.put(Favorites.CELLX, favorite.cellX);
1004          values.put(Favorites.CELLY, favorite.cellY);
1005          values.put(Favorites.SPANX, favorite.spanX);
1006          values.put(Favorites.SPANY, favorite.spanY);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1007 -        values.put(Favorites.ICON_TYPE, favorite.iconType);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1008 -        if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1009 -            values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1010 -            values.put(Favorites.ICON_RESOURCE, favorite.iconResource);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1011 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1012 -        if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1013 +        values.put(Favorites.RANK, favorite.rank);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1014 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1015 +        if (favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1016 +            values.put(Favorites.ICON_TYPE, favorite.iconType);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1017 +            if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1018 +                values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1019 +                values.put(Favorites.ICON_RESOURCE, favorite.iconResource);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1020 +            }</span>
1021              values.put(Favorites.ICON, favorite.icon);
1022          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1023 +</span>
1024          if (!TextUtils.isEmpty(favorite.title)) {
1025              values.put(Favorites.TITLE, favorite.title);
1026          } else {
1027              values.put(Favorites.TITLE, &quot;&quot;);
1028          }
1029          if (!TextUtils.isEmpty(favorite.intent)) {
1030              values.put(Favorites.INTENT, favorite.intent);
1031          }
1032          values.put(Favorites.ITEM_TYPE, favorite.itemType);
1033  
1034          UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
1035          long userSerialNumber =
1036                  UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHandle);
1037          values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
1038  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1039 -        DeviceProfieData currentProfile = getDeviceProfieData();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1040 +        // If we will attempt grid resize, use the original profile to validate grid size, as</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1041 +        // anything which fits in the original grid should fit in the current grid after</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1042 +        // grid migration.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1043 +        DeviceProfieData currentProfile = migrationCompatibleProfileData == null</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1044 +                ? mDeviceProfileData : migrationCompatibleProfileData;</span>
1045  
1046          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
1047              if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
1048                  values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
1049              }
1050              values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
1051              values.put(LauncherSettings.Favorites.RESTORED,
1052                      LauncherAppWidgetInfo.FLAG_ID_NOT_VALID |
1053                      LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY |
1054                      LauncherAppWidgetInfo.FLAG_UI_NOT_READY);
1055  
1056              // Verify placement
1057              if (((favorite.cellX + favorite.spanX) &gt; currentProfile.desktopCols)
1058                      || ((favorite.cellY + favorite.spanY) &gt; currentProfile.desktopRows)) {
1059                  restoreSuccessful = false;
1060                  throw new InvalidBackupException(&quot;Widget not in screen bounds, aborting restore&quot;);
1061              }
1062          } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1063 -            // Let LauncherModel know we&#x27;ve been here.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1064 -            values.put(LauncherSettings.Favorites.RESTORED, 1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1065 +            // Check if it is an hotseat item, that can be replaced.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1066 +            if (isReplaceableHotseatItem(favorite)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1067 +                    &amp;&amp; favorite.targetType != Favorite.TARGET_NONE</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1068 +                    &amp;&amp; favorite.targetType &lt; CommonAppTypeParser.SUPPORTED_TYPE_COUNT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1069 +                Log.e(TAG, &quot;Added item type flag&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1070 +                values.put(LauncherSettings.Favorites.RESTORED,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1071 +                        1 | CommonAppTypeParser.encodeItemTypeToFlag(favorite.targetType));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1072 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1073 +                // Let LauncherModel know we&#x27;ve been here.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1074 +                values.put(LauncherSettings.Favorites.RESTORED, 1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1075 +            }</span>
1076  
1077              // Verify placement
1078              if (favorite.container == Favorites.CONTAINER_HOTSEAT) {
1079                  if ((favorite.screen &gt;= currentProfile.hotseatCount)
1080                          || (favorite.screen == currentProfile.allappsRank)) {
1081                      restoreSuccessful = false;
1082                      throw new InvalidBackupException(&quot;Item not in hotseat bounds, aborting restore&quot;);
1083                  }
1084              } else {
1085                  if ((favorite.cellX &gt;= currentProfile.desktopCols)
1086                          || (favorite.cellY &gt;= currentProfile.desktopRows)) {
1087                      restoreSuccessful = false;
1088                      throw new InvalidBackupException(&quot;Item not in desktop bounds, aborting restore&quot;);
1089                  }
1090              }
1091          }
1092  
1093          return values;
1094      }
1095  
1096      /** Serialize a Screen for persistence, including a checksum wrapper. */
1097      private Screen packScreen(Cursor c) {
1098          Screen screen = new Screen();
1099          screen.id = c.getLong(ID_INDEX);
1100          screen.rank = c.getInt(SCREEN_RANK_INDEX);
1101          return screen;
1102      }
1103  
1104      /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
1105      private ContentValues unpackScreen(byte[] buffer, int dataSize)
1106              throws InvalidProtocolBufferNanoException {
1107          Screen screen = unpackProto(new Screen(), buffer, dataSize);
1108          ContentValues values = new ContentValues();
1109          values.put(WorkspaceScreens._ID, screen.id);
1110          values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
1111          return values;
1112      }
1113  
1114      /** Serialize an icon Resource for persistence, including a checksum wrapper. */
1115      private Resource packIcon(int dpi, Bitmap icon) {
1116          Resource res = new Resource();
1117          res.dpi = dpi;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1118 -        ByteArrayOutputStream os = new ByteArrayOutputStream();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1119 -        if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1120 -            res.data = os.toByteArray();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1121 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1122 +        res.data = Utilities.flattenBitmap(icon);</span>
1123          return res;
1124      }
1125  
1126      /** Serialize a widget for persistence, including a checksum wrapper. */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1127 -    private Widget packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1128 -            ComponentName provider) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1129 -        final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1130 +    private Widget packWidget(int dpi, ComponentName provider, UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1131 +        final LauncherAppWidgetProviderInfo info =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1132 +                LauncherModel.getProviderInfo(mContext, provider, user);</span>
1133          Widget widget = new Widget();
1134          widget.provider = provider.flattenToShortString();
1135          widget.label = info.label;
1136          widget.configure = info.configure != null;
1137          if (info.icon != 0) {
1138              widget.icon = new Resource();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1139 -            Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1140 +            Drawable fullResIcon = mIconCache.getFullResIcon(provider.getPackageName(), info.icon);</span>
1141              Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1142 -            ByteArrayOutputStream os = new ByteArrayOutputStream();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1143 -            if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1144 -                widget.icon.data = os.toByteArray();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1145 -                widget.icon.dpi = dpi;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1146 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1147 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1148 -        if (info.previewImage != 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1149 -            widget.preview = new Resource();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1150 -            Bitmap preview = previewLoader.generateWidgetPreview(info, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1151 -            ByteArrayOutputStream os = new ByteArrayOutputStream();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1152 -            if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1153 -                widget.preview.data = os.toByteArray();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1154 -                widget.preview.dpi = dpi;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1155 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1156 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1157 +            widget.icon.data = Utilities.flattenBitmap(icon);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1158 +            widget.icon.dpi = dpi;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1159 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1160 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1161 +        Point spans = info.getMinSpans(mIdp, mContext);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1162 +        widget.minSpanX = spans.x;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1163 +        widget.minSpanY = spans.y;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1164 +</span>
1165          return widget;
1166      }
1167  
1168      /**
1169       * Deserialize a proto after verifying checksum wrapper.
1170       */
1171      private &lt;T extends MessageNano&gt; T unpackProto(T proto, byte[] buffer, int dataSize)
1172              throws InvalidProtocolBufferNanoException {
1173          MessageNano.mergeFrom(proto, readCheckedBytes(buffer, dataSize));
1174          if (DEBUG) Log.d(TAG, &quot;unpacked proto &quot; + proto);
1175          return proto;
1176      }
1177  
1178      /**
1179       * Read the old journal from the input file.
1180       *
1181       * In the event of any error, just pretend we didn&#x27;t have a journal,
1182       * in that case, do a full backup.
1183       *
1184       * @param oldState the read-0only file descriptor pointing to the old journal
1185       * @return a Journal protocol buffer
1186       */
1187      private Journal readJournal(ParcelFileDescriptor oldState) {
1188          Journal journal = new Journal();
1189          if (oldState == null) {
1190              return journal;
1191          }
1192          FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
1193          try {
1194              int availableBytes = inStream.available();
1195              if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
1196              if (availableBytes &lt; MAX_JOURNAL_SIZE) {
1197                  byte[] buffer = new byte[availableBytes];
1198                  int bytesRead = 0;
1199                  boolean valid = false;
1200                  InvalidProtocolBufferNanoException lastProtoException = null;
1201                  while (availableBytes &gt; 0) {
1202                      try {
1203                          // OMG what are you doing? This is crazy inefficient!
1204                          // If we read a byte that is not ours, we will cause trouble: b/12491813
1205                          // However, we don&#x27;t know how many bytes to expect (oops).
1206                          // So we have to step through *slowly*, watching for the end.
1207                          int result = inStream.read(buffer, bytesRead, 1);
1208                          if (result &gt; 0) {
1209                              availableBytes -= result;
1210                              bytesRead += result;
1211                          } else {
1212                              Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1213                              // stop reading and see what there is to parse
1214                              availableBytes = 0;
1215                          }
1216                      } catch (IOException e) {
1217                          buffer = null;
1218                          availableBytes = 0;
1219                      }
1220  
1221                      // check the buffer to see if we have a valid journal
1222                      try {
1223                          MessageNano.mergeFrom(journal, readCheckedBytes(buffer, bytesRead));
1224                          // if we are here, then we have read a valid, checksum-verified journal
1225                          valid = true;
1226                          availableBytes = 0;
1227                          if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1228                      } catch (InvalidProtocolBufferNanoException e) {
1229                          // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1230                          lastProtoException = e;
1231                          journal.clear();
1232                      }
1233                  }
1234                  if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1235                  if (!valid) {
1236                      Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1237                  }
1238              }
1239          } catch (IOException e) {
1240              Log.w(TAG, &quot;failed to close the journal&quot;, e);
1241          } finally {
1242              try {
1243                  inStream.close();
1244              } catch (IOException e) {
1245                  Log.w(TAG, &quot;failed to close the journal&quot;, e);
1246              }
1247          }
1248          return journal;
1249      }
1250  
1251      private void writeRowToBackup(Key key, MessageNano proto, BackupDataOutput data)
1252              throws IOException {
1253          writeRowToBackup(keyToBackupKey(key), proto, data);
1254      }
1255  
1256      private void writeRowToBackup(String backupKey, MessageNano proto,
1257              BackupDataOutput data) throws IOException {
1258          byte[] blob = writeCheckedBytes(proto);
1259          data.writeEntityHeader(backupKey, blob.length);
1260          data.writeEntityData(blob, blob.length);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1261 +        mBackupDataWasUpdated = true;</span>
1262          if (VERBOSE) Log.v(TAG, &quot;Writing New entry &quot; + backupKey);
1263      }
1264  
1265      /**
1266       * Write the new journal to the output file.
1267       *
1268       * In the event of any error, just pretend we didn&#x27;t have a journal,
1269       * in that case, do a full backup.
1270  
1271       * @param newState the write-only file descriptor pointing to the new journal
1272       * @param journal a Journal protocol buffer
1273       */
1274      private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1275          FileOutputStream outStream = null;
1276          try {
1277              outStream = new FileOutputStream(newState.getFileDescriptor());
1278              final byte[] journalBytes = writeCheckedBytes(journal);
1279              outStream.write(journalBytes);
1280              outStream.close();
1281              if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1282          } catch (IOException e) {
1283              Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1284          }
1285      }
1286  
1287      /** Wrap a proto in a CheckedMessage and compute the checksum. */
1288      private byte[] writeCheckedBytes(MessageNano proto) {
1289          CheckedMessage wrapper = new CheckedMessage();
1290          wrapper.payload = MessageNano.toByteArray(proto);
1291          CRC32 checksum = new CRC32();
1292          checksum.update(wrapper.payload);
1293          wrapper.checksum = checksum.getValue();
1294          return MessageNano.toByteArray(wrapper);
1295      }
1296  
1297      /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1298      private static byte[] readCheckedBytes(byte[] buffer, int dataSize)
1299              throws InvalidProtocolBufferNanoException {
1300          CheckedMessage wrapper = new CheckedMessage();
1301          MessageNano.mergeFrom(wrapper, buffer, 0, dataSize);
1302          CRC32 checksum = new CRC32();
1303          checksum.update(wrapper.payload);
1304          if (wrapper.checksum != checksum.getValue()) {
1305              throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1306          }
1307          return wrapper.payload;
1308      }
1309  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1310 -    private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1311 -        if (mWidgetMap == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1312 -            List&lt;AppWidgetProviderInfo&gt; widgets =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1313 -                    AppWidgetManager.getInstance(mContext).getInstalledProviders();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1314 -            mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1315 -            for (AppWidgetProviderInfo info : widgets) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1316 -                mWidgetMap.put(info.provider, info);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1317 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1318 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1319 -        return mWidgetMap.get(component);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1320 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1321 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1322 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1323 -    private boolean initializeIconCache() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1324 -        if (mIconCache != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1325 -            return true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1326 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1327 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1328 -        final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1329 -        if (appState == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1330 -            Throwable stackTrace = new Throwable();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1331 -            stackTrace.fillInStackTrace();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1332 -            Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1333 -            return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1334 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1335 -        mIconCache = appState.getIconCache();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1336 -        return mIconCache != null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1337 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1338 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1339 -</span>
1340      /**
1341       * @return true if the launcher is in a state to support backup
1342       */
1343      private boolean launcherIsReady() {
1344          ContentResolver cr = mContext.getContentResolver();
1345          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);
1346          if (cursor == null) {
1347              // launcher data has been wiped, do nothing
1348              return false;
1349          }
1350          cursor.close();
1351  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1352 -        if (!initializeIconCache()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1353 +        if (LauncherAppState.getInstanceNoCreate() == null) {</span>
1354              // launcher services are unavailable, try again later
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1355 -            dataChanged();</span>
1356              return false;
1357          }
1358  
1359          return true;
1360      }
1361  
1362      private String getUserSelectionArg() {
1363          return Favorites.PROFILE_ID + &#x27;=&#x27; + UserManagerCompat.getInstance(mContext)
1364                  .getSerialNumberForUser(UserHandleCompat.myUserHandle());
1365      }
1366  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1367 -    private class InvalidBackupException extends IOException {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1368 -        private InvalidBackupException(Throwable cause) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1369 +    @Thunk class InvalidBackupException extends IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1370 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1371 +        private static final long serialVersionUID = 8931456637211665082L;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1372 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1373 +        @Thunk InvalidBackupException(Throwable cause) {</span>
1374              super(cause);
1375          }
1376  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1377 -        public InvalidBackupException(String reason) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1378 +        @Thunk InvalidBackupException(String reason) {</span>
1379              super(reason);
1380          }
1381      }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1382 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1383 +    public boolean shouldAttemptWorkspaceMigration() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1384 +        return migrationCompatibleProfileData != null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1385 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1386 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1387 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1388 +     * A class to check if an activity can handle one of the intents from a list of</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1389 +     * predefined intents.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1390 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1391 +    private class ItemTypeMatcher {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1392 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1393 +        private final ArrayList&lt;Intent&gt; mIntents;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1394 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1395 +        ItemTypeMatcher(int xml_res) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1396 +            mIntents = xml_res == 0 ? new ArrayList&lt;Intent&gt;() : parseIntents(xml_res);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1397 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1398 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1399 +        private ArrayList&lt;Intent&gt; parseIntents(int xml_res) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1400 +            ArrayList&lt;Intent&gt; intents = new ArrayList&lt;Intent&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1401 +            XmlResourceParser parser = mContext.getResources().getXml(xml_res);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1402 +            try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1403 +                DefaultLayoutParser.beginDocument(parser, DefaultLayoutParser.TAG_RESOLVE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1404 +                final int depth = parser.getDepth();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1405 +                int type;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1406 +                while (((type = parser.next()) != XmlPullParser.END_TAG ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1407 +                        parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1408 +                    if (type != XmlPullParser.START_TAG) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1409 +                        continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1410 +                    } else if (DefaultLayoutParser.TAG_FAVORITE.equals(parser.getName())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1411 +                        final String uri = DefaultLayoutParser.getAttributeValue(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1412 +                                parser, DefaultLayoutParser.ATTR_URI);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1413 +                        intents.add(Intent.parseUri(uri, 0));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1414 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1415 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1416 +            } catch (URISyntaxException | XmlPullParserException | IOException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1417 +                Log.e(TAG, &quot;Unable to parse &quot; + xml_res, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1418 +            } finally {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1419 +                parser.close();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1420 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1421 +            return intents;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1422 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1423 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1424 +        public boolean matches(ActivityInfo activity, PackageManager pm) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1425 +            for (Intent intent : mIntents) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1426 +                intent.setPackage(activity.packageName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1427 +                ResolveInfo info = pm.resolveActivity(intent, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1428 +                if (info != null &amp;&amp; (info.activityInfo.name.equals(activity.name)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1429 +                        || info.activityInfo.name.equals(activity.targetActivity))) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1430 +                    return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1431 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1432 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1433 +            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1434 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1435 +    }</span>
1436  }</pre></td>
                            <td><pre></pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            