<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>476</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    476
                    <a href="475.html">prev</a>
                    <a href="477.html">next</a>
                    <a href="476_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_2b8dbe3a5f5f673e87aa4b13133a4d3bf2b98b3c_src/com/android/launcher3/LauncherBackupHelper.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;2b8dbe3a5f5f673e87aa4b13133a4d3bf2b98b3c:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;2b8dbe3a5f5f673e87aa4b13133a4d3bf2b98b3c^1:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;2b8dbe3a5f5f673e87aa4b13133a4d3bf2b98b3c^2:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;6033ceb438d2d8e6c8406e2b61ae515e6156965c:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bj], [bj], [s], [s]], subset: [[bj], [sbj], [s]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  19 import com.google.protobuf.nano.MessageNano;
  20 
  21 import com.android.launcher3.LauncherSettings.Favorites;
  22 import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  23 import com.android.launcher3.backup.BackupProtos;
  24 import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  25 import com.android.launcher3.backup.BackupProtos.Favorite;
  26 import com.android.launcher3.backup.BackupProtos.Journal;
  27 import com.android.launcher3.backup.BackupProtos.Key;
  28 import com.android.launcher3.backup.BackupProtos.Resource;
  29 import com.android.launcher3.backup.BackupProtos.Screen;
  30 import com.android.launcher3.backup.BackupProtos.Widget;
  31 
  32 import android.app.backup.BackupDataInputStream;
  33 import android.app.backup.BackupDataOutput;
  34 import android.app.backup.BackupHelper;
  35 import android.app.backup.BackupManager;
  36 import android.appwidget.AppWidgetManager;
  37 import android.appwidget.AppWidgetProviderInfo;
  38 import android.content.ComponentName;
  39 import android.content.ContentResolver;
  40 import android.content.ContentValues;
  41 import android.content.Context;
  42 import android.content.Intent;
  43 import android.database.Cursor;
  44 import android.graphics.Bitmap;
  45 import android.graphics.BitmapFactory;
  46 import android.graphics.drawable.Drawable;
  47 import android.os.ParcelFileDescriptor;
  48 import android.text.TextUtils;
  49 import android.util.Base64;
  50 import android.util.Log;
  51 
  52 import java.io.ByteArrayOutputStream;
  53 import java.io.FileInputStream;
  54 import java.io.FileOutputStream;
  55 import java.io.IOException;
  56 import java.net.URISyntaxException;
  57 import java.util.ArrayList;
  58 import java.util.HashMap;
  59 import java.util.HashSet;
  60 import java.util.List;
  61 import java.util.Set;
  62 import java.util.zip.CRC32;
  63 
  64 /**
  65  * Persist the launcher home state across calamities.
  66  */
  67 public class LauncherBackupHelper implements BackupHelper {
  68 
  69     private static final String TAG = &quot;LauncherBackupHelper&quot;;
  70     private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  71     private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  72     private static final boolean DEBUG_PAYLOAD = false;
  73 
  74     private static final int MAX_JOURNAL_SIZE = 1000000;
  75 
  76     /** icons are large, dribble them out */
  77     private static final int MAX_ICONS_PER_PASS = 10;
  78 
  79     /** widgets contain previews, which are very large, dribble them out */
  80     private static final int MAX_WIDGETS_PER_PASS = 5;
  81 
  82     public static final int IMAGE_COMPRESSION_QUALITY = 75;
  83 
  84     public static final String LAUNCHER_PREFIX = &quot;L&quot;;
  85 
  86     public static final String LAUNCHER_PREFS_PREFIX = &quot;LP&quot;;
  87 
  88     private static final Bitmap.CompressFormat IMAGE_FORMAT =
  89             android.graphics.Bitmap.CompressFormat.PNG;
  90 
  91     private static BackupManager sBackupManager;
  92 
  93     private static final String[] FAVORITE_PROJECTION = {
  94             Favorites._ID,                     // 0
  95             Favorites.MODIFIED,                // 1
  96             Favorites.INTENT,                  // 2
  97             Favorites.APPWIDGET_PROVIDER,      // 3
  98             Favorites.APPWIDGET_ID,            // 4
  99             Favorites.CELLX,                   // 5
 100             Favorites.CELLY,                   // 6
 101             Favorites.CONTAINER,               // 7
 102             Favorites.ICON,                    // 8
 103             Favorites.ICON_PACKAGE,            // 9
 104             Favorites.ICON_RESOURCE,           // 10
 105             Favorites.ICON_TYPE,               // 11
 106             Favorites.ITEM_TYPE,               // 12
 107             Favorites.SCREEN,                  // 13
 108             Favorites.SPANX,                   // 14
 109             Favorites.SPANY,                   // 15
 110             Favorites.TITLE,                   // 16
 111     };
 112 
 113     private static final int ID_INDEX = 0;
 114     private static final int ID_MODIFIED = 1;
 115     private static final int INTENT_INDEX = 2;
 116     private static final int APPWIDGET_PROVIDER_INDEX = 3;
 117     private static final int APPWIDGET_ID_INDEX = 4;
 118     private static final int CELLX_INDEX = 5;
 119     private static final int CELLY_INDEX = 6;
 120     private static final int CONTAINER_INDEX = 7;
 121     private static final int ICON_INDEX = 8;
 122     private static final int ICON_PACKAGE_INDEX = 9;
 123     private static final int ICON_RESOURCE_INDEX = 10;
 124     private static final int ICON_TYPE_INDEX = 11;
 125     private static final int ITEM_TYPE_INDEX = 12;
 126     private static final int SCREEN_INDEX = 13;
 127     private static final int SPANX_INDEX = 14;
 128     private static final int SPANY_INDEX = 15;
 129     private static final int TITLE_INDEX = 16;
 130 
 131     private static final String[] SCREEN_PROJECTION = {
 132             WorkspaceScreens._ID,              // 0
 133             WorkspaceScreens.MODIFIED,         // 1
 134             WorkspaceScreens.SCREEN_RANK       // 2
 135     };
 136 
 137     private static final int SCREEN_RANK_INDEX = 2;
 138 
 139     private static IconCache mIconCache;
 140 
 141     private final Context mContext;
 142 
 143     private final boolean mRestoreEnabled;
 144 
 145     private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;
 146 
 147     private ArrayList&lt;Key&gt; mKeys;
 148 
 149     public LauncherBackupHelper(Context context, boolean restoreEnabled) {
 150         mContext = context;
 151         mRestoreEnabled = restoreEnabled;
 152     }
 153 
 154     private void dataChanged() {
 155         if (sBackupManager == null) {
 156             sBackupManager = new BackupManager(mContext);
 157         }
 158         sBackupManager.dataChanged();
 159     }
 160 
 161     /**
 162      * Back up launcher data so we can restore the user&#x27;s state on a new device.
 163      *
 164      * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 165      *
 166      * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 167      *
 168      * @param oldState notes from the last backup
 169      * @param data incremental key/value pairs to persist off-device
 170      * @param newState notes for the next backup
 171      * @throws IOException
 172      */
 173     @Override
 174     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 175             ParcelFileDescriptor newState) {
 176         if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 177 
 178         Journal in = readJournal(oldState);
 179         Journal out = new Journal();
 180 
 181         long lastBackupTime = in.t;
 182         out.t = System.currentTimeMillis();
 183         out.rows = 0;
 184         out.bytes = 0;
 185 
 186         Log.v(TAG, &quot;lastBackupTime = &quot; + lastBackupTime);
 187 
 188         ArrayList&lt;Key&gt; keys = new ArrayList&lt;Key&gt;();
 189         if (launcherIsReady()) {
 190             try {
 191                 backupFavorites(in, data, out, keys);
 192                 backupScreens(in, data, out, keys);
 193                 backupIcons(in, data, out, keys);
 194                 backupWidgets(in, data, out, keys);
 195             } catch (IOException e) {
 196                 Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 197             }
 198             out.key = keys.toArray(new BackupProtos.Key[keys.size()]);
 199         } else {
 200             out = in;
 201         }
 202 
 203 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
 204 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 205         out.key = keys.toArray(BackupProtos.Key.EMPTY_ARRAY);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 206         writeJournal(newState, out);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 207         Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 208     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 209 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 210     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 211      * Restore launcher configuration from the restored data stream.</span>
 212 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 213         out.key = keys.toArray(BackupProtos.Key.emptyArray());</span>
 214 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 215         writeJournal(newState, out);
 216         Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);
 217     }
 218 
 219     /**
 220      * Restore launcher configuration from the restored data stream.
 221      *
 222      * &lt;P&gt;Keys may arrive in any order.
 223      *
 224      * @param data the key/value pair from the server
 225      */
 226     @Override
 227     public void restoreEntity(BackupDataInputStream data) {
 228         if (VERBOSE) Log.v(TAG, &quot;restoreEntity&quot;);
 229         if (mKeys == null) {
 230             mKeys = new ArrayList&lt;Key&gt;();
 231         }
 232         byte[] buffer = new byte[512];
 233             String backupKey = data.getKey();
 234             int dataSize = data.size();
 235             if (buffer.length &lt; dataSize) {
 236                 buffer = new byte[dataSize];
 237             }
 238             Key key = null;
 239         int bytesRead = 0;
 240         try {
 241             bytesRead = data.read(buffer, 0, dataSize);
 242             if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 243         } catch (IOException e) {
 244             Log.e(TAG, &quot;failed to read entity from restore data&quot;, e);
 245         }
 246         try {
 247             key = backupKeyToKey(backupKey);
 248             mKeys.add(key);
 249             switch (key.type) {
 250                 case Key.FAVORITE:
 251                     restoreFavorite(key, buffer, dataSize, mKeys);
 252                     break;
 253 
 254                 case Key.SCREEN:
 255                     restoreScreen(key, buffer, dataSize, mKeys);
 256                     break;
 257 
 258                 case Key.ICON:
 259                     restoreIcon(key, buffer, dataSize, mKeys);
 260                     break;
 261 
 262                 case Key.WIDGET:
 263                     restoreWidget(key, buffer, dataSize, mKeys);
 264                     break;
 265 
 266                 default:
 267                     Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 268                     break;
 269             }
 270         } catch (KeyParsingException e) {
 271             Log.w(TAG, &quot;ignoring unparsable backup key: &quot; + backupKey);
 272         }
 273 
 274     }
 275 
 276     /**
 277      * Record the restore state for the next backup.
 278      *
 279      * @param newState notes about the backup state after restore.
 280      */
 281     @Override
 282     public void writeNewStateDescription(ParcelFileDescriptor newState) {
 283         // clear the output journal time, to force a full backup to
 284         // will catch any changes the restore process might have made
 285         Journal out = new Journal();
 286         out.t = 0;
 287 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 288         out.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);</span>
 289 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 290         out.key = mKeys.toArray(BackupProtos.Key.EMPTY_ARRAY);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 291         writeJournal(newState, out);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 292         Log.v(TAG, &quot;onRestore: read &quot; + mKeys.size() + &quot; rows&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 293         mKeys.clear();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 294     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 295 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 296     /**</span>
 297 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 298         out.key = mKeys.toArray(BackupProtos.Key.emptyArray());</span>
 299 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 300         writeJournal(newState, out);
 301         Log.v(TAG, &quot;onRestore: read &quot; + mKeys.size() + &quot; rows&quot;);
 302         mKeys.clear();
 303     }
 304 
 305     /**
 306      * Write all modified favorites to the data stream.
 307      *
 308      *
 309      * @param in notes from last backup
 310      * @param data output stream for key/value pairs
 311      * @param out notes about this backup
 312      * @param keys keys to mark as clean in the notes for next backup
 313      * @throws IOException
 314      */
 315     private void backupFavorites(Journal in, BackupDataOutput data, Journal out,
 316             ArrayList&lt;Key&gt; keys)
 317             throws IOException {
 318         // read the old ID set
 319         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.FAVORITE, in);
 320         if (DEBUG) Log.d(TAG, &quot;favorite savedIds.size()=&quot; + savedIds.size());
 321 
 322         // persist things that have changed since the last backup
 323         ContentResolver cr = mContext.getContentResolver();
 324         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 325                 null, null, null);
 326         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 327         try {
 328             cursor.moveToPosition(-1);
 329             while(cursor.moveToNext()) {
 330                 final long id = cursor.getLong(ID_INDEX);
 331                 final long updateTime = cursor.getLong(ID_MODIFIED);
 332                 Key key = getKey(Key.FAVORITE, id);
 333                 keys.add(key);
 334                 final String backupKey = keyToBackupKey(key);
 335                 currentIds.add(backupKey);
 336                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 337                     byte[] blob = packFavorite(cursor);
 338                     writeRowToBackup(key, blob, out, data);
 339                 } else {
 340                     if (VERBOSE) Log.v(TAG, &quot;favorite &quot; + id + &quot; was too old: &quot; + updateTime);
 341                 }
 342             }
 343         } finally {
 344             cursor.close();
 345         }
 346         if (DEBUG) Log.d(TAG, &quot;favorite currentIds.size()=&quot; + currentIds.size());
 347 
 348         // these IDs must have been deleted
 349         savedIds.removeAll(currentIds);
 350         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 351     }
 352 
 353     /**
 354      * Read a favorite from the stream.
 355      *
 356      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 357      *
 358      * @param key identifier for the row
 359      * @param buffer the serialized proto from the stream, may be larger than dataSize
 360      * @param dataSize the size of the proto from the stream
 361      * @param keys keys to mark as clean in the notes for next backup
 362      */
 363     private void restoreFavorite(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 364         if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 365         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 366                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 367 
 368         if (!mRestoreEnabled) {
 369             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 370             return;
 371         }
 372 
 373         try {
 374             ContentResolver cr = mContext.getContentResolver();
 375             ContentValues values = unpackFavorite(buffer, 0, dataSize);
 376             cr.insert(Favorites.CONTENT_URI, values);
 377         } catch (InvalidProtocolBufferNanoException e) {
 378             Log.e(TAG, &quot;failed to decode favorite&quot;, e);
 379         }
 380     }
 381 
 382     /**
 383      * Write all modified screens to the data stream.
 384      *
 385      *
 386      * @param in notes from last backup
 387      * @param data output stream for key/value pairs
 388      * @param out notes about this backup
 389      * @param keys keys to mark as clean in the notes for next backup
 390      * @throws IOException
 391      */
 392     private void backupScreens(Journal in, BackupDataOutput data, Journal out,
 393             ArrayList&lt;Key&gt; keys)
 394             throws IOException {
 395         // read the old ID set
 396         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.SCREEN, in);
 397         if (DEBUG) Log.d(TAG, &quot;screen savedIds.size()=&quot; + savedIds.size());
 398 
 399         // persist things that have changed since the last backup
 400         ContentResolver cr = mContext.getContentResolver();
 401         Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 402                 null, null, null);
 403         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 404         try {
 405             cursor.moveToPosition(-1);
 406             if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + in.t);
 407             while(cursor.moveToNext()) {
 408                 final long id = cursor.getLong(ID_INDEX);
 409                 final long updateTime = cursor.getLong(ID_MODIFIED);
 410                 Key key = getKey(Key.SCREEN, id);
 411                 keys.add(key);
 412                 final String backupKey = keyToBackupKey(key);
 413                 currentIds.add(backupKey);
 414                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 415                     byte[] blob = packScreen(cursor);
 416                     writeRowToBackup(key, blob, out, data);
 417                 } else {
 418                     if (VERBOSE) Log.v(TAG, &quot;screen &quot; + id + &quot; was too old: &quot; + updateTime);
 419                 }
 420             }
 421         } finally {
 422             cursor.close();
 423         }
 424         if (DEBUG) Log.d(TAG, &quot;screen currentIds.size()=&quot; + currentIds.size());
 425 
 426         // these IDs must have been deleted
 427         savedIds.removeAll(currentIds);
 428         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 429     }
 430 
 431     /**
 432      * Read a screen from the stream.
 433      *
 434      * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 435      *
 436      * @param key identifier for the row
 437      * @param buffer the serialized proto from the stream, may be larger than dataSize
 438      * @param dataSize the size of the proto from the stream
 439      * @param keys keys to mark as clean in the notes for next backup
 440      */
 441     private void restoreScreen(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 442         if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 443         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 444                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 445 
 446         if (!mRestoreEnabled) {
 447             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 448             return;
 449         }
 450 
 451         try {
 452             ContentResolver cr = mContext.getContentResolver();
 453             ContentValues values = unpackScreen(buffer, 0, dataSize);
 454             cr.insert(WorkspaceScreens.CONTENT_URI, values);
 455 
 456         } catch (InvalidProtocolBufferNanoException e) {
 457             Log.e(TAG, &quot;failed to decode screen&quot;, e);
 458         }
 459     }
 460 
 461     /**
 462      * Write all the static icon resources we need to render placeholders
 463      * for a package that is not installed.
 464      *
 465      * @param in notes from last backup
 466      * @param data output stream for key/value pairs
 467      * @param out notes about this backup
 468      * @param keys keys to mark as clean in the notes for next backup
 469      * @throws IOException
 470      */
 471     private void backupIcons(Journal in, BackupDataOutput data, Journal out,
 472             ArrayList&lt;Key&gt; keys) throws IOException {
 473         // persist icons that haven&#x27;t been persisted yet
 474         if (!initializeIconCache()) {
 475             dataChanged(); // try again later
 476             if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 477             return;
 478         }
 479         final ContentResolver cr = mContext.getContentResolver();
 480         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 481 
 482         // read the old ID set
 483         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.ICON, in);
 484         if (DEBUG) Log.d(TAG, &quot;icon savedIds.size()=&quot; + savedIds.size());
 485 
 486         int startRows = out.rows;
 487         if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 488         String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION;
 489         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 490                 where, null, null);
 491         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 492         try {
 493             cursor.moveToPosition(-1);
 494             while(cursor.moveToNext()) {
 495                 final long id = cursor.getLong(ID_INDEX);
 496                 final String intentDescription = cursor.getString(INTENT_INDEX);
 497                 try {
 498                     Intent intent = Intent.parseUri(intentDescription, 0);
 499                     ComponentName cn = intent.getComponent();
 500                     Key key = null;
 501                     String backupKey = null;
 502                     if (cn != null) {
 503                         key = getKey(Key.ICON, cn.flattenToShortString());
 504                         backupKey = keyToBackupKey(key);
 505                         currentIds.add(backupKey);
 506                     } else {
 507                         Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 508                     }
 509                     if (savedIds.contains(backupKey)) {
 510                         if (VERBOSE) Log.v(TAG, &quot;already saved icon &quot; + backupKey);
 511 
 512                         // remember that we already backed this up previously
 513                         keys.add(key);
 514                     } else if (backupKey != null) {
 515                         if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 516                         if ((out.rows - startRows) &lt; MAX_ICONS_PER_PASS) {
 517                             if (VERBOSE) Log.v(TAG, &quot;saving icon &quot; + backupKey);
 518                             Bitmap icon = mIconCache.getIcon(intent);
 519                             keys.add(key);
 520                             if (icon != null &amp;&amp; !mIconCache.isDefaultIcon(icon)) {
 521                                 byte[] blob = packIcon(dpi, icon);
 522                                 writeRowToBackup(key, blob, out, data);
 523                             }
 524                         } else {
 525                             if (VERBOSE) Log.d(TAG, &quot;deferring icon backup &quot; + backupKey);
 526                             // too many icons for this pass, request another.
 527                             dataChanged();
 528                         }
 529                     }
 530                 } catch (URISyntaxException e) {
 531                     Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 532                 } catch (IOException e) {
 533                     Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 534                 }
 535 
 536             }
 537         } finally {
 538             cursor.close();
 539         }
 540         if (DEBUG) Log.d(TAG, &quot;icon currentIds.size()=&quot; + currentIds.size());
 541 
 542         // these IDs must have been deleted
 543         savedIds.removeAll(currentIds);
 544         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 545     }
 546 
 547     /**
 548      * Read an icon from the stream.
 549      *
 550      * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 551      *
 552      * @param key identifier for the row
 553      * @param buffer the serialized proto from the stream, may be larger than dataSize
 554      * @param dataSize the size of the proto from the stream
 555      * @param keys keys to mark as clean in the notes for next backup
 556      */
 557     private void restoreIcon(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 558         if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 559         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 560                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 561 
 562         try {
 563             Resource res = unpackIcon(buffer, 0, dataSize);
 564             if (DEBUG) {
 565                 Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 566             }
 567             if (DEBUG_PAYLOAD) {
 568                 Log.d(TAG, &quot;read &quot; +
 569                         Base64.encodeToString(res.data, 0, res.data.length,
 570                                 Base64.NO_WRAP));
 571             }
 572             Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 573             if (icon == null) {
 574                 Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 575             }
 576 
 577             if (!mRestoreEnabled) {
 578                 if (VERBOSE) {
 579                     Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 580                 }
 581                 return;
 582             } else {
 583                 IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(key.name),
 584                         icon, res.dpi);
 585             }
 586         } catch (IOException e) {
 587             Log.d(TAG, &quot;failed to save restored icon for: &quot; + key.name, e);
 588         }
 589     }
 590 
 591     /**
 592      * Write all the static widget resources we need to render placeholders
 593      * for a package that is not installed.
 594      *
 595      * @param in notes from last backup
 596      * @param data output stream for key/value pairs
 597      * @param out notes about this backup
 598      * @param keys keys to mark as clean in the notes for next backup
 599      * @throws IOException
 600      */
 601     private void backupWidgets(Journal in, BackupDataOutput data, Journal out,
 602             ArrayList&lt;Key&gt; keys) throws IOException {
 603         // persist static widget info that hasn&#x27;t been persisted yet
 604         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 605         if (appState == null || !initializeIconCache()) {
 606             Log.w(TAG, &quot;Failed to get icon cache during restore&quot;);
 607             return;
 608         }
 609         final ContentResolver cr = mContext.getContentResolver();
 610         final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 611         final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
 612         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 613         final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 614         if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 615 
 616         // read the old ID set
 617         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.WIDGET, in);
 618         if (DEBUG) Log.d(TAG, &quot;widgets savedIds.size()=&quot; + savedIds.size());
 619 
 620         int startRows = out.rows;
 621         if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 622         String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET;
 623         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 624                 where, null, null);
 625         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 626         try {
 627             cursor.moveToPosition(-1);
 628             while(cursor.moveToNext()) {
 629                 final long id = cursor.getLong(ID_INDEX);
 630                 final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 631                 final int spanX = cursor.getInt(SPANX_INDEX);
 632                 final int spanY = cursor.getInt(SPANY_INDEX);
 633                 final ComponentName provider = ComponentName.unflattenFromString(providerName);
 634                 Key key = null;
 635                 String backupKey = null;
 636                 if (provider != null) {
 637                     key = getKey(Key.WIDGET, providerName);
 638                     backupKey = keyToBackupKey(key);
 639                     currentIds.add(backupKey);
 640                 } else {
 641                     Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 642                 }
 643                 if (savedIds.contains(backupKey)) {
 644                     if (VERBOSE) Log.v(TAG, &quot;already saved widget &quot; + backupKey);
 645 
 646                     // remember that we already backed this up previously
 647                     keys.add(key);
 648                 } else if (backupKey != null) {
 649                     if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 650                     if ((out.rows - startRows) &lt; MAX_WIDGETS_PER_PASS) {
 651                         if (VERBOSE) Log.v(TAG, &quot;saving widget &quot; + backupKey);
 652                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx,
 653                                 spanY * profile.cellHeightPx, widgetSpacingLayout);
 654                         byte[] blob = packWidget(dpi, previewLoader, mIconCache, provider);
 655                         keys.add(key);
 656                         writeRowToBackup(key, blob, out, data);
 657 
 658                     } else {
 659                         if (VERBOSE) Log.d(TAG, &quot;deferring widget backup &quot; + backupKey);
 660                         // too many widgets for this pass, request another.
 661                         dataChanged();
 662                     }
 663                 }
 664             }
 665         } finally {
 666             cursor.close();
 667         }
 668         if (DEBUG) Log.d(TAG, &quot;widget currentIds.size()=&quot; + currentIds.size());
 669 
 670         // these IDs must have been deleted
 671         savedIds.removeAll(currentIds);
 672         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 673     }
 674 
 675     /**
 676      * Read a widget from the stream.
 677      *
 678      * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 679      *
 680      * @param key identifier for the row
 681      * @param buffer the serialized proto from the stream, may be larger than dataSize
 682      * @param dataSize the size of the proto from the stream
 683      * @param keys keys to mark as clean in the notes for next backup
 684      */
 685     private void restoreWidget(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 686         if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 687         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 688                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 689         try {
 690             Widget widget = unpackWidget(buffer, 0, dataSize);
 691             if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 692             if (widget.icon.data != null)  {
 693                 Bitmap icon = BitmapFactory
 694                         .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 695                 if (icon == null) {
 696                     Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 697                 }
 698             }
 699 
 700             if (!mRestoreEnabled) {
 701                 if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 702                 return;
 703             } else {
 704                 // future site of widget table mutation
 705             }
 706         } catch (InvalidProtocolBufferNanoException e) {
 707             Log.e(TAG, &quot;failed to decode widget&quot;, e);
 708         }
 709     }
 710 
 711     /** create a new key, with an integer ID.
 712      *
 713      * &lt;P&gt; Keys contain their own checksum instead of using
 714      * the heavy-weight CheckedMessage wrapper.
 715      */
 716     private Key getKey(int type, long id) {
 717         Key key = new Key();
 718         key.type = type;
 719         key.id = id;
 720         key.checksum = checkKey(key);
 721         return key;
 722     }
 723 
 724     /** create a new key for a named object.
 725      *
 726      * &lt;P&gt; Keys contain their own checksum instead of using
 727      * the heavy-weight CheckedMessage wrapper.
 728      */
 729     private Key getKey(int type, String name) {
 730         Key key = new Key();
 731         key.type = type;
 732         key.name = name;
 733         key.checksum = checkKey(key);
 734         return key;
 735     }
 736 
 737     /** keys need to be strings, serialize and encode. */
 738     private String keyToBackupKey(Key key) {
 739         return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 740     }
 741 
 742     /** keys need to be strings, decode and parse. */
 743     private Key backupKeyToKey(String backupKey) throws KeyParsingException {
 744         try {
 745             Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 746             if (key.checksum != checkKey(key)) {
 747                 key = null;
 748                 throw new KeyParsingException(&quot;invalid key read from stream&quot; + backupKey);
 749             }
 750             return key;
 751         } catch (InvalidProtocolBufferNanoException e) {
 752             throw new KeyParsingException(e);
 753         } catch (IllegalArgumentException e) {
 754             throw new KeyParsingException(e);
 755         }
 756     }
 757 
 758     private String getKeyName(Key key) {
 759         if (TextUtils.isEmpty(key.name)) {
 760             return Long.toString(key.id);
 761         } else {
 762             return key.name;
 763         }
 764 
 765     }
 766 
 767     private String geKeyType(Key key) {
 768         switch (key.type) {
 769             case Key.FAVORITE:
 770                 return &quot;favorite&quot;;
 771             case Key.SCREEN:
 772                 return &quot;screen&quot;;
 773             case Key.ICON:
 774                 return &quot;icon&quot;;
 775             case Key.WIDGET:
 776                 return &quot;widget&quot;;
 777             default:
 778                 return &quot;anonymous&quot;;
 779         }
 780     }
 781 
 782     /** Compute the checksum over the important bits of a key. */
 783     private long checkKey(Key key) {
 784         CRC32 checksum = new CRC32();
 785         checksum.update(key.type);
 786         checksum.update((int) (key.id &amp; 0xffff));
 787         checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 788         if (!TextUtils.isEmpty(key.name)) {
 789             checksum.update(key.name.getBytes());
 790         }
 791         return checksum.getValue();
 792     }
 793 
 794     /** Serialize a Favorite for persistence, including a checksum wrapper. */
 795     private byte[] packFavorite(Cursor c) {
 796         Favorite favorite = new Favorite();
 797         favorite.id = c.getLong(ID_INDEX);
 798         favorite.screen = c.getInt(SCREEN_INDEX);
 799         favorite.container = c.getInt(CONTAINER_INDEX);
 800         favorite.cellX = c.getInt(CELLX_INDEX);
 801         favorite.cellY = c.getInt(CELLY_INDEX);
 802         favorite.spanX = c.getInt(SPANX_INDEX);
 803         favorite.spanY = c.getInt(SPANY_INDEX);
 804         favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 805         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 806             String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 807             if (!TextUtils.isEmpty(iconPackage)) {
 808                 favorite.iconPackage = iconPackage;
 809             }
 810             String iconResource = c.getString(ICON_RESOURCE_INDEX);
 811             if (!TextUtils.isEmpty(iconResource)) {
 812                 favorite.iconResource = iconResource;
 813             }
 814         }
 815         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 816             byte[] blob = c.getBlob(ICON_INDEX);
 817             if (blob != null &amp;&amp; blob.length &gt; 0) {
 818                 favorite.icon = blob;
 819             }
 820         }
 821         String title = c.getString(TITLE_INDEX);
 822         if (!TextUtils.isEmpty(title)) {
 823             favorite.title = title;
 824         }
 825         String intent = c.getString(INTENT_INDEX);
 826         if (!TextUtils.isEmpty(intent)) {
 827             favorite.intent = intent;
 828         }
 829         favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 830         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 831             favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 832             String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 833             if (!TextUtils.isEmpty(appWidgetProvider)) {
 834                 favorite.appWidgetProvider = appWidgetProvider;
 835             }
 836         }
 837 
 838         return writeCheckedBytes(favorite);
 839     }
 840 
 841     /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 842     private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize)
 843             throws InvalidProtocolBufferNanoException {
 844         Favorite favorite = new Favorite();
 845         MessageNano.mergeFrom(favorite, readCheckedBytes(buffer, offset, dataSize));
 846         if (VERBOSE) Log.v(TAG, &quot;unpacked favorite &quot; + favorite.itemType + &quot;, &quot; +
 847                 (TextUtils.isEmpty(favorite.title) ? favorite.id : favorite.title));
 848         ContentValues values = new ContentValues();
 849         values.put(Favorites._ID, favorite.id);
 850         values.put(Favorites.SCREEN, favorite.screen);
 851         values.put(Favorites.CONTAINER, favorite.container);
 852         values.put(Favorites.CELLX, favorite.cellX);
 853         values.put(Favorites.CELLY, favorite.cellY);
 854         values.put(Favorites.SPANX, favorite.spanX);
 855         values.put(Favorites.SPANY, favorite.spanY);
 856         values.put(Favorites.ICON_TYPE, favorite.iconType);
 857         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 858             values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 859             values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 860         }
 861         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 862             values.put(Favorites.ICON, favorite.icon);
 863         }
 864         if (!TextUtils.isEmpty(favorite.title)) {
 865             values.put(Favorites.TITLE, favorite.title);
 866         } else {
 867             values.put(Favorites.TITLE, &quot;&quot;);
 868         }
 869         if (!TextUtils.isEmpty(favorite.intent)) {
 870             values.put(Favorites.INTENT, favorite.intent);
 871         }
 872         values.put(Favorites.ITEM_TYPE, favorite.itemType);
 873         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 874             if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 875                 values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 876             }
 877             values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 878         }
 879 
 880         // Let LauncherModel know we&#x27;ve been here.
 881         values.put(LauncherSettings.Favorites.RESTORED, 1);
 882 
 883         return values;
 884     }
 885 
 886     /** Serialize a Screen for persistence, including a checksum wrapper. */
 887     private byte[] packScreen(Cursor c) {
 888         Screen screen = new Screen();
 889         screen.id = c.getLong(ID_INDEX);
 890         screen.rank = c.getInt(SCREEN_RANK_INDEX);
 891 
 892         return writeCheckedBytes(screen);
 893     }
 894 
 895     /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 896     private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize)
 897             throws InvalidProtocolBufferNanoException {
 898         Screen screen = new Screen();
 899         MessageNano.mergeFrom(screen, readCheckedBytes(buffer, offset, dataSize));
 900         if (VERBOSE) Log.v(TAG, &quot;unpacked screen &quot; + screen.id + &quot;/&quot; + screen.rank);
 901         ContentValues values = new ContentValues();
 902         values.put(WorkspaceScreens._ID, screen.id);
 903         values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 904         return values;
 905     }
 906 
 907     /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 908     private byte[] packIcon(int dpi, Bitmap icon) {
 909         Resource res = new Resource();
 910         res.dpi = dpi;
 911         ByteArrayOutputStream os = new ByteArrayOutputStream();
 912         if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 913             res.data = os.toByteArray();
 914         }
 915         return writeCheckedBytes(res);
 916     }
 917 
 918     /** Deserialize an icon resource from persistence, after verifying checksum wrapper. */
 919     private static Resource unpackIcon(byte[] buffer, int offset, int dataSize)
 920             throws InvalidProtocolBufferNanoException {
 921         Resource res = new Resource();
 922         MessageNano.mergeFrom(res, readCheckedBytes(buffer, offset, dataSize));
 923         if (VERBOSE) Log.v(TAG, &quot;unpacked icon &quot; + res.dpi + &quot;/&quot; + res.data.length);
 924         return res;
 925     }
 926 
 927     /** Serialize a widget for persistence, including a checksum wrapper. */
 928     private byte[] packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 929             ComponentName provider) {
 930         final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);
 931         Widget widget = new Widget();
 932         widget.provider = provider.flattenToShortString();
 933         widget.label = info.label;
 934         widget.configure = info.configure != null;
 935         if (info.icon != 0) {
 936             widget.icon = new Resource();
 937             Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
 938             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 939             ByteArrayOutputStream os = new ByteArrayOutputStream();
 940             if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 941                 widget.icon.data = os.toByteArray();
 942                 widget.icon.dpi = dpi;
 943             }
 944         }
 945         if (info.previewImage != 0) {
 946             widget.preview = new Resource();
 947             Bitmap preview = previewLoader.generateWidgetPreview(info, null);
 948             ByteArrayOutputStream os = new ByteArrayOutputStream();
 949             if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 950                 widget.preview.data = os.toByteArray();
 951                 widget.preview.dpi = dpi;
 952             }
 953         }
 954         return writeCheckedBytes(widget);
 955     }
 956 
 957     /** Deserialize a widget from persistence, after verifying checksum wrapper. */
 958     private Widget unpackWidget(byte[] buffer, int offset, int dataSize)
 959             throws InvalidProtocolBufferNanoException {
 960         Widget widget = new Widget();
 961         MessageNano.mergeFrom(widget, readCheckedBytes(buffer, offset, dataSize));
 962         if (VERBOSE) Log.v(TAG, &quot;unpacked widget &quot; + widget.provider);
 963         return widget;
 964     }
 965 
 966     /**
 967      * Read the old journal from the input file.
 968      *
 969      * In the event of any error, just pretend we didn&#x27;t have a journal,
 970      * in that case, do a full backup.
 971      *
 972      * @param oldState the read-0only file descriptor pointing to the old journal
 973      * @return a Journal protocol buffer
 974      */
 975     private Journal readJournal(ParcelFileDescriptor oldState) {
 976         Journal journal = new Journal();
 977         if (oldState == null) {
 978             return journal;
 979         }
 980         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
 981         try {
 982             int availableBytes = inStream.available();
 983             if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
 984             if (availableBytes &lt; MAX_JOURNAL_SIZE) {
 985                 byte[] buffer = new byte[availableBytes];
 986                 int bytesRead = 0;
 987                 boolean valid = false;
 988                 InvalidProtocolBufferNanoException lastProtoException = null;
 989                 while (availableBytes &gt; 0) {
 990                     try {
 991                         // OMG what are you doing? This is crazy inefficient!
 992                         // If we read a byte that is not ours, we will cause trouble: b/12491813
 993                         // However, we don&#x27;t know how many bytes to expect (oops).
 994                         // So we have to step through *slowly*, watching for the end.
 995                         int result = inStream.read(buffer, bytesRead, 1);
 996                         if (result &gt; 0) {
 997                             availableBytes -= result;
 998                             bytesRead += result;
 999                             if (DEBUG &amp;&amp; (bytesRead % 100 == 0)) {
1000                                 Log.d(TAG, &quot;read some bytes: &quot; + bytesRead);
1001                             }
1002                         } else {
1003                             Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1004                             // stop reading and see what there is to parse
1005                             availableBytes = 0;
1006                         }
1007                     } catch (IOException e) {
1008                         buffer = null;
1009                         availableBytes = 0;
1010                     }
1011 
1012                     // check the buffer to see if we have a valid journal
1013                     try {
1014                         MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));
1015                         // if we are here, then we have read a valid, checksum-verified journal
1016                         valid = true;
1017                         availableBytes = 0;
1018                         if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1019                     } catch (InvalidProtocolBufferNanoException e) {
1020                         // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1021                         lastProtoException = e;
1022                         journal.clear();
1023                     }
1024                 }
1025                 if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1026                 if (!valid) {
1027                     Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1028                 }
1029             }
1030         } catch (IOException e) {
1031             Log.w(TAG, &quot;failed to close the journal&quot;, e);
1032         } finally {
1033             try {
1034                 inStream.close();
1035             } catch (IOException e) {
1036                 Log.w(TAG, &quot;failed to close the journal&quot;, e);
1037             }
1038         }
1039         return journal;
1040     }
1041 
1042     private void writeRowToBackup(Key key, byte[] blob, Journal out,
1043             BackupDataOutput data) throws IOException {
1044         String backupKey = keyToBackupKey(key);
1045         data.writeEntityHeader(backupKey, blob.length);
1046         data.writeEntityData(blob, blob.length);
1047         out.rows++;
1048         out.bytes += blob.length;
1049         if (VERBOSE) Log.v(TAG, &quot;saving &quot; + geKeyType(key) + &quot; &quot; + backupKey + &quot;: &quot; +
1050                 getKeyName(key) + &quot;/&quot; + blob.length);
1051         if(DEBUG_PAYLOAD) {
1052             String encoded = Base64.encodeToString(blob, 0, blob.length, Base64.NO_WRAP);
1053             final int chunkSize = 1024;
1054             for (int offset = 0; offset &lt; encoded.length(); offset += chunkSize) {
1055                 int end = offset + chunkSize;
1056                 end = Math.min(end, encoded.length());
1057                 Log.w(TAG, &quot;wrote &quot; + encoded.substring(offset, end));
1058             }
1059         }
1060     }
1061 
1062     private Set&lt;String&gt; getSavedIdsByType(int type, Journal in) {
1063         Set&lt;String&gt; savedIds = new HashSet&lt;String&gt;();
1064         for(int i = 0; i &lt; in.key.length; i++) {
1065             Key key = in.key[i];
1066             if (key.type == type) {
1067                 savedIds.add(keyToBackupKey(key));
1068             }
1069         }
1070         return savedIds;
1071     }
1072 
1073     private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data)
1074             throws IOException {
1075         int rows = 0;
1076         for(String deleted: deletedIds) {
1077             if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
1078             data.writeEntityHeader(deleted, -1);
1079             rows++;
1080         }
1081         return rows;
1082     }
1083 
1084     /**
1085      * Write the new journal to the output file.
1086      *
1087      * In the event of any error, just pretend we didn&#x27;t have a journal,
1088      * in that case, do a full backup.
1089 
1090      * @param newState the write-only file descriptor pointing to the new journal
1091      * @param journal a Journal protocol buffer
1092      */
1093     private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1094         FileOutputStream outStream = null;
1095         try {
1096             outStream = new FileOutputStream(newState.getFileDescriptor());
1097             final byte[] journalBytes = writeCheckedBytes(journal);
1098             outStream.write(journalBytes);
1099             outStream.close();
1100             if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1101         } catch (IOException e) {
1102             Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1103         }
1104     }
1105 
1106     /** Wrap a proto in a CheckedMessage and compute the checksum. */
1107     private byte[] writeCheckedBytes(MessageNano proto) {
1108         CheckedMessage wrapper = new CheckedMessage();
1109         wrapper.payload = MessageNano.toByteArray(proto);
1110         CRC32 checksum = new CRC32();
1111         checksum.update(wrapper.payload);
1112         wrapper.checksum = checksum.getValue();
1113         return MessageNano.toByteArray(wrapper);
1114     }
1115 
1116     /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1117     private static byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize)
1118             throws InvalidProtocolBufferNanoException {
1119         CheckedMessage wrapper = new CheckedMessage();
1120         MessageNano.mergeFrom(wrapper, buffer, offset, dataSize);
1121         CRC32 checksum = new CRC32();
1122         checksum.update(wrapper.payload);
1123         if (wrapper.checksum != checksum.getValue()) {
1124             throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1125         }
1126         return wrapper.payload;
1127     }
1128 
1129     private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {
1130         if (mWidgetMap == null) {
1131             List&lt;AppWidgetProviderInfo&gt; widgets =
1132                     AppWidgetManager.getInstance(mContext).getInstalledProviders();
1133             mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());
1134             for (AppWidgetProviderInfo info : widgets) {
1135                 mWidgetMap.put(info.provider, info);
1136             }
1137         }
1138         return mWidgetMap.get(component);
1139     }
1140 
1141 
1142     private boolean initializeIconCache() {
1143         if (mIconCache != null) {
1144             return true;
1145         }
1146 
1147         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
1148         if (appState == null) {
1149             Throwable stackTrace = new Throwable();
1150             stackTrace.fillInStackTrace();
1151             Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);
1152             return false;
1153         }
1154         mIconCache = appState.getIconCache();
1155         return mIconCache != null;
1156     }
1157 
1158 
1159    // check if the launcher is in a state to support backup
1160     private boolean launcherIsReady() {
1161         ContentResolver cr = mContext.getContentResolver();
1162         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);
1163         if (cursor == null) {
1164             // launcher data has been wiped, do nothing
1165             return false;
1166         }
1167         cursor.close();
1168 
1169         if (!initializeIconCache()) {
1170             // launcher services are unavailable, try again later
1171             dataChanged();
1172             return false;
1173         }
1174 
1175         return true;
1176     }
1177 
1178     private class KeyParsingException extends Throwable {
1179         private KeyParsingException(Throwable cause) {
1180             super(cause);
1181         }
1182 
1183         public KeyParsingException(String reason) {
1184             super(reason);
1185         }
1186     }
1187 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  19 import com.google.protobuf.nano.MessageNano;
  20 
  21 import com.android.launcher3.LauncherSettings.Favorites;
  22 import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  23 import com.android.launcher3.backup.BackupProtos;
  24 import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  25 import com.android.launcher3.backup.BackupProtos.Favorite;
  26 import com.android.launcher3.backup.BackupProtos.Journal;
  27 import com.android.launcher3.backup.BackupProtos.Key;
  28 import com.android.launcher3.backup.BackupProtos.Resource;
  29 import com.android.launcher3.backup.BackupProtos.Screen;
  30 import com.android.launcher3.backup.BackupProtos.Widget;
  31 
  32 import android.app.backup.BackupDataInputStream;
  33 import android.app.backup.BackupDataOutput;
  34 import android.app.backup.BackupHelper;
  35 import android.app.backup.BackupManager;
  36 import android.appwidget.AppWidgetManager;
  37 import android.appwidget.AppWidgetProviderInfo;
  38 import android.content.ComponentName;
  39 import android.content.ContentResolver;
  40 import android.content.ContentValues;
  41 import android.content.Context;
  42 import android.content.Intent;
  43 import android.database.Cursor;
  44 import android.graphics.Bitmap;
  45 import android.graphics.BitmapFactory;
  46 import android.graphics.drawable.Drawable;
  47 import android.os.ParcelFileDescriptor;
  48 import android.text.TextUtils;
  49 import android.util.Base64;
  50 import android.util.Log;
  51 
  52 import java.io.ByteArrayOutputStream;
  53 import java.io.FileInputStream;
  54 import java.io.FileOutputStream;
  55 import java.io.IOException;
  56 import java.net.URISyntaxException;
  57 import java.util.ArrayList;
  58 import java.util.HashMap;
  59 import java.util.HashSet;
  60 import java.util.List;
  61 import java.util.Set;
  62 import java.util.zip.CRC32;
  63 
  64 /**
  65  * Persist the launcher home state across calamities.
  66  */
  67 public class LauncherBackupHelper implements BackupHelper {
  68 
  69     private static final String TAG = &quot;LauncherBackupHelper&quot;;
  70     private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  71     private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  72     private static final boolean DEBUG_PAYLOAD = false;
  73 
  74     private static final int MAX_JOURNAL_SIZE = 1000000;
  75 
  76     /** icons are large, dribble them out */
  77     private static final int MAX_ICONS_PER_PASS = 10;
  78 
  79     /** widgets contain previews, which are very large, dribble them out */
  80     private static final int MAX_WIDGETS_PER_PASS = 5;
  81 
  82     public static final int IMAGE_COMPRESSION_QUALITY = 75;
  83 
  84     public static final String LAUNCHER_PREFIX = &quot;L&quot;;
  85 
  86     public static final String LAUNCHER_PREFS_PREFIX = &quot;LP&quot;;
  87 
  88     private static final Bitmap.CompressFormat IMAGE_FORMAT =
  89             android.graphics.Bitmap.CompressFormat.PNG;
  90 
  91     private static BackupManager sBackupManager;
  92 
  93     private static final String[] FAVORITE_PROJECTION = {
  94             Favorites._ID,                     // 0
  95             Favorites.MODIFIED,                // 1
  96             Favorites.INTENT,                  // 2
  97             Favorites.APPWIDGET_PROVIDER,      // 3
  98             Favorites.APPWIDGET_ID,            // 4
  99             Favorites.CELLX,                   // 5
 100             Favorites.CELLY,                   // 6
 101             Favorites.CONTAINER,               // 7
 102             Favorites.ICON,                    // 8
 103             Favorites.ICON_PACKAGE,            // 9
 104             Favorites.ICON_RESOURCE,           // 10
 105             Favorites.ICON_TYPE,               // 11
 106             Favorites.ITEM_TYPE,               // 12
 107             Favorites.SCREEN,                  // 13
 108             Favorites.SPANX,                   // 14
 109             Favorites.SPANY,                   // 15
 110             Favorites.TITLE,                   // 16
 111     };
 112 
 113     private static final int ID_INDEX = 0;
 114     private static final int ID_MODIFIED = 1;
 115     private static final int INTENT_INDEX = 2;
 116     private static final int APPWIDGET_PROVIDER_INDEX = 3;
 117     private static final int APPWIDGET_ID_INDEX = 4;
 118     private static final int CELLX_INDEX = 5;
 119     private static final int CELLY_INDEX = 6;
 120     private static final int CONTAINER_INDEX = 7;
 121     private static final int ICON_INDEX = 8;
 122     private static final int ICON_PACKAGE_INDEX = 9;
 123     private static final int ICON_RESOURCE_INDEX = 10;
 124     private static final int ICON_TYPE_INDEX = 11;
 125     private static final int ITEM_TYPE_INDEX = 12;
 126     private static final int SCREEN_INDEX = 13;
 127     private static final int SPANX_INDEX = 14;
 128     private static final int SPANY_INDEX = 15;
 129     private static final int TITLE_INDEX = 16;
 130 
 131     private static final String[] SCREEN_PROJECTION = {
 132             WorkspaceScreens._ID,              // 0
 133             WorkspaceScreens.MODIFIED,         // 1
 134             WorkspaceScreens.SCREEN_RANK       // 2
 135     };
 136 
 137     private static final int SCREEN_RANK_INDEX = 2;
 138 
 139     private static IconCache mIconCache;
 140 
 141     private final Context mContext;
 142 
 143     private final boolean mRestoreEnabled;
 144 
 145     private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;
 146 
 147     private ArrayList&lt;Key&gt; mKeys;
 148 
 149     public LauncherBackupHelper(Context context, boolean restoreEnabled) {
 150         mContext = context;
 151         mRestoreEnabled = restoreEnabled;
 152     }
 153 
 154     private void dataChanged() {
 155         if (sBackupManager == null) {
 156             sBackupManager = new BackupManager(mContext);
 157         }
 158         sBackupManager.dataChanged();
 159     }
 160 
 161     /**
 162      * Back up launcher data so we can restore the user&#x27;s state on a new device.
 163      *
 164      * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 165      *
 166      * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 167      *
 168      * @param oldState notes from the last backup
 169      * @param data incremental key/value pairs to persist off-device
 170      * @param newState notes for the next backup
 171      * @throws IOException
 172      */
 173     @Override
 174     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 175             ParcelFileDescriptor newState) {
 176         if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 177 
 178         Journal in = readJournal(oldState);
 179         Journal out = new Journal();
 180 
 181         long lastBackupTime = in.t;
 182         out.t = System.currentTimeMillis();
 183         out.rows = 0;
 184         out.bytes = 0;
 185 
 186         Log.v(TAG, &quot;lastBackupTime = &quot; + lastBackupTime);
 187 
 188         ArrayList&lt;Key&gt; keys = new ArrayList&lt;Key&gt;();
 189         if (launcherIsReady()) {
 190         try {
 191             backupFavorites(in, data, out, keys);
 192             backupScreens(in, data, out, keys);
 193             backupIcons(in, data, out, keys);
 194             backupWidgets(in, data, out, keys);
 195         } catch (IOException e) {
 196             Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 197         }
 198             out.key = keys.toArray(new BackupProtos.Key[keys.size()]);
 199         } else {
 200             out = in;
 201         }
 202 
 203 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
 204 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 205         out.key = keys.toArray(BackupProtos.Key.EMPTY_ARRAY);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 206         writeJournal(newState, out);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 207         Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 208     }</span>
 209 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 210         out.key = keys.toArray(BackupProtos.Key.emptyArray());</span>
 211 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 212         writeJournal(newState, out);
 213         Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);
 214     }
 215 
 216     /**
 217      * Restore launcher configuration from the restored data stream.
 218      *
 219      * &lt;P&gt;Keys may arrive in any order.
 220      *
 221      * @param data the key/value pair from the server
 222      */
 223     @Override
 224     public void restoreEntity(BackupDataInputStream data) {
 225         if (VERBOSE) Log.v(TAG, &quot;restoreEntity&quot;);
 226         if (mKeys == null) {
 227             mKeys = new ArrayList&lt;Key&gt;();
 228         }
 229         byte[] buffer = new byte[512];
 230             String backupKey = data.getKey();
 231             int dataSize = data.size();
 232             if (buffer.length &lt; dataSize) {
 233                 buffer = new byte[dataSize];
 234             }
 235             Key key = null;
 236         int bytesRead = 0;
 237         try {
 238             bytesRead = data.read(buffer, 0, dataSize);
 239             if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 240         } catch (IOException e) {
 241             Log.e(TAG, &quot;failed to read entity from restore data&quot;, e);
 242         }
 243         try {
 244             key = backupKeyToKey(backupKey);
 245             mKeys.add(key);
 246             switch (key.type) {
 247                 case Key.FAVORITE:
 248                     restoreFavorite(key, buffer, dataSize, mKeys);
 249                     break;
 250 
 251                 case Key.SCREEN:
 252                     restoreScreen(key, buffer, dataSize, mKeys);
 253                     break;
 254 
 255                 case Key.ICON:
 256                     restoreIcon(key, buffer, dataSize, mKeys);
 257                     break;
 258 
 259                 case Key.WIDGET:
 260                     restoreWidget(key, buffer, dataSize, mKeys);
 261                     break;
 262 
 263                 default:
 264                     Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 265                     break;
 266             }
 267         } catch (KeyParsingException e) {
 268             Log.w(TAG, &quot;ignoring unparsable backup key: &quot; + backupKey);
 269         }
 270 
 271     }
 272 
 273     /**
 274      * Record the restore state for the next backup.
 275      *
 276      * @param newState notes about the backup state after restore.
 277      */
 278     @Override
 279     public void writeNewStateDescription(ParcelFileDescriptor newState) {
 280         // clear the output journal time, to force a full backup to
 281         // will catch any changes the restore process might have made
 282         Journal out = new Journal();
 283         out.t = 0;
 284 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 285         out.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);</span>
 286 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 287         out.key = mKeys.toArray(BackupProtos.Key.EMPTY_ARRAY);</span>
 288 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 289         out.key = mKeys.toArray(BackupProtos.Key.emptyArray());</span>
 290 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 291         writeJournal(newState, out);
 292         Log.v(TAG, &quot;onRestore: read &quot; + mKeys.size() + &quot; rows&quot;);
 293         mKeys.clear();
 294     }
 295 
 296     /**
 297      * Write all modified favorites to the data stream.
 298      *
 299      *
 300      * @param in notes from last backup
 301      * @param data output stream for key/value pairs
 302      * @param out notes about this backup
 303      * @param keys keys to mark as clean in the notes for next backup
 304      * @throws IOException
 305      */
 306     private void backupFavorites(Journal in, BackupDataOutput data, Journal out,
 307             ArrayList&lt;Key&gt; keys)
 308             throws IOException {
 309         // read the old ID set
 310         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.FAVORITE, in);
 311         if (DEBUG) Log.d(TAG, &quot;favorite savedIds.size()=&quot; + savedIds.size());
 312 
 313         // persist things that have changed since the last backup
 314         ContentResolver cr = mContext.getContentResolver();
 315         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 316                 null, null, null);
 317         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 318         try {
 319             cursor.moveToPosition(-1);
 320             while(cursor.moveToNext()) {
 321                 final long id = cursor.getLong(ID_INDEX);
 322                 final long updateTime = cursor.getLong(ID_MODIFIED);
 323                 Key key = getKey(Key.FAVORITE, id);
 324                 keys.add(key);
 325                 final String backupKey = keyToBackupKey(key);
 326                 currentIds.add(backupKey);
 327                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 328                     byte[] blob = packFavorite(cursor);
 329                     writeRowToBackup(key, blob, out, data);
 330                 } else {
 331                     if (VERBOSE) Log.v(TAG, &quot;favorite &quot; + id + &quot; was too old: &quot; + updateTime);
 332                 }
 333             }
 334         } finally {
 335             cursor.close();
 336         }
 337         if (DEBUG) Log.d(TAG, &quot;favorite currentIds.size()=&quot; + currentIds.size());
 338 
 339         // these IDs must have been deleted
 340         savedIds.removeAll(currentIds);
 341         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 342     }
 343 
 344     /**
 345      * Read a favorite from the stream.
 346      *
 347      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 348      *
 349      * @param key identifier for the row
 350      * @param buffer the serialized proto from the stream, may be larger than dataSize
 351      * @param dataSize the size of the proto from the stream
 352      * @param keys keys to mark as clean in the notes for next backup
 353      */
 354     private void restoreFavorite(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 355         if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 356         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 357                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 358 
 359         if (!mRestoreEnabled) {
 360             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 361             return;
 362         }
 363 
 364         try {
 365             ContentResolver cr = mContext.getContentResolver();
 366             ContentValues values = unpackFavorite(buffer, 0, dataSize);
 367             cr.insert(Favorites.CONTENT_URI, values);
 368         } catch (InvalidProtocolBufferNanoException e) {
 369             Log.e(TAG, &quot;failed to decode favorite&quot;, e);
 370         }
 371     }
 372 
 373     /**
 374      * Write all modified screens to the data stream.
 375      *
 376      *
 377      * @param in notes from last backup
 378      * @param data output stream for key/value pairs
 379      * @param out notes about this backup
 380      * @param keys keys to mark as clean in the notes for next backup
 381      * @throws IOException
 382      */
 383     private void backupScreens(Journal in, BackupDataOutput data, Journal out,
 384             ArrayList&lt;Key&gt; keys)
 385             throws IOException {
 386         // read the old ID set
 387         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.SCREEN, in);
 388         if (DEBUG) Log.d(TAG, &quot;screen savedIds.size()=&quot; + savedIds.size());
 389 
 390         // persist things that have changed since the last backup
 391         ContentResolver cr = mContext.getContentResolver();
 392         Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 393                 null, null, null);
 394         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 395         try {
 396             cursor.moveToPosition(-1);
 397             if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + in.t);
 398             while(cursor.moveToNext()) {
 399                 final long id = cursor.getLong(ID_INDEX);
 400                 final long updateTime = cursor.getLong(ID_MODIFIED);
 401                 Key key = getKey(Key.SCREEN, id);
 402                 keys.add(key);
 403                 final String backupKey = keyToBackupKey(key);
 404                 currentIds.add(backupKey);
 405                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 406                     byte[] blob = packScreen(cursor);
 407                     writeRowToBackup(key, blob, out, data);
 408                 } else {
 409                     if (VERBOSE) Log.v(TAG, &quot;screen &quot; + id + &quot; was too old: &quot; + updateTime);
 410                 }
 411             }
 412         } finally {
 413             cursor.close();
 414         }
 415         if (DEBUG) Log.d(TAG, &quot;screen currentIds.size()=&quot; + currentIds.size());
 416 
 417         // these IDs must have been deleted
 418         savedIds.removeAll(currentIds);
 419         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 420     }
 421 
 422     /**
 423      * Read a screen from the stream.
 424      *
 425      * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 426      *
 427      * @param key identifier for the row
 428      * @param buffer the serialized proto from the stream, may be larger than dataSize
 429      * @param dataSize the size of the proto from the stream
 430      * @param keys keys to mark as clean in the notes for next backup
 431      */
 432     private void restoreScreen(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 433         if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 434         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 435                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 436 
 437         if (!mRestoreEnabled) {
 438             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 439             return;
 440         }
 441 
 442         try {
 443             ContentResolver cr = mContext.getContentResolver();
 444             ContentValues values = unpackScreen(buffer, 0, dataSize);
 445             cr.insert(WorkspaceScreens.CONTENT_URI, values);
 446 
 447         } catch (InvalidProtocolBufferNanoException e) {
 448             Log.e(TAG, &quot;failed to decode screen&quot;, e);
 449         }
 450     }
 451 
 452     /**
 453      * Write all the static icon resources we need to render placeholders
 454      * for a package that is not installed.
 455      *
 456      * @param in notes from last backup
 457      * @param data output stream for key/value pairs
 458      * @param out notes about this backup
 459      * @param keys keys to mark as clean in the notes for next backup
 460      * @throws IOException
 461      */
 462     private void backupIcons(Journal in, BackupDataOutput data, Journal out,
 463             ArrayList&lt;Key&gt; keys) throws IOException {
 464         // persist icons that haven&#x27;t been persisted yet
 465         if (!initializeIconCache()) {
 466             dataChanged(); // try again later
 467             if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 468             return;
 469         }
 470         final ContentResolver cr = mContext.getContentResolver();
 471         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 472 
 473         // read the old ID set
 474         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.ICON, in);
 475         if (DEBUG) Log.d(TAG, &quot;icon savedIds.size()=&quot; + savedIds.size());
 476 
 477         int startRows = out.rows;
 478         if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 479         String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION;
 480         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 481                 where, null, null);
 482         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 483         try {
 484             cursor.moveToPosition(-1);
 485             while(cursor.moveToNext()) {
 486                 final long id = cursor.getLong(ID_INDEX);
 487                 final String intentDescription = cursor.getString(INTENT_INDEX);
 488                 try {
 489                     Intent intent = Intent.parseUri(intentDescription, 0);
 490                     ComponentName cn = intent.getComponent();
 491                     Key key = null;
 492                     String backupKey = null;
 493                     if (cn != null) {
 494                         key = getKey(Key.ICON, cn.flattenToShortString());
 495                         backupKey = keyToBackupKey(key);
 496                         currentIds.add(backupKey);
 497                     } else {
 498                         Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 499                     }
 500                     if (savedIds.contains(backupKey)) {
 501                         if (VERBOSE) Log.v(TAG, &quot;already saved icon &quot; + backupKey);
 502 
 503                         // remember that we already backed this up previously
 504                         keys.add(key);
 505                     } else if (backupKey != null) {
 506                         if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 507                         if ((out.rows - startRows) &lt; MAX_ICONS_PER_PASS) {
 508                             if (VERBOSE) Log.v(TAG, &quot;saving icon &quot; + backupKey);
 509                             Bitmap icon = mIconCache.getIcon(intent);
 510                             keys.add(key);
 511                             if (icon != null &amp;&amp; !mIconCache.isDefaultIcon(icon)) {
 512                                 byte[] blob = packIcon(dpi, icon);
 513                                 writeRowToBackup(key, blob, out, data);
 514                             }
 515                         } else {
 516                             if (VERBOSE) Log.d(TAG, &quot;deferring icon backup &quot; + backupKey);
 517                             // too many icons for this pass, request another.
 518                             dataChanged();
 519                         }
 520                     }
 521                 } catch (URISyntaxException e) {
 522                     Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 523                 } catch (IOException e) {
 524                     Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 525                 }
 526 
 527             }
 528         } finally {
 529             cursor.close();
 530         }
 531         if (DEBUG) Log.d(TAG, &quot;icon currentIds.size()=&quot; + currentIds.size());
 532 
 533         // these IDs must have been deleted
 534         savedIds.removeAll(currentIds);
 535         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 536     }
 537 
 538     /**
 539      * Read an icon from the stream.
 540      *
 541      * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 542      *
 543      * @param key identifier for the row
 544      * @param buffer the serialized proto from the stream, may be larger than dataSize
 545      * @param dataSize the size of the proto from the stream
 546      * @param keys keys to mark as clean in the notes for next backup
 547      */
 548     private void restoreIcon(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 549         if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 550         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 551                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 552 
 553         try {
 554             Resource res = unpackIcon(buffer, 0, dataSize);
 555             if (DEBUG) {
 556                 Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 557             }
 558             if (DEBUG_PAYLOAD) {
 559                 Log.d(TAG, &quot;read &quot; +
 560                     Base64.encodeToString(res.data, 0, res.data.length,
 561                             Base64.NO_WRAP));
 562             }
 563             Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 564             if (icon == null) {
 565                 Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 566             }
 567 
 568             if (!mRestoreEnabled) {
 569                 if (VERBOSE) {
 570                     Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 571                 }
 572                 return;
 573             } else {
 574                 IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(key.name),
 575                         icon, res.dpi);
 576             }
 577         } catch (IOException e) {
 578             Log.d(TAG, &quot;failed to save restored icon for: &quot; + key.name, e);
 579         }
 580     }
 581 
 582     /**
 583      * Write all the static widget resources we need to render placeholders
 584      * for a package that is not installed.
 585      *
 586      * @param in notes from last backup
 587      * @param data output stream for key/value pairs
 588      * @param out notes about this backup
 589      * @param keys keys to mark as clean in the notes for next backup
 590      * @throws IOException
 591      */
 592     private void backupWidgets(Journal in, BackupDataOutput data, Journal out,
 593             ArrayList&lt;Key&gt; keys) throws IOException {
 594         // persist static widget info that hasn&#x27;t been persisted yet
 595         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 596         if (appState == null || !initializeIconCache()) {
 597             Log.w(TAG, &quot;Failed to get icon cache during restore&quot;);
 598             return;
 599         }
 600         final ContentResolver cr = mContext.getContentResolver();
 601         final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 602         final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
 603         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 604         final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 605         if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 606 
 607         // read the old ID set
 608         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.WIDGET, in);
 609         if (DEBUG) Log.d(TAG, &quot;widgets savedIds.size()=&quot; + savedIds.size());
 610 
 611         int startRows = out.rows;
 612         if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 613         String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET;
 614         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 615                 where, null, null);
 616         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 617         try {
 618             cursor.moveToPosition(-1);
 619             while(cursor.moveToNext()) {
 620                 final long id = cursor.getLong(ID_INDEX);
 621                 final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 622                 final int spanX = cursor.getInt(SPANX_INDEX);
 623                 final int spanY = cursor.getInt(SPANY_INDEX);
 624                 final ComponentName provider = ComponentName.unflattenFromString(providerName);
 625                 Key key = null;
 626                 String backupKey = null;
 627                 if (provider != null) {
 628                     key = getKey(Key.WIDGET, providerName);
 629                     backupKey = keyToBackupKey(key);
 630                     currentIds.add(backupKey);
 631                 } else {
 632                     Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 633                 }
 634                 if (savedIds.contains(backupKey)) {
 635                     if (VERBOSE) Log.v(TAG, &quot;already saved widget &quot; + backupKey);
 636 
 637                     // remember that we already backed this up previously
 638                     keys.add(key);
 639                 } else if (backupKey != null) {
 640                     if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 641                     if ((out.rows - startRows) &lt; MAX_WIDGETS_PER_PASS) {
 642                         if (VERBOSE) Log.v(TAG, &quot;saving widget &quot; + backupKey);
 643                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx,
 644                                 spanY * profile.cellHeightPx, widgetSpacingLayout);
 645                         byte[] blob = packWidget(dpi, previewLoader, mIconCache, provider);
 646                         keys.add(key);
 647                         writeRowToBackup(key, blob, out, data);
 648 
 649                     } else {
 650                         if (VERBOSE) Log.d(TAG, &quot;deferring widget backup &quot; + backupKey);
 651                         // too many widgets for this pass, request another.
 652                         dataChanged();
 653                     }
 654                 }
 655             }
 656         } finally {
 657             cursor.close();
 658         }
 659         if (DEBUG) Log.d(TAG, &quot;widget currentIds.size()=&quot; + currentIds.size());
 660 
 661         // these IDs must have been deleted
 662         savedIds.removeAll(currentIds);
 663         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 664     }
 665 
 666     /**
 667      * Read a widget from the stream.
 668      *
 669      * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 670      *
 671      * @param key identifier for the row
 672      * @param buffer the serialized proto from the stream, may be larger than dataSize
 673      * @param dataSize the size of the proto from the stream
 674      * @param keys keys to mark as clean in the notes for next backup
 675      */
 676     private void restoreWidget(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 677         if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 678         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 679                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 680         try {
 681             Widget widget = unpackWidget(buffer, 0, dataSize);
 682             if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 683             if (widget.icon.data != null)  {
 684                 Bitmap icon = BitmapFactory
 685                         .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 686                 if (icon == null) {
 687                     Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 688                 }
 689             }
 690 
 691             if (!mRestoreEnabled) {
 692                 if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 693                 return;
 694             } else {
 695                 // future site of widget table mutation
 696             }
 697         } catch (InvalidProtocolBufferNanoException e) {
 698             Log.e(TAG, &quot;failed to decode widget&quot;, e);
 699         }
 700     }
 701 
 702     /** create a new key, with an integer ID.
 703      *
 704      * &lt;P&gt; Keys contain their own checksum instead of using
 705      * the heavy-weight CheckedMessage wrapper.
 706      */
 707     private Key getKey(int type, long id) {
 708         Key key = new Key();
 709         key.type = type;
 710         key.id = id;
 711         key.checksum = checkKey(key);
 712         return key;
 713     }
 714 
 715     /** create a new key for a named object.
 716      *
 717      * &lt;P&gt; Keys contain their own checksum instead of using
 718      * the heavy-weight CheckedMessage wrapper.
 719      */
 720     private Key getKey(int type, String name) {
 721         Key key = new Key();
 722         key.type = type;
 723         key.name = name;
 724         key.checksum = checkKey(key);
 725         return key;
 726     }
 727 
 728     /** keys need to be strings, serialize and encode. */
 729     private String keyToBackupKey(Key key) {
 730         return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 731     }
 732 
 733     /** keys need to be strings, decode and parse. */
 734     private Key backupKeyToKey(String backupKey) throws KeyParsingException {
 735         try {
 736             Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 737             if (key.checksum != checkKey(key)) {
 738                 key = null;
 739                 throw new KeyParsingException(&quot;invalid key read from stream&quot; + backupKey);
 740             }
 741             return key;
 742         } catch (InvalidProtocolBufferNanoException e) {
 743             throw new KeyParsingException(e);
 744         } catch (IllegalArgumentException e) {
 745             throw new KeyParsingException(e);
 746         }
 747     }
 748 
 749     private String getKeyName(Key key) {
 750         if (TextUtils.isEmpty(key.name)) {
 751             return Long.toString(key.id);
 752         } else {
 753             return key.name;
 754         }
 755 
 756     }
 757 
 758     private String geKeyType(Key key) {
 759         switch (key.type) {
 760             case Key.FAVORITE:
 761                 return &quot;favorite&quot;;
 762             case Key.SCREEN:
 763                 return &quot;screen&quot;;
 764             case Key.ICON:
 765                 return &quot;icon&quot;;
 766             case Key.WIDGET:
 767                 return &quot;widget&quot;;
 768             default:
 769                 return &quot;anonymous&quot;;
 770         }
 771     }
 772 
 773     /** Compute the checksum over the important bits of a key. */
 774     private long checkKey(Key key) {
 775         CRC32 checksum = new CRC32();
 776         checksum.update(key.type);
 777         checksum.update((int) (key.id &amp; 0xffff));
 778         checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 779         if (!TextUtils.isEmpty(key.name)) {
 780             checksum.update(key.name.getBytes());
 781         }
 782         return checksum.getValue();
 783     }
 784 
 785     /** Serialize a Favorite for persistence, including a checksum wrapper. */
 786     private byte[] packFavorite(Cursor c) {
 787         Favorite favorite = new Favorite();
 788         favorite.id = c.getLong(ID_INDEX);
 789         favorite.screen = c.getInt(SCREEN_INDEX);
 790         favorite.container = c.getInt(CONTAINER_INDEX);
 791         favorite.cellX = c.getInt(CELLX_INDEX);
 792         favorite.cellY = c.getInt(CELLY_INDEX);
 793         favorite.spanX = c.getInt(SPANX_INDEX);
 794         favorite.spanY = c.getInt(SPANY_INDEX);
 795         favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 796         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 797             String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 798             if (!TextUtils.isEmpty(iconPackage)) {
 799                 favorite.iconPackage = iconPackage;
 800             }
 801             String iconResource = c.getString(ICON_RESOURCE_INDEX);
 802             if (!TextUtils.isEmpty(iconResource)) {
 803                 favorite.iconResource = iconResource;
 804             }
 805         }
 806         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 807             byte[] blob = c.getBlob(ICON_INDEX);
 808             if (blob != null &amp;&amp; blob.length &gt; 0) {
 809                 favorite.icon = blob;
 810             }
 811         }
 812         String title = c.getString(TITLE_INDEX);
 813         if (!TextUtils.isEmpty(title)) {
 814             favorite.title = title;
 815         }
 816         String intent = c.getString(INTENT_INDEX);
 817         if (!TextUtils.isEmpty(intent)) {
 818             favorite.intent = intent;
 819         }
 820         favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 821         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 822             favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 823             String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 824             if (!TextUtils.isEmpty(appWidgetProvider)) {
 825                 favorite.appWidgetProvider = appWidgetProvider;
 826             }
 827         }
 828 
 829         return writeCheckedBytes(favorite);
 830     }
 831 
 832     /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 833     private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize)
 834             throws InvalidProtocolBufferNanoException {
 835         Favorite favorite = new Favorite();
 836         MessageNano.mergeFrom(favorite, readCheckedBytes(buffer, offset, dataSize));
 837         if (VERBOSE) Log.v(TAG, &quot;unpacked favorite &quot; + favorite.itemType + &quot;, &quot; +
 838                 (TextUtils.isEmpty(favorite.title) ? favorite.id : favorite.title));
 839         ContentValues values = new ContentValues();
 840         values.put(Favorites._ID, favorite.id);
 841         values.put(Favorites.SCREEN, favorite.screen);
 842         values.put(Favorites.CONTAINER, favorite.container);
 843         values.put(Favorites.CELLX, favorite.cellX);
 844         values.put(Favorites.CELLY, favorite.cellY);
 845         values.put(Favorites.SPANX, favorite.spanX);
 846         values.put(Favorites.SPANY, favorite.spanY);
 847         values.put(Favorites.ICON_TYPE, favorite.iconType);
 848         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 849             values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 850             values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 851         }
 852         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 853             values.put(Favorites.ICON, favorite.icon);
 854         }
 855         if (!TextUtils.isEmpty(favorite.title)) {
 856             values.put(Favorites.TITLE, favorite.title);
 857         } else {
 858             values.put(Favorites.TITLE, &quot;&quot;);
 859         }
 860         if (!TextUtils.isEmpty(favorite.intent)) {
 861             values.put(Favorites.INTENT, favorite.intent);
 862         }
 863         values.put(Favorites.ITEM_TYPE, favorite.itemType);
 864         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 865             if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 866                 values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 867             }
 868             values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 869         }
 870 
 871         // Let LauncherModel know we&#x27;ve been here.
 872         values.put(LauncherSettings.Favorites.RESTORED, 1);
 873 
 874         return values;
 875     }
 876 
 877     /** Serialize a Screen for persistence, including a checksum wrapper. */
 878     private byte[] packScreen(Cursor c) {
 879         Screen screen = new Screen();
 880         screen.id = c.getLong(ID_INDEX);
 881         screen.rank = c.getInt(SCREEN_RANK_INDEX);
 882 
 883         return writeCheckedBytes(screen);
 884     }
 885 
 886     /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 887     private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize)
 888             throws InvalidProtocolBufferNanoException {
 889         Screen screen = new Screen();
 890         MessageNano.mergeFrom(screen, readCheckedBytes(buffer, offset, dataSize));
 891         if (VERBOSE) Log.v(TAG, &quot;unpacked screen &quot; + screen.id + &quot;/&quot; + screen.rank);
 892         ContentValues values = new ContentValues();
 893         values.put(WorkspaceScreens._ID, screen.id);
 894         values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 895         return values;
 896     }
 897 
 898     /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 899     private byte[] packIcon(int dpi, Bitmap icon) {
 900         Resource res = new Resource();
 901         res.dpi = dpi;
 902         ByteArrayOutputStream os = new ByteArrayOutputStream();
 903         if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 904             res.data = os.toByteArray();
 905         }
 906         return writeCheckedBytes(res);
 907     }
 908 
 909     /** Deserialize an icon resource from persistence, after verifying checksum wrapper. */
 910     private static Resource unpackIcon(byte[] buffer, int offset, int dataSize)
 911             throws InvalidProtocolBufferNanoException {
 912         Resource res = new Resource();
 913         MessageNano.mergeFrom(res, readCheckedBytes(buffer, offset, dataSize));
 914         if (VERBOSE) Log.v(TAG, &quot;unpacked icon &quot; + res.dpi + &quot;/&quot; + res.data.length);
 915         return res;
 916     }
 917 
 918     /** Serialize a widget for persistence, including a checksum wrapper. */
 919     private byte[] packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 920             ComponentName provider) {
 921         final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);
 922         Widget widget = new Widget();
 923         widget.provider = provider.flattenToShortString();
 924         widget.label = info.label;
 925         widget.configure = info.configure != null;
 926         if (info.icon != 0) {
 927             widget.icon = new Resource();
 928             Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
 929             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 930             ByteArrayOutputStream os = new ByteArrayOutputStream();
 931             if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 932                 widget.icon.data = os.toByteArray();
 933                 widget.icon.dpi = dpi;
 934             }
 935         }
 936         if (info.previewImage != 0) {
 937             widget.preview = new Resource();
 938             Bitmap preview = previewLoader.generateWidgetPreview(info, null);
 939             ByteArrayOutputStream os = new ByteArrayOutputStream();
 940             if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 941                 widget.preview.data = os.toByteArray();
 942                 widget.preview.dpi = dpi;
 943             }
 944         }
 945         return writeCheckedBytes(widget);
 946     }
 947 
 948     /** Deserialize a widget from persistence, after verifying checksum wrapper. */
 949     private Widget unpackWidget(byte[] buffer, int offset, int dataSize)
 950             throws InvalidProtocolBufferNanoException {
 951         Widget widget = new Widget();
 952         MessageNano.mergeFrom(widget, readCheckedBytes(buffer, offset, dataSize));
 953         if (VERBOSE) Log.v(TAG, &quot;unpacked widget &quot; + widget.provider);
 954         return widget;
 955     }
 956 
 957     /**
 958      * Read the old journal from the input file.
 959      *
 960      * In the event of any error, just pretend we didn&#x27;t have a journal,
 961      * in that case, do a full backup.
 962      *
 963      * @param oldState the read-0only file descriptor pointing to the old journal
 964      * @return a Journal protocol buffer
 965      */
 966     private Journal readJournal(ParcelFileDescriptor oldState) {
 967         Journal journal = new Journal();
 968         if (oldState == null) {
 969             return journal;
 970         }
 971         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
 972         try {
 973             int availableBytes = inStream.available();
 974             if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
 975             if (availableBytes &lt; MAX_JOURNAL_SIZE) {
 976                 byte[] buffer = new byte[availableBytes];
 977                 int bytesRead = 0;
 978                 boolean valid = false;
 979                 InvalidProtocolBufferNanoException lastProtoException = null;
 980                 while (availableBytes &gt; 0) {
 981                     try {
 982                         // OMG what are you doing? This is crazy inefficient!
 983                         // If we read a byte that is not ours, we will cause trouble: b/12491813
 984                         // However, we don&#x27;t know how many bytes to expect (oops).
 985                         // So we have to step through *slowly*, watching for the end.
 986                         int result = inStream.read(buffer, bytesRead, 1);
 987                         if (result &gt; 0) {
 988                             availableBytes -= result;
 989                             bytesRead += result;
 990                             if (DEBUG &amp;&amp; (bytesRead % 100 == 0)) {
 991                                 Log.d(TAG, &quot;read some bytes: &quot; + bytesRead);
 992                             }
 993                         } else {
 994                             Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
 995                             // stop reading and see what there is to parse
 996                             availableBytes = 0;
 997                         }
 998                     } catch (IOException e) {
 999                         buffer = null;
1000                         availableBytes = 0;
1001                     }
1002 
1003                     // check the buffer to see if we have a valid journal
1004                     try {
1005                         MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));
1006                         // if we are here, then we have read a valid, checksum-verified journal
1007                         valid = true;
1008                         availableBytes = 0;
1009                         if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1010                     } catch (InvalidProtocolBufferNanoException e) {
1011                         // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1012                         lastProtoException = e;
1013                         journal.clear();
1014                     }
1015                 }
1016                 if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1017                 if (!valid) {
1018                     Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1019                 }
1020             }
1021         } catch (IOException e) {
1022             Log.w(TAG, &quot;failed to close the journal&quot;, e);
1023         } finally {
1024             try {
1025                 inStream.close();
1026             } catch (IOException e) {
1027                 Log.w(TAG, &quot;failed to close the journal&quot;, e);
1028             }
1029         }
1030         return journal;
1031     }
1032 
1033     private void writeRowToBackup(Key key, byte[] blob, Journal out,
1034             BackupDataOutput data) throws IOException {
1035         String backupKey = keyToBackupKey(key);
1036         data.writeEntityHeader(backupKey, blob.length);
1037         data.writeEntityData(blob, blob.length);
1038         out.rows++;
1039         out.bytes += blob.length;
1040         if (VERBOSE) Log.v(TAG, &quot;saving &quot; + geKeyType(key) + &quot; &quot; + backupKey + &quot;: &quot; +
1041                 getKeyName(key) + &quot;/&quot; + blob.length);
1042         if(DEBUG_PAYLOAD) {
1043             String encoded = Base64.encodeToString(blob, 0, blob.length, Base64.NO_WRAP);
1044             final int chunkSize = 1024;
1045             for (int offset = 0; offset &lt; encoded.length(); offset += chunkSize) {
1046                 int end = offset + chunkSize;
1047                 end = Math.min(end, encoded.length());
1048                 Log.w(TAG, &quot;wrote &quot; + encoded.substring(offset, end));
1049             }
1050         }
1051     }
1052 
1053     private Set&lt;String&gt; getSavedIdsByType(int type, Journal in) {
1054         Set&lt;String&gt; savedIds = new HashSet&lt;String&gt;();
1055         for(int i = 0; i &lt; in.key.length; i++) {
1056             Key key = in.key[i];
1057             if (key.type == type) {
1058                 savedIds.add(keyToBackupKey(key));
1059             }
1060         }
1061         return savedIds;
1062     }
1063 
1064     private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data)
1065             throws IOException {
1066         int rows = 0;
1067         for(String deleted: deletedIds) {
1068             if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
1069             data.writeEntityHeader(deleted, -1);
1070             rows++;
1071         }
1072         return rows;
1073     }
1074 
1075     /**
1076      * Write the new journal to the output file.
1077      *
1078      * In the event of any error, just pretend we didn&#x27;t have a journal,
1079      * in that case, do a full backup.
1080 
1081      * @param newState the write-only file descriptor pointing to the new journal
1082      * @param journal a Journal protocol buffer
1083      */
1084     private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1085         FileOutputStream outStream = null;
1086         try {
1087             outStream = new FileOutputStream(newState.getFileDescriptor());
1088             final byte[] journalBytes = writeCheckedBytes(journal);
1089             outStream.write(journalBytes);
1090             outStream.close();
1091             if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1092         } catch (IOException e) {
1093             Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1094         }
1095     }
1096 
1097     /** Wrap a proto in a CheckedMessage and compute the checksum. */
1098     private byte[] writeCheckedBytes(MessageNano proto) {
1099         CheckedMessage wrapper = new CheckedMessage();
1100         wrapper.payload = MessageNano.toByteArray(proto);
1101         CRC32 checksum = new CRC32();
1102         checksum.update(wrapper.payload);
1103         wrapper.checksum = checksum.getValue();
1104         return MessageNano.toByteArray(wrapper);
1105     }
1106 
1107     /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1108     private static byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize)
1109             throws InvalidProtocolBufferNanoException {
1110         CheckedMessage wrapper = new CheckedMessage();
1111         MessageNano.mergeFrom(wrapper, buffer, offset, dataSize);
1112         CRC32 checksum = new CRC32();
1113         checksum.update(wrapper.payload);
1114         if (wrapper.checksum != checksum.getValue()) {
1115             throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1116         }
1117         return wrapper.payload;
1118     }
1119 
1120     private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {
1121         if (mWidgetMap == null) {
1122             List&lt;AppWidgetProviderInfo&gt; widgets =
1123                     AppWidgetManager.getInstance(mContext).getInstalledProviders();
1124             mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());
1125             for (AppWidgetProviderInfo info : widgets) {
1126                 mWidgetMap.put(info.provider, info);
1127             }
1128         }
1129         return mWidgetMap.get(component);
1130     }
1131 
1132 
1133     private boolean initializeIconCache() {
1134         if (mIconCache != null) {
1135             return true;
1136         }
1137 
1138         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
1139         if (appState == null) {
1140             Throwable stackTrace = new Throwable();
1141             stackTrace.fillInStackTrace();
1142             Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);
1143             return false;
1144         }
1145         mIconCache = appState.getIconCache();
1146         return mIconCache != null;
1147     }
1148 
1149 
1150    // check if the launcher is in a state to support backup
1151     private boolean launcherIsReady() {
1152         ContentResolver cr = mContext.getContentResolver();
1153         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);
1154         if (cursor == null) {
1155             // launcher data has been wiped, do nothing
1156             return false;
1157         }
1158         cursor.close();
1159 
1160         if (!initializeIconCache()) {
1161             // launcher services are unavailable, try again later
1162             dataChanged();
1163             return false;
1164         }
1165 
1166         return true;
1167     }
1168 
1169     private class KeyParsingException extends Throwable {
1170         private KeyParsingException(Throwable cause) {
1171             super(cause);
1172         }
1173 
1174         public KeyParsingException(String reason) {
1175             super(reason);
1176         }
1177     }
1178 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.app.backup.BackupDataInputStream;
  19 import android.app.backup.BackupDataOutput;
  20 import android.app.backup.BackupHelper;
  21 import android.app.backup.BackupManager;
  22 import android.appwidget.AppWidgetManager;
  23 import android.appwidget.AppWidgetProviderInfo;
  24 import android.content.ComponentName;
  25 import android.content.ContentResolver;
  26 import android.content.ContentValues;
  27 import android.content.Context;
  28 import android.content.Intent;
  29 import android.database.Cursor;
  30 import android.graphics.Bitmap;
  31 import android.graphics.BitmapFactory;
  32 import android.graphics.drawable.Drawable;
  33 import android.os.ParcelFileDescriptor;
  34 import android.text.TextUtils;
  35 import android.util.Base64;
  36 import android.util.Log;
  37 import com.android.launcher3.LauncherSettings.Favorites;
  38 import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  39 import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  40 import com.android.launcher3.backup.BackupProtos.Favorite;
  41 import com.android.launcher3.backup.BackupProtos.Journal;
  42 import com.android.launcher3.backup.BackupProtos.Key;
  43 import com.android.launcher3.backup.BackupProtos.Resource;
  44 import com.android.launcher3.backup.BackupProtos.Screen;
  45 import com.android.launcher3.backup.BackupProtos.Widget;
  46 import com.android.launcher3.backup.BackupProtos;
  47 import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  48 import com.google.protobuf.nano.MessageNano;
  49 import java.io.ByteArrayOutputStream;
  50 import java.io.FileInputStream;
  51 import java.io.FileOutputStream;
  52 import java.io.IOException;
  53 import java.net.URISyntaxException;
  54 import java.util.ArrayList;
  55 import java.util.HashMap;
  56 import java.util.HashSet;
  57 import java.util.List;
  58 import java.util.Set;
  59 import java.util.zip.CRC32;
  60 
  61 
  62 /**
  63  * Persist the launcher home state across calamities.
  64  */
  65 public class LauncherBackupHelper implements BackupHelper {
  66     private static final String TAG = &quot;LauncherBackupHelper&quot;;
  67 
  68     private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  69 
  70     private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  71 
  72     private static final boolean DEBUG_PAYLOAD = false;
  73 
  74     private static final int MAX_JOURNAL_SIZE = 1000000;
  75 
  76     /**
  77      * icons are large, dribble them out
  78      */
  79     private static final int MAX_ICONS_PER_PASS = 10;
  80 
  81     /**
  82      * widgets contain previews, which are very large, dribble them out
  83      */
  84     private static final int MAX_WIDGETS_PER_PASS = 5;
  85 
  86     public static final int IMAGE_COMPRESSION_QUALITY = 75;
  87 
  88     public static final String LAUNCHER_PREFIX = &quot;L&quot;;
  89 
  90     public static final String LAUNCHER_PREFS_PREFIX = &quot;LP&quot;;
  91 
  92     private static final Bitmap.CompressFormat IMAGE_FORMAT =
  93             android.graphics.Bitmap.CompressFormat.PNG;
  94 
  95     private static BackupManager sBackupManager;
  96 
  97     private static final String[] FAVORITE_PROJECTION = new java.lang.String[]{ Favorites._ID, // 0
  98     Favorites.MODIFIED, // 1
  99     Favorites.INTENT, // 2
 100     Favorites.APPWIDGET_PROVIDER// 3
 101     , Favorites.APPWIDGET_ID// 4
 102     , Favorites.CELLX, // 5
 103     Favorites.CELLY, // 6
 104     Favorites.CONTAINER, // 7
 105     Favorites.ICON, // 8
 106     Favorites.ICON_PACKAGE// 9
 107     , Favorites.ICON_RESOURCE// 10
 108     , Favorites.ICON_TYPE, // 11
 109     Favorites.ITEM_TYPE, // 12
 110     Favorites.SCREEN, // 13
 111     Favorites.SPANX, // 14
 112     Favorites.SPANY, // 15
 113     Favorites.TITLE// 16
 114      };
 115 
 116     private static final int ID_INDEX = 0;
 117 
 118     private static final int ID_MODIFIED = 1;
 119 
 120     private static final int INTENT_INDEX = 2;
 121 
 122     private static final int APPWIDGET_PROVIDER_INDEX = 3;
 123 
 124     private static final int APPWIDGET_ID_INDEX = 4;
 125 
 126     private static final int CELLX_INDEX = 5;
 127 
 128     private static final int CELLY_INDEX = 6;
 129 
 130     private static final int CONTAINER_INDEX = 7;
 131 
 132     private static final int ICON_INDEX = 8;
 133 
 134     private static final int ICON_PACKAGE_INDEX = 9;
 135 
 136     private static final int ICON_RESOURCE_INDEX = 10;
 137 
 138     private static final int ICON_TYPE_INDEX = 11;
 139 
 140     private static final int ITEM_TYPE_INDEX = 12;
 141 
 142     private static final int SCREEN_INDEX = 13;
 143 
 144     private static final int SPANX_INDEX = 14;
 145 
 146     private static final int SPANY_INDEX = 15;
 147 
 148     private static final int TITLE_INDEX = 16;
 149 
 150     private static final String[] SCREEN_PROJECTION = new java.lang.String[]{ WorkspaceScreens._ID, // 0
 151     WorkspaceScreens.MODIFIED// 1
 152     , WorkspaceScreens.SCREEN_RANK// 2
 153      };
 154 
 155     private static final int SCREEN_RANK_INDEX = 2;
 156 
 157     private static IconCache mIconCache;
 158 
 159     private final Context mContext;
 160 
 161     private final boolean mRestoreEnabled;
 162 
 163     private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;
 164 
 165     private ArrayList&lt;Key&gt; mKeys;
 166 
 167     public LauncherBackupHelper(Context context, boolean restoreEnabled) {
 168         mContext = context;
 169         mRestoreEnabled = restoreEnabled;
 170     }
 171 
 172     private void dataChanged() {
 173         if (sBackupManager == null) {
 174             sBackupManager = new BackupManager(mContext);
 175         }
 176         sBackupManager.dataChanged();
 177     }
 178 
 179     /**
 180      * Back up launcher data so we can restore the user&#x27;s state on a new device.
 181      *
 182      * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 183      *
 184      * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 185      *
 186      * @param oldState notes from the last backup
 187      * @param data incremental key/value pairs to persist off-device
 188      * @param newState notes for the next backup
 189      * @throws IOException
 190      */
 191     @Override
<abbr title=" 192     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data, ParcelFileDescriptor newState) {"> 192     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data, ParcelFileDescriptor </abbr>
 193         if (VERBOSE) {
 194             Log.v(TAG, &quot;onBackup&quot;);
 195         }
 196         Journal in = readJournal(oldState);
 197         Journal out = new Journal();
 198         long lastBackupTime = in.t;
 199         out.t = System.currentTimeMillis();
 200         out.rows = 0;
 201         out.bytes = 0;
 202         Log.v(TAG, &quot;lastBackupTime = &quot; + lastBackupTime);
 203         ArrayList&lt;Key&gt; keys = new ArrayList&lt;Key&gt;();
 204         if (launcherIsReady()) {
 205             try {
 206                 backupFavorites(in, data, out, keys);
 207                 backupScreens(in, data, out, keys);
 208                 backupIcons(in, data, out, keys);
 209                 backupWidgets(in, data, out, keys);
 210             } catch (IOException e) {
 211                 Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 212             }
 213             out.key = keys.toArray(
 214 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 215 new BackupProtos.Key[keys.size()]</span>
 216 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 217 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 217 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw</abbr></span>
 218 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 219 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 220 BackupProtos.Key.emptyArray()</span>
 221 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 222             );
 223         } else {
 224             out = in;
 225         }
 226         writeJournal(newState, out);
 227         Log.v(TAG, (((&quot;onBackup: wrote &quot; + out.bytes) + &quot;b in &quot;) + out.rows) + &quot; rows.&quot;);
 228     }
 229 
 230     /**
 231      * Restore launcher configuration from the restored data stream.
 232      *
 233      * &lt;P&gt;Keys may arrive in any order.
 234      *
 235      * @param data the key/value pair from the server
 236      */
 237     @Override
 238     public void restoreEntity(BackupDataInputStream data) {
 239         if (VERBOSE) Log.v(TAG, &quot;restoreEntity&quot;);
 240         if (mKeys == null) {
 241             mKeys = new ArrayList&lt;Key&gt;();
 242         }
 243         byte[] buffer = new byte[512];
 244             String backupKey = data.getKey();
 245             int dataSize = data.size();
 246             if (buffer.length &lt; dataSize) {
 247                 buffer = new byte[dataSize];
 248             }
 249             Key key = null;
 250         int bytesRead = 0;
 251         try {
 252             bytesRead = data.read(buffer, 0, dataSize);
 253             if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 254         } catch (IOException e) {
 255             Log.e(TAG, &quot;failed to read entity from restore data&quot;, e);
 256         }
 257         try {
 258             key = backupKeyToKey(backupKey);
 259             mKeys.add(key);
 260             switch (key.type) {
 261                 case Key.FAVORITE:
 262                     restoreFavorite(key, buffer, dataSize, mKeys);
 263                     break;
 264 
 265                 case Key.SCREEN:
 266                     restoreScreen(key, buffer, dataSize, mKeys);
 267                     break;
 268 
 269                 case Key.ICON:
 270                     restoreIcon(key, buffer, dataSize, mKeys);
 271                     break;
 272 
 273                 case Key.WIDGET:
 274                     restoreWidget(key, buffer, dataSize, mKeys);
 275                     break;
 276 
 277                 default:
 278                     Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 279                     break;
 280             }
 281         } catch (KeyParsingException e) {
 282             Log.w(TAG, &quot;ignoring unparsable backup key: &quot; + backupKey);
 283         }
 284 
 285     }
 286 
 287     /**
 288      * Record the restore state for the next backup.
 289      *
 290      * @param newState notes about the backup state after restore.
 291      */
 292     @Override
 293     public void writeNewStateDescription(ParcelFileDescriptor newState) {
 294         // clear the output journal time, to force a full backup to
 295         // will catch any changes the restore process might have made
 296         Journal out = new Journal();
 297         out.t = 0;
 298         out.key = mKeys.toArray(
 299 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 300 new BackupProtos.Key[mKeys.size()]</span>
 301 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 302 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 302 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw</abbr></span>
 303 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 304 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 305 BackupProtos.Key.emptyArray()</span>
 306 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 307         );
 308         writeJournal(newState, out);
 309         Log.v(TAG, (&quot;onRestore: read &quot; + mKeys.size()) + &quot; rows&quot;);
 310         mKeys.clear();
 311     }
 312 
 313     /**
 314      * Write all modified favorites to the data stream.
 315      *
 316      *
 317      * @param in notes from last backup
 318      * @param data output stream for key/value pairs
 319      * @param out notes about this backup
 320      * @param keys keys to mark as clean in the notes for next backup
 321      * @throws IOException
 322      */
 323     private void backupFavorites(Journal in, BackupDataOutput data, Journal out,
 324             ArrayList&lt;Key&gt; keys)
 325             throws IOException {
 326         // read the old ID set
 327         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.FAVORITE, in);
 328         if (DEBUG) Log.d(TAG, &quot;favorite savedIds.size()=&quot; + savedIds.size());
 329 
 330         // persist things that have changed since the last backup
 331         ContentResolver cr = mContext.getContentResolver();
 332         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 333                 null, null, null);
 334         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 335         try {
 336             cursor.moveToPosition(-1);
 337             while(cursor.moveToNext()) {
 338                 final long id = cursor.getLong(ID_INDEX);
 339                 final long updateTime = cursor.getLong(ID_MODIFIED);
 340                 Key key = getKey(Key.FAVORITE, id);
 341                 keys.add(key);
 342                 final String backupKey = keyToBackupKey(key);
 343                 currentIds.add(backupKey);
 344                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 345                     byte[] blob = packFavorite(cursor);
 346                     writeRowToBackup(key, blob, out, data);
 347                 } else {
 348                     if (VERBOSE) Log.v(TAG, &quot;favorite &quot; + id + &quot; was too old: &quot; + updateTime);
 349                 }
 350             }
 351         } finally {
 352             cursor.close();
 353         }
 354         if (DEBUG) Log.d(TAG, &quot;favorite currentIds.size()=&quot; + currentIds.size());
 355 
 356         // these IDs must have been deleted
 357         savedIds.removeAll(currentIds);
 358         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 359     }
 360 
 361     /**
 362      * Read a favorite from the stream.
 363      *
 364      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 365      *
 366      * @param key identifier for the row
 367      * @param buffer the serialized proto from the stream, may be larger than dataSize
 368      * @param dataSize the size of the proto from the stream
 369      * @param keys keys to mark as clean in the notes for next backup
 370      */
 371     private void restoreFavorite(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 372         if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 373         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 374                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 375 
 376         if (!mRestoreEnabled) {
 377             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 378             return;
 379         }
 380 
 381         try {
 382             ContentResolver cr = mContext.getContentResolver();
 383             ContentValues values = unpackFavorite(buffer, 0, dataSize);
 384             cr.insert(Favorites.CONTENT_URI, values);
 385         } catch (InvalidProtocolBufferNanoException e) {
 386             Log.e(TAG, &quot;failed to decode favorite&quot;, e);
 387         }
 388     }
 389 
 390     /**
 391      * Write all modified screens to the data stream.
 392      *
 393      *
 394      * @param in notes from last backup
 395      * @param data output stream for key/value pairs
 396      * @param out notes about this backup
 397      * @param keys keys to mark as clean in the notes for next backup
 398      * @throws IOException
 399      */
 400     private void backupScreens(Journal in, BackupDataOutput data, Journal out,
 401             ArrayList&lt;Key&gt; keys)
 402             throws IOException {
 403         // read the old ID set
 404         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.SCREEN, in);
 405         if (DEBUG) Log.d(TAG, &quot;screen savedIds.size()=&quot; + savedIds.size());
 406 
 407         // persist things that have changed since the last backup
 408         ContentResolver cr = mContext.getContentResolver();
 409         Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 410                 null, null, null);
 411         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 412         try {
 413             cursor.moveToPosition(-1);
 414             if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + in.t);
 415             while(cursor.moveToNext()) {
 416                 final long id = cursor.getLong(ID_INDEX);
 417                 final long updateTime = cursor.getLong(ID_MODIFIED);
 418                 Key key = getKey(Key.SCREEN, id);
 419                 keys.add(key);
 420                 final String backupKey = keyToBackupKey(key);
 421                 currentIds.add(backupKey);
 422                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 423                     byte[] blob = packScreen(cursor);
 424                     writeRowToBackup(key, blob, out, data);
 425                 } else {
 426                     if (VERBOSE) Log.v(TAG, &quot;screen &quot; + id + &quot; was too old: &quot; + updateTime);
 427                 }
 428             }
 429         } finally {
 430             cursor.close();
 431         }
 432         if (DEBUG) Log.d(TAG, &quot;screen currentIds.size()=&quot; + currentIds.size());
 433 
 434         // these IDs must have been deleted
 435         savedIds.removeAll(currentIds);
 436         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 437     }
 438 
 439     /**
 440      * Read a screen from the stream.
 441      *
 442      * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 443      *
 444      * @param key identifier for the row
 445      * @param buffer the serialized proto from the stream, may be larger than dataSize
 446      * @param dataSize the size of the proto from the stream
 447      * @param keys keys to mark as clean in the notes for next backup
 448      */
 449     private void restoreScreen(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 450         if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 451         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 452                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 453 
 454         if (!mRestoreEnabled) {
 455             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 456             return;
 457         }
 458 
 459         try {
 460             ContentResolver cr = mContext.getContentResolver();
 461             ContentValues values = unpackScreen(buffer, 0, dataSize);
 462             cr.insert(WorkspaceScreens.CONTENT_URI, values);
 463 
 464         } catch (InvalidProtocolBufferNanoException e) {
 465             Log.e(TAG, &quot;failed to decode screen&quot;, e);
 466         }
 467     }
 468 
 469     /**
 470      * Write all the static icon resources we need to render placeholders
 471      * for a package that is not installed.
 472      *
 473      * @param in notes from last backup
 474      * @param data output stream for key/value pairs
 475      * @param out notes about this backup
 476      * @param keys keys to mark as clean in the notes for next backup
 477      * @throws IOException
 478      */
<abbr title=" 479     private void backupIcons(Journal in, BackupDataOutput data, Journal out, ArrayList&lt;Key&gt; keys) throws IOException {"> 479     private void backupIcons(Journal in, BackupDataOutput data, Journal out, ArrayList&lt;Key&gt; keys) throws </abbr>
 480         // persist icons that haven&#x27;t been persisted yet
 481         if (!initializeIconCache()) {
 482             dataChanged();// try again later
 483 
 484             if (DEBUG) {
 485                 Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 486             }
 487             return;
 488         }
 489         final ContentResolver cr = mContext.getContentResolver();
 490         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 491         // read the old ID set
 492         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.ICON, in);
 493         if (DEBUG) {
 494             Log.d(TAG, &quot;icon savedIds.size()=&quot; + savedIds.size());
 495         }
 496         int startRows = out.rows;
 497         if (DEBUG) {
 498             Log.d(TAG, &quot;starting here: &quot; + startRows);
 499         }
 500         String where = (Favorites.ITEM_TYPE + &quot;=&quot;) + Favorites.ITEM_TYPE_APPLICATION;
 501         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, where, null, null);
 502         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 503         try {
 504             cursor.moveToPosition(-1);
 505             while (cursor.moveToNext()) {
 506                 final long id = cursor.getLong(ID_INDEX);
 507                 final String intentDescription = cursor.getString(INTENT_INDEX);
 508                 try {
 509                     Intent intent = Intent.parseUri(intentDescription, 0);
 510                     ComponentName cn = intent.getComponent();
 511                     Key key = null;
 512                     String backupKey = null;
 513                     if (cn != null) {
 514                         key = getKey(Key.ICON, cn.flattenToShortString());
 515                         backupKey = keyToBackupKey(key);
 516                         currentIds.add(backupKey);
 517                     } else {
 518                         Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 519                     }
 520                     if (savedIds.contains(backupKey)) {
 521                         if (VERBOSE) {
 522                             Log.v(TAG, &quot;already saved icon &quot; + backupKey);
 523                         }
 524                         // remember that we already backed this up previously
 525                         keys.add(key);
 526                     } else if (backupKey != null) {
 527                         if (DEBUG) {
 528                             Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 529                         }
 530                         if ((out.rows - startRows) &lt; MAX_ICONS_PER_PASS) {
 531                             if (VERBOSE) {
 532                                 Log.v(TAG, &quot;saving icon &quot; + backupKey);
 533                             }
 534                             Bitmap icon = mIconCache.getIcon(intent);
 535                             keys.add(key);
 536                             if ((icon != null) &amp;&amp; (!mIconCache.isDefaultIcon(icon))) {
 537                                 byte[] blob = packIcon(dpi, icon);
 538                                 writeRowToBackup(key, blob, out, data);
 539                             }
 540                         } else {
 541                             if (VERBOSE) {
 542                                 Log.d(TAG, &quot;deferring icon backup &quot; + backupKey);
 543                             }
 544                             // too many icons for this pass, request another.
 545                             dataChanged();
 546                         }
 547                     }
 548                 } catch (URISyntaxException e) {
 549                     Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 550                 } catch (IOException e) {
 551                     Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 552                 }
 553             }
 554         } finally {
 555             cursor.close();
 556         }
 557         if (DEBUG) {
 558             Log.d(TAG, &quot;icon currentIds.size()=&quot; + currentIds.size());
 559         }
 560         // these IDs must have been deleted
 561         savedIds.removeAll(currentIds);
 562         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 563     }
 564 
 565     /**
 566      * Read an icon from the stream.
 567      *
 568      * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 569      *
 570      * @param key identifier for the row
 571      * @param buffer the serialized proto from the stream, may be larger than dataSize
 572      * @param dataSize the size of the proto from the stream
 573      * @param keys keys to mark as clean in the notes for next backup
 574      */
 575     private void restoreIcon(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 576         if (VERBOSE) {
 577             Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 578         }
 579         if (DEBUG) {
<abbr title=" 580             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));"> 580             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, </abbr>
 581         }
 582         try {
 583             Resource res = unpackIcon(buffer, 0, dataSize);
 584             if (DEBUG) {
 585                 Log.d(TAG, (&quot;unpacked &quot; + res.dpi) + &quot; dpi icon&quot;);
 586             }
 587             if (DEBUG_PAYLOAD) {
<abbr title=" 588                 Log.d(TAG, &quot;read &quot; + Base64.encodeToString(res.data, 0, res.data.length, Base64.NO_WRAP));"> 588                 Log.d(TAG, &quot;read &quot; + Base64.encodeToString(res.data, 0, res.data.length, Base64.NO_WRAP))</abbr>
 589             }
 590             Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 591             if (icon == null) {
 592                 Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 593             }
 594             if (!mRestoreEnabled) {
 595                 if (VERBOSE) {
 596                     Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 597                 }
 598                 return;
 599             } else {
<abbr title=" 600                 IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(key.name), icon, res.dpi);"> 600                 IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(key.name), icon, res.dp</abbr>
 601             }
 602         } catch (IOException e) {
 603             Log.d(TAG, &quot;failed to save restored icon for: &quot; + key.name, e);
 604         }
 605     }
 606 
 607     /**
 608      * Write all the static widget resources we need to render placeholders
 609      * for a package that is not installed.
 610      *
 611      * @param in notes from last backup
 612      * @param data output stream for key/value pairs
 613      * @param out notes about this backup
 614      * @param keys keys to mark as clean in the notes for next backup
 615      * @throws IOException
 616      */
<abbr title=" 617     private void backupWidgets(Journal in, BackupDataOutput data, Journal out, ArrayList&lt;Key&gt; keys) throws IOException {"> 617     private void backupWidgets(Journal in, BackupDataOutput data, Journal out, ArrayList&lt;Key&gt; keys) throw</abbr>
 618         // persist static widget info that hasn&#x27;t been persisted yet
 619         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 620         if ((appState == null) || (!initializeIconCache())) {
 621             Log.w(TAG, &quot;Failed to get icon cache during restore&quot;);
 622             return;
 623         }
 624         final ContentResolver cr = mContext.getContentResolver();
 625         final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 626         final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
 627         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 628         final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 629         if (DEBUG) {
 630             Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 631         }
 632         // read the old ID set
 633         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.WIDGET, in);
 634         if (DEBUG) {
 635             Log.d(TAG, &quot;widgets savedIds.size()=&quot; + savedIds.size());
 636         }
 637         int startRows = out.rows;
 638         if (DEBUG) {
 639             Log.d(TAG, &quot;starting here: &quot; + startRows);
 640         }
 641         String where = (Favorites.ITEM_TYPE + &quot;=&quot;) + Favorites.ITEM_TYPE_APPWIDGET;
 642         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, where, null, null);
 643         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 644         try {
 645             cursor.moveToPosition(-1);
 646             while (cursor.moveToNext()) {
 647                 final long id = cursor.getLong(ID_INDEX);
 648                 final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 649                 final int spanX = cursor.getInt(SPANX_INDEX);
 650                 final int spanY = cursor.getInt(SPANY_INDEX);
 651                 final ComponentName provider = ComponentName.unflattenFromString(providerName);
 652                 Key key = null;
 653                 String backupKey = null;
 654                 if (provider != null) {
 655                     key = getKey(Key.WIDGET, providerName);
 656                     backupKey = keyToBackupKey(key);
 657                     currentIds.add(backupKey);
 658                 } else {
 659                     Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 660                 }
 661                 if (savedIds.contains(backupKey)) {
 662                     if (VERBOSE) {
 663                         Log.v(TAG, &quot;already saved widget &quot; + backupKey);
 664                     }
 665                     // remember that we already backed this up previously
 666                     keys.add(key);
 667                 } else if (backupKey != null) {
 668                     if (DEBUG) {
 669                         Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 670                     }
 671                     if ((out.rows - startRows) &lt; MAX_WIDGETS_PER_PASS) {
 672                         if (VERBOSE) {
 673                             Log.v(TAG, &quot;saving widget &quot; + backupKey);
 674                         }
<abbr title=" 675                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx, spanY * profile.cellHeightPx, widgetSpacingLayout);"> 675                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx, spanY * profile.cellHei</abbr>
 676                         byte[] blob = packWidget(dpi, previewLoader, mIconCache, provider);
 677                         keys.add(key);
 678                         writeRowToBackup(key, blob, out, data);
 679                     } else {
 680                         if (VERBOSE) {
 681                             Log.d(TAG, &quot;deferring widget backup &quot; + backupKey);
 682                         }
 683                         // too many widgets for this pass, request another.
 684                         dataChanged();
 685                     }
 686                 }
 687             }
 688         } finally {
 689             cursor.close();
 690         }
 691         if (DEBUG) {
 692             Log.d(TAG, &quot;widget currentIds.size()=&quot; + currentIds.size());
 693         }
 694         // these IDs must have been deleted
 695         savedIds.removeAll(currentIds);
 696         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 697     }
 698 
 699     /**
 700      * Read a widget from the stream.
 701      *
 702      * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 703      *
 704      * @param key identifier for the row
 705      * @param buffer the serialized proto from the stream, may be larger than dataSize
 706      * @param dataSize the size of the proto from the stream
 707      * @param keys keys to mark as clean in the notes for next backup
 708      */
 709     private void restoreWidget(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 710         if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 711         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 712                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 713         try {
 714             Widget widget = unpackWidget(buffer, 0, dataSize);
 715             if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 716             if (widget.icon.data != null)  {
 717                 Bitmap icon = BitmapFactory
 718                         .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 719                 if (icon == null) {
 720                     Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 721                 }
 722             }
 723 
 724             if (!mRestoreEnabled) {
 725                 if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 726                 return;
 727             } else {
 728                 // future site of widget table mutation
 729             }
 730         } catch (InvalidProtocolBufferNanoException e) {
 731             Log.e(TAG, &quot;failed to decode widget&quot;, e);
 732         }
 733     }
 734 
 735     /** create a new key, with an integer ID.
 736      *
 737      * &lt;P&gt; Keys contain their own checksum instead of using
 738      * the heavy-weight CheckedMessage wrapper.
 739      */
 740     private Key getKey(int type, long id) {
 741         Key key = new Key();
 742         key.type = type;
 743         key.id = id;
 744         key.checksum = checkKey(key);
 745         return key;
 746     }
 747 
 748     /** create a new key for a named object.
 749      *
 750      * &lt;P&gt; Keys contain their own checksum instead of using
 751      * the heavy-weight CheckedMessage wrapper.
 752      */
 753     private Key getKey(int type, String name) {
 754         Key key = new Key();
 755         key.type = type;
 756         key.name = name;
 757         key.checksum = checkKey(key);
 758         return key;
 759     }
 760 
 761     /** keys need to be strings, serialize and encode. */
 762     private String keyToBackupKey(Key key) {
 763         return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 764     }
 765 
 766     /** keys need to be strings, decode and parse. */
 767     private Key backupKeyToKey(String backupKey) throws KeyParsingException {
 768         try {
 769             Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 770             if (key.checksum != checkKey(key)) {
 771                 key = null;
 772                 throw new KeyParsingException(&quot;invalid key read from stream&quot; + backupKey);
 773             }
 774             return key;
 775         } catch (InvalidProtocolBufferNanoException e) {
 776             throw new KeyParsingException(e);
 777         } catch (IllegalArgumentException e) {
 778             throw new KeyParsingException(e);
 779         }
 780     }
 781 
 782     private String getKeyName(Key key) {
 783         if (TextUtils.isEmpty(key.name)) {
 784             return Long.toString(key.id);
 785         } else {
 786             return key.name;
 787         }
 788 
 789     }
 790 
 791     private String geKeyType(Key key) {
 792         switch (key.type) {
 793             case Key.FAVORITE:
 794                 return &quot;favorite&quot;;
 795             case Key.SCREEN:
 796                 return &quot;screen&quot;;
 797             case Key.ICON:
 798                 return &quot;icon&quot;;
 799             case Key.WIDGET:
 800                 return &quot;widget&quot;;
 801             default:
 802                 return &quot;anonymous&quot;;
 803         }
 804     }
 805 
 806     /** Compute the checksum over the important bits of a key. */
 807     private long checkKey(Key key) {
 808         CRC32 checksum = new CRC32();
 809         checksum.update(key.type);
 810         checksum.update((int) (key.id &amp; 0xffff));
 811         checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 812         if (!TextUtils.isEmpty(key.name)) {
 813             checksum.update(key.name.getBytes());
 814         }
 815         return checksum.getValue();
 816     }
 817 
 818     /** Serialize a Favorite for persistence, including a checksum wrapper. */
 819     private byte[] packFavorite(Cursor c) {
 820         Favorite favorite = new Favorite();
 821         favorite.id = c.getLong(ID_INDEX);
 822         favorite.screen = c.getInt(SCREEN_INDEX);
 823         favorite.container = c.getInt(CONTAINER_INDEX);
 824         favorite.cellX = c.getInt(CELLX_INDEX);
 825         favorite.cellY = c.getInt(CELLY_INDEX);
 826         favorite.spanX = c.getInt(SPANX_INDEX);
 827         favorite.spanY = c.getInt(SPANY_INDEX);
 828         favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 829         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 830             String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 831             if (!TextUtils.isEmpty(iconPackage)) {
 832                 favorite.iconPackage = iconPackage;
 833             }
 834             String iconResource = c.getString(ICON_RESOURCE_INDEX);
 835             if (!TextUtils.isEmpty(iconResource)) {
 836                 favorite.iconResource = iconResource;
 837             }
 838         }
 839         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 840             byte[] blob = c.getBlob(ICON_INDEX);
 841             if (blob != null &amp;&amp; blob.length &gt; 0) {
 842                 favorite.icon = blob;
 843             }
 844         }
 845         String title = c.getString(TITLE_INDEX);
 846         if (!TextUtils.isEmpty(title)) {
 847             favorite.title = title;
 848         }
 849         String intent = c.getString(INTENT_INDEX);
 850         if (!TextUtils.isEmpty(intent)) {
 851             favorite.intent = intent;
 852         }
 853         favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 854         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 855             favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 856             String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 857             if (!TextUtils.isEmpty(appWidgetProvider)) {
 858                 favorite.appWidgetProvider = appWidgetProvider;
 859             }
 860         }
 861 
 862         return writeCheckedBytes(favorite);
 863     }
 864 
 865     /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
<abbr title=" 866     private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNanoException {"> 866     private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize) throws InvalidProtocolB</abbr>
 867         Favorite favorite = new Favorite();
 868         MessageNano.mergeFrom(favorite, readCheckedBytes(buffer, offset, dataSize));
 869         if (VERBOSE) {
<abbr title=" 870             Log.v(TAG, ((&quot;unpacked favorite &quot; + favorite.itemType) + &quot;, &quot;) + (TextUtils.isEmpty(favorite.title) ? favorite.id : favorite.title));"> 870             Log.v(TAG, ((&quot;unpacked favorite &quot; + favorite.itemType) + &quot;, &quot;) + (TextUtils.isEmpty(favorite.</abbr>
 871         }
 872         ContentValues values = new ContentValues();
 873         values.put(Favorites._ID, favorite.id);
 874         values.put(Favorites.SCREEN, favorite.screen);
 875         values.put(Favorites.CONTAINER, favorite.container);
 876         values.put(Favorites.CELLX, favorite.cellX);
 877         values.put(Favorites.CELLY, favorite.cellY);
 878         values.put(Favorites.SPANX, favorite.spanX);
 879         values.put(Favorites.SPANY, favorite.spanY);
 880         values.put(Favorites.ICON_TYPE, favorite.iconType);
 881         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 882             values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 883             values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 884         }
 885         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 886             values.put(Favorites.ICON, favorite.icon);
 887         }
 888         if (!TextUtils.isEmpty(favorite.title)) {
 889             values.put(Favorites.TITLE, favorite.title);
 890         } else {
 891             values.put(Favorites.TITLE, &quot;&quot;);
 892         }
 893         if (!TextUtils.isEmpty(favorite.intent)) {
 894             values.put(Favorites.INTENT, favorite.intent);
 895         }
 896         values.put(Favorites.ITEM_TYPE, favorite.itemType);
 897         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 898             if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 899                 values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 900             }
 901             values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 902         }
 903         // Let LauncherModel know we&#x27;ve been here.
 904         values.put(LauncherSettings.Favorites.RESTORED, 1);
 905         return values;
 906     }
 907 
 908     /** Serialize a Screen for persistence, including a checksum wrapper. */
 909     private byte[] packScreen(Cursor c) {
 910         Screen screen = new Screen();
 911         screen.id = c.getLong(ID_INDEX);
 912         screen.rank = c.getInt(SCREEN_RANK_INDEX);
 913 
 914         return writeCheckedBytes(screen);
 915     }
 916 
 917     /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
<abbr title=" 918     private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNanoException {"> 918     private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBuf</abbr>
 919         Screen screen = new Screen();
 920         MessageNano.mergeFrom(screen, readCheckedBytes(buffer, offset, dataSize));
 921         if (VERBOSE) {
 922             Log.v(TAG, ((&quot;unpacked screen &quot; + screen.id) + &quot;/&quot;) + screen.rank);
 923         }
 924         ContentValues values = new ContentValues();
 925         values.put(WorkspaceScreens._ID, screen.id);
 926         values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 927         return values;
 928     }
 929 
 930     /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 931     private byte[] packIcon(int dpi, Bitmap icon) {
 932         Resource res = new Resource();
 933         res.dpi = dpi;
 934         ByteArrayOutputStream os = new ByteArrayOutputStream();
 935         if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 936             res.data = os.toByteArray();
 937         }
 938         return writeCheckedBytes(res);
 939     }
 940 
 941     /** Deserialize an icon resource from persistence, after verifying checksum wrapper. */
<abbr title=" 942     private static Resource unpackIcon(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNanoException {"> 942     private static Resource unpackIcon(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBuf</abbr>
 943         Resource res = new Resource();
 944         MessageNano.mergeFrom(res, readCheckedBytes(buffer, offset, dataSize));
 945         if (VERBOSE) {
 946             Log.v(TAG, ((&quot;unpacked icon &quot; + res.dpi) + &quot;/&quot;) + res.data.length);
 947         }
 948         return res;
 949     }
 950 
 951     /** Serialize a widget for persistence, including a checksum wrapper. */
 952     private byte[] packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 953             ComponentName provider) {
 954         final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);
 955         Widget widget = new Widget();
 956         widget.provider = provider.flattenToShortString();
 957         widget.label = info.label;
 958         widget.configure = info.configure != null;
 959         if (info.icon != 0) {
 960             widget.icon = new Resource();
 961             Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
 962             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 963             ByteArrayOutputStream os = new ByteArrayOutputStream();
 964             if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 965                 widget.icon.data = os.toByteArray();
 966                 widget.icon.dpi = dpi;
 967             }
 968         }
 969         if (info.previewImage != 0) {
 970             widget.preview = new Resource();
 971             Bitmap preview = previewLoader.generateWidgetPreview(info, null);
 972             ByteArrayOutputStream os = new ByteArrayOutputStream();
 973             if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 974                 widget.preview.data = os.toByteArray();
 975                 widget.preview.dpi = dpi;
 976             }
 977         }
 978         return writeCheckedBytes(widget);
 979     }
 980 
 981     /** Deserialize a widget from persistence, after verifying checksum wrapper. */
<abbr title=" 982     private Widget unpackWidget(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNanoException {"> 982     private Widget unpackWidget(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNano</abbr>
 983         Widget widget = new Widget();
 984         MessageNano.mergeFrom(widget, readCheckedBytes(buffer, offset, dataSize));
 985         if (VERBOSE) {
 986             Log.v(TAG, &quot;unpacked widget &quot; + widget.provider);
 987         }
 988         return widget;
 989     }
 990 
 991     /**
 992      * Read the old journal from the input file.
 993      *
 994      * In the event of any error, just pretend we didn&#x27;t have a journal,
 995      * in that case, do a full backup.
 996      *
 997      * @param oldState the read-0only file descriptor pointing to the old journal
 998      * @return a Journal protocol buffer
 999      */
1000     private Journal readJournal(ParcelFileDescriptor oldState) {
1001         Journal journal = new Journal();
1002         if (oldState == null) {
1003             return journal;
1004         }
1005         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
1006         try {
1007             int availableBytes = inStream.available();
1008             if (DEBUG) {
1009                 Log.d(TAG, &quot;available &quot; + availableBytes);
1010             }
1011             if (availableBytes &lt; MAX_JOURNAL_SIZE) {
1012                 byte[] buffer = new byte[availableBytes];
1013                 int bytesRead = 0;
1014                 boolean valid = false;
1015                 InvalidProtocolBufferNanoException lastProtoException = null;
1016                 while (availableBytes &gt; 0) {
1017                     try {
1018                         // OMG what are you doing? This is crazy inefficient!
1019                         // If we read a byte that is not ours, we will cause trouble: b/12491813
1020                         // However, we don&#x27;t know how many bytes to expect (oops).
1021                         // So we have to step through *slowly*, watching for the end.
1022                         int result = inStream.read(buffer, bytesRead, 1);
1023                         if (result &gt; 0) {
1024                             availableBytes -= result;
1025                             bytesRead += result;
1026                             if (DEBUG &amp;&amp; ((bytesRead % 100) == 0)) {
1027                                 Log.d(TAG, &quot;read some bytes: &quot; + bytesRead);
1028                             }
1029                         } else {
1030                             Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1031                             // stop reading and see what there is to parse
1032                             availableBytes = 0;
1033                         }
1034                     } catch (IOException e) {
1035                         buffer = null;
1036                         availableBytes = 0;
1037                     }
1038                     // check the buffer to see if we have a valid journal
1039                     try {
1040                         MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));
1041                         // if we are here, then we have read a valid, checksum-verified journal
1042                         valid = true;
1043                         availableBytes = 0;
1044                         if (VERBOSE) {
1045                             Log.v(TAG, (&quot;read &quot; + bytesRead) + &quot; bytes of journal&quot;);
1046                         }
1047                     } catch (InvalidProtocolBufferNanoException e) {
1048                         // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1049                         lastProtoException = e;
1050                         journal.clear();
1051                     }
1052                 }
1053                 if (DEBUG) {
1054                     Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1055                 }
1056                 if (!valid) {
1057                     Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1058                 }
1059             }
1060         } catch (IOException e) {
1061             Log.w(TAG, &quot;failed to close the journal&quot;, e);
1062         } finally {
1063             try {
1064                 inStream.close();
1065             } catch (IOException e) {
1066                 Log.w(TAG, &quot;failed to close the journal&quot;, e);
1067             }
1068         }
1069         return journal;
1070     }
1071 
1072     private void writeRowToBackup(Key key, byte[] blob, Journal out,
1073             BackupDataOutput data) throws IOException {
1074         String backupKey = keyToBackupKey(key);
1075         data.writeEntityHeader(backupKey, blob.length);
1076         data.writeEntityData(blob, blob.length);
1077         out.rows++;
1078         out.bytes += blob.length;
1079         if (VERBOSE) Log.v(TAG, &quot;saving &quot; + geKeyType(key) + &quot; &quot; + backupKey + &quot;: &quot; +
1080                 getKeyName(key) + &quot;/&quot; + blob.length);
1081         if(DEBUG_PAYLOAD) {
1082             String encoded = Base64.encodeToString(blob, 0, blob.length, Base64.NO_WRAP);
1083             final int chunkSize = 1024;
1084             for (int offset = 0; offset &lt; encoded.length(); offset += chunkSize) {
1085                 int end = offset + chunkSize;
1086                 end = Math.min(end, encoded.length());
1087                 Log.w(TAG, &quot;wrote &quot; + encoded.substring(offset, end));
1088             }
1089         }
1090     }
1091 
1092     private Set&lt;String&gt; getSavedIdsByType(int type, Journal in) {
1093         Set&lt;String&gt; savedIds = new HashSet&lt;String&gt;();
1094         for(int i = 0; i &lt; in.key.length; i++) {
1095             Key key = in.key[i];
1096             if (key.type == type) {
1097                 savedIds.add(keyToBackupKey(key));
1098             }
1099         }
1100         return savedIds;
1101     }
1102 
1103     private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data)
1104             throws IOException {
1105         int rows = 0;
1106         for(String deleted: deletedIds) {
1107             if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
1108             data.writeEntityHeader(deleted, -1);
1109             rows++;
1110         }
1111         return rows;
1112     }
1113 
1114     /**
1115      * Write the new journal to the output file.
1116      *
1117      * In the event of any error, just pretend we didn&#x27;t have a journal,
1118      * in that case, do a full backup.
1119 
1120      * @param newState the write-only file descriptor pointing to the new journal
1121      * @param journal a Journal protocol buffer
1122      */
1123     private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1124         FileOutputStream outStream = null;
1125         try {
1126             outStream = new FileOutputStream(newState.getFileDescriptor());
1127             final byte[] journalBytes = writeCheckedBytes(journal);
1128             outStream.write(journalBytes);
1129             outStream.close();
1130             if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1131         } catch (IOException e) {
1132             Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1133         }
1134     }
1135 
1136     /** Wrap a proto in a CheckedMessage and compute the checksum. */
1137     private byte[] writeCheckedBytes(MessageNano proto) {
1138         CheckedMessage wrapper = new CheckedMessage();
1139         wrapper.payload = MessageNano.toByteArray(proto);
1140         CRC32 checksum = new CRC32();
1141         checksum.update(wrapper.payload);
1142         wrapper.checksum = checksum.getValue();
1143         return MessageNano.toByteArray(wrapper);
1144     }
1145 
1146     /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
<abbr title="1147     private static byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNanoException {">1147     private static byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize) throws InvalidProtoco</abbr>
1148         CheckedMessage wrapper = new CheckedMessage();
1149         MessageNano.mergeFrom(wrapper, buffer, offset, dataSize);
1150         CRC32 checksum = new CRC32();
1151         checksum.update(wrapper.payload);
1152         if (wrapper.checksum != checksum.getValue()) {
1153             throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1154         }
1155         return wrapper.payload;
1156     }
1157 
1158     private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {
1159         if (mWidgetMap == null) {
1160             List&lt;AppWidgetProviderInfo&gt; widgets =
1161                     AppWidgetManager.getInstance(mContext).getInstalledProviders();
1162             mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());
1163             for (AppWidgetProviderInfo info : widgets) {
1164                 mWidgetMap.put(info.provider, info);
1165             }
1166         }
1167         return mWidgetMap.get(component);
1168     }
1169 
1170     private boolean initializeIconCache() {
1171         if (mIconCache != null) {
1172             return true;
1173         }
1174         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
1175         if (appState == null) {
1176             Throwable stackTrace = new Throwable();
1177             stackTrace.fillInStackTrace();
1178             Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);
1179             return false;
1180         }
1181         mIconCache = appState.getIconCache();
1182         return mIconCache != null;
1183     }
1184 
1185 // check if the launcher is in a state to support backup
1186  private boolean launcherIsReady() {
1187      ContentResolver cr = mContext.getContentResolver();
1188      Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);
1189      if (cursor == null) {
1190          // launcher data has been wiped, do nothing
1191          return false;
1192      }
1193      cursor.close();
1194 
1195      if (!initializeIconCache()) {
1196          // launcher services are unavailable, try again later
1197          dataChanged();
1198          return false;
1199      }
1200 
1201      return true;
1202  }
1203 
1204     private class KeyParsingException extends Throwable {
1205         private KeyParsingException(Throwable cause) {
1206             super(cause);
1207         }
1208 
1209         public KeyParsingException(String reason) {
1210             super(reason);
1211         }
1212     }
1213 }</pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2013 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  package com.android.launcher3;
  17  
  18  import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  19  import com.google.protobuf.nano.MessageNano;
  20  
  21  import com.android.launcher3.LauncherSettings.Favorites;
  22  import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  23  import com.android.launcher3.backup.BackupProtos;
  24  import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  25  import com.android.launcher3.backup.BackupProtos.Favorite;
  26  import com.android.launcher3.backup.BackupProtos.Journal;
  27  import com.android.launcher3.backup.BackupProtos.Key;
  28  import com.android.launcher3.backup.BackupProtos.Resource;
  29  import com.android.launcher3.backup.BackupProtos.Screen;
  30  import com.android.launcher3.backup.BackupProtos.Widget;
  31  
  32  import android.app.backup.BackupDataInputStream;
  33  import android.app.backup.BackupDataOutput;
  34  import android.app.backup.BackupHelper;
  35  import android.app.backup.BackupManager;
  36  import android.appwidget.AppWidgetManager;
  37  import android.appwidget.AppWidgetProviderInfo;
  38  import android.content.ComponentName;
  39  import android.content.ContentResolver;
  40  import android.content.ContentValues;
  41  import android.content.Context;
  42  import android.content.Intent;
  43  import android.database.Cursor;
  44  import android.graphics.Bitmap;
  45  import android.graphics.BitmapFactory;
  46  import android.graphics.drawable.Drawable;
  47  import android.os.ParcelFileDescriptor;
  48  import android.text.TextUtils;
  49  import android.util.Base64;
  50  import android.util.Log;
  51  
  52  import java.io.ByteArrayOutputStream;
  53  import java.io.FileInputStream;
  54  import java.io.FileOutputStream;
  55  import java.io.IOException;
  56  import java.net.URISyntaxException;
  57  import java.util.ArrayList;
  58  import java.util.HashMap;
  59  import java.util.HashSet;
  60  import java.util.List;
  61  import java.util.Set;
  62  import java.util.zip.CRC32;
  63  
  64  /**
  65   * Persist the launcher home state across calamities.
  66   */
  67  public class LauncherBackupHelper implements BackupHelper {
  68  
  69      private static final String TAG = &quot;LauncherBackupHelper&quot;;
  70      private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  71      private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  72      private static final boolean DEBUG_PAYLOAD = false;
  73  
  74      private static final int MAX_JOURNAL_SIZE = 1000000;
  75  
  76      /** icons are large, dribble them out */
  77      private static final int MAX_ICONS_PER_PASS = 10;
  78  
  79      /** widgets contain previews, which are very large, dribble them out */
  80      private static final int MAX_WIDGETS_PER_PASS = 5;
  81  
  82      public static final int IMAGE_COMPRESSION_QUALITY = 75;
  83  
  84      public static final String LAUNCHER_PREFIX = &quot;L&quot;;
  85  
  86      public static final String LAUNCHER_PREFS_PREFIX = &quot;LP&quot;;
  87  
  88      private static final Bitmap.CompressFormat IMAGE_FORMAT =
  89              android.graphics.Bitmap.CompressFormat.PNG;
  90  
  91      private static BackupManager sBackupManager;
  92  
  93      private static final String[] FAVORITE_PROJECTION = {
  94              Favorites._ID,                     // 0
  95              Favorites.MODIFIED,                // 1
  96              Favorites.INTENT,                  // 2
  97              Favorites.APPWIDGET_PROVIDER,      // 3
  98              Favorites.APPWIDGET_ID,            // 4
  99              Favorites.CELLX,                   // 5
 100              Favorites.CELLY,                   // 6
 101              Favorites.CONTAINER,               // 7
 102              Favorites.ICON,                    // 8
 103              Favorites.ICON_PACKAGE,            // 9
 104              Favorites.ICON_RESOURCE,           // 10
 105              Favorites.ICON_TYPE,               // 11
 106              Favorites.ITEM_TYPE,               // 12
 107              Favorites.SCREEN,                  // 13
 108              Favorites.SPANX,                   // 14
 109              Favorites.SPANY,                   // 15
 110              Favorites.TITLE,                   // 16
 111      };
 112  
 113      private static final int ID_INDEX = 0;
 114      private static final int ID_MODIFIED = 1;
 115      private static final int INTENT_INDEX = 2;
 116      private static final int APPWIDGET_PROVIDER_INDEX = 3;
 117      private static final int APPWIDGET_ID_INDEX = 4;
 118      private static final int CELLX_INDEX = 5;
 119      private static final int CELLY_INDEX = 6;
 120      private static final int CONTAINER_INDEX = 7;
 121      private static final int ICON_INDEX = 8;
 122      private static final int ICON_PACKAGE_INDEX = 9;
 123      private static final int ICON_RESOURCE_INDEX = 10;
 124      private static final int ICON_TYPE_INDEX = 11;
 125      private static final int ITEM_TYPE_INDEX = 12;
 126      private static final int SCREEN_INDEX = 13;
 127      private static final int SPANX_INDEX = 14;
 128      private static final int SPANY_INDEX = 15;
 129      private static final int TITLE_INDEX = 16;
 130  
 131      private static final String[] SCREEN_PROJECTION = {
 132              WorkspaceScreens._ID,              // 0
 133              WorkspaceScreens.MODIFIED,         // 1
 134              WorkspaceScreens.SCREEN_RANK       // 2
 135      };
 136  
 137      private static final int SCREEN_RANK_INDEX = 2;
 138  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 139 +    private static IconCache mIconCache;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 140 +</span>
 141      private final Context mContext;
 142  
 143      private final boolean mRestoreEnabled;
 144  
 145      private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;
 146  
 147      private ArrayList&lt;Key&gt; mKeys;
 148  
 149      public LauncherBackupHelper(Context context, boolean restoreEnabled) {
 150          mContext = context;
 151          mRestoreEnabled = restoreEnabled;
 152      }
 153  
 154      private void dataChanged() {
 155          if (sBackupManager == null) {
 156              sBackupManager = new BackupManager(mContext);
 157          }
 158          sBackupManager.dataChanged();
 159      }
 160  
 161      /**
 162       * Back up launcher data so we can restore the user&#x27;s state on a new device.
 163       *
 164       * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 165       *
 166       * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 167       *
 168       * @param oldState notes from the last backup
 169       * @param data incremental key/value pairs to persist off-device
 170       * @param newState notes for the next backup
 171       * @throws IOException
 172       */
 173      @Override
 174      public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 175              ParcelFileDescriptor newState) {
 176          if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 177  
 178          Journal in = readJournal(oldState);
 179          Journal out = new Journal();
 180  
 181          long lastBackupTime = in.t;
 182          out.t = System.currentTimeMillis();
 183          out.rows = 0;
 184          out.bytes = 0;
 185  
 186          Log.v(TAG, &quot;lastBackupTime = &quot; + lastBackupTime);
 187  
 188          ArrayList&lt;Key&gt; keys = new ArrayList&lt;Key&gt;();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 189 -        try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 190 -            backupFavorites(in, data, out, keys);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 191 -            backupScreens(in, data, out, keys);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 192 -            backupIcons(in, data, out, keys);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 193 -            backupWidgets(in, data, out, keys);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 194 -        } catch (IOException e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 195 -            Log.e(TAG, &quot;launcher backup has failed&quot;, e);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 196 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 197 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 198 -        out.key = keys.toArray(BackupProtos.Key.EMPTY_ARRAY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 199 +        if (launcherIsReady()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 200 +            try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 201 +                backupFavorites(in, data, out, keys);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 202 +                backupScreens(in, data, out, keys);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 203 +                backupIcons(in, data, out, keys);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 204 +                backupWidgets(in, data, out, keys);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 205 +            } catch (IOException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 206 +                Log.e(TAG, &quot;launcher backup has failed&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 207 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 208 +            out.key = keys.toArray(new BackupProtos.Key[keys.size()]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 209 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 210 +            out = in;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 211 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 212 +</span>
 213          writeJournal(newState, out);
 214          Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);
 215      }
 216  
 217      /**
 218       * Restore launcher configuration from the restored data stream.
 219       *
 220       * &lt;P&gt;Keys may arrive in any order.
 221       *
 222       * @param data the key/value pair from the server
 223       */
 224      @Override
 225      public void restoreEntity(BackupDataInputStream data) {
 226          if (VERBOSE) Log.v(TAG, &quot;restoreEntity&quot;);
 227          if (mKeys == null) {
 228              mKeys = new ArrayList&lt;Key&gt;();
 229          }
 230          byte[] buffer = new byte[512];
 231              String backupKey = data.getKey();
 232              int dataSize = data.size();
 233              if (buffer.length &lt; dataSize) {
 234                  buffer = new byte[dataSize];
 235              }
 236              Key key = null;
 237          int bytesRead = 0;
 238          try {
 239              bytesRead = data.read(buffer, 0, dataSize);
 240              if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 241          } catch (IOException e) {
 242              Log.e(TAG, &quot;failed to read entity from restore data&quot;, e);
 243          }
 244          try {
 245              key = backupKeyToKey(backupKey);
 246              mKeys.add(key);
 247              switch (key.type) {
 248                  case Key.FAVORITE:
 249                      restoreFavorite(key, buffer, dataSize, mKeys);
 250                      break;
 251  
 252                  case Key.SCREEN:
 253                      restoreScreen(key, buffer, dataSize, mKeys);
 254                      break;
 255  
 256                  case Key.ICON:
 257                      restoreIcon(key, buffer, dataSize, mKeys);
 258                      break;
 259  
 260                  case Key.WIDGET:
 261                      restoreWidget(key, buffer, dataSize, mKeys);
 262                      break;
 263  
 264                  default:
 265                      Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 266                      break;
 267              }
 268          } catch (KeyParsingException e) {
 269              Log.w(TAG, &quot;ignoring unparsable backup key: &quot; + backupKey);
 270          }
 271  
 272      }
 273  
 274      /**
 275       * Record the restore state for the next backup.
 276       *
 277       * @param newState notes about the backup state after restore.
 278       */
 279      @Override
 280      public void writeNewStateDescription(ParcelFileDescriptor newState) {
 281          // clear the output journal time, to force a full backup to
 282          // will catch any changes the restore process might have made
 283          Journal out = new Journal();
 284          out.t = 0;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 285 -        out.key = mKeys.toArray(BackupProtos.Key.EMPTY_ARRAY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 286 +        out.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);</span>
 287          writeJournal(newState, out);
 288          Log.v(TAG, &quot;onRestore: read &quot; + mKeys.size() + &quot; rows&quot;);
 289          mKeys.clear();
 290      }
 291  
 292      /**
 293       * Write all modified favorites to the data stream.
 294       *
 295       *
 296       * @param in notes from last backup
 297       * @param data output stream for key/value pairs
 298       * @param out notes about this backup
 299       * @param keys keys to mark as clean in the notes for next backup
 300       * @throws IOException
 301       */
 302      private void backupFavorites(Journal in, BackupDataOutput data, Journal out,
 303              ArrayList&lt;Key&gt; keys)
 304              throws IOException {
 305          // read the old ID set
 306          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.FAVORITE, in);
 307          if (DEBUG) Log.d(TAG, &quot;favorite savedIds.size()=&quot; + savedIds.size());
 308  
 309          // persist things that have changed since the last backup
 310          ContentResolver cr = mContext.getContentResolver();
 311          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 312                  null, null, null);
 313          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 314          try {
 315              cursor.moveToPosition(-1);
 316              while(cursor.moveToNext()) {
 317                  final long id = cursor.getLong(ID_INDEX);
 318                  final long updateTime = cursor.getLong(ID_MODIFIED);
 319                  Key key = getKey(Key.FAVORITE, id);
 320                  keys.add(key);
 321                  final String backupKey = keyToBackupKey(key);
 322                  currentIds.add(backupKey);
 323                  if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 324                      byte[] blob = packFavorite(cursor);
 325                      writeRowToBackup(key, blob, out, data);
 326                  } else {
 327                      if (VERBOSE) Log.v(TAG, &quot;favorite &quot; + id + &quot; was too old: &quot; + updateTime);
 328                  }
 329              }
 330          } finally {
 331              cursor.close();
 332          }
 333          if (DEBUG) Log.d(TAG, &quot;favorite currentIds.size()=&quot; + currentIds.size());
 334  
 335          // these IDs must have been deleted
 336          savedIds.removeAll(currentIds);
 337          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 338      }
 339  
 340      /**
 341       * Read a favorite from the stream.
 342       *
 343       * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 344       *
 345       * @param key identifier for the row
 346       * @param buffer the serialized proto from the stream, may be larger than dataSize
 347       * @param dataSize the size of the proto from the stream
 348       * @param keys keys to mark as clean in the notes for next backup
 349       */
 350      private void restoreFavorite(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 351          if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 352          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 353                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 354  
 355          if (!mRestoreEnabled) {
 356              if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 357              return;
 358          }
 359  
 360          try {
 361              ContentResolver cr = mContext.getContentResolver();
 362              ContentValues values = unpackFavorite(buffer, 0, dataSize);
 363              cr.insert(Favorites.CONTENT_URI, values);
 364          } catch (InvalidProtocolBufferNanoException e) {
 365              Log.e(TAG, &quot;failed to decode favorite&quot;, e);
 366          }
 367      }
 368  
 369      /**
 370       * Write all modified screens to the data stream.
 371       *
 372       *
 373       * @param in notes from last backup
 374       * @param data output stream for key/value pairs
 375       * @param out notes about this backup
 376       * @param keys keys to mark as clean in the notes for next backup
 377       * @throws IOException
 378       */
 379      private void backupScreens(Journal in, BackupDataOutput data, Journal out,
 380              ArrayList&lt;Key&gt; keys)
 381              throws IOException {
 382          // read the old ID set
 383          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.SCREEN, in);
 384          if (DEBUG) Log.d(TAG, &quot;screen savedIds.size()=&quot; + savedIds.size());
 385  
 386          // persist things that have changed since the last backup
 387          ContentResolver cr = mContext.getContentResolver();
 388          Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 389                  null, null, null);
 390          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 391          try {
 392              cursor.moveToPosition(-1);
 393              if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + in.t);
 394              while(cursor.moveToNext()) {
 395                  final long id = cursor.getLong(ID_INDEX);
 396                  final long updateTime = cursor.getLong(ID_MODIFIED);
 397                  Key key = getKey(Key.SCREEN, id);
 398                  keys.add(key);
 399                  final String backupKey = keyToBackupKey(key);
 400                  currentIds.add(backupKey);
 401                  if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 402                      byte[] blob = packScreen(cursor);
 403                      writeRowToBackup(key, blob, out, data);
 404                  } else {
 405                      if (VERBOSE) Log.v(TAG, &quot;screen &quot; + id + &quot; was too old: &quot; + updateTime);
 406                  }
 407              }
 408          } finally {
 409              cursor.close();
 410          }
 411          if (DEBUG) Log.d(TAG, &quot;screen currentIds.size()=&quot; + currentIds.size());
 412  
 413          // these IDs must have been deleted
 414          savedIds.removeAll(currentIds);
 415          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 416      }
 417  
 418      /**
 419       * Read a screen from the stream.
 420       *
 421       * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 422       *
 423       * @param key identifier for the row
 424       * @param buffer the serialized proto from the stream, may be larger than dataSize
 425       * @param dataSize the size of the proto from the stream
 426       * @param keys keys to mark as clean in the notes for next backup
 427       */
 428      private void restoreScreen(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 429          if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 430          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 431                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 432  
 433          if (!mRestoreEnabled) {
 434              if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 435              return;
 436          }
 437  
 438          try {
 439              ContentResolver cr = mContext.getContentResolver();
 440              ContentValues values = unpackScreen(buffer, 0, dataSize);
 441              cr.insert(WorkspaceScreens.CONTENT_URI, values);
 442  
 443          } catch (InvalidProtocolBufferNanoException e) {
 444              Log.e(TAG, &quot;failed to decode screen&quot;, e);
 445          }
 446      }
 447  
 448      /**
 449       * Write all the static icon resources we need to render placeholders
 450       * for a package that is not installed.
 451       *
 452       * @param in notes from last backup
 453       * @param data output stream for key/value pairs
 454       * @param out notes about this backup
 455       * @param keys keys to mark as clean in the notes for next backup
 456       * @throws IOException
 457       */
 458      private void backupIcons(Journal in, BackupDataOutput data, Journal out,
 459              ArrayList&lt;Key&gt; keys) throws IOException {
 460          // persist icons that haven&#x27;t been persisted yet
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 461 -        final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 462 -        if (appState == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 463 +        if (!initializeIconCache()) {</span>
 464              dataChanged(); // try again later
 465              if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 466              return;
 467          }
 468          final ContentResolver cr = mContext.getContentResolver();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 469 -        final IconCache iconCache = appState.getIconCache();</span>
 470          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 471  
 472          // read the old ID set
 473          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.ICON, in);
 474          if (DEBUG) Log.d(TAG, &quot;icon savedIds.size()=&quot; + savedIds.size());
 475  
 476          int startRows = out.rows;
 477          if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 478          String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION;
 479          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 480                  where, null, null);
 481          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 482          try {
 483              cursor.moveToPosition(-1);
 484              while(cursor.moveToNext()) {
 485                  final long id = cursor.getLong(ID_INDEX);
 486                  final String intentDescription = cursor.getString(INTENT_INDEX);
 487                  try {
 488                      Intent intent = Intent.parseUri(intentDescription, 0);
 489                      ComponentName cn = intent.getComponent();
 490                      Key key = null;
 491                      String backupKey = null;
 492                      if (cn != null) {
 493                          key = getKey(Key.ICON, cn.flattenToShortString());
 494                          backupKey = keyToBackupKey(key);
 495                          currentIds.add(backupKey);
 496                      } else {
 497                          Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 498                      }
 499                      if (savedIds.contains(backupKey)) {
 500                          if (VERBOSE) Log.v(TAG, &quot;already saved icon &quot; + backupKey);
 501  
 502                          // remember that we already backed this up previously
 503                          keys.add(key);
 504                      } else if (backupKey != null) {
 505                          if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 506                          if ((out.rows - startRows) &lt; MAX_ICONS_PER_PASS) {
 507                              if (VERBOSE) Log.v(TAG, &quot;saving icon &quot; + backupKey);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 508 -                            Bitmap icon = iconCache.getIcon(intent);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 509 +                            Bitmap icon = mIconCache.getIcon(intent);</span>
 510                              keys.add(key);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 511 -                            if (icon != null &amp;&amp; !iconCache.isDefaultIcon(icon)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 512 +                            if (icon != null &amp;&amp; !mIconCache.isDefaultIcon(icon)) {</span>
 513                                  byte[] blob = packIcon(dpi, icon);
 514                                  writeRowToBackup(key, blob, out, data);
 515                              }
 516                          } else {
 517                              if (VERBOSE) Log.d(TAG, &quot;deferring icon backup &quot; + backupKey);
 518                              // too many icons for this pass, request another.
 519                              dataChanged();
 520                          }
 521                      }
 522                  } catch (URISyntaxException e) {
 523                      Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 524                  } catch (IOException e) {
 525                      Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 526                  }
 527  
 528              }
 529          } finally {
 530              cursor.close();
 531          }
 532          if (DEBUG) Log.d(TAG, &quot;icon currentIds.size()=&quot; + currentIds.size());
 533  
 534          // these IDs must have been deleted
 535          savedIds.removeAll(currentIds);
 536          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 537      }
 538  
 539      /**
 540       * Read an icon from the stream.
 541       *
 542       * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 543       *
 544       * @param key identifier for the row
 545       * @param buffer the serialized proto from the stream, may be larger than dataSize
 546       * @param dataSize the size of the proto from the stream
 547       * @param keys keys to mark as clean in the notes for next backup
 548       */
 549      private void restoreIcon(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 550          if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 551          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 552                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 553 +</span>
 554          try {
 555              Resource res = unpackIcon(buffer, 0, dataSize);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 556 -            if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 557 -            if (DEBUG_PAYLOAD) Log.d(TAG, &quot;read &quot; +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 558 -                    Base64.encodeToString(res.data, 0, res.data.length,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 559 -                            Base64.NO_WRAP));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 560 +            if (DEBUG) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 561 +                Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 562 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 563 +            if (DEBUG_PAYLOAD) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 564 +                Log.d(TAG, &quot;read &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 565 +                        Base64.encodeToString(res.data, 0, res.data.length,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 566 +                                Base64.NO_WRAP));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 567 +            }</span>
 568              Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 569              if (icon == null) {
 570                  Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 571              }
 572  
 573              if (!mRestoreEnabled) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 574 -                if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 575 +                if (VERBOSE) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 576 +                    Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 577 +                }</span>
 578                  return;
 579              } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 580 -                // future site of icon cache mutation</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 581 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 582 -        } catch (InvalidProtocolBufferNanoException e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 583 -            Log.e(TAG, &quot;failed to decode icon&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 584 +                IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(key.name),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 585 +                        icon, res.dpi);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 586 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 587 +        } catch (IOException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 588 +            Log.d(TAG, &quot;failed to save restored icon for: &quot; + key.name, e);</span>
 589          }
 590      }
 591  
 592      /**
 593       * Write all the static widget resources we need to render placeholders
 594       * for a package that is not installed.
 595       *
 596       * @param in notes from last backup
 597       * @param data output stream for key/value pairs
 598       * @param out notes about this backup
 599       * @param keys keys to mark as clean in the notes for next backup
 600       * @throws IOException
 601       */
 602      private void backupWidgets(Journal in, BackupDataOutput data, Journal out,
 603              ArrayList&lt;Key&gt; keys) throws IOException {
 604          // persist static widget info that hasn&#x27;t been persisted yet
 605          final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 606 -        if (appState == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 607 -            dataChanged(); // try again later</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 608 -            if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying widget backup&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 609 +        if (appState == null || !initializeIconCache()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 610 +            Log.w(TAG, &quot;Failed to get icon cache during restore&quot;);</span>
 611              return;
 612          }
 613          final ContentResolver cr = mContext.getContentResolver();
 614          final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 615          final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 616 -        final IconCache iconCache = appState.getIconCache();</span>
 617          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 618          final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 619          if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 620  
 621          // read the old ID set
 622          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.WIDGET, in);
 623          if (DEBUG) Log.d(TAG, &quot;widgets savedIds.size()=&quot; + savedIds.size());
 624  
 625          int startRows = out.rows;
 626          if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 627          String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET;
 628          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 629                  where, null, null);
 630          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 631          try {
 632              cursor.moveToPosition(-1);
 633              while(cursor.moveToNext()) {
 634                  final long id = cursor.getLong(ID_INDEX);
 635                  final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 636                  final int spanX = cursor.getInt(SPANX_INDEX);
 637                  final int spanY = cursor.getInt(SPANY_INDEX);
 638                  final ComponentName provider = ComponentName.unflattenFromString(providerName);
 639                  Key key = null;
 640                  String backupKey = null;
 641                  if (provider != null) {
 642                      key = getKey(Key.WIDGET, providerName);
 643                      backupKey = keyToBackupKey(key);
 644                      currentIds.add(backupKey);
 645                  } else {
 646                      Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 647                  }
 648                  if (savedIds.contains(backupKey)) {
 649                      if (VERBOSE) Log.v(TAG, &quot;already saved widget &quot; + backupKey);
 650  
 651                      // remember that we already backed this up previously
 652                      keys.add(key);
 653                  } else if (backupKey != null) {
 654                      if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 655                      if ((out.rows - startRows) &lt; MAX_WIDGETS_PER_PASS) {
 656                          if (VERBOSE) Log.v(TAG, &quot;saving widget &quot; + backupKey);
 657                          previewLoader.setPreviewSize(spanX * profile.cellWidthPx,
 658                                  spanY * profile.cellHeightPx, widgetSpacingLayout);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 659 -                        byte[] blob = packWidget(dpi, previewLoader, iconCache, provider);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 660 +                        byte[] blob = packWidget(dpi, previewLoader, mIconCache, provider);</span>
 661                          keys.add(key);
 662                          writeRowToBackup(key, blob, out, data);
 663  
 664                      } else {
 665                          if (VERBOSE) Log.d(TAG, &quot;deferring widget backup &quot; + backupKey);
 666                          // too many widgets for this pass, request another.
 667                          dataChanged();
 668                      }
 669                  }
 670              }
 671          } finally {
 672              cursor.close();
 673          }
 674          if (DEBUG) Log.d(TAG, &quot;widget currentIds.size()=&quot; + currentIds.size());
 675  
 676          // these IDs must have been deleted
 677          savedIds.removeAll(currentIds);
 678          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 679      }
 680  
 681      /**
 682       * Read a widget from the stream.
 683       *
 684       * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 685       *
 686       * @param key identifier for the row
 687       * @param buffer the serialized proto from the stream, may be larger than dataSize
 688       * @param dataSize the size of the proto from the stream
 689       * @param keys keys to mark as clean in the notes for next backup
 690       */
 691      private void restoreWidget(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 692          if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 693          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 694                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 695          try {
 696              Widget widget = unpackWidget(buffer, 0, dataSize);
 697              if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 698              if (widget.icon.data != null)  {
 699                  Bitmap icon = BitmapFactory
 700                          .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 701                  if (icon == null) {
 702                      Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 703                  }
 704              }
 705  
 706              if (!mRestoreEnabled) {
 707                  if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 708                  return;
 709              } else {
 710                  // future site of widget table mutation
 711              }
 712          } catch (InvalidProtocolBufferNanoException e) {
 713              Log.e(TAG, &quot;failed to decode widget&quot;, e);
 714          }
 715      }
 716  
 717      /** create a new key, with an integer ID.
 718       *
 719       * &lt;P&gt; Keys contain their own checksum instead of using
 720       * the heavy-weight CheckedMessage wrapper.
 721       */
 722      private Key getKey(int type, long id) {
 723          Key key = new Key();
 724          key.type = type;
 725          key.id = id;
 726          key.checksum = checkKey(key);
 727          return key;
 728      }
 729  
 730      /** create a new key for a named object.
 731       *
 732       * &lt;P&gt; Keys contain their own checksum instead of using
 733       * the heavy-weight CheckedMessage wrapper.
 734       */
 735      private Key getKey(int type, String name) {
 736          Key key = new Key();
 737          key.type = type;
 738          key.name = name;
 739          key.checksum = checkKey(key);
 740          return key;
 741      }
 742  
 743      /** keys need to be strings, serialize and encode. */
 744      private String keyToBackupKey(Key key) {
 745          return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 746      }
 747  
 748      /** keys need to be strings, decode and parse. */
 749      private Key backupKeyToKey(String backupKey) throws KeyParsingException {
 750          try {
 751              Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 752              if (key.checksum != checkKey(key)) {
 753                  key = null;
 754                  throw new KeyParsingException(&quot;invalid key read from stream&quot; + backupKey);
 755              }
 756              return key;
 757          } catch (InvalidProtocolBufferNanoException e) {
 758              throw new KeyParsingException(e);
 759          } catch (IllegalArgumentException e) {
 760              throw new KeyParsingException(e);
 761          }
 762      }
 763  
 764      private String getKeyName(Key key) {
 765          if (TextUtils.isEmpty(key.name)) {
 766              return Long.toString(key.id);
 767          } else {
 768              return key.name;
 769          }
 770  
 771      }
 772  
 773      private String geKeyType(Key key) {
 774          switch (key.type) {
 775              case Key.FAVORITE:
 776                  return &quot;favorite&quot;;
 777              case Key.SCREEN:
 778                  return &quot;screen&quot;;
 779              case Key.ICON:
 780                  return &quot;icon&quot;;
 781              case Key.WIDGET:
 782                  return &quot;widget&quot;;
 783              default:
 784                  return &quot;anonymous&quot;;
 785          }
 786      }
 787  
 788      /** Compute the checksum over the important bits of a key. */
 789      private long checkKey(Key key) {
 790          CRC32 checksum = new CRC32();
 791          checksum.update(key.type);
 792          checksum.update((int) (key.id &amp; 0xffff));
 793          checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 794          if (!TextUtils.isEmpty(key.name)) {
 795              checksum.update(key.name.getBytes());
 796          }
 797          return checksum.getValue();
 798      }
 799  
 800      /** Serialize a Favorite for persistence, including a checksum wrapper. */
 801      private byte[] packFavorite(Cursor c) {
 802          Favorite favorite = new Favorite();
 803          favorite.id = c.getLong(ID_INDEX);
 804          favorite.screen = c.getInt(SCREEN_INDEX);
 805          favorite.container = c.getInt(CONTAINER_INDEX);
 806          favorite.cellX = c.getInt(CELLX_INDEX);
 807          favorite.cellY = c.getInt(CELLY_INDEX);
 808          favorite.spanX = c.getInt(SPANX_INDEX);
 809          favorite.spanY = c.getInt(SPANY_INDEX);
 810          favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 811          if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 812              String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 813              if (!TextUtils.isEmpty(iconPackage)) {
 814                  favorite.iconPackage = iconPackage;
 815              }
 816              String iconResource = c.getString(ICON_RESOURCE_INDEX);
 817              if (!TextUtils.isEmpty(iconResource)) {
 818                  favorite.iconResource = iconResource;
 819              }
 820          }
 821          if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 822              byte[] blob = c.getBlob(ICON_INDEX);
 823              if (blob != null &amp;&amp; blob.length &gt; 0) {
 824                  favorite.icon = blob;
 825              }
 826          }
 827          String title = c.getString(TITLE_INDEX);
 828          if (!TextUtils.isEmpty(title)) {
 829              favorite.title = title;
 830          }
 831          String intent = c.getString(INTENT_INDEX);
 832          if (!TextUtils.isEmpty(intent)) {
 833              favorite.intent = intent;
 834          }
 835          favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 836          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 837              favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 838              String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 839              if (!TextUtils.isEmpty(appWidgetProvider)) {
 840                  favorite.appWidgetProvider = appWidgetProvider;
 841              }
 842          }
 843  
 844          return writeCheckedBytes(favorite);
 845      }
 846  
 847      /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 848      private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize)
 849              throws InvalidProtocolBufferNanoException {
 850          Favorite favorite = new Favorite();
 851          MessageNano.mergeFrom(favorite, readCheckedBytes(buffer, offset, dataSize));
 852          if (VERBOSE) Log.v(TAG, &quot;unpacked favorite &quot; + favorite.itemType + &quot;, &quot; +
 853                  (TextUtils.isEmpty(favorite.title) ? favorite.id : favorite.title));
 854          ContentValues values = new ContentValues();
 855          values.put(Favorites._ID, favorite.id);
 856          values.put(Favorites.SCREEN, favorite.screen);
 857          values.put(Favorites.CONTAINER, favorite.container);
 858          values.put(Favorites.CELLX, favorite.cellX);
 859          values.put(Favorites.CELLY, favorite.cellY);
 860          values.put(Favorites.SPANX, favorite.spanX);
 861          values.put(Favorites.SPANY, favorite.spanY);
 862          values.put(Favorites.ICON_TYPE, favorite.iconType);
 863          if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 864              values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 865              values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 866          }
 867          if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 868              values.put(Favorites.ICON, favorite.icon);
 869          }
 870          if (!TextUtils.isEmpty(favorite.title)) {
 871              values.put(Favorites.TITLE, favorite.title);
 872          } else {
 873              values.put(Favorites.TITLE, &quot;&quot;);
 874          }
 875          if (!TextUtils.isEmpty(favorite.intent)) {
 876              values.put(Favorites.INTENT, favorite.intent);
 877          }
 878          values.put(Favorites.ITEM_TYPE, favorite.itemType);
 879          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 880              if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 881                  values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 882              }
 883              values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 884          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 885 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 886 +        // Let LauncherModel know we&#x27;ve been here.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 887 +        values.put(LauncherSettings.Favorites.RESTORED, 1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 888 +</span>
 889          return values;
 890      }
 891  
 892      /** Serialize a Screen for persistence, including a checksum wrapper. */
 893      private byte[] packScreen(Cursor c) {
 894          Screen screen = new Screen();
 895          screen.id = c.getLong(ID_INDEX);
 896          screen.rank = c.getInt(SCREEN_RANK_INDEX);
 897  
 898          return writeCheckedBytes(screen);
 899      }
 900  
 901      /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 902      private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize)
 903              throws InvalidProtocolBufferNanoException {
 904          Screen screen = new Screen();
 905          MessageNano.mergeFrom(screen, readCheckedBytes(buffer, offset, dataSize));
 906          if (VERBOSE) Log.v(TAG, &quot;unpacked screen &quot; + screen.id + &quot;/&quot; + screen.rank);
 907          ContentValues values = new ContentValues();
 908          values.put(WorkspaceScreens._ID, screen.id);
 909          values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 910          return values;
 911      }
 912  
 913      /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 914      private byte[] packIcon(int dpi, Bitmap icon) {
 915          Resource res = new Resource();
 916          res.dpi = dpi;
 917          ByteArrayOutputStream os = new ByteArrayOutputStream();
 918          if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 919              res.data = os.toByteArray();
 920          }
 921          return writeCheckedBytes(res);
 922      }
 923  
 924      /** Deserialize an icon resource from persistence, after verifying checksum wrapper. */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 925 -    private Resource unpackIcon(byte[] buffer, int offset, int dataSize)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 926 +    private static Resource unpackIcon(byte[] buffer, int offset, int dataSize)</span>
 927              throws InvalidProtocolBufferNanoException {
 928          Resource res = new Resource();
 929          MessageNano.mergeFrom(res, readCheckedBytes(buffer, offset, dataSize));
 930          if (VERBOSE) Log.v(TAG, &quot;unpacked icon &quot; + res.dpi + &quot;/&quot; + res.data.length);
 931          return res;
 932      }
 933  
 934      /** Serialize a widget for persistence, including a checksum wrapper. */
 935      private byte[] packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 936              ComponentName provider) {
 937          final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);
 938          Widget widget = new Widget();
 939          widget.provider = provider.flattenToShortString();
 940          widget.label = info.label;
 941          widget.configure = info.configure != null;
 942          if (info.icon != 0) {
 943              widget.icon = new Resource();
 944              Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
 945              Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 946              ByteArrayOutputStream os = new ByteArrayOutputStream();
 947              if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 948                  widget.icon.data = os.toByteArray();
 949                  widget.icon.dpi = dpi;
 950              }
 951          }
 952          if (info.previewImage != 0) {
 953              widget.preview = new Resource();
 954              Bitmap preview = previewLoader.generateWidgetPreview(info, null);
 955              ByteArrayOutputStream os = new ByteArrayOutputStream();
 956              if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 957                  widget.preview.data = os.toByteArray();
 958                  widget.preview.dpi = dpi;
 959              }
 960          }
 961          return writeCheckedBytes(widget);
 962      }
 963  
 964      /** Deserialize a widget from persistence, after verifying checksum wrapper. */
 965      private Widget unpackWidget(byte[] buffer, int offset, int dataSize)
 966              throws InvalidProtocolBufferNanoException {
 967          Widget widget = new Widget();
 968          MessageNano.mergeFrom(widget, readCheckedBytes(buffer, offset, dataSize));
 969          if (VERBOSE) Log.v(TAG, &quot;unpacked widget &quot; + widget.provider);
 970          return widget;
 971      }
 972  
 973      /**
 974       * Read the old journal from the input file.
 975       *
 976       * In the event of any error, just pretend we didn&#x27;t have a journal,
 977       * in that case, do a full backup.
 978       *
 979       * @param oldState the read-0only file descriptor pointing to the old journal
 980       * @return a Journal protocol buffer
 981       */
 982      private Journal readJournal(ParcelFileDescriptor oldState) {
 983          Journal journal = new Journal();
 984          if (oldState == null) {
 985              return journal;
 986          }
 987          FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
 988          try {
 989              int availableBytes = inStream.available();
 990              if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
 991              if (availableBytes &lt; MAX_JOURNAL_SIZE) {
 992                  byte[] buffer = new byte[availableBytes];
 993                  int bytesRead = 0;
 994                  boolean valid = false;
 995                  InvalidProtocolBufferNanoException lastProtoException = null;
 996                  while (availableBytes &gt; 0) {
 997                      try {
 998                          // OMG what are you doing? This is crazy inefficient!
 999                          // If we read a byte that is not ours, we will cause trouble: b/12491813
1000                          // However, we don&#x27;t know how many bytes to expect (oops).
1001                          // So we have to step through *slowly*, watching for the end.
1002                          int result = inStream.read(buffer, bytesRead, 1);
1003                          if (result &gt; 0) {
1004                              availableBytes -= result;
1005                              bytesRead += result;
1006                              if (DEBUG &amp;&amp; (bytesRead % 100 == 0)) {
1007                                  Log.d(TAG, &quot;read some bytes: &quot; + bytesRead);
1008                              }
1009                          } else {
1010                              Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1011                              // stop reading and see what there is to parse
1012                              availableBytes = 0;
1013                          }
1014                      } catch (IOException e) {
1015                          buffer = null;
1016                          availableBytes = 0;
1017                      }
1018  
1019                      // check the buffer to see if we have a valid journal
1020                      try {
1021                          MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));
1022                          // if we are here, then we have read a valid, checksum-verified journal
1023                          valid = true;
1024                          availableBytes = 0;
1025                          if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1026                      } catch (InvalidProtocolBufferNanoException e) {
1027                          // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1028                          lastProtoException = e;
1029                          journal.clear();
1030                      }
1031                  }
1032                  if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1033                  if (!valid) {
1034                      Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1035                  }
1036              }
1037          } catch (IOException e) {
1038              Log.w(TAG, &quot;failed to close the journal&quot;, e);
1039          } finally {
1040              try {
1041                  inStream.close();
1042              } catch (IOException e) {
1043                  Log.w(TAG, &quot;failed to close the journal&quot;, e);
1044              }
1045          }
1046          return journal;
1047      }
1048  
1049      private void writeRowToBackup(Key key, byte[] blob, Journal out,
1050              BackupDataOutput data) throws IOException {
1051          String backupKey = keyToBackupKey(key);
1052          data.writeEntityHeader(backupKey, blob.length);
1053          data.writeEntityData(blob, blob.length);
1054          out.rows++;
1055          out.bytes += blob.length;
1056          if (VERBOSE) Log.v(TAG, &quot;saving &quot; + geKeyType(key) + &quot; &quot; + backupKey + &quot;: &quot; +
1057                  getKeyName(key) + &quot;/&quot; + blob.length);
1058          if(DEBUG_PAYLOAD) {
1059              String encoded = Base64.encodeToString(blob, 0, blob.length, Base64.NO_WRAP);
1060              final int chunkSize = 1024;
1061              for (int offset = 0; offset &lt; encoded.length(); offset += chunkSize) {
1062                  int end = offset + chunkSize;
1063                  end = Math.min(end, encoded.length());
1064                  Log.w(TAG, &quot;wrote &quot; + encoded.substring(offset, end));
1065              }
1066          }
1067      }
1068  
1069      private Set&lt;String&gt; getSavedIdsByType(int type, Journal in) {
1070          Set&lt;String&gt; savedIds = new HashSet&lt;String&gt;();
1071          for(int i = 0; i &lt; in.key.length; i++) {
1072              Key key = in.key[i];
1073              if (key.type == type) {
1074                  savedIds.add(keyToBackupKey(key));
1075              }
1076          }
1077          return savedIds;
1078      }
1079  
1080      private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data)
1081              throws IOException {
1082          int rows = 0;
1083          for(String deleted: deletedIds) {
1084              if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
1085              data.writeEntityHeader(deleted, -1);
1086              rows++;
1087          }
1088          return rows;
1089      }
1090  
1091      /**
1092       * Write the new journal to the output file.
1093       *
1094       * In the event of any error, just pretend we didn&#x27;t have a journal,
1095       * in that case, do a full backup.
1096  
1097       * @param newState the write-only file descriptor pointing to the new journal
1098       * @param journal a Journal protocol buffer
1099       */
1100      private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1101          FileOutputStream outStream = null;
1102          try {
1103              outStream = new FileOutputStream(newState.getFileDescriptor());
1104              final byte[] journalBytes = writeCheckedBytes(journal);
1105              outStream.write(journalBytes);
1106              outStream.close();
1107              if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1108          } catch (IOException e) {
1109              Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1110          }
1111      }
1112  
1113      /** Wrap a proto in a CheckedMessage and compute the checksum. */
1114      private byte[] writeCheckedBytes(MessageNano proto) {
1115          CheckedMessage wrapper = new CheckedMessage();
1116          wrapper.payload = MessageNano.toByteArray(proto);
1117          CRC32 checksum = new CRC32();
1118          checksum.update(wrapper.payload);
1119          wrapper.checksum = checksum.getValue();
1120          return MessageNano.toByteArray(wrapper);
1121      }
1122  
1123      /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1124 -    private byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1125 +    private static byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize)</span>
1126              throws InvalidProtocolBufferNanoException {
1127          CheckedMessage wrapper = new CheckedMessage();
1128          MessageNano.mergeFrom(wrapper, buffer, offset, dataSize);
1129          CRC32 checksum = new CRC32();
1130          checksum.update(wrapper.payload);
1131          if (wrapper.checksum != checksum.getValue()) {
1132              throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1133          }
1134          return wrapper.payload;
1135      }
1136  
1137      private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {
1138          if (mWidgetMap == null) {
1139              List&lt;AppWidgetProviderInfo&gt; widgets =
1140                      AppWidgetManager.getInstance(mContext).getInstalledProviders();
1141              mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());
1142              for (AppWidgetProviderInfo info : widgets) {
1143                  mWidgetMap.put(info.provider, info);
1144              }
1145          }
1146          return mWidgetMap.get(component);
1147      }
1148  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1149 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1150 +    private boolean initializeIconCache() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1151 +        if (mIconCache != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1152 +            return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1153 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1154 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1155 +        final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1156 +        if (appState == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1157 +            Throwable stackTrace = new Throwable();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1158 +            stackTrace.fillInStackTrace();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1159 +            Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1160 +            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1161 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1162 +        mIconCache = appState.getIconCache();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1163 +        return mIconCache != null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1164 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1165 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1166 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1167 +   // check if the launcher is in a state to support backup</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1168 +    private boolean launcherIsReady() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1169 +        ContentResolver cr = mContext.getContentResolver();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1170 +        Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1171 +        if (cursor == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1172 +            // launcher data has been wiped, do nothing</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1173 +            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1174 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1175 +        cursor.close();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1176 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1177 +        if (!initializeIconCache()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1178 +            // launcher services are unavailable, try again later</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1179 +            dataChanged();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1180 +            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1181 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1182 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1183 +        return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1184 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1185 +</span>
1186      private class KeyParsingException extends Throwable {
1187          private KeyParsingException(Throwable cause) {
1188              super(cause);
1189          }
1190  
1191          public KeyParsingException(String reason) {
1192              super(reason);
1193          }
1194      }
1195  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2013 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  package com.android.launcher3;
  17  
  18  import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  19  import com.google.protobuf.nano.MessageNano;
  20  
  21  import com.android.launcher3.LauncherSettings.Favorites;
  22  import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  23  import com.android.launcher3.backup.BackupProtos;
  24  import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  25  import com.android.launcher3.backup.BackupProtos.Favorite;
  26  import com.android.launcher3.backup.BackupProtos.Journal;
  27  import com.android.launcher3.backup.BackupProtos.Key;
  28  import com.android.launcher3.backup.BackupProtos.Resource;
  29  import com.android.launcher3.backup.BackupProtos.Screen;
  30  import com.android.launcher3.backup.BackupProtos.Widget;
  31  
  32  import android.app.backup.BackupDataInputStream;
  33  import android.app.backup.BackupDataOutput;
  34  import android.app.backup.BackupHelper;
  35  import android.app.backup.BackupManager;
  36  import android.appwidget.AppWidgetManager;
  37  import android.appwidget.AppWidgetProviderInfo;
  38  import android.content.ComponentName;
  39  import android.content.ContentResolver;
  40  import android.content.ContentValues;
  41  import android.content.Context;
  42  import android.content.Intent;
  43  import android.database.Cursor;
  44  import android.graphics.Bitmap;
  45  import android.graphics.BitmapFactory;
  46  import android.graphics.drawable.Drawable;
  47  import android.os.ParcelFileDescriptor;
  48  import android.text.TextUtils;
  49  import android.util.Base64;
  50  import android.util.Log;
  51  
  52  import java.io.ByteArrayOutputStream;
  53  import java.io.FileInputStream;
  54  import java.io.FileOutputStream;
  55  import java.io.IOException;
  56  import java.net.URISyntaxException;
  57  import java.util.ArrayList;
  58  import java.util.HashMap;
  59  import java.util.HashSet;
  60  import java.util.List;
  61  import java.util.Set;
  62  import java.util.zip.CRC32;
  63  
  64  /**
  65   * Persist the launcher home state across calamities.
  66   */
  67  public class LauncherBackupHelper implements BackupHelper {
  68  
  69      private static final String TAG = &quot;LauncherBackupHelper&quot;;
  70      private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  71      private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  72      private static final boolean DEBUG_PAYLOAD = false;
  73  
  74      private static final int MAX_JOURNAL_SIZE = 1000000;
  75  
  76      /** icons are large, dribble them out */
  77      private static final int MAX_ICONS_PER_PASS = 10;
  78  
  79      /** widgets contain previews, which are very large, dribble them out */
  80      private static final int MAX_WIDGETS_PER_PASS = 5;
  81  
  82      public static final int IMAGE_COMPRESSION_QUALITY = 75;
  83  
  84      public static final String LAUNCHER_PREFIX = &quot;L&quot;;
  85  
  86      public static final String LAUNCHER_PREFS_PREFIX = &quot;LP&quot;;
  87  
  88      private static final Bitmap.CompressFormat IMAGE_FORMAT =
  89              android.graphics.Bitmap.CompressFormat.PNG;
  90  
  91      private static BackupManager sBackupManager;
  92  
  93      private static final String[] FAVORITE_PROJECTION = {
  94              Favorites._ID,                     // 0
  95              Favorites.MODIFIED,                // 1
  96              Favorites.INTENT,                  // 2
  97              Favorites.APPWIDGET_PROVIDER,      // 3
  98              Favorites.APPWIDGET_ID,            // 4
  99              Favorites.CELLX,                   // 5
 100              Favorites.CELLY,                   // 6
 101              Favorites.CONTAINER,               // 7
 102              Favorites.ICON,                    // 8
 103              Favorites.ICON_PACKAGE,            // 9
 104              Favorites.ICON_RESOURCE,           // 10
 105              Favorites.ICON_TYPE,               // 11
 106              Favorites.ITEM_TYPE,               // 12
 107              Favorites.SCREEN,                  // 13
 108              Favorites.SPANX,                   // 14
 109              Favorites.SPANY,                   // 15
 110              Favorites.TITLE,                   // 16
 111      };
 112  
 113      private static final int ID_INDEX = 0;
 114      private static final int ID_MODIFIED = 1;
 115      private static final int INTENT_INDEX = 2;
 116      private static final int APPWIDGET_PROVIDER_INDEX = 3;
 117      private static final int APPWIDGET_ID_INDEX = 4;
 118      private static final int CELLX_INDEX = 5;
 119      private static final int CELLY_INDEX = 6;
 120      private static final int CONTAINER_INDEX = 7;
 121      private static final int ICON_INDEX = 8;
 122      private static final int ICON_PACKAGE_INDEX = 9;
 123      private static final int ICON_RESOURCE_INDEX = 10;
 124      private static final int ICON_TYPE_INDEX = 11;
 125      private static final int ITEM_TYPE_INDEX = 12;
 126      private static final int SCREEN_INDEX = 13;
 127      private static final int SPANX_INDEX = 14;
 128      private static final int SPANY_INDEX = 15;
 129      private static final int TITLE_INDEX = 16;
 130  
 131      private static final String[] SCREEN_PROJECTION = {
 132              WorkspaceScreens._ID,              // 0
 133              WorkspaceScreens.MODIFIED,         // 1
 134              WorkspaceScreens.SCREEN_RANK       // 2
 135      };
 136  
 137      private static final int SCREEN_RANK_INDEX = 2;
 138  


 139      private final Context mContext;
 140  
 141      private final boolean mRestoreEnabled;
 142  
 143      private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;
 144  
 145      private ArrayList&lt;Key&gt; mKeys;
 146  
 147      public LauncherBackupHelper(Context context, boolean restoreEnabled) {
 148          mContext = context;
 149          mRestoreEnabled = restoreEnabled;
 150      }
 151  
 152      private void dataChanged() {
 153          if (sBackupManager == null) {
 154              sBackupManager = new BackupManager(mContext);
 155          }
 156          sBackupManager.dataChanged();
 157      }
 158  
 159      /**
 160       * Back up launcher data so we can restore the user&#x27;s state on a new device.
 161       *
 162       * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 163       *
 164       * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 165       *
 166       * @param oldState notes from the last backup
 167       * @param data incremental key/value pairs to persist off-device
 168       * @param newState notes for the next backup
 169       * @throws IOException
 170       */
 171      @Override
 172      public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 173              ParcelFileDescriptor newState) {
 174          if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 175  
 176          Journal in = readJournal(oldState);
 177          Journal out = new Journal();
 178  
 179          long lastBackupTime = in.t;
 180          out.t = System.currentTimeMillis();
 181          out.rows = 0;
 182          out.bytes = 0;
 183  
 184          Log.v(TAG, &quot;lastBackupTime = &quot; + lastBackupTime);
 185  
 186          ArrayList&lt;Key&gt; keys = new ArrayList&lt;Key&gt;();
 187          try {
 188              backupFavorites(in, data, out, keys);
 189              backupScreens(in, data, out, keys);
 190              backupIcons(in, data, out, keys);
 191              backupWidgets(in, data, out, keys);
 192          } catch (IOException e) {
 193              Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 194          }
 195  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 196 -        out.key = keys.toArray(BackupProtos.Key.EMPTY_ARRAY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 197 +        out.key = keys.toArray(BackupProtos.Key.emptyArray());</span>













 198          writeJournal(newState, out);
 199          Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);
 200      }
 201  
 202      /**
 203       * Restore launcher configuration from the restored data stream.
 204       *
 205       * &lt;P&gt;Keys may arrive in any order.
 206       *
 207       * @param data the key/value pair from the server
 208       */
 209      @Override
 210      public void restoreEntity(BackupDataInputStream data) {
 211          if (VERBOSE) Log.v(TAG, &quot;restoreEntity&quot;);
 212          if (mKeys == null) {
 213              mKeys = new ArrayList&lt;Key&gt;();
 214          }
 215          byte[] buffer = new byte[512];
 216              String backupKey = data.getKey();
 217              int dataSize = data.size();
 218              if (buffer.length &lt; dataSize) {
 219                  buffer = new byte[dataSize];
 220              }
 221              Key key = null;
 222          int bytesRead = 0;
 223          try {
 224              bytesRead = data.read(buffer, 0, dataSize);
 225              if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 226          } catch (IOException e) {
 227              Log.e(TAG, &quot;failed to read entity from restore data&quot;, e);
 228          }
 229          try {
 230              key = backupKeyToKey(backupKey);
 231              mKeys.add(key);
 232              switch (key.type) {
 233                  case Key.FAVORITE:
 234                      restoreFavorite(key, buffer, dataSize, mKeys);
 235                      break;
 236  
 237                  case Key.SCREEN:
 238                      restoreScreen(key, buffer, dataSize, mKeys);
 239                      break;
 240  
 241                  case Key.ICON:
 242                      restoreIcon(key, buffer, dataSize, mKeys);
 243                      break;
 244  
 245                  case Key.WIDGET:
 246                      restoreWidget(key, buffer, dataSize, mKeys);
 247                      break;
 248  
 249                  default:
 250                      Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 251                      break;
 252              }
 253          } catch (KeyParsingException e) {
 254              Log.w(TAG, &quot;ignoring unparsable backup key: &quot; + backupKey);
 255          }
 256  
 257      }
 258  
 259      /**
 260       * Record the restore state for the next backup.
 261       *
 262       * @param newState notes about the backup state after restore.
 263       */
 264      @Override
 265      public void writeNewStateDescription(ParcelFileDescriptor newState) {
 266          // clear the output journal time, to force a full backup to
 267          // will catch any changes the restore process might have made
 268          Journal out = new Journal();
 269          out.t = 0;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 270 -        out.key = mKeys.toArray(BackupProtos.Key.EMPTY_ARRAY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 271 +        out.key = mKeys.toArray(BackupProtos.Key.emptyArray());</span>
 272          writeJournal(newState, out);
 273          Log.v(TAG, &quot;onRestore: read &quot; + mKeys.size() + &quot; rows&quot;);
 274          mKeys.clear();
 275      }
 276  
 277      /**
 278       * Write all modified favorites to the data stream.
 279       *
 280       *
 281       * @param in notes from last backup
 282       * @param data output stream for key/value pairs
 283       * @param out notes about this backup
 284       * @param keys keys to mark as clean in the notes for next backup
 285       * @throws IOException
 286       */
 287      private void backupFavorites(Journal in, BackupDataOutput data, Journal out,
 288              ArrayList&lt;Key&gt; keys)
 289              throws IOException {
 290          // read the old ID set
 291          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.FAVORITE, in);
 292          if (DEBUG) Log.d(TAG, &quot;favorite savedIds.size()=&quot; + savedIds.size());
 293  
 294          // persist things that have changed since the last backup
 295          ContentResolver cr = mContext.getContentResolver();
 296          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 297                  null, null, null);
 298          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 299          try {
 300              cursor.moveToPosition(-1);
 301              while(cursor.moveToNext()) {
 302                  final long id = cursor.getLong(ID_INDEX);
 303                  final long updateTime = cursor.getLong(ID_MODIFIED);
 304                  Key key = getKey(Key.FAVORITE, id);
 305                  keys.add(key);
 306                  final String backupKey = keyToBackupKey(key);
 307                  currentIds.add(backupKey);
 308                  if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 309                      byte[] blob = packFavorite(cursor);
 310                      writeRowToBackup(key, blob, out, data);
 311                  } else {
 312                      if (VERBOSE) Log.v(TAG, &quot;favorite &quot; + id + &quot; was too old: &quot; + updateTime);
 313                  }
 314              }
 315          } finally {
 316              cursor.close();
 317          }
 318          if (DEBUG) Log.d(TAG, &quot;favorite currentIds.size()=&quot; + currentIds.size());
 319  
 320          // these IDs must have been deleted
 321          savedIds.removeAll(currentIds);
 322          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 323      }
 324  
 325      /**
 326       * Read a favorite from the stream.
 327       *
 328       * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 329       *
 330       * @param key identifier for the row
 331       * @param buffer the serialized proto from the stream, may be larger than dataSize
 332       * @param dataSize the size of the proto from the stream
 333       * @param keys keys to mark as clean in the notes for next backup
 334       */
 335      private void restoreFavorite(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 336          if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 337          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 338                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 339  
 340          if (!mRestoreEnabled) {
 341              if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 342              return;
 343          }
 344  
 345          try {
 346              ContentResolver cr = mContext.getContentResolver();
 347              ContentValues values = unpackFavorite(buffer, 0, dataSize);
 348              cr.insert(Favorites.CONTENT_URI, values);
 349          } catch (InvalidProtocolBufferNanoException e) {
 350              Log.e(TAG, &quot;failed to decode favorite&quot;, e);
 351          }
 352      }
 353  
 354      /**
 355       * Write all modified screens to the data stream.
 356       *
 357       *
 358       * @param in notes from last backup
 359       * @param data output stream for key/value pairs
 360       * @param out notes about this backup
 361       * @param keys keys to mark as clean in the notes for next backup
 362       * @throws IOException
 363       */
 364      private void backupScreens(Journal in, BackupDataOutput data, Journal out,
 365              ArrayList&lt;Key&gt; keys)
 366              throws IOException {
 367          // read the old ID set
 368          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.SCREEN, in);
 369          if (DEBUG) Log.d(TAG, &quot;screen savedIds.size()=&quot; + savedIds.size());
 370  
 371          // persist things that have changed since the last backup
 372          ContentResolver cr = mContext.getContentResolver();
 373          Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 374                  null, null, null);
 375          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 376          try {
 377              cursor.moveToPosition(-1);
 378              if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + in.t);
 379              while(cursor.moveToNext()) {
 380                  final long id = cursor.getLong(ID_INDEX);
 381                  final long updateTime = cursor.getLong(ID_MODIFIED);
 382                  Key key = getKey(Key.SCREEN, id);
 383                  keys.add(key);
 384                  final String backupKey = keyToBackupKey(key);
 385                  currentIds.add(backupKey);
 386                  if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 387                      byte[] blob = packScreen(cursor);
 388                      writeRowToBackup(key, blob, out, data);
 389                  } else {
 390                      if (VERBOSE) Log.v(TAG, &quot;screen &quot; + id + &quot; was too old: &quot; + updateTime);
 391                  }
 392              }
 393          } finally {
 394              cursor.close();
 395          }
 396          if (DEBUG) Log.d(TAG, &quot;screen currentIds.size()=&quot; + currentIds.size());
 397  
 398          // these IDs must have been deleted
 399          savedIds.removeAll(currentIds);
 400          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 401      }
 402  
 403      /**
 404       * Read a screen from the stream.
 405       *
 406       * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 407       *
 408       * @param key identifier for the row
 409       * @param buffer the serialized proto from the stream, may be larger than dataSize
 410       * @param dataSize the size of the proto from the stream
 411       * @param keys keys to mark as clean in the notes for next backup
 412       */
 413      private void restoreScreen(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 414          if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 415          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 416                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 417  
 418          if (!mRestoreEnabled) {
 419              if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 420              return;
 421          }
 422  
 423          try {
 424              ContentResolver cr = mContext.getContentResolver();
 425              ContentValues values = unpackScreen(buffer, 0, dataSize);
 426              cr.insert(WorkspaceScreens.CONTENT_URI, values);
 427  
 428          } catch (InvalidProtocolBufferNanoException e) {
 429              Log.e(TAG, &quot;failed to decode screen&quot;, e);
 430          }
 431      }
 432  
 433      /**
 434       * Write all the static icon resources we need to render placeholders
 435       * for a package that is not installed.
 436       *
 437       * @param in notes from last backup
 438       * @param data output stream for key/value pairs
 439       * @param out notes about this backup
 440       * @param keys keys to mark as clean in the notes for next backup
 441       * @throws IOException
 442       */
 443      private void backupIcons(Journal in, BackupDataOutput data, Journal out,
 444              ArrayList&lt;Key&gt; keys) throws IOException {
 445          // persist icons that haven&#x27;t been persisted yet
 446          final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 447          if (appState == null) {

 448              dataChanged(); // try again later
 449              if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 450              return;
 451          }
 452          final ContentResolver cr = mContext.getContentResolver();
 453          final IconCache iconCache = appState.getIconCache();
 454          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 455  
 456          // read the old ID set
 457          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.ICON, in);
 458          if (DEBUG) Log.d(TAG, &quot;icon savedIds.size()=&quot; + savedIds.size());
 459  
 460          int startRows = out.rows;
 461          if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 462          String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION;
 463          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 464                  where, null, null);
 465          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 466          try {
 467              cursor.moveToPosition(-1);
 468              while(cursor.moveToNext()) {
 469                  final long id = cursor.getLong(ID_INDEX);
 470                  final String intentDescription = cursor.getString(INTENT_INDEX);
 471                  try {
 472                      Intent intent = Intent.parseUri(intentDescription, 0);
 473                      ComponentName cn = intent.getComponent();
 474                      Key key = null;
 475                      String backupKey = null;
 476                      if (cn != null) {
 477                          key = getKey(Key.ICON, cn.flattenToShortString());
 478                          backupKey = keyToBackupKey(key);
 479                          currentIds.add(backupKey);
 480                      } else {
 481                          Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 482                      }
 483                      if (savedIds.contains(backupKey)) {
 484                          if (VERBOSE) Log.v(TAG, &quot;already saved icon &quot; + backupKey);
 485  
 486                          // remember that we already backed this up previously
 487                          keys.add(key);
 488                      } else if (backupKey != null) {
 489                          if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 490                          if ((out.rows - startRows) &lt; MAX_ICONS_PER_PASS) {
 491                              if (VERBOSE) Log.v(TAG, &quot;saving icon &quot; + backupKey);
 492                              Bitmap icon = iconCache.getIcon(intent);

 493                              keys.add(key);
 494                              if (icon != null &amp;&amp; !iconCache.isDefaultIcon(icon)) {

 495                                  byte[] blob = packIcon(dpi, icon);
 496                                  writeRowToBackup(key, blob, out, data);
 497                              }
 498                          } else {
 499                              if (VERBOSE) Log.d(TAG, &quot;deferring icon backup &quot; + backupKey);
 500                              // too many icons for this pass, request another.
 501                              dataChanged();
 502                          }
 503                      }
 504                  } catch (URISyntaxException e) {
 505                      Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 506                  } catch (IOException e) {
 507                      Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 508                  }
 509  
 510              }
 511          } finally {
 512              cursor.close();
 513          }
 514          if (DEBUG) Log.d(TAG, &quot;icon currentIds.size()=&quot; + currentIds.size());
 515  
 516          // these IDs must have been deleted
 517          savedIds.removeAll(currentIds);
 518          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 519      }
 520  
 521      /**
 522       * Read an icon from the stream.
 523       *
 524       * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 525       *
 526       * @param key identifier for the row
 527       * @param buffer the serialized proto from the stream, may be larger than dataSize
 528       * @param dataSize the size of the proto from the stream
 529       * @param keys keys to mark as clean in the notes for next backup
 530       */
 531      private void restoreIcon(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 532          if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 533          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 534                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));

 535          try {
 536              Resource res = unpackIcon(buffer, 0, dataSize);
 537              if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 538              if (DEBUG_PAYLOAD) Log.d(TAG, &quot;read &quot; +
 539                      Base64.encodeToString(res.data, 0, res.data.length,
 540                              Base64.NO_WRAP));








 541              Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 542              if (icon == null) {
 543                  Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 544              }
 545  
 546              if (!mRestoreEnabled) {
 547                  if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);



 548                  return;
 549              } else {
 550                  // future site of icon cache mutation
 551              }
 552          } catch (InvalidProtocolBufferNanoException e) {
 553              Log.e(TAG, &quot;failed to decode icon&quot;, e);





 554          }
 555      }
 556  
 557      /**
 558       * Write all the static widget resources we need to render placeholders
 559       * for a package that is not installed.
 560       *
 561       * @param in notes from last backup
 562       * @param data output stream for key/value pairs
 563       * @param out notes about this backup
 564       * @param keys keys to mark as clean in the notes for next backup
 565       * @throws IOException
 566       */
 567      private void backupWidgets(Journal in, BackupDataOutput data, Journal out,
 568              ArrayList&lt;Key&gt; keys) throws IOException {
 569          // persist static widget info that hasn&#x27;t been persisted yet
 570          final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 571          if (appState == null) {
 572              dataChanged(); // try again later
 573              if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying widget backup&quot;);


 574              return;
 575          }
 576          final ContentResolver cr = mContext.getContentResolver();
 577          final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 578          final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
 579          final IconCache iconCache = appState.getIconCache();
 580          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 581          final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 582          if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 583  
 584          // read the old ID set
 585          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.WIDGET, in);
 586          if (DEBUG) Log.d(TAG, &quot;widgets savedIds.size()=&quot; + savedIds.size());
 587  
 588          int startRows = out.rows;
 589          if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 590          String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET;
 591          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 592                  where, null, null);
 593          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 594          try {
 595              cursor.moveToPosition(-1);
 596              while(cursor.moveToNext()) {
 597                  final long id = cursor.getLong(ID_INDEX);
 598                  final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 599                  final int spanX = cursor.getInt(SPANX_INDEX);
 600                  final int spanY = cursor.getInt(SPANY_INDEX);
 601                  final ComponentName provider = ComponentName.unflattenFromString(providerName);
 602                  Key key = null;
 603                  String backupKey = null;
 604                  if (provider != null) {
 605                      key = getKey(Key.WIDGET, providerName);
 606                      backupKey = keyToBackupKey(key);
 607                      currentIds.add(backupKey);
 608                  } else {
 609                      Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 610                  }
 611                  if (savedIds.contains(backupKey)) {
 612                      if (VERBOSE) Log.v(TAG, &quot;already saved widget &quot; + backupKey);
 613  
 614                      // remember that we already backed this up previously
 615                      keys.add(key);
 616                  } else if (backupKey != null) {
 617                      if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 618                      if ((out.rows - startRows) &lt; MAX_WIDGETS_PER_PASS) {
 619                          if (VERBOSE) Log.v(TAG, &quot;saving widget &quot; + backupKey);
 620                          previewLoader.setPreviewSize(spanX * profile.cellWidthPx,
 621                                  spanY * profile.cellHeightPx, widgetSpacingLayout);
 622                          byte[] blob = packWidget(dpi, previewLoader, iconCache, provider);

 623                          keys.add(key);
 624                          writeRowToBackup(key, blob, out, data);
 625  
 626                      } else {
 627                          if (VERBOSE) Log.d(TAG, &quot;deferring widget backup &quot; + backupKey);
 628                          // too many widgets for this pass, request another.
 629                          dataChanged();
 630                      }
 631                  }
 632              }
 633          } finally {
 634              cursor.close();
 635          }
 636          if (DEBUG) Log.d(TAG, &quot;widget currentIds.size()=&quot; + currentIds.size());
 637  
 638          // these IDs must have been deleted
 639          savedIds.removeAll(currentIds);
 640          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 641      }
 642  
 643      /**
 644       * Read a widget from the stream.
 645       *
 646       * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 647       *
 648       * @param key identifier for the row
 649       * @param buffer the serialized proto from the stream, may be larger than dataSize
 650       * @param dataSize the size of the proto from the stream
 651       * @param keys keys to mark as clean in the notes for next backup
 652       */
 653      private void restoreWidget(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 654          if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 655          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 656                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 657          try {
 658              Widget widget = unpackWidget(buffer, 0, dataSize);
 659              if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 660              if (widget.icon.data != null)  {
 661                  Bitmap icon = BitmapFactory
 662                          .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 663                  if (icon == null) {
 664                      Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 665                  }
 666              }
 667  
 668              if (!mRestoreEnabled) {
 669                  if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 670                  return;
 671              } else {
 672                  // future site of widget table mutation
 673              }
 674          } catch (InvalidProtocolBufferNanoException e) {
 675              Log.e(TAG, &quot;failed to decode widget&quot;, e);
 676          }
 677      }
 678  
 679      /** create a new key, with an integer ID.
 680       *
 681       * &lt;P&gt; Keys contain their own checksum instead of using
 682       * the heavy-weight CheckedMessage wrapper.
 683       */
 684      private Key getKey(int type, long id) {
 685          Key key = new Key();
 686          key.type = type;
 687          key.id = id;
 688          key.checksum = checkKey(key);
 689          return key;
 690      }
 691  
 692      /** create a new key for a named object.
 693       *
 694       * &lt;P&gt; Keys contain their own checksum instead of using
 695       * the heavy-weight CheckedMessage wrapper.
 696       */
 697      private Key getKey(int type, String name) {
 698          Key key = new Key();
 699          key.type = type;
 700          key.name = name;
 701          key.checksum = checkKey(key);
 702          return key;
 703      }
 704  
 705      /** keys need to be strings, serialize and encode. */
 706      private String keyToBackupKey(Key key) {
 707          return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 708      }
 709  
 710      /** keys need to be strings, decode and parse. */
 711      private Key backupKeyToKey(String backupKey) throws KeyParsingException {
 712          try {
 713              Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 714              if (key.checksum != checkKey(key)) {
 715                  key = null;
 716                  throw new KeyParsingException(&quot;invalid key read from stream&quot; + backupKey);
 717              }
 718              return key;
 719          } catch (InvalidProtocolBufferNanoException e) {
 720              throw new KeyParsingException(e);
 721          } catch (IllegalArgumentException e) {
 722              throw new KeyParsingException(e);
 723          }
 724      }
 725  
 726      private String getKeyName(Key key) {
 727          if (TextUtils.isEmpty(key.name)) {
 728              return Long.toString(key.id);
 729          } else {
 730              return key.name;
 731          }
 732  
 733      }
 734  
 735      private String geKeyType(Key key) {
 736          switch (key.type) {
 737              case Key.FAVORITE:
 738                  return &quot;favorite&quot;;
 739              case Key.SCREEN:
 740                  return &quot;screen&quot;;
 741              case Key.ICON:
 742                  return &quot;icon&quot;;
 743              case Key.WIDGET:
 744                  return &quot;widget&quot;;
 745              default:
 746                  return &quot;anonymous&quot;;
 747          }
 748      }
 749  
 750      /** Compute the checksum over the important bits of a key. */
 751      private long checkKey(Key key) {
 752          CRC32 checksum = new CRC32();
 753          checksum.update(key.type);
 754          checksum.update((int) (key.id &amp; 0xffff));
 755          checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 756          if (!TextUtils.isEmpty(key.name)) {
 757              checksum.update(key.name.getBytes());
 758          }
 759          return checksum.getValue();
 760      }
 761  
 762      /** Serialize a Favorite for persistence, including a checksum wrapper. */
 763      private byte[] packFavorite(Cursor c) {
 764          Favorite favorite = new Favorite();
 765          favorite.id = c.getLong(ID_INDEX);
 766          favorite.screen = c.getInt(SCREEN_INDEX);
 767          favorite.container = c.getInt(CONTAINER_INDEX);
 768          favorite.cellX = c.getInt(CELLX_INDEX);
 769          favorite.cellY = c.getInt(CELLY_INDEX);
 770          favorite.spanX = c.getInt(SPANX_INDEX);
 771          favorite.spanY = c.getInt(SPANY_INDEX);
 772          favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 773          if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 774              String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 775              if (!TextUtils.isEmpty(iconPackage)) {
 776                  favorite.iconPackage = iconPackage;
 777              }
 778              String iconResource = c.getString(ICON_RESOURCE_INDEX);
 779              if (!TextUtils.isEmpty(iconResource)) {
 780                  favorite.iconResource = iconResource;
 781              }
 782          }
 783          if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 784              byte[] blob = c.getBlob(ICON_INDEX);
 785              if (blob != null &amp;&amp; blob.length &gt; 0) {
 786                  favorite.icon = blob;
 787              }
 788          }
 789          String title = c.getString(TITLE_INDEX);
 790          if (!TextUtils.isEmpty(title)) {
 791              favorite.title = title;
 792          }
 793          String intent = c.getString(INTENT_INDEX);
 794          if (!TextUtils.isEmpty(intent)) {
 795              favorite.intent = intent;
 796          }
 797          favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 798          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 799              favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 800              String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 801              if (!TextUtils.isEmpty(appWidgetProvider)) {
 802                  favorite.appWidgetProvider = appWidgetProvider;
 803              }
 804          }
 805  
 806          return writeCheckedBytes(favorite);
 807      }
 808  
 809      /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 810      private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize)
 811              throws InvalidProtocolBufferNanoException {
 812          Favorite favorite = new Favorite();
 813          MessageNano.mergeFrom(favorite, readCheckedBytes(buffer, offset, dataSize));
 814          if (VERBOSE) Log.v(TAG, &quot;unpacked favorite &quot; + favorite.itemType + &quot;, &quot; +
 815                  (TextUtils.isEmpty(favorite.title) ? favorite.id : favorite.title));
 816          ContentValues values = new ContentValues();
 817          values.put(Favorites._ID, favorite.id);
 818          values.put(Favorites.SCREEN, favorite.screen);
 819          values.put(Favorites.CONTAINER, favorite.container);
 820          values.put(Favorites.CELLX, favorite.cellX);
 821          values.put(Favorites.CELLY, favorite.cellY);
 822          values.put(Favorites.SPANX, favorite.spanX);
 823          values.put(Favorites.SPANY, favorite.spanY);
 824          values.put(Favorites.ICON_TYPE, favorite.iconType);
 825          if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 826              values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 827              values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 828          }
 829          if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 830              values.put(Favorites.ICON, favorite.icon);
 831          }
 832          if (!TextUtils.isEmpty(favorite.title)) {
 833              values.put(Favorites.TITLE, favorite.title);
 834          } else {
 835              values.put(Favorites.TITLE, &quot;&quot;);
 836          }
 837          if (!TextUtils.isEmpty(favorite.intent)) {
 838              values.put(Favorites.INTENT, favorite.intent);
 839          }
 840          values.put(Favorites.ITEM_TYPE, favorite.itemType);
 841          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 842              if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 843                  values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 844              }
 845              values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 846          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 847 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 848 +        // Let LauncherModel know we&#x27;ve been here.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 849 +        values.put(LauncherSettings.Favorites.RESTORED, 1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 850 +</span>
 851          return values;
 852      }
 853  
 854      /** Serialize a Screen for persistence, including a checksum wrapper. */
 855      private byte[] packScreen(Cursor c) {
 856          Screen screen = new Screen();
 857          screen.id = c.getLong(ID_INDEX);
 858          screen.rank = c.getInt(SCREEN_RANK_INDEX);
 859  
 860          return writeCheckedBytes(screen);
 861      }
 862  
 863      /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 864      private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize)
 865              throws InvalidProtocolBufferNanoException {
 866          Screen screen = new Screen();
 867          MessageNano.mergeFrom(screen, readCheckedBytes(buffer, offset, dataSize));
 868          if (VERBOSE) Log.v(TAG, &quot;unpacked screen &quot; + screen.id + &quot;/&quot; + screen.rank);
 869          ContentValues values = new ContentValues();
 870          values.put(WorkspaceScreens._ID, screen.id);
 871          values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 872          return values;
 873      }
 874  
 875      /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 876      private byte[] packIcon(int dpi, Bitmap icon) {
 877          Resource res = new Resource();
 878          res.dpi = dpi;
 879          ByteArrayOutputStream os = new ByteArrayOutputStream();
 880          if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 881              res.data = os.toByteArray();
 882          }
 883          return writeCheckedBytes(res);
 884      }
 885  
 886      /** Deserialize an icon resource from persistence, after verifying checksum wrapper. */
 887      private Resource unpackIcon(byte[] buffer, int offset, int dataSize)

 888              throws InvalidProtocolBufferNanoException {
 889          Resource res = new Resource();
 890          MessageNano.mergeFrom(res, readCheckedBytes(buffer, offset, dataSize));
 891          if (VERBOSE) Log.v(TAG, &quot;unpacked icon &quot; + res.dpi + &quot;/&quot; + res.data.length);
 892          return res;
 893      }
 894  
 895      /** Serialize a widget for persistence, including a checksum wrapper. */
 896      private byte[] packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 897              ComponentName provider) {
 898          final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);
 899          Widget widget = new Widget();
 900          widget.provider = provider.flattenToShortString();
 901          widget.label = info.label;
 902          widget.configure = info.configure != null;
 903          if (info.icon != 0) {
 904              widget.icon = new Resource();
 905              Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
 906              Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 907              ByteArrayOutputStream os = new ByteArrayOutputStream();
 908              if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 909                  widget.icon.data = os.toByteArray();
 910                  widget.icon.dpi = dpi;
 911              }
 912          }
 913          if (info.previewImage != 0) {
 914              widget.preview = new Resource();
 915              Bitmap preview = previewLoader.generateWidgetPreview(info, null);
 916              ByteArrayOutputStream os = new ByteArrayOutputStream();
 917              if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 918                  widget.preview.data = os.toByteArray();
 919                  widget.preview.dpi = dpi;
 920              }
 921          }
 922          return writeCheckedBytes(widget);
 923      }
 924  
 925      /** Deserialize a widget from persistence, after verifying checksum wrapper. */
 926      private Widget unpackWidget(byte[] buffer, int offset, int dataSize)
 927              throws InvalidProtocolBufferNanoException {
 928          Widget widget = new Widget();
 929          MessageNano.mergeFrom(widget, readCheckedBytes(buffer, offset, dataSize));
 930          if (VERBOSE) Log.v(TAG, &quot;unpacked widget &quot; + widget.provider);
 931          return widget;
 932      }
 933  
 934      /**
 935       * Read the old journal from the input file.
 936       *
 937       * In the event of any error, just pretend we didn&#x27;t have a journal,
 938       * in that case, do a full backup.
 939       *
 940       * @param oldState the read-0only file descriptor pointing to the old journal
 941       * @return a Journal protocol buffer
 942       */
 943      private Journal readJournal(ParcelFileDescriptor oldState) {
 944          Journal journal = new Journal();
 945          if (oldState == null) {
 946              return journal;
 947          }
 948          FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
 949          try {
 950              int availableBytes = inStream.available();
 951              if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
 952              if (availableBytes &lt; MAX_JOURNAL_SIZE) {
 953                  byte[] buffer = new byte[availableBytes];
 954                  int bytesRead = 0;
 955                  boolean valid = false;
 956                  InvalidProtocolBufferNanoException lastProtoException = null;
 957                  while (availableBytes &gt; 0) {
 958                      try {
 959                          // OMG what are you doing? This is crazy inefficient!
 960                          // If we read a byte that is not ours, we will cause trouble: b/12491813
 961                          // However, we don&#x27;t know how many bytes to expect (oops).
 962                          // So we have to step through *slowly*, watching for the end.
 963                          int result = inStream.read(buffer, bytesRead, 1);
 964                          if (result &gt; 0) {
 965                              availableBytes -= result;
 966                              bytesRead += result;
 967                              if (DEBUG &amp;&amp; (bytesRead % 100 == 0)) {
 968                                  Log.d(TAG, &quot;read some bytes: &quot; + bytesRead);
 969                              }
 970                          } else {
 971                              Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
 972                              // stop reading and see what there is to parse
 973                              availableBytes = 0;
 974                          }
 975                      } catch (IOException e) {
 976                          buffer = null;
 977                          availableBytes = 0;
 978                      }
 979  
 980                      // check the buffer to see if we have a valid journal
 981                      try {
 982                          MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));
 983                          // if we are here, then we have read a valid, checksum-verified journal
 984                          valid = true;
 985                          availableBytes = 0;
 986                          if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
 987                      } catch (InvalidProtocolBufferNanoException e) {
 988                          // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
 989                          lastProtoException = e;
 990                          journal.clear();
 991                      }
 992                  }
 993                  if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
 994                  if (!valid) {
 995                      Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
 996                  }
 997              }
 998          } catch (IOException e) {
 999              Log.w(TAG, &quot;failed to close the journal&quot;, e);
1000          } finally {
1001              try {
1002                  inStream.close();
1003              } catch (IOException e) {
1004                  Log.w(TAG, &quot;failed to close the journal&quot;, e);
1005              }
1006          }
1007          return journal;
1008      }
1009  
1010      private void writeRowToBackup(Key key, byte[] blob, Journal out,
1011              BackupDataOutput data) throws IOException {
1012          String backupKey = keyToBackupKey(key);
1013          data.writeEntityHeader(backupKey, blob.length);
1014          data.writeEntityData(blob, blob.length);
1015          out.rows++;
1016          out.bytes += blob.length;
1017          if (VERBOSE) Log.v(TAG, &quot;saving &quot; + geKeyType(key) + &quot; &quot; + backupKey + &quot;: &quot; +
1018                  getKeyName(key) + &quot;/&quot; + blob.length);
1019          if(DEBUG_PAYLOAD) {
1020              String encoded = Base64.encodeToString(blob, 0, blob.length, Base64.NO_WRAP);
1021              final int chunkSize = 1024;
1022              for (int offset = 0; offset &lt; encoded.length(); offset += chunkSize) {
1023                  int end = offset + chunkSize;
1024                  end = Math.min(end, encoded.length());
1025                  Log.w(TAG, &quot;wrote &quot; + encoded.substring(offset, end));
1026              }
1027          }
1028      }
1029  
1030      private Set&lt;String&gt; getSavedIdsByType(int type, Journal in) {
1031          Set&lt;String&gt; savedIds = new HashSet&lt;String&gt;();
1032          for(int i = 0; i &lt; in.key.length; i++) {
1033              Key key = in.key[i];
1034              if (key.type == type) {
1035                  savedIds.add(keyToBackupKey(key));
1036              }
1037          }
1038          return savedIds;
1039      }
1040  
1041      private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data)
1042              throws IOException {
1043          int rows = 0;
1044          for(String deleted: deletedIds) {
1045              if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
1046              data.writeEntityHeader(deleted, -1);
1047              rows++;
1048          }
1049          return rows;
1050      }
1051  
1052      /**
1053       * Write the new journal to the output file.
1054       *
1055       * In the event of any error, just pretend we didn&#x27;t have a journal,
1056       * in that case, do a full backup.
1057  
1058       * @param newState the write-only file descriptor pointing to the new journal
1059       * @param journal a Journal protocol buffer
1060       */
1061      private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1062          FileOutputStream outStream = null;
1063          try {
1064              outStream = new FileOutputStream(newState.getFileDescriptor());
1065              final byte[] journalBytes = writeCheckedBytes(journal);
1066              outStream.write(journalBytes);
1067              outStream.close();
1068              if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1069          } catch (IOException e) {
1070              Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1071          }
1072      }
1073  
1074      /** Wrap a proto in a CheckedMessage and compute the checksum. */
1075      private byte[] writeCheckedBytes(MessageNano proto) {
1076          CheckedMessage wrapper = new CheckedMessage();
1077          wrapper.payload = MessageNano.toByteArray(proto);
1078          CRC32 checksum = new CRC32();
1079          checksum.update(wrapper.payload);
1080          wrapper.checksum = checksum.getValue();
1081          return MessageNano.toByteArray(wrapper);
1082      }
1083  
1084      /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1085      private byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize)

1086              throws InvalidProtocolBufferNanoException {
1087          CheckedMessage wrapper = new CheckedMessage();
1088          MessageNano.mergeFrom(wrapper, buffer, offset, dataSize);
1089          CRC32 checksum = new CRC32();
1090          checksum.update(wrapper.payload);
1091          if (wrapper.checksum != checksum.getValue()) {
1092              throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1093          }
1094          return wrapper.payload;
1095      }
1096  
1097      private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {
1098          if (mWidgetMap == null) {
1099              List&lt;AppWidgetProviderInfo&gt; widgets =
1100                      AppWidgetManager.getInstance(mContext).getInstalledProviders();
1101              mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());
1102              for (AppWidgetProviderInfo info : widgets) {
1103                  mWidgetMap.put(info.provider, info);
1104              }
1105          }
1106          return mWidgetMap.get(component);
1107      }
1108  





































1109      private class KeyParsingException extends Throwable {
1110          private KeyParsingException(Throwable cause) {
1111              super(cause);
1112          }
1113  
1114          public KeyParsingException(String reason) {
1115              super(reason);
1116          }
1117      }
1118  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            