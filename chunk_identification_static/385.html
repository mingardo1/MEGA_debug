<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>385</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    385
                    <a href="384.html">prev</a>
                    <a href="386.html">next</a>
                    <a href="385_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_4e8d16e405d7ac0e0007bbc3dd9b22374f24aa3d_core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;4e8d16e405d7ac0e0007bbc3dd9b22374f24aa3d:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;4e8d16e405d7ac0e0007bbc3dd9b22374f24aa3d^1:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;4e8d16e405d7ac0e0007bbc3dd9b22374f24aa3d^2:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;c80c4d38a06965690d100b0eda63e984a558ef55:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bj]], subset: [[bj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.side;
  22 
  23 import org.apache.flink.api.common.typeinfo.TypeInformation;
  24 import org.apache.flink.api.java.tuple.Tuple2;
  25 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  26 import org.apache.flink.streaming.api.datastream.DataStream;
  27 import org.apache.flink.table.api.StreamQueryConfig;
  28 import org.apache.flink.table.api.Table;
  29 import org.apache.flink.table.api.TableSchema;
  30 import org.apache.flink.table.api.java.StreamTableEnvironment;
  31 import org.apache.flink.table.runtime.CRowKeySelector;
  32 import org.apache.flink.table.runtime.types.CRow;
  33 import org.apache.flink.table.runtime.types.CRowTypeInfo;
  34 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  35 import org.apache.flink.types.Row;
  36 
  37 import com.dtstack.flink.sql.enums.ECacheType;
  38 import com.dtstack.flink.sql.exec.FlinkSQLExec;
  39 import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  40 import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  41 import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  42 import com.dtstack.flink.sql.util.ClassUtil;
  43 import com.dtstack.flink.sql.util.ParseUtils;
  44 import com.dtstack.flink.sql.util.TableUtils;
  45 import com.google.common.base.Preconditions;
  46 import com.google.common.collect.HashBasedTable;
  47 import com.google.common.collect.Lists;
  48 import com.google.common.collect.Maps;
  49 import com.google.common.collect.Sets;
  50 import org.apache.calcite.sql.SqlBasicCall;
  51 import org.apache.calcite.sql.SqlIdentifier;
  52 import org.apache.calcite.sql.SqlKind;
  53 import org.apache.calcite.sql.SqlNode;
  54 import org.apache.calcite.sql.SqlSelect;
  55 import org.apache.calcite.sql.SqlWithItem;
  56 import org.apache.calcite.sql.parser.SqlParseException;
  57 import org.apache.commons.collections.CollectionUtils;
  58 import org.apache.commons.lang3.StringUtils;
  59 import org.slf4j.Logger;
  60 import org.slf4j.LoggerFactory;
  61 
  62 import java.sql.Timestamp;
  63 import java.util.Arrays;
  64 import java.util.LinkedList;
  65 import java.util.List;
  66 import java.util.Map;
  67 import java.util.Queue;
  68 import java.util.Set;
  69 
  70 import static org.apache.calcite.sql.SqlKind.*;
  71 
  72 /**
  73  * Reason:
  74  * Date: 2018/7/24
  75  * Company: www.dtstack.com
  76  * @author xuchao
  77  */
  78 
  79 public class SideSqlExec {
  80 
  81     private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  82 
  83     private String localSqlPluginPath = null;
  84 
  85     private String tmpFields = null;
  86 
  87     private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  88 
  89     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  90 
  91     public void exec(String sql,
  92                      Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
  93                      StreamTableEnvironment tableEnv,
  94                      Map&lt;String, Table&gt; tableCache,
  95                      StreamQueryConfig queryConfig,
  96                      CreateTmpTableParser.SqlParserResult createView) throws Exception {
  97         if(localSqlPluginPath == null){
  98             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
  99         }
 100 
 101         localTableCache.putAll(tableCache);
 102         try {
 103             sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 104         } catch (Exception e) {
 105             LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 106         }
 107 
 108         if(createView != null){
 109             LOG.warn(&quot;create view info\n&quot;);
 110             LOG.warn(createView.getExecSql());
 111             LOG.warn(&quot;-----------------&quot;);
 112         }
 113 
 114         SideSQLParser sideSQLParser = new SideSQLParser();
 115         sideSQLParser.setLocalTableCache(localTableCache);
 116         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());
 117         Object pollObj = null;
 118 
 119         while((pollObj = exeQueue.poll()) != null){
 120 
 121             if(pollObj instanceof SqlNode){
 122                 SqlNode pollSqlNode = (SqlNode) pollObj;
 123 
 124 
 125                 if(pollSqlNode.getKind() == INSERT){
 126                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);
 127                     if(LOG.isInfoEnabled()){
 128                         LOG.info(&quot;----------real exec sql-----------\n{}&quot;, pollSqlNode.toString());
 129                     }
 130 
 131                 }else if(pollSqlNode.getKind() == AS){
 132                     dealAsSourceTable(tableEnv, pollSqlNode, tableCache);
 133 
 134                 } else if (pollSqlNode.getKind() == WITH_ITEM) {
 135                     SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 136                     String TableAlias = sqlWithItem.name.toString();
 137                     Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 138                     tableEnv.registerTable(TableAlias, table);
 139 
 140                 } else if (pollSqlNode.getKind() == SELECT){
<abbr title=" 141                     Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);"> 141                     Preconditions.checkState(createView != null, &quot;select sql must included by create view🔵</abbr>
 142                     Table table = tableEnv.sqlQuery(pollObj.toString());
 143 
 144                     if (createView.getFieldsInfoStr() == null){
 145                         tableEnv.registerTable(createView.getTableName(), table);
 146                     } else {
 147                         if (checkFieldsInfo(createView, table)){
 148                             table = table.as(tmpFields);
 149                             tableEnv.registerTable(createView.getTableName(), table);
 150                         } else {
 151                             throw new RuntimeException(&quot;Fields mismatch&quot;);
 152                         }
 153                     }
 154 
 155                     localTableCache.put(createView.getTableName(), table);
 156                 }
 157 
 158             }else if (pollObj instanceof JoinInfo){
 159                 LOG.info(&quot;----------exec join info----------\n{}&quot;, pollObj.toString());
 160                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv);
 161             }
 162         }
 163 
 164     }
 165 
 166 
 167     /**
 168      * 解析出as查询的表和字段的关系
 169      * @param asSqlNode
 170      * @param tableCache
 171      * @return
 172      */
 173     private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 174         SqlNode info = asSqlNode.getOperands()[0];
 175         SqlNode alias = asSqlNode.getOperands()[1];
 176 
 177         SqlKind infoKind = info.getKind();
 178         if(infoKind != SELECT){
 179             return null;
 180         }
 181 
 182         List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 183 
 184         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 185         for (FieldInfo fieldInfo : extractFieldList) {
 186             String tableName = fieldInfo.getTable();
 187             String fieldName = fieldInfo.getFieldName();
 188             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 189             mappingTable.put(tableName, fieldName, mappingFieldName);
 190         }
 191 
 192         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 193         replaceInfo.setMappingTable(mappingTable);
 194         replaceInfo.setTargetTableName(alias.toString());
 195         replaceInfo.setTargetTableAlias(alias.toString());
 196         return replaceInfo;
 197     }
 198 
 199 
 200     public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {
 201         SqlKind sqlKind = sqlNode.getKind();
 202         if(sqlKind != AS){
 203             throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 204         }
 205 
 206         SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 207         SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 208 
 209         AliasInfo aliasInfo = new AliasInfo();
 210         aliasInfo.setName(info.toString());
 211         aliasInfo.setAlias(alias.toString());
 212 
 213         return aliasInfo;
 214     }
 215 
 216     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo,
 217                                            HashBasedTable&lt;String, String, String&gt; mappingTable) {
 218         TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 219         String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 220         for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 221             FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 222             String tableName = fieldInfo.getTable();
 223             String fieldName = fieldInfo.getFieldName();
 224 
 225             String mappingFieldName = mappingTable.get(tableName, fieldName);
<abbr title=" 226             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;);"> 226             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be f🔵</abbr>
 227 
 228             sideOutTypes[i] = fieldInfo.getTypeInformation();
 229             sideOutNames[i] = mappingFieldName;
 230         }
 231         return new RowTypeInfo(sideOutTypes, sideOutNames);
 232     }
 233 
 234 
 235 
 236     /**
 237      *  对时间类型进行类型转换
 238      * @param leftTypeInfo
 239      * @return
 240      */
 241     private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 242         TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 243         TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 244         for (int i = 0; i &lt; sideOutTypes.length; i++) {
 245             sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 246         }
 247         RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 248         return rowTypeInfo;
 249     }
 250 
 251     private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 252         if (typeInformation instanceof TimeIndicatorTypeInfo) {
 253             return TypeInformation.of(Timestamp.class);
 254         }
 255         return typeInformation;
 256     }
 257 
 258 
 259 
 260 
 261 
 262 
 263     public void setLocalSqlPluginPath(String localSqlPluginPath) {
 264         this.localSqlPluginPath = localSqlPluginPath;
 265     }
 266 
<abbr title=" 267     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){"> 267     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableNa🔵</abbr>
 268         Table table = localTableCache.get(tableAlias);
 269         if(table == null){
 270             table = localTableCache.get(tableName);
 271         }
 272 
 273         if(table == null){
 274             throw new RuntimeException(&quot;not register table &quot; + tableAlias);
 275         }
 276 
 277         return table;
 278     }
 279 
 280 
 281     /**
<abbr title=" 282      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 282      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., d🔵</abbr>
 283      *
 284      * @return
 285      */
<abbr title=" 286     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 286     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInf🔵</abbr>
 287         List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 288         if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 289             return true;
 290         }
 291         return false;
 292     }
 293 
 294     private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 295         List&lt;String&gt; res = Lists.newArrayList();
 296         sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 297             res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 298         });
 299         return res;
 300     }
 301 
<abbr title=" 302     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 302     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTa🔵</abbr>
 303         List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 304         ParseUtils.parseAnd(conditionNode, sqlNodeList);
 305         List&lt;String&gt; conditionFields = Lists.newArrayList();
 306         for(SqlNode sqlNode : sqlNodeList){
 307             if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 308                 throw new RuntimeException(&quot;not compare operator.&quot;);
 309             }
 310 
 311             SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 312             SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 313 
 314             String leftTableName = left.getComponent(0).getSimple();
 315             String rightTableName = right.getComponent(0).getSimple();
 316 
 317             String tableCol = &quot;&quot;;
 318             if(leftTableName.equalsIgnoreCase(specifyTableName)){
 319                 tableCol = left.getComponent(1).getSimple();
 320             }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 321                 tableCol = right.getComponent(1).getSimple();
 322             }else{
<abbr title=" 323                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 323                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specify🔵</abbr>
 324             }
 325             tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 326             conditionFields.add(tableCol);
 327         }
 328 
 329         return conditionFields;
 330     }
 331 
 332     protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 333                                      SqlNode pollSqlNode,
 334                                      Map&lt;String, Table&gt; tableCache) throws SqlParseException {
 335 
 336         AliasInfo aliasInfo = parseASNode(pollSqlNode);
 337         if (localTableCache.containsKey(aliasInfo.getName())) {
 338             return;
 339         }
 340 
 341         Table table = tableEnv.sqlQuery(aliasInfo.getName());
 342         tableEnv.registerTable(aliasInfo.getAlias(), table);
 343         localTableCache.put(aliasInfo.getAlias(), table);
 344 
 345         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 346 
 347         FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 348         if(fieldReplaceInfo == null){
 349            return;
 350         }
 351 
 352         //as 的源表
 353         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 354         SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];
 355         TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 356 
 357     }
 358 
 359     private void joinFun(Object pollObj,
 360                          Map&lt;String, Table&gt; localTableCache,
 361                          Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
 362                          StreamTableEnvironment tableEnv) throws Exception{
 363         JoinInfo joinInfo = (JoinInfo) pollObj;
 364 
 365         JoinScope joinScope = new JoinScope();
 366         JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 367         leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 368         leftScopeChild.setTableName(joinInfo.getLeftTableName());
 369 
<abbr title=" 370         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 370         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLe🔵</abbr>
<abbr title=" 371         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColumnNames());"> 371         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema(🔵</abbr>
 372         leftScopeChild.setRowTypeInfo(leftTypeInfo);
 373 
 374         JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 375         rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 376         rightScopeChild.setTableName(joinInfo.getRightTableName());
 377         AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 378         if(sideTableInfo == null){
 379             sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 380         }
 381 
 382         if(sideTableInfo == null){
 383             throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 384         }
 385 
 386 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 387         if(!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 388             throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 389         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 390 </span>
 391 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 392 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 393                         SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosition());"> 393                         SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getP🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 394                         sqlSelect.setSelectList(newSelectList);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 395 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 396                         //where</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 397                         if(whereNode != null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 398                             SqlNode[] sqlNodeList = ((SqlBasicCall)whereNode).getOperands();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 399                             for(int i =0; i&lt;sqlNodeList.length; i++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 400                                 SqlNode whereSqlNode = sqlNodeList[i];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 401                                 SqlNode replaceNode = replaceNodeInfo(whereSqlNode, replaceInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 402                                 sqlNodeList[i] = replaceNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 403                             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 404                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 405                         if(sqlGroup != null &amp;&amp; CollectionUtils.isNotEmpty(sqlGroup.getList())){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 406                             for( int i=0; i&lt;sqlGroup.getList().size(); i++){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 407                                 SqlNode selectNode = sqlGroup.getList().get(i);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 408                                 SqlNode replaceNode = replaceNodeInfo(selectNode, replaceInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 409                                 sqlGroup.set(i, replaceNode);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 410                             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 411                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 412                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 413                 }else{</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 414                     throw new RuntimeException(&quot;---not deal type:&quot; + sqlNode);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 415                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 416 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 417                 break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 418             case UNION:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 419                 SqlNode unionLeft = ((SqlBasicCall) sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 420                 SqlNode unionRight = ((SqlBasicCall) sqlNode).getOperands()[1];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 421                 replaceFieldName(unionLeft, replaceInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 422                 replaceFieldName(unionRight, replaceInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 423 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 424                 break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 425             case ORDER_BY:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 426                 SqlOrderBy sqlOrderBy  = (SqlOrderBy) sqlNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 427                 replaceFieldName(sqlOrderBy.query, replaceInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 428                 SqlNodeList orderFiledList = sqlOrderBy.orderList;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 429                 for (int i=0 ;i&lt;orderFiledList.size();i++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 430                     SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTableAlias());"> 430                     SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getT🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 431                     orderFiledList.set(i, replaceNode);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 432                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 433 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 434             default:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 435                 break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 436         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 437     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 438 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 439     private SqlNode replaceOrderByTableName(SqlNode orderNode, String tableAlias) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 440         if(orderNode.getKind() == IDENTIFIER){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 441             SqlIdentifier sqlIdentifier = (SqlIdentifier) orderNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 442             if (sqlIdentifier.names.size() == 1) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 443                 return orderNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 444             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 445             return sqlIdentifier.setName(0, tableAlias);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 446         } else if (orderNode instanceof  SqlBasicCall) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 447             SqlBasicCall sqlBasicCall = (SqlBasicCall) orderNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 448             for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 449                 SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 450                 sqlBasicCall.getOperands()[i] = replaceOrderByTableName(sqlNode , tableAlias);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 451             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 452             return sqlBasicCall;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 453         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 454             return orderNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 455         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 456     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 457 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 458     private SqlNode replaceNodeInfo(SqlNode groupNode, FieldReplaceInfo replaceInfo){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 459         if(groupNode.getKind() == IDENTIFIER){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 460             SqlIdentifier sqlIdentifier = (SqlIdentifier) groupNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 461             if(sqlIdentifier.names.size() == 1){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 462                 return sqlIdentifier;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 463             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 464 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 465             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 465             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSim🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 466             if(mappingFieldName == null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 467                 throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + sqlIdentifier.toString() );</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 468             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 469 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 470             sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 471             return sqlIdentifier.setName(1, mappingFieldName);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 472         }else if(groupNode instanceof  SqlBasicCall){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 473             SqlBasicCall sqlBasicCall = (SqlBasicCall) groupNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 474             for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 475                 SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 476                 SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 477                 sqlBasicCall.getOperands()[i] = replaceNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 478             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 479 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 480             return sqlBasicCall;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 481         }else{</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 482             return groupNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 483         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 484     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 485 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 486     public SqlNode filterNodeWithTargetName(SqlNode sqlNode, String targetTableName) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 487 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 488         SqlKind sqlKind = sqlNode.getKind();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 489         switch (sqlKind){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 490             case SELECT:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 491                 SqlNode fromNode = ((SqlSelect)sqlNode).getFrom();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 492                 if(fromNode.getKind() == AS &amp;&amp; ((SqlBasicCall)fromNode).getOperands()[0].getKind() == IDENTIFIER){"> 492                 if(fromNode.getKind() == AS &amp;&amp; ((SqlBasicCall)fromNode).getOperands()[0].getKind() == IDE🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 493                     if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableName)){"> 493                     if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableN🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 494                         return sqlNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 495                     }else{</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 496                         return null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 497                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 498                 }else{</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 499                     return filterNodeWithTargetName(fromNode, targetTableName);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 500                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 501             case AS:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 502                 SqlNode childNode = ((SqlBasicCall)sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 503                 return filterNodeWithTargetName(childNode, targetTableName);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 504             case JOIN:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 505                 SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 506                 SqlNode rightNode =  ((SqlJoin)sqlNode).getRight();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 507                 SqlNode leftReturnNode = filterNodeWithTargetName(leftNode, targetTableName);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 508                 SqlNode rightReturnNode = filterNodeWithTargetName(rightNode, targetTableName);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 509 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 510                 if(leftReturnNode != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 511                     return leftReturnNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 512                 }else if(rightReturnNode != null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 513                     return rightReturnNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 514                 }else{</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 515                     return null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 516                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 517             default:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 518                 break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 519         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 520 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 521         return null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 522     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 523 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 524 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 525     public void setLocalSqlPluginPath(String localSqlPluginPath) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 526         this.localSqlPluginPath = localSqlPluginPath;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 527     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 528 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 529     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){"> 529     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableNa🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 530         Table table = localTableCache.get(tableAlias);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 531         if(table == null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 532             table = localTableCache.get(tableName);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 533         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 534 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 535         if(table == null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 536             throw new RuntimeException(&quot;not register table &quot; + tableName);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 537         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 538 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 539         return table;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 540     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 541 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 542     private List&lt;SqlNode&gt; replaceSelectStarFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 543         SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 544         List&lt;SqlNode&gt; sqlNodes = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 545         if(sqlIdentifier.isStar()){//处理 [* or table.*]</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 546             int identifierSize = sqlIdentifier.names.size();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 547             Collection&lt;String&gt; columns = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 548             if(identifierSize == 1){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 549                 columns = replaceInfo.getMappingTable().values();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 550             }else{</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 551                 columns = replaceInfo.getMappingTable().row(sqlIdentifier.names.get(0)).values();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 552             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 553 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 554             for(String colAlias : columns){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 555                 SqlParserPos sqlParserPos = new SqlParserPos(0, 0);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 556                 List&lt;String&gt; columnInfo = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 557                 columnInfo.add(replaceInfo.getTargetTableAlias());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 558                 columnInfo.add(colAlias);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 559                 SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(columnInfo, sqlParserPos);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 560                 sqlNodes.add(sqlIdentifierAlias);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 561             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 562 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 563             return sqlNodes;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 564         }else{</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 565             throw new RuntimeException(&quot;is not a star select field.&quot; + selectNode);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 566         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 567     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 568 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 569     private SqlNode replaceSelectFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 570         if (selectNode.getKind() == AS) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 571             SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 572             SqlNode replaceNode = replaceSelectFieldName(leftNode, replaceInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 573             if (replaceNode != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 574                 ((SqlBasicCall) selectNode).getOperands()[0] = replaceNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 575             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 576 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 577             return selectNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 578         }else if(selectNode.getKind() == IDENTIFIER){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 579             SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 580 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 581             if(sqlIdentifier.names.size() == 1){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 582                 return selectNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 583             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 584 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 585             //Same level mappingTable</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 586             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 586             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSim🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 587             if (mappingFieldName == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 588                 throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + selectNode.toString() );</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 589             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 590 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 591             sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 592             sqlIdentifier = sqlIdentifier.setName(1, mappingFieldName);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 593             return sqlIdentifier;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 594         }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//字面含义</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 595             return selectNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 596         }else if(  AGGREGATE.contains(selectNode.getKind())</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 597                 || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 598                 || COMPARISON.contains(selectNode.getKind())</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 599                 || selectNode.getKind() == OTHER_FUNCTION</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 600                 || selectNode.getKind() == DIVIDE</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 601                 || selectNode.getKind() == CAST</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 602                 || selectNode.getKind() == TRIM</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 603                 || selectNode.getKind() == TIMES</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 604                 || selectNode.getKind() == PLUS</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 605                 || selectNode.getKind() == NOT_IN</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 606                 || selectNode.getKind() == OR</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 607                 || selectNode.getKind() == AND</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 608                 || selectNode.getKind() == MINUS</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 609                 || selectNode.getKind() == TUMBLE</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 610                 || selectNode.getKind() == TUMBLE_START</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 611                 || selectNode.getKind() == TUMBLE_END</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 612                 || selectNode.getKind() == SESSION</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 613                 || selectNode.getKind() == SESSION_START</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 614                 || selectNode.getKind() == SESSION_END</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 615                 || selectNode.getKind() == HOP</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 616                 || selectNode.getKind() == HOP_START</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 617                 || selectNode.getKind() == HOP_END</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 618                 || selectNode.getKind() == BETWEEN</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 619                 || selectNode.getKind() == IS_NULL</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 620                 || selectNode.getKind() == IS_NOT_NULL</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 621                 || selectNode.getKind() == CONTAINS</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 622                 || selectNode.getKind() == TIMESTAMP_ADD</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 623                 || selectNode.getKind() == TIMESTAMP_DIFF</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 624                 || selectNode.getKind() == LIKE</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 625 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 626                 ){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 627             SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 628             for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 629                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 630                 if(sqlNode instanceof SqlLiteral){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 631                     continue;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 632                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 633 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 634                 if(sqlNode instanceof SqlDataTypeSpec){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 635                     continue;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 636                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 637 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 638                 SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 639                 if(replaceNode == null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 640                     continue;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 641                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 642 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 643                 sqlBasicCall.getOperands()[i] = replaceNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 644             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 645 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 646             return selectNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 647         }else if(selectNode.getKind() == CASE){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 648             SqlCase sqlCase = (SqlCase) selectNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 649             SqlNodeList whenOperands = sqlCase.getWhenOperands();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 650             SqlNodeList thenOperands = sqlCase.getThenOperands();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 651             SqlNode elseNode = sqlCase.getElseOperand();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 652 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 653             for(int i=0; i&lt;whenOperands.size(); i++){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 654                 SqlNode oneOperand = whenOperands.get(i);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 655                 SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 656                 if (replaceNode != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 657                     whenOperands.set(i, replaceNode);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 658                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 659             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 660 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 661             for(int i=0; i&lt;thenOperands.size(); i++){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 662                 SqlNode oneOperand = thenOperands.get(i);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 663                 SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 664                 if (replaceNode != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 665                     thenOperands.set(i, replaceNode);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 666                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 667             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 668 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 669             ((SqlCase) selectNode).setOperand(3, replaceSelectFieldName(elseNode, replaceInfo));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 670             return selectNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 671         }else if(selectNode.getKind() == OTHER){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 672             //不处理</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 673             return selectNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 674         }else{</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 675             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 675             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, 🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 676         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 677     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 678 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 679     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 680      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 680      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., d🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 681      *</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 682      * @return</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 683      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 684     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 684     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInf🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 685         List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 686         if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 687             return true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 688         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 689         return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 690     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 691 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 692     private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 693         List&lt;String&gt; res = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 694         sideTableInfo.getPrimaryKeys().forEach(field -&gt; {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 695             res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 696         });</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 697         return res;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 698     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 699 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 700     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 700     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTa🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 701         List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 702         ParseUtils.parseAnd(conditionNode, sqlNodeList);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 703         List&lt;String&gt; conditionFields = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 704         for(SqlNode sqlNode : sqlNodeList){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 705             if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 706                 throw new RuntimeException(&quot;not compare operator.&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 707             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 708 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 709             SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 710             SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 711 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 712             String leftTableName = left.getComponent(0).getSimple();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 713             String rightTableName = right.getComponent(0).getSimple();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 714 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 715             String tableCol = &quot;&quot;;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 716             if(leftTableName.equalsIgnoreCase(specifyTableName)){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 717                 tableCol = left.getComponent(1).getSimple();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 718             }else if(rightTableName.equalsIgnoreCase(specifyTableName)){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 719                 tableCol = right.getComponent(1).getSimple();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 720             }else{</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 721                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 721                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specify🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 722             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 723             tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 724             conditionFields.add(tableCol);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 725         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 726 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 727         return conditionFields;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 728     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 729 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 730     protected void dealAsSourceTable(StreamTableEnvironment tableEnv,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 731                                      SqlNode pollSqlNode,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 732                                      Map&lt;String, Table&gt; tableCache,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 733                                      List&lt;FieldReplaceInfo&gt; replaceInfoList) throws SqlParseException {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 734 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 735         AliasInfo aliasInfo = parseAsNode(pollSqlNode);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 736         if (localTableCache.containsKey(aliasInfo.getName())) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 737             return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 738         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 739 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 740         Table table = tableEnv.sqlQuery(aliasInfo.getName());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 741         tableEnv.registerTable(aliasInfo.getAlias(), table);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 742         localTableCache.put(aliasInfo.getAlias(), table);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 743 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 744         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 745 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 746         FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 747         if(fieldReplaceInfo == null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 748            return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 749         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 750 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 751         //as 的源表</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 752         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 753         SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 754         TableUtils.getFromTableInfo(fromNode, fromTableNameSet);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 755         for(FieldReplaceInfo tmp : replaceInfoList){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 756             if(fromTableNameSet.contains(tmp.getTargetTableName())</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 757                     || fromTableNameSet.contains(tmp.getTargetTableAlias())){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 758                 fieldReplaceInfo.setPreNode(tmp);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 759                 break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 760             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 761         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 762         replaceInfoList.add(fieldReplaceInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 763     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 764 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 765     private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 766                          Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,"> 766                          Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 767                          List&lt;FieldReplaceInfo&gt; replaceInfoList) throws Exception{</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 768         JoinInfo joinInfo = (JoinInfo) pollObj;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 769 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 770         JoinScope joinScope = new JoinScope();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 771         JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 772         leftScopeChild.setAlias(joinInfo.getLeftTableAlias());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 773         leftScopeChild.setTableName(joinInfo.getLeftTableName());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 774 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 775         SqlKind sqlKind = joinInfo.getLeftNode().getKind();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 776         if(sqlKind == AS){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 777             dealAsSourceTable(tableEnv, joinInfo.getLeftNode(), localTableCache, replaceInfoList);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 778         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 779 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 780         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 780         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLe🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 781         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColumnNames());"> 781         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema(🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 782         leftScopeChild.setRowTypeInfo(leftTypeInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 783 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 784         JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 785         rightScopeChild.setAlias(joinInfo.getRightTableAlias());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 786         rightScopeChild.setTableName(joinInfo.getRightTableName());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 787         AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 788         if(sideTableInfo == null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 789             sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 790         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 791 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 792         if(sideTableInfo == null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 793             throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 794         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 795 </span>
 796 =======
 797 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 798         rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 799 
 800         joinScope.addScope(leftScopeChild);
 801         joinScope.addScope(rightScopeChild);
 802 
 803         HashBasedTable&lt;String, String, String&gt; mappingTable = ((JoinInfo) pollObj).getTableFieldRef();
 804 
 805         //获取两个表的所有字段
<abbr title=" 806         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 806         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), join🔵</abbr>
 807         //通过join的查询字段信息过滤出需要的字段信息
<abbr title=" 808         sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getFieldName()) == null);"> 808         sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo🔵</abbr>
 809 
 810         String leftTableAlias = joinInfo.getLeftTableAlias();
 811         Table targetTable = localTableCache.get(leftTableAlias);
 812         if(targetTable == null){
 813             targetTable = localTableCache.get(joinInfo.getLeftTableName());
 814         }
 815 
<abbr title=" 816         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColumnNames());"> 816         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema(🔵</abbr>
 817 
<abbr title=" 818         DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)"> 818         DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.c🔵</abbr>
 819                 .map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; {
 820                     return new CRow(tp2.f1, tp2.f0);
 821                 }).returns(CRow.class);
 822 
 823 
 824         //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 825         if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 826             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 826             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTa🔵</abbr>
 827             List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 828             int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 829             adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 829             adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, tar🔵</abbr>
 830         }
 831 
 832         DataStream&lt;CRow&gt; dsOut = null;
 833         if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title=" 834             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 834             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), 🔵</abbr>
 835         }else{
<abbr title=" 836             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 836             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSq🔵</abbr>
 837         }
 838 
 839         RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 840 
 841         CRowTypeInfo cRowTypeInfo = new CRowTypeInfo(sideOutTypeInfo);
 842         dsOut.getTransformation().setOutputType(cRowTypeInfo);
 843 
 844         String targetTableName = joinInfo.getNewTableName();
 845         String targetTableAlias = joinInfo.getNewTableAlias();
 846 
 847         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 848         replaceInfo.setMappingTable(mappingTable);
 849         replaceInfo.setTargetTableName(targetTableName);
 850         replaceInfo.setTargetTableAlias(targetTableAlias);
 851 
 852         if (!tableEnv.isRegistered(joinInfo.getNewTableName())){
 853             Table joinTable = tableEnv.fromDataStream(dsOut);
 854             tableEnv.registerTable(joinInfo.getNewTableName(), joinTable);
 855             localTableCache.put(joinInfo.getNewTableName(), joinTable);
 856         }
 857     }
 858 
 859     private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 860         String[] fieldNames = schema.getFieldNames();
 861         TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 862 
<abbr title=" 863         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);"> 863         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::ne🔵</abbr>
<abbr title=" 864         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 864         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(Typ🔵</abbr>
 865         return new RowTypeInfo(projectedTypes, projectedNames);
 866     }
 867 
 868 
 869     private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 870         List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 871         String fieldsInfo = result.getFieldsInfoStr();
 872         String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 873         for (int i = 0; i &lt; fields.length; i++) {
 874             String[] filed = fields[i].split(&quot;\\s&quot;);
 875             if (filed.length &lt; 2 || fields.length != table.getSchema().getColumnNames().length){
 876                 return false;
 877             } else {
 878                 String[] filedNameArr = new String[filed.length - 1];
 879                 System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 880                 String fieldName = String.join(&quot; &quot;, filedNameArr);
 881                 fieldNames.add(fieldName);
 882                 String fieldType = filed[filed.length - 1 ].trim();
 883                 Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 884                 Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 885                 if (fieldClass == tableField){
 886                     continue;
 887                 } else {
 888                     return false;
 889                 }
 890             }
 891         }
 892         tmpFields = String.join(&quot;,&quot;, fieldNames);
 893         return true;
 894     }
 895 
 896 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.side;
  22 
  23 import org.apache.flink.api.common.typeinfo.TypeInformation;
  24 import org.apache.flink.api.java.tuple.Tuple2;
  25 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  26 import org.apache.flink.streaming.api.datastream.DataStream;
  27 import org.apache.flink.table.api.StreamQueryConfig;
  28 import org.apache.flink.table.api.Table;
  29 import org.apache.flink.table.api.TableSchema;
  30 import org.apache.flink.table.api.java.StreamTableEnvironment;
  31 import org.apache.flink.table.runtime.CRowKeySelector;
  32 import org.apache.flink.table.runtime.types.CRow;
  33 import org.apache.flink.table.runtime.types.CRowTypeInfo;
  34 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  35 import org.apache.flink.types.Row;
  36 
  37 import com.dtstack.flink.sql.enums.ECacheType;
  38 import com.dtstack.flink.sql.exec.FlinkSQLExec;
  39 import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  40 import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  41 import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  42 import com.dtstack.flink.sql.util.ClassUtil;
  43 import com.dtstack.flink.sql.util.ParseUtils;
  44 import com.dtstack.flink.sql.util.TableUtils;
  45 import com.google.common.base.Preconditions;
  46 import com.google.common.collect.HashBasedTable;
  47 import com.google.common.collect.Lists;
  48 import com.google.common.collect.Maps;
  49 import com.google.common.collect.Sets;
  50 import org.apache.calcite.sql.SqlBasicCall;
  51 import org.apache.calcite.sql.SqlIdentifier;
  52 import org.apache.calcite.sql.SqlKind;
  53 import org.apache.calcite.sql.SqlNode;
  54 import org.apache.calcite.sql.SqlSelect;
  55 import org.apache.calcite.sql.SqlWithItem;
  56 import org.apache.calcite.sql.parser.SqlParseException;
  57 import org.apache.commons.collections.CollectionUtils;
  58 import org.apache.commons.lang3.StringUtils;
  59 import org.slf4j.Logger;
  60 import org.slf4j.LoggerFactory;
  61 
  62 import java.sql.Timestamp;
  63 import java.util.Arrays;
  64 import java.util.LinkedList;
  65 import java.util.List;
  66 import java.util.Map;
  67 import java.util.Queue;
  68 import java.util.Set;
  69 
  70 import static org.apache.calcite.sql.SqlKind.*;
  71 
  72 /**
  73  * Reason:
  74  * Date: 2018/7/24
  75  * Company: www.dtstack.com
  76  * @author xuchao
  77  */
  78 
  79 public class SideSqlExec {
  80 
  81     private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  82 
  83     private String localSqlPluginPath = null;
  84 
  85     private String tmpFields = null;
  86 
  87     private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  88 
  89     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  90 
  91     public void exec(String sql,
  92                      Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
  93                      StreamTableEnvironment tableEnv,
  94                      Map&lt;String, Table&gt; tableCache,
  95                      StreamQueryConfig queryConfig,
  96                      CreateTmpTableParser.SqlParserResult createView) throws Exception {
  97         if(localSqlPluginPath == null){
  98             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
  99         }
 100 
 101         localTableCache.putAll(tableCache);
 102         try {
 103             sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 104         } catch (Exception e) {
 105             LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 106         }
 107 
 108         if(createView != null){
 109             LOG.warn(&quot;create view info\n&quot;);
 110             LOG.warn(createView.getExecSql());
 111             LOG.warn(&quot;-----------------&quot;);
 112         }
 113 
 114         SideSQLParser sideSQLParser = new SideSQLParser();
 115         sideSQLParser.setLocalTableCache(localTableCache);
 116         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());
 117         Object pollObj = null;
 118 
 119         while((pollObj = exeQueue.poll()) != null){
 120 
 121             if(pollObj instanceof SqlNode){
 122                 SqlNode pollSqlNode = (SqlNode) pollObj;
 123 
 124 
 125                 if(pollSqlNode.getKind() == INSERT){
 126                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);
 127                     if(LOG.isInfoEnabled()){
 128                         LOG.info(&quot;----------real exec sql-----------\n{}&quot;, pollSqlNode.toString());
 129                     }
 130 
 131                 }else if(pollSqlNode.getKind() == AS){
 132                     dealAsSourceTable(tableEnv, pollSqlNode, tableCache);
 133 
 134                 } else if (pollSqlNode.getKind() == WITH_ITEM) {
 135                     SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 136                     String TableAlias = sqlWithItem.name.toString();
 137                     Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 138                     tableEnv.registerTable(TableAlias, table);
 139 
 140                 } else if (pollSqlNode.getKind() == SELECT){
<abbr title=" 141                     Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);"> 141                     Preconditions.checkState(createView != null, &quot;select sql must included by create view🔵</abbr>
 142                     Table table = tableEnv.sqlQuery(pollObj.toString());
 143 
 144                     if (createView.getFieldsInfoStr() == null){
 145                         tableEnv.registerTable(createView.getTableName(), table);
 146                     } else {
 147                         if (checkFieldsInfo(createView, table)){
 148                             table = table.as(tmpFields);
 149                             tableEnv.registerTable(createView.getTableName(), table);
 150                         } else {
 151                             throw new RuntimeException(&quot;Fields mismatch&quot;);
 152                         }
 153                     }
 154 
 155                     localTableCache.put(createView.getTableName(), table);
 156                 }
 157 
 158             }else if (pollObj instanceof JoinInfo){
 159                 LOG.info(&quot;----------exec join info----------\n{}&quot;, pollObj.toString());
 160                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv);
 161             }
 162         }
 163 
 164     }
 165 
 166 
 167     /**
 168      * 解析出as查询的表和字段的关系
 169      * @param asSqlNode
 170      * @param tableCache
 171      * @return
 172      */
 173     private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 174         SqlNode info = asSqlNode.getOperands()[0];
 175         SqlNode alias = asSqlNode.getOperands()[1];
 176 
 177         SqlKind infoKind = info.getKind();
 178         if(infoKind != SELECT){
 179             return null;
 180         }
 181 
 182         List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 183 
 184         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 185         for (FieldInfo fieldInfo : extractFieldList) {
 186             String tableName = fieldInfo.getTable();
 187             String fieldName = fieldInfo.getFieldName();
 188             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 189             mappingTable.put(tableName, fieldName, mappingFieldName);
 190         }
 191 
 192         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 193         replaceInfo.setMappingTable(mappingTable);
 194         replaceInfo.setTargetTableName(alias.toString());
 195         replaceInfo.setTargetTableAlias(alias.toString());
 196         return replaceInfo;
 197     }
 198 
 199 
 200     public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {
 201         SqlKind sqlKind = sqlNode.getKind();
 202         if(sqlKind != AS){
 203             throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 204         }
 205 
 206         SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 207         SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 208 
 209         AliasInfo aliasInfo = new AliasInfo();
 210         aliasInfo.setName(info.toString());
 211         aliasInfo.setAlias(alias.toString());
 212 
 213         return aliasInfo;
 214     }
 215 
 216     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo,
 217                                            HashBasedTable&lt;String, String, String&gt; mappingTable) {
 218         TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 219         String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 220         for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 221             FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 222             String tableName = fieldInfo.getTable();
 223             String fieldName = fieldInfo.getFieldName();
 224 
 225             String mappingFieldName = mappingTable.get(tableName, fieldName);
<abbr title=" 226             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;);"> 226             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be f🔵</abbr>
 227 
 228             sideOutTypes[i] = fieldInfo.getTypeInformation();
 229             sideOutNames[i] = mappingFieldName;
 230         }
 231         return new RowTypeInfo(sideOutTypes, sideOutNames);
 232     }
 233 
 234 
 235 
 236     /**
 237      *  对时间类型进行类型转换
 238      * @param leftTypeInfo
 239      * @return
 240      */
 241     private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 242         TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 243         TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 244         for (int i = 0; i &lt; sideOutTypes.length; i++) {
 245             sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 246         }
 247         RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 248         return rowTypeInfo;
 249     }
 250 
 251     private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 252         if (typeInformation instanceof TimeIndicatorTypeInfo) {
 253             return TypeInformation.of(Timestamp.class);
 254         }
 255         return typeInformation;
 256     }
 257 
 258 
 259 
 260 
 261 
 262 
 263     public void setLocalSqlPluginPath(String localSqlPluginPath) {
 264         this.localSqlPluginPath = localSqlPluginPath;
 265     }
 266 
<abbr title=" 267     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){"> 267     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableNa🔵</abbr>
 268         Table table = localTableCache.get(tableAlias);
 269         if(table == null){
 270             table = localTableCache.get(tableName);
 271         }
 272 
 273         if(table == null){
 274             throw new RuntimeException(&quot;not register table &quot; + tableAlias);
 275         }
 276 
 277         return table;
 278     }
 279 
 280 
 281     /**
<abbr title=" 282      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 282      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., d🔵</abbr>
 283      *
 284      * @return
 285      */
<abbr title=" 286     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 286     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInf🔵</abbr>
 287         List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 288         if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 289             return true;
 290         }
 291         return false;
 292     }
 293 
 294     private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 295         List&lt;String&gt; res = Lists.newArrayList();
 296         sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 297             res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 298         });
 299         return res;
 300     }
 301 
<abbr title=" 302     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 302     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTa🔵</abbr>
 303         List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 304         ParseUtils.parseAnd(conditionNode, sqlNodeList);
 305         List&lt;String&gt; conditionFields = Lists.newArrayList();
 306         for(SqlNode sqlNode : sqlNodeList){
 307             if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 308                 throw new RuntimeException(&quot;not compare operator.&quot;);
 309             }
 310 
 311             SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 312             SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 313 
 314             String leftTableName = left.getComponent(0).getSimple();
 315             String rightTableName = right.getComponent(0).getSimple();
 316 
 317             String tableCol = &quot;&quot;;
 318             if(leftTableName.equalsIgnoreCase(specifyTableName)){
 319                 tableCol = left.getComponent(1).getSimple();
 320             }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 321                 tableCol = right.getComponent(1).getSimple();
 322             }else{
<abbr title=" 323                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 323                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specify🔵</abbr>
 324             }
 325             tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 326             conditionFields.add(tableCol);
 327         }
 328 
 329         return conditionFields;
 330     }
 331 
 332     protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 333                                      SqlNode pollSqlNode,
 334                                      Map&lt;String, Table&gt; tableCache) throws SqlParseException {
 335 
 336         AliasInfo aliasInfo = parseASNode(pollSqlNode);
 337         if (localTableCache.containsKey(aliasInfo.getName())) {
 338             return;
 339         }
 340 
 341         Table table = tableEnv.sqlQuery(aliasInfo.getName());
 342         tableEnv.registerTable(aliasInfo.getAlias(), table);
 343         localTableCache.put(aliasInfo.getAlias(), table);
 344 
 345         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 346 
 347         FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 348         if(fieldReplaceInfo == null){
 349            return;
 350         }
 351 
 352         //as 的源表
 353         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 354         SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];
 355         TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 356 
 357     }
 358 
 359     private void joinFun(Object pollObj,
 360                          Map&lt;String, Table&gt; localTableCache,
 361                          Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
 362                          StreamTableEnvironment tableEnv) throws Exception{
 363         JoinInfo joinInfo = (JoinInfo) pollObj;
 364 
 365         JoinScope joinScope = new JoinScope();
 366         JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 367         leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 368         leftScopeChild.setTableName(joinInfo.getLeftTableName());
 369 
<abbr title=" 370         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 370         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLe🔵</abbr>
<abbr title=" 371         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColumnNames());"> 371         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema(🔵</abbr>
 372         leftScopeChild.setRowTypeInfo(leftTypeInfo);
 373 
 374         JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 375         rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 376         rightScopeChild.setTableName(joinInfo.getRightTableName());
 377         AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 378         if(sideTableInfo == null){
 379             sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 380         }
 381 
 382         if(sideTableInfo == null){
 383             throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 384         }
 385 
 386 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 387         if(!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 388             throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 389         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 390 </span>
 391 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 392         if(sideTableInfo == null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 393             throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 394         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 395 </span>
 396 =======
 397 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 398         rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 399 
 400         joinScope.addScope(leftScopeChild);
 401         joinScope.addScope(rightScopeChild);
 402 
 403         HashBasedTable&lt;String, String, String&gt; mappingTable = ((JoinInfo) pollObj).getTableFieldRef();
 404 
 405         //获取两个表的所有字段
<abbr title=" 406         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 406         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), join🔵</abbr>
 407         //通过join的查询字段信息过滤出需要的字段信息
<abbr title=" 408         sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getFieldName()) == null);"> 408         sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo🔵</abbr>
 409 
 410         String leftTableAlias = joinInfo.getLeftTableAlias();
 411         Table targetTable = localTableCache.get(leftTableAlias);
 412         if(targetTable == null){
 413             targetTable = localTableCache.get(joinInfo.getLeftTableName());
 414         }
 415 
<abbr title=" 416         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColumnNames());"> 416         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema(🔵</abbr>
 417 
<abbr title=" 418         DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)"> 418         DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.c🔵</abbr>
 419                 .map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; {
 420                     return new CRow(tp2.f1, tp2.f0);
 421                 }).returns(CRow.class);
 422 
 423 
 424         //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 425         if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 426             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 426             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTa🔵</abbr>
 427             List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 428             int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 429             adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 429             adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, tar🔵</abbr>
 430         }
 431 
 432         DataStream&lt;CRow&gt; dsOut = null;
 433         if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title=" 434             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 434             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), 🔵</abbr>
 435         }else{
<abbr title=" 436             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 436             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSq🔵</abbr>
 437         }
 438 
 439         RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 440 
 441         CRowTypeInfo cRowTypeInfo = new CRowTypeInfo(sideOutTypeInfo);
 442         dsOut.getTransformation().setOutputType(cRowTypeInfo);
 443 
 444         String targetTableName = joinInfo.getNewTableName();
 445         String targetTableAlias = joinInfo.getNewTableAlias();
 446 
 447         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 448         replaceInfo.setMappingTable(mappingTable);
 449         replaceInfo.setTargetTableName(targetTableName);
 450         replaceInfo.setTargetTableAlias(targetTableAlias);
 451 
 452         if (!tableEnv.isRegistered(joinInfo.getNewTableName())){
 453             Table joinTable = tableEnv.fromDataStream(dsOut);
 454             tableEnv.registerTable(joinInfo.getNewTableName(), joinTable);
 455             localTableCache.put(joinInfo.getNewTableName(), joinTable);
 456         }
 457     }
 458 
 459     private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 460         String[] fieldNames = schema.getFieldNames();
 461         TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 462 
<abbr title=" 463         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);"> 463         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::ne🔵</abbr>
<abbr title=" 464         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 464         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(Typ🔵</abbr>
 465         return new RowTypeInfo(projectedTypes, projectedNames);
 466     }
 467 
 468 
 469     private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 470         List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 471         String fieldsInfo = result.getFieldsInfoStr();
 472         String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 473         for (int i = 0; i &lt; fields.length; i++) {
 474             String[] filed = fields[i].split(&quot;\\s&quot;);
 475             if (filed.length &lt; 2 || fields.length != table.getSchema().getColumnNames().length){
 476                 return false;
 477             } else {
 478                 String[] filedNameArr = new String[filed.length - 1];
 479                 System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 480                 String fieldName = String.join(&quot; &quot;, filedNameArr);
 481                 fieldNames.add(fieldName);
 482                 String fieldType = filed[filed.length - 1 ].trim();
 483                 Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 484                 Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 485                 if (fieldClass == tableField){
 486                     continue;
 487                 } else {
 488                     return false;
 489                 }
 490             }
 491         }
 492         tmpFields = String.join(&quot;,&quot;, fieldNames);
 493         return true;
 494     }
 495 
 496 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side;
  19 
  20 import com.dtstack.flink.sql.enums.ECacheType;
  21 import com.dtstack.flink.sql.exec.FlinkSQLExec;
  22 import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  23 import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  24 import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  25 import com.dtstack.flink.sql.util.ClassUtil;
  26 import com.dtstack.flink.sql.util.ParseUtils;
  27 import com.dtstack.flink.sql.util.TableUtils;
  28 import com.google.common.base.Preconditions;
  29 import com.google.common.collect.HashBasedTable;
  30 import com.google.common.collect.Lists;
  31 import com.google.common.collect.Maps;
  32 import com.google.common.collect.Sets;
  33 import java.sql.Timestamp;
  34 import java.util.Arrays;
  35 import java.util.LinkedList;
  36 import java.util.List;
  37 import java.util.Map;
  38 import java.util.Queue;
  39 import java.util.Set;
  40 import org.apache.calcite.sql.SqlBasicCall;
  41 import org.apache.calcite.sql.SqlIdentifier;
  42 import org.apache.calcite.sql.SqlKind;
  43 import org.apache.calcite.sql.SqlNode;
  44 import org.apache.calcite.sql.SqlSelect;
  45 import org.apache.calcite.sql.SqlWithItem;
  46 import org.apache.calcite.sql.parser.SqlParseException;
  47 import org.apache.commons.collections.CollectionUtils;
  48 import org.apache.commons.lang3.StringUtils;
  49 import org.apache.flink.api.common.typeinfo.TypeInformation;
  50 import org.apache.flink.api.java.tuple.Tuple2;
  51 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  52 import org.apache.flink.streaming.api.datastream.DataStream;
  53 import org.apache.flink.table.api.StreamQueryConfig;
  54 import org.apache.flink.table.api.Table;
  55 import org.apache.flink.table.api.TableSchema;
  56 import org.apache.flink.table.api.java.StreamTableEnvironment;
  57 import org.apache.flink.table.runtime.CRowKeySelector;
  58 import org.apache.flink.table.runtime.types.CRow;
  59 import org.apache.flink.table.runtime.types.CRowTypeInfo;
  60 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  61 import org.apache.flink.types.Row;
  62 import org.slf4j.Logger;
  63 import org.slf4j.LoggerFactory;
  64 import static org.apache.calcite.sql.SqlKind.*;
  65 
  66 
  67 /**
  68  * Reason:
  69  * Date: 2018/7/24
  70  * Company: www.dtstack.com
  71  * @author xuchao
  72  */
  73 public class SideSqlExec {
  74     private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  75 
  76     private String localSqlPluginPath = null;
  77 
  78     private String tmpFields = null;
  79 
  80     private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  81 
  82     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  83 
<abbr title="  84     public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv, Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.SqlParserResult createView) throws Exception {">  84     public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment 🔵</abbr>
  85         if (localSqlPluginPath == null) {
  86             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
  87         }
  88         localTableCache.putAll(tableCache);
  89         try {
  90             sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
  91         } catch (java.lang.Exception e) {
  92             LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
  93         }
  94         if (createView != null) {
  95             LOG.warn(&quot;create view info\n&quot;);
  96             LOG.warn(createView.getExecSql());
  97             LOG.warn(&quot;-----------------&quot;);
  98         }
  99         SideSQLParser sideSQLParser = new SideSQLParser();
 100         sideSQLParser.setLocalTableCache(localTableCache);
 101         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());
 102         Object pollObj = null;
 103         while ((pollObj = exeQueue.poll()) != null) {
 104             if (pollObj instanceof SqlNode) {
 105                 SqlNode pollSqlNode = ((SqlNode) (pollObj));
 106                 if (pollSqlNode.getKind() == INSERT) {
 107                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);
 108                     if (LOG.isInfoEnabled()) {
 109                         LOG.info(&quot;----------real exec sql-----------\n{}&quot;, pollSqlNode.toString());
 110                     }
 111                 } else if (pollSqlNode.getKind() == AS) {
 112                     dealAsSourceTable(tableEnv, pollSqlNode, tableCache);
 113                 } else if (pollSqlNode.getKind() == WITH_ITEM) {
 114                     SqlWithItem sqlWithItem = ((SqlWithItem) (pollSqlNode));
 115                     String TableAlias = sqlWithItem.name.toString();
 116                     Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 117                     tableEnv.registerTable(TableAlias, table);
 118                 } else if (pollSqlNode.getKind() == SELECT) {
<abbr title=" 119                     Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);"> 119                     Preconditions.checkState(createView != null, &quot;select sql must included by create view🔵</abbr>
 120                     Table table = tableEnv.sqlQuery(pollObj.toString());
 121                     if (createView.getFieldsInfoStr() == null) {
 122                         tableEnv.registerTable(createView.getTableName(), table);
 123                     } else if (checkFieldsInfo(createView, table)) {
 124                         table = table.as(tmpFields);
 125                         tableEnv.registerTable(createView.getTableName(), table);
 126                     } else {
 127                         throw new RuntimeException(&quot;Fields mismatch&quot;);
 128                     }
 129                     localTableCache.put(createView.getTableName(), table);
 130                 }
 131             } else if (pollObj instanceof JoinInfo) {
 132                 LOG.info(&quot;----------exec join info----------\n{}&quot;, pollObj.toString());
 133                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv);
 134             }
 135         }
 136     }
 137 
 138     /**
 139      * 解析出as查询的表和字段的关系
 140      * @param asSqlNode
 141      * @param tableCache
 142      * @return
 143      */
 144     private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 145         SqlNode info = asSqlNode.getOperands()[0];
 146         SqlNode alias = asSqlNode.getOperands()[1];
 147 
 148         SqlKind infoKind = info.getKind();
 149         if(infoKind != SELECT){
 150             return null;
 151         }
 152 
 153         List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 154 
 155         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 156         for (FieldInfo fieldInfo : extractFieldList) {
 157             String tableName = fieldInfo.getTable();
 158             String fieldName = fieldInfo.getFieldName();
 159             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 160             mappingTable.put(tableName, fieldName, mappingFieldName);
 161         }
 162 
 163         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 164         replaceInfo.setMappingTable(mappingTable);
 165         replaceInfo.setTargetTableName(alias.toString());
 166         replaceInfo.setTargetTableAlias(alias.toString());
 167         return replaceInfo;
 168     }
 169 
 170     public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {
 171         SqlKind sqlKind = sqlNode.getKind();
 172         if (sqlKind != AS) {
 173             throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 174         }
 175         SqlNode info = ((SqlBasicCall) (sqlNode)).getOperands()[0];
 176         SqlNode alias = ((SqlBasicCall) (sqlNode)).getOperands()[1];
 177         AliasInfo aliasInfo = new AliasInfo();
 178         aliasInfo.setName(info.toString());
 179         aliasInfo.setAlias(alias.toString());
 180         return aliasInfo;
 181     }
 182 
<abbr title=" 183     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 183     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, Stri🔵</abbr>
 184         TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 185         String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 186         for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 187             FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 188             String tableName = fieldInfo.getTable();
 189             String fieldName = fieldInfo.getFieldName();
 190             String mappingFieldName = mappingTable.get(tableName, fieldName);
<abbr title=" 191             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;);"> 191             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be f🔵</abbr>
 192             sideOutTypes[i] = fieldInfo.getTypeInformation();
 193             sideOutNames[i] = mappingFieldName;
 194         }
 195         return new RowTypeInfo(sideOutTypes, sideOutNames);
 196     }
 197 
 198     /**
 199      *  对时间类型进行类型转换
 200      * @param leftTypeInfo
 201      * @return
 202      */
 203     private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 204         TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 205         TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 206         for (int i = 0; i &lt; sideOutTypes.length; i++) {
 207             sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 208         }
 209         RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 210         return rowTypeInfo;
 211     }
 212 
 213     private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 214         if (typeInformation instanceof TimeIndicatorTypeInfo) {
 215             return TypeInformation.of(Timestamp.class);
 216         }
 217         return typeInformation;
 218     }
 219 
 220     public void setLocalSqlPluginPath(String localSqlPluginPath) {
 221         this.localSqlPluginPath = localSqlPluginPath;
 222     }
 223 
<abbr title=" 224     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName) {"> 224     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableNa🔵</abbr>
 225         Table table = localTableCache.get(tableAlias);
 226         if (table == null) {
 227             table = localTableCache.get(tableName);
 228         }
 229         if (table == null) {
 230             throw new RuntimeException(&quot;not register table &quot; + tableAlias);
 231         }
 232         return table;
 233     }
 234 
 235     /**
<abbr title=" 236      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 236      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., d🔵</abbr>
 237      *
 238      * @return
 239      */
<abbr title=" 240     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 240     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInf🔵</abbr>
 241         List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 242         if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 243             return true;
 244         }
 245         return false;
 246     }
 247 
 248     private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 249         List&lt;String&gt; res = Lists.newArrayList();
 250         sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 251             res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 252         });
 253         return res;
 254     }
 255 
<abbr title=" 256     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 256     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTa🔵</abbr>
 257         List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 258         ParseUtils.parseAnd(conditionNode, sqlNodeList);
 259         List&lt;String&gt; conditionFields = Lists.newArrayList();
 260         for(SqlNode sqlNode : sqlNodeList){
 261             if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 262                 throw new RuntimeException(&quot;not compare operator.&quot;);
 263             }
 264 
 265             SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 266             SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 267 
 268             String leftTableName = left.getComponent(0).getSimple();
 269             String rightTableName = right.getComponent(0).getSimple();
 270 
 271             String tableCol = &quot;&quot;;
 272             if(leftTableName.equalsIgnoreCase(specifyTableName)){
 273                 tableCol = left.getComponent(1).getSimple();
 274             }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 275                 tableCol = right.getComponent(1).getSimple();
 276             }else{
<abbr title=" 277                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 277                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specify🔵</abbr>
 278             }
 279             tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 280             conditionFields.add(tableCol);
 281         }
 282 
 283         return conditionFields;
 284     }
 285 
<abbr title=" 286     protected void dealAsSourceTable(StreamTableEnvironment tableEnv, SqlNode pollSqlNode, Map&lt;String, Table&gt; tableCache) throws SqlParseException {"> 286     protected void dealAsSourceTable(StreamTableEnvironment tableEnv, SqlNode pollSqlNode, Map&lt;String, Ta🔵</abbr>
 287         AliasInfo aliasInfo = parseASNode(pollSqlNode);
 288         if (localTableCache.containsKey(aliasInfo.getName())) {
 289             return;
 290         }
 291         Table table = tableEnv.sqlQuery(aliasInfo.getName());
 292         tableEnv.registerTable(aliasInfo.getAlias(), table);
 293         localTableCache.put(aliasInfo.getAlias(), table);
 294         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 295         FieldReplaceInfo fieldReplaceInfo = parseAsQuery(((SqlBasicCall) (pollSqlNode)), tableCache);
 296         if (fieldReplaceInfo == null) {
 297             return;
 298         }
 299         // as 的源表
 300         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 301         SqlNode fromNode = ((SqlBasicCall) (pollSqlNode)).getOperands()[0];
 302         TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 303     }
 304 
<abbr title=" 305     private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv) throws Exception {"> 305     private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache, Map&lt;String, AbstractSideTabl🔵</abbr>
 306         JoinInfo joinInfo = ((JoinInfo) (pollObj));
 307         JoinScope joinScope = new JoinScope();
 308         JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 309         leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 310         leftScopeChild.setTableName(joinInfo.getLeftTableName());
<abbr title=" 311         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 311         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLe🔵</abbr>
<abbr title=" 312         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColumnNames());"> 312         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema(🔵</abbr>
 313         leftScopeChild.setRowTypeInfo(leftTypeInfo);
 314         JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 315         rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 316         rightScopeChild.setTableName(joinInfo.getRightTableName());
 317         AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 318         if (sideTableInfo == null) {
 319             sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 320         }
 321         if (sideTableInfo == null) {
 322             throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 323         }
 324         if (!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)) {
 325             throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);
 326         }
 327         rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 328         joinScope.addScope(leftScopeChild);
 329         joinScope.addScope(rightScopeChild);
 330         HashBasedTable&lt;String, String, String&gt; mappingTable = ((JoinInfo) (pollObj)).getTableFieldRef();
 331         // 获取两个表的所有字段
<abbr title=" 332         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 332         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), join🔵</abbr>
 333         //通过join的查询字段信息过滤出需要的字段信息
<abbr title=" 334         sideJoinFieldInfo.removeIf(( tmpFieldInfo) -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getFieldName()) == null);"> 334         sideJoinFieldInfo.removeIf(( tmpFieldInfo) -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldI🔵</abbr>
 335         String leftTableAlias = joinInfo.getLeftTableAlias();
 336         Table targetTable = localTableCache.get(leftTableAlias);
 337         if (targetTable == null) {
 338             targetTable = localTableCache.get(joinInfo.getLeftTableName());
 339         }
<abbr title=" 340         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColumnNames());"> 340         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema(🔵</abbr>
<abbr title=" 341         DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, Row.class).map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; {"> 341         DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, Row.class).map((Tuple2&lt;Boole🔵</abbr>
 342             return new CRow(tp2.f1, tp2.f0);
 343         }).returns(CRow.class);
 344         // join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 345         if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 346             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 346             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTa🔵</abbr>
 347             List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 348             int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 349             adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 349             adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, tar🔵</abbr>
 350         }
 351         DataStream&lt;CRow&gt; dsOut = null;
 352         if (ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())) {
<abbr title=" 353             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 353             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), 🔵</abbr>
 354         } else {
<abbr title=" 355             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 355             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSq🔵</abbr>
 356         }
 357         RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 358         CRowTypeInfo cRowTypeInfo = new CRowTypeInfo(sideOutTypeInfo);
 359         dsOut.getTransformation().setOutputType(cRowTypeInfo);
 360         String targetTableName = joinInfo.getNewTableName();
 361         String targetTableAlias = joinInfo.getNewTableAlias();
 362         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 363         replaceInfo.setMappingTable(mappingTable);
 364         replaceInfo.setTargetTableName(targetTableName);
 365         replaceInfo.setTargetTableAlias(targetTableAlias);
 366         if (!tableEnv.isRegistered(joinInfo.getNewTableName())) {
 367             Table joinTable = tableEnv.fromDataStream(dsOut);
 368             tableEnv.registerTable(joinInfo.getNewTableName(), joinTable);
 369             localTableCache.put(joinInfo.getNewTableName(), joinTable);
 370         }
 371     }
 372 
 373     private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 374         String[] fieldNames = schema.getFieldNames();
 375         TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 376 
<abbr title=" 377         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);"> 377         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::ne🔵</abbr>
<abbr title=" 378         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 378         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(Typ🔵</abbr>
 379         return new RowTypeInfo(projectedTypes, projectedNames);
 380     }
 381 
 382     private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 383         List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 384         String fieldsInfo = result.getFieldsInfoStr();
 385         String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 386         for (int i = 0; i &lt; fields.length; i++) {
 387             String[] filed = fields[i].split(&quot;\\s&quot;);
 388             if (filed.length &lt; 2 || fields.length != table.getSchema().getColumnNames().length){
 389                 return false;
 390             } else {
 391                 String[] filedNameArr = new String[filed.length - 1];
 392                 System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 393                 String fieldName = String.join(&quot; &quot;, filedNameArr);
 394                 fieldNames.add(fieldName);
 395                 String fieldType = filed[filed.length - 1 ].trim();
 396                 Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 397                 Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 398                 if (fieldClass == tableField){
 399                     continue;
 400                 } else {
 401                     return false;
 402                 }
 403             }
 404         }
 405         tmpFields = String.join(&quot;,&quot;, fieldNames);
 406         return true;
 407     }
 408 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.side;
  22  
  23  import org.apache.flink.api.common.typeinfo.TypeInformation;
  24  import org.apache.flink.api.java.tuple.Tuple2;
  25  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  26  import org.apache.flink.streaming.api.datastream.DataStream;
  27  import org.apache.flink.table.api.StreamQueryConfig;
  28  import org.apache.flink.table.api.Table;
  29  import org.apache.flink.table.api.TableSchema;
  30  import org.apache.flink.table.api.java.StreamTableEnvironment;
  31  import org.apache.flink.table.runtime.CRowKeySelector;
  32  import org.apache.flink.table.runtime.types.CRow;
  33  import org.apache.flink.table.runtime.types.CRowTypeInfo;
  34  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  35  import org.apache.flink.types.Row;
  36  
  37  import com.dtstack.flink.sql.enums.ECacheType;
  38  import com.dtstack.flink.sql.exec.FlinkSQLExec;
  39  import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  40  import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  41  import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  42  import com.dtstack.flink.sql.util.ClassUtil;
  43  import com.dtstack.flink.sql.util.ParseUtils;
  44  import com.dtstack.flink.sql.util.TableUtils;
  45  import com.google.common.base.Preconditions;
  46  import com.google.common.collect.HashBasedTable;
  47  import com.google.common.collect.Lists;
  48  import com.google.common.collect.Maps;
  49  import com.google.common.collect.Sets;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  50 -import org.apache.calcite.sql.SqlAsOperator;</span>
  51  import org.apache.calcite.sql.SqlBasicCall;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  52 -import org.apache.calcite.sql.SqlDataTypeSpec;</span>
  53  import org.apache.calcite.sql.SqlIdentifier;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  54 -import org.apache.calcite.sql.SqlInsert;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  55 -import org.apache.calcite.sql.SqlJoin;</span>
  56  import org.apache.calcite.sql.SqlKind;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  57 -import org.apache.calcite.sql.SqlLiteral;</span>
  58  import org.apache.calcite.sql.SqlNode;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  59 -import org.apache.calcite.sql.SqlNodeList;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  60 -import org.apache.calcite.sql.SqlOperator;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  61 -import org.apache.calcite.sql.SqlOrderBy;</span>
  62  import org.apache.calcite.sql.SqlSelect;
  63  import org.apache.calcite.sql.SqlWithItem;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  64 -import org.apache.calcite.sql.fun.SqlCase;</span>
  65  import org.apache.calcite.sql.parser.SqlParseException;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  66 -import org.apache.calcite.sql.parser.SqlParserPos;</span>
  67  import org.apache.commons.collections.CollectionUtils;
  68  import org.apache.commons.lang3.StringUtils;
  69  import org.slf4j.Logger;
  70  import org.slf4j.LoggerFactory;
  71  
  72  import java.sql.Timestamp;
  73  import java.util.Arrays;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  74 -import java.util.Collection;</span>
  75  import java.util.LinkedList;
  76  import java.util.List;
  77  import java.util.Map;
  78  import java.util.Queue;
  79  import java.util.Set;
  80  
  81  import static org.apache.calcite.sql.SqlKind.*;
  82  
  83  /**
  84   * Reason:
  85   * Date: 2018/7/24
  86   * Company: www.dtstack.com
  87   * @author xuchao
  88   */
  89  
  90  public class SideSqlExec {
  91  
  92      private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  93  
  94      private String localSqlPluginPath = null;
  95  
  96      private String tmpFields = null;
  97  
  98      private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  99  
 100      private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
 101  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 102 -    public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 103 -                     Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.SqlParserResult createView) throws Exception {"> 103 -                     Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.SqlParserR🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 104 +    public void exec(String sql,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 105 +                     Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 106 +                     StreamTableEnvironment tableEnv,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 107 +                     Map&lt;String, Table&gt; tableCache,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 108 +                     StreamQueryConfig queryConfig,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 109 +                     CreateTmpTableParser.SqlParserResult createView) throws Exception {</span>
 110          if(localSqlPluginPath == null){
 111              throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
 112          }
 113  
 114          localTableCache.putAll(tableCache);
 115          try {
 116              sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 117          } catch (Exception e) {
 118              LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 119          }
 120  
 121          if(createView != null){
 122              LOG.warn(&quot;create view info\n&quot;);
 123              LOG.warn(createView.getExecSql());
 124              LOG.warn(&quot;-----------------&quot;);
 125          }
 126  
 127          SideSQLParser sideSQLParser = new SideSQLParser();
 128          sideSQLParser.setLocalTableCache(localTableCache);
 129          Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());
 130          Object pollObj = null;
 131  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 132 -        //need clean</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 133 -        boolean preIsSideJoin = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 134 -        List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 135 -</span>
 136          while((pollObj = exeQueue.poll()) != null){
 137  
 138              if(pollObj instanceof SqlNode){
 139                  SqlNode pollSqlNode = (SqlNode) pollObj;
 140  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 141 -                if(preIsSideJoin){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 142 -                    preIsSideJoin = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 143 -                    List&lt;String&gt; fieldNames = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 144 -                    for(FieldReplaceInfo replaceInfo : replaceInfoList){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 145 -                        fieldNames = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 146 -                        replaceFieldName(pollSqlNode, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 147 -                        addAliasForFieldNode(pollSqlNode, fieldNames, replaceInfo.getMappingTable());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 148 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 149 -                }</span>
 150  
 151                  if(pollSqlNode.getKind() == INSERT){
 152                      FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);
 153                      if(LOG.isInfoEnabled()){
 154                          LOG.info(&quot;----------real exec sql-----------\n{}&quot;, pollSqlNode.toString());
 155                      }
 156  
 157                  }else if(pollSqlNode.getKind() == AS){
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 158 -                    dealAsSourceTable(tableEnv, pollSqlNode, tableCache, replaceInfoList);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 159 +                    dealAsSourceTable(tableEnv, pollSqlNode, tableCache);</span>
 160  
 161                  } else if (pollSqlNode.getKind() == WITH_ITEM) {
 162                      SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 163                      String TableAlias = sqlWithItem.name.toString();
 164                      Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 165                      tableEnv.registerTable(TableAlias, table);
 166  
 167                  } else if (pollSqlNode.getKind() == SELECT){
 168                      Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);
 169                      Table table = tableEnv.sqlQuery(pollObj.toString());
 170  
 171                      if (createView.getFieldsInfoStr() == null){
 172                          tableEnv.registerTable(createView.getTableName(), table);
 173                      } else {
 174                          if (checkFieldsInfo(createView, table)){
 175                              table = table.as(tmpFields);
 176                              tableEnv.registerTable(createView.getTableName(), table);
 177                          } else {
 178                              throw new RuntimeException(&quot;Fields mismatch&quot;);
 179                          }
 180                      }
 181  
 182                      localTableCache.put(createView.getTableName(), table);
 183                  }
 184  
 185              }else if (pollObj instanceof JoinInfo){
 186                  LOG.info(&quot;----------exec join info----------\n{}&quot;, pollObj.toString());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 187 -                preIsSideJoin = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 188 -                joinFun(pollObj, localTableCache, sideTableMap, tableEnv, replaceInfoList);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 189 +                joinFun(pollObj, localTableCache, sideTableMap, tableEnv);</span>
 190              }
 191          }
 192  
 193      }
 194  
 195  
 196      /**
 197       * 解析出as查询的表和字段的关系
 198       * @param asSqlNode
 199       * @param tableCache
 200       * @return
 201       */
 202      private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 203          SqlNode info = asSqlNode.getOperands()[0];
 204          SqlNode alias = asSqlNode.getOperands()[1];
 205  
 206          SqlKind infoKind = info.getKind();
 207          if(infoKind != SELECT){
 208              return null;
 209          }
 210  
 211          List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 212  
 213          HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 214          for (FieldInfo fieldInfo : extractFieldList) {
 215              String tableName = fieldInfo.getTable();
 216              String fieldName = fieldInfo.getFieldName();
 217              String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 218              mappingTable.put(tableName, fieldName, mappingFieldName);
 219          }
 220  
 221          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 222          replaceInfo.setMappingTable(mappingTable);
 223          replaceInfo.setTargetTableName(alias.toString());
 224          replaceInfo.setTargetTableAlias(alias.toString());
 225          return replaceInfo;
 226      }
 227  
 228  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 229 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 230 -     * 添加字段别名</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 231 -     * @param pollSqlNode</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 232 -     * @param fieldList</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 233 -     * @param mappingTable</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 234 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 235 -    private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 235 -    private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, 🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 236 -        SqlKind sqlKind = pollSqlNode.getKind();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 237 -        switch (sqlKind) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 238 -            case INSERT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 239 -                SqlNode source = ((SqlInsert) pollSqlNode).getSource();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 240 -                addAliasForFieldNode(source, fieldList, mappingTable);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 241 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 242 -            case AS:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 243 -                addAliasForFieldNode(((SqlBasicCall) pollSqlNode).getOperands()[0], fieldList, mappingTable);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 244 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 245 -            case SELECT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 246 -                SqlNodeList selectList = ((SqlSelect) pollSqlNode).getSelectList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 247 -                selectList.getList().forEach(node -&gt; {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 248 -                    if (node.getKind() == IDENTIFIER) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 249 -                        SqlIdentifier sqlIdentifier = (SqlIdentifier) node;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 250 -                        if (sqlIdentifier.names.size() == 1) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 251 -                            return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 252 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 253 -                        // save real field</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 254 -                        String fieldName = sqlIdentifier.names.get(1);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 255 -                        if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().containsKey(fieldName)) {"> 255 -                        if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().contai🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 256 -                            fieldList.add(fieldName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 257 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 258 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 259 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 260 -                });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 261 -                for (int i = 0; i &lt; selectList.getList().size(); i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 262 -                    SqlNode node = selectList.get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 263 -                    if (node.getKind() == IDENTIFIER) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 264 -                        SqlIdentifier sqlIdentifier = (SqlIdentifier) node;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 265 -                        if (sqlIdentifier.names.size() == 1) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 266 -                            return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 267 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 268 -                        String name = sqlIdentifier.names.get(1);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 269 -                        // avoid real field pv0 convert pv</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 270 -                        if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring(0, name.length() - 1))) {"> 270 -                        if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 271 -                            SqlOperator operator = new SqlAsOperator();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 272 -                            SqlParserPos sqlParserPos = new SqlParserPos(0, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 273 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 274 -                            SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() - 1), null, sqlParserPos);"> 274 -                            SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() -🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 275 -                            SqlNode[] sqlNodes = new SqlNode[2];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 276 -                            sqlNodes[0] = sqlIdentifier;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 277 -                            sqlNodes[1] = sqlIdentifierAlias;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 278 -                            SqlBasicCall sqlBasicCall = new SqlBasicCall(operator, sqlNodes, sqlParserPos);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 279 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 280 -                            selectList.set(i, sqlBasicCall);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 281 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 282 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 283 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 284 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 285 -            default:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 286 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 287 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 288 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 289 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 290 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 291 -    public AliasInfo parseAsNode(SqlNode sqlNode) throws SqlParseException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 292 +    public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {</span>
 293          SqlKind sqlKind = sqlNode.getKind();
 294          if(sqlKind != AS){
 295              throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 296          }
 297  
 298          SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 299          SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 300  
 301          AliasInfo aliasInfo = new AliasInfo();
 302          aliasInfo.setName(info.toString());
 303          aliasInfo.setAlias(alias.toString());
 304  
 305          return aliasInfo;
 306      }
 307  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 308 -    public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 308 -    public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, Strin🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 309 +    public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 310 +                                           HashBasedTable&lt;String, String, String&gt; mappingTable) {</span>
 311          TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 312          String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 313          for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 314              FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 315              String tableName = fieldInfo.getTable();
 316              String fieldName = fieldInfo.getFieldName();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 317 -            String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 318 -            mappingTable.put(tableName, fieldName, mappingFieldName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 319 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 320 +            String mappingFieldName = mappingTable.get(tableName, fieldName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 321 +            Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;);"> 321 +            Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;🔵</abbr></span>
 322  
 323              sideOutTypes[i] = fieldInfo.getTypeInformation();
 324              sideOutNames[i] = mappingFieldName;
 325          }
 326          return new RowTypeInfo(sideOutTypes, sideOutNames);
 327      }
 328  
 329  
 330  
 331      /**
 332       *  对时间类型进行类型转换
 333       * @param leftTypeInfo
 334       * @return
 335       */
 336      private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 337          TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 338          TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 339          for (int i = 0; i &lt; sideOutTypes.length; i++) {
 340              sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 341          }
 342          RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 343          return rowTypeInfo;
 344      }
 345  
 346      private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 347          if (typeInformation instanceof TimeIndicatorTypeInfo) {
 348              return TypeInformation.of(Timestamp.class);
 349          }
 350          return typeInformation;
 351      }
 352  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 353 -    //需要考虑更多的情况</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 354 -    private void replaceFieldName(SqlNode sqlNode, FieldReplaceInfo replaceInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 355 -        SqlKind sqlKind = sqlNode.getKind();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 356 -        switch (sqlKind) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 357 -            case INSERT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 358 -                SqlNode sqlSource = ((SqlInsert) sqlNode).getSource();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 359 -                replaceFieldName(sqlSource, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 360 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 361 -            case AS:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 362 -                SqlNode asNode = ((SqlBasicCall) sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 363 -                replaceFieldName(asNode, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 364 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 365 -            case SELECT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 366 -                SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTargetTableName());"> 366 -                SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTargetTableName🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 367 -                if(sqlSelect == null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 368 -                    return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 369 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 370 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 371 -                SqlNode sqlSource1 = sqlSelect.getFrom();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 372 -                if(sqlSource1.getKind() == AS){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 373 -                    String tableName = ((SqlBasicCall)sqlSource1).getOperands()[0].toString();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 374 -                    if(tableName.equalsIgnoreCase(replaceInfo.getTargetTableName())){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 375 -                        SqlNodeList sqlSelectList = sqlSelect.getSelectList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 376 -                        SqlNode whereNode = sqlSelect.getWhere();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 377 -                        SqlNodeList sqlGroup = sqlSelect.getGroup();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 378 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 379 -                        //TODO 暂时不处理having</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 380 -                        SqlNode sqlHaving = sqlSelect.getHaving();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 381 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 382 -                        List&lt;SqlNode&gt; newSelectNodeList = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 383 -                        for( int i=0; i&lt;sqlSelectList.getList().size(); i++){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 384 -                            SqlNode selectNode = sqlSelectList.getList().get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 385 -                            //特殊处理 isStar的标识</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 386 -                            if(selectNode.getKind() == IDENTIFIER &amp;&amp; ((SqlIdentifier) selectNode).isStar()){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 387 -                                List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, replaceInfo);"> 387 -                                List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, replaceInfo🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 388 -                                newSelectNodeList.addAll(replaceNodeList);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 389 -                                continue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 390 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 391 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 392 -                            SqlNode replaceNode = replaceSelectFieldName(selectNode, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 393 -                            if(replaceNode == null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 394 -                                continue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 395 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 396 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 397 -                            //sqlSelectList.set(i, replaceNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 398 -                            newSelectNodeList.add(replaceNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 399 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 400 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 401 -                        SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosition());"> 401 -                        SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosi🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 402 -                        sqlSelect.setSelectList(newSelectList);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 403 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 404 -                        //where</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 405 -                        if(whereNode != null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 406 -                            SqlNode[] sqlNodeList = ((SqlBasicCall)whereNode).getOperands();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 407 -                            for(int i =0; i&lt;sqlNodeList.length; i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 408 -                                SqlNode whereSqlNode = sqlNodeList[i];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 409 -                                SqlNode replaceNode = replaceNodeInfo(whereSqlNode, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 410 -                                sqlNodeList[i] = replaceNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 411 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 412 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 413 -                        if(sqlGroup != null &amp;&amp; CollectionUtils.isNotEmpty(sqlGroup.getList())){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 414 -                            for( int i=0; i&lt;sqlGroup.getList().size(); i++){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 415 -                                SqlNode selectNode = sqlGroup.getList().get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 416 -                                SqlNode replaceNode = replaceNodeInfo(selectNode, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 417 -                                sqlGroup.set(i, replaceNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 418 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 419 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 420 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 421 -                }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 422 -                    throw new RuntimeException(&quot;---not deal type:&quot; + sqlNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 423 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 424 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 425 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 426 -            case UNION:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 427 -                SqlNode unionLeft = ((SqlBasicCall) sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 428 -                SqlNode unionRight = ((SqlBasicCall) sqlNode).getOperands()[1];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 429 -                replaceFieldName(unionLeft, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 430 -                replaceFieldName(unionRight, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 431 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 432 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 433 -            case ORDER_BY:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 434 -                SqlOrderBy sqlOrderBy  = (SqlOrderBy) sqlNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 435 -                replaceFieldName(sqlOrderBy.query, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 436 -                SqlNodeList orderFiledList = sqlOrderBy.orderList;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 437 -                for (int i=0 ;i&lt;orderFiledList.size();i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 438 -                    SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTableAlias());"> 438 -                    SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTabl🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 439 -                    orderFiledList.set(i, replaceNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 440 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 441 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 442 -            default:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 443 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 444 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 445 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 446 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 447 -    private SqlNode replaceOrderByTableName(SqlNode orderNode, String tableAlias) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 448 -        if(orderNode.getKind() == IDENTIFIER){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 449 -            SqlIdentifier sqlIdentifier = (SqlIdentifier) orderNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 450 -            if (sqlIdentifier.names.size() == 1) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 451 -                return orderNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 452 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 453 -            return sqlIdentifier.setName(0, tableAlias);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 454 -        } else if (orderNode instanceof  SqlBasicCall) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 455 -            SqlBasicCall sqlBasicCall = (SqlBasicCall) orderNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 456 -            for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 457 -                SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 458 -                sqlBasicCall.getOperands()[i] = replaceOrderByTableName(sqlNode , tableAlias);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 459 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 460 -            return sqlBasicCall;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 461 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 462 -            return orderNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 463 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 464 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 465 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 466 -    private SqlNode replaceNodeInfo(SqlNode groupNode, FieldReplaceInfo replaceInfo){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 467 -        if(groupNode.getKind() == IDENTIFIER){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 468 -            SqlIdentifier sqlIdentifier = (SqlIdentifier) groupNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 469 -            if(sqlIdentifier.names.size() == 1){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 470 -                return sqlIdentifier;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 471 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 472 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 473 -            String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 473 -            String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sq🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 474 -            if(mappingFieldName == null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 475 -                throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + sqlIdentifier.toString() );</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 476 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 477 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 478 -            sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 479 -            return sqlIdentifier.setName(1, mappingFieldName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 480 -        }else if(groupNode instanceof  SqlBasicCall){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 481 -            SqlBasicCall sqlBasicCall = (SqlBasicCall) groupNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 482 -            for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 483 -                SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 484 -                SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 485 -                sqlBasicCall.getOperands()[i] = replaceNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 486 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 487 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 488 -            return sqlBasicCall;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 489 -        }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 490 -            return groupNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 491 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 492 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 493 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 494 -    public SqlNode filterNodeWithTargetName(SqlNode sqlNode, String targetTableName) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 495 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 496 -        SqlKind sqlKind = sqlNode.getKind();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 497 -        switch (sqlKind){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 498 -            case SELECT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 499 -                SqlNode fromNode = ((SqlSelect)sqlNode).getFrom();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 500 -                if(fromNode.getKind() == AS &amp;&amp; ((SqlBasicCall)fromNode).getOperands()[0].getKind() == IDENTIFIER){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 501 -                    if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableName)){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 502 -                        return sqlNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 503 -                    }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 504 -                        return null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 505 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 506 -                }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 507 -                    return filterNodeWithTargetName(fromNode, targetTableName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 508 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 509 -            case AS:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 510 -                SqlNode childNode = ((SqlBasicCall)sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 511 -                return filterNodeWithTargetName(childNode, targetTableName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 512 -            case JOIN:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 513 -                SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 514 -                SqlNode rightNode =  ((SqlJoin)sqlNode).getRight();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 515 -                SqlNode leftReturnNode = filterNodeWithTargetName(leftNode, targetTableName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 516 -                SqlNode rightReturnNode = filterNodeWithTargetName(rightNode, targetTableName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 517 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 518 -                if(leftReturnNode != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 519 -                    return leftReturnNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 520 -                }else if(rightReturnNode != null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 521 -                    return rightReturnNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 522 -                }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 523 -                    return null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 524 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 525 -            default:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 526 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 527 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 528 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 529 -        return null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 530 -    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 531 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 532 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 533 +</span>
 534  
 535  
 536      public void setLocalSqlPluginPath(String localSqlPluginPath) {
 537          this.localSqlPluginPath = localSqlPluginPath;
 538      }
 539  
 540      private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){
 541          Table table = localTableCache.get(tableAlias);
 542          if(table == null){
 543              table = localTableCache.get(tableName);
 544          }
 545  
 546          if(table == null){
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 547 -            throw new RuntimeException(&quot;not register table &quot; + tableName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 548 +            throw new RuntimeException(&quot;not register table &quot; + tableAlias);</span>
 549          }
 550  
 551          return table;
 552      }
 553  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 554 -    private List&lt;SqlNode&gt; replaceSelectStarFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 555 -        SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 556 -        List&lt;SqlNode&gt; sqlNodes = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 557 -        if(sqlIdentifier.isStar()){//处理 [* or table.*]</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 558 -            int identifierSize = sqlIdentifier.names.size();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 559 -            Collection&lt;String&gt; columns = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 560 -            if(identifierSize == 1){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 561 -                columns = replaceInfo.getMappingTable().values();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 562 -            }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 563 -                columns = replaceInfo.getMappingTable().row(sqlIdentifier.names.get(0)).values();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 564 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 565 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 566 -            for(String colAlias : columns){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 567 -                SqlParserPos sqlParserPos = new SqlParserPos(0, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 568 -                List&lt;String&gt; columnInfo = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 569 -                columnInfo.add(replaceInfo.getTargetTableAlias());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 570 -                columnInfo.add(colAlias);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 571 -                SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(columnInfo, sqlParserPos);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 572 -                sqlNodes.add(sqlIdentifierAlias);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 573 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 574 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 575 -            return sqlNodes;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 576 -        }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 577 -            throw new RuntimeException(&quot;is not a star select field.&quot; + selectNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 578 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 579 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 580 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 581 -    private SqlNode replaceSelectFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 582 -        if (selectNode.getKind() == AS) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 583 -            SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 584 -            SqlNode replaceNode = replaceSelectFieldName(leftNode, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 585 -            if (replaceNode != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 586 -                ((SqlBasicCall) selectNode).getOperands()[0] = replaceNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 587 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 588 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 589 -            return selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 590 -        }else if(selectNode.getKind() == IDENTIFIER){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 591 -            SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 592 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 593 -            if(sqlIdentifier.names.size() == 1){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 594 -                return selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 595 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 596 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 597 -            //Same level mappingTable</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 598 -            String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 598 -            String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sq🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 599 -            if (mappingFieldName == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 600 -                throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + selectNode.toString() );</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 601 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 602 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 603 -            sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 604 -            sqlIdentifier = sqlIdentifier.setName(1, mappingFieldName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 605 -            return sqlIdentifier;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 606 -        }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//字面含义</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 607 -            return selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 608 -        }else if(  AGGREGATE.contains(selectNode.getKind())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 609 -                || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 610 -                || COMPARISON.contains(selectNode.getKind())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 611 -                || selectNode.getKind() == OTHER_FUNCTION</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 612 -                || selectNode.getKind() == DIVIDE</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 613 -                || selectNode.getKind() == CAST</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 614 -                || selectNode.getKind() == TRIM</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 615 -                || selectNode.getKind() == TIMES</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 616 -                || selectNode.getKind() == PLUS</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 617 -                || selectNode.getKind() == NOT_IN</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 618 -                || selectNode.getKind() == OR</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 619 -                || selectNode.getKind() == AND</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 620 -                || selectNode.getKind() == MINUS</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 621 -                || selectNode.getKind() == TUMBLE</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 622 -                || selectNode.getKind() == TUMBLE_START</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 623 -                || selectNode.getKind() == TUMBLE_END</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 624 -                || selectNode.getKind() == SESSION</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 625 -                || selectNode.getKind() == SESSION_START</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 626 -                || selectNode.getKind() == SESSION_END</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 627 -                || selectNode.getKind() == HOP</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 628 -                || selectNode.getKind() == HOP_START</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 629 -                || selectNode.getKind() == HOP_END</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 630 -                || selectNode.getKind() == BETWEEN</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 631 -                || selectNode.getKind() == IS_NULL</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 632 -                || selectNode.getKind() == IS_NOT_NULL</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 633 -                || selectNode.getKind() == CONTAINS</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 634 -                || selectNode.getKind() == TIMESTAMP_ADD</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 635 -                || selectNode.getKind() == TIMESTAMP_DIFF</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 636 -                || selectNode.getKind() == LIKE</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 637 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 638 -                ){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 639 -            SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 640 -            for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 641 -                SqlNode sqlNode = sqlBasicCall.getOperands()[i];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 642 -                if(sqlNode instanceof SqlLiteral){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 643 -                    continue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 644 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 645 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 646 -                if(sqlNode instanceof SqlDataTypeSpec){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 647 -                    continue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 648 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 649 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 650 -                SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 651 -                if(replaceNode == null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 652 -                    continue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 653 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 654 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 655 -                sqlBasicCall.getOperands()[i] = replaceNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 656 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 657 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 658 -            return selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 659 -        }else if(selectNode.getKind() == CASE){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 660 -            SqlCase sqlCase = (SqlCase) selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 661 -            SqlNodeList whenOperands = sqlCase.getWhenOperands();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 662 -            SqlNodeList thenOperands = sqlCase.getThenOperands();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 663 -            SqlNode elseNode = sqlCase.getElseOperand();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 664 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 665 -            for(int i=0; i&lt;whenOperands.size(); i++){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 666 -                SqlNode oneOperand = whenOperands.get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 667 -                SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 668 -                if (replaceNode != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 669 -                    whenOperands.set(i, replaceNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 670 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 671 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 672 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 673 -            for(int i=0; i&lt;thenOperands.size(); i++){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 674 -                SqlNode oneOperand = thenOperands.get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 675 -                SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 676 -                if (replaceNode != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 677 -                    thenOperands.set(i, replaceNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 678 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 679 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 680 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 681 -            ((SqlCase) selectNode).setOperand(3, replaceSelectFieldName(elseNode, replaceInfo));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 682 -            return selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 683 -        }else if(selectNode.getKind() == OTHER){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 684 -            //不处理</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 685 -            return selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 686 -        }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 687 -            throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 687 -            throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNod🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 688 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 689 -    }</span>
 690  
 691      /**
<abbr title=" 692       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 692       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension 🔵</abbr>
 693       *
 694       * @return
 695       */
<abbr title=" 696      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 696      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTab🔵</abbr>
 697          List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 698          if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 699              return true;
 700          }
 701          return false;
 702      }
 703  
 704      private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 705          List&lt;String&gt; res = Lists.newArrayList();
 706          sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 707              res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 708          });
 709          return res;
 710      }
 711  
<abbr title=" 712      public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 712      public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo s🔵</abbr>
 713          List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 714          ParseUtils.parseAnd(conditionNode, sqlNodeList);
 715          List&lt;String&gt; conditionFields = Lists.newArrayList();
 716          for(SqlNode sqlNode : sqlNodeList){
 717              if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 718                  throw new RuntimeException(&quot;not compare operator.&quot;);
 719              }
 720  
 721              SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 722              SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 723  
 724              String leftTableName = left.getComponent(0).getSimple();
 725              String rightTableName = right.getComponent(0).getSimple();
 726  
 727              String tableCol = &quot;&quot;;
 728              if(leftTableName.equalsIgnoreCase(specifyTableName)){
 729                  tableCol = left.getComponent(1).getSimple();
 730              }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 731                  tableCol = right.getComponent(1).getSimple();
 732              }else{
<abbr title=" 733                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 733                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName🔵</abbr>
 734              }
 735              tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 736              conditionFields.add(tableCol);
 737          }
 738  
 739          return conditionFields;
 740      }
 741  
 742      protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 743                                       SqlNode pollSqlNode,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 744 -                                     Map&lt;String, Table&gt; tableCache,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 745 -                                     List&lt;FieldReplaceInfo&gt; replaceInfoList) throws SqlParseException {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 746 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 747 -        AliasInfo aliasInfo = parseAsNode(pollSqlNode);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 748 +                                     Map&lt;String, Table&gt; tableCache) throws SqlParseException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 749 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 750 +        AliasInfo aliasInfo = parseASNode(pollSqlNode);</span>
 751          if (localTableCache.containsKey(aliasInfo.getName())) {
 752              return;
 753          }
 754  
 755          Table table = tableEnv.sqlQuery(aliasInfo.getName());
 756          tableEnv.registerTable(aliasInfo.getAlias(), table);
 757          localTableCache.put(aliasInfo.getAlias(), table);
 758  
 759          LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 760  
 761          FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 762          if(fieldReplaceInfo == null){
 763             return;
 764          }
 765  
 766          //as 的源表
 767          Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 768          SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];
 769          TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 770 -        for(FieldReplaceInfo tmp : replaceInfoList){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 771 -            if(fromTableNameSet.contains(tmp.getTargetTableName())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 772 -                    || fromTableNameSet.contains(tmp.getTargetTableAlias())){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 773 -                fieldReplaceInfo.setPreNode(tmp);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 774 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 775 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 776 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 777 -        replaceInfoList.add(fieldReplaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 778 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 779 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 780 -    private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 781 -                         Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 782 -                         List&lt;FieldReplaceInfo&gt; replaceInfoList) throws Exception{</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 783 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 784 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 785 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 786 +    private void joinFun(Object pollObj,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 787 +                         Map&lt;String, Table&gt; localTableCache,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 788 +                         Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 789 +                         StreamTableEnvironment tableEnv) throws Exception{</span>
 790          JoinInfo joinInfo = (JoinInfo) pollObj;
 791  
 792          JoinScope joinScope = new JoinScope();
 793          JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 794          leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 795          leftScopeChild.setTableName(joinInfo.getLeftTableName());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 796 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 797 -        SqlKind sqlKind = joinInfo.getLeftNode().getKind();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 798 -        if(sqlKind == AS){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 799 -            dealAsSourceTable(tableEnv, joinInfo.getLeftNode(), localTableCache, replaceInfoList);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 800 -        }</span>
 801  
<abbr title=" 802          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 802          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableNa🔵</abbr>
<abbr title=" 803          RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColumnNames());"> 803          RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColu🔵</abbr>
 804          leftScopeChild.setRowTypeInfo(leftTypeInfo);
 805  
 806          JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 807          rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 808          rightScopeChild.setTableName(joinInfo.getRightTableName());
 809          AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 810          if(sideTableInfo == null){
 811              sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 812          }
 813  
 814          if(sideTableInfo == null){
 815              throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 816          }
 817  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 818 -//        if(!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 819 -//            throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 820 -//        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 821 +        if(!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 822 +            throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 823 +        }</span>
 824  
 825          rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 826  
 827          joinScope.addScope(leftScopeChild);
 828          joinScope.addScope(rightScopeChild);
 829  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 830 +        HashBasedTable&lt;String, String, String&gt; mappingTable = ((JoinInfo) pollObj).getTableFieldRef();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 831 +</span>
 832          //获取两个表的所有字段
<abbr title=" 833          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 833          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, tr🔵</abbr>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 834 +        //通过join的查询字段信息过滤出需要的字段信息</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 835 +        sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getFieldName()) == null);"> 835 +        sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getField🔵</abbr></span>
 836  
 837          String leftTableAlias = joinInfo.getLeftTableAlias();
 838          Table targetTable = localTableCache.get(leftTableAlias);
 839          if(targetTable == null){
 840              targetTable = localTableCache.get(joinInfo.getLeftTableName());
 841          }
 842  
<abbr title=" 843          RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColumnNames());"> 843          RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColu🔵</abbr>
 844  
 845          DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)
 846                  .map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; {
 847                      return new CRow(tp2.f1, tp2.f0);
 848                  }).returns(CRow.class);
 849  
 850  
 851          //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 852          if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 853              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 853              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(🔵</abbr>
 854              List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 855              int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 856              adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 856              adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.🔵</abbr>
 857          }
 858  
 859          DataStream&lt;CRow&gt; dsOut = null;
 860          if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title=" 861              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 861              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlP🔵</abbr>
 862          }else{
<abbr title=" 863              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 863              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPa🔵</abbr>
 864          }
 865  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 866 -        // TODO  将嵌套表中的字段传递过去, 去除冗余的ROWtime</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 867 -        HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();</span>
 868          RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 869  
 870          CRowTypeInfo cRowTypeInfo = new CRowTypeInfo(sideOutTypeInfo);
 871          dsOut.getTransformation().setOutputType(cRowTypeInfo);
 872  
 873          String targetTableName = joinInfo.getNewTableName();
 874          String targetTableAlias = joinInfo.getNewTableAlias();
 875  
 876          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 877          replaceInfo.setMappingTable(mappingTable);
 878          replaceInfo.setTargetTableName(targetTableName);
 879          replaceInfo.setTargetTableAlias(targetTableAlias);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 880 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 881 -        //判断之前是不是被替换过,被替换过则设置之前的替换信息作为上一个节点</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 882 -        for(FieldReplaceInfo tmp : replaceInfoList){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 883 -            if(tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 884 -            ||tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableAlias())){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 885 -                replaceInfo.setPreNode(tmp);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 886 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 887 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 888 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 889 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 890 -        replaceInfoList.add(replaceInfo);</span>
 891  
 892          if (!tableEnv.isRegistered(joinInfo.getNewTableName())){
 893              Table joinTable = tableEnv.fromDataStream(dsOut);
 894              tableEnv.registerTable(joinInfo.getNewTableName(), joinTable);
 895              localTableCache.put(joinInfo.getNewTableName(), joinTable);
 896          }
 897      }
 898  
 899      private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 900          String[] fieldNames = schema.getFieldNames();
 901          TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 902  
 903          String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);
<abbr title=" 904          TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 904          TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformat🔵</abbr>
 905          return new RowTypeInfo(projectedTypes, projectedNames);
 906      }
 907  
 908  
 909      private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 910          List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 911          String fieldsInfo = result.getFieldsInfoStr();
 912          String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 913          for (int i = 0; i &lt; fields.length; i++) {
 914              String[] filed = fields[i].split(&quot;\\s&quot;);
 915              if (filed.length &lt; 2 || fields.length != table.getSchema().getColumnNames().length){
 916                  return false;
 917              } else {
 918                  String[] filedNameArr = new String[filed.length - 1];
 919                  System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 920                  String fieldName = String.join(&quot; &quot;, filedNameArr);
 921                  fieldNames.add(fieldName);
 922                  String fieldType = filed[filed.length - 1 ].trim();
 923                  Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 924                  Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 925                  if (fieldClass == tableField){
 926                      continue;
 927                  } else {
 928                      return false;
 929                  }
 930              }
 931          }
 932          tmpFields = String.join(&quot;,&quot;, fieldNames);
 933          return true;
 934      }
 935  
 936  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.side;
  22  
  23  import org.apache.flink.api.common.typeinfo.TypeInformation;
  24  import org.apache.flink.api.java.tuple.Tuple2;
  25  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  26  import org.apache.flink.streaming.api.datastream.DataStream;
  27  import org.apache.flink.table.api.StreamQueryConfig;
  28  import org.apache.flink.table.api.Table;
  29  import org.apache.flink.table.api.TableSchema;
  30  import org.apache.flink.table.api.java.StreamTableEnvironment;
  31  import org.apache.flink.table.runtime.CRowKeySelector;
  32  import org.apache.flink.table.runtime.types.CRow;
  33  import org.apache.flink.table.runtime.types.CRowTypeInfo;
  34  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  35  import org.apache.flink.types.Row;
  36  
  37  import com.dtstack.flink.sql.enums.ECacheType;
  38  import com.dtstack.flink.sql.exec.FlinkSQLExec;
  39  import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  40  import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  41  import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  42  import com.dtstack.flink.sql.util.ClassUtil;
  43  import com.dtstack.flink.sql.util.ParseUtils;
  44  import com.dtstack.flink.sql.util.TableUtils;
  45  import com.google.common.base.Preconditions;
  46  import com.google.common.collect.HashBasedTable;
  47  import com.google.common.collect.Lists;
  48  import com.google.common.collect.Maps;
  49  import com.google.common.collect.Sets;
  50  import org.apache.calcite.sql.SqlAsOperator;
  51  import org.apache.calcite.sql.SqlBasicCall;
  52  import org.apache.calcite.sql.SqlDataTypeSpec;
  53  import org.apache.calcite.sql.SqlIdentifier;
  54  import org.apache.calcite.sql.SqlInsert;
  55  import org.apache.calcite.sql.SqlJoin;
  56  import org.apache.calcite.sql.SqlKind;
  57  import org.apache.calcite.sql.SqlLiteral;
  58  import org.apache.calcite.sql.SqlNode;
  59  import org.apache.calcite.sql.SqlNodeList;
  60  import org.apache.calcite.sql.SqlOperator;
  61  import org.apache.calcite.sql.SqlOrderBy;
  62  import org.apache.calcite.sql.SqlSelect;
  63  import org.apache.calcite.sql.SqlWithItem;
  64  import org.apache.calcite.sql.fun.SqlCase;
  65  import org.apache.calcite.sql.parser.SqlParseException;
  66  import org.apache.calcite.sql.parser.SqlParserPos;
  67  import org.apache.commons.collections.CollectionUtils;
  68  import org.apache.commons.lang3.StringUtils;
  69  import org.slf4j.Logger;
  70  import org.slf4j.LoggerFactory;
  71  
  72  import java.sql.Timestamp;
  73  import java.util.Arrays;
  74  import java.util.Collection;
  75  import java.util.LinkedList;
  76  import java.util.List;
  77  import java.util.Map;
  78  import java.util.Queue;
  79  import java.util.Set;
  80  
  81  import static org.apache.calcite.sql.SqlKind.*;
  82  
  83  /**
  84   * Reason:
  85   * Date: 2018/7/24
  86   * Company: www.dtstack.com
  87   * @author xuchao
  88   */
  89  
  90  public class SideSqlExec {
  91  
  92      private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  93  
  94      private String localSqlPluginPath = null;
  95  
  96      private String tmpFields = null;
  97  
  98      private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  99  
 100      private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
 101  
 102      public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,
<abbr title=" 103                       Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.SqlParserResult createView) throws Exception {"> 103                       Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.SqlParserR🔵</abbr>






 104          if(localSqlPluginPath == null){
 105              throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
 106          }
 107  
 108          localTableCache.putAll(tableCache);
 109          try {
 110              sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 111          } catch (Exception e) {
 112              LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 113          }
 114  
 115          if(createView != null){
 116              LOG.warn(&quot;create view info\n&quot;);
 117              LOG.warn(createView.getExecSql());
 118              LOG.warn(&quot;-----------------&quot;);
 119          }
 120  
 121          SideSQLParser sideSQLParser = new SideSQLParser();
 122          sideSQLParser.setLocalTableCache(localTableCache);
 123          Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());
 124          Object pollObj = null;
 125  
 126          //need clean
 127          boolean preIsSideJoin = false;
 128          List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();
 129  
 130          while((pollObj = exeQueue.poll()) != null){
 131  
 132              if(pollObj instanceof SqlNode){
 133                  SqlNode pollSqlNode = (SqlNode) pollObj;
 134  
 135                  if(preIsSideJoin){
 136                      preIsSideJoin = false;
 137                      List&lt;String&gt; fieldNames = null;
 138                      for(FieldReplaceInfo replaceInfo : replaceInfoList){
 139                          fieldNames = Lists.newArrayList();
 140                          replaceFieldName(pollSqlNode, replaceInfo);
 141                          addAliasForFieldNode(pollSqlNode, fieldNames, replaceInfo.getMappingTable());
 142                      }
 143                  }
 144  
 145                  if(pollSqlNode.getKind() == INSERT){
 146                      FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);
 147                      if(LOG.isInfoEnabled()){
 148                          LOG.info(&quot;----------real exec sql-----------\n{}&quot;, pollSqlNode.toString());
 149                      }
 150  
 151                  }else if(pollSqlNode.getKind() == AS){
 152                      dealAsSourceTable(tableEnv, pollSqlNode, tableCache, replaceInfoList);

 153  
 154                  } else if (pollSqlNode.getKind() == WITH_ITEM) {
 155                      SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 156                      String TableAlias = sqlWithItem.name.toString();
 157                      Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 158                      tableEnv.registerTable(TableAlias, table);
 159  
 160                  } else if (pollSqlNode.getKind() == SELECT){
 161                      Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);
 162                      Table table = tableEnv.sqlQuery(pollObj.toString());
 163  
 164                      if (createView.getFieldsInfoStr() == null){
 165                          tableEnv.registerTable(createView.getTableName(), table);
 166                      } else {
 167                          if (checkFieldsInfo(createView, table)){
 168                              table = table.as(tmpFields);
 169                              tableEnv.registerTable(createView.getTableName(), table);
 170                          } else {
 171                              throw new RuntimeException(&quot;Fields mismatch&quot;);
 172                          }
 173                      }
 174  
 175                      localTableCache.put(createView.getTableName(), table);
 176                  }
 177  
 178              }else if (pollObj instanceof JoinInfo){
 179                  LOG.info(&quot;----------exec join info----------\n{}&quot;, pollObj.toString());
 180                  preIsSideJoin = true;
 181                  joinFun(pollObj, localTableCache, sideTableMap, tableEnv, replaceInfoList);

 182              }
 183          }
 184  
 185      }
 186  
 187  
 188      /**
 189       * 解析出as查询的表和字段的关系
 190       * @param asSqlNode
 191       * @param tableCache
 192       * @return
 193       */
 194      private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 195          SqlNode info = asSqlNode.getOperands()[0];
 196          SqlNode alias = asSqlNode.getOperands()[1];
 197  
 198          SqlKind infoKind = info.getKind();
 199          if(infoKind != SELECT){
 200              return null;
 201          }
 202  
 203          List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 204  
 205          HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 206          for (FieldInfo fieldInfo : extractFieldList) {
 207              String tableName = fieldInfo.getTable();
 208              String fieldName = fieldInfo.getFieldName();
 209              String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 210              mappingTable.put(tableName, fieldName, mappingFieldName);
 211          }
 212  
 213          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 214          replaceInfo.setMappingTable(mappingTable);
 215          replaceInfo.setTargetTableName(alias.toString());
 216          replaceInfo.setTargetTableAlias(alias.toString());
 217          return replaceInfo;
 218      }
 219  
 220  
 221      /**
 222       * 添加字段别名
 223       * @param pollSqlNode
 224       * @param fieldList
 225       * @param mappingTable
 226       */
<abbr title=" 227      private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 227      private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, 🔵</abbr>
 228          SqlKind sqlKind = pollSqlNode.getKind();
 229          switch (sqlKind) {
 230              case INSERT:
 231                  SqlNode source = ((SqlInsert) pollSqlNode).getSource();
 232                  addAliasForFieldNode(source, fieldList, mappingTable);
 233                  break;
 234              case AS:
 235                  addAliasForFieldNode(((SqlBasicCall) pollSqlNode).getOperands()[0], fieldList, mappingTable);
 236                  break;
 237              case SELECT:
 238                  SqlNodeList selectList = ((SqlSelect) pollSqlNode).getSelectList();
 239                  selectList.getList().forEach(node -&gt; {
 240                      if (node.getKind() == IDENTIFIER) {
 241                          SqlIdentifier sqlIdentifier = (SqlIdentifier) node;
 242                          if (sqlIdentifier.names.size() == 1) {
 243                              return;
 244                          }
 245                          // save real field
 246                          String fieldName = sqlIdentifier.names.get(1);
<abbr title=" 247                          if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().containsKey(fieldName)) {"> 247                          if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().contai🔵</abbr>
 248                              fieldList.add(fieldName);
 249                          }
 250  
 251                      }
 252                  });
 253                  for (int i = 0; i &lt; selectList.getList().size(); i++) {
 254                      SqlNode node = selectList.get(i);
 255                      if (node.getKind() == IDENTIFIER) {
 256                          SqlIdentifier sqlIdentifier = (SqlIdentifier) node;
 257                          if (sqlIdentifier.names.size() == 1) {
 258                              return;
 259                          }
 260                          String name = sqlIdentifier.names.get(1);
 261                          // avoid real field pv0 convert pv
<abbr title=" 262                          if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring(0, name.length() - 1))) {"> 262                          if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring🔵</abbr>
 263                              SqlOperator operator = new SqlAsOperator();
 264                              SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 265  
<abbr title=" 266                              SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() - 1), null, sqlParserPos);"> 266                              SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() -🔵</abbr>
 267                              SqlNode[] sqlNodes = new SqlNode[2];
 268                              sqlNodes[0] = sqlIdentifier;
 269                              sqlNodes[1] = sqlIdentifierAlias;
 270                              SqlBasicCall sqlBasicCall = new SqlBasicCall(operator, sqlNodes, sqlParserPos);
 271  
 272                              selectList.set(i, sqlBasicCall);
 273                          }
 274                      }
 275                  }
 276                  break;
 277              default:
 278                  break;
 279          }
 280      }
 281  
 282  
 283      public AliasInfo parseAsNode(SqlNode sqlNode) throws SqlParseException {

 284          SqlKind sqlKind = sqlNode.getKind();
 285          if(sqlKind != AS){
 286              throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 287          }
 288  
 289          SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 290          SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 291  
 292          AliasInfo aliasInfo = new AliasInfo();
 293          aliasInfo.setName(info.toString());
 294          aliasInfo.setAlias(alias.toString());
 295  
 296          return aliasInfo;
 297      }
 298  
<abbr title=" 299      public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 299      public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, Strin🔵</abbr>


 300          TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 301          String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 302          for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 303              FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 304              String tableName = fieldInfo.getTable();
 305              String fieldName = fieldInfo.getFieldName();
 306              String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 307              mappingTable.put(tableName, fieldName, mappingFieldName);



 308  
 309              sideOutTypes[i] = fieldInfo.getTypeInformation();
 310              sideOutNames[i] = mappingFieldName;
 311          }
 312          return new RowTypeInfo(sideOutTypes, sideOutNames);
 313      }
 314  
 315  
 316  
 317      /**
 318       *  对时间类型进行类型转换
 319       * @param leftTypeInfo
 320       * @return
 321       */
 322      private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 323          TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 324          TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 325          for (int i = 0; i &lt; sideOutTypes.length; i++) {
 326              sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 327          }
 328          RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 329          return rowTypeInfo;
 330      }
 331  
 332      private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 333          if (typeInformation instanceof TimeIndicatorTypeInfo) {
 334              return TypeInformation.of(Timestamp.class);
 335          }
 336          return typeInformation;
 337      }
 338  
 339      //需要考虑更多的情况
 340      private void replaceFieldName(SqlNode sqlNode, FieldReplaceInfo replaceInfo) {
 341          SqlKind sqlKind = sqlNode.getKind();
 342          switch (sqlKind) {
 343              case INSERT:
 344                  SqlNode sqlSource = ((SqlInsert) sqlNode).getSource();
 345                  replaceFieldName(sqlSource, replaceInfo);
 346                  break;
 347              case AS:
 348                  SqlNode asNode = ((SqlBasicCall) sqlNode).getOperands()[0];
 349                  replaceFieldName(asNode, replaceInfo);
 350                  break;
 351              case SELECT:
<abbr title=" 352                  SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTargetTableName());"> 352                  SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTargetTableName🔵</abbr>
 353                  if(sqlSelect == null){
 354                      return;
 355                  }
 356  
 357                  SqlNode sqlSource1 = sqlSelect.getFrom();
 358                  if(sqlSource1.getKind() == AS){
 359                      String tableName = ((SqlBasicCall)sqlSource1).getOperands()[0].toString();
 360                      if(tableName.equalsIgnoreCase(replaceInfo.getTargetTableName())){
 361                          SqlNodeList sqlSelectList = sqlSelect.getSelectList();
 362                          SqlNode whereNode = sqlSelect.getWhere();
 363                          SqlNodeList sqlGroup = sqlSelect.getGroup();
 364  
 365                          //TODO 暂时不处理having
 366                          SqlNode sqlHaving = sqlSelect.getHaving();
 367  
 368                          List&lt;SqlNode&gt; newSelectNodeList = Lists.newArrayList();
 369                          for( int i=0; i&lt;sqlSelectList.getList().size(); i++){
 370                              SqlNode selectNode = sqlSelectList.getList().get(i);
 371                              //特殊处理 isStar的标识
 372                              if(selectNode.getKind() == IDENTIFIER &amp;&amp; ((SqlIdentifier) selectNode).isStar()){
<abbr title=" 373                                  List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, replaceInfo);"> 373                                  List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, replaceInfo🔵</abbr>
 374                                  newSelectNodeList.addAll(replaceNodeList);
 375                                  continue;
 376                              }
 377  
 378                              SqlNode replaceNode = replaceSelectFieldName(selectNode, replaceInfo);
 379                              if(replaceNode == null){
 380                                  continue;
 381                              }
 382  
 383                              //sqlSelectList.set(i, replaceNode);
 384                              newSelectNodeList.add(replaceNode);
 385                          }
 386  
<abbr title=" 387                          SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosition());"> 387                          SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosi🔵</abbr>
 388                          sqlSelect.setSelectList(newSelectList);
 389  
 390                          //where
 391                          if(whereNode != null){
 392                              SqlNode[] sqlNodeList = ((SqlBasicCall)whereNode).getOperands();
 393                              for(int i =0; i&lt;sqlNodeList.length; i++) {
 394                                  SqlNode whereSqlNode = sqlNodeList[i];
 395                                  SqlNode replaceNode = replaceNodeInfo(whereSqlNode, replaceInfo);
 396                                  sqlNodeList[i] = replaceNode;
 397                              }
 398                          }
 399                          if(sqlGroup != null &amp;&amp; CollectionUtils.isNotEmpty(sqlGroup.getList())){
 400                              for( int i=0; i&lt;sqlGroup.getList().size(); i++){
 401                                  SqlNode selectNode = sqlGroup.getList().get(i);
 402                                  SqlNode replaceNode = replaceNodeInfo(selectNode, replaceInfo);
 403                                  sqlGroup.set(i, replaceNode);
 404                              }
 405                          }
 406                      }
 407                  }else{
 408                      throw new RuntimeException(&quot;---not deal type:&quot; + sqlNode);
 409                  }
 410  
 411                  break;
 412              case UNION:
 413                  SqlNode unionLeft = ((SqlBasicCall) sqlNode).getOperands()[0];
 414                  SqlNode unionRight = ((SqlBasicCall) sqlNode).getOperands()[1];
 415                  replaceFieldName(unionLeft, replaceInfo);
 416                  replaceFieldName(unionRight, replaceInfo);
 417  
 418                  break;
 419              case ORDER_BY:
 420                  SqlOrderBy sqlOrderBy  = (SqlOrderBy) sqlNode;
 421                  replaceFieldName(sqlOrderBy.query, replaceInfo);
 422                  SqlNodeList orderFiledList = sqlOrderBy.orderList;
 423                  for (int i=0 ;i&lt;orderFiledList.size();i++) {
<abbr title=" 424                      SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTableAlias());"> 424                      SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTabl🔵</abbr>
 425                      orderFiledList.set(i, replaceNode);
 426                  }
 427  
 428              default:
 429                  break;
 430          }
 431      }
 432  
 433      private SqlNode replaceOrderByTableName(SqlNode orderNode, String tableAlias) {
 434          if(orderNode.getKind() == IDENTIFIER){
 435              SqlIdentifier sqlIdentifier = (SqlIdentifier) orderNode;
 436              if (sqlIdentifier.names.size() == 1) {
 437                  return orderNode;
 438              }
 439              return sqlIdentifier.setName(0, tableAlias);
 440          } else if (orderNode instanceof  SqlBasicCall) {
 441              SqlBasicCall sqlBasicCall = (SqlBasicCall) orderNode;
 442              for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 443                  SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 444                  sqlBasicCall.getOperands()[i] = replaceOrderByTableName(sqlNode , tableAlias);
 445              }
 446              return sqlBasicCall;
 447          } else {
 448              return orderNode;
 449          }
 450      }
 451  
 452      private SqlNode replaceNodeInfo(SqlNode groupNode, FieldReplaceInfo replaceInfo){
 453          if(groupNode.getKind() == IDENTIFIER){
 454              SqlIdentifier sqlIdentifier = (SqlIdentifier) groupNode;
 455              if(sqlIdentifier.names.size() == 1){
 456                  return sqlIdentifier;
 457              }
 458  
<abbr title=" 459              String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 459              String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sq🔵</abbr>
 460              if(mappingFieldName == null){
 461                  throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + sqlIdentifier.toString() );
 462              }
 463  
 464              sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());
 465              return sqlIdentifier.setName(1, mappingFieldName);
 466          }else if(groupNode instanceof  SqlBasicCall){
 467              SqlBasicCall sqlBasicCall = (SqlBasicCall) groupNode;
 468              for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 469                  SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 470                  SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);
 471                  sqlBasicCall.getOperands()[i] = replaceNode;
 472              }
 473  
 474              return sqlBasicCall;
 475          }else{
 476              return groupNode;
 477          }
 478      }
 479  
 480      public SqlNode filterNodeWithTargetName(SqlNode sqlNode, String targetTableName) {
 481  
 482          SqlKind sqlKind = sqlNode.getKind();
 483          switch (sqlKind){
 484              case SELECT:
 485                  SqlNode fromNode = ((SqlSelect)sqlNode).getFrom();
 486                  if(fromNode.getKind() == AS &amp;&amp; ((SqlBasicCall)fromNode).getOperands()[0].getKind() == IDENTIFIER){
 487                      if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableName)){
 488                          return sqlNode;
 489                      }else{
 490                          return null;
 491                      }
 492                  }else{
 493                      return filterNodeWithTargetName(fromNode, targetTableName);
 494                  }
 495              case AS:
 496                  SqlNode childNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 497                  return filterNodeWithTargetName(childNode, targetTableName);
 498              case JOIN:
 499                  SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 500                  SqlNode rightNode =  ((SqlJoin)sqlNode).getRight();
 501                  SqlNode leftReturnNode = filterNodeWithTargetName(leftNode, targetTableName);
 502                  SqlNode rightReturnNode = filterNodeWithTargetName(rightNode, targetTableName);
 503  
 504                  if(leftReturnNode != null) {
 505                      return leftReturnNode;
 506                  }else if(rightReturnNode != null){
 507                      return rightReturnNode;
 508                  }else{
 509                      return null;
 510                  }
 511              default:
 512                  break;
 513          }
 514  
 515          return null;
 516      }



 517  
 518  
 519      public void setLocalSqlPluginPath(String localSqlPluginPath) {
 520          this.localSqlPluginPath = localSqlPluginPath;
 521      }
 522  
 523      private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){
 524          Table table = localTableCache.get(tableAlias);
 525          if(table == null){
 526              table = localTableCache.get(tableName);
 527          }
 528  
 529          if(table == null){
 530              throw new RuntimeException(&quot;not register table &quot; + tableName);

 531          }
 532  
 533          return table;
 534      }
 535  
 536      private List&lt;SqlNode&gt; replaceSelectStarFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo){
 537          SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 538          List&lt;SqlNode&gt; sqlNodes = Lists.newArrayList();
 539          if(sqlIdentifier.isStar()){//处理 [* or table.*]
 540              int identifierSize = sqlIdentifier.names.size();
 541              Collection&lt;String&gt; columns = null;
 542              if(identifierSize == 1){
 543                  columns = replaceInfo.getMappingTable().values();
 544              }else{
 545                  columns = replaceInfo.getMappingTable().row(sqlIdentifier.names.get(0)).values();
 546              }
 547  
 548              for(String colAlias : columns){
 549                  SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 550                  List&lt;String&gt; columnInfo = Lists.newArrayList();
 551                  columnInfo.add(replaceInfo.getTargetTableAlias());
 552                  columnInfo.add(colAlias);
 553                  SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(columnInfo, sqlParserPos);
 554                  sqlNodes.add(sqlIdentifierAlias);
 555              }
 556  
 557              return sqlNodes;
 558          }else{
 559              throw new RuntimeException(&quot;is not a star select field.&quot; + selectNode);
 560          }
 561      }
 562  
 563      private SqlNode replaceSelectFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo) {
 564          if (selectNode.getKind() == AS) {
 565              SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];
 566              SqlNode replaceNode = replaceSelectFieldName(leftNode, replaceInfo);
 567              if (replaceNode != null) {
 568                  ((SqlBasicCall) selectNode).getOperands()[0] = replaceNode;
 569              }
 570  
 571              return selectNode;
 572          }else if(selectNode.getKind() == IDENTIFIER){
 573              SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 574  
 575              if(sqlIdentifier.names.size() == 1){
 576                  return selectNode;
 577              }
 578  
 579              //Same level mappingTable
<abbr title=" 580              String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 580              String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sq🔵</abbr>
 581              if (mappingFieldName == null) {
 582                  throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + selectNode.toString() );
 583              }
 584  
 585              sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());
 586              sqlIdentifier = sqlIdentifier.setName(1, mappingFieldName);
 587              return sqlIdentifier;
 588          }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//字面含义
 589              return selectNode;
 590          }else if(  AGGREGATE.contains(selectNode.getKind())
 591                  || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 592                  || COMPARISON.contains(selectNode.getKind())
 593                  || selectNode.getKind() == OTHER_FUNCTION
 594                  || selectNode.getKind() == DIVIDE
 595                  || selectNode.getKind() == CAST
 596                  || selectNode.getKind() == TRIM
 597                  || selectNode.getKind() == TIMES
 598                  || selectNode.getKind() == PLUS
 599                  || selectNode.getKind() == NOT_IN
 600                  || selectNode.getKind() == OR
 601                  || selectNode.getKind() == AND
 602                  || selectNode.getKind() == MINUS
 603                  || selectNode.getKind() == TUMBLE
 604                  || selectNode.getKind() == TUMBLE_START
 605                  || selectNode.getKind() == TUMBLE_END
 606                  || selectNode.getKind() == SESSION
 607                  || selectNode.getKind() == SESSION_START
 608                  || selectNode.getKind() == SESSION_END
 609                  || selectNode.getKind() == HOP
 610                  || selectNode.getKind() == HOP_START
 611                  || selectNode.getKind() == HOP_END
 612                  || selectNode.getKind() == BETWEEN
 613                  || selectNode.getKind() == IS_NULL
 614                  || selectNode.getKind() == IS_NOT_NULL
 615                  || selectNode.getKind() == CONTAINS
 616                  || selectNode.getKind() == TIMESTAMP_ADD
 617                  || selectNode.getKind() == TIMESTAMP_DIFF
 618                  || selectNode.getKind() == LIKE
 619  
 620                  ){
 621              SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 622              for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 623                  SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 624                  if(sqlNode instanceof SqlLiteral){
 625                      continue;
 626                  }
 627  
 628                  if(sqlNode instanceof SqlDataTypeSpec){
 629                      continue;
 630                  }
 631  
 632                  SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);
 633                  if(replaceNode == null){
 634                      continue;
 635                  }
 636  
 637                  sqlBasicCall.getOperands()[i] = replaceNode;
 638              }
 639  
 640              return selectNode;
 641          }else if(selectNode.getKind() == CASE){
 642              SqlCase sqlCase = (SqlCase) selectNode;
 643              SqlNodeList whenOperands = sqlCase.getWhenOperands();
 644              SqlNodeList thenOperands = sqlCase.getThenOperands();
 645              SqlNode elseNode = sqlCase.getElseOperand();
 646  
 647              for(int i=0; i&lt;whenOperands.size(); i++){
 648                  SqlNode oneOperand = whenOperands.get(i);
 649                  SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);
 650                  if (replaceNode != null) {
 651                      whenOperands.set(i, replaceNode);
 652                  }
 653              }
 654  
 655              for(int i=0; i&lt;thenOperands.size(); i++){
 656                  SqlNode oneOperand = thenOperands.get(i);
 657                  SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);
 658                  if (replaceNode != null) {
 659                      thenOperands.set(i, replaceNode);
 660                  }
 661              }
 662  
 663              ((SqlCase) selectNode).setOperand(3, replaceSelectFieldName(elseNode, replaceInfo));
 664              return selectNode;
 665          }else if(selectNode.getKind() == OTHER){
 666              //不处理
 667              return selectNode;
 668          }else{
<abbr title=" 669              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 669              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNod🔵</abbr>
 670          }
 671      }
 672  
 673      /**
<abbr title=" 674       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 674       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension 🔵</abbr>
 675       *
 676       * @return
 677       */
<abbr title=" 678      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 678      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTab🔵</abbr>
 679          List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 680          if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 681              return true;
 682          }
 683          return false;
 684      }
 685  
 686      private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 687          List&lt;String&gt; res = Lists.newArrayList();
 688          sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 689              res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 690          });
 691          return res;
 692      }
 693  
<abbr title=" 694      public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 694      public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo s🔵</abbr>
 695          List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 696          ParseUtils.parseAnd(conditionNode, sqlNodeList);
 697          List&lt;String&gt; conditionFields = Lists.newArrayList();
 698          for(SqlNode sqlNode : sqlNodeList){
 699              if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 700                  throw new RuntimeException(&quot;not compare operator.&quot;);
 701              }
 702  
 703              SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 704              SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 705  
 706              String leftTableName = left.getComponent(0).getSimple();
 707              String rightTableName = right.getComponent(0).getSimple();
 708  
 709              String tableCol = &quot;&quot;;
 710              if(leftTableName.equalsIgnoreCase(specifyTableName)){
 711                  tableCol = left.getComponent(1).getSimple();
 712              }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 713                  tableCol = right.getComponent(1).getSimple();
 714              }else{
<abbr title=" 715                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 715                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName🔵</abbr>
 716              }
 717              tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 718              conditionFields.add(tableCol);
 719          }
 720  
 721          return conditionFields;
 722      }
 723  
 724      protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 725                                       SqlNode pollSqlNode,
 726                                       Map&lt;String, Table&gt; tableCache,
 727                                       List&lt;FieldReplaceInfo&gt; replaceInfoList) throws SqlParseException {
 728  
 729          AliasInfo aliasInfo = parseAsNode(pollSqlNode);



 730          if (localTableCache.containsKey(aliasInfo.getName())) {
 731              return;
 732          }
 733  
 734          Table table = tableEnv.sqlQuery(aliasInfo.getName());
 735          tableEnv.registerTable(aliasInfo.getAlias(), table);
 736          localTableCache.put(aliasInfo.getAlias(), table);
 737  
 738          LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 739  
 740          FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 741          if(fieldReplaceInfo == null){
 742             return;
 743          }
 744  
 745          //as 的源表
 746          Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 747          SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];
 748          TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 749          for(FieldReplaceInfo tmp : replaceInfoList){
 750              if(fromTableNameSet.contains(tmp.getTargetTableName())
 751                      || fromTableNameSet.contains(tmp.getTargetTableAlias())){
 752                  fieldReplaceInfo.setPreNode(tmp);
 753                  break;
 754              }
 755          }
 756          replaceInfoList.add(fieldReplaceInfo);
 757      }
 758  
 759      private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache,
 760                           Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,
 761                           List&lt;FieldReplaceInfo&gt; replaceInfoList) throws Exception{







 762          JoinInfo joinInfo = (JoinInfo) pollObj;
 763  
 764          JoinScope joinScope = new JoinScope();
 765          JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 766          leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 767          leftScopeChild.setTableName(joinInfo.getLeftTableName());
 768  
 769          SqlKind sqlKind = joinInfo.getLeftNode().getKind();
 770          if(sqlKind == AS){
 771              dealAsSourceTable(tableEnv, joinInfo.getLeftNode(), localTableCache, replaceInfoList);
 772          }
 773  
<abbr title=" 774          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 774          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableNa🔵</abbr>
<abbr title=" 775          RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColumnNames());"> 775          RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColu🔵</abbr>
 776          leftScopeChild.setRowTypeInfo(leftTypeInfo);
 777  
 778          JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 779          rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 780          rightScopeChild.setTableName(joinInfo.getRightTableName());
 781          AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 782          if(sideTableInfo == null){
 783              sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 784          }
 785  
 786          if(sideTableInfo == null){
 787              throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 788          }
 789  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 790 -//        if(!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 791 -//            throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 792 -//        }</span>



<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 793 -</span>
 794          rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 795  
 796          joinScope.addScope(leftScopeChild);
 797          joinScope.addScope(rightScopeChild);
 798  


 799          //获取两个表的所有字段
<abbr title=" 800          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 800          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, tr🔵</abbr>


 801  
 802          String leftTableAlias = joinInfo.getLeftTableAlias();
 803          Table targetTable = localTableCache.get(leftTableAlias);
 804          if(targetTable == null){
 805              targetTable = localTableCache.get(joinInfo.getLeftTableName());
 806          }
 807  
<abbr title=" 808          RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColumnNames());"> 808          RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColu🔵</abbr>
 809  
 810          DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)
 811                  .map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; {
 812                      return new CRow(tp2.f1, tp2.f0);
 813                  }).returns(CRow.class);
 814  
 815  
 816          //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 817          if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 818              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 818              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(🔵</abbr>
 819              List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 820              int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 821              adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 821              adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.🔵</abbr>
 822          }
 823  
 824          DataStream&lt;CRow&gt; dsOut = null;
 825          if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title=" 826              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 826              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlP🔵</abbr>
 827          }else{
<abbr title=" 828              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 828              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPa🔵</abbr>
 829          }
 830  
 831          // TODO  将嵌套表中的字段传递过去, 去除冗余的ROWtime
 832          HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 833          RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 834  
 835          CRowTypeInfo cRowTypeInfo = new CRowTypeInfo(sideOutTypeInfo);
 836          dsOut.getTransformation().setOutputType(cRowTypeInfo);
 837  
 838          String targetTableName = joinInfo.getNewTableName();
 839          String targetTableAlias = joinInfo.getNewTableAlias();
 840  
 841          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 842          replaceInfo.setMappingTable(mappingTable);
 843          replaceInfo.setTargetTableName(targetTableName);
 844          replaceInfo.setTargetTableAlias(targetTableAlias);
 845  
 846          //判断之前是不是被替换过,被替换过则设置之前的替换信息作为上一个节点
 847          for(FieldReplaceInfo tmp : replaceInfoList){
 848              if(tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName())
 849              ||tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableAlias())){
 850                  replaceInfo.setPreNode(tmp);
 851                  break;
 852              }
 853          }
 854  
 855          replaceInfoList.add(replaceInfo);
 856  
 857          if (!tableEnv.isRegistered(joinInfo.getNewTableName())){
 858              Table joinTable = tableEnv.fromDataStream(dsOut);
 859              tableEnv.registerTable(joinInfo.getNewTableName(), joinTable);
 860              localTableCache.put(joinInfo.getNewTableName(), joinTable);
 861          }
 862      }
 863  
 864      private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 865          String[] fieldNames = schema.getFieldNames();
 866          TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 867  
 868          String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);
<abbr title=" 869          TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 869          TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformat🔵</abbr>
 870          return new RowTypeInfo(projectedTypes, projectedNames);
 871      }
 872  
 873  
 874      private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 875          List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 876          String fieldsInfo = result.getFieldsInfoStr();
 877          String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 878          for (int i = 0; i &lt; fields.length; i++) {
 879              String[] filed = fields[i].split(&quot;\\s&quot;);
 880              if (filed.length &lt; 2 || fields.length != table.getSchema().getColumnNames().length){
 881                  return false;
 882              } else {
 883                  String[] filedNameArr = new String[filed.length - 1];
 884                  System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 885                  String fieldName = String.join(&quot; &quot;, filedNameArr);
 886                  fieldNames.add(fieldName);
 887                  String fieldType = filed[filed.length - 1 ].trim();
 888                  Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 889                  Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 890                  if (fieldClass == tableField){
 891                      continue;
 892                  } else {
 893                      return false;
 894                  }
 895              }
 896          }
 897          tmpFields = String.join(&quot;,&quot;, fieldNames);
 898          return true;
 899      }
 900  
 901  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            