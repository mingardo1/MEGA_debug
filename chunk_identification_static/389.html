<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>389</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    389
                    <a href="388.html">prev</a>
                    <a href="390.html">next</a>
                    <a href="389_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_07c4ccdd6f1f5fed2b5b800377edca583bc33bbe_core/src/main/java/com/dtstack/flink/sql/parser/CreateTmpTableParser.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;07c4ccdd6f1f5fed2b5b800377edca583bc33bbe:core/src/main/java/com/dtstack/flink/sql/parser/CreateTmpTableParser.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;07c4ccdd6f1f5fed2b5b800377edca583bc33bbe^1:core/src/main/java/com/dtstack/flink/sql/parser/CreateTmpTableParser.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;07c4ccdd6f1f5fed2b5b800377edca583bc33bbe^2:core/src/main/java/com/dtstack/flink/sql/parser/CreateTmpTableParser.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e1736f333f6ce46e1045ac877bcaa38cbc20c6cc:core/src/main/java/com/dtstack/flink/sql/parser/CreateTmpTableParser.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.parser;
  22 
  23 import com.dtstack.flink.sql.util.DtStringUtil;
  24 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  25 import org.apache.calcite.sql.*;</span>
  26 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  27 import org.apache.calcite.config.Lex;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  28 import org.apache.calcite.sql.*;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  29 import org.apache.calcite.sql.parser.SqlParseException;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  30 import org.apache.calcite.sql.parser.SqlParser;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  31 import com.google.common.collect.Lists;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  32 import java.util.List;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  33 import java.util.regex.Matcher;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  34 import java.util.regex.Pattern;</span>
  35 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  36 import org.apache.calcite.config.Lex;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  37 import org.apache.calcite.sql.SqlBasicCall;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  38 import org.apache.calcite.sql.SqlJoin;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  39 import org.apache.calcite.sql.SqlKind;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  40 import org.apache.calcite.sql.SqlNode;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  41 import org.apache.calcite.sql.SqlSelect;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  42 import org.apache.calcite.sql.parser.SqlParseException;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  43 import org.apache.calcite.sql.parser.SqlParser;</span>
  44 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  45 import com.google.common.collect.Lists;
  46 import org.apache.flink.table.calcite.FlinkPlannerImpl;
  47 
  48 import java.util.List;
  49 import java.util.regex.Matcher;
  50 import java.util.regex.Pattern;
  51 
  52 import static org.apache.calcite.sql.SqlKind.IDENTIFIER;
  53 
  54 /**
  55  * parser create tmp table sql
  56  * Date: 2018/6/26
  57  * Company: www.dtstack.com
  58  * @author yanxi
  59  */
  60 public class CreateTmpTableParser implements IParser {
  61 
  62     //select table tableName as select
  63     private static final String PATTERN_STR = &quot;(?i)create\\s+view\\s+([^\\s]+)\\s+as\\s+select\\s+(.*)&quot;;
  64 
  65     private static final String EMPTY_STR = &quot;(?i)^\\screate\\s+view\\s+(\\S+)\\s*\\((.+)\\)$&quot;;
  66 
  67     private static final Pattern NONEMPTYVIEW = Pattern.compile(PATTERN_STR);
  68 
  69     private static final Pattern EMPTYVIEW = Pattern.compile(EMPTY_STR);
  70 
  71     public static CreateTmpTableParser newInstance(){
  72         return new CreateTmpTableParser();
  73     }
  74 
  75     @Override
  76     public boolean verify(String sql) {
  77         if (Pattern.compile(EMPTY_STR).matcher(sql).find()){
  78             return true;
  79         }
  80         return NONEMPTYVIEW.matcher(sql).find();
  81     }
  82 
  83     @Override
  84     public void parseSql(String sql, SqlTree sqlTree) {
  85         if (NONEMPTYVIEW.matcher(sql).find()){
  86             Matcher matcher = NONEMPTYVIEW.matcher(sql);
  87             String tableName = null;
  88             String selectSql = null;
  89             if(matcher.find()) {
  90                 tableName = matcher.group(1);
  91                 selectSql = &quot;select &quot; + matcher.group(2);
  92             }
  93             FlinkPlannerImpl flinkPlanner = FlinkPlanner.getFlinkPlanner();
  94 
  95             SqlNode sqlNode = null;
  96             try {
  97                 sqlNode = flinkPlanner.parse(selectSql);
  98             } catch (Exception e) {
  99                 throw new RuntimeException(&quot;&quot;, e);
 100             }
 101 
<abbr title=" 102             CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResult();"> 102             CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResul🔵</abbr>
 103             parseNode(sqlNode, sqlParseResult);
 104 
 105             sqlParseResult.setTableName(tableName);
 106             String transformSelectSql = DtStringUtil.replaceIgnoreQuota(sqlNode.toString(), &quot;`&quot;, &quot;&quot;);
 107             sqlParseResult.setExecSql(transformSelectSql);
 108             sqlTree.addTmpSql(sqlParseResult);
 109             sqlTree.addTmplTableInfo(tableName, sqlParseResult);
 110         } else {
 111             if (EMPTYVIEW.matcher(sql).find())
 112             {
 113                 Matcher matcher = EMPTYVIEW.matcher(sql);
 114                 String tableName = null;
 115                 String fieldsInfoStr = null;
 116                 if (matcher.find()){
 117                     tableName = matcher.group(1);
 118                     fieldsInfoStr = matcher.group(2);
 119                 }
<abbr title=" 120                 CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResult();"> 120                 CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserR🔵</abbr>
 121                 sqlParseResult.setFieldsInfoStr(fieldsInfoStr);
 122                 sqlParseResult.setTableName(tableName);
 123                 sqlTree.addTmplTableInfo(tableName, sqlParseResult);
 124             }
 125 
 126         }
 127 
 128     }
 129 
 130     private static void parseNode(SqlNode sqlNode, CreateTmpTableParser.SqlParserResult sqlParseResult){
 131         SqlKind sqlKind = sqlNode.getKind();
 132         switch (sqlKind){
 133             case SELECT:
 134                 SqlNode sqlFrom = ((SqlSelect)sqlNode).getFrom();
 135                 if(sqlFrom.getKind() == IDENTIFIER){
 136                     sqlParseResult.addSourceTable(sqlFrom.toString());
 137                 }else{
 138                     parseNode(sqlFrom, sqlParseResult);
 139                 }
 140                 break;
 141             case JOIN:
 142                 SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 143                 SqlNode rightNode = ((SqlJoin)sqlNode).getRight();
 144 
 145                 if(leftNode.getKind() == IDENTIFIER){
 146                     sqlParseResult.addSourceTable(leftNode.toString());
 147                 }else{
 148                     parseNode(leftNode, sqlParseResult);
 149                 }
 150 
 151                 if(rightNode.getKind() == IDENTIFIER){
 152                     sqlParseResult.addSourceTable(rightNode.toString());
 153                 }else{
 154                     parseNode(rightNode, sqlParseResult);
 155                 }
 156                 break;
 157             case AS:
 158                 //不解析column,所以 as 相关的都是表
 159                 SqlNode identifierNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 160                 if(identifierNode.getKind() != IDENTIFIER){
 161                     parseNode(identifierNode, sqlParseResult);
 162                 }else {
 163                     sqlParseResult.addSourceTable(identifierNode.toString());
 164                 }
 165                 break;
 166             case UNION:
 167                 SqlNode unionLeft = ((SqlBasicCall)sqlNode).getOperands()[0];
 168                 SqlNode unionRight = ((SqlBasicCall)sqlNode).getOperands()[1];
 169                 if(unionLeft.getKind() == IDENTIFIER){
 170                     sqlParseResult.addSourceTable(unionLeft.toString());
 171                 }else{
 172                     parseNode(unionLeft, sqlParseResult);
 173                 }
 174                 if(unionRight.getKind() == IDENTIFIER){
 175                     sqlParseResult.addSourceTable(unionRight.toString());
 176                 }else{
 177                     parseNode(unionRight, sqlParseResult);
 178                 }
 179                 break;
 180             default:
 181                 //do nothing
 182                 break;
 183         }
 184     }
 185 
 186     public static class SqlParserResult {
 187         private String tableName;
 188 
 189         private String fieldsInfoStr;
 190 
 191         private String execSql;
 192 
 193         private List&lt;String&gt; sourceTableList = Lists.newArrayList();
 194 
 195         public String getTableName() {
 196             return tableName;
 197         }
 198 
 199         public void setTableName(String tableName) {
 200             this.tableName = tableName;
 201         }
 202 
 203         public String getExecSql() {
 204             return execSql;
 205         }
 206 
 207         public void setExecSql(String execSql) {
 208             this.execSql = execSql;
 209         }
 210 
 211         public String getFieldsInfoStr() {
 212             return fieldsInfoStr;
 213         }
 214 
 215         public void setFieldsInfoStr(String fieldsInfoStr) {
 216             this.fieldsInfoStr = fieldsInfoStr;
 217         }
 218 
 219         public void addSourceTable(String sourceTable){
 220             sourceTableList.add(sourceTable);
 221         }
 222 
 223         public List&lt;String&gt; getSourceTableList() {
 224             return sourceTableList;
 225         }
 226 
 227     }
 228 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.parser;
  22 
  23 import com.dtstack.flink.sql.util.DtStringUtil;
  24 import org.apache.calcite.sql.SqlBasicCall;
  25 import org.apache.calcite.sql.SqlJoin;
  26 import org.apache.calcite.sql.SqlKind;
  27 import org.apache.calcite.sql.SqlNode;
  28 import org.apache.calcite.sql.SqlSelect;
  29 import com.google.common.collect.Lists;
  30 import org.apache.flink.table.calcite.FlinkPlannerImpl;
  31 
  32 import java.util.List;
  33 import java.util.regex.Matcher;
  34 import java.util.regex.Pattern;
  35 
  36 import static org.apache.calcite.sql.SqlKind.IDENTIFIER;
  37 
  38 /**
  39  * parser create tmp table sql
  40  * Date: 2018/6/26
  41  * Company: www.dtstack.com
  42  * @author yanxi
  43  */
  44 public class CreateTmpTableParser implements IParser {
  45 
  46     //select table tableName as select
  47     private static final String PATTERN_STR = &quot;(?i)create\\s+view\\s+([^\\s]+)\\s+as\\s+select\\s+(.*)&quot;;
  48 
  49     private static final String EMPTY_STR = &quot;(?i)^\\screate\\s+view\\s+(\\S+)\\s*\\((.+)\\)$&quot;;
  50 
  51     private static final Pattern NONEMPTYVIEW = Pattern.compile(PATTERN_STR);
  52 
  53     private static final Pattern EMPTYVIEW = Pattern.compile(EMPTY_STR);
  54 
  55     public static CreateTmpTableParser newInstance(){
  56         return new CreateTmpTableParser();
  57     }
  58 
  59     @Override
  60     public boolean verify(String sql) {
  61         if (Pattern.compile(EMPTY_STR).matcher(sql).find()){
  62             return true;
  63         }
  64         return NONEMPTYVIEW.matcher(sql).find();
  65     }
  66 
  67     @Override
  68     public void parseSql(String sql, SqlTree sqlTree) {
  69         if (NONEMPTYVIEW.matcher(sql).find()){
  70             Matcher matcher = NONEMPTYVIEW.matcher(sql);
  71             String tableName = null;
  72             String selectSql = null;
  73             if(matcher.find()) {
  74                 tableName = matcher.group(1);
  75                 selectSql = &quot;select &quot; + matcher.group(2);
  76             }
  77             FlinkPlannerImpl flinkPlanner = FlinkPlanner.getFlinkPlanner();
  78 
  79             SqlNode sqlNode = null;
  80             try {
  81                 sqlNode = flinkPlanner.parse(selectSql);
  82             } catch (Exception e) {
  83                 throw new RuntimeException(&quot;&quot;, e);
  84             }
  85 
<abbr title="  86             CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResult();">  86             CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResul🔵</abbr>
  87             parseNode(sqlNode, sqlParseResult);
  88 
  89             sqlParseResult.setTableName(tableName);
  90             String transformSelectSql = DtStringUtil.replaceIgnoreQuota(sqlNode.toString(), &quot;`&quot;, &quot;&quot;);
  91             sqlParseResult.setExecSql(transformSelectSql);
  92             sqlTree.addTmpSql(sqlParseResult);
  93             sqlTree.addTmplTableInfo(tableName, sqlParseResult);
  94         } else {
  95             if (EMPTYVIEW.matcher(sql).find())
  96             {
  97                 Matcher matcher = EMPTYVIEW.matcher(sql);
  98                 String tableName = null;
  99                 String fieldsInfoStr = null;
 100                 if (matcher.find()){
 101                     tableName = matcher.group(1);
 102                     fieldsInfoStr = matcher.group(2);
 103                 }
<abbr title=" 104                 CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResult();"> 104                 CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserR🔵</abbr>
 105                 sqlParseResult.setFieldsInfoStr(fieldsInfoStr);
 106                 sqlParseResult.setTableName(tableName);
 107                 sqlTree.addTmplTableInfo(tableName, sqlParseResult);
 108             }
 109 
 110         }
 111 
 112     }
 113 
 114     private static void parseNode(SqlNode sqlNode, CreateTmpTableParser.SqlParserResult sqlParseResult){
 115         SqlKind sqlKind = sqlNode.getKind();
 116         switch (sqlKind){
 117             case SELECT:
 118                 SqlNode sqlFrom = ((SqlSelect)sqlNode).getFrom();
 119                 if(sqlFrom.getKind() == IDENTIFIER){
 120                     sqlParseResult.addSourceTable(sqlFrom.toString());
 121                 }else{
 122                     parseNode(sqlFrom, sqlParseResult);
 123                 }
 124                 break;
 125             case JOIN:
 126                 SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 127                 SqlNode rightNode = ((SqlJoin)sqlNode).getRight();
 128 
 129                 if(leftNode.getKind() == IDENTIFIER){
 130                     sqlParseResult.addSourceTable(leftNode.toString());
 131                 }else{
 132                     parseNode(leftNode, sqlParseResult);
 133                 }
 134 
 135                 if(rightNode.getKind() == IDENTIFIER){
 136                     sqlParseResult.addSourceTable(rightNode.toString());
 137                 }else{
 138                     parseNode(rightNode, sqlParseResult);
 139                 }
 140                 break;
 141             case AS:
 142                 //不解析column,所以 as 相关的都是表
 143                 SqlNode identifierNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 144                 if(identifierNode.getKind() != IDENTIFIER){
 145                     parseNode(identifierNode, sqlParseResult);
 146                 }else {
 147                     sqlParseResult.addSourceTable(identifierNode.toString());
 148                 }
 149                 break;
 150             case UNION:
 151                 SqlNode unionLeft = ((SqlBasicCall)sqlNode).getOperands()[0];
 152                 SqlNode unionRight = ((SqlBasicCall)sqlNode).getOperands()[1];
 153                 if(unionLeft.getKind() == IDENTIFIER){
 154                     sqlParseResult.addSourceTable(unionLeft.toString());
 155                 }else{
 156                     parseNode(unionLeft, sqlParseResult);
 157                 }
 158                 if(unionRight.getKind() == IDENTIFIER){
 159                     sqlParseResult.addSourceTable(unionRight.toString());
 160                 }else{
 161                     parseNode(unionRight, sqlParseResult);
 162                 }
 163                 break;
 164             default:
 165                 //do nothing
 166                 break;
 167         }
 168     }
 169 
 170     public static class SqlParserResult {
 171         private String tableName;
 172 
 173         private String fieldsInfoStr;
 174 
 175         private String execSql;
 176 
 177         private List&lt;String&gt; sourceTableList = Lists.newArrayList();
 178 
 179         public String getTableName() {
 180             return tableName;
 181         }
 182 
 183         public void setTableName(String tableName) {
 184             this.tableName = tableName;
 185         }
 186 
 187         public String getExecSql() {
 188             return execSql;
 189         }
 190 
 191         public void setExecSql(String execSql) {
 192             this.execSql = execSql;
 193         }
 194 
 195         public String getFieldsInfoStr() {
 196             return fieldsInfoStr;
 197         }
 198 
 199         public void setFieldsInfoStr(String fieldsInfoStr) {
 200             this.fieldsInfoStr = fieldsInfoStr;
 201         }
 202 
 203         public void addSourceTable(String sourceTable){
 204             sourceTableList.add(sourceTable);
 205         }
 206 
 207         public List&lt;String&gt; getSourceTableList() {
 208             return sourceTableList;
 209         }
 210 
 211     }
 212 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.parser;
  19 
  20 import com.dtstack.flink.sql.util.DtStringUtil;
  21 import com.google.common.collect.Lists;
  22 import java.util.List;
  23 import java.util.regex.Matcher;
  24 import java.util.regex.Pattern;
  25 import org.apache.calcite.sql.SqlBasicCall;
  26 import org.apache.calcite.sql.SqlJoin;
  27 import org.apache.calcite.sql.SqlKind;
  28 import org.apache.calcite.sql.SqlNode;
  29 import org.apache.calcite.sql.SqlSelect;
  30 import org.apache.flink.table.calcite.FlinkPlannerImpl;
  31 import static org.apache.calcite.sql.SqlKind.IDENTIFIER;
  32 
  33 
  34 /**
  35  * parser create tmp table sql
  36  * Date: 2018/6/26
  37  * Company: www.dtstack.com
  38  * @author yanxi
  39  */
  40 public class CreateTmpTableParser implements IParser {
  41     //select table tableName as select
  42     //select table tableName as select
  43     private static final String PATTERN_STR = &quot;(?i)create\\s+view\\s+([^\\s]+)\\s+as\\s+select\\s+(.*)&quot;;
  44 
  45     private static final String EMPTY_STR = &quot;(?i)^\\screate\\s+view\\s+(\\S+)\\s*\\((.+)\\)$&quot;;
  46 
  47     private static final Pattern NONEMPTYVIEW = Pattern.compile(PATTERN_STR);
  48 
  49     private static final Pattern EMPTYVIEW = Pattern.compile(EMPTY_STR);
  50 
  51     public static CreateTmpTableParser newInstance(){
  52         return new CreateTmpTableParser();
  53     }
  54 
  55     @Override
  56     public boolean verify(String sql) {
  57         if (Pattern.compile(EMPTY_STR).matcher(sql).find()){
  58             return true;
  59         }
  60         return NONEMPTYVIEW.matcher(sql).find();
  61     }
  62 
  63     @Override
  64     public void parseSql(String sql, SqlTree sqlTree) {
  65         if (NONEMPTYVIEW.matcher(sql).find()) {
  66             Matcher matcher = NONEMPTYVIEW.matcher(sql);
  67             String tableName = null;
  68             String selectSql = null;
  69             if (matcher.find()) {
  70                 tableName = matcher.group(1);
  71                 selectSql = &quot;select &quot; + matcher.group(2);
  72             }
  73             FlinkPlannerImpl flinkPlanner = FlinkPlanner.getFlinkPlanner();
  74             SqlNode sqlNode = null;
  75             try {
  76                 sqlNode = flinkPlanner.parse(selectSql);
  77             } catch (java.lang.Exception e) {
  78                 throw new RuntimeException(&quot;&quot;, e);
  79             }
<abbr title="  80             CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResult();">  80             CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResul🔵</abbr>
  81             parseNode(sqlNode, sqlParseResult);
  82             sqlParseResult.setTableName(tableName);
  83             String transformSelectSql = DtStringUtil.replaceIgnoreQuota(sqlNode.toString(), &quot;`&quot;, &quot;&quot;);
  84             sqlParseResult.setExecSql(transformSelectSql);
  85             sqlTree.addTmpSql(sqlParseResult);
  86             sqlTree.addTmplTableInfo(tableName, sqlParseResult);
  87         } else if (EMPTYVIEW.matcher(sql).find()) {
  88             Matcher matcher = EMPTYVIEW.matcher(sql);
  89             String tableName = null;
  90             String fieldsInfoStr = null;
  91             if (matcher.find()) {
  92                 tableName = matcher.group(1);
  93                 fieldsInfoStr = matcher.group(2);
  94             }
<abbr title="  95             CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResult();">  95             CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResul🔵</abbr>
  96             sqlParseResult.setFieldsInfoStr(fieldsInfoStr);
  97             sqlParseResult.setTableName(tableName);
  98             sqlTree.addTmplTableInfo(tableName, sqlParseResult);
  99         }
 100     }
 101 
 102     private static void parseNode(SqlNode sqlNode, CreateTmpTableParser.SqlParserResult sqlParseResult) {
 103         SqlKind sqlKind = sqlNode.getKind();
 104         switch (sqlKind) {
 105             case SELECT :
 106                 SqlNode sqlFrom = ((SqlSelect) (sqlNode)).getFrom();
 107                 if (sqlFrom.getKind() == IDENTIFIER) {
 108                     sqlParseResult.addSourceTable(sqlFrom.toString());
 109                 } else {
 110                     parseNode(sqlFrom, sqlParseResult);
 111                 }
 112                 break;
 113             case JOIN :
 114                 SqlNode leftNode = ((SqlJoin) (sqlNode)).getLeft();
 115                 SqlNode rightNode = ((SqlJoin) (sqlNode)).getRight();
 116                 if (leftNode.getKind() == IDENTIFIER) {
 117                     sqlParseResult.addSourceTable(leftNode.toString());
 118                 } else {
 119                     parseNode(leftNode, sqlParseResult);
 120                 }
 121                 if (rightNode.getKind() == IDENTIFIER) {
 122                     sqlParseResult.addSourceTable(rightNode.toString());
 123                 } else {
 124                     parseNode(rightNode, sqlParseResult);
 125                 }
 126                 break;
 127             case AS :
 128                 //不解析column,所以 as 相关的都是表
 129                 SqlNode identifierNode = ((SqlBasicCall) (sqlNode)).getOperands()[0];
 130                 if (identifierNode.getKind() != IDENTIFIER) {
 131                     parseNode(identifierNode, sqlParseResult);
 132                 } else {
 133                     sqlParseResult.addSourceTable(identifierNode.toString());
 134                 }
 135                 break;
 136             case UNION :
 137                 SqlNode unionLeft = ((SqlBasicCall) (sqlNode)).getOperands()[0];
 138                 SqlNode unionRight = ((SqlBasicCall) (sqlNode)).getOperands()[1];
 139                 if (unionLeft.getKind() == IDENTIFIER) {
 140                     sqlParseResult.addSourceTable(unionLeft.toString());
 141                 } else {
 142                     parseNode(unionLeft, sqlParseResult);
 143                 }
 144                 if (unionRight.getKind() == IDENTIFIER) {
 145                     sqlParseResult.addSourceTable(unionRight.toString());
 146                 } else {
 147                     parseNode(unionRight, sqlParseResult);
 148                 }
 149                 break;
 150             default :
 151                 // do nothing
 152                 break;
 153         }
 154     }
 155 
 156     public static class SqlParserResult {
 157         private String tableName;
 158 
 159         private String fieldsInfoStr;
 160 
 161         private String execSql;
 162 
 163         private List&lt;String&gt; sourceTableList = Lists.newArrayList();
 164 
 165         public String getTableName() {
 166             return tableName;
 167         }
 168 
 169         public void setTableName(String tableName) {
 170             this.tableName = tableName;
 171         }
 172 
 173         public String getExecSql() {
 174             return execSql;
 175         }
 176 
 177         public void setExecSql(String execSql) {
 178             this.execSql = execSql;
 179         }
 180 
 181         public String getFieldsInfoStr() {
 182             return fieldsInfoStr;
 183         }
 184 
 185         public void setFieldsInfoStr(String fieldsInfoStr) {
 186             this.fieldsInfoStr = fieldsInfoStr;
 187         }
 188 
 189         public void addSourceTable(String sourceTable) {
 190             sourceTableList.add(sourceTable);
 191         }
 192 
 193         public List&lt;String&gt; getSourceTableList() {
 194             return sourceTableList;
 195         }
 196     }
 197 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.parser;
  22  
  23  import com.dtstack.flink.sql.util.DtStringUtil;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  24 -import org.apache.calcite.config.Lex;</span>
  25  import org.apache.calcite.sql.*;





<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  26 -import org.apache.calcite.sql.parser.SqlParseException;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  27 -import org.apache.calcite.sql.parser.SqlParser;</span>
  28  import com.google.common.collect.Lists;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 +import org.apache.flink.table.calcite.FlinkPlannerImpl;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  30 +</span>
  31  import java.util.List;
  32  import java.util.regex.Matcher;
  33  import java.util.regex.Pattern;
  34  
  35  import static org.apache.calcite.sql.SqlKind.IDENTIFIER;
  36  
  37  /**
  38   * parser create tmp table sql
  39   * Date: 2018/6/26
  40   * Company: www.dtstack.com
  41   * @author yanxi
  42   */
  43  public class CreateTmpTableParser implements IParser {
  44  
  45      //select table tableName as select
  46      private static final String PATTERN_STR = &quot;(?i)create\\s+view\\s+([^\\s]+)\\s+as\\s+select\\s+(.*)&quot;;
  47  
  48      private static final String EMPTY_STR = &quot;(?i)^\\screate\\s+view\\s+(\\S+)\\s*\\((.+)\\)$&quot;;
  49  
  50      private static final Pattern NONEMPTYVIEW = Pattern.compile(PATTERN_STR);
  51  
  52      private static final Pattern EMPTYVIEW = Pattern.compile(EMPTY_STR);
  53  
  54      public static CreateTmpTableParser newInstance(){
  55          return new CreateTmpTableParser();
  56      }
  57  
  58      @Override
  59      public boolean verify(String sql) {
  60          if (Pattern.compile(EMPTY_STR).matcher(sql).find()){
  61              return true;
  62          }
  63          return NONEMPTYVIEW.matcher(sql).find();
  64      }
  65  
  66      @Override
  67      public void parseSql(String sql, SqlTree sqlTree) {
  68          if (NONEMPTYVIEW.matcher(sql).find()){
  69              Matcher matcher = NONEMPTYVIEW.matcher(sql);
  70              String tableName = null;
  71              String selectSql = null;
  72              if(matcher.find()) {
  73                  tableName = matcher.group(1);
  74                  selectSql = &quot;select &quot; + matcher.group(2);
  75              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  76 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  77 -            SqlParser.Config config = SqlParser</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  78 -                    .configBuilder()</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  79 -                    .setLex(Lex.MYSQL)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  80 -                    .build();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  81 -            SqlParser sqlParser = SqlParser.create(selectSql,config);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  82 +            FlinkPlannerImpl flinkPlanner = FlinkPlanner.getFlinkPlanner();</span>
  83  
  84              SqlNode sqlNode = null;
  85              try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  86 -                sqlNode = sqlParser.parseStmt();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  87 -            } catch (SqlParseException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  88 +                sqlNode = flinkPlanner.parse(selectSql);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  89 +            } catch (Exception e) {</span>
  90                  throw new RuntimeException(&quot;&quot;, e);
  91              }
  92  
  93              CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResult();
  94              parseNode(sqlNode, sqlParseResult);
  95  
  96              sqlParseResult.setTableName(tableName);
  97              String transformSelectSql = DtStringUtil.replaceIgnoreQuota(sqlNode.toString(), &quot;`&quot;, &quot;&quot;);
  98              sqlParseResult.setExecSql(transformSelectSql);
  99              sqlTree.addTmpSql(sqlParseResult);
 100              sqlTree.addTmplTableInfo(tableName, sqlParseResult);
 101          } else {
 102              if (EMPTYVIEW.matcher(sql).find())
 103              {
 104                  Matcher matcher = EMPTYVIEW.matcher(sql);
 105                  String tableName = null;
 106                  String fieldsInfoStr = null;
 107                  if (matcher.find()){
 108                      tableName = matcher.group(1);
 109                      fieldsInfoStr = matcher.group(2);
 110                  }
 111                  CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResult();
 112                  sqlParseResult.setFieldsInfoStr(fieldsInfoStr);
 113                  sqlParseResult.setTableName(tableName);
 114                  sqlTree.addTmplTableInfo(tableName, sqlParseResult);
 115              }
 116  
 117          }
 118  
 119      }
 120  
 121      private static void parseNode(SqlNode sqlNode, CreateTmpTableParser.SqlParserResult sqlParseResult){
 122          SqlKind sqlKind = sqlNode.getKind();
 123          switch (sqlKind){
 124              case SELECT:
 125                  SqlNode sqlFrom = ((SqlSelect)sqlNode).getFrom();
 126                  if(sqlFrom.getKind() == IDENTIFIER){
 127                      sqlParseResult.addSourceTable(sqlFrom.toString());
 128                  }else{
 129                      parseNode(sqlFrom, sqlParseResult);
 130                  }
 131                  break;
 132              case JOIN:
 133                  SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 134                  SqlNode rightNode = ((SqlJoin)sqlNode).getRight();
 135  
 136                  if(leftNode.getKind() == IDENTIFIER){
 137                      sqlParseResult.addSourceTable(leftNode.toString());
 138                  }else{
 139                      parseNode(leftNode, sqlParseResult);
 140                  }
 141  
 142                  if(rightNode.getKind() == IDENTIFIER){
 143                      sqlParseResult.addSourceTable(rightNode.toString());
 144                  }else{
 145                      parseNode(rightNode, sqlParseResult);
 146                  }
 147                  break;
 148              case AS:
 149                  //不解析column,所以 as 相关的都是表
 150                  SqlNode identifierNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 151                  if(identifierNode.getKind() != IDENTIFIER){
 152                      parseNode(identifierNode, sqlParseResult);
 153                  }else {
 154                      sqlParseResult.addSourceTable(identifierNode.toString());
 155                  }
 156                  break;
 157              case UNION:
 158                  SqlNode unionLeft = ((SqlBasicCall)sqlNode).getOperands()[0];
 159                  SqlNode unionRight = ((SqlBasicCall)sqlNode).getOperands()[1];
 160                  if(unionLeft.getKind() == IDENTIFIER){
 161                      sqlParseResult.addSourceTable(unionLeft.toString());
 162                  }else{
 163                      parseNode(unionLeft, sqlParseResult);
 164                  }
 165                  if(unionRight.getKind() == IDENTIFIER){
 166                      sqlParseResult.addSourceTable(unionRight.toString());
 167                  }else{
 168                      parseNode(unionRight, sqlParseResult);
 169                  }
 170                  break;
 171              default:
 172                  //do nothing
 173                  break;
 174          }
 175      }
 176  
 177      public static class SqlParserResult {
 178          private String tableName;
 179  
 180          private String fieldsInfoStr;
 181  
 182          private String execSql;
 183  
 184          private List&lt;String&gt; sourceTableList = Lists.newArrayList();
 185  
 186          public String getTableName() {
 187              return tableName;
 188          }
 189  
 190          public void setTableName(String tableName) {
 191              this.tableName = tableName;
 192          }
 193  
 194          public String getExecSql() {
 195              return execSql;
 196          }
 197  
 198          public void setExecSql(String execSql) {
 199              this.execSql = execSql;
 200          }
 201  
 202          public String getFieldsInfoStr() {
 203              return fieldsInfoStr;
 204          }
 205  
 206          public void setFieldsInfoStr(String fieldsInfoStr) {
 207              this.fieldsInfoStr = fieldsInfoStr;
 208          }
 209  
 210          public void addSourceTable(String sourceTable){
 211              sourceTableList.add(sourceTable);
 212          }
 213  
 214          public List&lt;String&gt; getSourceTableList() {
 215              return sourceTableList;
 216          }
 217  
 218      }
 219  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.parser;
  22  
  23  import com.dtstack.flink.sql.util.DtStringUtil;
  24  import org.apache.calcite.config.Lex;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  25 -import org.apache.calcite.sql.*;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  26 +import org.apache.calcite.sql.SqlBasicCall;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  27 +import org.apache.calcite.sql.SqlJoin;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  28 +import org.apache.calcite.sql.SqlKind;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 +import org.apache.calcite.sql.SqlNode;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  30 +import org.apache.calcite.sql.SqlSelect;</span>
  31  import org.apache.calcite.sql.parser.SqlParseException;
  32  import org.apache.calcite.sql.parser.SqlParser;
  33  import com.google.common.collect.Lists;


  34  import java.util.List;
  35  import java.util.regex.Matcher;
  36  import java.util.regex.Pattern;
  37  
  38  import static org.apache.calcite.sql.SqlKind.IDENTIFIER;
  39  
  40  /**
  41   * parser create tmp table sql
  42   * Date: 2018/6/26
  43   * Company: www.dtstack.com
  44   * @author yanxi
  45   */
  46  public class CreateTmpTableParser implements IParser {
  47  
  48      //select table tableName as select
  49      private static final String PATTERN_STR = &quot;(?i)create\\s+view\\s+([^\\s]+)\\s+as\\s+select\\s+(.*)&quot;;
  50  
  51      private static final String EMPTY_STR = &quot;(?i)^\\screate\\s+view\\s+(\\S+)\\s*\\((.+)\\)$&quot;;
  52  
  53      private static final Pattern NONEMPTYVIEW = Pattern.compile(PATTERN_STR);
  54  
  55      private static final Pattern EMPTYVIEW = Pattern.compile(EMPTY_STR);
  56  
  57      public static CreateTmpTableParser newInstance(){
  58          return new CreateTmpTableParser();
  59      }
  60  
  61      @Override
  62      public boolean verify(String sql) {
  63          if (Pattern.compile(EMPTY_STR).matcher(sql).find()){
  64              return true;
  65          }
  66          return NONEMPTYVIEW.matcher(sql).find();
  67      }
  68  
  69      @Override
  70      public void parseSql(String sql, SqlTree sqlTree) {
  71          if (NONEMPTYVIEW.matcher(sql).find()){
  72              Matcher matcher = NONEMPTYVIEW.matcher(sql);
  73              String tableName = null;
  74              String selectSql = null;
  75              if(matcher.find()) {
  76                  tableName = matcher.group(1);
  77                  selectSql = &quot;select &quot; + matcher.group(2);
  78              }
  79  
  80              SqlParser.Config config = SqlParser
  81                      .configBuilder()
  82                      .setLex(Lex.MYSQL)
  83                      .build();
  84              SqlParser sqlParser = SqlParser.create(selectSql,config);

  85  
  86              SqlNode sqlNode = null;
  87              try {
  88                  sqlNode = sqlParser.parseStmt();
  89              } catch (SqlParseException e) {


  90                  throw new RuntimeException(&quot;&quot;, e);
  91              }
  92  
  93              CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResult();
  94              parseNode(sqlNode, sqlParseResult);
  95  
  96              sqlParseResult.setTableName(tableName);
  97              String transformSelectSql = DtStringUtil.replaceIgnoreQuota(sqlNode.toString(), &quot;`&quot;, &quot;&quot;);
  98              sqlParseResult.setExecSql(transformSelectSql);
  99              sqlTree.addTmpSql(sqlParseResult);
 100              sqlTree.addTmplTableInfo(tableName, sqlParseResult);
 101          } else {
 102              if (EMPTYVIEW.matcher(sql).find())
 103              {
 104                  Matcher matcher = EMPTYVIEW.matcher(sql);
 105                  String tableName = null;
 106                  String fieldsInfoStr = null;
 107                  if (matcher.find()){
 108                      tableName = matcher.group(1);
 109                      fieldsInfoStr = matcher.group(2);
 110                  }
 111                  CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResult();
 112                  sqlParseResult.setFieldsInfoStr(fieldsInfoStr);
 113                  sqlParseResult.setTableName(tableName);
 114                  sqlTree.addTmplTableInfo(tableName, sqlParseResult);
 115              }
 116  
 117          }
 118  
 119      }
 120  
 121      private static void parseNode(SqlNode sqlNode, CreateTmpTableParser.SqlParserResult sqlParseResult){
 122          SqlKind sqlKind = sqlNode.getKind();
 123          switch (sqlKind){
 124              case SELECT:
 125                  SqlNode sqlFrom = ((SqlSelect)sqlNode).getFrom();
 126                  if(sqlFrom.getKind() == IDENTIFIER){
 127                      sqlParseResult.addSourceTable(sqlFrom.toString());
 128                  }else{
 129                      parseNode(sqlFrom, sqlParseResult);
 130                  }
 131                  break;
 132              case JOIN:
 133                  SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 134                  SqlNode rightNode = ((SqlJoin)sqlNode).getRight();
 135  
 136                  if(leftNode.getKind() == IDENTIFIER){
 137                      sqlParseResult.addSourceTable(leftNode.toString());
 138                  }else{
 139                      parseNode(leftNode, sqlParseResult);
 140                  }
 141  
 142                  if(rightNode.getKind() == IDENTIFIER){
 143                      sqlParseResult.addSourceTable(rightNode.toString());
 144                  }else{
 145                      parseNode(rightNode, sqlParseResult);
 146                  }
 147                  break;
 148              case AS:
 149                  //不解析column,所以 as 相关的都是表
 150                  SqlNode identifierNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 151                  if(identifierNode.getKind() != IDENTIFIER){
 152                      parseNode(identifierNode, sqlParseResult);
 153                  }else {
 154                      sqlParseResult.addSourceTable(identifierNode.toString());
 155                  }
 156                  break;
 157              case UNION:
 158                  SqlNode unionLeft = ((SqlBasicCall)sqlNode).getOperands()[0];
 159                  SqlNode unionRight = ((SqlBasicCall)sqlNode).getOperands()[1];
 160                  if(unionLeft.getKind() == IDENTIFIER){
 161                      sqlParseResult.addSourceTable(unionLeft.toString());
 162                  }else{
 163                      parseNode(unionLeft, sqlParseResult);
 164                  }
 165                  if(unionRight.getKind() == IDENTIFIER){
 166                      sqlParseResult.addSourceTable(unionRight.toString());
 167                  }else{
 168                      parseNode(unionRight, sqlParseResult);
 169                  }
 170                  break;
 171              default:
 172                  //do nothing
 173                  break;
 174          }
 175      }
 176  
 177      public static class SqlParserResult {
 178          private String tableName;
 179  
 180          private String fieldsInfoStr;
 181  
 182          private String execSql;
 183  
 184          private List&lt;String&gt; sourceTableList = Lists.newArrayList();
 185  
 186          public String getTableName() {
 187              return tableName;
 188          }
 189  
 190          public void setTableName(String tableName) {
 191              this.tableName = tableName;
 192          }
 193  
 194          public String getExecSql() {
 195              return execSql;
 196          }
 197  
 198          public void setExecSql(String execSql) {
 199              this.execSql = execSql;
 200          }
 201  
 202          public String getFieldsInfoStr() {
 203              return fieldsInfoStr;
 204          }
 205  
 206          public void setFieldsInfoStr(String fieldsInfoStr) {
 207              this.fieldsInfoStr = fieldsInfoStr;
 208          }
 209  
 210          public void addSourceTable(String sourceTable){
 211              sourceTableList.add(sourceTable);
 212          }
 213  
 214          public List&lt;String&gt; getSourceTableList() {
 215              return sourceTableList;
 216          }
 217  
 218      }
 219  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            