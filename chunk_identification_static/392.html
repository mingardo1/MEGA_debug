<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>392</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    392
                    <a href="391.html">prev</a>
                    <a href="393.html">next</a>
                    <a href="392_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_69925bb1923f86f4b590962cdcd4299b98b9f30d_src/com/android/launcher3/LauncherModel.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;69925bb1923f86f4b590962cdcd4299b98b9f30d:src/com/android/launcher3/LauncherModel.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;69925bb1923f86f4b590962cdcd4299b98b9f30d^1:src/com/android/launcher3/LauncherModel.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;69925bb1923f86f4b590962cdcd4299b98b9f30d^2:src/com/android/launcher3/LauncherModel.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;298a9c61853b7460d5dbe14429f05f8f2deed6bc:src/com/android/launcher3/LauncherModel.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b]], subset: [[b], [b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher3;
  18 
  19 import android.app.SearchManager;
  20 import android.appwidget.AppWidgetManager;
  21 import android.appwidget.AppWidgetProviderInfo;
  22 import android.content.BroadcastReceiver;
  23 import android.content.ComponentName;
  24 import android.content.ContentProviderClient;
  25 import android.content.ContentProviderOperation;
  26 import android.content.ContentResolver;
  27 import android.content.ContentValues;
  28 import android.content.Context;
  29 import android.content.Intent;
  30 import android.content.Intent.ShortcutIconResource;
  31 import android.content.IntentFilter;
  32 import android.content.SharedPreferences;
  33 import android.content.pm.PackageManager;
  34 import android.content.pm.ProviderInfo;
  35 import android.content.pm.ResolveInfo;
  36 import android.content.res.Configuration;
  37 import android.content.res.Resources;
  38 import android.database.Cursor;
  39 import android.graphics.Bitmap;
  40 import android.graphics.BitmapFactory;
  41 import android.net.Uri;
  42 import android.os.Environment;
  43 import android.os.Handler;
  44 import android.os.HandlerThread;
  45 import android.os.Parcelable;
  46 import android.os.Process;
  47 import android.os.RemoteException;
  48 import android.os.SystemClock;
  49 import android.provider.BaseColumns;
  50 import android.text.TextUtils;
  51 import android.util.Log;
  52 import android.util.Pair;
  53 
  54 import com.android.launcher3.compat.AppWidgetManagerCompat;
  55 import com.android.launcher3.compat.LauncherActivityInfoCompat;
  56 import com.android.launcher3.compat.LauncherAppsCompat;
  57 import com.android.launcher3.compat.PackageInstallerCompat;
  58 import com.android.launcher3.compat.PackageInstallerCompat.PackageInstallInfo;
  59 import com.android.launcher3.compat.UserHandleCompat;
  60 import com.android.launcher3.compat.UserManagerCompat;
  61 
  62 import java.lang.ref.WeakReference;
  63 import java.net.URISyntaxException;
  64 import java.security.InvalidParameterException;
  65 import java.text.Collator;
  66 import java.util.ArrayList;
  67 import java.util.Arrays;
  68 import java.util.Collection;
  69 import java.util.Collections;
  70 import java.util.Comparator;
  71 import java.util.HashMap;
  72 import java.util.HashSet;
  73 import java.util.Iterator;
  74 import java.util.List;
  75 import java.util.Map.Entry;
  76 import java.util.Set;
  77 import java.util.TreeMap;
  78 import java.util.concurrent.atomic.AtomicBoolean;
  79 
  80 /**
  81  * Maintains in-memory state of the Launcher. It is expected that there should be only one
  82  * LauncherModel object held in a static. Also provide APIs for updating the database state
  83  * for the Launcher.
  84  */
  85 public class LauncherModel extends BroadcastReceiver
  86         implements LauncherAppsCompat.OnAppsChangedCallbackCompat {
  87     static final boolean DEBUG_LOADERS = false;
  88     private static final boolean DEBUG_RECEIVER = false;
  89     private static final boolean REMOVE_UNRESTORED_ICONS = true;
  90 
  91     static final String TAG = &quot;Launcher.Model&quot;;
  92 
  93     // true = use a &quot;More Apps&quot; folder for non-workspace apps on upgrade
  94     // false = strew non-workspace apps across the workspace on upgrade
  95     public static final boolean UPGRADE_USE_MORE_APPS_FOLDER = false;
  96     public static final int LOADER_FLAG_NONE = 0;
  97     public static final int LOADER_FLAG_CLEAR_WORKSPACE = 1 &lt;&lt; 0;
  98     public static final int LOADER_FLAG_MIGRATE_SHORTCUTS = 1 &lt;&lt; 1;
  99 
 100     private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
 101     private static final long INVALID_SCREEN_ID = -1L;
 102 
 103     private final boolean mAppsCanBeOnRemoveableStorage;
 104     private final boolean mOldContentProviderExists;
 105 
 106     private final LauncherAppState mApp;
 107     private final Object mLock = new Object();
 108     private DeferredHandler mHandler = new DeferredHandler();
 109     private LoaderTask mLoaderTask;
 110     private boolean mIsLoaderTaskRunning;
 111     private volatile boolean mFlushingWorkerThread;
 112 
 113     // Specific runnable types that are run on the main thread deferred handler, this allows us to
 114     // clear all queued binding runnables when the Launcher activity is destroyed.
 115     private static final int MAIN_THREAD_NORMAL_RUNNABLE = 0;
 116     private static final int MAIN_THREAD_BINDING_RUNNABLE = 1;
 117 
 118     private static final String MIGRATE_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
 119 
 120     private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
 121     static {
 122         sWorkerThread.start();
 123     }
 124     private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
 125 
 126     // We start off with everything not loaded.  After that, we assume that
 127     // our monitoring of the package manager provides all updates and we never
 128     // need to do a requery.  These are only ever touched from the loader thread.
 129     private boolean mWorkspaceLoaded;
 130     private boolean mAllAppsLoaded;
 131 
 132     // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
 133     // pages as this delays the rotation process.  Instead, we wait for a callback from the first
 134     // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 135     // a normal load, we also clear this set of Runnables.
 136     static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 137 
 138     private WeakReference&lt;Callbacks&gt; mCallbacks;
 139 
 140     // &lt; only access in worker thread &gt;
 141     AllAppsList mBgAllAppsList;
 142 
 143     // The lock that must be acquired before referencing any static bg data structures.  Unlike
 144     // other locks, this one can generally be held long-term because we never expect any of these
 145     // static data structures to be referenced outside of the worker thread except on the first
 146     // load after configuration change.
 147     static final Object sBgLock = new Object();
 148 
 149     // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 150     // LauncherModel to their ids
 151     static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
 152 
 153     // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 154     //       created by LauncherModel that are directly on the home screen (however, no widgets or
 155     //       shortcuts within folders).
 156     static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 157 
 158     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 159     static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 160         new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 161 
 162     // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 163     static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 164 
 165     // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 166     static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 167 
 168     // sBgWorkspaceScreens is the ordered set of workspace screens.
 169     static final ArrayList&lt;Long&gt; sBgWorkspaceScreens = new ArrayList&lt;Long&gt;();
 170 
 171     // sPendingPackages is a set of packages which could be on sdcard and are not available yet
 172     static final HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; sPendingPackages =
 173             new HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt;();
 174 
 175     // &lt;/ only access in worker thread &gt;
 176 
 177     private IconCache mIconCache;
 178 
 179     protected int mPreviousConfigMcc;
 180 
 181     private final LauncherAppsCompat mLauncherApps;
 182     private final UserManagerCompat mUserManager;
 183 
 184     public interface Callbacks {
 185         public boolean setLoadOnResume();
 186         public int getCurrentWorkspaceScreen();
 187         public void startBinding();
 188         public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end,
 189                               boolean forceAnimateIcons);
 190         public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 191         public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 192         public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 193         public void finishBindingItems(boolean upgradePath);
 194         public void bindAppWidget(LauncherAppWidgetInfo info);
 195         public void bindAllApplications(ArrayList&lt;AppInfo&gt; apps);
 196         public void bindAppsAdded(ArrayList&lt;Long&gt; newScreens,
 197                                   ArrayList&lt;ItemInfo&gt; addNotAnimated,
 198                                   ArrayList&lt;ItemInfo&gt; addAnimated,
 199                                   ArrayList&lt;AppInfo&gt; addedApps);
 200         public void bindAppsUpdated(ArrayList&lt;AppInfo&gt; apps);
 201         public void bindAppsRestored(ArrayList&lt;AppInfo&gt; apps);
 202         public void updatePackageState(ArrayList&lt;PackageInstallInfo&gt; installInfo);
 203         public void updatePackageBadge(String packageName);
 204         public void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames,
 205                         ArrayList&lt;AppInfo&gt; appInfos, UserHandleCompat user);
 206         public void bindPackagesUpdated(ArrayList&lt;Object&gt; widgetsAndShortcuts);
 207         public void bindSearchablesChanged();
 208         public boolean isAllAppsButtonRank(int rank);
 209         public void onPageBoundSynchronously(int page);
 210         public void dumpLogsToLocalData();
 211     }
 212 
 213     public interface ItemInfoFilter {
 214         public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn);
 215     }
 216 
 217     LauncherModel(LauncherAppState app, IconCache iconCache, AppFilter appFilter) {
 218         Context context = app.getContext();
 219 
 220         mAppsCanBeOnRemoveableStorage = Environment.isExternalStorageRemovable();
 221         String oldProvider = context.getString(R.string.old_launcher_provider_uri);
 222         // This may be the same as MIGRATE_AUTHORITY, or it may be replaced by a different
 223         // resource string.
 224         String redirectAuthority = Uri.parse(oldProvider).getAuthority();
 225         ProviderInfo providerInfo =
 226                 context.getPackageManager().resolveContentProvider(MIGRATE_AUTHORITY, 0);
 227         ProviderInfo redirectProvider =
 228                 context.getPackageManager().resolveContentProvider(redirectAuthority, 0);
 229 
 230         Log.d(TAG, &quot;Old launcher provider: &quot; + oldProvider);
 231         mOldContentProviderExists = (providerInfo != null) &amp;&amp; (redirectProvider != null);
 232 
 233         if (mOldContentProviderExists) {
 234             Log.d(TAG, &quot;Old launcher provider exists.&quot;);
 235         } else {
 236             Log.d(TAG, &quot;Old launcher provider does not exist.&quot;);
 237         }
 238 
 239         mApp = app;
 240         mBgAllAppsList = new AllAppsList(iconCache, appFilter);
 241         mIconCache = iconCache;
 242 
 243         final Resources res = context.getResources();
 244         Configuration config = res.getConfiguration();
 245         mPreviousConfigMcc = config.mcc;
 246         mLauncherApps = LauncherAppsCompat.getInstance(context);
 247         mUserManager = UserManagerCompat.getInstance(context);
 248     }
 249 
 250     /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 251      * posted on the main thread handler. */
 252     private void runOnMainThread(Runnable r) {
 253         runOnMainThread(r, 0);
 254     }
 255     private void runOnMainThread(Runnable r, int type) {
 256         if (sWorkerThread.getThreadId() == Process.myTid()) {
 257             // If we are on the worker thread, post onto the main handler
 258             mHandler.post(r);
 259         } else {
 260             r.run();
 261         }
 262     }
 263 
 264     /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 265      * posted on the worker thread handler. */
 266     private static void runOnWorkerThread(Runnable r) {
 267         if (sWorkerThread.getThreadId() == Process.myTid()) {
 268             r.run();
 269         } else {
 270             // If we are not on the worker thread, then post to the worker handler
 271             sWorker.post(r);
 272         }
 273     }
 274 
 275     boolean canMigrateFromOldLauncherDb(Launcher launcher) {
 276         return mOldContentProviderExists &amp;&amp; !launcher.isLauncherPreinstalled() ;
 277     }
 278 
 279     static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;ItemInfo&gt; items, int[] xy,
 280                                  long screen) {
 281         LauncherAppState app = LauncherAppState.getInstance();
 282         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 283         final int xCount = (int) grid.numColumns;
 284         final int yCount = (int) grid.numRows;
 285         boolean[][] occupied = new boolean[xCount][yCount];
 286 
 287         int cellX, cellY, spanX, spanY;
 288         for (int i = 0; i &lt; items.size(); ++i) {
 289             final ItemInfo item = items.get(i);
 290             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 291                 if (item.screenId == screen) {
 292                     cellX = item.cellX;
 293                     cellY = item.cellY;
 294                     spanX = item.spanX;
 295                     spanY = item.spanY;
 296                     for (int x = cellX; 0 &lt;= x &amp;&amp; x &lt; cellX + spanX &amp;&amp; x &lt; xCount; x++) {
 297                         for (int y = cellY; 0 &lt;= y &amp;&amp; y &lt; cellY + spanY &amp;&amp; y &lt; yCount; y++) {
 298                             occupied[x][y] = true;
 299                         }
 300                     }
 301                 }
 302             }
 303         }
 304 
 305         return CellLayout.findVacantCell(xy, 1, 1, xCount, yCount, occupied);
 306     }
 307     static Pair&lt;Long, int[]&gt; findNextAvailableIconSpace(Context context, String name,
 308                                                         Intent launchIntent,
 309                                                         int firstScreenIndex,
 310                                                         ArrayList&lt;Long&gt; workspaceScreens) {
 311         // Lock on the app so that we don&#x27;t try and get the items while apps are being added
 312         LauncherAppState app = LauncherAppState.getInstance();
 313         LauncherModel model = app.getModel();
 314         boolean found = false;
 315         synchronized (app) {
 316             if (sWorkerThread.getThreadId() != Process.myTid()) {
 317                 // Flush the LauncherModel worker thread, so that if we just did another
 318                 // processInstallShortcut, we give it time for its shortcut to get added to the
 319                 // database (getItemsInLocalCoordinates reads the database)
 320                 model.flushWorkerThread();
 321             }
 322             final ArrayList&lt;ItemInfo&gt; items = LauncherModel.getItemsInLocalCoordinates(context);
 323 
 324             // Try adding to the workspace screens incrementally, starting at the default or center
 325             // screen and alternating between +1, -1, +2, -2, etc. (using ~ ceil(i/2f)*(-1)^(i-1))
 326             firstScreenIndex = Math.min(firstScreenIndex, workspaceScreens.size());
 327             int count = workspaceScreens.size();
 328             for (int screen = firstScreenIndex; screen &lt; count &amp;&amp; !found; screen++) {
 329                 int[] tmpCoordinates = new int[2];
 330                 if (findNextAvailableIconSpaceInScreen(items, tmpCoordinates,
 331                         workspaceScreens.get(screen))) {
 332                     // Update the Launcher db
 333                     return new Pair&lt;Long, int[]&gt;(workspaceScreens.get(screen), tmpCoordinates);
 334                 }
 335             }
 336         }
 337         return null;
 338     }
 339 
 340 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 341     public void setPackageState(final ArrayList&lt;PackageInstallInfo&gt; installInfo) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 342         // Process the updated package state</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 343         Runnable r = new Runnable() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 344             public void run() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 345                 Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 346                 if (callbacks != null) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 347                     callbacks.updatePackageState(installInfo);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 348                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 349             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 350         };</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 351         mHandler.post(r);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 352     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 353 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 354     public void updatePackageBadge(final String packageName) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 355         // Process the updated package badge</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 356         Runnable r = new Runnable() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 357             public void run() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 358                 Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 359                 if (callbacks != null) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 360                     callbacks.updatePackageBadge(packageName);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 361                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 362             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 363         };</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 364         mHandler.post(r);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 365     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 366 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 367     public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 368         final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 369 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 370         if (allAppsApps == null) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 371             throw new RuntimeException(&quot;allAppsApps must not be null&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 372         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 373         if (allAppsApps.isEmpty()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 374             return;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 375         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 376 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 377         final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 378         Iterator&lt;AppInfo&gt; iter = allAppsApps.iterator();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 379         while (iter.hasNext()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 380             ItemInfo a = iter.next();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 381             if (LauncherModel.appWasPromise(ctx, a.getIntent(), a.user)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 382                 restoredAppsFinal.add((AppInfo) a);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 383             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 384         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 385 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 386         // Process the newly added applications and add them to the database first</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 387         Runnable r = new Runnable() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 388             public void run() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 389                 runOnMainThread(new Runnable() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 390                     public void run() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 391                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 392                         if (callbacks == cb &amp;&amp; cb != null) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 393                             if (!restoredAppsFinal.isEmpty()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 394                                 for (AppInfo info : restoredAppsFinal) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 395                                     final Intent intent = info.getIntent();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 396                                     if (intent != null) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 397                                         mIconCache.deletePreloadedIcon(intent.getComponent(),</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 398                                                 info.user);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 399                                     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 400                                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 401                                 callbacks.bindAppsUpdated(restoredAppsFinal);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 402                             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 403                             callbacks.bindAppsAdded(null, null, null, allAppsApps);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 404                         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 405                     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 406                 });</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 407             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 408         };</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 409         runOnWorkerThread(r);</span>
 410 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 411     public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 412         final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 413 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 414         if (allAppsApps == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 415             throw new RuntimeException(&quot;allAppsApps must not be null&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 416         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 417         if (allAppsApps.isEmpty()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 418             return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 419         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 420 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 421         // Process the newly added applications and add them to the database first</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 422         Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 423             public void run() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 424                 runOnMainThread(new Runnable() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 425                     public void run() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 426                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 427                         if (callbacks == cb &amp;&amp; cb != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 428                             callbacks.bindAppsAdded(null, null, null, allAppsApps);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 429                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 430                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 431                 });</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 432             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 433         };</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 434         runOnWorkerThread(r);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 435     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 436 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 437     public void addAndBindAddedWorkspaceApps(final Context context,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 438             final ArrayList&lt;ItemInfo&gt; workspaceApps) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 439         final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 440 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 441         if (workspaceApps == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 442             throw new RuntimeException(&quot;workspaceApps and allAppsApps must not be null&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 443         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 444         if (workspaceApps.isEmpty()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 445             return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 446         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 447         // Process the newly added applications and add them to the database first</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 448         Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 449             public void run() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 450                 final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 451                 final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 452 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 453                 // Get the list of workspace screens.  We need to append to this list and</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 454                 // can not use sBgWorkspaceScreens because loadWorkspace() may not have been</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 455                 // called.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 456                 ArrayList&lt;Long&gt; workspaceScreens = new ArrayList&lt;Long&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 457                 TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(context);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 458                 for (Integer i : orderedScreens.keySet()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 459                     long screenId = orderedScreens.get(i);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 460                     workspaceScreens.add(screenId);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 461                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 462 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 463                 synchronized(sBgLock) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 464                     Iterator&lt;ItemInfo&gt; iter = workspaceApps.iterator();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 465                     while (iter.hasNext()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 466                         ItemInfo a = iter.next();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 467                         final String name = a.title.toString();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 468                         final Intent launchIntent = a.getIntent();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 469 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 470                         // Short-circuit this logic if the icon exists somewhere on the workspace</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 471                         if (LauncherModel.shortcutExists(context, name, launchIntent)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 472                             continue;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 473                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 474 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 475                         // Add this icon to the db, creating a new page if necessary.  If there</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 476                         // is only the empty page then we just add items to the first page.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 477                         // Otherwise, we add them to the next pages.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 478                         int startSearchPageIndex = workspaceScreens.isEmpty() ? 0 : 1;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 479                         Pair&lt;Long, int[]&gt; coords = LauncherModel.findNextAvailableIconSpace(context,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 480                                 name, launchIntent, startSearchPageIndex, workspaceScreens);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 481                         if (coords == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 482                             LauncherProvider lp = LauncherAppState.getLauncherProvider();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 483 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 484                             // If we can&#x27;t find a valid position, then just add a new screen.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 485                             // This takes time so we need to re-queue the add until the new</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 486                             // page is added.  Create as many screens as necessary to satisfy</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 487                             // the startSearchPageIndex.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 488                             int numPagesToAdd = Math.max(1, startSearchPageIndex + 1 -</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 489                                     workspaceScreens.size());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 490                             while (numPagesToAdd &gt; 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 491                                 long screenId = lp.generateNewScreenId();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 492                                 // Save the screen id for binding in the workspace</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 493                                 workspaceScreens.add(screenId);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 494                                 addedWorkspaceScreensFinal.add(screenId);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 495                                 numPagesToAdd--;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 496                             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 497 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 498                             // Find the coordinate again</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 499                             coords = LauncherModel.findNextAvailableIconSpace(context,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 500                                     name, launchIntent, startSearchPageIndex, workspaceScreens);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 501                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 502                         if (coords == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 503                             throw new RuntimeException(&quot;Coordinates should not be null&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 504                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 505 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 506                         ShortcutInfo shortcutInfo;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 507                         if (a instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 508                             shortcutInfo = (ShortcutInfo) a;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 509                         } else if (a instanceof AppInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 510                             shortcutInfo = ((AppInfo) a).makeShortcut();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 511                         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 512                             throw new RuntimeException(&quot;Unexpected info type&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 513                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 514 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 515                         // Add the shortcut to the db</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 516                         addItemToDatabase(context, shortcutInfo,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 517                                 LauncherSettings.Favorites.CONTAINER_DESKTOP,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 518                                 coords.first, coords.second[0], coords.second[1], false);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 519                         // Save the ShortcutInfo for binding in the workspace</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 520                         addedShortcutsFinal.add(shortcutInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 521                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 522                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 523 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 524                 // Update the workspace screens</span>
 525 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 526     public void addAndBindAddedApps(final Context context, final ArrayList&lt;ItemInfo&gt; workspaceApps,</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 527                                     final ArrayList&lt;AppInfo&gt; allAppsApps) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 528         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 529         addAndBindAddedApps(context, workspaceApps, cb, allAppsApps);</span>
 530 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 531     }
 532     public void addAndBindAddedApps(final Context context, final ArrayList&lt;ItemInfo&gt; workspaceApps,
 533                                 final Callbacks callbacks, final ArrayList&lt;AppInfo&gt; allAppsApps) {
 534         if (workspaceApps == null || allAppsApps == null) {
 535             throw new RuntimeException(&quot;workspaceApps and allAppsApps must not be null&quot;);
 536         }
 537         if (workspaceApps.isEmpty() &amp;&amp; allAppsApps.isEmpty()) {
 538             return;
 539         }
 540         // Process the newly added applications and add them to the database first
 541         Runnable r = new Runnable() {
 542             public void run() {
 543                 final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();
 544                 final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
 545                 final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();
 546 
 547                 // Get the list of workspace screens.  We need to append to this list and
 548                 // can not use sBgWorkspaceScreens because loadWorkspace() may not have been
 549                 // called.
 550                 ArrayList&lt;Long&gt; workspaceScreens = new ArrayList&lt;Long&gt;();
 551                 TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(context);
 552                 for (Integer i : orderedScreens.keySet()) {
 553                     long screenId = orderedScreens.get(i);
 554                     workspaceScreens.add(screenId);
 555                 }
 556 
 557                 synchronized(sBgLock) {
 558                     Iterator&lt;ItemInfo&gt; iter = workspaceApps.iterator();
 559                     while (iter.hasNext()) {
 560                         ItemInfo a = iter.next();
 561                         final String name = a.title.toString();
 562                         final Intent launchIntent = a.getIntent();
 563 
 564                         // Short-circuit this logic if the icon exists somewhere on the workspace
 565                         if (LauncherModel.shortcutExists(context, name, launchIntent)) {
 566                             // Only InstallShortcutReceiver sends us shortcutInfos, ignore them
 567                             if (a instanceof AppInfo &amp;&amp;
 568                                     LauncherModel.appWasPromise(context, launchIntent, a.user)) {
 569                                 restoredAppsFinal.add((AppInfo) a);
 570                             }
 571                             continue;
 572                         }
 573 
 574                         // Add this icon to the db, creating a new page if necessary.  If there
 575                         // is only the empty page then we just add items to the first page.
 576                         // Otherwise, we add them to the next pages.
 577                         int startSearchPageIndex = workspaceScreens.isEmpty() ? 0 : 1;
 578                         Pair&lt;Long, int[]&gt; coords = LauncherModel.findNextAvailableIconSpace(context,
 579                                 name, launchIntent, startSearchPageIndex, workspaceScreens);
 580                         if (coords == null) {
 581                             LauncherProvider lp = LauncherAppState.getLauncherProvider();
 582 
 583                             // If we can&#x27;t find a valid position, then just add a new screen.
 584                             // This takes time so we need to re-queue the add until the new
 585                             // page is added.  Create as many screens as necessary to satisfy
 586                             // the startSearchPageIndex.
 587                             int numPagesToAdd = Math.max(1, startSearchPageIndex + 1 -
 588                                     workspaceScreens.size());
 589                             while (numPagesToAdd &gt; 0) {
 590                                 long screenId = lp.generateNewScreenId();
 591                                 // Save the screen id for binding in the workspace
 592                                 workspaceScreens.add(screenId);
 593                                 addedWorkspaceScreensFinal.add(screenId);
 594                                 numPagesToAdd--;
 595                             }
 596 
 597                             // Find the coordinate again
 598                             coords = LauncherModel.findNextAvailableIconSpace(context,
 599                                     name, launchIntent, startSearchPageIndex, workspaceScreens);
 600                         }
 601                         if (coords == null) {
 602                             throw new RuntimeException(&quot;Coordinates should not be null&quot;);
 603                         }
 604 
 605                         ShortcutInfo shortcutInfo;
 606                         if (a instanceof ShortcutInfo) {
 607                             shortcutInfo = (ShortcutInfo) a;
 608                         } else if (a instanceof AppInfo) {
 609                             shortcutInfo = ((AppInfo) a).makeShortcut();
 610                         } else {
 611                             throw new RuntimeException(&quot;Unexpected info type&quot;);
 612                         }
 613 
 614                         // Add the shortcut to the db
 615                         addItemToDatabase(context, shortcutInfo,
 616                                 LauncherSettings.Favorites.CONTAINER_DESKTOP,
 617                                 coords.first, coords.second[0], coords.second[1], false);
 618                         // Save the ShortcutInfo for binding in the workspace
 619                         addedShortcutsFinal.add(shortcutInfo);
 620                     }
 621                 }
 622 
 623                 // Update the workspace screens
 624                 updateWorkspaceScreenOrder(context, workspaceScreens);
 625 
 626                 if (!addedShortcutsFinal.isEmpty() || !allAppsApps.isEmpty()) {
 627                     runOnMainThread(new Runnable() {
 628                         public void run() {
 629                             Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 630                             if (callbacks == cb &amp;&amp; cb != null) {
 631                                 final ArrayList&lt;ItemInfo&gt; addAnimated = new ArrayList&lt;ItemInfo&gt;();
 632                                 final ArrayList&lt;ItemInfo&gt; addNotAnimated = new ArrayList&lt;ItemInfo&gt;();
 633                                 if (!addedShortcutsFinal.isEmpty()) {
<abbr title=" 634                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 1);"> 634                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - </abbr>
 635                                     long lastScreenId = info.screenId;
 636                                     for (ItemInfo i : addedShortcutsFinal) {
 637                                         if (i.screenId == lastScreenId) {
 638                                             addAnimated.add(i);
 639                                         } else {
 640                                             addNotAnimated.add(i);
 641                                         }
 642                                     }
 643                                 }
 644                                 callbacks.bindAppsAdded(addedWorkspaceScreensFinal,
 645 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 646                                         addNotAnimated, addAnimated, null);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 647                                 if (!restoredAppsFinal.isEmpty()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 648                                     callbacks.bindAppsUpdated(restoredAppsFinal);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 649                                 }</span>
 650 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 651 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 652                 // Update the workspace screens</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 653                 updateWorkspaceScreenOrder(context, workspaceScreens);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 654 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 655                 if (!addedShortcutsFinal.isEmpty()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 656                     runOnMainThread(new Runnable() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 657                         public void run() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 658                             Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 659                             if (callbacks == cb &amp;&amp; cb != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 660                                 final ArrayList&lt;ItemInfo&gt; addAnimated = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 661                                 final ArrayList&lt;ItemInfo&gt; addNotAnimated = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 662                                 if (!addedShortcutsFinal.isEmpty()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 663                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 1);"> 663                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - </abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 664                                     long lastScreenId = info.screenId;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 665                                     for (ItemInfo i : addedShortcutsFinal) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 666                                         if (i.screenId == lastScreenId) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 667                                             addAnimated.add(i);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 668                                         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 669                                             addNotAnimated.add(i);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 670                                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 671                                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 672                                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 673                                 callbacks.bindAppsAdded(addedWorkspaceScreensFinal,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 674                                         addNotAnimated, addAnimated, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 675                             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 676                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 677                     });</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 678                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 679             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 680         };</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 681         runOnWorkerThread(r);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 682     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 683 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 684     public Bitmap getFallbackIcon() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 685         if (mDefaultIcon == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 686             final Context context = LauncherAppState.getInstance().getContext();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 687             mDefaultIcon = Utilities.createIconBitmap(</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 688                     mIconCache.getFullResDefaultActivityIcon(), context);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 689         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 690         return Bitmap.createBitmap(mDefaultIcon);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 691     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 692 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 693     public void unbindItemInfosAndClearQueuedBindRunnables() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 694         if (sWorkerThread.getThreadId() == Process.myTid()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 695             throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; +</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 696                     &quot;main thread&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 697         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 698 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 699         // Clear any deferred bind runnables</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 700         mDeferredBindRunnables.clear();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 701         // Remove any queued bind runnables</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 702         mHandler.cancelAllRunnablesOfType(MAIN_THREAD_BINDING_RUNNABLE);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 703         // Unbind all the workspace items</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 704         unbindWorkspaceItemsOnMainThread();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 705     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 706 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 707     /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 708     void unbindWorkspaceItemsOnMainThread() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 709         // Ensure that we don&#x27;t use the same workspace items data structure on the main thread</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 710         // by making a copy of workspace items first.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 711         final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 712         final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 713         synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 714             tmpWorkspaceItems.addAll(sBgWorkspaceItems);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 715             tmpAppWidgets.addAll(sBgAppWidgets);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 716         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 717         Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 718                 @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 719                 public void run() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 720                    for (ItemInfo item : tmpWorkspaceItems) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 721                        item.unbind();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 722                    }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 723                    for (ItemInfo item : tmpAppWidgets) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 724                        item.unbind();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 725                    }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 726                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 727             };</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 728         runOnMainThread(r);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 729     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 730 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 731     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 732      * Adds an item to the DB if it was not created previously, or move it to a new</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 733      * &lt;container, screen, cellX, cellY&gt;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 734      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 735     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 736             long screenId, int cellX, int cellY) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 737         if (item.container == ItemInfo.NO_ID) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 738             // From all apps</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 739             addItemToDatabase(context, item, container, screenId, cellX, cellY, false);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 740         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 741             // From somewhere else</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 742             moveItemInDatabase(context, item, container, screenId, cellX, cellY);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 743         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 744     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 745 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 746     static void checkItemInfoLocked(</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 747             final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 748         ItemInfo modelItem = sBgItemsIdMap.get(itemId);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 749         if (modelItem != null &amp;&amp; item != modelItem) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 750             // check all the data is consistent</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 751             if (modelItem instanceof ShortcutInfo &amp;&amp; item instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 752                 ShortcutInfo modelShortcut = (ShortcutInfo) modelItem;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 753                 ShortcutInfo shortcut = (ShortcutInfo) item;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 754                 if (modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 755                         modelShortcut.intent.filterEquals(shortcut.intent) &amp;&amp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 756                         modelShortcut.id == shortcut.id &amp;&amp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 757                         modelShortcut.itemType == shortcut.itemType &amp;&amp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 758                         modelShortcut.container == shortcut.container &amp;&amp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 759                         modelShortcut.screenId == shortcut.screenId &amp;&amp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 760                         modelShortcut.cellX == shortcut.cellX &amp;&amp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 761                         modelShortcut.cellY == shortcut.cellY &amp;&amp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 762                         modelShortcut.spanX == shortcut.spanX &amp;&amp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 763                         modelShortcut.spanY == shortcut.spanY &amp;&amp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 764                         ((modelShortcut.dropPos == null &amp;&amp; shortcut.dropPos == null) ||</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 765                         (modelShortcut.dropPos != null &amp;&amp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 766                                 shortcut.dropPos != null &amp;&amp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 767                                 modelShortcut.dropPos[0] == shortcut.dropPos[0] &amp;&amp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 768                         modelShortcut.dropPos[1] == shortcut.dropPos[1]))) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 769                     // For all intents and purposes, this is the same object</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 770                     return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 771                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 772             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 773 </span>
 774 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 775                                         addNotAnimated, addAnimated, allAppsApps);</span>
 776 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 777                             }
 778                         }
 779                     });
 780                 }
 781             }
 782         };
 783         runOnWorkerThread(r);
 784     }
 785 
 786     public void unbindItemInfosAndClearQueuedBindRunnables() {
 787         if (sWorkerThread.getThreadId() == Process.myTid()) {
 788             throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; +
 789                     &quot;main thread&quot;);
 790         }
 791 
 792         // Clear any deferred bind runnables
 793         synchronized (mDeferredBindRunnables) {
 794             mDeferredBindRunnables.clear();
 795         }
 796         // Remove any queued bind runnables
 797         mHandler.cancelAllRunnablesOfType(MAIN_THREAD_BINDING_RUNNABLE);
 798         // Unbind all the workspace items
 799         unbindWorkspaceItemsOnMainThread();
 800     }
 801 
 802     /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 803     void unbindWorkspaceItemsOnMainThread() {
 804         // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 805         // by making a copy of workspace items first.
 806         final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 807         final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 808         synchronized (sBgLock) {
 809             tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 810             tmpAppWidgets.addAll(sBgAppWidgets);
 811         }
 812         Runnable r = new Runnable() {
 813                 @Override
 814                 public void run() {
 815                    for (ItemInfo item : tmpWorkspaceItems) {
 816                        item.unbind();
 817                    }
 818                    for (ItemInfo item : tmpAppWidgets) {
 819                        item.unbind();
 820                    }
 821                 }
 822             };
 823         runOnMainThread(r);
 824     }
 825 
 826     /**
 827      * Adds an item to the DB if it was not created previously, or move it to a new
 828      * &lt;container, screen, cellX, cellY&gt;
 829      */
 830     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 831             long screenId, int cellX, int cellY) {
 832         if (item.container == ItemInfo.NO_ID) {
 833             // From all apps
 834             addItemToDatabase(context, item, container, screenId, cellX, cellY, false);
 835         } else {
 836             // From somewhere else
 837             moveItemInDatabase(context, item, container, screenId, cellX, cellY);
 838         }
 839     }
 840 
 841     static void checkItemInfoLocked(
 842             final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {
 843         ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 844         if (modelItem != null &amp;&amp; item != modelItem) {
 845             // check all the data is consistent
 846             if (modelItem instanceof ShortcutInfo &amp;&amp; item instanceof ShortcutInfo) {
 847                 ShortcutInfo modelShortcut = (ShortcutInfo) modelItem;
 848                 ShortcutInfo shortcut = (ShortcutInfo) item;
 849                 if (modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp;
 850                         modelShortcut.intent.filterEquals(shortcut.intent) &amp;&amp;
 851                         modelShortcut.id == shortcut.id &amp;&amp;
 852                         modelShortcut.itemType == shortcut.itemType &amp;&amp;
 853                         modelShortcut.container == shortcut.container &amp;&amp;
 854                         modelShortcut.screenId == shortcut.screenId &amp;&amp;
 855                         modelShortcut.cellX == shortcut.cellX &amp;&amp;
 856                         modelShortcut.cellY == shortcut.cellY &amp;&amp;
 857                         modelShortcut.spanX == shortcut.spanX &amp;&amp;
 858                         modelShortcut.spanY == shortcut.spanY &amp;&amp;
 859                         ((modelShortcut.dropPos == null &amp;&amp; shortcut.dropPos == null) ||
 860                         (modelShortcut.dropPos != null &amp;&amp;
 861                                 shortcut.dropPos != null &amp;&amp;
 862                                 modelShortcut.dropPos[0] == shortcut.dropPos[0] &amp;&amp;
 863                         modelShortcut.dropPos[1] == shortcut.dropPos[1]))) {
 864                     // For all intents and purposes, this is the same object
 865                     return;
 866                 }
 867             }
 868 
 869             // the modelItem needs to match up perfectly with item if our model is
 870             // to be consistent with the database-- for now, just require
 871             // modelItem == item or the equality check above
 872             String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 873                     &quot;modelItem: &quot; +
 874                     ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 875                     &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 876             RuntimeException e = new RuntimeException(msg);
 877             if (stackTrace != null) {
 878                 e.setStackTrace(stackTrace);
 879             }
 880             throw e;
 881         }
 882     }
 883 
 884     static void checkItemInfo(final ItemInfo item) {
 885         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 886         final long itemId = item.id;
 887         Runnable r = new Runnable() {
 888             public void run() {
 889                 synchronized (sBgLock) {
 890                     checkItemInfoLocked(itemId, item, stackTrace);
 891                 }
 892             }
 893         };
 894         runOnWorkerThread(r);
 895     }
 896 
 897     static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 898             final ItemInfo item, final String callingFunction) {
 899         final long itemId = item.id;
 900         final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 901         final ContentResolver cr = context.getContentResolver();
 902 
 903         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 904         Runnable r = new Runnable() {
 905             public void run() {
 906                 cr.update(uri, values, null, null);
 907                 updateItemArrays(item, itemId, stackTrace);
 908             }
 909         };
 910         runOnWorkerThread(r);
 911     }
 912 
 913     static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList,
 914             final ArrayList&lt;ItemInfo&gt; items, final String callingFunction) {
 915         final ContentResolver cr = context.getContentResolver();
 916 
 917         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 918         Runnable r = new Runnable() {
 919             public void run() {
 920                 ArrayList&lt;ContentProviderOperation&gt; ops =
 921                         new ArrayList&lt;ContentProviderOperation&gt;();
 922                 int count = items.size();
 923                 for (int i = 0; i &lt; count; i++) {
 924                     ItemInfo item = items.get(i);
 925                     final long itemId = item.id;
 926                     final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 927                     ContentValues values = valuesList.get(i);
 928 
 929                     ops.add(ContentProviderOperation.newUpdate(uri).withValues(values).build());
 930                     updateItemArrays(item, itemId, stackTrace);
 931 
 932                 }
 933                 try {
 934                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
 935                 } catch (Exception e) {
 936                     e.printStackTrace();
 937                 }
 938             }
 939         };
 940         runOnWorkerThread(r);
 941     }
 942 
 943     static void updateItemArrays(ItemInfo item, long itemId, StackTraceElement[] stackTrace) {
 944         // Lock on mBgLock *after* the db operation
 945         synchronized (sBgLock) {
 946             checkItemInfoLocked(itemId, item, stackTrace);
 947 
 948             if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
 949                     item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 950                 // Item is in a folder, make sure this folder exists
 951                 if (!sBgFolders.containsKey(item.container)) {
 952                     // An items container is being set to a that of an item which is not in
 953                     // the list of Folders.
 954                     String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +
 955                             item.container + &quot;, not in the list of folders&quot;;
 956                     Log.e(TAG, msg);
 957                 }
 958             }
 959 
 960             // Items are added/removed from the corresponding FolderInfo elsewhere, such
 961             // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 962             // that are on the desktop, as appropriate
 963             ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 964             if (modelItem != null &amp;&amp;
 965                     (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 966                      modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {
 967                 switch (modelItem.itemType) {
 968                     case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 969                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 970                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 971                         if (!sBgWorkspaceItems.contains(modelItem)) {
 972                             sBgWorkspaceItems.add(modelItem);
 973                         }
 974                         break;
 975                     default:
 976                         break;
 977                 }
 978             } else {
 979                 sBgWorkspaceItems.remove(modelItem);
 980             }
 981         }
 982     }
 983 
 984     public void flushWorkerThread() {
 985         mFlushingWorkerThread = true;
 986         Runnable waiter = new Runnable() {
 987                 public void run() {
 988                     synchronized (this) {
 989                         notifyAll();
 990                         mFlushingWorkerThread = false;
 991                     }
 992                 }
 993             };
 994 
 995         synchronized(waiter) {
 996             runOnWorkerThread(waiter);
 997             if (mLoaderTask != null) {
 998                 synchronized(mLoaderTask) {
 999                     mLoaderTask.notify();
1000                 }
1001             }
1002             boolean success = false;
1003             while (!success) {
1004                 try {
1005                     waiter.wait();
1006                     success = true;
1007                 } catch (InterruptedException e) {
1008                 }
1009             }
1010         }
1011     }
1012 
1013     /**
1014      * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
1015      */
1016     static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
1017             final long screenId, final int cellX, final int cellY) {
1018         item.container = container;
1019         item.cellX = cellX;
1020         item.cellY = cellY;
1021 
1022         // We store hotseat items in canonical form which is this orientation invariant position
1023         // in the hotseat
1024         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
1025                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1026             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
1027         } else {
1028             item.screenId = screenId;
1029         }
1030 
1031         final ContentValues values = new ContentValues();
1032         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
1033         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
1034         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
1035         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
1036 
1037         updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
1038     }
1039 
1040     /**
1041      * Move items in the DB to a new &lt;container, screen, cellX, cellY&gt;. We assume that the
1042      * cellX, cellY have already been updated on the ItemInfos.
1043      */
1044     static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items,
1045             final long container, final int screen) {
1046 
1047         ArrayList&lt;ContentValues&gt; contentValues = new ArrayList&lt;ContentValues&gt;();
1048         int count = items.size();
1049 
1050         for (int i = 0; i &lt; count; i++) {
1051             ItemInfo item = items.get(i);
1052             item.container = container;
1053 
1054             // We store hotseat items in canonical form which is this orientation invariant position
1055             // in the hotseat
1056             if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
1057                     container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1058                 item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(item.cellX,
1059                         item.cellY);
1060             } else {
1061                 item.screenId = screen;
1062             }
1063 
1064             final ContentValues values = new ContentValues();
1065             values.put(LauncherSettings.Favorites.CONTAINER, item.container);
1066             values.put(LauncherSettings.Favorites.CELLX, item.cellX);
1067             values.put(LauncherSettings.Favorites.CELLY, item.cellY);
1068             values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
1069 
1070             contentValues.add(values);
1071         }
1072         updateItemsInDatabaseHelper(context, contentValues, items, &quot;moveItemInDatabase&quot;);
1073     }
1074 
1075     /**
1076      * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
1077      */
1078     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
1079             final long screenId, final int cellX, final int cellY, final int spanX, final int spanY) {
1080         item.container = container;
1081         item.cellX = cellX;
1082         item.cellY = cellY;
1083         item.spanX = spanX;
1084         item.spanY = spanY;
1085 
1086         // We store hotseat items in canonical form which is this orientation invariant position
1087         // in the hotseat
1088         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
1089                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1090             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
1091         } else {
1092             item.screenId = screenId;
1093         }
1094 
1095         final ContentValues values = new ContentValues();
1096         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
1097         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
1098         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
1099         values.put(LauncherSettings.Favorites.SPANX, item.spanX);
1100         values.put(LauncherSettings.Favorites.SPANY, item.spanY);
1101         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
1102 
1103         updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
1104     }
1105 
1106     /**
1107      * Update an item to the database in a specified container.
1108      */
1109     static void updateItemInDatabase(Context context, final ItemInfo item) {
1110         final ContentValues values = new ContentValues();
1111         item.onAddToDatabase(context, values);
1112         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
1113         updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
1114     }
1115 
1116     /**
1117      * Returns true if the shortcuts already exists in the database.
1118      * we identify a shortcut by its title and intent.
1119      */
1120     static boolean shortcutExists(Context context, String title, Intent intent) {
1121         final ContentResolver cr = context.getContentResolver();
1122         final Intent intentWithPkg, intentWithoutPkg;
1123 
1124         if (intent.getComponent() != null) {
1125             // If component is not null, an intent with null package will produce
1126             // the same result and should also be a match.
1127             if (intent.getPackage() != null) {
1128                 intentWithPkg = intent;
1129                 intentWithoutPkg = new Intent(intent).setPackage(null);
1130             } else {
1131                 intentWithPkg = new Intent(intent).setPackage(
1132                         intent.getComponent().getPackageName());
1133                 intentWithoutPkg = intent;
1134             }
1135         } else {
1136             intentWithPkg = intent;
1137             intentWithoutPkg = intent;
1138         }
1139         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
1140             new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and (intent=? or intent=?)&quot;,
1141             new String[] { title, intentWithPkg.toUri(0), intentWithoutPkg.toUri(0) }, null);
1142         boolean result = false;
1143         try {
1144             result = c.moveToFirst();
1145         } finally {
1146             c.close();
1147         }
1148         return result;
1149     }
1150 
1151     /**
1152      * Returns true if the promise shortcuts with the same package name exists on the workspace.
1153      */
1154     static boolean appWasPromise(Context context, Intent intent, UserHandleCompat user) {
1155         final ComponentName component = intent.getComponent();
1156         if (component == null) {
1157             return false;
1158         }
1159         return !getItemsByPackageName(component.getPackageName(), user).isEmpty();
1160     }
1161 
1162     /**
1163      * Returns an ItemInfo array containing all the items in the LauncherModel.
1164      * The ItemInfo.id is not set through this function.
1165      */
1166     static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
1167         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
1168         final ContentResolver cr = context.getContentResolver();
1169         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
1170                 LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
1171                 LauncherSettings.Favorites.SCREEN,
1172                 LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,
1173                 LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY,
1174                 LauncherSettings.Favorites.PROFILE_ID }, null, null, null);
1175 
1176         final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
1177         final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
1178         final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
1179         final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
1180         final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
1181         final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
1182         final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
1183         final int profileIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.PROFILE_ID);
1184         UserManagerCompat userManager = UserManagerCompat.getInstance(context);
1185         try {
1186             while (c.moveToNext()) {
1187                 ItemInfo item = new ItemInfo();
1188                 item.cellX = c.getInt(cellXIndex);
1189                 item.cellY = c.getInt(cellYIndex);
1190                 item.spanX = Math.max(1, c.getInt(spanXIndex));
1191                 item.spanY = Math.max(1, c.getInt(spanYIndex));
1192                 item.container = c.getInt(containerIndex);
1193                 item.itemType = c.getInt(itemTypeIndex);
1194                 item.screenId = c.getInt(screenIndex);
1195                 long serialNumber = c.getInt(profileIdIndex);
1196                 item.user = userManager.getUserForSerialNumber(serialNumber);
1197                 // Skip if user has been deleted.
1198                 if (item.user != null) {
1199                     items.add(item);
1200                 }
1201             }
1202         } catch (Exception e) {
1203             items.clear();
1204         } finally {
1205             c.close();
1206         }
1207 
1208         return items;
1209     }
1210 
1211     /**
1212      * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
1213      */
1214     FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
1215         final ContentResolver cr = context.getContentResolver();
1216         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
1217                 &quot;_id=? and (itemType=? or itemType=?)&quot;,
1218                 new String[] { String.valueOf(id),
1219                         String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
1220 
1221         try {
1222             if (c.moveToFirst()) {
1223                 final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
1224                 final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
1225                 final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
1226                 final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
1227                 final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
1228                 final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
1229 
1230                 FolderInfo folderInfo = null;
1231                 switch (c.getInt(itemTypeIndex)) {
1232                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1233                         folderInfo = findOrMakeFolder(folderList, id);
1234                         break;
1235                 }
1236 
1237                 folderInfo.title = c.getString(titleIndex);
1238                 folderInfo.id = id;
1239                 folderInfo.container = c.getInt(containerIndex);
1240                 folderInfo.screenId = c.getInt(screenIndex);
1241                 folderInfo.cellX = c.getInt(cellXIndex);
1242                 folderInfo.cellY = c.getInt(cellYIndex);
1243 
1244                 return folderInfo;
1245             }
1246         } finally {
1247             c.close();
1248         }
1249 
1250         return null;
1251     }
1252 
1253     /**
1254      * Add an item to the database in a specified container. Sets the container, screen, cellX and
1255      * cellY fields of the item. Also assigns an ID to the item.
1256      */
1257     static void addItemToDatabase(Context context, final ItemInfo item, final long container,
1258             final long screenId, final int cellX, final int cellY, final boolean notify) {
1259         item.container = container;
1260         item.cellX = cellX;
1261         item.cellY = cellY;
1262         // We store hotseat items in canonical form which is this orientation invariant position
1263         // in the hotseat
1264         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
1265                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1266             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
1267         } else {
1268             item.screenId = screenId;
1269         }
1270 
1271         final ContentValues values = new ContentValues();
1272         final ContentResolver cr = context.getContentResolver();
1273         item.onAddToDatabase(context, values);
1274 
1275         item.id = LauncherAppState.getLauncherProvider().generateNewItemId();
1276         values.put(LauncherSettings.Favorites._ID, item.id);
1277         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
1278 
1279         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
1280         Runnable r = new Runnable() {
1281             public void run() {
1282                 cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
1283                         LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);
1284 
1285                 // Lock on mBgLock *after* the db operation
1286                 synchronized (sBgLock) {
1287                     checkItemInfoLocked(item.id, item, stackTrace);
1288                     sBgItemsIdMap.put(item.id, item);
1289                     switch (item.itemType) {
1290                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1291                             sBgFolders.put(item.id, (FolderInfo) item);
1292                             // Fall through
1293                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1294                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1295                             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
1296                                     item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1297                                 sBgWorkspaceItems.add(item);
1298                             } else {
1299                                 if (!sBgFolders.containsKey(item.container)) {
1300                                     // Adding an item to a folder that doesn&#x27;t exist.
1301                                     String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +
1302                                             &quot; doesn&#x27;t exist&quot;;
1303                                     Log.e(TAG, msg);
1304                                 }
1305                             }
1306                             break;
1307                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1308                             sBgAppWidgets.add((LauncherAppWidgetInfo) item);
1309                             break;
1310                     }
1311                 }
1312             }
1313         };
1314         runOnWorkerThread(r);
1315     }
1316 
1317     /**
1318      * Creates a new unique child id, for a given cell span across all layouts.
1319      */
1320     static int getCellLayoutChildId(
1321             long container, long screen, int localCellX, int localCellY, int spanX, int spanY) {
1322         return (((int) container &amp; 0xFF) &lt;&lt; 24)
1323                 | ((int) screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
1324     }
1325 
1326     private static ArrayList&lt;ItemInfo&gt; getItemsByPackageName(
1327             final String pn, final UserHandleCompat user) {
1328         ItemInfoFilter filter  = new ItemInfoFilter() {
1329             @Override
1330             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
1331                 return cn.getPackageName().equals(pn) &amp;&amp; info.user.equals(user);
1332             }
1333         };
1334         return filterItemInfos(sBgItemsIdMap.values(), filter);
1335     }
1336 
1337     /**
1338      * Removes all the items from the database corresponding to the specified package.
1339      */
1340     static void deletePackageFromDatabase(Context context, final String pn,
1341             final UserHandleCompat user) {
1342         deleteItemsFromDatabase(context, getItemsByPackageName(pn, user));
1343     }
1344 
1345     /**
1346      * Removes the specified item from the database
1347      * @param context
1348      * @param item
1349      */
1350     static void deleteItemFromDatabase(Context context, final ItemInfo item) {
1351         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
1352         items.add(item);
1353         deleteItemsFromDatabase(context, items);
1354     }
1355 
1356     /**
1357      * Removes the specified items from the database
1358      * @param context
1359      * @param item
1360      */
1361     static void deleteItemsFromDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items) {
1362         final ContentResolver cr = context.getContentResolver();
1363 
1364         Runnable r = new Runnable() {
1365             public void run() {
1366                 for (ItemInfo item : items) {
1367                     final Uri uri = LauncherSettings.Favorites.getContentUri(item.id, false);
1368                     cr.delete(uri, null, null);
1369 
1370                     // Lock on mBgLock *after* the db operation
1371                     synchronized (sBgLock) {
1372                         switch (item.itemType) {
1373                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1374                                 sBgFolders.remove(item.id);
1375                                 for (ItemInfo info: sBgItemsIdMap.values()) {
1376                                     if (info.container == item.id) {
1377                                         // We are deleting a folder which still contains items that
1378                                         // think they are contained by that folder.
1379                                         String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +
1380                                                 &quot;contains items (&quot; + info + &quot;)&quot;;
1381                                         Log.e(TAG, msg);
1382                                     }
1383                                 }
1384                                 sBgWorkspaceItems.remove(item);
1385                                 break;
1386                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1387                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1388                                 sBgWorkspaceItems.remove(item);
1389                                 break;
1390                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1391                                 sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
1392                                 break;
1393                         }
1394                         sBgItemsIdMap.remove(item.id);
1395                         sBgDbIconCache.remove(item);
1396                     }
1397                 }
1398             }
1399         };
1400         runOnWorkerThread(r);
1401     }
1402 
1403     /**
1404      * Update the order of the workspace screens in the database. The array list contains
1405      * a list of screen ids in the order that they should appear.
1406      */
1407     void updateWorkspaceScreenOrder(Context context, final ArrayList&lt;Long&gt; screens) {
1408         // Log to disk
1409         Launcher.addDumpLog(TAG, &quot;11683562 - updateWorkspaceScreenOrder()&quot;, true);
1410         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; + TextUtils.join(&quot;, &quot;, screens), true);
1411 
1412         final ArrayList&lt;Long&gt; screensCopy = new ArrayList&lt;Long&gt;(screens);
1413         final ContentResolver cr = context.getContentResolver();
1414         final Uri uri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1415 
1416         // Remove any negative screen ids -- these aren&#x27;t persisted
1417         Iterator&lt;Long&gt; iter = screensCopy.iterator();
1418         while (iter.hasNext()) {
1419             long id = iter.next();
1420             if (id &lt; 0) {
1421                 iter.remove();
1422             }
1423         }
1424 
1425         Runnable r = new Runnable() {
1426             @Override
1427             public void run() {
1428                 ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
1429                 // Clear the table
1430                 ops.add(ContentProviderOperation.newDelete(uri).build());
1431                 int count = screensCopy.size();
1432                 for (int i = 0; i &lt; count; i++) {
1433                     ContentValues v = new ContentValues();
1434                     long screenId = screensCopy.get(i);
1435                     v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1436                     v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1437                     ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());
1438                 }
1439 
1440                 try {
1441                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
1442                 } catch (Exception ex) {
1443                     throw new RuntimeException(ex);
1444                 }
1445 
1446                 synchronized (sBgLock) {
1447                     sBgWorkspaceScreens.clear();
1448                     sBgWorkspaceScreens.addAll(screensCopy);
1449                 }
1450             }
1451         };
1452         runOnWorkerThread(r);
1453     }
1454 
1455     /**
1456      * Remove the contents of the specified folder from the database
1457      */
1458     static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
1459         final ContentResolver cr = context.getContentResolver();
1460 
1461         Runnable r = new Runnable() {
1462             public void run() {
1463                 cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
1464                 // Lock on mBgLock *after* the db operation
1465                 synchronized (sBgLock) {
1466                     sBgItemsIdMap.remove(info.id);
1467                     sBgFolders.remove(info.id);
1468                     sBgDbIconCache.remove(info);
1469                     sBgWorkspaceItems.remove(info);
1470                 }
1471 
1472                 cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
1473                         LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
1474                 // Lock on mBgLock *after* the db operation
1475                 synchronized (sBgLock) {
1476                     for (ItemInfo childInfo : info.contents) {
1477                         sBgItemsIdMap.remove(childInfo.id);
1478                         sBgDbIconCache.remove(childInfo);
1479                     }
1480                 }
1481             }
1482         };
1483         runOnWorkerThread(r);
1484     }
1485 
1486     /**
1487      * Set this as the current Launcher activity object for the loader.
1488      */
1489     public void initialize(Callbacks callbacks) {
1490         synchronized (mLock) {
1491             mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
1492         }
1493     }
1494 
1495     @Override
1496     public void onPackageChanged(String packageName, UserHandleCompat user) {
1497         int op = PackageUpdatedTask.OP_UPDATE;
1498         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1499                 user));
1500     }
1501 
1502     @Override
1503     public void onPackageRemoved(String packageName, UserHandleCompat user) {
1504         int op = PackageUpdatedTask.OP_REMOVE;
1505         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1506                 user));
1507     }
1508 
1509     @Override
1510     public void onPackageAdded(String packageName, UserHandleCompat user) {
1511         int op = PackageUpdatedTask.OP_ADD;
1512         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1513                 user));
1514     }
1515 
1516     @Override
1517     public void onPackagesAvailable(String[] packageNames, UserHandleCompat user,
1518             boolean replacing) {
1519         if (!replacing) {
1520             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packageNames,
1521                     user));
1522             if (mAppsCanBeOnRemoveableStorage) {
1523                 // Only rebind if we support removable storage. It catches the
1524                 // case where
1525                 // apps on the external sd card need to be reloaded
1526                 startLoaderFromBackground();
1527             }
1528         } else {
1529             // If we are replacing then just update the packages in the list
1530             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE,
1531                     packageNames, user));
1532         }
1533     }
1534 
1535     @Override
1536     public void onPackagesUnavailable(String[] packageNames, UserHandleCompat user,
1537             boolean replacing) {
1538         if (!replacing) {
1539             enqueuePackageUpdated(new PackageUpdatedTask(
1540                     PackageUpdatedTask.OP_UNAVAILABLE, packageNames,
1541                     user));
1542         }
1543 
1544     }
1545 
1546     /**
1547      * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
1548      * ACTION_PACKAGE_CHANGED.
1549      */
1550     @Override
1551     public void onReceive(Context context, Intent intent) {
1552         if (DEBUG_RECEIVER) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
1553 
1554         final String action = intent.getAction();
1555         if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
1556             // If we have changed locale we need to clear out the labels in all apps/workspace.
1557             forceReload();
1558         } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
1559              // Check if configuration change was an mcc/mnc change which would affect app resources
1560              // and we would need to clear out the labels in all apps/workspace. Same handling as
1561              // above for ACTION_LOCALE_CHANGED
1562              Configuration currentConfig = context.getResources().getConfiguration();
1563              if (mPreviousConfigMcc != currentConfig.mcc) {
1564                    Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
1565                        + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
1566                    forceReload();
1567              }
1568              // Update previousConfig
1569              mPreviousConfigMcc = currentConfig.mcc;
1570         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
1571                    SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
1572             if (mCallbacks != null) {
1573                 Callbacks callbacks = mCallbacks.get();
1574                 if (callbacks != null) {
1575                     callbacks.bindSearchablesChanged();
1576                 }
1577             }
1578         }
1579     }
1580 
1581     void forceReload() {
1582         resetLoadedState(true, true);
1583 
1584         // Do this here because if the launcher activity is running it will be restarted.
1585         // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
1586         // to reload.
1587         startLoaderFromBackground();
1588     }
1589 
1590     public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
1591         synchronized (mLock) {
1592             // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
1593             // mWorkspaceLoaded to true later
1594             stopLoaderLocked();
1595             if (resetAllAppsLoaded) mAllAppsLoaded = false;
1596             if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
1597         }
1598     }
1599 
1600     /**
1601      * When the launcher is in the background, it&#x27;s possible for it to miss paired
1602      * configuration changes.  So whenever we trigger the loader from the background
1603      * tell the launcher that it needs to re-run the loader when it comes back instead
1604      * of doing it now.
1605      */
1606     public void startLoaderFromBackground() {
1607         boolean runLoader = false;
1608         if (mCallbacks != null) {
1609             Callbacks callbacks = mCallbacks.get();
1610             if (callbacks != null) {
1611                 // Only actually run the loader if they&#x27;re not paused.
1612                 if (!callbacks.setLoadOnResume()) {
1613                     runLoader = true;
1614                 }
1615             }
1616         }
1617         if (runLoader) {
1618             startLoader(false, PagedView.INVALID_RESTORE_PAGE);
1619         }
1620     }
1621 
1622     // If there is already a loader task running, tell it to stop.
1623     // returns true if isLaunching() was true on the old task
1624     private boolean stopLoaderLocked() {
1625         boolean isLaunching = false;
1626         LoaderTask oldTask = mLoaderTask;
1627         if (oldTask != null) {
1628             if (oldTask.isLaunching()) {
1629                 isLaunching = true;
1630             }
1631             oldTask.stopLocked();
1632         }
1633         return isLaunching;
1634     }
1635 
1636     public boolean isCurrentCallbacks(Callbacks callbacks) {
1637         return (mCallbacks != null &amp;&amp; mCallbacks.get() == callbacks);
1638     }
1639 
1640     public void startLoader(boolean isLaunching, int synchronousBindPage) {
1641         startLoader(isLaunching, synchronousBindPage, LOADER_FLAG_NONE);
1642     }
1643 
1644     public void startLoader(boolean isLaunching, int synchronousBindPage, int loadFlags) {
1645         synchronized (mLock) {
1646             if (DEBUG_LOADERS) {
1647                 Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
1648             }
1649 
1650             // Clear any deferred bind-runnables from the synchronized load process
1651             // We must do this before any loading/binding is scheduled below.
1652             synchronized (mDeferredBindRunnables) {
1653                 mDeferredBindRunnables.clear();
1654             }
1655 
1656             // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
1657             if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
1658                 // If there is already one running, tell it to stop.
1659                 // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
1660                 isLaunching = isLaunching || stopLoaderLocked();
1661                 mLoaderTask = new LoaderTask(mApp.getContext(), isLaunching, loadFlags);
1662                 if (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE
1663                         &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {
1664                     mLoaderTask.runBindSynchronousPage(synchronousBindPage);
1665                 } else {
1666                     sWorkerThread.setPriority(Thread.NORM_PRIORITY);
1667                     sWorker.post(mLoaderTask);
1668                 }
1669             }
1670         }
1671     }
1672 
1673     void bindRemainingSynchronousPages() {
1674         // Post the remaining side pages to be loaded
1675         if (!mDeferredBindRunnables.isEmpty()) {
1676             Runnable[] deferredBindRunnables = null;
1677             synchronized (mDeferredBindRunnables) {
1678                 deferredBindRunnables = mDeferredBindRunnables.toArray(
1679                         new Runnable[mDeferredBindRunnables.size()]);
1680                 mDeferredBindRunnables.clear();
1681             }
1682             for (final Runnable r : deferredBindRunnables) {
1683                 mHandler.post(r, MAIN_THREAD_BINDING_RUNNABLE);
1684             }
1685         }
1686     }
1687 
1688     public void stopLoader() {
1689         synchronized (mLock) {
1690             if (mLoaderTask != null) {
1691                 mLoaderTask.stopLocked();
1692             }
1693         }
1694     }
1695 
1696     /** Loads the workspace screens db into a map of Rank -&gt; ScreenId */
1697     private static TreeMap&lt;Integer, Long&gt; loadWorkspaceScreensDb(Context context) {
1698         final ContentResolver contentResolver = context.getContentResolver();
1699         final Uri screensUri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1700         final Cursor sc = contentResolver.query(screensUri, null, null, null, null);
1701         TreeMap&lt;Integer, Long&gt; orderedScreens = new TreeMap&lt;Integer, Long&gt;();
1702 
1703         try {
1704             final int idIndex = sc.getColumnIndexOrThrow(
1705                     LauncherSettings.WorkspaceScreens._ID);
1706             final int rankIndex = sc.getColumnIndexOrThrow(
1707                     LauncherSettings.WorkspaceScreens.SCREEN_RANK);
1708             while (sc.moveToNext()) {
1709                 try {
1710                     long screenId = sc.getLong(idIndex);
1711                     int rank = sc.getInt(rankIndex);
1712                     orderedScreens.put(rank, screenId);
1713                 } catch (Exception e) {
<abbr title="1714                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e, true);">1714                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e,</abbr>
1715                 }
1716             }
1717         } finally {
1718             sc.close();
1719         }
1720 
1721         // Log to disk
1722         Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspaceScreensDb()&quot;, true);
1723         ArrayList&lt;String&gt; orderedScreensPairs= new ArrayList&lt;String&gt;();
1724         for (Integer i : orderedScreens.keySet()) {
1725             orderedScreensPairs.add(&quot;{ &quot; + i + &quot;: &quot; + orderedScreens.get(i) + &quot; }&quot;);
1726         }
1727         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; +
1728                 TextUtils.join(&quot;, &quot;, orderedScreensPairs), true);
1729         return orderedScreens;
1730     }
1731 
1732     public boolean isAllAppsLoaded() {
1733         return mAllAppsLoaded;
1734     }
1735 
1736     boolean isLoadingWorkspace() {
1737         synchronized (mLock) {
1738             if (mLoaderTask != null) {
1739                 return mLoaderTask.isLoadingWorkspace();
1740             }
1741         }
1742         return false;
1743     }
1744 
1745     /**
1746      * Runnable for the thread that loads the contents of the launcher:
1747      *   - workspace icons
1748      *   - widgets
1749      *   - all apps icons
1750      */
1751     private class LoaderTask implements Runnable {
1752         private Context mContext;
1753         private boolean mIsLaunching;
1754         private boolean mIsLoadingAndBindingWorkspace;
1755         private boolean mStopped;
1756         private boolean mLoadAndBindStepFinished;
1757         private int mFlags;
1758 
1759         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
1760 
1761         LoaderTask(Context context, boolean isLaunching, int flags) {
1762             mContext = context;
1763             mIsLaunching = isLaunching;
1764             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
1765             mFlags = flags;
1766         }
1767 
1768         boolean isLaunching() {
1769             return mIsLaunching;
1770         }
1771 
1772         boolean isLoadingWorkspace() {
1773             return mIsLoadingAndBindingWorkspace;
1774         }
1775 
1776         /** Returns whether this is an upgrade path */
1777         private boolean loadAndBindWorkspace() {
1778             mIsLoadingAndBindingWorkspace = true;
1779 
1780             // Load the workspace
1781             if (DEBUG_LOADERS) {
1782                 Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1783             }
1784 
1785             boolean isUpgradePath = false;
1786             if (!mWorkspaceLoaded) {
1787                 isUpgradePath = loadWorkspace();
1788                 synchronized (LoaderTask.this) {
1789                     if (mStopped) {
1790                         return isUpgradePath;
1791                     }
1792                     mWorkspaceLoaded = true;
1793                 }
1794             }
1795 
1796             // Bind the workspace
1797             bindWorkspace(-1, isUpgradePath);
1798             return isUpgradePath;
1799         }
1800 
1801         private void waitForIdle() {
1802             // Wait until the either we&#x27;re stopped or the other threads are done.
1803             // This way we don&#x27;t start loading all apps until the workspace has settled
1804             // down.
1805             synchronized (LoaderTask.this) {
1806                 final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1807 
1808                 mHandler.postIdle(new Runnable() {
1809                         public void run() {
1810                             synchronized (LoaderTask.this) {
1811                                 mLoadAndBindStepFinished = true;
1812                                 if (DEBUG_LOADERS) {
1813                                     Log.d(TAG, &quot;done with previous binding step&quot;);
1814                                 }
1815                                 LoaderTask.this.notify();
1816                             }
1817                         }
1818                     });
1819 
1820                 while (!mStopped &amp;&amp; !mLoadAndBindStepFinished &amp;&amp; !mFlushingWorkerThread) {
1821                     try {
1822                         // Just in case mFlushingWorkerThread changes but we aren&#x27;t woken up,
1823                         // wait no longer than 1sec at a time
1824                         this.wait(1000);
1825                     } catch (InterruptedException ex) {
1826                         // Ignore
1827                     }
1828                 }
1829                 if (DEBUG_LOADERS) {
1830                     Log.d(TAG, &quot;waited &quot;
1831                             + (SystemClock.uptimeMillis()-workspaceWaitTime)
1832                             + &quot;ms for previous step to finish binding&quot;);
1833                 }
1834             }
1835         }
1836 
1837         void runBindSynchronousPage(int synchronousBindPage) {
1838             if (synchronousBindPage == PagedView.INVALID_RESTORE_PAGE) {
1839                 // Ensure that we have a valid page index to load synchronously
1840                 throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1841                         &quot;valid page index&quot;);
1842             }
1843             if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1844                 // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1845                 // loaded already (we should load everything asynchronously in that case)
1846                 throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1847             }
1848             synchronized (mLock) {
1849                 if (mIsLoaderTaskRunning) {
1850                     // Ensure that we are never running the background loading at this point since
1851                     // we also touch the background collections
1852                     throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1853                 }
1854             }
1855 
1856             // XXX: Throw an exception if we are already loading (since we touch the worker thread
1857             //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1858             //      this call is synchronous, we can get away with not locking).
1859 
1860             // The LauncherModel is static in the LauncherAppState and mHandler may have queued
1861             // operations from the previous activity.  We need to ensure that all queued operations
1862             // are executed before any synchronous binding work is done.
1863             mHandler.flush();
1864 
1865             // Divide the set of loaded items into those that we are binding synchronously, and
1866             // everything else that is to be bound normally (asynchronously).
1867             bindWorkspace(synchronousBindPage, false);
1868             // XXX: For now, continue posting the binding of AllApps as there are other issues that
1869             //      arise from that.
1870             onlyBindAllApps();
1871         }
1872 
1873         public void run() {
1874             boolean isUpgrade = false;
1875 
1876             synchronized (mLock) {
1877                 mIsLoaderTaskRunning = true;
1878             }
1879             // Optimize for end-user experience: if the Launcher is up and // running with the
1880             // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1881             // workspace first (default).
1882             keep_running: {
1883                 // Elevate priority when Home launches for the first time to avoid
1884                 // starving at boot time. Staring at a blank home is not cool.
1885                 synchronized (mLock) {
1886                     if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1887                             (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1888                     android.os.Process.setThreadPriority(mIsLaunching
1889                             ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1890                 }
1891                 if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1892                 isUpgrade = loadAndBindWorkspace();
1893 
1894                 if (mStopped) {
1895                     break keep_running;
1896                 }
1897 
1898                 // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1899                 // settled down.
1900                 synchronized (mLock) {
1901                     if (mIsLaunching) {
1902                         if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1903                         android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1904                     }
1905                 }
1906                 waitForIdle();
1907 
1908                 // second step
1909                 if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1910                 loadAndBindAllApps();
1911 
1912                 // Restore the default thread priority after we are done loading items
1913                 synchronized (mLock) {
1914                     android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1915                 }
1916             }
1917 
1918             // Update the saved icons if necessary
1919             if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1920             synchronized (sBgLock) {
1921                 for (Object key : sBgDbIconCache.keySet()) {
1922                     updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
1923                 }
1924                 sBgDbIconCache.clear();
1925             }
1926 
1927             if (LauncherAppState.isDisableAllApps()) {
1928                 // Ensure that all the applications that are in the system are
1929                 // represented on the home screen.
1930                 if (!UPGRADE_USE_MORE_APPS_FOLDER || !isUpgrade) {
1931                     verifyApplications();
1932                 }
1933             }
1934 
1935             // Clear out this reference, otherwise we end up holding it until all of the
1936             // callback runnables are done.
1937             mContext = null;
1938 
1939             synchronized (mLock) {
1940                 // If we are still the last one to be scheduled, remove ourselves.
1941                 if (mLoaderTask == this) {
1942                     mLoaderTask = null;
1943                 }
1944                 mIsLoaderTaskRunning = false;
1945             }
1946         }
1947 
1948         public void stopLocked() {
1949             synchronized (LoaderTask.this) {
1950                 mStopped = true;
1951                 this.notify();
1952             }
1953         }
1954 
1955         /**
1956          * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1957          * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1958          * object that was around when the deferred message was scheduled, and if there&#x27;s
1959          * a new Callbacks object around then also return null.  This will save us from
1960          * calling onto it with data that will be ignored.
1961          */
1962         Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1963             synchronized (mLock) {
1964                 if (mStopped) {
1965                     return null;
1966                 }
1967 
1968                 if (mCallbacks == null) {
1969                     return null;
1970                 }
1971 
1972                 final Callbacks callbacks = mCallbacks.get();
1973                 if (callbacks != oldCallbacks) {
1974                     return null;
1975                 }
1976                 if (callbacks == null) {
1977                     Log.w(TAG, &quot;no mCallbacks&quot;);
1978                     return null;
1979                 }
1980 
1981                 return callbacks;
1982             }
1983         }
1984 
1985         private void verifyApplications() {
1986             final Context context = mApp.getContext();
1987 
1988             // Cross reference all the applications in our apps list with items in the workspace
1989             ArrayList&lt;ItemInfo&gt; tmpInfos;
1990             ArrayList&lt;ItemInfo&gt; added = new ArrayList&lt;ItemInfo&gt;();
1991             synchronized (sBgLock) {
1992                 for (AppInfo app : mBgAllAppsList.data) {
1993                     tmpInfos = getItemInfoForComponentName(app.componentName, app.user);
1994                     if (tmpInfos.isEmpty()) {
1995                         // We are missing an application icon, so add this to the workspace
1996                         added.add(app);
1997                         // This is a rare event, so lets log it
1998                         Log.e(TAG, &quot;Missing Application on load: &quot; + app);
1999                     }
2000                 }
2001             }
2002             if (!added.isEmpty()) {
2003                 Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2004                 addAndBindAddedApps(context, added, cb, new ArrayList&lt;AppInfo&gt;());
2005             }
2006         }
2007 
2008         // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
2009         private boolean checkItemPlacement(HashMap&lt;Long, ItemInfo[][]&gt; occupied, ItemInfo item,
2010                                            AtomicBoolean deleteOnInvalidPlacement) {
2011             LauncherAppState app = LauncherAppState.getInstance();
2012             DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2013             final int countX = (int) grid.numColumns;
2014             final int countY = (int) grid.numRows;
2015 
2016             long containerIndex = item.screenId;
2017             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2018                 // Return early if we detect that an item is under the hotseat button
2019                 if (mCallbacks == null ||
2020                         mCallbacks.get().isAllAppsButtonRank((int) item.screenId)) {
2021                     deleteOnInvalidPlacement.set(true);
2022                     Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
2023                             + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
2024                             + item.cellY + &quot;) occupied by all apps&quot;);
2025                     return false;
2026                 }
2027 
2028                 final ItemInfo[][] hotseatItems =
2029                         occupied.get((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT);
2030 
2031                 if (item.screenId &gt;= grid.numHotseatIcons) {
2032                     Log.e(TAG, &quot;Error loading shortcut &quot; + item
2033                             + &quot; into hotseat position &quot; + item.screenId
2034                             + &quot;, position out of bounds: (0 to &quot; + (grid.numHotseatIcons - 1)
2035                             + &quot;)&quot;);
2036                     return false;
2037                 }
2038 
2039                 if (hotseatItems != null) {
2040                     if (hotseatItems[(int) item.screenId][0] != null) {
2041                         Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
2042                                 + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
2043                                 + item.cellY + &quot;) occupied by &quot;
2044                                 + occupied.get(LauncherSettings.Favorites.CONTAINER_HOTSEAT)
2045                                 [(int) item.screenId][0]);
2046                             return false;
2047                     } else {
2048                         hotseatItems[(int) item.screenId][0] = item;
2049                         return true;
2050                     }
2051                 } else {
2052                     final ItemInfo[][] items = new ItemInfo[(int) grid.numHotseatIcons][1];
2053                     items[(int) item.screenId][0] = item;
2054                     occupied.put((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT, items);
2055                     return true;
2056                 }
2057             } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2058                 // Skip further checking if it is not the hotseat or workspace container
2059                 return true;
2060             }
2061 
2062             if (!occupied.containsKey(item.screenId)) {
2063                 ItemInfo[][] items = new ItemInfo[countX + 1][countY + 1];
2064                 occupied.put(item.screenId, items);
2065             }
2066 
2067             final ItemInfo[][] screens = occupied.get(item.screenId);
2068             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2069                     item.cellX &lt; 0 || item.cellY &lt; 0 ||
2070                     item.cellX + item.spanX &gt; countX || item.cellY + item.spanY &gt; countY) {
2071                 Log.e(TAG, &quot;Error loading shortcut &quot; + item
2072                         + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
2073                         + item.cellX + &quot;,&quot; + item.cellY
2074                         + &quot;) out of screen bounds ( &quot; + countX + &quot;x&quot; + countY + &quot;)&quot;);
2075                 return false;
2076             }
2077 
2078             // Check if any workspace icons overlap with each other
2079             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
2080                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
2081                     if (screens[x][y] != null) {
2082                         Log.e(TAG, &quot;Error loading shortcut &quot; + item
2083                             + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
2084                             + x + &quot;,&quot; + y
2085                             + &quot;) occupied by &quot;
2086                             + screens[x][y]);
2087                         return false;
2088                     }
2089                 }
2090             }
2091             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
2092                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
2093                     screens[x][y] = item;
2094                 }
2095             }
2096 
2097             return true;
2098         }
2099 
2100         /** Clears all the sBg data structures */
2101         private void clearSBgDataStructures() {
2102             synchronized (sBgLock) {
2103                 sBgWorkspaceItems.clear();
2104                 sBgAppWidgets.clear();
2105                 sBgFolders.clear();
2106                 sBgItemsIdMap.clear();
2107                 sBgDbIconCache.clear();
2108                 sBgWorkspaceScreens.clear();
2109             }
2110         }
2111 
2112         /** Returns whether this is an upgrade path */
2113         private boolean loadWorkspace() {
2114             // Log to disk
2115             Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspace()&quot;, true);
2116 
2117             final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2118 
2119             final Context context = mContext;
2120             final ContentResolver contentResolver = context.getContentResolver();
2121             final PackageManager manager = context.getPackageManager();
2122             final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
2123             final boolean isSafeMode = manager.isSafeMode();
2124             final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
2125             final boolean isSdCardReady = context.registerReceiver(null,
2126                     new IntentFilter(StartupReceiver.SYSTEM_READY)) != null;
2127 
2128             LauncherAppState app = LauncherAppState.getInstance();
2129             DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2130             int countX = (int) grid.numColumns;
2131             int countY = (int) grid.numRows;
2132 
2133             if ((mFlags &amp; LOADER_FLAG_CLEAR_WORKSPACE) != 0) {
2134                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: resetting launcher database&quot;, true);
2135                 LauncherAppState.getLauncherProvider().deleteDatabase();
2136             }
2137 
2138             if ((mFlags &amp; LOADER_FLAG_MIGRATE_SHORTCUTS) != 0) {
2139                 // append the user&#x27;s Launcher2 shortcuts
2140                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: migrating from launcher2&quot;, true);
2141                 LauncherAppState.getLauncherProvider().migrateLauncher2Shortcuts();
2142             } else {
2143                 // Make sure the default workspace is loaded
2144                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: loading default favorites&quot;, false);
2145                 LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary();
2146             }
2147 
2148             // This code path is for our old migration code and should no longer be exercised
2149             boolean loadedOldDb = false;
2150 
2151             // Log to disk
2152             Launcher.addDumpLog(TAG, &quot;11683562 -   loadedOldDb: &quot; + loadedOldDb, true);
2153 
2154             synchronized (sBgLock) {
2155                 clearSBgDataStructures();
2156                 final HashSet&lt;String&gt; installingPkgs = PackageInstallerCompat
2157                         .getInstance(mContext).updateAndGetActiveSessionCache();
2158 
2159                 final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
2160                 final ArrayList&lt;Long&gt; restoredRows = new ArrayList&lt;Long&gt;();
2161                 final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION;
2162                 if (DEBUG_LOADERS) Log.d(TAG, &quot;loading model from &quot; + contentUri);
2163                 final Cursor c = contentResolver.query(contentUri, null, null, null, null);
2164 
2165                 // +1 for the hotseat (it can be larger than the workspace)
2166                 // Load workspace in reverse order to ensure that latest items are loaded first (and
2167                 // before any earlier duplicates)
2168                 final HashMap&lt;Long, ItemInfo[][]&gt; occupied = new HashMap&lt;Long, ItemInfo[][]&gt;();
2169 
2170                 try {
2171                     final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
2172                     final int intentIndex = c.getColumnIndexOrThrow
2173                             (LauncherSettings.Favorites.INTENT);
2174                     final int titleIndex = c.getColumnIndexOrThrow
2175                             (LauncherSettings.Favorites.TITLE);
2176                     final int iconTypeIndex = c.getColumnIndexOrThrow(
2177                             LauncherSettings.Favorites.ICON_TYPE);
2178                     final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
2179                     final int iconPackageIndex = c.getColumnIndexOrThrow(
2180                             LauncherSettings.Favorites.ICON_PACKAGE);
2181                     final int iconResourceIndex = c.getColumnIndexOrThrow(
2182                             LauncherSettings.Favorites.ICON_RESOURCE);
2183                     final int containerIndex = c.getColumnIndexOrThrow(
2184                             LauncherSettings.Favorites.CONTAINER);
2185                     final int itemTypeIndex = c.getColumnIndexOrThrow(
2186                             LauncherSettings.Favorites.ITEM_TYPE);
2187                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(
2188                             LauncherSettings.Favorites.APPWIDGET_ID);
2189                     final int appWidgetProviderIndex = c.getColumnIndexOrThrow(
2190                             LauncherSettings.Favorites.APPWIDGET_PROVIDER);
2191                     final int screenIndex = c.getColumnIndexOrThrow(
2192                             LauncherSettings.Favorites.SCREEN);
2193                     final int cellXIndex = c.getColumnIndexOrThrow
2194                             (LauncherSettings.Favorites.CELLX);
2195                     final int cellYIndex = c.getColumnIndexOrThrow
2196                             (LauncherSettings.Favorites.CELLY);
2197                     final int spanXIndex = c.getColumnIndexOrThrow
2198                             (LauncherSettings.Favorites.SPANX);
2199                     final int spanYIndex = c.getColumnIndexOrThrow(
2200                             LauncherSettings.Favorites.SPANY);
2201                     final int restoredIndex = c.getColumnIndexOrThrow(
2202                             LauncherSettings.Favorites.RESTORED);
2203                     final int profileIdIndex = c.getColumnIndexOrThrow(
2204                             LauncherSettings.Favorites.PROFILE_ID);
2205                     //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
2206                     //final int displayModeIndex = c.getColumnIndexOrThrow(
2207                     //        LauncherSettings.Favorites.DISPLAY_MODE);
2208 
2209                     ShortcutInfo info;
2210                     String intentDescription;
2211                     LauncherAppWidgetInfo appWidgetInfo;
2212                     int container;
2213                     long id;
2214                     Intent intent;
2215                     UserHandleCompat user;
2216 
2217                     while (!mStopped &amp;&amp; c.moveToNext()) {
2218                         AtomicBoolean deleteOnInvalidPlacement = new AtomicBoolean(false);
2219                         try {
2220                             int itemType = c.getInt(itemTypeIndex);
2221                             boolean restored = 0 != c.getInt(restoredIndex);
2222                             boolean allowMissingTarget = false;
2223 
2224                             switch (itemType) {
2225                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
2226                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
2227                                 id = c.getLong(idIndex);
2228                                 intentDescription = c.getString(intentIndex);
2229                                 long serialNumber = c.getInt(profileIdIndex);
2230                                 user = mUserManager.getUserForSerialNumber(serialNumber);
2231                                 int promiseType = c.getInt(restoredIndex);
2232                                 if (user == null) {
2233                                     // User has been deleted remove the item.
2234                                     itemsToRemove.add(id);
2235                                     continue;
2236                                 }
2237                                 try {
2238                                     intent = Intent.parseUri(intentDescription, 0);
2239                                     ComponentName cn = intent.getComponent();
2240                                     if (cn != null &amp;&amp; cn.getPackageName() != null) {
2241                                         boolean validPkg = launcherApps.isPackageEnabledForProfile(
2242                                                 cn.getPackageName(), user);
2243                                         boolean validComponent = validPkg &amp;&amp;
2244                                                 launcherApps.isActivityEnabledForProfile(cn, user);
2245 
2246                                         if (validComponent) {
2247                                             if (restored) {
2248                                                 // no special handling necessary for this item
2249                                                 restoredRows.add(id);
2250                                                 restored = false;
2251                                             }
2252                                         } else if (validPkg) {
2253                                             intent = null;
2254                                             if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
2255                                                 // We allow auto install apps to have their intent
2256                                                 // updated after an install.
2257                                                 intent = manager.getLaunchIntentForPackage(
2258                                                         cn.getPackageName());
2259                                                 if (intent != null) {
2260                                                     ContentValues values = new ContentValues();
2261                                                     values.put(LauncherSettings.Favorites.INTENT,
2262                                                             intent.toUri(0));
2263                                                     String where = BaseColumns._ID + &quot;= ?&quot;;
2264                                                     String[] args = {Long.toString(id)};
<abbr title="2265                                                     contentResolver.update(contentUri, values, where, args);">2265                                                     contentResolver.update(contentUri, values, where, arg</abbr>
2266                                                 }
2267                                             }
2268 
2269                                             if (intent == null) {
2270                                                 // The app is installed but the component is no
2271                                                 // longer available.
2272                                                 Launcher.addDumpLog(TAG,
2273                                                         &quot;Invalid component removed: &quot; + cn, true);
2274                                                 itemsToRemove.add(id);
2275                                                 continue;
2276                                             } else {
2277                                                 // no special handling necessary for this item
2278                                                 restoredRows.add(id);
2279                                                 restored = false;
2280                                             }
2281                                         } else if (restored) {
2282                                             // Package is not yet available but might be
2283                                             // installed later.
2284                                             Launcher.addDumpLog(TAG,
2285                                                     &quot;package not yet restored: &quot; + cn, true);
2286 
2287                                             if ((promiseType &amp; ShortcutInfo.FLAG_RESTORE_STARTED) != 0) {
2288                                                 // Restore has started once.
2289                                             } else if (installingPkgs.contains(cn.getPackageName())) {
2290                                                 // App restore has started. Update the flag
2291                                                 promiseType |= ShortcutInfo.FLAG_RESTORE_STARTED;
2292                                                 ContentValues values = new ContentValues();
2293                                                 values.put(LauncherSettings.Favorites.RESTORED,
2294                                                         promiseType);
2295                                                 String where = BaseColumns._ID + &quot;= ?&quot;;
2296                                                 String[] args = {Long.toString(id)};
2297                                                 contentResolver.update(contentUri, values, where, args);
2298 
2299                                             } else if (REMOVE_UNRESTORED_ICONS) {
2300                                                 Launcher.addDumpLog(TAG,
2301                                                         &quot;Unrestored package removed: &quot; + cn, true);
2302                                                 itemsToRemove.add(id);
2303                                                 continue;
2304                                             }
2305                                         } else if (isSdCardReady) {
2306                                             // Do not wait for external media load anymore.
2307                                             // Log the invalid package, and remove it
2308                                             Launcher.addDumpLog(TAG,
2309                                                     &quot;Invalid package removed: &quot; + cn, true);
2310                                             itemsToRemove.add(id);
2311                                             continue;
2312                                         } else {
2313                                             // SdCard is not ready yet. Package might get available,
2314                                             // once it is ready.
2315                                             Launcher.addDumpLog(TAG, &quot;Invalid package: &quot; + cn
2316                                                     + &quot; (check again later)&quot;, true);
2317                                             HashSet&lt;String&gt; pkgs = sPendingPackages.get(user);
2318                                             if (pkgs == null) {
2319                                                 pkgs = new HashSet&lt;String&gt;();
2320                                                 sPendingPackages.put(user, pkgs);
2321                                             }
2322                                             pkgs.add(cn.getPackageName());
2323                                             allowMissingTarget = true;
2324                                             // Add the icon on the workspace anyway.
2325                                         }
2326                                     } else if (cn == null) {
2327                                         // For shortcuts with no component, keep them as they are
2328                                         restoredRows.add(id);
2329                                         restored = false;
2330                                     }
2331                                 } catch (URISyntaxException e) {
2332                                     Launcher.addDumpLog(TAG,
2333                                             &quot;Invalid uri: &quot; + intentDescription, true);
2334                                     continue;
2335                                 }
2336 
2337                                 if (restored) {
2338                                     if (user.equals(UserHandleCompat.myUserHandle())) {
2339                                         Launcher.addDumpLog(TAG,
2340                                                 &quot;constructing info for partially restored package&quot;,
2341                                                 true);
2342                                         info = getRestoredItemInfo(c, titleIndex, intent, promiseType);
2343                                         intent = getRestoredItemIntent(c, context, intent);
2344                                     } else {
2345                                         // Don&#x27;t restore items for other profiles.
2346                                         itemsToRemove.add(id);
2347                                         continue;
2348                                     }
2349                                 } else if (itemType ==
2350                                         LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
2351                                     info = getShortcutInfo(manager, intent, user, context, c,
2352                                             iconIndex, titleIndex, mLabelCache, allowMissingTarget);
2353                                 } else {
2354                                     info = getShortcutInfo(c, context, iconTypeIndex,
2355                                             iconPackageIndex, iconResourceIndex, iconIndex,
2356                                             titleIndex);
2357 
2358                                     // App shortcuts that used to be automatically added to Launcher
2359                                     // didn&#x27;t always have the correct intent flags set, so do that
2360                                     // here
2361                                     if (intent.getAction() != null &amp;&amp;
2362                                         intent.getCategories() != null &amp;&amp;
2363                                         intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
2364                                         intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
2365                                         intent.addFlags(
2366                                             Intent.FLAG_ACTIVITY_NEW_TASK |
2367                                             Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
2368                                     }
2369                                 }
2370 
2371                                 if (info != null) {
2372                                     info.id = id;
2373                                     info.intent = intent;
2374                                     container = c.getInt(containerIndex);
2375                                     info.container = container;
2376                                     info.screenId = c.getInt(screenIndex);
2377                                     info.cellX = c.getInt(cellXIndex);
2378                                     info.cellY = c.getInt(cellYIndex);
2379                                     info.spanX = 1;
2380                                     info.spanY = 1;
2381                                     info.intent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);
2382                                     info.isDisabled = isSafeMode
2383                                             &amp;&amp; !Utilities.isSystemApp(context, intent);
2384 
2385                                     // check &amp; update map of what&#x27;s occupied
2386                                     deleteOnInvalidPlacement.set(false);
2387                                     if (!checkItemPlacement(occupied, info, deleteOnInvalidPlacement)) {
2388                                         if (deleteOnInvalidPlacement.get()) {
2389                                             itemsToRemove.add(id);
2390                                         }
2391                                         break;
2392                                     }
2393 
2394                                     switch (container) {
2395                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2396                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2397                                         sBgWorkspaceItems.add(info);
2398                                         break;
2399                                     default:
2400                                         // Item is in a user folder
2401                                         FolderInfo folderInfo =
2402                                                 findOrMakeFolder(sBgFolders, container);
2403                                         folderInfo.add(info);
2404                                         break;
2405                                     }
2406                                     sBgItemsIdMap.put(info.id, info);
2407 
2408                                     // now that we&#x27;ve loaded everthing re-save it with the
2409                                     // icon in case it disappears somehow.
2410                                     queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
2411                                 } else {
2412                                     throw new RuntimeException(&quot;Unexpected null ShortcutInfo&quot;);
2413                                 }
2414                                 break;
2415 
2416                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
2417                                 id = c.getLong(idIndex);
2418                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
2419 
2420                                 folderInfo.title = c.getString(titleIndex);
2421                                 folderInfo.id = id;
2422                                 container = c.getInt(containerIndex);
2423                                 folderInfo.container = container;
2424                                 folderInfo.screenId = c.getInt(screenIndex);
2425                                 folderInfo.cellX = c.getInt(cellXIndex);
2426                                 folderInfo.cellY = c.getInt(cellYIndex);
2427                                 folderInfo.spanX = 1;
2428                                 folderInfo.spanY = 1;
2429 
2430                                 // check &amp; update map of what&#x27;s occupied
2431                                 deleteOnInvalidPlacement.set(false);
2432                                 if (!checkItemPlacement(occupied, folderInfo,
2433                                         deleteOnInvalidPlacement)) {
2434                                     if (deleteOnInvalidPlacement.get()) {
2435                                         itemsToRemove.add(id);
2436                                     }
2437                                     break;
2438                                 }
2439 
2440                                 switch (container) {
2441                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2442                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2443                                         sBgWorkspaceItems.add(folderInfo);
2444                                         break;
2445                                 }
2446 
2447                                 if (restored) {
2448                                     // no special handling required for restored folders
2449                                     restoredRows.add(id);
2450                                 }
2451 
2452                                 sBgItemsIdMap.put(folderInfo.id, folderInfo);
2453                                 sBgFolders.put(folderInfo.id, folderInfo);
2454                                 break;
2455 
2456                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
2457                                 // Read all Launcher-specific widget details
2458                                 int appWidgetId = c.getInt(appWidgetIdIndex);
2459                                 String savedProvider = c.getString(appWidgetProviderIndex);
2460                                 id = c.getLong(idIndex);
2461                                 final ComponentName component =
2462                                         ComponentName.unflattenFromString(savedProvider);
2463 
2464                                 final int restoreStatus = c.getInt(restoredIndex);
2465                                 final boolean isIdValid = (restoreStatus &amp;
2466                                         LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) == 0;
2467 
2468                                 final boolean wasProviderReady = (restoreStatus &amp;
2469                                         LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) == 0;
2470 
2471                                 final AppWidgetProviderInfo provider = isIdValid
2472                                         ? widgets.getAppWidgetInfo(appWidgetId)
2473                                         : findAppWidgetProviderInfoWithComponent(context, component);
2474 
2475                                 final boolean isProviderReady = isValidProvider(provider);
2476                                 if (!isSafeMode &amp;&amp; wasProviderReady &amp;&amp; !isProviderReady) {
2477                                     String log = &quot;Deleting widget that isn&#x27;t installed anymore: &quot;
2478                                             + &quot;id=&quot; + id + &quot; appWidgetId=&quot; + appWidgetId;
2479                                     Log.e(TAG, log);
2480                                     Launcher.addDumpLog(TAG, log, false);
2481                                     itemsToRemove.add(id);
2482                                 } else {
2483                                     if (isProviderReady) {
2484                                         appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2485                                                 provider.provider);
2486                                         int[] minSpan =
2487                                                 Launcher.getMinSpanForWidget(context, provider);
2488                                         appWidgetInfo.minSpanX = minSpan[0];
2489                                         appWidgetInfo.minSpanY = minSpan[1];
2490 
2491                                         int status = restoreStatus;
2492                                         if (!wasProviderReady) {
2493                                             // If provider was not previously ready, update the
2494                                             // status and UI flag.
2495 
<abbr title="2496                                             // Id would be valid only if the widget restore broadcast was received.">2496                                             // Id would be valid only if the widget restore broadcast was</abbr>
2497                                             if (isIdValid) {
2498                                                 status = LauncherAppWidgetInfo.RESTORE_COMPLETED;
2499                                             } else {
2500                                                 status &amp;= ~LauncherAppWidgetInfo
2501                                                         .FLAG_PROVIDER_NOT_READY;
2502                                             }
2503                                         }
2504                                         appWidgetInfo.restoreStatus = status;
2505                                     } else {
2506                                         Log.v(TAG, &quot;Widget restore pending id=&quot; + id
2507                                                 + &quot; appWidgetId=&quot; + appWidgetId
2508                                                 + &quot; status =&quot; + restoreStatus);
2509                                         appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2510                                                 component);
2511                                         appWidgetInfo.restoreStatus = restoreStatus;
2512 
<abbr title="2513                                         if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) != 0) {">2513                                         if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) </abbr>
2514                                             // Restore has started once.
2515                                         } else if (installingPkgs.contains(component.getPackageName())) {
2516                                             // App restore has started. Update the flag
2517                                             appWidgetInfo.restoreStatus |=
2518                                                     LauncherAppWidgetInfo.FLAG_RESTORE_STARTED;
2519                                         } else if (REMOVE_UNRESTORED_ICONS) {
2520                                             Launcher.addDumpLog(TAG,
2521                                                     &quot;Unrestored widget removed: &quot; + component, true);
2522                                             itemsToRemove.add(id);
2523                                             continue;
2524                                         }
2525                                     }
2526 
2527                                     appWidgetInfo.id = id;
2528                                     appWidgetInfo.screenId = c.getInt(screenIndex);
2529                                     appWidgetInfo.cellX = c.getInt(cellXIndex);
2530                                     appWidgetInfo.cellY = c.getInt(cellYIndex);
2531                                     appWidgetInfo.spanX = c.getInt(spanXIndex);
2532                                     appWidgetInfo.spanY = c.getInt(spanYIndex);
2533 
2534                                     container = c.getInt(containerIndex);
2535                                     if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2536                                         container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2537                                         Log.e(TAG, &quot;Widget found where container != &quot; +
2538                                             &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
2539                                         continue;
2540                                     }
2541 
2542                                     appWidgetInfo.container = c.getInt(containerIndex);
2543                                     // check &amp; update map of what&#x27;s occupied
2544                                     deleteOnInvalidPlacement.set(false);
2545                                     if (!checkItemPlacement(occupied, appWidgetInfo,
2546                                             deleteOnInvalidPlacement)) {
2547                                         if (deleteOnInvalidPlacement.get()) {
2548                                             itemsToRemove.add(id);
2549                                         }
2550                                         break;
2551                                     }
2552 
2553                                     String providerName = appWidgetInfo.providerName.flattenToString();
2554                                     if (!providerName.equals(savedProvider) ||
2555                                             (appWidgetInfo.restoreStatus != restoreStatus)) {
2556                                         ContentValues values = new ContentValues();
2557                                         values.put(LauncherSettings.Favorites.APPWIDGET_PROVIDER,
2558                                                 providerName);
2559                                         values.put(LauncherSettings.Favorites.RESTORED,
2560                                                 appWidgetInfo.restoreStatus);
2561                                         String where = BaseColumns._ID + &quot;= ?&quot;;
2562                                         String[] args = {Long.toString(id)};
2563                                         contentResolver.update(contentUri, values, where, args);
2564                                     }
2565                                     sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
2566                                     sBgAppWidgets.add(appWidgetInfo);
2567                                 }
2568                                 break;
2569                             }
2570                         } catch (Exception e) {
2571                             Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;, e, true);
2572                         }
2573                     }
2574                 } finally {
2575                     if (c != null) {
2576                         c.close();
2577                     }
2578                 }
2579 
2580                 // Break early if we&#x27;ve stopped loading
2581                 if (mStopped) {
2582                     clearSBgDataStructures();
2583                     return false;
2584                 }
2585 
2586                 if (itemsToRemove.size() &gt; 0) {
2587                     ContentProviderClient client = contentResolver.acquireContentProviderClient(
2588                             contentUri);
2589                     // Remove dead items
2590                     for (long id : itemsToRemove) {
2591                         if (DEBUG_LOADERS) {
2592                             Log.d(TAG, &quot;Removed id = &quot; + id);
2593                         }
2594                         // Don&#x27;t notify content observers
2595                         try {
2596                             client.delete(LauncherSettings.Favorites.getContentUri(id, false),
2597                                     null, null);
2598                         } catch (RemoteException e) {
2599                             Log.w(TAG, &quot;Could not remove id = &quot; + id);
2600                         }
2601                     }
2602                 }
2603 
2604                 if (restoredRows.size() &gt; 0) {
2605                     ContentProviderClient updater = contentResolver.acquireContentProviderClient(
2606                             contentUri);
2607                     // Update restored items that no longer require special handling
2608                     try {
2609                         StringBuilder selectionBuilder = new StringBuilder();
2610                         selectionBuilder.append(LauncherSettings.Favorites._ID);
2611                         selectionBuilder.append(&quot; IN (&quot;);
2612                         selectionBuilder.append(TextUtils.join(&quot;, &quot;, restoredRows));
2613                         selectionBuilder.append(&quot;)&quot;);
2614                         ContentValues values = new ContentValues();
2615                         values.put(LauncherSettings.Favorites.RESTORED, 0);
2616                         updater.update(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
2617                                 values, selectionBuilder.toString(), null);
2618                     } catch (RemoteException e) {
2619                         Log.w(TAG, &quot;Could not update restored rows&quot;);
2620                     }
2621                 }
2622 
2623                 if (!isSdCardReady &amp;&amp; !sPendingPackages.isEmpty()) {
2624                     context.registerReceiver(new AppsAvailabilityCheck(),
2625                             new IntentFilter(StartupReceiver.SYSTEM_READY),
2626                             null, sWorker);
2627                 }
2628 
2629                 if (loadedOldDb) {
2630                     long maxScreenId = 0;
2631                     // If we&#x27;re importing we use the old screen order.
2632                     for (ItemInfo item: sBgItemsIdMap.values()) {
2633                         long screenId = item.screenId;
2634                         if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2635                                 !sBgWorkspaceScreens.contains(screenId)) {
2636                             sBgWorkspaceScreens.add(screenId);
2637                             if (screenId &gt; maxScreenId) {
2638                                 maxScreenId = screenId;
2639                             }
2640                         }
2641                     }
2642                     Collections.sort(sBgWorkspaceScreens);
2643                     // Log to disk
2644                     Launcher.addDumpLog(TAG, &quot;11683562 -   maxScreenId: &quot; + maxScreenId, true);
2645                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2646                             TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2647 
2648                     LauncherAppState.getLauncherProvider().updateMaxScreenId(maxScreenId);
2649                     updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2650 
2651                     // Update the max item id after we load an old db
2652                     long maxItemId = 0;
2653                     // If we&#x27;re importing we use the old screen order.
2654                     for (ItemInfo item: sBgItemsIdMap.values()) {
2655                         maxItemId = Math.max(maxItemId, item.id);
2656                     }
2657                     LauncherAppState.getLauncherProvider().updateMaxItemId(maxItemId);
2658                 } else {
2659                     TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(mContext);
2660                     for (Integer i : orderedScreens.keySet()) {
2661                         sBgWorkspaceScreens.add(orderedScreens.get(i));
2662                     }
2663                     // Log to disk
2664                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2665                             TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2666 
2667                     // Remove any empty screens
2668                     ArrayList&lt;Long&gt; unusedScreens = new ArrayList&lt;Long&gt;(sBgWorkspaceScreens);
2669                     for (ItemInfo item: sBgItemsIdMap.values()) {
2670                         long screenId = item.screenId;
2671                         if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2672                                 unusedScreens.contains(screenId)) {
2673                             unusedScreens.remove(screenId);
2674                         }
2675                     }
2676 
2677                     // If there are any empty screens remove them, and update.
2678                     if (unusedScreens.size() != 0) {
2679                         // Log to disk
2680                         Launcher.addDumpLog(TAG, &quot;11683562 -   unusedScreens (to be removed): &quot; +
2681                                 TextUtils.join(&quot;, &quot;, unusedScreens), true);
2682 
2683                         sBgWorkspaceScreens.removeAll(unusedScreens);
2684                         updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2685                     }
2686                 }
2687 
2688                 if (DEBUG_LOADERS) {
2689                     Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2690                     Log.d(TAG, &quot;workspace layout: &quot;);
2691                     int nScreens = occupied.size();
2692                     for (int y = 0; y &lt; countY; y++) {
2693                         String line = &quot;&quot;;
2694 
2695                         Iterator&lt;Long&gt; iter = occupied.keySet().iterator();
2696                         while (iter.hasNext()) {
2697                             long screenId = iter.next();
2698                             if (screenId &gt; 0) {
2699                                 line += &quot; | &quot;;
2700                             }
2701                             for (int x = 0; x &lt; countX; x++) {
2702                                 ItemInfo[][] screen = occupied.get(screenId);
2703                                 if (x &lt; screen.length &amp;&amp; y &lt; screen[x].length) {
2704                                     line += (screen[x][y] != null) ? &quot;#&quot; : &quot;.&quot;;
2705                                 } else {
2706                                     line += &quot;!&quot;;
2707                                 }
2708                             }
2709                         }
2710                         Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
2711                     }
2712                 }
2713             }
2714             return loadedOldDb;
2715         }
2716 
2717         /** Filters the set of items who are directly or indirectly (via another container) on the
2718          * specified screen. */
2719         private void filterCurrentWorkspaceItems(long currentScreenId,
2720                 ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
2721                 ArrayList&lt;ItemInfo&gt; currentScreenItems,
2722                 ArrayList&lt;ItemInfo&gt; otherScreenItems) {
2723             // Purge any null ItemInfos
2724             Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
2725             while (iter.hasNext()) {
2726                 ItemInfo i = iter.next();
2727                 if (i == null) {
2728                     iter.remove();
2729                 }
2730             }
2731 
2732             // Order the set of items by their containers first, this allows use to walk through the
2733             // list sequentially, build up a list of containers that are in the specified screen,
2734             // as well as all items in those containers.
2735             Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
2736             Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
2737                 @Override
2738                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2739                     return (int) (lhs.container - rhs.container);
2740                 }
2741             });
2742             for (ItemInfo info : allWorkspaceItems) {
2743                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2744                     if (info.screenId == currentScreenId) {
2745                         currentScreenItems.add(info);
2746                         itemsOnScreen.add(info.id);
2747                     } else {
2748                         otherScreenItems.add(info);
2749                     }
2750                 } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2751                     currentScreenItems.add(info);
2752                     itemsOnScreen.add(info.id);
2753                 } else {
2754                     if (itemsOnScreen.contains(info.container)) {
2755                         currentScreenItems.add(info);
2756                         itemsOnScreen.add(info.id);
2757                     } else {
2758                         otherScreenItems.add(info);
2759                     }
2760                 }
2761             }
2762         }
2763 
2764         /** Filters the set of widgets which are on the specified screen. */
2765         private void filterCurrentAppWidgets(long currentScreenId,
2766                 ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2767                 ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
2768                 ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
2769 
2770             for (LauncherAppWidgetInfo widget : appWidgets) {
2771                 if (widget == null) continue;
2772                 if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2773                         widget.screenId == currentScreenId) {
2774                     currentScreenWidgets.add(widget);
2775                 } else {
2776                     otherScreenWidgets.add(widget);
2777                 }
2778             }
2779         }
2780 
2781         /** Filters the set of folders which are on the specified screen. */
2782         private void filterCurrentFolders(long currentScreenId,
2783                 HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
2784                 HashMap&lt;Long, FolderInfo&gt; folders,
2785                 HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
2786                 HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
2787 
2788             for (long id : folders.keySet()) {
2789                 ItemInfo info = itemsIdMap.get(id);
2790                 FolderInfo folder = folders.get(id);
2791                 if (info == null || folder == null) continue;
2792                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2793                         info.screenId == currentScreenId) {
2794                     currentScreenFolders.put(id, folder);
2795                 } else {
2796                     otherScreenFolders.put(id, folder);
2797                 }
2798             }
2799         }
2800 
2801         /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
2802          * right) */
2803         private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
2804             final LauncherAppState app = LauncherAppState.getInstance();
2805             final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2806             // XXX: review this
2807             Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
2808                 @Override
2809                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2810                     int cellCountX = (int) grid.numColumns;
2811                     int cellCountY = (int) grid.numRows;
2812                     int screenOffset = cellCountX * cellCountY;
2813                     int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
2814                     long lr = (lhs.container * containerOffset + lhs.screenId * screenOffset +
2815                             lhs.cellY * cellCountX + lhs.cellX);
2816                     long rr = (rhs.container * containerOffset + rhs.screenId * screenOffset +
2817                             rhs.cellY * cellCountX + rhs.cellX);
2818                     return (int) (lr - rr);
2819                 }
2820             });
2821         }
2822 
2823         private void bindWorkspaceScreens(final Callbacks oldCallbacks,
2824                 final ArrayList&lt;Long&gt; orderedScreens) {
2825             final Runnable r = new Runnable() {
2826                 @Override
2827                 public void run() {
2828                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2829                     if (callbacks != null) {
2830                         callbacks.bindScreens(orderedScreens);
2831                     }
2832                 }
2833             };
2834             runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2835         }
2836 
2837         private void bindWorkspaceItems(final Callbacks oldCallbacks,
2838                 final ArrayList&lt;ItemInfo&gt; workspaceItems,
2839                 final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2840                 final HashMap&lt;Long, FolderInfo&gt; folders,
2841                 ArrayList&lt;Runnable&gt; deferredBindRunnables) {
2842 
2843             final boolean postOnMainThread = (deferredBindRunnables != null);
2844 
2845             // Bind the workspace items
2846             int N = workspaceItems.size();
2847             for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
2848                 final int start = i;
2849                 final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
2850                 final Runnable r = new Runnable() {
2851                     @Override
2852                     public void run() {
2853                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2854                         if (callbacks != null) {
2855                             callbacks.bindItems(workspaceItems, start, start+chunkSize,
2856                                     false);
2857                         }
2858                     }
2859                 };
2860                 if (postOnMainThread) {
2861                     synchronized (deferredBindRunnables) {
2862                         deferredBindRunnables.add(r);
2863                     }
2864                 } else {
2865                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2866                 }
2867             }
2868 
2869             // Bind the folders
2870             if (!folders.isEmpty()) {
2871                 final Runnable r = new Runnable() {
2872                     public void run() {
2873                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2874                         if (callbacks != null) {
2875                             callbacks.bindFolders(folders);
2876                         }
2877                     }
2878                 };
2879                 if (postOnMainThread) {
2880                     synchronized (deferredBindRunnables) {
2881                         deferredBindRunnables.add(r);
2882                     }
2883                 } else {
2884                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2885                 }
2886             }
2887 
2888             // Bind the widgets, one at a time
2889             N = appWidgets.size();
2890             for (int i = 0; i &lt; N; i++) {
2891                 final LauncherAppWidgetInfo widget = appWidgets.get(i);
2892                 final Runnable r = new Runnable() {
2893                     public void run() {
2894                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2895                         if (callbacks != null) {
2896                             callbacks.bindAppWidget(widget);
2897                         }
2898                     }
2899                 };
2900                 if (postOnMainThread) {
2901                     deferredBindRunnables.add(r);
2902                 } else {
2903                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2904                 }
2905             }
2906         }
2907 
2908         /**
2909          * Binds all loaded data to actual views on the main thread.
2910          */
2911         private void bindWorkspace(int synchronizeBindPage, final boolean isUpgradePath) {
2912             final long t = SystemClock.uptimeMillis();
2913             Runnable r;
2914 
2915             // Don&#x27;t use these two variables in any of the callback runnables.
2916             // Otherwise we hold a reference to them.
2917             final Callbacks oldCallbacks = mCallbacks.get();
2918             if (oldCallbacks == null) {
2919                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2920                 Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
2921                 return;
2922             }
2923 
2924             // Save a copy of all the bg-thread collections
2925             ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
2926             ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
2927                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2928             HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
2929             HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
2930             ArrayList&lt;Long&gt; orderedScreenIds = new ArrayList&lt;Long&gt;();
2931             synchronized (sBgLock) {
2932                 workspaceItems.addAll(sBgWorkspaceItems);
2933                 appWidgets.addAll(sBgAppWidgets);
2934                 folders.putAll(sBgFolders);
2935                 itemsIdMap.putAll(sBgItemsIdMap);
2936                 orderedScreenIds.addAll(sBgWorkspaceScreens);
2937             }
2938 
2939             final boolean isLoadingSynchronously =
2940                     synchronizeBindPage != PagedView.INVALID_RESTORE_PAGE;
2941             int currScreen = isLoadingSynchronously ? synchronizeBindPage :
2942                 oldCallbacks.getCurrentWorkspaceScreen();
2943             if (currScreen &gt;= orderedScreenIds.size()) {
2944                 // There may be no workspace screens (just hotseat items and an empty page).
2945                 currScreen = PagedView.INVALID_RESTORE_PAGE;
2946             }
2947             final int currentScreen = currScreen;
2948             final long currentScreenId = currentScreen &lt; 0
2949                     ? INVALID_SCREEN_ID : orderedScreenIds.get(currentScreen);
2950 
2951             // Load all the items that are on the current page first (and in the process, unbind
2952             // all the existing workspace items before we call startBinding() below.
2953             unbindWorkspaceItemsOnMainThread();
2954 
2955             // Separate the items that are on the current screen, and all the other remaining items
2956             ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2957             ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2958             ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
2959                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2960             ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
2961                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2962             HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
2963             HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
2964 
2965             filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems,
2966                     otherWorkspaceItems);
2967             filterCurrentAppWidgets(currentScreenId, appWidgets, currentAppWidgets,
2968                     otherAppWidgets);
2969             filterCurrentFolders(currentScreenId, itemsIdMap, folders, currentFolders,
2970                     otherFolders);
2971             sortWorkspaceItemsSpatially(currentWorkspaceItems);
2972             sortWorkspaceItemsSpatially(otherWorkspaceItems);
2973 
2974             // Tell the workspace that we&#x27;re about to start binding items
2975             r = new Runnable() {
2976                 public void run() {
2977                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2978                     if (callbacks != null) {
2979                         callbacks.startBinding();
2980                     }
2981                 }
2982             };
2983             runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2984 
2985             bindWorkspaceScreens(oldCallbacks, orderedScreenIds);
2986 
2987             // Load items on the current page
2988             bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
2989                     currentFolders, null);
2990             if (isLoadingSynchronously) {
2991                 r = new Runnable() {
2992                     public void run() {
2993                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2994                         if (callbacks != null &amp;&amp; currentScreen != PagedView.INVALID_RESTORE_PAGE) {
2995                             callbacks.onPageBoundSynchronously(currentScreen);
2996                         }
2997                     }
2998                 };
2999                 runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
3000             }
3001 
3002             // Load all the remaining pages (if we are loading synchronously, we want to defer this
3003             // work until after the first render)
3004             synchronized (mDeferredBindRunnables) {
3005                 mDeferredBindRunnables.clear();
3006             }
3007             bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
3008                     (isLoadingSynchronously ? mDeferredBindRunnables : null));
3009 
3010             // Tell the workspace that we&#x27;re done binding items
3011             r = new Runnable() {
3012                 public void run() {
3013                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
3014                     if (callbacks != null) {
3015                         callbacks.finishBindingItems(isUpgradePath);
3016                     }
3017 
3018                     // If we&#x27;re profiling, ensure this is the last thing in the queue.
3019                     if (DEBUG_LOADERS) {
3020                         Log.d(TAG, &quot;bound workspace in &quot;
3021                             + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
3022                     }
3023 
3024                     mIsLoadingAndBindingWorkspace = false;
3025                 }
3026             };
3027             if (isLoadingSynchronously) {
3028                 synchronized (mDeferredBindRunnables) {
3029                     mDeferredBindRunnables.add(r);
3030                 }
3031             } else {
3032                 runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
3033             }
3034         }
3035 
3036         private void loadAndBindAllApps() {
3037             if (DEBUG_LOADERS) {
3038                 Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
3039             }
3040             if (!mAllAppsLoaded) {
3041                 loadAllApps();
3042                 synchronized (LoaderTask.this) {
3043                     if (mStopped) {
3044                         return;
3045                     }
3046                     mAllAppsLoaded = true;
3047                 }
3048             } else {
3049                 onlyBindAllApps();
3050             }
3051         }
3052 
3053         private void onlyBindAllApps() {
3054             final Callbacks oldCallbacks = mCallbacks.get();
3055             if (oldCallbacks == null) {
3056                 // This launcher has exited and nobody bothered to tell us.  Just bail.
3057                 Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
3058                 return;
3059             }
3060 
3061             // shallow copy
3062             @SuppressWarnings(&quot;unchecked&quot;)
3063             final ArrayList&lt;AppInfo&gt; list
3064                     = (ArrayList&lt;AppInfo&gt;) mBgAllAppsList.data.clone();
3065             Runnable r = new Runnable() {
3066                 public void run() {
3067                     final long t = SystemClock.uptimeMillis();
3068                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
3069                     if (callbacks != null) {
3070                         callbacks.bindAllApplications(list);
3071                     }
3072                     if (DEBUG_LOADERS) {
3073                         Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
3074                                 + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
3075                     }
3076                 }
3077             };
3078             boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
3079             if (isRunningOnMainThread) {
3080                 r.run();
3081             } else {
3082                 mHandler.post(r);
3083             }
3084         }
3085 
3086         private void loadAllApps() {
3087             final long loadTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
3088 
3089             final Callbacks oldCallbacks = mCallbacks.get();
3090             if (oldCallbacks == null) {
3091                 // This launcher has exited and nobody bothered to tell us.  Just bail.
3092                 Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllApps)&quot;);
3093                 return;
3094             }
3095 
3096             final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
3097             mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
3098 
3099             final List&lt;UserHandleCompat&gt; profiles = mUserManager.getUserProfiles();
3100 
3101             // Clear the list of apps
3102             mBgAllAppsList.clear();
3103             for (UserHandleCompat user : profiles) {
3104                 // Query for the set of apps
3105                 final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
3106                 List&lt;LauncherActivityInfoCompat&gt; apps = mLauncherApps.getActivityList(null, user);
3107                 if (DEBUG_LOADERS) {
3108                     Log.d(TAG, &quot;getActivityList took &quot;
3109                             + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms for user &quot; + user);
3110                     Log.d(TAG, &quot;getActivityList got &quot; + apps.size() + &quot; apps for user &quot; + user);
3111                 }
3112                 // Fail if we don&#x27;t have any apps
3113                 if (apps == null || apps.isEmpty()) {
3114                     return;
3115                 }
3116                 // Sort the applications by name
3117                 final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
3118                 Collections.sort(apps,
3119                         new LauncherModel.ShortcutNameComparator(mLabelCache));
3120                 if (DEBUG_LOADERS) {
3121                     Log.d(TAG, &quot;sort took &quot;
3122                             + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);
3123                 }
3124 
3125                 // Create the ApplicationInfos
3126                 for (int i = 0; i &lt; apps.size(); i++) {
3127                     LauncherActivityInfoCompat app = apps.get(i);
3128                     // This builds the icon bitmaps.
3129                     mBgAllAppsList.add(new AppInfo(mContext, app, user, mIconCache, mLabelCache));
3130                 }
3131             }
3132             // Huh? Shouldn&#x27;t this be inside the Runnable below?
3133             final ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added;
3134             mBgAllAppsList.added = new ArrayList&lt;AppInfo&gt;();
3135 
3136             // Post callback on main thread
3137             mHandler.post(new Runnable() {
3138                 public void run() {
3139                     final long bindTime = SystemClock.uptimeMillis();
3140                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
3141                     if (callbacks != null) {
3142                         callbacks.bindAllApplications(added);
3143                         if (DEBUG_LOADERS) {
3144                             Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
3145                                 + (SystemClock.uptimeMillis() - bindTime) + &quot;ms&quot;);
3146                         }
3147                     } else {
3148                         Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
3149                     }
3150                 }
3151             });
3152 
3153             if (DEBUG_LOADERS) {
3154                 Log.d(TAG, &quot;Icons processed in &quot;
3155                         + (SystemClock.uptimeMillis() - loadTime) + &quot;ms&quot;);
3156             }
3157         }
3158 
3159         public void dumpState() {
3160             synchronized (sBgLock) {
3161                 Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
3162                 Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
3163                 Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
3164                 Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
3165                 Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
3166             }
3167         }
3168     }
3169 
3170     void enqueuePackageUpdated(PackageUpdatedTask task) {
3171         sWorker.post(task);
3172     }
3173 
3174     private class AppsAvailabilityCheck extends BroadcastReceiver {
3175 
3176         @Override
3177         public void onReceive(Context context, Intent intent) {
3178             synchronized (sBgLock) {
3179                 final LauncherAppsCompat launcherApps = LauncherAppsCompat
3180                         .getInstance(mApp.getContext());
3181                 ArrayList&lt;String&gt; packagesRemoved;
3182                 for (Entry&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; entry : sPendingPackages.entrySet()) {
3183                     UserHandleCompat user = entry.getKey();
3184                     packagesRemoved = new ArrayList&lt;String&gt;();
3185                     for (String pkg : entry.getValue()) {
3186                         if (!launcherApps.isPackageEnabledForProfile(pkg, user)) {
3187                             Launcher.addDumpLog(TAG, &quot;Package not found: &quot; + pkg, true);
3188                             packagesRemoved.add(pkg);
3189                         }
3190                     }
3191                     if (!packagesRemoved.isEmpty()) {
3192                         enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_REMOVE,
3193                                 packagesRemoved.toArray(new String[packagesRemoved.size()]), user));
3194                     }
3195                 }
3196                 sPendingPackages.clear();
3197             }
3198         }
3199     }
3200 
3201     /**
3202      * Workaround to re-check unrestored items, in-case they were installed but the Package-ADD
3203      * runnable was missed by the launcher.
3204      */
3205     public void recheckRestoredItems(final Context context) {
3206         Runnable r = new Runnable() {
3207 
3208             @Override
3209             public void run() {
3210                 LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3211                 HashSet&lt;String&gt; installedPackages = new HashSet&lt;String&gt;();
3212                 UserHandleCompat user = UserHandleCompat.myUserHandle();
3213                 synchronized(sBgLock) {
3214                     for (ItemInfo info : sBgItemsIdMap.values()) {
3215                         if (info instanceof ShortcutInfo) {
3216                             ShortcutInfo si = (ShortcutInfo) info;
3217                             if (si.isPromise() &amp;&amp; si.getTargetComponent() != null
3218                                     &amp;&amp; launcherApps.isPackageEnabledForProfile(
3219                                             si.getTargetComponent().getPackageName(), user)) {
3220                                 installedPackages.add(si.getTargetComponent().getPackageName());
3221                             }
3222                         } else if (info instanceof LauncherAppWidgetInfo) {
3223                             LauncherAppWidgetInfo widget = (LauncherAppWidgetInfo) info;
3224                             if (widget.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY)
3225                                     &amp;&amp; launcherApps.isPackageEnabledForProfile(
3226                                             widget.providerName.getPackageName(), user)) {
3227                                 installedPackages.add(widget.providerName.getPackageName());
3228                             }
3229                         }
3230                     }
3231                 }
3232 
3233                 if (!installedPackages.isEmpty()) {
3234                     final ArrayList&lt;AppInfo&gt; restoredApps = new ArrayList&lt;AppInfo&gt;();
3235                     for (String pkg : installedPackages) {
3236                         for (LauncherActivityInfoCompat info : launcherApps.getActivityList(pkg, user)) {
3237                             restoredApps.add(new AppInfo(context, info, user, mIconCache, null));
3238                         }
3239                     }
3240 
3241                     final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
3242                     if (!restoredApps.isEmpty()) {
3243                         mHandler.post(new Runnable() {
3244                             public void run() {
3245                                 Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3246                                 if (callbacks == cb &amp;&amp; cb != null) {
3247                                     callbacks.bindAppsRestored(restoredApps);
3248                                 }
3249                             }
3250                         });
3251                     }
3252 
3253                 }
3254             }
3255         };
3256         sWorker.post(r);
3257     }
3258 
3259     private class PackageUpdatedTask implements Runnable {
3260         int mOp;
3261         String[] mPackages;
3262         UserHandleCompat mUser;
3263 
3264         public static final int OP_NONE = 0;
3265         public static final int OP_ADD = 1;
3266         public static final int OP_UPDATE = 2;
3267         public static final int OP_REMOVE = 3; // uninstlled
3268         public static final int OP_UNAVAILABLE = 4; // external media unmounted
3269 
3270 
3271         public PackageUpdatedTask(int op, String[] packages, UserHandleCompat user) {
3272             mOp = op;
3273             mPackages = packages;
3274             mUser = user;
3275         }
3276 
3277         public void run() {
3278             final Context context = mApp.getContext();
3279 
3280             final String[] packages = mPackages;
3281             final int N = packages.length;
3282             switch (mOp) {
3283                 case OP_ADD:
3284                     for (int i=0; i&lt;N; i++) {
3285                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
3286                         mIconCache.remove(packages[i], mUser);
3287                         mBgAllAppsList.addPackage(context, packages[i], mUser);
3288                     }
3289                     break;
3290                 case OP_UPDATE:
3291                     for (int i=0; i&lt;N; i++) {
3292                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
3293                         mBgAllAppsList.updatePackage(context, packages[i], mUser);
3294                         WidgetPreviewLoader.removePackageFromDb(
3295                                 mApp.getWidgetPreviewCacheDb(), packages[i]);
3296                     }
3297                     break;
3298                 case OP_REMOVE:
3299                 case OP_UNAVAILABLE:
3300                     for (int i=0; i&lt;N; i++) {
3301                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
3302                         mBgAllAppsList.removePackage(packages[i], mUser);
3303                         WidgetPreviewLoader.removePackageFromDb(
3304                                 mApp.getWidgetPreviewCacheDb(), packages[i]);
3305                     }
3306                     break;
3307             }
3308 
3309             ArrayList&lt;AppInfo&gt; added = null;
3310             ArrayList&lt;AppInfo&gt; modified = null;
3311             final ArrayList&lt;AppInfo&gt; removedApps = new ArrayList&lt;AppInfo&gt;();
3312 
3313             if (mBgAllAppsList.added.size() &gt; 0) {
3314                 added = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.added);
3315                 mBgAllAppsList.added.clear();
3316             }
3317             if (mBgAllAppsList.modified.size() &gt; 0) {
3318                 modified = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.modified);
3319                 mBgAllAppsList.modified.clear();
3320             }
3321             if (mBgAllAppsList.removed.size() &gt; 0) {
3322                 removedApps.addAll(mBgAllAppsList.removed);
3323                 mBgAllAppsList.removed.clear();
3324             }
3325 
3326             final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
3327             if (callbacks == null) {
3328                 Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
3329                 return;
3330             }
3331 
3332             if (added != null) {
3333                 // Ensure that we add all the workspace applications to the db
3334                 Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3335                 if (!LauncherAppState.isDisableAllApps()) {
3336                     addAndBindAddedApps(context, new ArrayList&lt;ItemInfo&gt;(), cb, added);
3337                 } else {
3338                     final ArrayList&lt;ItemInfo&gt; addedInfos = new ArrayList&lt;ItemInfo&gt;(added);
3339                     addAndBindAddedApps(context, addedInfos, cb, added);
3340                 }
3341             }
3342             if (modified != null) {
3343                 final ArrayList&lt;AppInfo&gt; modifiedFinal = modified;
3344 
3345                 // Update the launcher db to reflect the changes
3346                 for (AppInfo a : modifiedFinal) {
3347                     ArrayList&lt;ItemInfo&gt; infos =
3348                             getItemInfoForComponentName(a.componentName, mUser);
3349                     for (ItemInfo i : infos) {
3350                         if (isShortcutInfoUpdateable(i)) {
3351                             ShortcutInfo info = (ShortcutInfo) i;
3352                             info.title = a.title.toString();
3353                             info.contentDescription = a.contentDescription;
3354                             updateItemInDatabase(context, info);
3355                         }
3356                     }
3357                 }
3358 
3359                 mHandler.post(new Runnable() {
3360                     public void run() {
3361                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3362                         if (callbacks == cb &amp;&amp; cb != null) {
3363                             callbacks.bindAppsUpdated(modifiedFinal);
3364                         }
3365                     }
3366                 });
3367             }
3368 
3369             final ArrayList&lt;String&gt; removedPackageNames =
3370                     new ArrayList&lt;String&gt;();
3371             if (mOp == OP_REMOVE) {
3372                 // Mark all packages in the broadcast to be removed
3373                 removedPackageNames.addAll(Arrays.asList(packages));
3374             } else if (mOp == OP_UPDATE) {
3375                 // Mark disabled packages in the broadcast to be removed
3376                 final PackageManager pm = context.getPackageManager();
3377                 for (int i=0; i&lt;N; i++) {
3378                     if (isPackageDisabled(context, packages[i], mUser)) {
3379                         removedPackageNames.add(packages[i]);
3380                     }
3381                 }
3382             }
3383             // Remove all the components associated with this package
3384             for (String pn : removedPackageNames) {
3385                 deletePackageFromDatabase(context, pn, mUser);
3386             }
3387             // Remove all the specific components
3388             for (AppInfo a : removedApps) {
3389                 ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName, mUser);
3390                 deleteItemsFromDatabase(context, infos);
3391             }
3392             if (!removedPackageNames.isEmpty() || !removedApps.isEmpty()) {
3393                 // Remove any queued items from the install queue
3394                 String spKey = LauncherAppState.getSharedPreferencesKey();
3395                 SharedPreferences sp =
3396                         context.getSharedPreferences(spKey, Context.MODE_PRIVATE);
3397                 InstallShortcutReceiver.removeFromInstallQueue(sp, removedPackageNames);
3398                 // Call the components-removed callback
3399                 mHandler.post(new Runnable() {
3400                     public void run() {
3401                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3402                         if (callbacks == cb &amp;&amp; cb != null) {
3403                             callbacks.bindComponentsRemoved(removedPackageNames, removedApps, mUser);
3404                         }
3405                     }
3406                 });
3407             }
3408 
3409             final ArrayList&lt;Object&gt; widgetsAndShortcuts =
3410                     getSortedWidgetsAndShortcuts(context);
3411             mHandler.post(new Runnable() {
3412                 @Override
3413                 public void run() {
3414                     Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3415                     if (callbacks == cb &amp;&amp; cb != null) {
3416                         callbacks.bindPackagesUpdated(widgetsAndShortcuts);
3417                     }
3418                 }
3419             });
3420 
3421             // Write all the logs to disk
3422             mHandler.post(new Runnable() {
3423                 public void run() {
3424                     Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3425                     if (callbacks == cb &amp;&amp; cb != null) {
3426                         callbacks.dumpLogsToLocalData();
3427                     }
3428                 }
3429             });
3430         }
3431     }
3432 
3433     // Returns a list of ResolveInfos/AppWindowInfos in sorted order
3434     public static ArrayList&lt;Object&gt; getSortedWidgetsAndShortcuts(Context context) {
3435         PackageManager packageManager = context.getPackageManager();
3436         final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();
3437         widgetsAndShortcuts.addAll(AppWidgetManagerCompat.getInstance(context).getAllProviders());
3438 
3439         Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
3440         widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));
3441         Collections.sort(widgetsAndShortcuts, new WidgetAndShortcutNameComparator(context));
3442         return widgetsAndShortcuts;
3443     }
3444 
3445     private static boolean isPackageDisabled(Context context, String packageName,
3446             UserHandleCompat user) {
3447         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3448         return !launcherApps.isPackageEnabledForProfile(packageName, user);
3449     }
3450 
3451     public static boolean isValidPackageActivity(Context context, ComponentName cn,
3452             UserHandleCompat user) {
3453         if (cn == null) {
3454             return false;
3455         }
3456         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3457         if (!launcherApps.isPackageEnabledForProfile(cn.getPackageName(), user)) {
3458             return false;
3459         }
3460         return launcherApps.isActivityEnabledForProfile(cn, user);
3461     }
3462 
3463     public static boolean isValidPackage(Context context, String packageName,
3464             UserHandleCompat user) {
3465         if (packageName == null) {
3466             return false;
3467         }
3468         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3469         return launcherApps.isPackageEnabledForProfile(packageName, user);
3470     }
3471 
3472     /**
3473      * Make an ShortcutInfo object for a restored application or shortcut item that points
3474      * to a package that is not yet installed on the system.
3475      */
3476     public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex, Intent intent,
3477             int promiseType) {
3478         final ShortcutInfo info = new ShortcutInfo();
3479         info.user = UserHandleCompat.myUserHandle();
3480         mIconCache.getTitleAndIcon(info, intent, info.user, true);
3481 
3482         if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_ICON) != 0) {
3483             String title = (cursor != null) ? cursor.getString(titleIndex) : null;
3484             if (!TextUtils.isEmpty(title)) {
3485                 info.title = title;
3486             }
3487             info.status = ShortcutInfo.FLAG_RESTORED_ICON;
3488         } else if  ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
3489             if (TextUtils.isEmpty(info.title)) {
3490                 info.title = (cursor != null) ? cursor.getString(titleIndex) : &quot;&quot;;
3491             }
3492             info.status = ShortcutInfo.FLAG_AUTOINTALL_ICON;
3493         } else {
3494             throw new InvalidParameterException(&quot;Invalid restoreType &quot; + promiseType);
3495         }
3496 
3497         info.contentDescription = mUserManager.getBadgedLabelForUser(
3498                 info.title.toString(), info.user);
3499         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3500         info.promisedIntent = intent;
3501         return info;
3502     }
3503 
3504     /**
3505      * Make an Intent object for a restored application or shortcut item that points
3506      * to the market page for the item.
3507      */
3508     private Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {
3509         ComponentName componentName = intent.getComponent();
3510         return getMarketIntent(componentName.getPackageName());
3511     }
3512 
3513     static Intent getMarketIntent(String packageName) {
3514         return new Intent(Intent.ACTION_VIEW)
3515             .setData(new Uri.Builder()
3516                 .scheme(&quot;market&quot;)
3517                 .authority(&quot;details&quot;)
3518                 .appendQueryParameter(&quot;id&quot;, packageName)
3519                 .build());
3520     }
3521 
3522     /**
3523      * This is called from the code that adds shortcuts from the intent receiver.  This
3524      * doesn&#x27;t have a Cursor, but
3525      */
3526     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,
3527             UserHandleCompat user, Context context) {
3528         return getShortcutInfo(manager, intent, user, context, null, -1, -1, null, false);
3529     }
3530 
3531     /**
3532      * Make an ShortcutInfo object for a shortcut that is an application.
3533      *
3534      * If c is not null, then it will be used to fill in missing data like the title and icon.
3535      */
3536     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,
3537             UserHandleCompat user, Context context, Cursor c, int iconIndex, int titleIndex,
3538             HashMap&lt;Object, CharSequence&gt; labelCache, boolean allowMissingTarget) {
3539         if (user == null) {
3540             Log.d(TAG, &quot;Null user found in getShortcutInfo&quot;);
3541             return null;
3542         }
3543 
3544         ComponentName componentName = intent.getComponent();
3545         if (componentName == null) {
3546             Log.d(TAG, &quot;Missing component found in getShortcutInfo: &quot; + componentName);
3547             return null;
3548         }
3549 
3550         Intent newIntent = new Intent(intent.getAction(), null);
3551         newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
3552         newIntent.setComponent(componentName);
3553         LauncherActivityInfoCompat lai = mLauncherApps.resolveActivity(newIntent, user);
3554         if ((lai == null) &amp;&amp; !allowMissingTarget) {
3555             Log.d(TAG, &quot;Missing activity found in getShortcutInfo: &quot; + componentName);
3556             return null;
3557         }
3558 
3559         final ShortcutInfo info = new ShortcutInfo();
3560 
3561         // the resource -- This may implicitly give us back the fallback icon,
3562         // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
3563         // to avoid saving lots of copies of that in the database, and most apps
3564         // have icons anyway.
3565         Bitmap icon = mIconCache.getIcon(componentName, lai, labelCache);
3566 
3567         // the db
3568         if (icon == null) {
3569             if (c != null) {
3570                 icon = getIconFromCursor(c, iconIndex, context);
3571             }
3572         }
3573         // the fallback icon
3574         if (icon == null) {
3575             icon = mIconCache.getDefaultIcon(user);
3576             info.usingFallbackIcon = true;
3577         }
3578         info.setIcon(icon);
3579 
3580         // From the cache.
3581         if (labelCache != null) {
3582             info.title = labelCache.get(componentName);
3583         }
3584 
3585         // from the resource
3586         if (info.title == null &amp;&amp; lai != null) {
3587             info.title = lai.getLabel();
3588             if (labelCache != null) {
3589                 labelCache.put(componentName, info.title);
3590             }
3591         }
3592         // from the db
3593         if (info.title == null) {
3594             if (c != null) {
3595                 info.title =  c.getString(titleIndex);
3596             }
3597         }
3598         // fall back to the class name of the activity
3599         if (info.title == null) {
3600             info.title = componentName.getClassName();
3601         }
3602         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
3603         info.user = user;
3604         info.contentDescription = mUserManager.getBadgedLabelForUser(
3605                 info.title.toString(), info.user);
3606         return info;
3607     }
3608 
3609     static ArrayList&lt;ItemInfo&gt; filterItemInfos(Collection&lt;ItemInfo&gt; infos,
3610             ItemInfoFilter f) {
3611         HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();
3612         for (ItemInfo i : infos) {
3613             if (i instanceof ShortcutInfo) {
3614                 ShortcutInfo info = (ShortcutInfo) i;
3615                 ComponentName cn = info.getTargetComponent();
3616                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3617                     filtered.add(info);
3618                 }
3619             } else if (i instanceof FolderInfo) {
3620                 FolderInfo info = (FolderInfo) i;
3621                 for (ShortcutInfo s : info.contents) {
3622                     ComponentName cn = s.getTargetComponent();
3623                     if (cn != null &amp;&amp; f.filterItem(info, s, cn)) {
3624                         filtered.add(s);
3625                     }
3626                 }
3627             } else if (i instanceof LauncherAppWidgetInfo) {
3628                 LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) i;
3629                 ComponentName cn = info.providerName;
3630                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3631                     filtered.add(info);
3632                 }
3633             }
3634         }
3635         return new ArrayList&lt;ItemInfo&gt;(filtered);
3636     }
3637 
3638     private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname,
3639             final UserHandleCompat user) {
3640         ItemInfoFilter filter  = new ItemInfoFilter() {
3641             @Override
3642             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
3643                 if (info.user == null) {
3644                     return cn.equals(cname);
3645                 } else {
3646                     return cn.equals(cname) &amp;&amp; info.user.equals(user);
3647                 }
3648             }
3649         };
3650         return filterItemInfos(sBgItemsIdMap.values(), filter);
3651     }
3652 
3653     public static boolean isShortcutInfoUpdateable(ItemInfo i) {
3654         if (i instanceof ShortcutInfo) {
3655             ShortcutInfo info = (ShortcutInfo) i;
3656             // We need to check for ACTION_MAIN otherwise getComponent() might
3657             // return null for some shortcuts (for instance, for shortcuts to
3658             // web pages.)
3659             Intent intent = info.intent;
3660             ComponentName name = intent.getComponent();
3661             if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION &amp;&amp;
3662                     Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3663                 return true;
3664             }
3665             // placeholder shortcuts get special treatment, let them through too.
3666             if (info.isPromise()) {
3667                 return true;
3668             }
3669         }
3670         return false;
3671     }
3672 
3673     /**
3674      * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
3675      */
3676     private ShortcutInfo getShortcutInfo(Cursor c, Context context,
3677             int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
3678             int titleIndex) {
3679 
3680         Bitmap icon = null;
3681         final ShortcutInfo info = new ShortcutInfo();
3682         // Non-app shortcuts are only supported for current user.
3683         info.user = UserHandleCompat.myUserHandle();
3684         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3685 
3686         // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
3687 
3688         info.title = c.getString(titleIndex);
3689 
3690         int iconType = c.getInt(iconTypeIndex);
3691         switch (iconType) {
3692         case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
3693             String packageName = c.getString(iconPackageIndex);
3694             String resourceName = c.getString(iconResourceIndex);
3695             PackageManager packageManager = context.getPackageManager();
3696             info.customIcon = false;
3697             // the resource
3698             try {
3699                 Resources resources = packageManager.getResourcesForApplication(packageName);
3700                 if (resources != null) {
3701                     final int id = resources.getIdentifier(resourceName, null, null);
3702                     icon = Utilities.createIconBitmap(
3703                             mIconCache.getFullResIcon(resources, id), context);
3704                 }
3705             } catch (Exception e) {
3706                 // drop this.  we have other places to look for icons
3707             }
3708             // the db
3709             if (icon == null) {
3710                 icon = getIconFromCursor(c, iconIndex, context);
3711             }
3712             // the fallback icon
3713             if (icon == null) {
3714                 icon = mIconCache.getDefaultIcon(info.user);
3715                 info.usingFallbackIcon = true;
3716             }
3717             break;
3718         case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
3719             icon = getIconFromCursor(c, iconIndex, context);
3720             if (icon == null) {
3721                 icon = mIconCache.getDefaultIcon(info.user);
3722                 info.customIcon = false;
3723                 info.usingFallbackIcon = true;
3724             } else {
3725                 info.customIcon = true;
3726             }
3727             break;
3728         default:
3729             icon = mIconCache.getDefaultIcon(info.user);
3730             info.usingFallbackIcon = true;
3731             info.customIcon = false;
3732             break;
3733         }
3734         info.setIcon(icon);
3735         return info;
3736     }
3737 
3738     Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
3739         @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
3740         final boolean debug = false;
3741         if (debug) {
3742             Log.d(TAG, &quot;getIconFromCursor app=&quot;
3743                     + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
3744         }
3745         byte[] data = c.getBlob(iconIndex);
3746         try {
3747             return Utilities.createIconBitmap(
3748                     BitmapFactory.decodeByteArray(data, 0, data.length), context);
3749         } catch (Exception e) {
3750             return null;
3751         }
3752     }
3753 
3754     ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
3755             int cellX, int cellY, boolean notify) {
3756         final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
3757         if (info == null) {
3758             return null;
3759         }
3760         addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
3761 
3762         return info;
3763     }
3764 
3765     /**
3766      * Attempts to find an AppWidgetProviderInfo that matches the given component.
3767      */
3768     static AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,
3769             ComponentName component) {
3770         List&lt;AppWidgetProviderInfo&gt; widgets =
3771             AppWidgetManager.getInstance(context).getInstalledProviders();
3772         for (AppWidgetProviderInfo info : widgets) {
3773             if (info.provider.equals(component)) {
3774                 return info;
3775             }
3776         }
3777         return null;
3778     }
3779 
3780     ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
3781         Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
3782         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
3783         Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
3784 
3785         if (intent == null) {
3786             // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
3787             Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
3788             return null;
3789         }
3790 
3791         Bitmap icon = null;
3792         boolean customIcon = false;
3793         ShortcutIconResource iconResource = null;
3794 
3795         if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {
3796             icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);
3797             customIcon = true;
3798         } else {
3799             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
3800             if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {
3801                 try {
3802                     iconResource = (ShortcutIconResource) extra;
3803                     final PackageManager packageManager = context.getPackageManager();
3804                     Resources resources = packageManager.getResourcesForApplication(
3805                             iconResource.packageName);
3806                     final int id = resources.getIdentifier(iconResource.resourceName, null, null);
3807                     icon = Utilities.createIconBitmap(
3808                             mIconCache.getFullResIcon(resources, id),
3809                             context);
3810                 } catch (Exception e) {
3811                     Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);
3812                 }
3813             }
3814         }
3815 
3816         final ShortcutInfo info = new ShortcutInfo();
3817 
3818         // Only support intents for current user for now. Intents sent from other
3819         // users wouldn&#x27;t get here without intent forwarding anyway.
3820         info.user = UserHandleCompat.myUserHandle();
3821         if (icon == null) {
3822             if (fallbackIcon != null) {
3823                 icon = fallbackIcon;
3824             } else {
3825                 icon = mIconCache.getDefaultIcon(info.user);
3826                 info.usingFallbackIcon = true;
3827             }
3828         }
3829         info.setIcon(icon);
3830 
3831         info.title = name;
3832         info.contentDescription = mUserManager.getBadgedLabelForUser(
3833                 info.title.toString(), info.user);
3834         info.intent = intent;
3835         info.customIcon = customIcon;
3836         info.iconResource = iconResource;
3837 
3838         return info;
3839     }
3840 
3841     boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
3842             int iconIndex) {
3843         // If apps can&#x27;t be on SD, don&#x27;t even bother.
3844         if (!mAppsCanBeOnRemoveableStorage) {
3845             return false;
3846         }
3847         // If this icon doesn&#x27;t have a custom icon, check to see
3848         // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
3849         // we&#x27;re going to show, store what we are going to show back
3850         // into the DB.  We do this so when we&#x27;re loading, if the
3851         // package manager can&#x27;t find an icon (for example because
3852         // the app is on SD) then we can use that instead.
3853         if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
3854             cache.put(info, c.getBlob(iconIndex));
3855             return true;
3856         }
3857         return false;
3858     }
3859     void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
3860         boolean needSave = false;
3861         try {
3862             if (data != null) {
3863                 Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
3864                 Bitmap loaded = info.getIcon(mIconCache);
3865                 needSave = !saved.sameAs(loaded);
3866             } else {
3867                 needSave = true;
3868             }
3869         } catch (Exception e) {
3870             needSave = true;
3871         }
3872         if (needSave) {
3873             Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
3874             // This is slower than is ideal, but this only happens once
3875             // or when the app is updated with a new icon.
3876             updateItemInDatabase(context, info);
3877         }
3878     }
3879 
3880     /**
3881      * Return an existing FolderInfo object if we have encountered this ID previously,
3882      * or make a new one.
3883      */
3884     private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
3885         // See if a placeholder was created for us already
3886         FolderInfo folderInfo = folders.get(id);
3887         if (folderInfo == null) {
3888             // No placeholder -- create a new instance
3889             folderInfo = new FolderInfo();
3890             folders.put(id, folderInfo);
3891         }
3892         return folderInfo;
3893     }
3894 
3895     public static final Comparator&lt;AppInfo&gt; getAppNameComparator() {
3896         final Collator collator = Collator.getInstance();
3897         return new Comparator&lt;AppInfo&gt;() {
3898             public final int compare(AppInfo a, AppInfo b) {
3899                 if (a.user.equals(b.user)) {
3900                     int result = collator.compare(a.title.toString().trim(),
3901                             b.title.toString().trim());
3902                     if (result == 0) {
3903                         result = a.componentName.compareTo(b.componentName);
3904                     }
3905                     return result;
3906                 } else {
3907                     // TODO Need to figure out rules for sorting
3908                     // profiles, this puts work second.
3909                     return a.user.toString().compareTo(b.user.toString());
3910                 }
3911             }
3912         };
3913     }
3914     public static final Comparator&lt;AppInfo&gt; APP_INSTALL_TIME_COMPARATOR
3915             = new Comparator&lt;AppInfo&gt;() {
3916         public final int compare(AppInfo a, AppInfo b) {
3917             if (a.firstInstallTime &lt; b.firstInstallTime) return 1;
3918             if (a.firstInstallTime &gt; b.firstInstallTime) return -1;
3919             return 0;
3920         }
3921     };
3922     static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
3923         if (info.activityInfo != null) {
3924             return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
3925         } else {
3926             return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
3927         }
3928     }
3929     public static class ShortcutNameComparator implements Comparator&lt;LauncherActivityInfoCompat&gt; {
3930         private Collator mCollator;
3931         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
3932         ShortcutNameComparator(PackageManager pm) {
3933             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
3934             mCollator = Collator.getInstance();
3935         }
3936         ShortcutNameComparator(HashMap&lt;Object, CharSequence&gt; labelCache) {
3937             mLabelCache = labelCache;
3938             mCollator = Collator.getInstance();
3939         }
3940         public final int compare(LauncherActivityInfoCompat a, LauncherActivityInfoCompat b) {
3941             String labelA, labelB;
3942             ComponentName keyA = a.getComponentName();
3943             ComponentName keyB = b.getComponentName();
3944             if (mLabelCache.containsKey(keyA)) {
3945                 labelA = mLabelCache.get(keyA).toString();
3946             } else {
3947                 labelA = a.getLabel().toString().trim();
3948 
3949                 mLabelCache.put(keyA, labelA);
3950             }
3951             if (mLabelCache.containsKey(keyB)) {
3952                 labelB = mLabelCache.get(keyB).toString();
3953             } else {
3954                 labelB = b.getLabel().toString().trim();
3955 
3956                 mLabelCache.put(keyB, labelB);
3957             }
3958             return mCollator.compare(labelA, labelB);
3959         }
3960     };
3961     public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
3962         private final AppWidgetManagerCompat mManager;
3963         private final PackageManager mPackageManager;
3964         private final HashMap&lt;Object, String&gt; mLabelCache;
3965         private final Collator mCollator;
3966 
3967         WidgetAndShortcutNameComparator(Context context) {
3968             mManager = AppWidgetManagerCompat.getInstance(context);
3969             mPackageManager = context.getPackageManager();
3970             mLabelCache = new HashMap&lt;Object, String&gt;();
3971             mCollator = Collator.getInstance();
3972         }
3973         public final int compare(Object a, Object b) {
3974             String labelA, labelB;
3975             if (mLabelCache.containsKey(a)) {
3976                 labelA = mLabelCache.get(a);
3977             } else {
3978                 labelA = (a instanceof AppWidgetProviderInfo)
3979                         ? mManager.loadLabel((AppWidgetProviderInfo) a)
3980                         : ((ResolveInfo) a).loadLabel(mPackageManager).toString().trim();
3981                 mLabelCache.put(a, labelA);
3982             }
3983             if (mLabelCache.containsKey(b)) {
3984                 labelB = mLabelCache.get(b);
3985             } else {
3986                 labelB = (b instanceof AppWidgetProviderInfo)
3987                         ? mManager.loadLabel((AppWidgetProviderInfo) b)
3988                         : ((ResolveInfo) b).loadLabel(mPackageManager).toString().trim();
3989                 mLabelCache.put(b, labelB);
3990             }
3991             return mCollator.compare(labelA, labelB);
3992         }
3993     };
3994 
3995     static boolean isValidProvider(AppWidgetProviderInfo provider) {
3996         return (provider != null) &amp;&amp; (provider.provider != null)
3997                 &amp;&amp; (provider.provider.getPackageName() != null);
3998     }
3999 
4000     public void dumpState() {
4001         Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
4002         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
4003         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
4004         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
4005         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
4006         if (mLoaderTask != null) {
4007             mLoaderTask.dumpState();
4008         } else {
4009             Log.d(TAG, &quot;mLoaderTask=null&quot;);
4010         }
4011     }
4012 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher3;
  18 
  19 import android.app.SearchManager;
  20 import android.appwidget.AppWidgetManager;
  21 import android.appwidget.AppWidgetProviderInfo;
  22 import android.content.BroadcastReceiver;
  23 import android.content.ComponentName;
  24 import android.content.ContentProviderClient;
  25 import android.content.ContentProviderOperation;
  26 import android.content.ContentResolver;
  27 import android.content.ContentValues;
  28 import android.content.Context;
  29 import android.content.Intent;
  30 import android.content.Intent.ShortcutIconResource;
  31 import android.content.IntentFilter;
  32 import android.content.SharedPreferences;
  33 import android.content.pm.PackageManager;
  34 import android.content.pm.ProviderInfo;
  35 import android.content.pm.ResolveInfo;
  36 import android.content.res.Configuration;
  37 import android.content.res.Resources;
  38 import android.database.Cursor;
  39 import android.graphics.Bitmap;
  40 import android.graphics.BitmapFactory;
  41 import android.net.Uri;
  42 import android.os.Environment;
  43 import android.os.Handler;
  44 import android.os.HandlerThread;
  45 import android.os.Parcelable;
  46 import android.os.Process;
  47 import android.os.RemoteException;
  48 import android.os.SystemClock;
  49 import android.provider.BaseColumns;
  50 import android.text.TextUtils;
  51 import android.util.Log;
  52 import android.util.Pair;
  53 
  54 import com.android.launcher3.compat.AppWidgetManagerCompat;
  55 import com.android.launcher3.compat.LauncherActivityInfoCompat;
  56 import com.android.launcher3.compat.LauncherAppsCompat;
  57 import com.android.launcher3.compat.PackageInstallerCompat;
  58 import com.android.launcher3.compat.PackageInstallerCompat.PackageInstallInfo;
  59 import com.android.launcher3.compat.UserHandleCompat;
  60 import com.android.launcher3.compat.UserManagerCompat;
  61 
  62 import java.lang.ref.WeakReference;
  63 import java.net.URISyntaxException;
  64 import java.security.InvalidParameterException;
  65 import java.text.Collator;
  66 import java.util.ArrayList;
  67 import java.util.Arrays;
  68 import java.util.Collection;
  69 import java.util.Collections;
  70 import java.util.Comparator;
  71 import java.util.HashMap;
  72 import java.util.HashSet;
  73 import java.util.Iterator;
  74 import java.util.List;
  75 import java.util.Map.Entry;
  76 import java.util.Set;
  77 import java.util.TreeMap;
  78 import java.util.concurrent.atomic.AtomicBoolean;
  79 
  80 /**
  81  * Maintains in-memory state of the Launcher. It is expected that there should be only one
  82  * LauncherModel object held in a static. Also provide APIs for updating the database state
  83  * for the Launcher.
  84  */
  85 public class LauncherModel extends BroadcastReceiver
  86         implements LauncherAppsCompat.OnAppsChangedCallbackCompat {
  87     static final boolean DEBUG_LOADERS = false;
  88     private static final boolean DEBUG_RECEIVER = false;
  89     private static final boolean REMOVE_UNRESTORED_ICONS = true;
  90 
  91     static final String TAG = &quot;Launcher.Model&quot;;
  92 
  93     // true = use a &quot;More Apps&quot; folder for non-workspace apps on upgrade
  94     // false = strew non-workspace apps across the workspace on upgrade
  95     public static final boolean UPGRADE_USE_MORE_APPS_FOLDER = false;
  96     public static final int LOADER_FLAG_NONE = 0;
  97     public static final int LOADER_FLAG_CLEAR_WORKSPACE = 1 &lt;&lt; 0;
  98     public static final int LOADER_FLAG_MIGRATE_SHORTCUTS = 1 &lt;&lt; 1;
  99 
 100     private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
 101     private static final long INVALID_SCREEN_ID = -1L;
 102 
 103     private final boolean mAppsCanBeOnRemoveableStorage;
 104     private final boolean mOldContentProviderExists;
 105 
 106     private final LauncherAppState mApp;
 107     private final Object mLock = new Object();
 108     private DeferredHandler mHandler = new DeferredHandler();
 109     private LoaderTask mLoaderTask;
 110     private boolean mIsLoaderTaskRunning;
 111     private volatile boolean mFlushingWorkerThread;
 112 
 113     // Specific runnable types that are run on the main thread deferred handler, this allows us to
 114     // clear all queued binding runnables when the Launcher activity is destroyed.
 115     private static final int MAIN_THREAD_NORMAL_RUNNABLE = 0;
 116     private static final int MAIN_THREAD_BINDING_RUNNABLE = 1;
 117 
 118     private static final String MIGRATE_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
 119 
 120     private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
 121     static {
 122         sWorkerThread.start();
 123     }
 124     private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
 125 
 126     // We start off with everything not loaded.  After that, we assume that
 127     // our monitoring of the package manager provides all updates and we never
 128     // need to do a requery.  These are only ever touched from the loader thread.
 129     private boolean mWorkspaceLoaded;
 130     private boolean mAllAppsLoaded;
 131 
 132     // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
 133     // pages as this delays the rotation process.  Instead, we wait for a callback from the first
 134     // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 135     // a normal load, we also clear this set of Runnables.
 136     static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 137 
 138     private WeakReference&lt;Callbacks&gt; mCallbacks;
 139 
 140     // &lt; only access in worker thread &gt;
 141     AllAppsList mBgAllAppsList;
 142 
 143     // The lock that must be acquired before referencing any static bg data structures.  Unlike
 144     // other locks, this one can generally be held long-term because we never expect any of these
 145     // static data structures to be referenced outside of the worker thread except on the first
 146     // load after configuration change.
 147     static final Object sBgLock = new Object();
 148 
 149     // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 150     // LauncherModel to their ids
 151     static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
 152 
 153     // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 154     //       created by LauncherModel that are directly on the home screen (however, no widgets or
 155     //       shortcuts within folders).
 156     static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 157 
 158     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 159     static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 160         new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 161 
 162     // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 163     static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 164 
 165     // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 166     static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 167 
 168     // sBgWorkspaceScreens is the ordered set of workspace screens.
 169     static final ArrayList&lt;Long&gt; sBgWorkspaceScreens = new ArrayList&lt;Long&gt;();
 170 
 171     // sPendingPackages is a set of packages which could be on sdcard and are not available yet
 172     static final HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; sPendingPackages =
 173             new HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt;();
 174 
 175     // &lt;/ only access in worker thread &gt;
 176 
 177     private IconCache mIconCache;
 178 
 179     protected int mPreviousConfigMcc;
 180 
 181     private final LauncherAppsCompat mLauncherApps;
 182     private final UserManagerCompat mUserManager;
 183 
 184     public interface Callbacks {
 185         public boolean setLoadOnResume();
 186         public int getCurrentWorkspaceScreen();
 187         public void startBinding();
 188         public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end,
 189                               boolean forceAnimateIcons);
 190         public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 191         public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 192         public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 193         public void finishBindingItems(boolean upgradePath);
 194         public void bindAppWidget(LauncherAppWidgetInfo info);
 195         public void bindAllApplications(ArrayList&lt;AppInfo&gt; apps);
 196         public void bindAppsAdded(ArrayList&lt;Long&gt; newScreens,
 197                                   ArrayList&lt;ItemInfo&gt; addNotAnimated,
 198                                   ArrayList&lt;ItemInfo&gt; addAnimated,
 199                                   ArrayList&lt;AppInfo&gt; addedApps);
 200         public void bindAppsUpdated(ArrayList&lt;AppInfo&gt; apps);
 201         public void bindAppsRestored(ArrayList&lt;AppInfo&gt; apps);
 202         public void updatePackageState(ArrayList&lt;PackageInstallInfo&gt; installInfo);
 203         public void updatePackageBadge(String packageName);
 204         public void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames,
 205                         ArrayList&lt;AppInfo&gt; appInfos, UserHandleCompat user);
 206         public void bindPackagesUpdated(ArrayList&lt;Object&gt; widgetsAndShortcuts);
 207         public void bindSearchablesChanged();
 208         public boolean isAllAppsButtonRank(int rank);
 209         public void onPageBoundSynchronously(int page);
 210         public void dumpLogsToLocalData();
 211     }
 212 
 213     public interface ItemInfoFilter {
 214         public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn);
 215     }
 216 
 217     LauncherModel(LauncherAppState app, IconCache iconCache, AppFilter appFilter) {
 218         Context context = app.getContext();
 219 
 220         mAppsCanBeOnRemoveableStorage = Environment.isExternalStorageRemovable();
 221         String oldProvider = context.getString(R.string.old_launcher_provider_uri);
 222         // This may be the same as MIGRATE_AUTHORITY, or it may be replaced by a different
 223         // resource string.
 224         String redirectAuthority = Uri.parse(oldProvider).getAuthority();
 225         ProviderInfo providerInfo =
 226                 context.getPackageManager().resolveContentProvider(MIGRATE_AUTHORITY, 0);
 227         ProviderInfo redirectProvider =
 228                 context.getPackageManager().resolveContentProvider(redirectAuthority, 0);
 229 
 230         Log.d(TAG, &quot;Old launcher provider: &quot; + oldProvider);
 231         mOldContentProviderExists = (providerInfo != null) &amp;&amp; (redirectProvider != null);
 232 
 233         if (mOldContentProviderExists) {
 234             Log.d(TAG, &quot;Old launcher provider exists.&quot;);
 235         } else {
 236             Log.d(TAG, &quot;Old launcher provider does not exist.&quot;);
 237         }
 238 
 239         mApp = app;
 240         mBgAllAppsList = new AllAppsList(iconCache, appFilter);
 241         mIconCache = iconCache;
 242 
 243         final Resources res = context.getResources();
 244         Configuration config = res.getConfiguration();
 245         mPreviousConfigMcc = config.mcc;
 246         mLauncherApps = LauncherAppsCompat.getInstance(context);
 247         mUserManager = UserManagerCompat.getInstance(context);
 248     }
 249 
 250     /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 251      * posted on the main thread handler. */
 252     private void runOnMainThread(Runnable r) {
 253         runOnMainThread(r, 0);
 254     }
 255     private void runOnMainThread(Runnable r, int type) {
 256         if (sWorkerThread.getThreadId() == Process.myTid()) {
 257             // If we are on the worker thread, post onto the main handler
 258             mHandler.post(r);
 259         } else {
 260             r.run();
 261         }
 262     }
 263 
 264     /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 265      * posted on the worker thread handler. */
 266     private static void runOnWorkerThread(Runnable r) {
 267         if (sWorkerThread.getThreadId() == Process.myTid()) {
 268             r.run();
 269         } else {
 270             // If we are not on the worker thread, then post to the worker handler
 271             sWorker.post(r);
 272         }
 273     }
 274 
 275     boolean canMigrateFromOldLauncherDb(Launcher launcher) {
 276         return mOldContentProviderExists &amp;&amp; !launcher.isLauncherPreinstalled() ;
 277     }
 278 
 279     static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;ItemInfo&gt; items, int[] xy,
 280                                  long screen) {
 281         LauncherAppState app = LauncherAppState.getInstance();
 282         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 283         final int xCount = (int) grid.numColumns;
 284         final int yCount = (int) grid.numRows;
 285         boolean[][] occupied = new boolean[xCount][yCount];
 286 
 287         int cellX, cellY, spanX, spanY;
 288         for (int i = 0; i &lt; items.size(); ++i) {
 289             final ItemInfo item = items.get(i);
 290             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 291                 if (item.screenId == screen) {
 292                     cellX = item.cellX;
 293                     cellY = item.cellY;
 294                     spanX = item.spanX;
 295                     spanY = item.spanY;
 296                     for (int x = cellX; 0 &lt;= x &amp;&amp; x &lt; cellX + spanX &amp;&amp; x &lt; xCount; x++) {
 297                         for (int y = cellY; 0 &lt;= y &amp;&amp; y &lt; cellY + spanY &amp;&amp; y &lt; yCount; y++) {
 298                             occupied[x][y] = true;
 299                         }
 300                     }
 301                 }
 302             }
 303         }
 304 
 305         return CellLayout.findVacantCell(xy, 1, 1, xCount, yCount, occupied);
 306     }
 307     static Pair&lt;Long, int[]&gt; findNextAvailableIconSpace(Context context, String name,
 308                                                         Intent launchIntent,
 309                                                         int firstScreenIndex,
 310                                                         ArrayList&lt;Long&gt; workspaceScreens) {
 311         // Lock on the app so that we don&#x27;t try and get the items while apps are being added
 312         LauncherAppState app = LauncherAppState.getInstance();
 313         LauncherModel model = app.getModel();
 314         boolean found = false;
 315         synchronized (app) {
 316             if (sWorkerThread.getThreadId() != Process.myTid()) {
 317                 // Flush the LauncherModel worker thread, so that if we just did another
 318                 // processInstallShortcut, we give it time for its shortcut to get added to the
 319                 // database (getItemsInLocalCoordinates reads the database)
 320                 model.flushWorkerThread();
 321             }
 322             final ArrayList&lt;ItemInfo&gt; items = LauncherModel.getItemsInLocalCoordinates(context);
 323 
 324             // Try adding to the workspace screens incrementally, starting at the default or center
 325             // screen and alternating between +1, -1, +2, -2, etc. (using ~ ceil(i/2f)*(-1)^(i-1))
 326             firstScreenIndex = Math.min(firstScreenIndex, workspaceScreens.size());
 327             int count = workspaceScreens.size();
 328             for (int screen = firstScreenIndex; screen &lt; count &amp;&amp; !found; screen++) {
 329                 int[] tmpCoordinates = new int[2];
 330                 if (findNextAvailableIconSpaceInScreen(items, tmpCoordinates,
 331                         workspaceScreens.get(screen))) {
 332                     // Update the Launcher db
 333                     return new Pair&lt;Long, int[]&gt;(workspaceScreens.get(screen), tmpCoordinates);
 334                 }
 335             }
 336         }
 337         return null;
 338     }
 339 
 340     public void setPackageState(final ArrayList&lt;PackageInstallInfo&gt; installInfo) {
 341         // Process the updated package state
 342         Runnable r = new Runnable() {
 343             public void run() {
 344                 Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 345                 if (callbacks != null) {
 346                     callbacks.updatePackageState(installInfo);
 347                 }
 348             }
 349         };
 350         mHandler.post(r);
 351     }
 352 
 353     public void updatePackageBadge(final String packageName) {
 354         // Process the updated package badge
 355         Runnable r = new Runnable() {
 356             public void run() {
 357                 Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 358                 if (callbacks != null) {
 359                     callbacks.updatePackageBadge(packageName);
 360                 }
 361             }
 362         };
 363         mHandler.post(r);
 364     }
 365 
 366     public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {
 367         final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 368 
 369         if (allAppsApps == null) {
 370             throw new RuntimeException(&quot;allAppsApps must not be null&quot;);
 371         }
 372         if (allAppsApps.isEmpty()) {
 373             return;
 374         }
 375 
 376         final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();
 377         Iterator&lt;AppInfo&gt; iter = allAppsApps.iterator();
 378         while (iter.hasNext()) {
 379             ItemInfo a = iter.next();
 380             if (LauncherModel.appWasPromise(ctx, a.getIntent(), a.user)) {
 381                 restoredAppsFinal.add((AppInfo) a);
 382             }
 383         }
 384 
 385         // Process the newly added applications and add them to the database first
 386         Runnable r = new Runnable() {
 387             public void run() {
 388                 runOnMainThread(new Runnable() {
 389                     public void run() {
 390                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 391                         if (callbacks == cb &amp;&amp; cb != null) {
 392                             if (!restoredAppsFinal.isEmpty()) {
 393                                 for (AppInfo info : restoredAppsFinal) {
 394                                     final Intent intent = info.getIntent();
 395                                     if (intent != null) {
 396                                         mIconCache.deletePreloadedIcon(intent.getComponent(),
 397                                                 info.user);
 398                                     }
 399                                 }
 400                                 callbacks.bindAppsUpdated(restoredAppsFinal);
 401                             }
 402                             callbacks.bindAppsAdded(null, null, null, allAppsApps);
 403                         }
 404                     }
 405                 });
 406             }
 407         };
 408         runOnWorkerThread(r);
 409     }
 410 
 411     public void addAndBindAddedWorkspaceApps(final Context context,
 412             final ArrayList&lt;ItemInfo&gt; workspaceApps) {
 413         final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 414 
 415         if (workspaceApps == null) {
 416             throw new RuntimeException(&quot;workspaceApps and allAppsApps must not be null&quot;);
 417         }
 418         if (workspaceApps.isEmpty()) {
 419             return;
 420         }
 421         // Process the newly added applications and add them to the database first
 422         Runnable r = new Runnable() {
 423             public void run() {
 424                 final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();
 425                 final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
 426                 final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();
 427 
 428                 // Get the list of workspace screens.  We need to append to this list and
 429                 // can not use sBgWorkspaceScreens because loadWorkspace() may not have been
 430                 // called.
 431                 ArrayList&lt;Long&gt; workspaceScreens = new ArrayList&lt;Long&gt;();
 432                 TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(context);
 433                 for (Integer i : orderedScreens.keySet()) {
 434                     long screenId = orderedScreens.get(i);
 435                     workspaceScreens.add(screenId);
 436                 }
 437 
 438                 synchronized(sBgLock) {
 439                     Iterator&lt;ItemInfo&gt; iter = workspaceApps.iterator();
 440                     while (iter.hasNext()) {
 441                         ItemInfo a = iter.next();
 442                         final String name = a.title.toString();
 443                         final Intent launchIntent = a.getIntent();
 444 
 445                         // Short-circuit this logic if the icon exists somewhere on the workspace
 446                         if (LauncherModel.shortcutExists(context, name, launchIntent)) {
 447                             // Only InstallShortcutReceiver sends us shortcutInfos, ignore them
 448                             if (a instanceof AppInfo &amp;&amp;
 449                                     LauncherModel.appWasPromise(context, launchIntent, a.user)) {
 450                                 restoredAppsFinal.add((AppInfo) a);
 451                             }
 452                             continue;
 453                         }
 454 
 455                         // Add this icon to the db, creating a new page if necessary.  If there
 456                         // is only the empty page then we just add items to the first page.
 457                         // Otherwise, we add them to the next pages.
 458                         int startSearchPageIndex = workspaceScreens.isEmpty() ? 0 : 1;
 459                         Pair&lt;Long, int[]&gt; coords = LauncherModel.findNextAvailableIconSpace(context,
 460                                 name, launchIntent, startSearchPageIndex, workspaceScreens);
 461                         if (coords == null) {
 462                             LauncherProvider lp = LauncherAppState.getLauncherProvider();
 463 
 464                             // If we can&#x27;t find a valid position, then just add a new screen.
 465                             // This takes time so we need to re-queue the add until the new
 466                             // page is added.  Create as many screens as necessary to satisfy
 467                             // the startSearchPageIndex.
 468                             int numPagesToAdd = Math.max(1, startSearchPageIndex + 1 -
 469                                     workspaceScreens.size());
 470                             while (numPagesToAdd &gt; 0) {
 471                                 long screenId = lp.generateNewScreenId();
 472                                 // Save the screen id for binding in the workspace
 473                                 workspaceScreens.add(screenId);
 474                                 addedWorkspaceScreensFinal.add(screenId);
 475                                 numPagesToAdd--;
 476                             }
 477 
 478                             // Find the coordinate again
 479                             coords = LauncherModel.findNextAvailableIconSpace(context,
 480                                     name, launchIntent, startSearchPageIndex, workspaceScreens);
 481                         }
 482                         if (coords == null) {
 483                             throw new RuntimeException(&quot;Coordinates should not be null&quot;);
 484                         }
 485 
 486                         ShortcutInfo shortcutInfo;
 487                         if (a instanceof ShortcutInfo) {
 488                             shortcutInfo = (ShortcutInfo) a;
 489                         } else if (a instanceof AppInfo) {
 490                             shortcutInfo = ((AppInfo) a).makeShortcut();
 491                         } else {
 492                             throw new RuntimeException(&quot;Unexpected info type&quot;);
 493                         }
 494 
 495                         // Add the shortcut to the db
 496                         addItemToDatabase(context, shortcutInfo,
 497                                 LauncherSettings.Favorites.CONTAINER_DESKTOP,
 498                                 coords.first, coords.second[0], coords.second[1], false);
 499                         // Save the ShortcutInfo for binding in the workspace
 500                         addedShortcutsFinal.add(shortcutInfo);
 501                     }
 502                 }
 503 
 504                 // Update the workspace screens
 505                 updateWorkspaceScreenOrder(context, workspaceScreens);
 506 
 507                 if (!addedShortcutsFinal.isEmpty()) {
 508                     runOnMainThread(new Runnable() {
 509                         public void run() {
 510                             Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 511                             if (callbacks == cb &amp;&amp; cb != null) {
 512                                 final ArrayList&lt;ItemInfo&gt; addAnimated = new ArrayList&lt;ItemInfo&gt;();
 513                                 final ArrayList&lt;ItemInfo&gt; addNotAnimated = new ArrayList&lt;ItemInfo&gt;();
 514                                 if (!addedShortcutsFinal.isEmpty()) {
<abbr title=" 515                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 1);"> 515                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - </abbr>
 516                                     long lastScreenId = info.screenId;
 517                                     for (ItemInfo i : addedShortcutsFinal) {
 518                                         if (i.screenId == lastScreenId) {
 519                                             addAnimated.add(i);
 520                                         } else {
 521                                             addNotAnimated.add(i);
 522                                         }
 523                                     }
 524                                 }
 525                                 callbacks.bindAppsAdded(addedWorkspaceScreensFinal,
 526                                         addNotAnimated, addAnimated, null);
 527                                 if (!restoredAppsFinal.isEmpty()) {
 528                                     callbacks.bindAppsUpdated(restoredAppsFinal);
 529                                 }
 530                             }
 531                         }
 532                     });
 533                 }
 534             }
 535         };
 536         runOnWorkerThread(r);
 537     }
 538 
 539     public void unbindItemInfosAndClearQueuedBindRunnables() {
 540         if (sWorkerThread.getThreadId() == Process.myTid()) {
 541             throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; +
 542                     &quot;main thread&quot;);
 543         }
 544 
 545         // Clear any deferred bind runnables
 546         synchronized (mDeferredBindRunnables) {
 547             mDeferredBindRunnables.clear();
 548         }
 549         // Remove any queued bind runnables
 550         mHandler.cancelAllRunnablesOfType(MAIN_THREAD_BINDING_RUNNABLE);
 551         // Unbind all the workspace items
 552         unbindWorkspaceItemsOnMainThread();
 553     }
 554 
 555     /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 556     void unbindWorkspaceItemsOnMainThread() {
 557         // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 558         // by making a copy of workspace items first.
 559         final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 560         final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 561         synchronized (sBgLock) {
 562             tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 563             tmpAppWidgets.addAll(sBgAppWidgets);
 564         }
 565         Runnable r = new Runnable() {
 566                 @Override
 567                 public void run() {
 568                    for (ItemInfo item : tmpWorkspaceItems) {
 569                        item.unbind();
 570                    }
 571                    for (ItemInfo item : tmpAppWidgets) {
 572                        item.unbind();
 573                    }
 574                 }
 575             };
 576         runOnMainThread(r);
 577     }
 578 
 579     /**
 580      * Adds an item to the DB if it was not created previously, or move it to a new
 581      * &lt;container, screen, cellX, cellY&gt;
 582      */
 583     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 584             long screenId, int cellX, int cellY) {
 585         if (item.container == ItemInfo.NO_ID) {
 586             // From all apps
 587             addItemToDatabase(context, item, container, screenId, cellX, cellY, false);
 588         } else {
 589             // From somewhere else
 590             moveItemInDatabase(context, item, container, screenId, cellX, cellY);
 591         }
 592     }
 593 
 594     static void checkItemInfoLocked(
 595             final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {
 596         ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 597         if (modelItem != null &amp;&amp; item != modelItem) {
 598             // check all the data is consistent
 599             if (modelItem instanceof ShortcutInfo &amp;&amp; item instanceof ShortcutInfo) {
 600                 ShortcutInfo modelShortcut = (ShortcutInfo) modelItem;
 601                 ShortcutInfo shortcut = (ShortcutInfo) item;
 602                 if (modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp;
 603                         modelShortcut.intent.filterEquals(shortcut.intent) &amp;&amp;
 604                         modelShortcut.id == shortcut.id &amp;&amp;
 605                         modelShortcut.itemType == shortcut.itemType &amp;&amp;
 606                         modelShortcut.container == shortcut.container &amp;&amp;
 607                         modelShortcut.screenId == shortcut.screenId &amp;&amp;
 608                         modelShortcut.cellX == shortcut.cellX &amp;&amp;
 609                         modelShortcut.cellY == shortcut.cellY &amp;&amp;
 610                         modelShortcut.spanX == shortcut.spanX &amp;&amp;
 611                         modelShortcut.spanY == shortcut.spanY &amp;&amp;
 612                         ((modelShortcut.dropPos == null &amp;&amp; shortcut.dropPos == null) ||
 613                         (modelShortcut.dropPos != null &amp;&amp;
 614                                 shortcut.dropPos != null &amp;&amp;
 615                                 modelShortcut.dropPos[0] == shortcut.dropPos[0] &amp;&amp;
 616                         modelShortcut.dropPos[1] == shortcut.dropPos[1]))) {
 617                     // For all intents and purposes, this is the same object
 618                     return;
 619                 }
 620             }
 621 
 622             // the modelItem needs to match up perfectly with item if our model is
 623             // to be consistent with the database-- for now, just require
 624             // modelItem == item or the equality check above
 625             String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 626                     &quot;modelItem: &quot; +
 627                     ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 628                     &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 629             RuntimeException e = new RuntimeException(msg);
 630             if (stackTrace != null) {
 631                 e.setStackTrace(stackTrace);
 632             }
 633             throw e;
 634         }
 635     }
 636 
 637     static void checkItemInfo(final ItemInfo item) {
 638         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 639         final long itemId = item.id;
 640         Runnable r = new Runnable() {
 641             public void run() {
 642                 synchronized (sBgLock) {
 643                     checkItemInfoLocked(itemId, item, stackTrace);
 644                 }
 645             }
 646         };
 647         runOnWorkerThread(r);
 648     }
 649 
 650     static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 651             final ItemInfo item, final String callingFunction) {
 652         final long itemId = item.id;
 653         final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 654         final ContentResolver cr = context.getContentResolver();
 655 
 656         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 657         Runnable r = new Runnable() {
 658             public void run() {
 659                 cr.update(uri, values, null, null);
 660                 updateItemArrays(item, itemId, stackTrace);
 661             }
 662         };
 663         runOnWorkerThread(r);
 664     }
 665 
 666     static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList,
 667             final ArrayList&lt;ItemInfo&gt; items, final String callingFunction) {
 668         final ContentResolver cr = context.getContentResolver();
 669 
 670         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 671         Runnable r = new Runnable() {
 672             public void run() {
 673                 ArrayList&lt;ContentProviderOperation&gt; ops =
 674                         new ArrayList&lt;ContentProviderOperation&gt;();
 675                 int count = items.size();
 676                 for (int i = 0; i &lt; count; i++) {
 677                     ItemInfo item = items.get(i);
 678                     final long itemId = item.id;
 679                     final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 680                     ContentValues values = valuesList.get(i);
 681 
 682                     ops.add(ContentProviderOperation.newUpdate(uri).withValues(values).build());
 683                     updateItemArrays(item, itemId, stackTrace);
 684 
 685                 }
 686                 try {
 687                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
 688                 } catch (Exception e) {
 689                     e.printStackTrace();
 690                 }
 691             }
 692         };
 693         runOnWorkerThread(r);
 694     }
 695 
 696     static void updateItemArrays(ItemInfo item, long itemId, StackTraceElement[] stackTrace) {
 697         // Lock on mBgLock *after* the db operation
 698         synchronized (sBgLock) {
 699             checkItemInfoLocked(itemId, item, stackTrace);
 700 
 701             if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
 702                     item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 703                 // Item is in a folder, make sure this folder exists
 704                 if (!sBgFolders.containsKey(item.container)) {
 705                     // An items container is being set to a that of an item which is not in
 706                     // the list of Folders.
 707                     String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +
 708                             item.container + &quot;, not in the list of folders&quot;;
 709                     Log.e(TAG, msg);
 710                 }
 711             }
 712 
 713             // Items are added/removed from the corresponding FolderInfo elsewhere, such
 714             // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 715             // that are on the desktop, as appropriate
 716             ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 717             if (modelItem != null &amp;&amp;
 718                     (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 719                      modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {
 720                 switch (modelItem.itemType) {
 721                     case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 722                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 723                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 724                         if (!sBgWorkspaceItems.contains(modelItem)) {
 725                             sBgWorkspaceItems.add(modelItem);
 726                         }
 727                         break;
 728                     default:
 729                         break;
 730                 }
 731             } else {
 732                 sBgWorkspaceItems.remove(modelItem);
 733             }
 734         }
 735     }
 736 
 737     public void flushWorkerThread() {
 738         mFlushingWorkerThread = true;
 739         Runnable waiter = new Runnable() {
 740                 public void run() {
 741                     synchronized (this) {
 742                         notifyAll();
 743                         mFlushingWorkerThread = false;
 744                     }
 745                 }
 746             };
 747 
 748         synchronized(waiter) {
 749             runOnWorkerThread(waiter);
 750             if (mLoaderTask != null) {
 751                 synchronized(mLoaderTask) {
 752                     mLoaderTask.notify();
 753                 }
 754             }
 755             boolean success = false;
 756             while (!success) {
 757                 try {
 758                     waiter.wait();
 759                     success = true;
 760                 } catch (InterruptedException e) {
 761                 }
 762             }
 763         }
 764     }
 765 
 766     /**
 767      * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 768      */
 769     static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 770             final long screenId, final int cellX, final int cellY) {
 771         item.container = container;
 772         item.cellX = cellX;
 773         item.cellY = cellY;
 774 
 775         // We store hotseat items in canonical form which is this orientation invariant position
 776         // in the hotseat
 777         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 778                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 779             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 780         } else {
 781             item.screenId = screenId;
 782         }
 783 
 784         final ContentValues values = new ContentValues();
 785         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 786         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 787         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 788         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 789 
 790         updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 791     }
 792 
 793     /**
 794      * Move items in the DB to a new &lt;container, screen, cellX, cellY&gt;. We assume that the
 795      * cellX, cellY have already been updated on the ItemInfos.
 796      */
 797     static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items,
 798             final long container, final int screen) {
 799 
 800         ArrayList&lt;ContentValues&gt; contentValues = new ArrayList&lt;ContentValues&gt;();
 801         int count = items.size();
 802 
 803         for (int i = 0; i &lt; count; i++) {
 804             ItemInfo item = items.get(i);
 805             item.container = container;
 806 
 807             // We store hotseat items in canonical form which is this orientation invariant position
 808             // in the hotseat
 809             if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 810                     container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 811                 item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(item.cellX,
 812                         item.cellY);
 813             } else {
 814                 item.screenId = screen;
 815             }
 816 
 817             final ContentValues values = new ContentValues();
 818             values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 819             values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 820             values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 821             values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 822 
 823             contentValues.add(values);
 824         }
 825         updateItemsInDatabaseHelper(context, contentValues, items, &quot;moveItemInDatabase&quot;);
 826     }
 827 
 828     /**
 829      * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 830      */
 831     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 832             final long screenId, final int cellX, final int cellY, final int spanX, final int spanY) {
 833         item.container = container;
 834         item.cellX = cellX;
 835         item.cellY = cellY;
 836         item.spanX = spanX;
 837         item.spanY = spanY;
 838 
 839         // We store hotseat items in canonical form which is this orientation invariant position
 840         // in the hotseat
 841         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 842                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 843             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 844         } else {
 845             item.screenId = screenId;
 846         }
 847 
 848         final ContentValues values = new ContentValues();
 849         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 850         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 851         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 852         values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 853         values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 854         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 855 
 856         updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 857     }
 858 
 859     /**
 860      * Update an item to the database in a specified container.
 861      */
 862     static void updateItemInDatabase(Context context, final ItemInfo item) {
 863         final ContentValues values = new ContentValues();
 864         item.onAddToDatabase(context, values);
 865         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 866         updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 867     }
 868 
 869     /**
 870      * Returns true if the shortcuts already exists in the database.
 871      * we identify a shortcut by its title and intent.
 872      */
 873     static boolean shortcutExists(Context context, String title, Intent intent) {
 874         final ContentResolver cr = context.getContentResolver();
 875         final Intent intentWithPkg, intentWithoutPkg;
 876 
 877         if (intent.getComponent() != null) {
 878             // If component is not null, an intent with null package will produce
 879             // the same result and should also be a match.
 880             if (intent.getPackage() != null) {
 881                 intentWithPkg = intent;
 882                 intentWithoutPkg = new Intent(intent).setPackage(null);
 883             } else {
 884                 intentWithPkg = new Intent(intent).setPackage(
 885                         intent.getComponent().getPackageName());
 886                 intentWithoutPkg = intent;
 887             }
 888         } else {
 889             intentWithPkg = intent;
 890             intentWithoutPkg = intent;
 891         }
 892         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 893             new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and (intent=? or intent=?)&quot;,
 894             new String[] { title, intentWithPkg.toUri(0), intentWithoutPkg.toUri(0) }, null);
 895         boolean result = false;
 896         try {
 897             result = c.moveToFirst();
 898         } finally {
 899             c.close();
 900         }
 901         return result;
 902     }
 903 
 904     /**
 905      * Returns true if the promise shortcuts with the same package name exists on the workspace.
 906      */
 907     static boolean appWasPromise(Context context, Intent intent, UserHandleCompat user) {
 908         final ComponentName component = intent.getComponent();
 909         if (component == null) {
 910             return false;
 911         }
 912         return !getItemsByPackageName(component.getPackageName(), user).isEmpty();
 913     }
 914 
 915     /**
 916      * Returns an ItemInfo array containing all the items in the LauncherModel.
 917      * The ItemInfo.id is not set through this function.
 918      */
 919     static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 920         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 921         final ContentResolver cr = context.getContentResolver();
 922         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
 923                 LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
 924                 LauncherSettings.Favorites.SCREEN,
 925                 LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,
 926                 LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY,
 927                 LauncherSettings.Favorites.PROFILE_ID }, null, null, null);
 928 
 929         final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 930         final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 931         final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 932         final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 933         final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 934         final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 935         final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 936         final int profileIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.PROFILE_ID);
 937         UserManagerCompat userManager = UserManagerCompat.getInstance(context);
 938         try {
 939             while (c.moveToNext()) {
 940                 ItemInfo item = new ItemInfo();
 941                 item.cellX = c.getInt(cellXIndex);
 942                 item.cellY = c.getInt(cellYIndex);
 943                 item.spanX = Math.max(1, c.getInt(spanXIndex));
 944                 item.spanY = Math.max(1, c.getInt(spanYIndex));
 945                 item.container = c.getInt(containerIndex);
 946                 item.itemType = c.getInt(itemTypeIndex);
 947                 item.screenId = c.getInt(screenIndex);
 948                 long serialNumber = c.getInt(profileIdIndex);
 949                 item.user = userManager.getUserForSerialNumber(serialNumber);
 950                 // Skip if user has been deleted.
 951                 if (item.user != null) {
 952                     items.add(item);
 953                 }
 954             }
 955         } catch (Exception e) {
 956             items.clear();
 957         } finally {
 958             c.close();
 959         }
 960 
 961         return items;
 962     }
 963 
 964     /**
 965      * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 966      */
 967     FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
 968         final ContentResolver cr = context.getContentResolver();
 969         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
 970                 &quot;_id=? and (itemType=? or itemType=?)&quot;,
 971                 new String[] { String.valueOf(id),
 972                         String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
 973 
 974         try {
 975             if (c.moveToFirst()) {
 976                 final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 977                 final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 978                 final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 979                 final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 980                 final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 981                 final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 982 
 983                 FolderInfo folderInfo = null;
 984                 switch (c.getInt(itemTypeIndex)) {
 985                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 986                         folderInfo = findOrMakeFolder(folderList, id);
 987                         break;
 988                 }
 989 
 990                 folderInfo.title = c.getString(titleIndex);
 991                 folderInfo.id = id;
 992                 folderInfo.container = c.getInt(containerIndex);
 993                 folderInfo.screenId = c.getInt(screenIndex);
 994                 folderInfo.cellX = c.getInt(cellXIndex);
 995                 folderInfo.cellY = c.getInt(cellYIndex);
 996 
 997                 return folderInfo;
 998             }
 999         } finally {
1000             c.close();
1001         }
1002 
1003         return null;
1004     }
1005 
1006     /**
1007      * Add an item to the database in a specified container. Sets the container, screen, cellX and
1008      * cellY fields of the item. Also assigns an ID to the item.
1009      */
1010     static void addItemToDatabase(Context context, final ItemInfo item, final long container,
1011             final long screenId, final int cellX, final int cellY, final boolean notify) {
1012         item.container = container;
1013         item.cellX = cellX;
1014         item.cellY = cellY;
1015         // We store hotseat items in canonical form which is this orientation invariant position
1016         // in the hotseat
1017         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
1018                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1019             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
1020         } else {
1021             item.screenId = screenId;
1022         }
1023 
1024         final ContentValues values = new ContentValues();
1025         final ContentResolver cr = context.getContentResolver();
1026         item.onAddToDatabase(context, values);
1027 
1028         item.id = LauncherAppState.getLauncherProvider().generateNewItemId();
1029         values.put(LauncherSettings.Favorites._ID, item.id);
1030         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
1031 
1032         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
1033         Runnable r = new Runnable() {
1034             public void run() {
1035                 cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
1036                         LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);
1037 
1038                 // Lock on mBgLock *after* the db operation
1039                 synchronized (sBgLock) {
1040                     checkItemInfoLocked(item.id, item, stackTrace);
1041                     sBgItemsIdMap.put(item.id, item);
1042                     switch (item.itemType) {
1043                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1044                             sBgFolders.put(item.id, (FolderInfo) item);
1045                             // Fall through
1046                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1047                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1048                             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
1049                                     item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1050                                 sBgWorkspaceItems.add(item);
1051                             } else {
1052                                 if (!sBgFolders.containsKey(item.container)) {
1053                                     // Adding an item to a folder that doesn&#x27;t exist.
1054                                     String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +
1055                                             &quot; doesn&#x27;t exist&quot;;
1056                                     Log.e(TAG, msg);
1057                                 }
1058                             }
1059                             break;
1060                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1061                             sBgAppWidgets.add((LauncherAppWidgetInfo) item);
1062                             break;
1063                     }
1064                 }
1065             }
1066         };
1067         runOnWorkerThread(r);
1068     }
1069 
1070     /**
1071      * Creates a new unique child id, for a given cell span across all layouts.
1072      */
1073     static int getCellLayoutChildId(
1074             long container, long screen, int localCellX, int localCellY, int spanX, int spanY) {
1075         return (((int) container &amp; 0xFF) &lt;&lt; 24)
1076                 | ((int) screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
1077     }
1078 
1079     private static ArrayList&lt;ItemInfo&gt; getItemsByPackageName(
1080             final String pn, final UserHandleCompat user) {
1081         ItemInfoFilter filter  = new ItemInfoFilter() {
1082             @Override
1083             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
1084                 return cn.getPackageName().equals(pn) &amp;&amp; info.user.equals(user);
1085             }
1086         };
1087         return filterItemInfos(sBgItemsIdMap.values(), filter);
1088     }
1089 
1090     /**
1091      * Removes all the items from the database corresponding to the specified package.
1092      */
1093     static void deletePackageFromDatabase(Context context, final String pn,
1094             final UserHandleCompat user) {
1095         deleteItemsFromDatabase(context, getItemsByPackageName(pn, user));
1096     }
1097 
1098     /**
1099      * Removes the specified item from the database
1100      * @param context
1101      * @param item
1102      */
1103     static void deleteItemFromDatabase(Context context, final ItemInfo item) {
1104         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
1105         items.add(item);
1106         deleteItemsFromDatabase(context, items);
1107     }
1108 
1109     /**
1110      * Removes the specified items from the database
1111      * @param context
1112      * @param item
1113      */
1114     static void deleteItemsFromDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items) {
1115         final ContentResolver cr = context.getContentResolver();
1116 
1117         Runnable r = new Runnable() {
1118             public void run() {
1119                 for (ItemInfo item : items) {
1120                     final Uri uri = LauncherSettings.Favorites.getContentUri(item.id, false);
1121                     cr.delete(uri, null, null);
1122 
1123                     // Lock on mBgLock *after* the db operation
1124                     synchronized (sBgLock) {
1125                         switch (item.itemType) {
1126                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1127                                 sBgFolders.remove(item.id);
1128                                 for (ItemInfo info: sBgItemsIdMap.values()) {
1129                                     if (info.container == item.id) {
1130                                         // We are deleting a folder which still contains items that
1131                                         // think they are contained by that folder.
1132                                         String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +
1133                                                 &quot;contains items (&quot; + info + &quot;)&quot;;
1134                                         Log.e(TAG, msg);
1135                                     }
1136                                 }
1137                                 sBgWorkspaceItems.remove(item);
1138                                 break;
1139                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1140                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1141                                 sBgWorkspaceItems.remove(item);
1142                                 break;
1143                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1144                                 sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
1145                                 break;
1146                         }
1147                         sBgItemsIdMap.remove(item.id);
1148                         sBgDbIconCache.remove(item);
1149                     }
1150                 }
1151             }
1152         };
1153         runOnWorkerThread(r);
1154     }
1155 
1156     /**
1157      * Update the order of the workspace screens in the database. The array list contains
1158      * a list of screen ids in the order that they should appear.
1159      */
1160     void updateWorkspaceScreenOrder(Context context, final ArrayList&lt;Long&gt; screens) {
1161         // Log to disk
1162         Launcher.addDumpLog(TAG, &quot;11683562 - updateWorkspaceScreenOrder()&quot;, true);
1163         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; + TextUtils.join(&quot;, &quot;, screens), true);
1164 
1165         final ArrayList&lt;Long&gt; screensCopy = new ArrayList&lt;Long&gt;(screens);
1166         final ContentResolver cr = context.getContentResolver();
1167         final Uri uri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1168 
1169         // Remove any negative screen ids -- these aren&#x27;t persisted
1170         Iterator&lt;Long&gt; iter = screensCopy.iterator();
1171         while (iter.hasNext()) {
1172             long id = iter.next();
1173             if (id &lt; 0) {
1174                 iter.remove();
1175             }
1176         }
1177 
1178         Runnable r = new Runnable() {
1179             @Override
1180             public void run() {
1181                 ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
1182                 // Clear the table
1183                 ops.add(ContentProviderOperation.newDelete(uri).build());
1184                 int count = screensCopy.size();
1185                 for (int i = 0; i &lt; count; i++) {
1186                     ContentValues v = new ContentValues();
1187                     long screenId = screensCopy.get(i);
1188                     v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1189                     v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1190                     ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());
1191                 }
1192 
1193                 try {
1194                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
1195                 } catch (Exception ex) {
1196                     throw new RuntimeException(ex);
1197                 }
1198 
1199                 synchronized (sBgLock) {
1200                     sBgWorkspaceScreens.clear();
1201                     sBgWorkspaceScreens.addAll(screensCopy);
1202                 }
1203             }
1204         };
1205         runOnWorkerThread(r);
1206     }
1207 
1208     /**
1209      * Remove the contents of the specified folder from the database
1210      */
1211     static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
1212         final ContentResolver cr = context.getContentResolver();
1213 
1214         Runnable r = new Runnable() {
1215             public void run() {
1216                 cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
1217                 // Lock on mBgLock *after* the db operation
1218                 synchronized (sBgLock) {
1219                     sBgItemsIdMap.remove(info.id);
1220                     sBgFolders.remove(info.id);
1221                     sBgDbIconCache.remove(info);
1222                     sBgWorkspaceItems.remove(info);
1223                 }
1224 
1225                 cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
1226                         LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
1227                 // Lock on mBgLock *after* the db operation
1228                 synchronized (sBgLock) {
1229                     for (ItemInfo childInfo : info.contents) {
1230                         sBgItemsIdMap.remove(childInfo.id);
1231                         sBgDbIconCache.remove(childInfo);
1232                     }
1233                 }
1234             }
1235         };
1236         runOnWorkerThread(r);
1237     }
1238 
1239     /**
1240      * Set this as the current Launcher activity object for the loader.
1241      */
1242     public void initialize(Callbacks callbacks) {
1243         synchronized (mLock) {
1244             mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
1245         }
1246     }
1247 
1248     @Override
1249     public void onPackageChanged(String packageName, UserHandleCompat user) {
1250         int op = PackageUpdatedTask.OP_UPDATE;
1251         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1252                 user));
1253     }
1254 
1255     @Override
1256     public void onPackageRemoved(String packageName, UserHandleCompat user) {
1257         int op = PackageUpdatedTask.OP_REMOVE;
1258         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1259                 user));
1260     }
1261 
1262     @Override
1263     public void onPackageAdded(String packageName, UserHandleCompat user) {
1264         int op = PackageUpdatedTask.OP_ADD;
1265         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1266                 user));
1267     }
1268 
1269     @Override
1270     public void onPackagesAvailable(String[] packageNames, UserHandleCompat user,
1271             boolean replacing) {
1272         if (!replacing) {
1273             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packageNames,
1274                     user));
1275             if (mAppsCanBeOnRemoveableStorage) {
1276                 // Only rebind if we support removable storage. It catches the
1277                 // case where
1278                 // apps on the external sd card need to be reloaded
1279                 startLoaderFromBackground();
1280             }
1281         } else {
1282             // If we are replacing then just update the packages in the list
1283             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE,
1284                     packageNames, user));
1285         }
1286     }
1287 
1288     @Override
1289     public void onPackagesUnavailable(String[] packageNames, UserHandleCompat user,
1290             boolean replacing) {
1291         if (!replacing) {
1292             enqueuePackageUpdated(new PackageUpdatedTask(
1293                     PackageUpdatedTask.OP_UNAVAILABLE, packageNames,
1294                     user));
1295         }
1296 
1297     }
1298 
1299     /**
1300      * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
1301      * ACTION_PACKAGE_CHANGED.
1302      */
1303     @Override
1304     public void onReceive(Context context, Intent intent) {
1305         if (DEBUG_RECEIVER) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
1306 
1307         final String action = intent.getAction();
1308         if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
1309             // If we have changed locale we need to clear out the labels in all apps/workspace.
1310             forceReload();
1311         } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
1312              // Check if configuration change was an mcc/mnc change which would affect app resources
1313              // and we would need to clear out the labels in all apps/workspace. Same handling as
1314              // above for ACTION_LOCALE_CHANGED
1315              Configuration currentConfig = context.getResources().getConfiguration();
1316              if (mPreviousConfigMcc != currentConfig.mcc) {
1317                    Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
1318                        + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
1319                    forceReload();
1320              }
1321              // Update previousConfig
1322              mPreviousConfigMcc = currentConfig.mcc;
1323         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
1324                    SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
1325             if (mCallbacks != null) {
1326                 Callbacks callbacks = mCallbacks.get();
1327                 if (callbacks != null) {
1328                     callbacks.bindSearchablesChanged();
1329                 }
1330             }
1331         }
1332     }
1333 
1334     void forceReload() {
1335         resetLoadedState(true, true);
1336 
1337         // Do this here because if the launcher activity is running it will be restarted.
1338         // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
1339         // to reload.
1340         startLoaderFromBackground();
1341     }
1342 
1343     public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
1344         synchronized (mLock) {
1345             // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
1346             // mWorkspaceLoaded to true later
1347             stopLoaderLocked();
1348             if (resetAllAppsLoaded) mAllAppsLoaded = false;
1349             if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
1350         }
1351     }
1352 
1353     /**
1354      * When the launcher is in the background, it&#x27;s possible for it to miss paired
1355      * configuration changes.  So whenever we trigger the loader from the background
1356      * tell the launcher that it needs to re-run the loader when it comes back instead
1357      * of doing it now.
1358      */
1359     public void startLoaderFromBackground() {
1360         boolean runLoader = false;
1361         if (mCallbacks != null) {
1362             Callbacks callbacks = mCallbacks.get();
1363             if (callbacks != null) {
1364                 // Only actually run the loader if they&#x27;re not paused.
1365                 if (!callbacks.setLoadOnResume()) {
1366                     runLoader = true;
1367                 }
1368             }
1369         }
1370         if (runLoader) {
1371             startLoader(false, PagedView.INVALID_RESTORE_PAGE);
1372         }
1373     }
1374 
1375     // If there is already a loader task running, tell it to stop.
1376     // returns true if isLaunching() was true on the old task
1377     private boolean stopLoaderLocked() {
1378         boolean isLaunching = false;
1379         LoaderTask oldTask = mLoaderTask;
1380         if (oldTask != null) {
1381             if (oldTask.isLaunching()) {
1382                 isLaunching = true;
1383             }
1384             oldTask.stopLocked();
1385         }
1386         return isLaunching;
1387     }
1388 
1389     public boolean isCurrentCallbacks(Callbacks callbacks) {
1390         return (mCallbacks != null &amp;&amp; mCallbacks.get() == callbacks);
1391     }
1392 
1393     public void startLoader(boolean isLaunching, int synchronousBindPage) {
1394         startLoader(isLaunching, synchronousBindPage, LOADER_FLAG_NONE);
1395     }
1396 
1397     public void startLoader(boolean isLaunching, int synchronousBindPage, int loadFlags) {
1398         synchronized (mLock) {
1399             if (DEBUG_LOADERS) {
1400                 Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
1401             }
1402 
1403             // Clear any deferred bind-runnables from the synchronized load process
1404             // We must do this before any loading/binding is scheduled below.
1405             synchronized (mDeferredBindRunnables) {
1406                 mDeferredBindRunnables.clear();
1407             }
1408 
1409             // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
1410             if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
1411                 // If there is already one running, tell it to stop.
1412                 // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
1413                 isLaunching = isLaunching || stopLoaderLocked();
1414                 mLoaderTask = new LoaderTask(mApp.getContext(), isLaunching, loadFlags);
1415                 if (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE
1416                         &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {
1417                     mLoaderTask.runBindSynchronousPage(synchronousBindPage);
1418                 } else {
1419                     sWorkerThread.setPriority(Thread.NORM_PRIORITY);
1420                     sWorker.post(mLoaderTask);
1421                 }
1422             }
1423         }
1424     }
1425 
1426     void bindRemainingSynchronousPages() {
1427         // Post the remaining side pages to be loaded
1428         if (!mDeferredBindRunnables.isEmpty()) {
1429             Runnable[] deferredBindRunnables = null;
1430             synchronized (mDeferredBindRunnables) {
1431                 deferredBindRunnables = mDeferredBindRunnables.toArray(
1432                         new Runnable[mDeferredBindRunnables.size()]);
1433                 mDeferredBindRunnables.clear();
1434             }
1435             for (final Runnable r : deferredBindRunnables) {
1436                 mHandler.post(r, MAIN_THREAD_BINDING_RUNNABLE);
1437             }
1438         }
1439     }
1440 
1441     public void stopLoader() {
1442         synchronized (mLock) {
1443             if (mLoaderTask != null) {
1444                 mLoaderTask.stopLocked();
1445             }
1446         }
1447     }
1448 
1449     /** Loads the workspace screens db into a map of Rank -&gt; ScreenId */
1450     private static TreeMap&lt;Integer, Long&gt; loadWorkspaceScreensDb(Context context) {
1451         final ContentResolver contentResolver = context.getContentResolver();
1452         final Uri screensUri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1453         final Cursor sc = contentResolver.query(screensUri, null, null, null, null);
1454         TreeMap&lt;Integer, Long&gt; orderedScreens = new TreeMap&lt;Integer, Long&gt;();
1455 
1456         try {
1457             final int idIndex = sc.getColumnIndexOrThrow(
1458                     LauncherSettings.WorkspaceScreens._ID);
1459             final int rankIndex = sc.getColumnIndexOrThrow(
1460                     LauncherSettings.WorkspaceScreens.SCREEN_RANK);
1461             while (sc.moveToNext()) {
1462                 try {
1463                     long screenId = sc.getLong(idIndex);
1464                     int rank = sc.getInt(rankIndex);
1465                     orderedScreens.put(rank, screenId);
1466                 } catch (Exception e) {
<abbr title="1467                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e, true);">1467                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e,</abbr>
1468                 }
1469             }
1470         } finally {
1471             sc.close();
1472         }
1473 
1474         // Log to disk
1475         Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspaceScreensDb()&quot;, true);
1476         ArrayList&lt;String&gt; orderedScreensPairs= new ArrayList&lt;String&gt;();
1477         for (Integer i : orderedScreens.keySet()) {
1478             orderedScreensPairs.add(&quot;{ &quot; + i + &quot;: &quot; + orderedScreens.get(i) + &quot; }&quot;);
1479         }
1480         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; +
1481                 TextUtils.join(&quot;, &quot;, orderedScreensPairs), true);
1482         return orderedScreens;
1483     }
1484 
1485     public boolean isAllAppsLoaded() {
1486         return mAllAppsLoaded;
1487     }
1488 
1489     boolean isLoadingWorkspace() {
1490         synchronized (mLock) {
1491             if (mLoaderTask != null) {
1492                 return mLoaderTask.isLoadingWorkspace();
1493             }
1494         }
1495         return false;
1496     }
1497 
1498     /**
1499      * Runnable for the thread that loads the contents of the launcher:
1500      *   - workspace icons
1501      *   - widgets
1502      *   - all apps icons
1503      */
1504     private class LoaderTask implements Runnable {
1505         private Context mContext;
1506         private boolean mIsLaunching;
1507         private boolean mIsLoadingAndBindingWorkspace;
1508         private boolean mStopped;
1509         private boolean mLoadAndBindStepFinished;
1510         private int mFlags;
1511 
1512         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
1513 
1514         LoaderTask(Context context, boolean isLaunching, int flags) {
1515             mContext = context;
1516             mIsLaunching = isLaunching;
1517             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
1518             mFlags = flags;
1519         }
1520 
1521         boolean isLaunching() {
1522             return mIsLaunching;
1523         }
1524 
1525         boolean isLoadingWorkspace() {
1526             return mIsLoadingAndBindingWorkspace;
1527         }
1528 
1529         /** Returns whether this is an upgrade path */
1530         private boolean loadAndBindWorkspace() {
1531             mIsLoadingAndBindingWorkspace = true;
1532 
1533             // Load the workspace
1534             if (DEBUG_LOADERS) {
1535                 Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1536             }
1537 
1538             boolean isUpgradePath = false;
1539             if (!mWorkspaceLoaded) {
1540                 isUpgradePath = loadWorkspace();
1541                 synchronized (LoaderTask.this) {
1542                     if (mStopped) {
1543                         return isUpgradePath;
1544                     }
1545                     mWorkspaceLoaded = true;
1546                 }
1547             }
1548 
1549             // Bind the workspace
1550             bindWorkspace(-1, isUpgradePath);
1551             return isUpgradePath;
1552         }
1553 
1554         private void waitForIdle() {
1555             // Wait until the either we&#x27;re stopped or the other threads are done.
1556             // This way we don&#x27;t start loading all apps until the workspace has settled
1557             // down.
1558             synchronized (LoaderTask.this) {
1559                 final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1560 
1561                 mHandler.postIdle(new Runnable() {
1562                         public void run() {
1563                             synchronized (LoaderTask.this) {
1564                                 mLoadAndBindStepFinished = true;
1565                                 if (DEBUG_LOADERS) {
1566                                     Log.d(TAG, &quot;done with previous binding step&quot;);
1567                                 }
1568                                 LoaderTask.this.notify();
1569                             }
1570                         }
1571                     });
1572 
1573                 while (!mStopped &amp;&amp; !mLoadAndBindStepFinished &amp;&amp; !mFlushingWorkerThread) {
1574                     try {
1575                         // Just in case mFlushingWorkerThread changes but we aren&#x27;t woken up,
1576                         // wait no longer than 1sec at a time
1577                         this.wait(1000);
1578                     } catch (InterruptedException ex) {
1579                         // Ignore
1580                     }
1581                 }
1582                 if (DEBUG_LOADERS) {
1583                     Log.d(TAG, &quot;waited &quot;
1584                             + (SystemClock.uptimeMillis()-workspaceWaitTime)
1585                             + &quot;ms for previous step to finish binding&quot;);
1586                 }
1587             }
1588         }
1589 
1590         void runBindSynchronousPage(int synchronousBindPage) {
1591             if (synchronousBindPage == PagedView.INVALID_RESTORE_PAGE) {
1592                 // Ensure that we have a valid page index to load synchronously
1593                 throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1594                         &quot;valid page index&quot;);
1595             }
1596             if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1597                 // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1598                 // loaded already (we should load everything asynchronously in that case)
1599                 throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1600             }
1601             synchronized (mLock) {
1602                 if (mIsLoaderTaskRunning) {
1603                     // Ensure that we are never running the background loading at this point since
1604                     // we also touch the background collections
1605                     throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1606                 }
1607             }
1608 
1609             // XXX: Throw an exception if we are already loading (since we touch the worker thread
1610             //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1611             //      this call is synchronous, we can get away with not locking).
1612 
1613             // The LauncherModel is static in the LauncherAppState and mHandler may have queued
1614             // operations from the previous activity.  We need to ensure that all queued operations
1615             // are executed before any synchronous binding work is done.
1616             mHandler.flush();
1617 
1618             // Divide the set of loaded items into those that we are binding synchronously, and
1619             // everything else that is to be bound normally (asynchronously).
1620             bindWorkspace(synchronousBindPage, false);
1621             // XXX: For now, continue posting the binding of AllApps as there are other issues that
1622             //      arise from that.
1623             onlyBindAllApps();
1624         }
1625 
1626         public void run() {
1627             boolean isUpgrade = false;
1628 
1629             synchronized (mLock) {
1630                 mIsLoaderTaskRunning = true;
1631             }
1632             // Optimize for end-user experience: if the Launcher is up and // running with the
1633             // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1634             // workspace first (default).
1635             keep_running: {
1636                 // Elevate priority when Home launches for the first time to avoid
1637                 // starving at boot time. Staring at a blank home is not cool.
1638                 synchronized (mLock) {
1639                     if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1640                             (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1641                     android.os.Process.setThreadPriority(mIsLaunching
1642                             ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1643                 }
1644                 if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1645                 isUpgrade = loadAndBindWorkspace();
1646 
1647                 if (mStopped) {
1648                     break keep_running;
1649                 }
1650 
1651                 // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1652                 // settled down.
1653                 synchronized (mLock) {
1654                     if (mIsLaunching) {
1655                         if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1656                         android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1657                     }
1658                 }
1659                 waitForIdle();
1660 
1661                 // second step
1662                 if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1663                 loadAndBindAllApps();
1664 
1665                 // Restore the default thread priority after we are done loading items
1666                 synchronized (mLock) {
1667                     android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1668                 }
1669             }
1670 
1671             // Update the saved icons if necessary
1672             if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1673             synchronized (sBgLock) {
1674                 for (Object key : sBgDbIconCache.keySet()) {
1675                     updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
1676                 }
1677                 sBgDbIconCache.clear();
1678             }
1679 
1680             if (LauncherAppState.isDisableAllApps()) {
1681                 // Ensure that all the applications that are in the system are
1682                 // represented on the home screen.
1683                 if (!UPGRADE_USE_MORE_APPS_FOLDER || !isUpgrade) {
1684                     verifyApplications();
1685                 }
1686             }
1687 
1688             // Clear out this reference, otherwise we end up holding it until all of the
1689             // callback runnables are done.
1690             mContext = null;
1691 
1692             synchronized (mLock) {
1693                 // If we are still the last one to be scheduled, remove ourselves.
1694                 if (mLoaderTask == this) {
1695                     mLoaderTask = null;
1696                 }
1697                 mIsLoaderTaskRunning = false;
1698             }
1699         }
1700 
1701         public void stopLocked() {
1702             synchronized (LoaderTask.this) {
1703                 mStopped = true;
1704                 this.notify();
1705             }
1706         }
1707 
1708         /**
1709          * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1710          * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1711          * object that was around when the deferred message was scheduled, and if there&#x27;s
1712          * a new Callbacks object around then also return null.  This will save us from
1713          * calling onto it with data that will be ignored.
1714          */
1715         Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1716             synchronized (mLock) {
1717                 if (mStopped) {
1718                     return null;
1719                 }
1720 
1721                 if (mCallbacks == null) {
1722                     return null;
1723                 }
1724 
1725                 final Callbacks callbacks = mCallbacks.get();
1726                 if (callbacks != oldCallbacks) {
1727                     return null;
1728                 }
1729                 if (callbacks == null) {
1730                     Log.w(TAG, &quot;no mCallbacks&quot;);
1731                     return null;
1732                 }
1733 
1734                 return callbacks;
1735             }
1736         }
1737 
1738         private void verifyApplications() {
1739             final Context context = mApp.getContext();
1740 
1741             // Cross reference all the applications in our apps list with items in the workspace
1742             ArrayList&lt;ItemInfo&gt; tmpInfos;
1743             ArrayList&lt;ItemInfo&gt; added = new ArrayList&lt;ItemInfo&gt;();
1744             synchronized (sBgLock) {
1745                 for (AppInfo app : mBgAllAppsList.data) {
1746                     tmpInfos = getItemInfoForComponentName(app.componentName, app.user);
1747                     if (tmpInfos.isEmpty()) {
1748                         // We are missing an application icon, so add this to the workspace
1749                         added.add(app);
1750                         // This is a rare event, so lets log it
1751                         Log.e(TAG, &quot;Missing Application on load: &quot; + app);
1752                     }
1753                 }
1754             }
1755             if (!added.isEmpty()) {
1756                 addAndBindAddedWorkspaceApps(context, added);
1757             }
1758         }
1759 
1760         // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1761         private boolean checkItemPlacement(HashMap&lt;Long, ItemInfo[][]&gt; occupied, ItemInfo item,
1762                                            AtomicBoolean deleteOnInvalidPlacement) {
1763             LauncherAppState app = LauncherAppState.getInstance();
1764             DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1765             final int countX = (int) grid.numColumns;
1766             final int countY = (int) grid.numRows;
1767 
1768             long containerIndex = item.screenId;
1769             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1770                 // Return early if we detect that an item is under the hotseat button
1771                 if (mCallbacks == null ||
1772                         mCallbacks.get().isAllAppsButtonRank((int) item.screenId)) {
1773                     deleteOnInvalidPlacement.set(true);
1774                     Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1775                             + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1776                             + item.cellY + &quot;) occupied by all apps&quot;);
1777                     return false;
1778                 }
1779 
1780                 final ItemInfo[][] hotseatItems =
1781                         occupied.get((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT);
1782 
1783                 if (item.screenId &gt;= grid.numHotseatIcons) {
1784                     Log.e(TAG, &quot;Error loading shortcut &quot; + item
1785                             + &quot; into hotseat position &quot; + item.screenId
1786                             + &quot;, position out of bounds: (0 to &quot; + (grid.numHotseatIcons - 1)
1787                             + &quot;)&quot;);
1788                     return false;
1789                 }
1790 
1791                 if (hotseatItems != null) {
1792                     if (hotseatItems[(int) item.screenId][0] != null) {
1793                         Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1794                                 + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1795                                 + item.cellY + &quot;) occupied by &quot;
1796                                 + occupied.get(LauncherSettings.Favorites.CONTAINER_HOTSEAT)
1797                                 [(int) item.screenId][0]);
1798                             return false;
1799                     } else {
1800                         hotseatItems[(int) item.screenId][0] = item;
1801                         return true;
1802                     }
1803                 } else {
1804                     final ItemInfo[][] items = new ItemInfo[(int) grid.numHotseatIcons][1];
1805                     items[(int) item.screenId][0] = item;
1806                     occupied.put((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT, items);
1807                     return true;
1808                 }
1809             } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1810                 // Skip further checking if it is not the hotseat or workspace container
1811                 return true;
1812             }
1813 
1814             if (!occupied.containsKey(item.screenId)) {
1815                 ItemInfo[][] items = new ItemInfo[countX + 1][countY + 1];
1816                 occupied.put(item.screenId, items);
1817             }
1818 
1819             final ItemInfo[][] screens = occupied.get(item.screenId);
1820             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1821                     item.cellX &lt; 0 || item.cellY &lt; 0 ||
1822                     item.cellX + item.spanX &gt; countX || item.cellY + item.spanY &gt; countY) {
1823                 Log.e(TAG, &quot;Error loading shortcut &quot; + item
1824                         + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1825                         + item.cellX + &quot;,&quot; + item.cellY
1826                         + &quot;) out of screen bounds ( &quot; + countX + &quot;x&quot; + countY + &quot;)&quot;);
1827                 return false;
1828             }
1829 
1830             // Check if any workspace icons overlap with each other
1831             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1832                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1833                     if (screens[x][y] != null) {
1834                         Log.e(TAG, &quot;Error loading shortcut &quot; + item
1835                             + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1836                             + x + &quot;,&quot; + y
1837                             + &quot;) occupied by &quot;
1838                             + screens[x][y]);
1839                         return false;
1840                     }
1841                 }
1842             }
1843             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1844                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1845                     screens[x][y] = item;
1846                 }
1847             }
1848 
1849             return true;
1850         }
1851 
1852         /** Clears all the sBg data structures */
1853         private void clearSBgDataStructures() {
1854             synchronized (sBgLock) {
1855                 sBgWorkspaceItems.clear();
1856                 sBgAppWidgets.clear();
1857                 sBgFolders.clear();
1858                 sBgItemsIdMap.clear();
1859                 sBgDbIconCache.clear();
1860                 sBgWorkspaceScreens.clear();
1861             }
1862         }
1863 
1864         /** Returns whether this is an upgrade path */
1865         private boolean loadWorkspace() {
1866             // Log to disk
1867             Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspace()&quot;, true);
1868 
1869             final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1870 
1871             final Context context = mContext;
1872             final ContentResolver contentResolver = context.getContentResolver();
1873             final PackageManager manager = context.getPackageManager();
1874             final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1875             final boolean isSafeMode = manager.isSafeMode();
1876             final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
1877             final boolean isSdCardReady = context.registerReceiver(null,
1878                     new IntentFilter(StartupReceiver.SYSTEM_READY)) != null;
1879 
1880             LauncherAppState app = LauncherAppState.getInstance();
1881             DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1882             int countX = (int) grid.numColumns;
1883             int countY = (int) grid.numRows;
1884 
1885             if ((mFlags &amp; LOADER_FLAG_CLEAR_WORKSPACE) != 0) {
1886                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: resetting launcher database&quot;, true);
1887                 LauncherAppState.getLauncherProvider().deleteDatabase();
1888             }
1889 
1890             if ((mFlags &amp; LOADER_FLAG_MIGRATE_SHORTCUTS) != 0) {
1891                 // append the user&#x27;s Launcher2 shortcuts
1892                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: migrating from launcher2&quot;, true);
1893                 LauncherAppState.getLauncherProvider().migrateLauncher2Shortcuts();
1894             } else {
1895                 // Make sure the default workspace is loaded
1896                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: loading default favorites&quot;, false);
1897                 LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary();
1898             }
1899 
1900             // This code path is for our old migration code and should no longer be exercised
1901             boolean loadedOldDb = false;
1902 
1903             // Log to disk
1904             Launcher.addDumpLog(TAG, &quot;11683562 -   loadedOldDb: &quot; + loadedOldDb, true);
1905 
1906             synchronized (sBgLock) {
1907                 clearSBgDataStructures();
1908                 final HashSet&lt;String&gt; installingPkgs = PackageInstallerCompat
1909                         .getInstance(mContext).updateAndGetActiveSessionCache();
1910 
1911                 final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1912                 final ArrayList&lt;Long&gt; restoredRows = new ArrayList&lt;Long&gt;();
1913                 final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION;
1914                 if (DEBUG_LOADERS) Log.d(TAG, &quot;loading model from &quot; + contentUri);
1915                 final Cursor c = contentResolver.query(contentUri, null, null, null, null);
1916 
1917                 // +1 for the hotseat (it can be larger than the workspace)
1918                 // Load workspace in reverse order to ensure that latest items are loaded first (and
1919                 // before any earlier duplicates)
1920                 final HashMap&lt;Long, ItemInfo[][]&gt; occupied = new HashMap&lt;Long, ItemInfo[][]&gt;();
1921 
1922                 try {
1923                     final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1924                     final int intentIndex = c.getColumnIndexOrThrow
1925                             (LauncherSettings.Favorites.INTENT);
1926                     final int titleIndex = c.getColumnIndexOrThrow
1927                             (LauncherSettings.Favorites.TITLE);
1928                     final int iconTypeIndex = c.getColumnIndexOrThrow(
1929                             LauncherSettings.Favorites.ICON_TYPE);
1930                     final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
1931                     final int iconPackageIndex = c.getColumnIndexOrThrow(
1932                             LauncherSettings.Favorites.ICON_PACKAGE);
1933                     final int iconResourceIndex = c.getColumnIndexOrThrow(
1934                             LauncherSettings.Favorites.ICON_RESOURCE);
1935                     final int containerIndex = c.getColumnIndexOrThrow(
1936                             LauncherSettings.Favorites.CONTAINER);
1937                     final int itemTypeIndex = c.getColumnIndexOrThrow(
1938                             LauncherSettings.Favorites.ITEM_TYPE);
1939                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(
1940                             LauncherSettings.Favorites.APPWIDGET_ID);
1941                     final int appWidgetProviderIndex = c.getColumnIndexOrThrow(
1942                             LauncherSettings.Favorites.APPWIDGET_PROVIDER);
1943                     final int screenIndex = c.getColumnIndexOrThrow(
1944                             LauncherSettings.Favorites.SCREEN);
1945                     final int cellXIndex = c.getColumnIndexOrThrow
1946                             (LauncherSettings.Favorites.CELLX);
1947                     final int cellYIndex = c.getColumnIndexOrThrow
1948                             (LauncherSettings.Favorites.CELLY);
1949                     final int spanXIndex = c.getColumnIndexOrThrow
1950                             (LauncherSettings.Favorites.SPANX);
1951                     final int spanYIndex = c.getColumnIndexOrThrow(
1952                             LauncherSettings.Favorites.SPANY);
1953                     final int restoredIndex = c.getColumnIndexOrThrow(
1954                             LauncherSettings.Favorites.RESTORED);
1955                     final int profileIdIndex = c.getColumnIndexOrThrow(
1956                             LauncherSettings.Favorites.PROFILE_ID);
1957                     //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1958                     //final int displayModeIndex = c.getColumnIndexOrThrow(
1959                     //        LauncherSettings.Favorites.DISPLAY_MODE);
1960 
1961                     ShortcutInfo info;
1962                     String intentDescription;
1963                     LauncherAppWidgetInfo appWidgetInfo;
1964                     int container;
1965                     long id;
1966                     Intent intent;
1967                     UserHandleCompat user;
1968 
1969                     while (!mStopped &amp;&amp; c.moveToNext()) {
1970                         AtomicBoolean deleteOnInvalidPlacement = new AtomicBoolean(false);
1971                         try {
1972                             int itemType = c.getInt(itemTypeIndex);
1973                             boolean restored = 0 != c.getInt(restoredIndex);
1974                             boolean allowMissingTarget = false;
1975 
1976                             switch (itemType) {
1977                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1978                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1979                                 id = c.getLong(idIndex);
1980                                 intentDescription = c.getString(intentIndex);
1981                                 long serialNumber = c.getInt(profileIdIndex);
1982                                 user = mUserManager.getUserForSerialNumber(serialNumber);
1983                                 int promiseType = c.getInt(restoredIndex);
1984                                 if (user == null) {
1985                                     // User has been deleted remove the item.
1986                                     itemsToRemove.add(id);
1987                                     continue;
1988                                 }
1989                                 try {
1990                                     intent = Intent.parseUri(intentDescription, 0);
1991                                     ComponentName cn = intent.getComponent();
1992                                     if (cn != null &amp;&amp; cn.getPackageName() != null) {
1993                                         boolean validPkg = launcherApps.isPackageEnabledForProfile(
1994                                                 cn.getPackageName(), user);
1995                                         boolean validComponent = validPkg &amp;&amp;
1996                                                 launcherApps.isActivityEnabledForProfile(cn, user);
1997 
1998                                         if (validComponent) {
1999                                             if (restored) {
2000                                                 // no special handling necessary for this item
2001                                                 restoredRows.add(id);
2002                                                 restored = false;
2003                                             }
2004                                         } else if (validPkg) {
2005                                             intent = null;
2006                                             if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
2007                                                 // We allow auto install apps to have their intent
2008                                                 // updated after an install.
2009                                                 intent = manager.getLaunchIntentForPackage(
2010                                                         cn.getPackageName());
2011                                                 if (intent != null) {
2012                                                     ContentValues values = new ContentValues();
2013                                                     values.put(LauncherSettings.Favorites.INTENT,
2014                                                             intent.toUri(0));
2015                                                     String where = BaseColumns._ID + &quot;= ?&quot;;
2016                                                     String[] args = {Long.toString(id)};
<abbr title="2017                                                     contentResolver.update(contentUri, values, where, args);">2017                                                     contentResolver.update(contentUri, values, where, arg</abbr>
2018                                                 }
2019                                             }
2020 
2021                                             if (intent == null) {
2022                                                 // The app is installed but the component is no
2023                                                 // longer available.
2024                                                 Launcher.addDumpLog(TAG,
2025                                                         &quot;Invalid component removed: &quot; + cn, true);
2026                                                 itemsToRemove.add(id);
2027                                                 continue;
2028                                             } else {
2029                                                 // no special handling necessary for this item
2030                                                 restoredRows.add(id);
2031                                                 restored = false;
2032                                             }
2033                                         } else if (restored) {
2034                                             // Package is not yet available but might be
2035                                             // installed later.
2036                                             Launcher.addDumpLog(TAG,
2037                                                     &quot;package not yet restored: &quot; + cn, true);
2038 
2039                                             if ((promiseType &amp; ShortcutInfo.FLAG_RESTORE_STARTED) != 0) {
2040                                                 // Restore has started once.
2041                                             } else if (installingPkgs.contains(cn.getPackageName())) {
2042                                                 // App restore has started. Update the flag
2043                                                 promiseType |= ShortcutInfo.FLAG_RESTORE_STARTED;
2044                                                 ContentValues values = new ContentValues();
2045                                                 values.put(LauncherSettings.Favorites.RESTORED,
2046                                                         promiseType);
2047                                                 String where = BaseColumns._ID + &quot;= ?&quot;;
2048                                                 String[] args = {Long.toString(id)};
2049                                                 contentResolver.update(contentUri, values, where, args);
2050 
2051                                             } else if (REMOVE_UNRESTORED_ICONS) {
2052                                                 Launcher.addDumpLog(TAG,
2053                                                         &quot;Unrestored package removed: &quot; + cn, true);
2054                                                 itemsToRemove.add(id);
2055                                                 continue;
2056                                             }
2057                                         } else if (isSdCardReady) {
2058                                             // Do not wait for external media load anymore.
2059                                             // Log the invalid package, and remove it
2060                                             Launcher.addDumpLog(TAG,
2061                                                     &quot;Invalid package removed: &quot; + cn, true);
2062                                             itemsToRemove.add(id);
2063                                             continue;
2064                                         } else {
2065                                             // SdCard is not ready yet. Package might get available,
2066                                             // once it is ready.
2067                                             Launcher.addDumpLog(TAG, &quot;Invalid package: &quot; + cn
2068                                                     + &quot; (check again later)&quot;, true);
2069                                             HashSet&lt;String&gt; pkgs = sPendingPackages.get(user);
2070                                             if (pkgs == null) {
2071                                                 pkgs = new HashSet&lt;String&gt;();
2072                                                 sPendingPackages.put(user, pkgs);
2073                                             }
2074                                             pkgs.add(cn.getPackageName());
2075                                             allowMissingTarget = true;
2076                                             // Add the icon on the workspace anyway.
2077                                         }
2078                                     } else if (cn == null) {
2079                                         // For shortcuts with no component, keep them as they are
2080                                         restoredRows.add(id);
2081                                         restored = false;
2082                                     }
2083                                 } catch (URISyntaxException e) {
2084                                     Launcher.addDumpLog(TAG,
2085                                             &quot;Invalid uri: &quot; + intentDescription, true);
2086                                     continue;
2087                                 }
2088 
2089                                 if (restored) {
2090                                     if (user.equals(UserHandleCompat.myUserHandle())) {
2091                                         Launcher.addDumpLog(TAG,
2092                                                 &quot;constructing info for partially restored package&quot;,
2093                                                 true);
2094                                         info = getRestoredItemInfo(c, titleIndex, intent, promiseType);
2095                                         intent = getRestoredItemIntent(c, context, intent);
2096                                     } else {
2097                                         // Don&#x27;t restore items for other profiles.
2098                                         itemsToRemove.add(id);
2099                                         continue;
2100                                     }
2101                                 } else if (itemType ==
2102                                         LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
2103                                     info = getShortcutInfo(manager, intent, user, context, c,
2104                                             iconIndex, titleIndex, mLabelCache, allowMissingTarget);
2105                                 } else {
2106                                     info = getShortcutInfo(c, context, iconTypeIndex,
2107                                             iconPackageIndex, iconResourceIndex, iconIndex,
2108                                             titleIndex);
2109 
2110                                     // App shortcuts that used to be automatically added to Launcher
2111                                     // didn&#x27;t always have the correct intent flags set, so do that
2112                                     // here
2113                                     if (intent.getAction() != null &amp;&amp;
2114                                         intent.getCategories() != null &amp;&amp;
2115                                         intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
2116                                         intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
2117                                         intent.addFlags(
2118                                             Intent.FLAG_ACTIVITY_NEW_TASK |
2119                                             Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
2120                                     }
2121                                 }
2122 
2123                                 if (info != null) {
2124                                     info.id = id;
2125                                     info.intent = intent;
2126                                     container = c.getInt(containerIndex);
2127                                     info.container = container;
2128                                     info.screenId = c.getInt(screenIndex);
2129                                     info.cellX = c.getInt(cellXIndex);
2130                                     info.cellY = c.getInt(cellYIndex);
2131                                     info.spanX = 1;
2132                                     info.spanY = 1;
2133                                     info.intent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);
2134                                     info.isDisabled = isSafeMode
2135                                             &amp;&amp; !Utilities.isSystemApp(context, intent);
2136 
2137                                     // check &amp; update map of what&#x27;s occupied
2138                                     deleteOnInvalidPlacement.set(false);
2139                                     if (!checkItemPlacement(occupied, info, deleteOnInvalidPlacement)) {
2140                                         if (deleteOnInvalidPlacement.get()) {
2141                                             itemsToRemove.add(id);
2142                                         }
2143                                         break;
2144                                     }
2145 
2146                                     switch (container) {
2147                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2148                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2149                                         sBgWorkspaceItems.add(info);
2150                                         break;
2151                                     default:
2152                                         // Item is in a user folder
2153                                         FolderInfo folderInfo =
2154                                                 findOrMakeFolder(sBgFolders, container);
2155                                         folderInfo.add(info);
2156                                         break;
2157                                     }
2158                                     sBgItemsIdMap.put(info.id, info);
2159 
2160                                     // now that we&#x27;ve loaded everthing re-save it with the
2161                                     // icon in case it disappears somehow.
2162                                     queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
2163                                 } else {
2164                                     throw new RuntimeException(&quot;Unexpected null ShortcutInfo&quot;);
2165                                 }
2166                                 break;
2167 
2168                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
2169                                 id = c.getLong(idIndex);
2170                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
2171 
2172                                 folderInfo.title = c.getString(titleIndex);
2173                                 folderInfo.id = id;
2174                                 container = c.getInt(containerIndex);
2175                                 folderInfo.container = container;
2176                                 folderInfo.screenId = c.getInt(screenIndex);
2177                                 folderInfo.cellX = c.getInt(cellXIndex);
2178                                 folderInfo.cellY = c.getInt(cellYIndex);
2179                                 folderInfo.spanX = 1;
2180                                 folderInfo.spanY = 1;
2181 
2182                                 // check &amp; update map of what&#x27;s occupied
2183                                 deleteOnInvalidPlacement.set(false);
2184                                 if (!checkItemPlacement(occupied, folderInfo,
2185                                         deleteOnInvalidPlacement)) {
2186                                     if (deleteOnInvalidPlacement.get()) {
2187                                         itemsToRemove.add(id);
2188                                     }
2189                                     break;
2190                                 }
2191 
2192                                 switch (container) {
2193                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2194                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2195                                         sBgWorkspaceItems.add(folderInfo);
2196                                         break;
2197                                 }
2198 
2199                                 if (restored) {
2200                                     // no special handling required for restored folders
2201                                     restoredRows.add(id);
2202                                 }
2203 
2204                                 sBgItemsIdMap.put(folderInfo.id, folderInfo);
2205                                 sBgFolders.put(folderInfo.id, folderInfo);
2206                                 break;
2207 
2208                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
2209                                 // Read all Launcher-specific widget details
2210                                 int appWidgetId = c.getInt(appWidgetIdIndex);
2211                                 String savedProvider = c.getString(appWidgetProviderIndex);
2212                                 id = c.getLong(idIndex);
2213                                 final ComponentName component =
2214                                         ComponentName.unflattenFromString(savedProvider);
2215 
2216                                 final int restoreStatus = c.getInt(restoredIndex);
2217                                 final boolean isIdValid = (restoreStatus &amp;
2218                                         LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) == 0;
2219 
2220                                 final boolean wasProviderReady = (restoreStatus &amp;
2221                                         LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) == 0;
2222 
2223                                 final AppWidgetProviderInfo provider = isIdValid
2224                                         ? widgets.getAppWidgetInfo(appWidgetId)
2225                                         : findAppWidgetProviderInfoWithComponent(context, component);
2226 
2227                                 final boolean isProviderReady = isValidProvider(provider);
2228                                 if (!isSafeMode &amp;&amp; wasProviderReady &amp;&amp; !isProviderReady) {
2229                                     String log = &quot;Deleting widget that isn&#x27;t installed anymore: &quot;
2230                                             + &quot;id=&quot; + id + &quot; appWidgetId=&quot; + appWidgetId;
2231                                     Log.e(TAG, log);
2232                                     Launcher.addDumpLog(TAG, log, false);
2233                                     itemsToRemove.add(id);
2234                                 } else {
2235                                     if (isProviderReady) {
2236                                         appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2237                                                 provider.provider);
2238                                         int[] minSpan =
2239                                                 Launcher.getMinSpanForWidget(context, provider);
2240                                         appWidgetInfo.minSpanX = minSpan[0];
2241                                         appWidgetInfo.minSpanY = minSpan[1];
2242 
2243                                         int status = restoreStatus;
2244                                         if (!wasProviderReady) {
2245                                             // If provider was not previously ready, update the
2246                                             // status and UI flag.
2247 
<abbr title="2248                                             // Id would be valid only if the widget restore broadcast was received.">2248                                             // Id would be valid only if the widget restore broadcast was</abbr>
2249                                             if (isIdValid) {
2250                                                 status = LauncherAppWidgetInfo.RESTORE_COMPLETED;
2251                                             } else {
2252                                                 status &amp;= ~LauncherAppWidgetInfo
2253                                                         .FLAG_PROVIDER_NOT_READY;
2254                                             }
2255                                         }
2256                                         appWidgetInfo.restoreStatus = status;
2257                                     } else {
2258                                         Log.v(TAG, &quot;Widget restore pending id=&quot; + id
2259                                                 + &quot; appWidgetId=&quot; + appWidgetId
2260                                                 + &quot; status =&quot; + restoreStatus);
2261                                         appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2262                                                 component);
2263                                         appWidgetInfo.restoreStatus = restoreStatus;
2264 
<abbr title="2265                                         if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) != 0) {">2265                                         if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) </abbr>
2266                                             // Restore has started once.
2267                                         } else if (installingPkgs.contains(component.getPackageName())) {
2268                                             // App restore has started. Update the flag
2269                                             appWidgetInfo.restoreStatus |=
2270                                                     LauncherAppWidgetInfo.FLAG_RESTORE_STARTED;
2271                                         } else if (REMOVE_UNRESTORED_ICONS) {
2272                                             Launcher.addDumpLog(TAG,
2273                                                     &quot;Unrestored widget removed: &quot; + component, true);
2274                                             itemsToRemove.add(id);
2275                                             continue;
2276                                         }
2277                                     }
2278 
2279                                     appWidgetInfo.id = id;
2280                                     appWidgetInfo.screenId = c.getInt(screenIndex);
2281                                     appWidgetInfo.cellX = c.getInt(cellXIndex);
2282                                     appWidgetInfo.cellY = c.getInt(cellYIndex);
2283                                     appWidgetInfo.spanX = c.getInt(spanXIndex);
2284                                     appWidgetInfo.spanY = c.getInt(spanYIndex);
2285 
2286                                     container = c.getInt(containerIndex);
2287                                     if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2288                                         container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2289                                         Log.e(TAG, &quot;Widget found where container != &quot; +
2290                                             &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
2291                                         continue;
2292                                     }
2293 
2294                                     appWidgetInfo.container = c.getInt(containerIndex);
2295                                     // check &amp; update map of what&#x27;s occupied
2296                                     deleteOnInvalidPlacement.set(false);
2297                                     if (!checkItemPlacement(occupied, appWidgetInfo,
2298                                             deleteOnInvalidPlacement)) {
2299                                         if (deleteOnInvalidPlacement.get()) {
2300                                             itemsToRemove.add(id);
2301                                         }
2302                                         break;
2303                                     }
2304 
2305                                     String providerName = appWidgetInfo.providerName.flattenToString();
2306                                     if (!providerName.equals(savedProvider) ||
2307                                             (appWidgetInfo.restoreStatus != restoreStatus)) {
2308                                         ContentValues values = new ContentValues();
2309                                         values.put(LauncherSettings.Favorites.APPWIDGET_PROVIDER,
2310                                                 providerName);
2311                                         values.put(LauncherSettings.Favorites.RESTORED,
2312                                                 appWidgetInfo.restoreStatus);
2313                                         String where = BaseColumns._ID + &quot;= ?&quot;;
2314                                         String[] args = {Long.toString(id)};
2315                                         contentResolver.update(contentUri, values, where, args);
2316                                     }
2317                                     sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
2318                                     sBgAppWidgets.add(appWidgetInfo);
2319                                 }
2320                                 break;
2321                             }
2322                         } catch (Exception e) {
2323                             Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;, e, true);
2324                         }
2325                     }
2326                 } finally {
2327                     if (c != null) {
2328                         c.close();
2329                     }
2330                 }
2331 
2332                 // Break early if we&#x27;ve stopped loading
2333                 if (mStopped) {
2334                     clearSBgDataStructures();
2335                     return false;
2336                 }
2337 
2338                 if (itemsToRemove.size() &gt; 0) {
2339                     ContentProviderClient client = contentResolver.acquireContentProviderClient(
2340                             contentUri);
2341                     // Remove dead items
2342                     for (long id : itemsToRemove) {
2343                         if (DEBUG_LOADERS) {
2344                             Log.d(TAG, &quot;Removed id = &quot; + id);
2345                         }
2346                         // Don&#x27;t notify content observers
2347                         try {
2348                             client.delete(LauncherSettings.Favorites.getContentUri(id, false),
2349                                     null, null);
2350                         } catch (RemoteException e) {
2351                             Log.w(TAG, &quot;Could not remove id = &quot; + id);
2352                         }
2353                     }
2354                 }
2355 
2356                 if (restoredRows.size() &gt; 0) {
2357                     ContentProviderClient updater = contentResolver.acquireContentProviderClient(
2358                             contentUri);
2359                     // Update restored items that no longer require special handling
2360                     try {
2361                         StringBuilder selectionBuilder = new StringBuilder();
2362                         selectionBuilder.append(LauncherSettings.Favorites._ID);
2363                         selectionBuilder.append(&quot; IN (&quot;);
2364                         selectionBuilder.append(TextUtils.join(&quot;, &quot;, restoredRows));
2365                         selectionBuilder.append(&quot;)&quot;);
2366                         ContentValues values = new ContentValues();
2367                         values.put(LauncherSettings.Favorites.RESTORED, 0);
2368                         updater.update(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
2369                                 values, selectionBuilder.toString(), null);
2370                     } catch (RemoteException e) {
2371                         Log.w(TAG, &quot;Could not update restored rows&quot;);
2372                     }
2373                 }
2374 
2375                 if (!isSdCardReady &amp;&amp; !sPendingPackages.isEmpty()) {
2376                     context.registerReceiver(new AppsAvailabilityCheck(),
2377                             new IntentFilter(StartupReceiver.SYSTEM_READY),
2378                             null, sWorker);
2379                 }
2380 
2381                 if (loadedOldDb) {
2382                     long maxScreenId = 0;
2383                     // If we&#x27;re importing we use the old screen order.
2384                     for (ItemInfo item: sBgItemsIdMap.values()) {
2385                         long screenId = item.screenId;
2386                         if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2387                                 !sBgWorkspaceScreens.contains(screenId)) {
2388                             sBgWorkspaceScreens.add(screenId);
2389                             if (screenId &gt; maxScreenId) {
2390                                 maxScreenId = screenId;
2391                             }
2392                         }
2393                     }
2394                     Collections.sort(sBgWorkspaceScreens);
2395                     // Log to disk
2396                     Launcher.addDumpLog(TAG, &quot;11683562 -   maxScreenId: &quot; + maxScreenId, true);
2397                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2398                             TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2399 
2400                     LauncherAppState.getLauncherProvider().updateMaxScreenId(maxScreenId);
2401                     updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2402 
2403                     // Update the max item id after we load an old db
2404                     long maxItemId = 0;
2405                     // If we&#x27;re importing we use the old screen order.
2406                     for (ItemInfo item: sBgItemsIdMap.values()) {
2407                         maxItemId = Math.max(maxItemId, item.id);
2408                     }
2409                     LauncherAppState.getLauncherProvider().updateMaxItemId(maxItemId);
2410                 } else {
2411                     TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(mContext);
2412                     for (Integer i : orderedScreens.keySet()) {
2413                         sBgWorkspaceScreens.add(orderedScreens.get(i));
2414                     }
2415                     // Log to disk
2416                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2417                             TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2418 
2419                     // Remove any empty screens
2420                     ArrayList&lt;Long&gt; unusedScreens = new ArrayList&lt;Long&gt;(sBgWorkspaceScreens);
2421                     for (ItemInfo item: sBgItemsIdMap.values()) {
2422                         long screenId = item.screenId;
2423                         if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2424                                 unusedScreens.contains(screenId)) {
2425                             unusedScreens.remove(screenId);
2426                         }
2427                     }
2428 
2429                     // If there are any empty screens remove them, and update.
2430                     if (unusedScreens.size() != 0) {
2431                         // Log to disk
2432                         Launcher.addDumpLog(TAG, &quot;11683562 -   unusedScreens (to be removed): &quot; +
2433                                 TextUtils.join(&quot;, &quot;, unusedScreens), true);
2434 
2435                         sBgWorkspaceScreens.removeAll(unusedScreens);
2436                         updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2437                     }
2438                 }
2439 
2440                 if (DEBUG_LOADERS) {
2441                     Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2442                     Log.d(TAG, &quot;workspace layout: &quot;);
2443                     int nScreens = occupied.size();
2444                     for (int y = 0; y &lt; countY; y++) {
2445                         String line = &quot;&quot;;
2446 
2447                         Iterator&lt;Long&gt; iter = occupied.keySet().iterator();
2448                         while (iter.hasNext()) {
2449                             long screenId = iter.next();
2450                             if (screenId &gt; 0) {
2451                                 line += &quot; | &quot;;
2452                             }
2453                             for (int x = 0; x &lt; countX; x++) {
2454                                 ItemInfo[][] screen = occupied.get(screenId);
2455                                 if (x &lt; screen.length &amp;&amp; y &lt; screen[x].length) {
2456                                     line += (screen[x][y] != null) ? &quot;#&quot; : &quot;.&quot;;
2457                                 } else {
2458                                     line += &quot;!&quot;;
2459                                 }
2460                             }
2461                         }
2462                         Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
2463                     }
2464                 }
2465             }
2466             return loadedOldDb;
2467         }
2468 
2469         /** Filters the set of items who are directly or indirectly (via another container) on the
2470          * specified screen. */
2471         private void filterCurrentWorkspaceItems(long currentScreenId,
2472                 ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
2473                 ArrayList&lt;ItemInfo&gt; currentScreenItems,
2474                 ArrayList&lt;ItemInfo&gt; otherScreenItems) {
2475             // Purge any null ItemInfos
2476             Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
2477             while (iter.hasNext()) {
2478                 ItemInfo i = iter.next();
2479                 if (i == null) {
2480                     iter.remove();
2481                 }
2482             }
2483 
2484             // Order the set of items by their containers first, this allows use to walk through the
2485             // list sequentially, build up a list of containers that are in the specified screen,
2486             // as well as all items in those containers.
2487             Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
2488             Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
2489                 @Override
2490                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2491                     return (int) (lhs.container - rhs.container);
2492                 }
2493             });
2494             for (ItemInfo info : allWorkspaceItems) {
2495                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2496                     if (info.screenId == currentScreenId) {
2497                         currentScreenItems.add(info);
2498                         itemsOnScreen.add(info.id);
2499                     } else {
2500                         otherScreenItems.add(info);
2501                     }
2502                 } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2503                     currentScreenItems.add(info);
2504                     itemsOnScreen.add(info.id);
2505                 } else {
2506                     if (itemsOnScreen.contains(info.container)) {
2507                         currentScreenItems.add(info);
2508                         itemsOnScreen.add(info.id);
2509                     } else {
2510                         otherScreenItems.add(info);
2511                     }
2512                 }
2513             }
2514         }
2515 
2516         /** Filters the set of widgets which are on the specified screen. */
2517         private void filterCurrentAppWidgets(long currentScreenId,
2518                 ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2519                 ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
2520                 ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
2521 
2522             for (LauncherAppWidgetInfo widget : appWidgets) {
2523                 if (widget == null) continue;
2524                 if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2525                         widget.screenId == currentScreenId) {
2526                     currentScreenWidgets.add(widget);
2527                 } else {
2528                     otherScreenWidgets.add(widget);
2529                 }
2530             }
2531         }
2532 
2533         /** Filters the set of folders which are on the specified screen. */
2534         private void filterCurrentFolders(long currentScreenId,
2535                 HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
2536                 HashMap&lt;Long, FolderInfo&gt; folders,
2537                 HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
2538                 HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
2539 
2540             for (long id : folders.keySet()) {
2541                 ItemInfo info = itemsIdMap.get(id);
2542                 FolderInfo folder = folders.get(id);
2543                 if (info == null || folder == null) continue;
2544                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2545                         info.screenId == currentScreenId) {
2546                     currentScreenFolders.put(id, folder);
2547                 } else {
2548                     otherScreenFolders.put(id, folder);
2549                 }
2550             }
2551         }
2552 
2553         /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
2554          * right) */
2555         private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
2556             final LauncherAppState app = LauncherAppState.getInstance();
2557             final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2558             // XXX: review this
2559             Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
2560                 @Override
2561                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2562                     int cellCountX = (int) grid.numColumns;
2563                     int cellCountY = (int) grid.numRows;
2564                     int screenOffset = cellCountX * cellCountY;
2565                     int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
2566                     long lr = (lhs.container * containerOffset + lhs.screenId * screenOffset +
2567                             lhs.cellY * cellCountX + lhs.cellX);
2568                     long rr = (rhs.container * containerOffset + rhs.screenId * screenOffset +
2569                             rhs.cellY * cellCountX + rhs.cellX);
2570                     return (int) (lr - rr);
2571                 }
2572             });
2573         }
2574 
2575         private void bindWorkspaceScreens(final Callbacks oldCallbacks,
2576                 final ArrayList&lt;Long&gt; orderedScreens) {
2577             final Runnable r = new Runnable() {
2578                 @Override
2579                 public void run() {
2580                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2581                     if (callbacks != null) {
2582                         callbacks.bindScreens(orderedScreens);
2583                     }
2584                 }
2585             };
2586             runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2587         }
2588 
2589         private void bindWorkspaceItems(final Callbacks oldCallbacks,
2590                 final ArrayList&lt;ItemInfo&gt; workspaceItems,
2591                 final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2592                 final HashMap&lt;Long, FolderInfo&gt; folders,
2593                 ArrayList&lt;Runnable&gt; deferredBindRunnables) {
2594 
2595             final boolean postOnMainThread = (deferredBindRunnables != null);
2596 
2597             // Bind the workspace items
2598             int N = workspaceItems.size();
2599             for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
2600                 final int start = i;
2601                 final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
2602                 final Runnable r = new Runnable() {
2603                     @Override
2604                     public void run() {
2605                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2606                         if (callbacks != null) {
2607                             callbacks.bindItems(workspaceItems, start, start+chunkSize,
2608                                     false);
2609                         }
2610                     }
2611                 };
2612                 if (postOnMainThread) {
2613                     synchronized (deferredBindRunnables) {
2614                         deferredBindRunnables.add(r);
2615                     }
2616                 } else {
2617                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2618                 }
2619             }
2620 
2621             // Bind the folders
2622             if (!folders.isEmpty()) {
2623                 final Runnable r = new Runnable() {
2624                     public void run() {
2625                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2626                         if (callbacks != null) {
2627                             callbacks.bindFolders(folders);
2628                         }
2629                     }
2630                 };
2631                 if (postOnMainThread) {
2632                     synchronized (deferredBindRunnables) {
2633                         deferredBindRunnables.add(r);
2634                     }
2635                 } else {
2636                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2637                 }
2638             }
2639 
2640             // Bind the widgets, one at a time
2641             N = appWidgets.size();
2642             for (int i = 0; i &lt; N; i++) {
2643                 final LauncherAppWidgetInfo widget = appWidgets.get(i);
2644                 final Runnable r = new Runnable() {
2645                     public void run() {
2646                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2647                         if (callbacks != null) {
2648                             callbacks.bindAppWidget(widget);
2649                         }
2650                     }
2651                 };
2652                 if (postOnMainThread) {
2653                     deferredBindRunnables.add(r);
2654                 } else {
2655                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2656                 }
2657             }
2658         }
2659 
2660         /**
2661          * Binds all loaded data to actual views on the main thread.
2662          */
2663         private void bindWorkspace(int synchronizeBindPage, final boolean isUpgradePath) {
2664             final long t = SystemClock.uptimeMillis();
2665             Runnable r;
2666 
2667             // Don&#x27;t use these two variables in any of the callback runnables.
2668             // Otherwise we hold a reference to them.
2669             final Callbacks oldCallbacks = mCallbacks.get();
2670             if (oldCallbacks == null) {
2671                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2672                 Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
2673                 return;
2674             }
2675 
2676             // Save a copy of all the bg-thread collections
2677             ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
2678             ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
2679                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2680             HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
2681             HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
2682             ArrayList&lt;Long&gt; orderedScreenIds = new ArrayList&lt;Long&gt;();
2683             synchronized (sBgLock) {
2684                 workspaceItems.addAll(sBgWorkspaceItems);
2685                 appWidgets.addAll(sBgAppWidgets);
2686                 folders.putAll(sBgFolders);
2687                 itemsIdMap.putAll(sBgItemsIdMap);
2688                 orderedScreenIds.addAll(sBgWorkspaceScreens);
2689             }
2690 
2691             final boolean isLoadingSynchronously =
2692                     synchronizeBindPage != PagedView.INVALID_RESTORE_PAGE;
2693             int currScreen = isLoadingSynchronously ? synchronizeBindPage :
2694                 oldCallbacks.getCurrentWorkspaceScreen();
2695             if (currScreen &gt;= orderedScreenIds.size()) {
2696                 // There may be no workspace screens (just hotseat items and an empty page).
2697                 currScreen = PagedView.INVALID_RESTORE_PAGE;
2698             }
2699             final int currentScreen = currScreen;
2700             final long currentScreenId = currentScreen &lt; 0
2701                     ? INVALID_SCREEN_ID : orderedScreenIds.get(currentScreen);
2702 
2703             // Load all the items that are on the current page first (and in the process, unbind
2704             // all the existing workspace items before we call startBinding() below.
2705             unbindWorkspaceItemsOnMainThread();
2706 
2707             // Separate the items that are on the current screen, and all the other remaining items
2708             ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2709             ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2710             ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
2711                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2712             ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
2713                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2714             HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
2715             HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
2716 
2717             filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems,
2718                     otherWorkspaceItems);
2719             filterCurrentAppWidgets(currentScreenId, appWidgets, currentAppWidgets,
2720                     otherAppWidgets);
2721             filterCurrentFolders(currentScreenId, itemsIdMap, folders, currentFolders,
2722                     otherFolders);
2723             sortWorkspaceItemsSpatially(currentWorkspaceItems);
2724             sortWorkspaceItemsSpatially(otherWorkspaceItems);
2725 
2726             // Tell the workspace that we&#x27;re about to start binding items
2727             r = new Runnable() {
2728                 public void run() {
2729                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2730                     if (callbacks != null) {
2731                         callbacks.startBinding();
2732                     }
2733                 }
2734             };
2735             runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2736 
2737             bindWorkspaceScreens(oldCallbacks, orderedScreenIds);
2738 
2739             // Load items on the current page
2740             bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
2741                     currentFolders, null);
2742             if (isLoadingSynchronously) {
2743                 r = new Runnable() {
2744                     public void run() {
2745                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2746                         if (callbacks != null &amp;&amp; currentScreen != PagedView.INVALID_RESTORE_PAGE) {
2747                             callbacks.onPageBoundSynchronously(currentScreen);
2748                         }
2749                     }
2750                 };
2751                 runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2752             }
2753 
2754             // Load all the remaining pages (if we are loading synchronously, we want to defer this
2755             // work until after the first render)
2756             synchronized (mDeferredBindRunnables) {
2757                 mDeferredBindRunnables.clear();
2758             }
2759             bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
2760                     (isLoadingSynchronously ? mDeferredBindRunnables : null));
2761 
2762             // Tell the workspace that we&#x27;re done binding items
2763             r = new Runnable() {
2764                 public void run() {
2765                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2766                     if (callbacks != null) {
2767                         callbacks.finishBindingItems(isUpgradePath);
2768                     }
2769 
2770                     // If we&#x27;re profiling, ensure this is the last thing in the queue.
2771                     if (DEBUG_LOADERS) {
2772                         Log.d(TAG, &quot;bound workspace in &quot;
2773                             + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2774                     }
2775 
2776                     mIsLoadingAndBindingWorkspace = false;
2777                 }
2778             };
2779             if (isLoadingSynchronously) {
2780                 synchronized (mDeferredBindRunnables) {
2781                     mDeferredBindRunnables.add(r);
2782                 }
2783             } else {
2784                 runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2785             }
2786         }
2787 
2788         private void loadAndBindAllApps() {
2789             if (DEBUG_LOADERS) {
2790                 Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
2791             }
2792             if (!mAllAppsLoaded) {
2793                 loadAllApps();
2794                 synchronized (LoaderTask.this) {
2795                     if (mStopped) {
2796                         return;
2797                     }
2798                     mAllAppsLoaded = true;
2799                 }
2800             } else {
2801                 onlyBindAllApps();
2802             }
2803         }
2804 
2805         private void onlyBindAllApps() {
2806             final Callbacks oldCallbacks = mCallbacks.get();
2807             if (oldCallbacks == null) {
2808                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2809                 Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
2810                 return;
2811             }
2812 
2813             // shallow copy
2814             @SuppressWarnings(&quot;unchecked&quot;)
2815             final ArrayList&lt;AppInfo&gt; list
2816                     = (ArrayList&lt;AppInfo&gt;) mBgAllAppsList.data.clone();
2817             Runnable r = new Runnable() {
2818                 public void run() {
2819                     final long t = SystemClock.uptimeMillis();
2820                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2821                     if (callbacks != null) {
2822                         callbacks.bindAllApplications(list);
2823                     }
2824                     if (DEBUG_LOADERS) {
2825                         Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
2826                                 + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2827                     }
2828                 }
2829             };
2830             boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
2831             if (isRunningOnMainThread) {
2832                 r.run();
2833             } else {
2834                 mHandler.post(r);
2835             }
2836         }
2837 
2838         private void loadAllApps() {
2839             final long loadTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2840 
2841             final Callbacks oldCallbacks = mCallbacks.get();
2842             if (oldCallbacks == null) {
2843                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2844                 Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllApps)&quot;);
2845                 return;
2846             }
2847 
2848             final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
2849             mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2850 
2851             final List&lt;UserHandleCompat&gt; profiles = mUserManager.getUserProfiles();
2852 
2853             // Clear the list of apps
2854             mBgAllAppsList.clear();
2855             for (UserHandleCompat user : profiles) {
2856                 // Query for the set of apps
2857                 final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2858                 List&lt;LauncherActivityInfoCompat&gt; apps = mLauncherApps.getActivityList(null, user);
2859                 if (DEBUG_LOADERS) {
2860                     Log.d(TAG, &quot;getActivityList took &quot;
2861                             + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms for user &quot; + user);
2862                     Log.d(TAG, &quot;getActivityList got &quot; + apps.size() + &quot; apps for user &quot; + user);
2863                 }
2864                 // Fail if we don&#x27;t have any apps
2865                 if (apps == null || apps.isEmpty()) {
2866                     return;
2867                 }
2868                 // Sort the applications by name
2869                 final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2870                 Collections.sort(apps,
2871                         new LauncherModel.ShortcutNameComparator(mLabelCache));
2872                 if (DEBUG_LOADERS) {
2873                     Log.d(TAG, &quot;sort took &quot;
2874                             + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);
2875                 }
2876 
2877                 // Create the ApplicationInfos
2878                 for (int i = 0; i &lt; apps.size(); i++) {
2879                     LauncherActivityInfoCompat app = apps.get(i);
2880                     // This builds the icon bitmaps.
2881                     mBgAllAppsList.add(new AppInfo(mContext, app, user, mIconCache, mLabelCache));
2882                 }
2883             }
2884             // Huh? Shouldn&#x27;t this be inside the Runnable below?
2885             final ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added;
2886             mBgAllAppsList.added = new ArrayList&lt;AppInfo&gt;();
2887 
2888             // Post callback on main thread
2889             mHandler.post(new Runnable() {
2890                 public void run() {
2891                     final long bindTime = SystemClock.uptimeMillis();
2892                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2893                     if (callbacks != null) {
2894                         callbacks.bindAllApplications(added);
2895                         if (DEBUG_LOADERS) {
2896                             Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
2897                                 + (SystemClock.uptimeMillis() - bindTime) + &quot;ms&quot;);
2898                         }
2899                     } else {
2900                         Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
2901                     }
2902                 }
2903             });
2904 
2905             if (DEBUG_LOADERS) {
2906                 Log.d(TAG, &quot;Icons processed in &quot;
2907                         + (SystemClock.uptimeMillis() - loadTime) + &quot;ms&quot;);
2908             }
2909         }
2910 
2911         public void dumpState() {
2912             synchronized (sBgLock) {
2913                 Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
2914                 Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
2915                 Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
2916                 Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
2917                 Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
2918             }
2919         }
2920     }
2921 
2922     void enqueuePackageUpdated(PackageUpdatedTask task) {
2923         sWorker.post(task);
2924     }
2925 
2926     private class AppsAvailabilityCheck extends BroadcastReceiver {
2927 
2928         @Override
2929         public void onReceive(Context context, Intent intent) {
2930             synchronized (sBgLock) {
2931                 final LauncherAppsCompat launcherApps = LauncherAppsCompat
2932                         .getInstance(mApp.getContext());
2933                 ArrayList&lt;String&gt; packagesRemoved;
2934                 for (Entry&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; entry : sPendingPackages.entrySet()) {
2935                     UserHandleCompat user = entry.getKey();
2936                     packagesRemoved = new ArrayList&lt;String&gt;();
2937                     for (String pkg : entry.getValue()) {
2938                         if (!launcherApps.isPackageEnabledForProfile(pkg, user)) {
2939                             Launcher.addDumpLog(TAG, &quot;Package not found: &quot; + pkg, true);
2940                             packagesRemoved.add(pkg);
2941                         }
2942                     }
2943                     if (!packagesRemoved.isEmpty()) {
2944                         enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_REMOVE,
2945                                 packagesRemoved.toArray(new String[packagesRemoved.size()]), user));
2946                     }
2947                 }
2948                 sPendingPackages.clear();
2949             }
2950         }
2951     }
2952 
2953     /**
2954      * Workaround to re-check unrestored items, in-case they were installed but the Package-ADD
2955      * runnable was missed by the launcher.
2956      */
2957     public void recheckRestoredItems(final Context context) {
2958         Runnable r = new Runnable() {
2959 
2960             @Override
2961             public void run() {
2962                 LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
2963                 HashSet&lt;String&gt; installedPackages = new HashSet&lt;String&gt;();
2964                 UserHandleCompat user = UserHandleCompat.myUserHandle();
2965                 synchronized(sBgLock) {
2966                     for (ItemInfo info : sBgItemsIdMap.values()) {
2967                         if (info instanceof ShortcutInfo) {
2968                             ShortcutInfo si = (ShortcutInfo) info;
2969                             if (si.isPromise() &amp;&amp; si.getTargetComponent() != null
2970                                     &amp;&amp; launcherApps.isPackageEnabledForProfile(
2971                                             si.getTargetComponent().getPackageName(), user)) {
2972                                 installedPackages.add(si.getTargetComponent().getPackageName());
2973                             }
2974                         } else if (info instanceof LauncherAppWidgetInfo) {
2975                             LauncherAppWidgetInfo widget = (LauncherAppWidgetInfo) info;
2976                             if (widget.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY)
2977                                     &amp;&amp; launcherApps.isPackageEnabledForProfile(
2978                                             widget.providerName.getPackageName(), user)) {
2979                                 installedPackages.add(widget.providerName.getPackageName());
2980                             }
2981                         }
2982                     }
2983                 }
2984 
2985                 if (!installedPackages.isEmpty()) {
2986                     final ArrayList&lt;AppInfo&gt; restoredApps = new ArrayList&lt;AppInfo&gt;();
2987                     for (String pkg : installedPackages) {
2988                         for (LauncherActivityInfoCompat info : launcherApps.getActivityList(pkg, user)) {
2989                             restoredApps.add(new AppInfo(context, info, user, mIconCache, null));
2990                         }
2991                     }
2992 
2993                     final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
2994                     if (!restoredApps.isEmpty()) {
2995                         mHandler.post(new Runnable() {
2996                             public void run() {
2997                                 Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2998                                 if (callbacks == cb &amp;&amp; cb != null) {
2999                                     callbacks.bindAppsRestored(restoredApps);
3000                                 }
3001                             }
3002                         });
3003                     }
3004 
3005                 }
3006             }
3007         };
3008         sWorker.post(r);
3009     }
3010 
3011     private class PackageUpdatedTask implements Runnable {
3012         int mOp;
3013         String[] mPackages;
3014         UserHandleCompat mUser;
3015 
3016         public static final int OP_NONE = 0;
3017         public static final int OP_ADD = 1;
3018         public static final int OP_UPDATE = 2;
3019         public static final int OP_REMOVE = 3; // uninstlled
3020         public static final int OP_UNAVAILABLE = 4; // external media unmounted
3021 
3022 
3023         public PackageUpdatedTask(int op, String[] packages, UserHandleCompat user) {
3024             mOp = op;
3025             mPackages = packages;
3026             mUser = user;
3027         }
3028 
3029         public void run() {
3030             final Context context = mApp.getContext();
3031 
3032             final String[] packages = mPackages;
3033             final int N = packages.length;
3034             switch (mOp) {
3035                 case OP_ADD:
3036                     for (int i=0; i&lt;N; i++) {
3037                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
3038                         mIconCache.remove(packages[i], mUser);
3039                         mBgAllAppsList.addPackage(context, packages[i], mUser);
3040                     }
3041                     break;
3042                 case OP_UPDATE:
3043                     for (int i=0; i&lt;N; i++) {
3044                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
3045                         mBgAllAppsList.updatePackage(context, packages[i], mUser);
3046                         WidgetPreviewLoader.removePackageFromDb(
3047                                 mApp.getWidgetPreviewCacheDb(), packages[i]);
3048                     }
3049                     break;
3050                 case OP_REMOVE:
3051                 case OP_UNAVAILABLE:
3052                     for (int i=0; i&lt;N; i++) {
3053                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
3054                         mBgAllAppsList.removePackage(packages[i], mUser);
3055                         WidgetPreviewLoader.removePackageFromDb(
3056                                 mApp.getWidgetPreviewCacheDb(), packages[i]);
3057                     }
3058                     break;
3059             }
3060 
3061             ArrayList&lt;AppInfo&gt; added = null;
3062             ArrayList&lt;AppInfo&gt; modified = null;
3063             final ArrayList&lt;AppInfo&gt; removedApps = new ArrayList&lt;AppInfo&gt;();
3064 
3065             if (mBgAllAppsList.added.size() &gt; 0) {
3066                 added = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.added);
3067                 mBgAllAppsList.added.clear();
3068             }
3069             if (mBgAllAppsList.modified.size() &gt; 0) {
3070                 modified = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.modified);
3071                 mBgAllAppsList.modified.clear();
3072             }
3073             if (mBgAllAppsList.removed.size() &gt; 0) {
3074                 removedApps.addAll(mBgAllAppsList.removed);
3075                 mBgAllAppsList.removed.clear();
3076             }
3077 
3078             final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
3079             if (callbacks == null) {
3080                 Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
3081                 return;
3082             }
3083 
3084             if (added != null) {
3085                 // Ensure that we add all the workspace applications to the db
3086                 if (LauncherAppState.isDisableAllApps()) {
3087                     final ArrayList&lt;ItemInfo&gt; addedInfos = new ArrayList&lt;ItemInfo&gt;(added);
3088                     addAndBindAddedWorkspaceApps(context, addedInfos);
3089                 } else {
3090                     addAppsToAllApps(context, added);
3091                 }
3092             }
3093 
3094             if (modified != null) {
3095                 final ArrayList&lt;AppInfo&gt; modifiedFinal = modified;
3096 
3097                 // Update the launcher db to reflect the changes
3098                 for (AppInfo a : modifiedFinal) {
3099                     ArrayList&lt;ItemInfo&gt; infos =
3100                             getItemInfoForComponentName(a.componentName, mUser);
3101                     for (ItemInfo i : infos) {
3102                         if (isShortcutInfoUpdateable(i)) {
3103                             ShortcutInfo info = (ShortcutInfo) i;
3104                             info.title = a.title.toString();
3105                             info.contentDescription = a.contentDescription;
3106                             updateItemInDatabase(context, info);
3107                         }
3108                     }
3109                 }
3110 
3111                 mHandler.post(new Runnable() {
3112                     public void run() {
3113                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3114                         if (callbacks == cb &amp;&amp; cb != null) {
3115                             callbacks.bindAppsUpdated(modifiedFinal);
3116                         }
3117                     }
3118                 });
3119             }
3120 
3121             final ArrayList&lt;String&gt; removedPackageNames =
3122                     new ArrayList&lt;String&gt;();
3123             if (mOp == OP_REMOVE) {
3124                 // Mark all packages in the broadcast to be removed
3125                 removedPackageNames.addAll(Arrays.asList(packages));
3126             } else if (mOp == OP_UPDATE) {
3127                 // Mark disabled packages in the broadcast to be removed
3128                 final PackageManager pm = context.getPackageManager();
3129                 for (int i=0; i&lt;N; i++) {
3130                     if (isPackageDisabled(context, packages[i], mUser)) {
3131                         removedPackageNames.add(packages[i]);
3132                     }
3133                 }
3134             }
3135             // Remove all the components associated with this package
3136             for (String pn : removedPackageNames) {
3137                 deletePackageFromDatabase(context, pn, mUser);
3138             }
3139             // Remove all the specific components
3140             for (AppInfo a : removedApps) {
3141                 ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName, mUser);
3142                 deleteItemsFromDatabase(context, infos);
3143             }
3144             if (!removedPackageNames.isEmpty() || !removedApps.isEmpty()) {
3145                 // Remove any queued items from the install queue
3146                 String spKey = LauncherAppState.getSharedPreferencesKey();
3147                 SharedPreferences sp =
3148                         context.getSharedPreferences(spKey, Context.MODE_PRIVATE);
3149                 InstallShortcutReceiver.removeFromInstallQueue(sp, removedPackageNames);
3150                 // Call the components-removed callback
3151                 mHandler.post(new Runnable() {
3152                     public void run() {
3153                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3154                         if (callbacks == cb &amp;&amp; cb != null) {
3155                             callbacks.bindComponentsRemoved(removedPackageNames, removedApps, mUser);
3156                         }
3157                     }
3158                 });
3159             }
3160 
3161             final ArrayList&lt;Object&gt; widgetsAndShortcuts =
3162                     getSortedWidgetsAndShortcuts(context);
3163             mHandler.post(new Runnable() {
3164                 @Override
3165                 public void run() {
3166                     Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3167                     if (callbacks == cb &amp;&amp; cb != null) {
3168                         callbacks.bindPackagesUpdated(widgetsAndShortcuts);
3169                     }
3170                 }
3171             });
3172 
3173             // Write all the logs to disk
3174             mHandler.post(new Runnable() {
3175                 public void run() {
3176                     Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3177                     if (callbacks == cb &amp;&amp; cb != null) {
3178                         callbacks.dumpLogsToLocalData();
3179                     }
3180                 }
3181             });
3182         }
3183     }
3184 
3185     // Returns a list of ResolveInfos/AppWindowInfos in sorted order
3186     public static ArrayList&lt;Object&gt; getSortedWidgetsAndShortcuts(Context context) {
3187         PackageManager packageManager = context.getPackageManager();
3188         final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();
3189         widgetsAndShortcuts.addAll(AppWidgetManagerCompat.getInstance(context).getAllProviders());
3190 
3191         Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
3192         widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));
3193         Collections.sort(widgetsAndShortcuts, new WidgetAndShortcutNameComparator(context));
3194         return widgetsAndShortcuts;
3195     }
3196 
3197     private static boolean isPackageDisabled(Context context, String packageName,
3198             UserHandleCompat user) {
3199         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3200         return !launcherApps.isPackageEnabledForProfile(packageName, user);
3201     }
3202 
3203     public static boolean isValidPackageActivity(Context context, ComponentName cn,
3204             UserHandleCompat user) {
3205         if (cn == null) {
3206             return false;
3207         }
3208         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3209         if (!launcherApps.isPackageEnabledForProfile(cn.getPackageName(), user)) {
3210             return false;
3211         }
3212         return launcherApps.isActivityEnabledForProfile(cn, user);
3213     }
3214 
3215     public static boolean isValidPackage(Context context, String packageName,
3216             UserHandleCompat user) {
3217         if (packageName == null) {
3218             return false;
3219         }
3220         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3221         return launcherApps.isPackageEnabledForProfile(packageName, user);
3222     }
3223 
3224     /**
3225      * Make an ShortcutInfo object for a restored application or shortcut item that points
3226      * to a package that is not yet installed on the system.
3227      */
3228     public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex, Intent intent,
3229             int promiseType) {
3230         final ShortcutInfo info = new ShortcutInfo();
3231         info.user = UserHandleCompat.myUserHandle();
3232         mIconCache.getTitleAndIcon(info, intent, info.user, true);
3233 
3234         if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_ICON) != 0) {
3235             String title = (cursor != null) ? cursor.getString(titleIndex) : null;
3236             if (!TextUtils.isEmpty(title)) {
3237                 info.title = title;
3238             }
3239             info.status = ShortcutInfo.FLAG_RESTORED_ICON;
3240         } else if  ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
3241             if (TextUtils.isEmpty(info.title)) {
3242                 info.title = (cursor != null) ? cursor.getString(titleIndex) : &quot;&quot;;
3243             }
3244             info.status = ShortcutInfo.FLAG_AUTOINTALL_ICON;
3245         } else {
3246             throw new InvalidParameterException(&quot;Invalid restoreType &quot; + promiseType);
3247         }
3248 
3249         info.contentDescription = mUserManager.getBadgedLabelForUser(
3250                 info.title.toString(), info.user);
3251         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3252         info.promisedIntent = intent;
3253         return info;
3254     }
3255 
3256     /**
3257      * Make an Intent object for a restored application or shortcut item that points
3258      * to the market page for the item.
3259      */
3260     private Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {
3261         ComponentName componentName = intent.getComponent();
3262         return getMarketIntent(componentName.getPackageName());
3263     }
3264 
3265     static Intent getMarketIntent(String packageName) {
3266         return new Intent(Intent.ACTION_VIEW)
3267             .setData(new Uri.Builder()
3268                 .scheme(&quot;market&quot;)
3269                 .authority(&quot;details&quot;)
3270                 .appendQueryParameter(&quot;id&quot;, packageName)
3271                 .build());
3272     }
3273 
3274     /**
3275      * This is called from the code that adds shortcuts from the intent receiver.  This
3276      * doesn&#x27;t have a Cursor, but
3277      */
3278     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,
3279             UserHandleCompat user, Context context) {
3280         return getShortcutInfo(manager, intent, user, context, null, -1, -1, null, false);
3281     }
3282 
3283     /**
3284      * Make an ShortcutInfo object for a shortcut that is an application.
3285      *
3286      * If c is not null, then it will be used to fill in missing data like the title and icon.
3287      */
3288     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,
3289             UserHandleCompat user, Context context, Cursor c, int iconIndex, int titleIndex,
3290             HashMap&lt;Object, CharSequence&gt; labelCache, boolean allowMissingTarget) {
3291         if (user == null) {
3292             Log.d(TAG, &quot;Null user found in getShortcutInfo&quot;);
3293             return null;
3294         }
3295 
3296         ComponentName componentName = intent.getComponent();
3297         if (componentName == null) {
3298             Log.d(TAG, &quot;Missing component found in getShortcutInfo: &quot; + componentName);
3299             return null;
3300         }
3301 
3302         Intent newIntent = new Intent(intent.getAction(), null);
3303         newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
3304         newIntent.setComponent(componentName);
3305         LauncherActivityInfoCompat lai = mLauncherApps.resolveActivity(newIntent, user);
3306         if ((lai == null) &amp;&amp; !allowMissingTarget) {
3307             Log.d(TAG, &quot;Missing activity found in getShortcutInfo: &quot; + componentName);
3308             return null;
3309         }
3310 
3311         final ShortcutInfo info = new ShortcutInfo();
3312 
3313         // the resource -- This may implicitly give us back the fallback icon,
3314         // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
3315         // to avoid saving lots of copies of that in the database, and most apps
3316         // have icons anyway.
3317         Bitmap icon = mIconCache.getIcon(componentName, lai, labelCache);
3318 
3319         // the db
3320         if (icon == null) {
3321             if (c != null) {
3322                 icon = getIconFromCursor(c, iconIndex, context);
3323             }
3324         }
3325         // the fallback icon
3326         if (icon == null) {
3327             icon = mIconCache.getDefaultIcon(user);
3328             info.usingFallbackIcon = true;
3329         }
3330         info.setIcon(icon);
3331 
3332         // From the cache.
3333         if (labelCache != null) {
3334             info.title = labelCache.get(componentName);
3335         }
3336 
3337         // from the resource
3338         if (info.title == null &amp;&amp; lai != null) {
3339             info.title = lai.getLabel();
3340             if (labelCache != null) {
3341                 labelCache.put(componentName, info.title);
3342             }
3343         }
3344         // from the db
3345         if (info.title == null) {
3346             if (c != null) {
3347                 info.title =  c.getString(titleIndex);
3348             }
3349         }
3350         // fall back to the class name of the activity
3351         if (info.title == null) {
3352             info.title = componentName.getClassName();
3353         }
3354         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
3355         info.user = user;
3356         info.contentDescription = mUserManager.getBadgedLabelForUser(
3357                 info.title.toString(), info.user);
3358         return info;
3359     }
3360 
3361     static ArrayList&lt;ItemInfo&gt; filterItemInfos(Collection&lt;ItemInfo&gt; infos,
3362             ItemInfoFilter f) {
3363         HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();
3364         for (ItemInfo i : infos) {
3365             if (i instanceof ShortcutInfo) {
3366                 ShortcutInfo info = (ShortcutInfo) i;
3367                 ComponentName cn = info.getTargetComponent();
3368                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3369                     filtered.add(info);
3370                 }
3371             } else if (i instanceof FolderInfo) {
3372                 FolderInfo info = (FolderInfo) i;
3373                 for (ShortcutInfo s : info.contents) {
3374                     ComponentName cn = s.getTargetComponent();
3375                     if (cn != null &amp;&amp; f.filterItem(info, s, cn)) {
3376                         filtered.add(s);
3377                     }
3378                 }
3379             } else if (i instanceof LauncherAppWidgetInfo) {
3380                 LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) i;
3381                 ComponentName cn = info.providerName;
3382                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3383                     filtered.add(info);
3384                 }
3385             }
3386         }
3387         return new ArrayList&lt;ItemInfo&gt;(filtered);
3388     }
3389 
3390     private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname,
3391             final UserHandleCompat user) {
3392         ItemInfoFilter filter  = new ItemInfoFilter() {
3393             @Override
3394             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
3395                 if (info.user == null) {
3396                     return cn.equals(cname);
3397                 } else {
3398                     return cn.equals(cname) &amp;&amp; info.user.equals(user);
3399                 }
3400             }
3401         };
3402         return filterItemInfos(sBgItemsIdMap.values(), filter);
3403     }
3404 
3405     public static boolean isShortcutInfoUpdateable(ItemInfo i) {
3406         if (i instanceof ShortcutInfo) {
3407             ShortcutInfo info = (ShortcutInfo) i;
3408             // We need to check for ACTION_MAIN otherwise getComponent() might
3409             // return null for some shortcuts (for instance, for shortcuts to
3410             // web pages.)
3411             Intent intent = info.intent;
3412             ComponentName name = intent.getComponent();
3413             if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION &amp;&amp;
3414                     Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3415                 return true;
3416             }
3417             // placeholder shortcuts get special treatment, let them through too.
3418             if (info.isPromise()) {
3419                 return true;
3420             }
3421         }
3422         return false;
3423     }
3424 
3425     /**
3426      * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
3427      */
3428     private ShortcutInfo getShortcutInfo(Cursor c, Context context,
3429             int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
3430             int titleIndex) {
3431 
3432         Bitmap icon = null;
3433         final ShortcutInfo info = new ShortcutInfo();
3434         // Non-app shortcuts are only supported for current user.
3435         info.user = UserHandleCompat.myUserHandle();
3436         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3437 
3438         // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
3439 
3440         info.title = c.getString(titleIndex);
3441 
3442         int iconType = c.getInt(iconTypeIndex);
3443         switch (iconType) {
3444         case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
3445             String packageName = c.getString(iconPackageIndex);
3446             String resourceName = c.getString(iconResourceIndex);
3447             PackageManager packageManager = context.getPackageManager();
3448             info.customIcon = false;
3449             // the resource
3450             try {
3451                 Resources resources = packageManager.getResourcesForApplication(packageName);
3452                 if (resources != null) {
3453                     final int id = resources.getIdentifier(resourceName, null, null);
3454                     icon = Utilities.createIconBitmap(
3455                             mIconCache.getFullResIcon(resources, id), context);
3456                 }
3457             } catch (Exception e) {
3458                 // drop this.  we have other places to look for icons
3459             }
3460             // the db
3461             if (icon == null) {
3462                 icon = getIconFromCursor(c, iconIndex, context);
3463             }
3464             // the fallback icon
3465             if (icon == null) {
3466                 icon = mIconCache.getDefaultIcon(info.user);
3467                 info.usingFallbackIcon = true;
3468             }
3469             break;
3470         case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
3471             icon = getIconFromCursor(c, iconIndex, context);
3472             if (icon == null) {
3473                 icon = mIconCache.getDefaultIcon(info.user);
3474                 info.customIcon = false;
3475                 info.usingFallbackIcon = true;
3476             } else {
3477                 info.customIcon = true;
3478             }
3479             break;
3480         default:
3481             icon = mIconCache.getDefaultIcon(info.user);
3482             info.usingFallbackIcon = true;
3483             info.customIcon = false;
3484             break;
3485         }
3486         info.setIcon(icon);
3487         return info;
3488     }
3489 
3490     Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
3491         @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
3492         final boolean debug = false;
3493         if (debug) {
3494             Log.d(TAG, &quot;getIconFromCursor app=&quot;
3495                     + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
3496         }
3497         byte[] data = c.getBlob(iconIndex);
3498         try {
3499             return Utilities.createIconBitmap(
3500                     BitmapFactory.decodeByteArray(data, 0, data.length), context);
3501         } catch (Exception e) {
3502             return null;
3503         }
3504     }
3505 
3506     ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
3507             int cellX, int cellY, boolean notify) {
3508         final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
3509         if (info == null) {
3510             return null;
3511         }
3512         addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
3513 
3514         return info;
3515     }
3516 
3517     /**
3518      * Attempts to find an AppWidgetProviderInfo that matches the given component.
3519      */
3520     static AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,
3521             ComponentName component) {
3522         List&lt;AppWidgetProviderInfo&gt; widgets =
3523             AppWidgetManager.getInstance(context).getInstalledProviders();
3524         for (AppWidgetProviderInfo info : widgets) {
3525             if (info.provider.equals(component)) {
3526                 return info;
3527             }
3528         }
3529         return null;
3530     }
3531 
3532     ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
3533         Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
3534         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
3535         Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
3536 
3537         if (intent == null) {
3538             // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
3539             Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
3540             return null;
3541         }
3542 
3543         Bitmap icon = null;
3544         boolean customIcon = false;
3545         ShortcutIconResource iconResource = null;
3546 
3547         if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {
3548             icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);
3549             customIcon = true;
3550         } else {
3551             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
3552             if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {
3553                 try {
3554                     iconResource = (ShortcutIconResource) extra;
3555                     final PackageManager packageManager = context.getPackageManager();
3556                     Resources resources = packageManager.getResourcesForApplication(
3557                             iconResource.packageName);
3558                     final int id = resources.getIdentifier(iconResource.resourceName, null, null);
3559                     icon = Utilities.createIconBitmap(
3560                             mIconCache.getFullResIcon(resources, id),
3561                             context);
3562                 } catch (Exception e) {
3563                     Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);
3564                 }
3565             }
3566         }
3567 
3568         final ShortcutInfo info = new ShortcutInfo();
3569 
3570         // Only support intents for current user for now. Intents sent from other
3571         // users wouldn&#x27;t get here without intent forwarding anyway.
3572         info.user = UserHandleCompat.myUserHandle();
3573         if (icon == null) {
3574             if (fallbackIcon != null) {
3575                 icon = fallbackIcon;
3576             } else {
3577                 icon = mIconCache.getDefaultIcon(info.user);
3578                 info.usingFallbackIcon = true;
3579             }
3580         }
3581         info.setIcon(icon);
3582 
3583         info.title = name;
3584         info.contentDescription = mUserManager.getBadgedLabelForUser(
3585                 info.title.toString(), info.user);
3586         info.intent = intent;
3587         info.customIcon = customIcon;
3588         info.iconResource = iconResource;
3589 
3590         return info;
3591     }
3592 
3593     boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
3594             int iconIndex) {
3595         // If apps can&#x27;t be on SD, don&#x27;t even bother.
3596         if (!mAppsCanBeOnRemoveableStorage) {
3597             return false;
3598         }
3599         // If this icon doesn&#x27;t have a custom icon, check to see
3600         // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
3601         // we&#x27;re going to show, store what we are going to show back
3602         // into the DB.  We do this so when we&#x27;re loading, if the
3603         // package manager can&#x27;t find an icon (for example because
3604         // the app is on SD) then we can use that instead.
3605         if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
3606             cache.put(info, c.getBlob(iconIndex));
3607             return true;
3608         }
3609         return false;
3610     }
3611     void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
3612         boolean needSave = false;
3613         try {
3614             if (data != null) {
3615                 Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
3616                 Bitmap loaded = info.getIcon(mIconCache);
3617                 needSave = !saved.sameAs(loaded);
3618             } else {
3619                 needSave = true;
3620             }
3621         } catch (Exception e) {
3622             needSave = true;
3623         }
3624         if (needSave) {
3625             Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
3626             // This is slower than is ideal, but this only happens once
3627             // or when the app is updated with a new icon.
3628             updateItemInDatabase(context, info);
3629         }
3630     }
3631 
3632     /**
3633      * Return an existing FolderInfo object if we have encountered this ID previously,
3634      * or make a new one.
3635      */
3636     private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
3637         // See if a placeholder was created for us already
3638         FolderInfo folderInfo = folders.get(id);
3639         if (folderInfo == null) {
3640             // No placeholder -- create a new instance
3641             folderInfo = new FolderInfo();
3642             folders.put(id, folderInfo);
3643         }
3644         return folderInfo;
3645     }
3646 
3647     public static final Comparator&lt;AppInfo&gt; getAppNameComparator() {
3648         final Collator collator = Collator.getInstance();
3649         return new Comparator&lt;AppInfo&gt;() {
3650             public final int compare(AppInfo a, AppInfo b) {
3651                 if (a.user.equals(b.user)) {
3652                     int result = collator.compare(a.title.toString().trim(),
3653                             b.title.toString().trim());
3654                     if (result == 0) {
3655                         result = a.componentName.compareTo(b.componentName);
3656                     }
3657                     return result;
3658                 } else {
3659                     // TODO Need to figure out rules for sorting
3660                     // profiles, this puts work second.
3661                     return a.user.toString().compareTo(b.user.toString());
3662                 }
3663             }
3664         };
3665     }
3666     public static final Comparator&lt;AppInfo&gt; APP_INSTALL_TIME_COMPARATOR
3667             = new Comparator&lt;AppInfo&gt;() {
3668         public final int compare(AppInfo a, AppInfo b) {
3669             if (a.firstInstallTime &lt; b.firstInstallTime) return 1;
3670             if (a.firstInstallTime &gt; b.firstInstallTime) return -1;
3671             return 0;
3672         }
3673     };
3674     static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
3675         if (info.activityInfo != null) {
3676             return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
3677         } else {
3678             return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
3679         }
3680     }
3681     public static class ShortcutNameComparator implements Comparator&lt;LauncherActivityInfoCompat&gt; {
3682         private Collator mCollator;
3683         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
3684         ShortcutNameComparator(PackageManager pm) {
3685             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
3686             mCollator = Collator.getInstance();
3687         }
3688         ShortcutNameComparator(HashMap&lt;Object, CharSequence&gt; labelCache) {
3689             mLabelCache = labelCache;
3690             mCollator = Collator.getInstance();
3691         }
3692         public final int compare(LauncherActivityInfoCompat a, LauncherActivityInfoCompat b) {
3693             String labelA, labelB;
3694             ComponentName keyA = a.getComponentName();
3695             ComponentName keyB = b.getComponentName();
3696             if (mLabelCache.containsKey(keyA)) {
3697                 labelA = mLabelCache.get(keyA).toString();
3698             } else {
3699                 labelA = a.getLabel().toString().trim();
3700 
3701                 mLabelCache.put(keyA, labelA);
3702             }
3703             if (mLabelCache.containsKey(keyB)) {
3704                 labelB = mLabelCache.get(keyB).toString();
3705             } else {
3706                 labelB = b.getLabel().toString().trim();
3707 
3708                 mLabelCache.put(keyB, labelB);
3709             }
3710             return mCollator.compare(labelA, labelB);
3711         }
3712     };
3713     public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
3714         private final AppWidgetManagerCompat mManager;
3715         private final PackageManager mPackageManager;
3716         private final HashMap&lt;Object, String&gt; mLabelCache;
3717         private final Collator mCollator;
3718 
3719         WidgetAndShortcutNameComparator(Context context) {
3720             mManager = AppWidgetManagerCompat.getInstance(context);
3721             mPackageManager = context.getPackageManager();
3722             mLabelCache = new HashMap&lt;Object, String&gt;();
3723             mCollator = Collator.getInstance();
3724         }
3725         public final int compare(Object a, Object b) {
3726             String labelA, labelB;
3727             if (mLabelCache.containsKey(a)) {
3728                 labelA = mLabelCache.get(a);
3729             } else {
3730                 labelA = (a instanceof AppWidgetProviderInfo)
3731                         ? mManager.loadLabel((AppWidgetProviderInfo) a)
3732                         : ((ResolveInfo) a).loadLabel(mPackageManager).toString().trim();
3733                 mLabelCache.put(a, labelA);
3734             }
3735             if (mLabelCache.containsKey(b)) {
3736                 labelB = mLabelCache.get(b);
3737             } else {
3738                 labelB = (b instanceof AppWidgetProviderInfo)
3739                         ? mManager.loadLabel((AppWidgetProviderInfo) b)
3740                         : ((ResolveInfo) b).loadLabel(mPackageManager).toString().trim();
3741                 mLabelCache.put(b, labelB);
3742             }
3743             return mCollator.compare(labelA, labelB);
3744         }
3745     };
3746 
3747     static boolean isValidProvider(AppWidgetProviderInfo provider) {
3748         return (provider != null) &amp;&amp; (provider.provider != null)
3749                 &amp;&amp; (provider.provider.getPackageName() != null);
3750     }
3751 
3752     public void dumpState() {
3753         Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
3754         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
3755         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
3756         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
3757         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
3758         if (mLoaderTask != null) {
3759             mLoaderTask.dumpState();
3760         } else {
3761             Log.d(TAG, &quot;mLoaderTask=null&quot;);
3762         }
3763     }
3764 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.app.SearchManager;
  19 import android.appwidget.AppWidgetManager;
  20 import android.appwidget.AppWidgetProviderInfo;
  21 import android.content.BroadcastReceiver;
  22 import android.content.ComponentName;
  23 import android.content.ContentProviderClient;
  24 import android.content.ContentProviderOperation;
  25 import android.content.ContentResolver;
  26 import android.content.ContentValues;
  27 import android.content.Context;
  28 import android.content.Intent.ShortcutIconResource;
  29 import android.content.Intent;
  30 import android.content.IntentFilter;
  31 import android.content.SharedPreferences;
  32 import android.content.pm.PackageManager;
  33 import android.content.pm.ProviderInfo;
  34 import android.content.pm.ResolveInfo;
  35 import android.content.res.Configuration;
  36 import android.content.res.Resources;
  37 import android.database.Cursor;
  38 import android.graphics.Bitmap;
  39 import android.graphics.BitmapFactory;
  40 import android.net.Uri;
  41 import android.os.Environment;
  42 import android.os.Handler;
  43 import android.os.HandlerThread;
  44 import android.os.Parcelable;
  45 import android.os.Process;
  46 import android.os.RemoteException;
  47 import android.os.SystemClock;
  48 import android.provider.BaseColumns;
  49 import android.text.TextUtils;
  50 import android.util.Log;
  51 import android.util.Pair;
  52 import com.android.launcher3.compat.AppWidgetManagerCompat;
  53 import com.android.launcher3.compat.LauncherActivityInfoCompat;
  54 import com.android.launcher3.compat.LauncherAppsCompat;
  55 import com.android.launcher3.compat.PackageInstallerCompat.PackageInstallInfo;
  56 import com.android.launcher3.compat.PackageInstallerCompat;
  57 import com.android.launcher3.compat.UserHandleCompat;
  58 import com.android.launcher3.compat.UserManagerCompat;
  59 import java.lang.ref.WeakReference;
  60 import java.net.URISyntaxException;
  61 import java.security.InvalidParameterException;
  62 import java.text.Collator;
  63 import java.util.ArrayList;
  64 import java.util.Arrays;
  65 import java.util.Collection;
  66 import java.util.Collections;
  67 import java.util.Comparator;
  68 import java.util.HashMap;
  69 import java.util.HashSet;
  70 import java.util.Iterator;
  71 import java.util.List;
  72 import java.util.Map.Entry;
  73 import java.util.Set;
  74 import java.util.TreeMap;
  75 import java.util.concurrent.atomic.AtomicBoolean;
  76 
  77 
  78 /**
  79  * Maintains in-memory state of the Launcher. It is expected that there should be only one
  80  * LauncherModel object held in a static. Also provide APIs for updating the database state
  81  * for the Launcher.
  82  */
<abbr title="  83 public class LauncherModel extends BroadcastReceiver implements LauncherAppsCompat.OnAppsChangedCallbackCompat {">  83 public class LauncherModel extends BroadcastReceiver implements LauncherAppsCompat.OnAppsChangedCallbackC</abbr>
  84     static final boolean DEBUG_LOADERS = false;
  85 
  86     private static final boolean DEBUG_RECEIVER = false;
  87 
  88     private static final boolean REMOVE_UNRESTORED_ICONS = true;
  89 
  90     static final String TAG = &quot;Launcher.Model&quot;;
  91 
  92     // true = use a &quot;More Apps&quot; folder for non-workspace apps on upgrade
  93     // false = strew non-workspace apps across the workspace on upgrade
  94     // true = use a &quot;More Apps&quot; folder for non-workspace apps on upgrade
  95     // false = strew non-workspace apps across the workspace on upgrade
  96     public static final boolean UPGRADE_USE_MORE_APPS_FOLDER = false;
  97 
  98     public static final int LOADER_FLAG_NONE = 0;
  99 
 100     public static final int LOADER_FLAG_CLEAR_WORKSPACE = 1 &lt;&lt; 0;
 101 
 102     public static final int LOADER_FLAG_MIGRATE_SHORTCUTS = 1 &lt;&lt; 1;
 103 
 104     // batch size for the workspace icons
 105     private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
 106 
 107     private static final long INVALID_SCREEN_ID = -1L;
 108 
 109     private final boolean mAppsCanBeOnRemoveableStorage;
 110 
 111     private final boolean mOldContentProviderExists;
 112 
 113     private final LauncherAppState mApp;
 114 
 115     private final Object mLock = new Object();
 116 
 117     private DeferredHandler mHandler = new DeferredHandler();
 118 
 119     private LoaderTask mLoaderTask;
 120 
 121     private boolean mIsLoaderTaskRunning;
 122 
 123     private volatile boolean mFlushingWorkerThread;
 124 
 125     // Specific runnable types that are run on the main thread deferred handler, this allows us to
 126     // clear all queued binding runnables when the Launcher activity is destroyed.
 127     private static final int MAIN_THREAD_NORMAL_RUNNABLE = 0;
 128 
 129     private static final int MAIN_THREAD_BINDING_RUNNABLE = 1;
 130 
 131     private static final String MIGRATE_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
 132 
 133     private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
 134 
 135     static {
 136         sWorkerThread.start();
 137     }
 138 
 139     private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
 140 
 141     // We start off with everything not loaded.  After that, we assume that
 142     // our monitoring of the package manager provides all updates and we never
 143     // need to do a requery.  These are only ever touched from the loader thread.
 144     private boolean mWorkspaceLoaded;
 145 
 146     private boolean mAllAppsLoaded;
 147 
 148     // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
 149     // pages as this delays the rotation process.  Instead, we wait for a callback from the first
 150     // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 151     // a normal load, we also clear this set of Runnables.
 152     static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 153 
 154     private WeakReference&lt;Callbacks&gt; mCallbacks;
 155 
 156     // &lt; only access in worker thread &gt;
 157     // &lt; only access in worker thread &gt;
 158     AllAppsList mBgAllAppsList;
 159 
 160     // The lock that must be acquired before referencing any static bg data structures.  Unlike
 161     // other locks, this one can generally be held long-term because we never expect any of these
 162     // static data structures to be referenced outside of the worker thread except on the first
 163     // load after configuration change.
 164     static final Object sBgLock = new Object();
 165 
 166     // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 167     // LauncherModel to their ids
 168     static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
 169 
 170     // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 171     //       created by LauncherModel that are directly on the home screen (however, no widgets or
 172     //       shortcuts within folders).
 173     static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 174 
 175     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 176     static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets = new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 177 
 178     // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 179     static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 180 
 181     // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 182     static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 183 
 184     // sBgWorkspaceScreens is the ordered set of workspace screens.
 185     // sBgWorkspaceScreens is the ordered set of workspace screens.
 186     static final ArrayList&lt;Long&gt; sBgWorkspaceScreens = new ArrayList&lt;Long&gt;();
 187 
 188     // sPendingPackages is a set of packages which could be on sdcard and are not available yet
<abbr title=" 189     static final HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; sPendingPackages = new HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt;();"> 189     static final HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; sPendingPackages = new HashMap&lt;UserHandleComp</abbr>
 190 
 191     // &lt;/ only access in worker thread &gt;
 192     // &lt;/ only access in worker thread &gt;
 193 
 194     private IconCache mIconCache;
 195 
 196     protected int mPreviousConfigMcc;
 197 
 198     private final LauncherAppsCompat mLauncherApps;
 199 
 200     private final UserManagerCompat mUserManager;
 201 
 202     public interface Callbacks {
 203         public boolean setLoadOnResume();
 204 
 205         public int getCurrentWorkspaceScreen();
 206 
 207         public void startBinding();
 208 
<abbr title=" 209         public abstract void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end, boolean forceAnimateIcons);"> 209         public abstract void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end, boolean forceAn</abbr>
 210 
 211         public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 212 
 213         public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 214 
 215         public abstract void bindFolders(HashMap&lt;Long, FolderInfo&gt; folders);
 216 
 217         public void finishBindingItems(boolean upgradePath);
 218 
 219         public abstract void bindAppWidget(LauncherAppWidgetInfo info);
 220 
 221         public abstract void bindAllApplications(ArrayList&lt;AppInfo&gt; apps);
 222 
<abbr title=" 223         public abstract void bindAppsAdded(ArrayList&lt;Long&gt; newScreens, ArrayList&lt;ItemInfo&gt; addNotAnimated, ArrayList&lt;ItemInfo&gt; addAnimated, ArrayList&lt;AppInfo&gt; addedApps);"> 223         public abstract void bindAppsAdded(ArrayList&lt;Long&gt; newScreens, ArrayList&lt;ItemInfo&gt; addNotAnimated</abbr>
 224 
 225         public abstract void bindAppsUpdated(ArrayList&lt;AppInfo&gt; apps);
 226 
 227         public void bindAppsRestored(ArrayList&lt;AppInfo&gt; apps);
 228 
 229         public void updatePackageState(ArrayList&lt;PackageInstallInfo&gt; installInfo);
 230 
 231         public void updatePackageBadge(String packageName);
 232 
<abbr title=" 233         public abstract void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames, ArrayList&lt;AppInfo&gt; appInfos, UserHandleCompat user);"> 233         public abstract void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames, ArrayList&lt;AppInfo&gt; app</abbr>
 234 
 235         public void bindPackagesUpdated(ArrayList&lt;Object&gt; widgetsAndShortcuts);
 236 
 237         public void bindSearchablesChanged();
 238 
 239         public boolean isAllAppsButtonRank(int rank);
 240 
 241         public void onPageBoundSynchronously(int page);
 242 
 243         public void dumpLogsToLocalData();
 244     }
 245 
 246     public interface ItemInfoFilter {
 247         public abstract boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn);
 248     }
 249 
 250     LauncherModel(LauncherAppState app, IconCache iconCache, AppFilter appFilter) {
 251         Context context = app.getContext();
 252         mAppsCanBeOnRemoveableStorage = Environment.isExternalStorageRemovable();
 253         String oldProvider = context.getString(R.string.old_launcher_provider_uri);
 254         // This may be the same as MIGRATE_AUTHORITY, or it may be replaced by a different
 255         // resource string.
 256         String redirectAuthority = Uri.parse(oldProvider).getAuthority();
<abbr title=" 257         ProviderInfo providerInfo = context.getPackageManager().resolveContentProvider(MIGRATE_AUTHORITY, 0);"> 257         ProviderInfo providerInfo = context.getPackageManager().resolveContentProvider(MIGRATE_AUTHORITY,</abbr>
<abbr title=" 258         ProviderInfo redirectProvider = context.getPackageManager().resolveContentProvider(redirectAuthority, 0);"> 258         ProviderInfo redirectProvider = context.getPackageManager().resolveContentProvider(redirectAuthor</abbr>
 259         Log.d(TAG, &quot;Old launcher provider: &quot; + oldProvider);
 260         mOldContentProviderExists = (providerInfo != null) &amp;&amp; (redirectProvider != null);
 261         if (mOldContentProviderExists) {
 262             Log.d(TAG, &quot;Old launcher provider exists.&quot;);
 263         } else {
 264             Log.d(TAG, &quot;Old launcher provider does not exist.&quot;);
 265         }
 266         mApp = app;
 267         mBgAllAppsList = new AllAppsList(iconCache, appFilter);
 268         mIconCache = iconCache;
 269         final Resources res = context.getResources();
 270         Configuration config = res.getConfiguration();
 271         mPreviousConfigMcc = config.mcc;
 272         mLauncherApps = LauncherAppsCompat.getInstance(context);
 273         mUserManager = UserManagerCompat.getInstance(context);
 274     }
 275 
 276     /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 277      * posted on the main thread handler. */
 278     private void runOnMainThread(Runnable r) {
 279         runOnMainThread(r, 0);
 280     }
 281 
 282     private void runOnMainThread(Runnable r, int type) {
 283         if (sWorkerThread.getThreadId() == Process.myTid()) {
 284             // If we are on the worker thread, post onto the main handler
 285             mHandler.post(r);
 286         } else {
 287             r.run();
 288         }
 289     }
 290 
 291     /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 292      * posted on the worker thread handler. */
 293     private static void runOnWorkerThread(Runnable r) {
 294         if (sWorkerThread.getThreadId() == Process.myTid()) {
 295             r.run();
 296         } else {
 297             // If we are not on the worker thread, then post to the worker handler
 298             sWorker.post(r);
 299         }
 300     }
 301 
 302     boolean canMigrateFromOldLauncherDb(Launcher launcher) {
 303         return mOldContentProviderExists &amp;&amp; (!launcher.isLauncherPreinstalled());
 304     }
 305 
 306     static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;ItemInfo&gt; items, int[] xy, long screen) {
 307         LauncherAppState app = LauncherAppState.getInstance();
 308         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 309         final int xCount = ((int) (grid.numColumns));
 310         final int yCount = ((int) (grid.numRows));
 311         boolean[][] occupied = new boolean[xCount][yCount];
 312         int cellX;
 313         int cellY;
 314         int spanX;
 315         int spanY;
 316         for (int i = 0; i &lt; items.size(); ++i) {
 317             final ItemInfo item = items.get(i);
 318             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 319                 if (item.screenId == screen) {
 320                     cellX = item.cellX;
 321                     cellY = item.cellY;
 322                     spanX = item.spanX;
 323                     spanY = item.spanY;
 324                     for (int x = cellX; ((0 &lt;= x) &amp;&amp; (x &lt; (cellX + spanX))) &amp;&amp; (x &lt; xCount); x++) {
 325                         for (int y = cellY; ((0 &lt;= y) &amp;&amp; (y &lt; (cellY + spanY))) &amp;&amp; (y &lt; yCount); y++) {
 326                             occupied[x][y] = true;
 327                         }
 328                     }
 329                 }
 330             }
 331         }
 332         return CellLayout.findVacantCell(xy, 1, 1, xCount, yCount, occupied);
 333     }
 334 
<abbr title=" 335     static Pair&lt;Long, int[]&gt; findNextAvailableIconSpace(Context context, String name, Intent launchIntent, int firstScreenIndex, ArrayList&lt;Long&gt; workspaceScreens) {"> 335     static Pair&lt;Long, int[]&gt; findNextAvailableIconSpace(Context context, String name, Intent launchIntent</abbr>
 336         // Lock on the app so that we don&#x27;t try and get the items while apps are being added
 337         LauncherAppState app = LauncherAppState.getInstance();
 338         LauncherModel model = app.getModel();
 339         boolean found = false;
 340         synchronized(app) {
 341             if (sWorkerThread.getThreadId() != Process.myTid()) {
 342                 // Flush the LauncherModel worker thread, so that if we just did another
 343                 // processInstallShortcut, we give it time for its shortcut to get added to the
 344                 // database (getItemsInLocalCoordinates reads the database)
 345                 model.flushWorkerThread();
 346             }
 347             final ArrayList&lt;ItemInfo&gt; items = LauncherModel.getItemsInLocalCoordinates(context);
 348             // Try adding to the workspace screens incrementally, starting at the default or center
 349             // screen and alternating between +1, -1, +2, -2, etc. (using ~ ceil(i/2f)*(-1)^(i-1))
 350             firstScreenIndex = Math.min(firstScreenIndex, workspaceScreens.size());
 351             int count = workspaceScreens.size();
 352             for (int screen = firstScreenIndex; (screen &lt; count) &amp;&amp; (!found); screen++) {
 353                 int[] tmpCoordinates = new int[2];
<abbr title=" 354                 if (findNextAvailableIconSpaceInScreen(items, tmpCoordinates, workspaceScreens.get(screen))) {"> 354                 if (findNextAvailableIconSpaceInScreen(items, tmpCoordinates, workspaceScreens.get(screen</abbr>
 355                     // Update the Launcher db
 356                     return new Pair&lt;Long, int[]&gt;(workspaceScreens.get(screen), tmpCoordinates);
 357                 }
 358             }
 359         }
 360         return null;
 361     }
 362 
 363     public void setPackageState(final ArrayList&lt;PackageInstallInfo&gt; installInfo) {
 364         // Process the updated package state
 365         Runnable r = new Runnable() {
 366             public void run() {
 367                 Callbacks callbacks = (mCallbacks != null) ? mCallbacks.get() : null;
 368                 if (callbacks != null) {
 369                     callbacks.updatePackageState(installInfo);
 370                 }
 371             }
 372         };
 373         mHandler.post(r);
 374     }
 375 
 376     public void updatePackageBadge(final String packageName) {
 377         // Process the updated package badge
 378         Runnable r = new Runnable() {
 379             public void run() {
 380                 Callbacks callbacks = (mCallbacks != null) ? mCallbacks.get() : null;
 381                 if (callbacks != null) {
 382                     callbacks.updatePackageBadge(packageName);
 383                 }
 384             }
 385         };
 386         mHandler.post(r);
 387     }
 388 
 389     public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {
 390         final Callbacks callbacks = (mCallbacks != null) ? mCallbacks.get() : null;
 391         if (allAppsApps == null) {
 392             throw new RuntimeException(&quot;allAppsApps must not be null&quot;);
 393         }
 394         if (allAppsApps.isEmpty()) {
 395             return;
 396         }
 397         final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();
 398         Iterator&lt;AppInfo&gt; iter = allAppsApps.iterator();
 399         while (iter.hasNext()) {
 400             ItemInfo a = iter.next();
 401             if (LauncherModel.appWasPromise(ctx, a.getIntent(), a.user)) {
 402                 restoredAppsFinal.add(((AppInfo) (a)));
 403             }
 404         }
 405         // Process the newly added applications and add them to the database first
 406         Runnable r = new Runnable() {
 407             public void run() {
 408                 runOnMainThread(new Runnable() {
 409                     public void run() {
 410                         Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
 411                         if ((callbacks == cb) &amp;&amp; (cb != null)) {
 412                             if (!restoredAppsFinal.isEmpty()) {
 413                                 for (AppInfo info : restoredAppsFinal) {
 414                                     final Intent intent = info.getIntent();
 415                                     if (intent != null) {
 416                                         mIconCache.deletePreloadedIcon(intent.getComponent(), info.user);
 417                                     }
 418                                 }
 419                                 callbacks.bindAppsUpdated(restoredAppsFinal);
 420                             }
 421                             callbacks.bindAppsAdded(null, null, null, allAppsApps);
 422                         }
 423                     }
 424                 });
 425             }
 426         };
 427         runOnWorkerThread(r);
 428     }
 429 
<abbr title=" 430     public void addAndBindAddedWorkspaceApps(final Context context, final ArrayList&lt;ItemInfo&gt; workspaceApps) {"> 430     public void addAndBindAddedWorkspaceApps(final Context context, final ArrayList&lt;ItemInfo&gt; workspaceAp</abbr>
 431         final Callbacks callbacks = (mCallbacks != null) ? mCallbacks.get() : null;
 432         if (workspaceApps == null) {
 433             throw new RuntimeException(&quot;workspaceApps and allAppsApps must not be null&quot;);
 434         }
 435         if (workspaceApps.isEmpty()) {
 436             return;
 437         }
 438         // Process the newly added applications and add them to the database first
 439         Runnable r = new Runnable() {
 440             public void run() {
 441                 final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();
 442                 final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
 443                 final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();
 444                 // Get the list of workspace screens.  We need to append to this list and
 445                 // can not use sBgWorkspaceScreens because loadWorkspace() may not have been
 446                 // called.
 447                 ArrayList&lt;Long&gt; workspaceScreens = new ArrayList&lt;Long&gt;();
 448                 TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(context);
 449                 for (Integer i : orderedScreens.keySet()) {
 450                     long screenId = orderedScreens.get(i);
 451                     workspaceScreens.add(screenId);
 452                 }
 453                 synchronized(sBgLock) {
 454                     Iterator&lt;ItemInfo&gt; iter = workspaceApps.iterator();
 455                     while (iter.hasNext()) {
 456                         ItemInfo a = iter.next();
 457                         final String name = a.title.toString();
 458                         final Intent launchIntent = a.getIntent();
 459                         // Short-circuit this logic if the icon exists somewhere on the workspace
 460                         if (LauncherModel.shortcutExists(context, name, launchIntent)) {
 461                             // Only InstallShortcutReceiver sends us shortcutInfos, ignore them
<abbr title=" 462                             if ((a instanceof AppInfo) &amp;&amp; LauncherModel.appWasPromise(context, launchIntent, a.user)) {"> 462                             if ((a instanceof AppInfo) &amp;&amp; LauncherModel.appWasPromise(context, launchInte</abbr>
 463                                 restoredAppsFinal.add(((AppInfo) (a)));
 464                             }
 465                             continue;
 466                         }
 467                         // Add this icon to the db, creating a new page if necessary.  If there
 468                         // is only the empty page then we just add items to the first page.
 469                         // Otherwise, we add them to the next pages.
 470                         int startSearchPageIndex = (workspaceScreens.isEmpty()) ? 0 : 1;
<abbr title=" 471                         Pair&lt;Long, int[]&gt; coords = LauncherModel.findNextAvailableIconSpace(context, name, launchIntent, startSearchPageIndex, workspaceScreens);"> 471                         Pair&lt;Long, int[]&gt; coords = LauncherModel.findNextAvailableIconSpace(context, name</abbr>
 472                         if (coords == null) {
 473                             LauncherProvider lp = LauncherAppState.getLauncherProvider();
 474                             // If we can&#x27;t find a valid position, then just add a new screen.
 475                             // This takes time so we need to re-queue the add until the new
 476                             // page is added.  Create as many screens as necessary to satisfy
 477                             // the startSearchPageIndex.
<abbr title=" 478                             int numPagesToAdd = Math.max(1, (startSearchPageIndex + 1) - workspaceScreens.size());"> 478                             int numPagesToAdd = Math.max(1, (startSearchPageIndex + 1) - workspaceScreens</abbr>
 479                             while (numPagesToAdd &gt; 0) {
 480                                 long screenId = lp.generateNewScreenId();
 481                                 // Save the screen id for binding in the workspace
 482                                 workspaceScreens.add(screenId);
 483                                 addedWorkspaceScreensFinal.add(screenId);
 484                                 numPagesToAdd--;
 485                             }
 486                             // Find the coordinate again
<abbr title=" 487                             coords = LauncherModel.findNextAvailableIconSpace(context, name, launchIntent, startSearchPageIndex, workspaceScreens);"> 487                             coords = LauncherModel.findNextAvailableIconSpace(context, name, launchIntent</abbr>
 488                         }
 489                         if (coords == null) {
 490                             throw new RuntimeException(&quot;Coordinates should not be null&quot;);
 491                         }
 492                         ShortcutInfo shortcutInfo;
 493                         if (a instanceof ShortcutInfo) {
 494                             shortcutInfo = ((ShortcutInfo) (a));
 495                         } else if (a instanceof AppInfo) {
 496                             shortcutInfo = ((AppInfo) (a)).makeShortcut();
 497                         } else {
 498                             throw new RuntimeException(&quot;Unexpected info type&quot;);
 499                         }
 500                         // Add the shortcut to the db
<abbr title=" 501                         addItemToDatabase(context, shortcutInfo, LauncherSettings.Favorites.CONTAINER_DESKTOP, coords.first, coords.second[0], coords.second[1], false);"> 501                         addItemToDatabase(context, shortcutInfo, LauncherSettings.Favorites.CONTAINER_DES</abbr>
 502                         // Save the ShortcutInfo for binding in the workspace
 503                         addedShortcutsFinal.add(shortcutInfo);
 504                     }
 505                 }
 506                 // Update the workspace screens
 507                 updateWorkspaceScreenOrder(context, workspaceScreens);
 508                 if (!addedShortcutsFinal.isEmpty()) {
 509                     runOnMainThread(new Runnable() {
 510                         public void run() {
 511                             Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
 512                             if ((callbacks == cb) &amp;&amp; (cb != null)) {
 513                                 final ArrayList&lt;ItemInfo&gt; addAnimated = new ArrayList&lt;ItemInfo&gt;();
 514                                 final ArrayList&lt;ItemInfo&gt; addNotAnimated = new ArrayList&lt;ItemInfo&gt;();
 515                                 if (!addedShortcutsFinal.isEmpty()) {
<abbr title=" 516                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 1);"> 516                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - </abbr>
 517                                     long lastScreenId = info.screenId;
 518                                     for (ItemInfo i : addedShortcutsFinal) {
 519                                         if (i.screenId == lastScreenId) {
 520                                             addAnimated.add(i);
 521                                         } else {
 522                                             addNotAnimated.add(i);
 523                                         }
 524                                     }
 525                                 }
<abbr title=" 526                                 callbacks.bindAppsAdded(addedWorkspaceScreensFinal, addNotAnimated, addAnimated, null);"> 526                                 callbacks.bindAppsAdded(addedWorkspaceScreensFinal, addNotAnimated, addAn</abbr>
 527                                 if (!restoredAppsFinal.isEmpty()) {
 528                                     callbacks.bindAppsUpdated(restoredAppsFinal);
 529                                 }
 530                             }
 531                         }
 532                     });
 533                 }
 534             }
 535         };
 536         runOnWorkerThread(r);
 537     }
 538 
 539     public void unbindItemInfosAndClearQueuedBindRunnables() {
 540         if (sWorkerThread.getThreadId() == Process.myTid()) {
<abbr title=" 541             throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; + &quot;main thread&quot;);"> 541             throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; + &quot;mai</abbr>
 542         }
 543         // Clear any deferred bind runnables
 544         synchronized(mDeferredBindRunnables) {
 545             mDeferredBindRunnables.clear();
 546         }
 547         // Remove any queued bind runnables
 548         mHandler.cancelAllRunnablesOfType(MAIN_THREAD_BINDING_RUNNABLE);
 549         // Unbind all the workspace items
 550         unbindWorkspaceItemsOnMainThread();
 551     }
 552 
 553     /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 554     void unbindWorkspaceItemsOnMainThread() {
 555         // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 556         // by making a copy of workspace items first.
 557         final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 558         final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 559         synchronized(sBgLock) {
 560             tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 561             tmpAppWidgets.addAll(sBgAppWidgets);
 562         }
 563         Runnable r = new Runnable() {
 564             @Override
 565             public void run() {
 566                 for (ItemInfo item : tmpWorkspaceItems) {
 567                     item.unbind();
 568                 }
 569                 for (ItemInfo item : tmpAppWidgets) {
 570                     item.unbind();
 571                 }
 572             }
 573         };
 574         runOnMainThread(r);
 575     }
 576 
 577     /**
 578      * Adds an item to the DB if it was not created previously, or move it to a new
 579      * &lt;container, screen, cellX, cellY&gt;
 580      */
<abbr title=" 581     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container, long screenId, int cellX, int cellY) {"> 581     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container, long screenId, in</abbr>
 582         if (item.container == ItemInfo.NO_ID) {
 583             // From all apps
 584             addItemToDatabase(context, item, container, screenId, cellX, cellY, false);
 585         } else {
 586             // From somewhere else
 587             moveItemInDatabase(context, item, container, screenId, cellX, cellY);
 588         }
 589     }
 590 
<abbr title=" 591     static void checkItemInfoLocked(final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {"> 591     static void checkItemInfoLocked(final long itemId, final ItemInfo item, StackTraceElement[] stackTrac</abbr>
 592         ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 593         if ((modelItem != null) &amp;&amp; (item != modelItem)) {
 594             // check all the data is consistent
 595             if ((modelItem instanceof ShortcutInfo) &amp;&amp; (item instanceof ShortcutInfo)) {
 596                 ShortcutInfo modelShortcut = ((ShortcutInfo) (modelItem));
 597                 ShortcutInfo shortcut = ((ShortcutInfo) (item));
<abbr title=" 598                 if ((((((((((modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp; modelShortcut.intent.filterEquals(shortcut.intent)) &amp;&amp; (modelShortcut.id == shortcut.id)) &amp;&amp; (modelShortcut.itemType == shortcut.itemType)) &amp;&amp; (modelShortcut.container == shortcut.container)) &amp;&amp; (modelShortcut.screenId == shortcut.screenId)) &amp;&amp; (modelShortcut.cellX == shortcut.cellX)) &amp;&amp; (modelShortcut.cellY == shortcut.cellY)) &amp;&amp; (modelShortcut.spanX == shortcut.spanX)) &amp;&amp; (modelShortcut.spanY == shortcut.spanY)) &amp;&amp; (((modelShortcut.dropPos == null) &amp;&amp; (shortcut.dropPos == null)) || ((((modelShortcut.dropPos != null) &amp;&amp; (shortcut.dropPos != null)) &amp;&amp; (modelShortcut.dropPos[0] == shortcut.dropPos[0])) &amp;&amp; (modelShortcut.dropPos[1] == shortcut.dropPos[1])))) {"> 598                 if ((((((((((modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp; modelSho</abbr>
 599                     // For all intents and purposes, this is the same object
 600                     return;
 601                 }
 602             }
 603             // the modelItem needs to match up perfectly with item if our model is
 604             // to be consistent with the database-- for now, just require
 605             // modelItem == item or the equality check above
<abbr title=" 606             String msg = (((&quot;item: &quot; + (item != null ? item.toString() : &quot;null&quot;)) + &quot;modelItem: &quot;) + (modelItem != null ? modelItem.toString() : &quot;null&quot;)) + &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;"> 606             String msg = (((&quot;item: &quot; + (item != null ? item.toString() : &quot;null&quot;)) + &quot;modelItem: &quot;) + (mod</abbr>
 607             RuntimeException e = new RuntimeException(msg);
 608             if (stackTrace != null) {
 609                 e.setStackTrace(stackTrace);
 610             }
 611             throw e;
 612         }
 613     }
 614 
 615     static void checkItemInfo(final ItemInfo item) {
 616         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 617         final long itemId = item.id;
 618         Runnable r = new Runnable() {
 619             public void run() {
 620                 synchronized(sBgLock) {
 621                     checkItemInfoLocked(itemId, item, stackTrace);
 622                 }
 623             }
 624         };
 625         runOnWorkerThread(r);
 626     }
 627 
<abbr title=" 628     static void updateItemInDatabaseHelper(Context context, final ContentValues values, final ItemInfo item, final String callingFunction) {"> 628     static void updateItemInDatabaseHelper(Context context, final ContentValues values, final ItemInfo it</abbr>
 629         final long itemId = item.id;
 630         final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 631         final ContentResolver cr = context.getContentResolver();
 632         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 633         Runnable r = new Runnable() {
 634             public void run() {
 635                 cr.update(uri, values, null, null);
 636                 updateItemArrays(item, itemId, stackTrace);
 637             }
 638         };
 639         runOnWorkerThread(r);
 640     }
 641 
<abbr title=" 642     static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList, final ArrayList&lt;ItemInfo&gt; items, final String callingFunction) {"> 642     static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList, f</abbr>
 643         final ContentResolver cr = context.getContentResolver();
 644         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 645         Runnable r = new Runnable() {
 646             public void run() {
 647                 ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
 648                 int count = items.size();
 649                 for (int i = 0; i &lt; count; i++) {
 650                     ItemInfo item = items.get(i);
 651                     final long itemId = item.id;
 652                     final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 653                     ContentValues values = valuesList.get(i);
 654                     ops.add(ContentProviderOperation.newUpdate(uri).withValues(values).build());
 655                     updateItemArrays(item, itemId, stackTrace);
 656                 }
 657                 try {
 658                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
 659                 } catch (java.lang.Exception e) {
 660                     e.printStackTrace();
 661                 }
 662             }
 663         };
 664         runOnWorkerThread(r);
 665     }
 666 
 667     static void updateItemArrays(ItemInfo item, long itemId, StackTraceElement[] stackTrace) {
 668         // Lock on mBgLock *after* the db operation
 669         synchronized(sBgLock) {
 670             checkItemInfoLocked(itemId, item, stackTrace);
<abbr title=" 671             if ((item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {"> 671             if ((item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (item.container != La</abbr>
 672                 // Item is in a folder, make sure this folder exists
 673                 if (!sBgFolders.containsKey(item.container)) {
 674                     // An items container is being set to a that of an item which is not in
 675                     // the list of Folders.
<abbr title=" 676                     String msg = (((&quot;item: &quot; + item) + &quot; container being set to: &quot;) + item.container) + &quot;, not in the list of folders&quot;;"> 676                     String msg = (((&quot;item: &quot; + item) + &quot; container being set to: &quot;) + item.container) + &quot;</abbr>
 677                     Log.e(TAG, msg);
 678                 }
 679             }
 680             // Items are added/removed from the corresponding FolderInfo elsewhere, such
 681             // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 682             // that are on the desktop, as appropriate
 683             ItemInfo modelItem = sBgItemsIdMap.get(itemId);
<abbr title=" 684             if ((modelItem != null) &amp;&amp; ((modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) || (modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT))) {"> 684             if ((modelItem != null) &amp;&amp; ((modelItem.container == LauncherSettings.Favorites.CONTAINER_DESK</abbr>
 685                 switch (modelItem.itemType) {
 686                     case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION :
 687                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT :
 688                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER :
 689                         if (!sBgWorkspaceItems.contains(modelItem)) {
 690                             sBgWorkspaceItems.add(modelItem);
 691                         }
 692                         break;
 693                     default :
 694                         break;
 695                 }
 696             } else {
 697                 sBgWorkspaceItems.remove(modelItem);
 698             }
 699         }
 700     }
 701 
 702     public void flushWorkerThread() {
 703         mFlushingWorkerThread = true;
 704         Runnable waiter = new Runnable() {
 705                 public void run() {
 706                     synchronized (this) {
 707                         notifyAll();
 708                         mFlushingWorkerThread = false;
 709                     }
 710                 }
 711             };
 712 
 713         synchronized(waiter) {
 714             runOnWorkerThread(waiter);
 715             if (mLoaderTask != null) {
 716                 synchronized(mLoaderTask) {
 717                     mLoaderTask.notify();
 718                 }
 719             }
 720             boolean success = false;
 721             while (!success) {
 722                 try {
 723                     waiter.wait();
 724                     success = true;
 725                 } catch (InterruptedException e) {
 726                 }
 727             }
 728         }
 729     }
 730 
 731     /**
 732      * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 733      */
<abbr title=" 734     static void moveItemInDatabase(Context context, final ItemInfo item, final long container, final long screenId, final int cellX, final int cellY) {"> 734     static void moveItemInDatabase(Context context, final ItemInfo item, final long container, final long</abbr>
 735         item.container = container;
 736         item.cellX = cellX;
 737         item.cellY = cellY;
 738         // We store hotseat items in canonical form which is this orientation invariant position
 739         // in the hotseat
<abbr title=" 740         if (((context instanceof Launcher) &amp;&amp; (screenId &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {"> 740         if (((context instanceof Launcher) &amp;&amp; (screenId &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorites</abbr>
 741             item.screenId = ((Launcher) (context)).getHotseat().getOrderInHotseat(cellX, cellY);
 742         } else {
 743             item.screenId = screenId;
 744         }
 745         final ContentValues values = new ContentValues();
 746         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 747         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 748         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 749         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 750         updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 751     }
 752 
 753     /**
 754      * Move items in the DB to a new &lt;container, screen, cellX, cellY&gt;. We assume that the
 755      * cellX, cellY have already been updated on the ItemInfos.
 756      */
<abbr title=" 757     static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items, final long container, final int screen) {"> 757     static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items, final long containe</abbr>
 758         ArrayList&lt;ContentValues&gt; contentValues = new ArrayList&lt;ContentValues&gt;();
 759         int count = items.size();
 760         for (int i = 0; i &lt; count; i++) {
 761             ItemInfo item = items.get(i);
 762             item.container = container;
 763             // We store hotseat items in canonical form which is this orientation invariant position
 764             // in the hotseat
<abbr title=" 765             if (((context instanceof Launcher) &amp;&amp; (screen &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {"> 765             if (((context instanceof Launcher) &amp;&amp; (screen &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorit</abbr>
<abbr title=" 766                 item.screenId = ((Launcher) (context)).getHotseat().getOrderInHotseat(item.cellX, item.cellY);"> 766                 item.screenId = ((Launcher) (context)).getHotseat().getOrderInHotseat(item.cellX, item.ce</abbr>
 767             } else {
 768                 item.screenId = screen;
 769             }
 770             final ContentValues values = new ContentValues();
 771             values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 772             values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 773             values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 774             values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 775             contentValues.add(values);
 776         }
 777         updateItemsInDatabaseHelper(context, contentValues, items, &quot;moveItemInDatabase&quot;);
 778     }
 779 
 780     /**
 781      * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 782      */
<abbr title=" 783     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container, final long screenId, final int cellX, final int cellY, final int spanX, final int spanY) {"> 783     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container, final lo</abbr>
 784         item.container = container;
 785         item.cellX = cellX;
 786         item.cellY = cellY;
 787         item.spanX = spanX;
 788         item.spanY = spanY;
 789         // We store hotseat items in canonical form which is this orientation invariant position
 790         // in the hotseat
<abbr title=" 791         if (((context instanceof Launcher) &amp;&amp; (screenId &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {"> 791         if (((context instanceof Launcher) &amp;&amp; (screenId &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorites</abbr>
 792             item.screenId = ((Launcher) (context)).getHotseat().getOrderInHotseat(cellX, cellY);
 793         } else {
 794             item.screenId = screenId;
 795         }
 796         final ContentValues values = new ContentValues();
 797         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 798         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 799         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 800         values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 801         values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 802         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 803         updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 804     }
 805 
 806     /**
 807      * Update an item to the database in a specified container.
 808      */
 809     static void updateItemInDatabase(Context context, final ItemInfo item) {
 810         final ContentValues values = new ContentValues();
 811         item.onAddToDatabase(context, values);
 812         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 813         updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 814     }
 815 
 816     /**
 817      * Returns true if the shortcuts already exists in the database.
 818      * we identify a shortcut by its title and intent.
 819      */
 820     static boolean shortcutExists(Context context, String title, Intent intent) {
 821         final ContentResolver cr = context.getContentResolver();
 822         final Intent intentWithPkg;
 823         final Intent intentWithoutPkg;
 824         if (intent.getComponent() != null) {
 825             // If component is not null, an intent with null package will produce
 826             // the same result and should also be a match.
 827             if (intent.getPackage() != null) {
 828                 intentWithPkg = intent;
 829                 intentWithoutPkg = new Intent(intent).setPackage(null);
 830             } else {
 831                 intentWithPkg = new Intent(intent).setPackage(intent.getComponent().getPackageName());
 832                 intentWithoutPkg = intent;
 833             }
 834         } else {
 835             intentWithPkg = intent;
 836             intentWithoutPkg = intent;
 837         }
<abbr title=" 838         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[]{ &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and (intent=? or intent=?)&quot;, new String[]{ title, intentWithPkg.toUri(0), intentWithoutPkg.toUri(0) }, null);"> 838         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[]{ &quot;title&quot;, &quot;intent&quot; }, &quot;t</abbr>
 839         boolean result = false;
 840         try {
 841             result = c.moveToFirst();
 842         } finally {
 843             c.close();
 844         }
 845         return result;
 846     }
 847 
 848     /**
 849      * Returns true if the promise shortcuts with the same package name exists on the workspace.
 850      */
 851     static boolean appWasPromise(Context context, Intent intent, UserHandleCompat user) {
 852         final ComponentName component = intent.getComponent();
 853         if (component == null) {
 854             return false;
 855         }
 856         return !getItemsByPackageName(component.getPackageName(), user).isEmpty();
 857     }
 858 
 859     /**
 860      * Returns an ItemInfo array containing all the items in the LauncherModel.
 861      * The ItemInfo.id is not set through this function.
 862      */
 863     static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 864         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 865         final ContentResolver cr = context.getContentResolver();
<abbr title=" 866         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[]{ LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER, LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY, LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY, LauncherSettings.Favorites.PROFILE_ID }, null, null, null);"> 866         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[]{ LauncherSettings.Favori</abbr>
 867         final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 868         final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 869         final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 870         final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 871         final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 872         final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 873         final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 874         final int profileIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.PROFILE_ID);
 875         UserManagerCompat userManager = UserManagerCompat.getInstance(context);
 876         try {
 877             while (c.moveToNext()) {
 878                 ItemInfo item = new ItemInfo();
 879                 item.cellX = c.getInt(cellXIndex);
 880                 item.cellY = c.getInt(cellYIndex);
 881                 item.spanX = Math.max(1, c.getInt(spanXIndex));
 882                 item.spanY = Math.max(1, c.getInt(spanYIndex));
 883                 item.container = c.getInt(containerIndex);
 884                 item.itemType = c.getInt(itemTypeIndex);
 885                 item.screenId = c.getInt(screenIndex);
 886                 long serialNumber = c.getInt(profileIdIndex);
 887                 item.user = userManager.getUserForSerialNumber(serialNumber);
 888                 // Skip if user has been deleted.
 889                 if (item.user != null) {
 890                     items.add(item);
 891                 }
 892             }
 893         } catch (java.lang.Exception e) {
 894             items.clear();
 895         } finally {
 896             c.close();
 897         }
 898         return items;
 899     }
 900 
 901     /**
 902      * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 903      */
 904     FolderInfo getFolderById(Context context, HashMap&lt;Long, FolderInfo&gt; folderList, long id) {
 905         final ContentResolver cr = context.getContentResolver();
<abbr title=" 906         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null, &quot;_id=? and (itemType=? or itemType=?)&quot;, new String[]{ String.valueOf(id), String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER) }, null);"> 906         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null, &quot;_id=? and (itemType=? or itemT</abbr>
 907         try {
 908             if (c.moveToFirst()) {
 909                 final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 910                 final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 911                 final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 912                 final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 913                 final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 914                 final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 915                 FolderInfo folderInfo = null;
 916                 switch (c.getInt(itemTypeIndex)) {
 917                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER :
 918                         folderInfo = findOrMakeFolder(folderList, id);
 919                         break;
 920                 }
 921                 folderInfo.title = c.getString(titleIndex);
 922                 folderInfo.id = id;
 923                 folderInfo.container = c.getInt(containerIndex);
 924                 folderInfo.screenId = c.getInt(screenIndex);
 925                 folderInfo.cellX = c.getInt(cellXIndex);
 926                 folderInfo.cellY = c.getInt(cellYIndex);
 927                 return folderInfo;
 928             }
 929         } finally {
 930             c.close();
 931         }
 932         return null;
 933     }
 934 
 935     /**
 936      * Add an item to the database in a specified container. Sets the container, screen, cellX and
 937      * cellY fields of the item. Also assigns an ID to the item.
 938      */
<abbr title=" 939     static void addItemToDatabase(Context context, final ItemInfo item, final long container, final long screenId, final int cellX, final int cellY, final boolean notify) {"> 939     static void addItemToDatabase(Context context, final ItemInfo item, final long container, final long </abbr>
 940         item.container = container;
 941         item.cellX = cellX;
 942         item.cellY = cellY;
 943         // We store hotseat items in canonical form which is this orientation invariant position
 944         // in the hotseat
<abbr title=" 945         if (((context instanceof Launcher) &amp;&amp; (screenId &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {"> 945         if (((context instanceof Launcher) &amp;&amp; (screenId &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorites</abbr>
 946             item.screenId = ((Launcher) (context)).getHotseat().getOrderInHotseat(cellX, cellY);
 947         } else {
 948             item.screenId = screenId;
 949         }
 950         final ContentValues values = new ContentValues();
 951         final ContentResolver cr = context.getContentResolver();
 952         item.onAddToDatabase(context, values);
 953         item.id = LauncherAppState.getLauncherProvider().generateNewItemId();
 954         values.put(LauncherSettings.Favorites._ID, item.id);
 955         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 956         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 957         Runnable r = new Runnable() {
 958             public void run() {
<abbr title=" 959                 cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI : LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);"> 959                 cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI : LauncherSettings.Favorites.CO</abbr>
 960                 // Lock on mBgLock *after* the db operation
 961                 synchronized(sBgLock) {
 962                     checkItemInfoLocked(item.id, item, stackTrace);
 963                     sBgItemsIdMap.put(item.id, item);
 964                     switch (item.itemType) {
 965                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER :
 966                             sBgFolders.put(item.id, ((FolderInfo) (item)));
 967                             // Fall through
 968                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION :
 969                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT :
<abbr title=" 970                             if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) || (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {"> 970                             if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) || (item</abbr>
 971                                 sBgWorkspaceItems.add(item);
 972                             } else if (!sBgFolders.containsKey(item.container)) {
 973                                 // Adding an item to a folder that doesn&#x27;t exist.
<abbr title=" 974                                 String msg = ((&quot;adding item: &quot; + item) + &quot; to a folder that &quot;) + &quot; doesn&#x27;t exist&quot;;"> 974                                 String msg = ((&quot;adding item: &quot; + item) + &quot; to a folder that &quot;) + &quot; doesn&#x27;</abbr>
 975                                 Log.e(TAG, msg);
 976                             }
 977                             break;
 978                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET :
 979                             sBgAppWidgets.add(((LauncherAppWidgetInfo) (item)));
 980                             break;
 981                     }
 982                 }
 983             }
 984         };
 985         runOnWorkerThread(r);
 986     }
 987 
 988     /**
 989      * Creates a new unique child id, for a given cell span across all layouts.
 990      */
 991     static int getCellLayoutChildId(
 992             long container, long screen, int localCellX, int localCellY, int spanX, int spanY) {
 993         return (((int) container &amp; 0xFF) &lt;&lt; 24)
 994                 | ((int) screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
 995     }
 996 
<abbr title=" 997     private static ArrayList&lt;ItemInfo&gt; getItemsByPackageName(final String pn, final UserHandleCompat user) {"> 997     private static ArrayList&lt;ItemInfo&gt; getItemsByPackageName(final String pn, final UserHandleCompat user</abbr>
 998         ItemInfoFilter filter = new ItemInfoFilter() {
 999             @Override
1000             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
1001                 return cn.getPackageName().equals(pn) &amp;&amp; info.user.equals(user);
1002             }
1003         };
1004         return filterItemInfos(sBgItemsIdMap.values(), filter);
1005     }
1006 
1007     /**
1008      * Removes all the items from the database corresponding to the specified package.
1009      */
1010     static void deletePackageFromDatabase(Context context, final String pn,
1011             final UserHandleCompat user) {
1012         deleteItemsFromDatabase(context, getItemsByPackageName(pn, user));
1013     }
1014 
1015     /**
1016      * Removes the specified item from the database
1017      * @param context
1018      * @param item
1019      */
1020     static void deleteItemFromDatabase(Context context, final ItemInfo item) {
1021         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
1022         items.add(item);
1023         deleteItemsFromDatabase(context, items);
1024     }
1025 
1026     /**
1027      * Removes the specified items from the database
1028      * @param context
1029      * @param item
1030      */
1031     static void deleteItemsFromDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items) {
1032         final ContentResolver cr = context.getContentResolver();
1033         Runnable r = new Runnable() {
1034             public void run() {
1035                 for (ItemInfo item : items) {
1036                     final Uri uri = LauncherSettings.Favorites.getContentUri(item.id, false);
1037                     cr.delete(uri, null, null);
1038                 // Lock on mBgLock *after* the db operation
1039                     synchronized(sBgLock) {
1040                         switch (item.itemType) {
1041                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER :
1042                                 sBgFolders.remove(item.id);
1043                                 for (ItemInfo info : sBgItemsIdMap.values()) {
1044                                     if (info.container == item.id) {
1045                                     // We are deleting a folder which still contains items that
1046                                     // think they are contained by that folder.
<abbr title="1047                                         String msg = ((((&quot;deleting a folder (&quot; + item) + &quot;) which still &quot;) + &quot;contains items (&quot;) + info) + &quot;)&quot;;">1047                                         String msg = ((((&quot;deleting a folder (&quot; + item) + &quot;) which still &quot;</abbr>
1048                                         Log.e(TAG, msg);
1049                                     }
1050                                 }
1051                                 sBgWorkspaceItems.remove(item);
1052                                 break;
1053                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION :
1054                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT :
1055                                 sBgWorkspaceItems.remove(item);
1056                                 break;
1057                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET :
1058                                 sBgAppWidgets.remove(((LauncherAppWidgetInfo) (item)));
1059                                 break;
1060                         }
1061                         sBgItemsIdMap.remove(item.id);
1062                         sBgDbIconCache.remove(item);
1063                     }
1064                 }
1065             }
1066         };
1067         runOnWorkerThread(r);
1068     }
1069 
1070     /**
1071      * Update the order of the workspace screens in the database. The array list contains
1072      * a list of screen ids in the order that they should appear.
1073      */
1074     void updateWorkspaceScreenOrder(Context context, final ArrayList&lt;Long&gt; screens) {
1075         // Log to disk
1076         Launcher.addDumpLog(TAG, &quot;11683562 - updateWorkspaceScreenOrder()&quot;, true);
1077         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; + TextUtils.join(&quot;, &quot;, screens), true);
1078         final ArrayList&lt;Long&gt; screensCopy = new ArrayList&lt;Long&gt;(screens);
1079         final ContentResolver cr = context.getContentResolver();
1080         final Uri uri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1081         // Remove any negative screen ids -- these aren&#x27;t persisted
1082         Iterator&lt;Long&gt; iter = screensCopy.iterator();
1083         while (iter.hasNext()) {
1084             long id = iter.next();
1085             if (id &lt; 0) {
1086                 iter.remove();
1087             }
1088         }
1089         Runnable r = new Runnable() {
1090             @Override
1091             public void run() {
1092                 ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
1093                 // Clear the table
1094                 ops.add(ContentProviderOperation.newDelete(uri).build());
1095                 int count = screensCopy.size();
1096                 for (int i = 0; i &lt; count; i++) {
1097                     ContentValues v = new ContentValues();
1098                     long screenId = screensCopy.get(i);
1099                     v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1100                     v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1101                     ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());
1102                 }
1103                 try {
1104                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
1105                 } catch (java.lang.Exception ex) {
1106                     throw new RuntimeException(ex);
1107                 }
1108                 synchronized(sBgLock) {
1109                     sBgWorkspaceScreens.clear();
1110                     sBgWorkspaceScreens.addAll(screensCopy);
1111                 }
1112             }
1113         };
1114         runOnWorkerThread(r);
1115     }
1116 
1117     /**
1118      * Remove the contents of the specified folder from the database
1119      */
1120     static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
1121         final ContentResolver cr = context.getContentResolver();
1122         Runnable r = new Runnable() {
1123             public void run() {
1124                 cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
1125                 // Lock on mBgLock *after* the db operation
1126                 synchronized(sBgLock) {
1127                     sBgItemsIdMap.remove(info.id);
1128                     sBgFolders.remove(info.id);
1129                     sBgDbIconCache.remove(info);
1130                     sBgWorkspaceItems.remove(info);
1131                 }
<abbr title="1132                 cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, (LauncherSettings.Favorites.CONTAINER + &quot;=&quot;) + info.id, null);">1132                 cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, (LauncherSettings.Favor</abbr>
1133                 // Lock on mBgLock *after* the db operation
1134                 synchronized(sBgLock) {
1135                     for (ItemInfo childInfo : info.contents) {
1136                         sBgItemsIdMap.remove(childInfo.id);
1137                         sBgDbIconCache.remove(childInfo);
1138                     }
1139                 }
1140             }
1141         };
1142         runOnWorkerThread(r);
1143     }
1144 
1145     /**
1146      * Set this as the current Launcher activity object for the loader.
1147      */
1148     public void initialize(Callbacks callbacks) {
1149         synchronized (mLock) {
1150             mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
1151         }
1152     }
1153 
1154     @Override
1155     public void onPackageChanged(String packageName, UserHandleCompat user) {
1156         int op = PackageUpdatedTask.OP_UPDATE;
1157         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[]{ packageName }, user));
1158     }
1159 
1160     @Override
1161     public void onPackageRemoved(String packageName, UserHandleCompat user) {
1162         int op = PackageUpdatedTask.OP_REMOVE;
1163         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[]{ packageName }, user));
1164     }
1165 
1166     @Override
1167     public void onPackageAdded(String packageName, UserHandleCompat user) {
1168         int op = PackageUpdatedTask.OP_ADD;
1169         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[]{ packageName }, user));
1170     }
1171 
1172     @Override
1173     public void onPackagesAvailable(String[] packageNames, UserHandleCompat user, boolean replacing) {
1174         if (!replacing) {
1175             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packageNames, user));
1176             if (mAppsCanBeOnRemoveableStorage) {
1177                 // Only rebind if we support removable storage. It catches the
1178                 // case where
1179                 // apps on the external sd card need to be reloaded
1180                 startLoaderFromBackground();
1181             }
1182         } else {
1183             // If we are replacing then just update the packages in the list
<abbr title="1184             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE, packageNames, user));">1184             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE, packageNames, user</abbr>
1185         }
1186     }
1187 
1188     @Override
1189     public void onPackagesUnavailable(String[] packageNames, UserHandleCompat user, boolean replacing) {
1190         if (!replacing) {
<abbr title="1191             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UNAVAILABLE, packageNames, user));">1191             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UNAVAILABLE, packageNames,</abbr>
1192         }
1193     }
1194 
1195     /**
1196      * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
1197      * ACTION_PACKAGE_CHANGED.
1198      */
1199     @Override
1200     public void onReceive(Context context, Intent intent) {
1201         if (DEBUG_RECEIVER) {
1202             Log.d(TAG, &quot;onReceive intent=&quot; + intent);
1203         }
1204         final String action = intent.getAction();
1205         if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
1206             // If we have changed locale we need to clear out the labels in all apps/workspace.
1207             forceReload();
1208         } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
1209             // Check if configuration change was an mcc/mnc change which would affect app resources
1210             // and we would need to clear out the labels in all apps/workspace. Same handling as
1211             // above for ACTION_LOCALE_CHANGED
1212             Configuration currentConfig = context.getResources().getConfiguration();
1213             if (mPreviousConfigMcc != currentConfig.mcc) {
<abbr title="1214                 Log.d(TAG, ((&quot;Reload apps on config change. curr_mcc:&quot; + currentConfig.mcc) + &quot; prevmcc:&quot;) + mPreviousConfigMcc);">1214                 Log.d(TAG, ((&quot;Reload apps on config change. curr_mcc:&quot; + currentConfig.mcc) + &quot; prevmcc:&quot;</abbr>
1215                 forceReload();
1216             }
1217             // Update previousConfig
1218             mPreviousConfigMcc = currentConfig.mcc;
<abbr title="1219         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) || SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {">1219         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) || SearchManager.IN</abbr>
1220             if (mCallbacks != null) {
1221                 Callbacks callbacks = mCallbacks.get();
1222                 if (callbacks != null) {
1223                     callbacks.bindSearchablesChanged();
1224                 }
1225             }
1226         }
1227     }
1228 
1229     void forceReload() {
1230         resetLoadedState(true, true);
1231         // Do this here because if the launcher activity is running it will be restarted.
1232         // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
1233         // to reload.
1234         startLoaderFromBackground();
1235     }
1236 
1237     public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
1238         synchronized (mLock) {
1239             // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
1240             // mWorkspaceLoaded to true later
1241             stopLoaderLocked();
1242             if (resetAllAppsLoaded) mAllAppsLoaded = false;
1243             if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
1244         }
1245     }
1246 
1247     /**
1248      * When the launcher is in the background, it&#x27;s possible for it to miss paired
1249      * configuration changes.  So whenever we trigger the loader from the background
1250      * tell the launcher that it needs to re-run the loader when it comes back instead
1251      * of doing it now.
1252      */
1253     public void startLoaderFromBackground() {
1254         boolean runLoader = false;
1255         if (mCallbacks != null) {
1256             Callbacks callbacks = mCallbacks.get();
1257             if (callbacks != null) {
1258                 // Only actually run the loader if they&#x27;re not paused.
1259                 if (!callbacks.setLoadOnResume()) {
1260                     runLoader = true;
1261                 }
1262             }
1263         }
1264         if (runLoader) {
1265             startLoader(false, PagedView.INVALID_RESTORE_PAGE);
1266         }
1267     }
1268 
1269     // If there is already a loader task running, tell it to stop.
1270     // returns true if isLaunching() was true on the old task
1271     private boolean stopLoaderLocked() {
1272         boolean isLaunching = false;
1273         LoaderTask oldTask = mLoaderTask;
1274         if (oldTask != null) {
1275             if (oldTask.isLaunching()) {
1276                 isLaunching = true;
1277             }
1278             oldTask.stopLocked();
1279         }
1280         return isLaunching;
1281     }
1282 
1283     public boolean isCurrentCallbacks(Callbacks callbacks) {
1284         return (mCallbacks != null &amp;&amp; mCallbacks.get() == callbacks);
1285     }
1286 
1287     public void startLoader(boolean isLaunching, int synchronousBindPage) {
1288         startLoader(isLaunching, synchronousBindPage, LOADER_FLAG_NONE);
1289     }
1290 
1291     public void startLoader(boolean isLaunching, int synchronousBindPage, int loadFlags) {
1292         synchronized(mLock) {
1293             if (DEBUG_LOADERS) {
1294                 Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
1295             }
1296             // Clear any deferred bind-runnables from the synchronized load process
1297             // We must do this before any loading/binding is scheduled below.
1298             synchronized(mDeferredBindRunnables) {
1299                 mDeferredBindRunnables.clear();
1300             }
1301             // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
1302             if ((mCallbacks != null) &amp;&amp; (mCallbacks.get() != null)) {
1303                 // If there is already one running, tell it to stop.
1304                 // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
1305                 isLaunching = isLaunching || stopLoaderLocked();
1306                 mLoaderTask = new LoaderTask(mApp.getContext(), isLaunching, loadFlags);
<abbr title="1307                 if (((synchronousBindPage != PagedView.INVALID_RESTORE_PAGE) &amp;&amp; mAllAppsLoaded) &amp;&amp; mWorkspaceLoaded) {">1307                 if (((synchronousBindPage != PagedView.INVALID_RESTORE_PAGE) &amp;&amp; mAllAppsLoaded) &amp;&amp; mWorks</abbr>
1308                     mLoaderTask.runBindSynchronousPage(synchronousBindPage);
1309                 } else {
1310                     sWorkerThread.setPriority(Thread.NORM_PRIORITY);
1311                     sWorker.post(mLoaderTask);
1312                 }
1313             }
1314         }
1315     }
1316 
1317     void bindRemainingSynchronousPages() {
1318         // Post the remaining side pages to be loaded
1319         if (!mDeferredBindRunnables.isEmpty()) {
1320             Runnable[] deferredBindRunnables = null;
1321             synchronized(mDeferredBindRunnables) {
<abbr title="1322                 deferredBindRunnables = mDeferredBindRunnables.toArray(new Runnable[mDeferredBindRunnables.size()]);">1322                 deferredBindRunnables = mDeferredBindRunnables.toArray(new Runnable[mDeferredBindRunnable</abbr>
1323                 mDeferredBindRunnables.clear();
1324             }
1325             for (final Runnable r : deferredBindRunnables) {
1326                 mHandler.post(r, MAIN_THREAD_BINDING_RUNNABLE);
1327             }
1328         }
1329     }
1330 
1331     public void stopLoader() {
1332         synchronized (mLock) {
1333             if (mLoaderTask != null) {
1334                 mLoaderTask.stopLocked();
1335             }
1336         }
1337     }
1338 
1339     /** Loads the workspace screens db into a map of Rank -&gt; ScreenId */
1340     private static TreeMap&lt;Integer, Long&gt; loadWorkspaceScreensDb(Context context) {
1341         final ContentResolver contentResolver = context.getContentResolver();
1342         final Uri screensUri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1343         final Cursor sc = contentResolver.query(screensUri, null, null, null, null);
1344         TreeMap&lt;Integer, Long&gt; orderedScreens = new TreeMap&lt;Integer, Long&gt;();
1345         try {
1346             final int idIndex = sc.getColumnIndexOrThrow(LauncherSettings.WorkspaceScreens._ID);
<abbr title="1347             final int rankIndex = sc.getColumnIndexOrThrow(LauncherSettings.WorkspaceScreens.SCREEN_RANK);">1347             final int rankIndex = sc.getColumnIndexOrThrow(LauncherSettings.WorkspaceScreens.SCREEN_RANK)</abbr>
1348             while (sc.moveToNext()) {
1349                 try {
1350                     long screenId = sc.getLong(idIndex);
1351                     int rank = sc.getInt(rankIndex);
1352                     orderedScreens.put(rank, screenId);
1353                 } catch (java.lang.Exception e) {
<abbr title="1354                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e, true);">1354                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e,</abbr>
1355                 }
1356             }
1357         } finally {
1358             sc.close();
1359         }
1360         // Log to disk
1361         Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspaceScreensDb()&quot;, true);
1362         ArrayList&lt;String&gt; orderedScreensPairs = new ArrayList&lt;String&gt;();
1363         for (Integer i : orderedScreens.keySet()) {
1364             orderedScreensPairs.add((((&quot;{ &quot; + i) + &quot;: &quot;) + orderedScreens.get(i)) + &quot; }&quot;);
1365         }
<abbr title="1366         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; + TextUtils.join(&quot;, &quot;, orderedScreensPairs), true);">1366         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; + TextUtils.join(&quot;, &quot;, orderedScreensPairs), tr</abbr>
1367         return orderedScreens;
1368     }
1369 
1370     public boolean isAllAppsLoaded() {
1371         return mAllAppsLoaded;
1372     }
1373 
1374     boolean isLoadingWorkspace() {
1375         synchronized (mLock) {
1376             if (mLoaderTask != null) {
1377                 return mLoaderTask.isLoadingWorkspace();
1378             }
1379         }
1380         return false;
1381     }
1382 
1383     /**
1384      * Runnable for the thread that loads the contents of the launcher:
1385      *   - workspace icons
1386      *   - widgets
1387      *   - all apps icons
1388      */
1389     private class LoaderTask implements Runnable {
1390         private Context mContext;
1391 
1392         private boolean mIsLaunching;
1393 
1394         private boolean mIsLoadingAndBindingWorkspace;
1395 
1396         private boolean mStopped;
1397 
1398         private boolean mLoadAndBindStepFinished;
1399 
1400         private int mFlags;
1401 
1402         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
1403 
1404         LoaderTask(Context context, boolean isLaunching, int flags) {
1405             mContext = context;
1406             mIsLaunching = isLaunching;
1407             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
1408             mFlags = flags;
1409         }
1410 
1411         boolean isLaunching() {
1412             return mIsLaunching;
1413         }
1414 
1415         boolean isLoadingWorkspace() {
1416             return mIsLoadingAndBindingWorkspace;
1417         }
1418 
1419         /** Returns whether this is an upgrade path */
1420         private boolean loadAndBindWorkspace() {
1421             mIsLoadingAndBindingWorkspace = true;
1422 
1423             // Load the workspace
1424             if (DEBUG_LOADERS) {
1425                 Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1426             }
1427 
1428             boolean isUpgradePath = false;
1429             if (!mWorkspaceLoaded) {
1430                 isUpgradePath = loadWorkspace();
1431                 synchronized (LoaderTask.this) {
1432                     if (mStopped) {
1433                         return isUpgradePath;
1434                     }
1435                     mWorkspaceLoaded = true;
1436                 }
1437             }
1438 
1439             // Bind the workspace
1440             bindWorkspace(-1, isUpgradePath);
1441             return isUpgradePath;
1442         }
1443 
1444         private void waitForIdle() {
1445             // Wait until the either we&#x27;re stopped or the other threads are done.
1446             // This way we don&#x27;t start loading all apps until the workspace has settled
1447             // down.
1448             synchronized (LoaderTask.this) {
1449                 final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1450 
1451                 mHandler.postIdle(new Runnable() {
1452                         public void run() {
1453                             synchronized (LoaderTask.this) {
1454                                 mLoadAndBindStepFinished = true;
1455                                 if (DEBUG_LOADERS) {
1456                                     Log.d(TAG, &quot;done with previous binding step&quot;);
1457                                 }
1458                                 LoaderTask.this.notify();
1459                             }
1460                         }
1461                     });
1462 
1463                 while (!mStopped &amp;&amp; !mLoadAndBindStepFinished &amp;&amp; !mFlushingWorkerThread) {
1464                     try {
1465                         // Just in case mFlushingWorkerThread changes but we aren&#x27;t woken up,
1466                         // wait no longer than 1sec at a time
1467                         this.wait(1000);
1468                     } catch (InterruptedException ex) {
1469                         // Ignore
1470                     }
1471                 }
1472                 if (DEBUG_LOADERS) {
1473                     Log.d(TAG, &quot;waited &quot;
1474                             + (SystemClock.uptimeMillis()-workspaceWaitTime)
1475                             + &quot;ms for previous step to finish binding&quot;);
1476                 }
1477             }
1478         }
1479 
1480         void runBindSynchronousPage(int synchronousBindPage) {
1481             if (synchronousBindPage == PagedView.INVALID_RESTORE_PAGE) {
1482                 // Ensure that we have a valid page index to load synchronously
1483                 throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1484                         &quot;valid page index&quot;);
1485             }
1486             if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1487                 // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1488                 // loaded already (we should load everything asynchronously in that case)
1489                 throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1490             }
1491             synchronized (mLock) {
1492                 if (mIsLoaderTaskRunning) {
1493                     // Ensure that we are never running the background loading at this point since
1494                     // we also touch the background collections
1495                     throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1496                 }
1497             }
1498 
1499             // XXX: Throw an exception if we are already loading (since we touch the worker thread
1500             //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1501             //      this call is synchronous, we can get away with not locking).
1502 
1503             // The LauncherModel is static in the LauncherAppState and mHandler may have queued
1504             // operations from the previous activity.  We need to ensure that all queued operations
1505             // are executed before any synchronous binding work is done.
1506             mHandler.flush();
1507 
1508             // Divide the set of loaded items into those that we are binding synchronously, and
1509             // everything else that is to be bound normally (asynchronously).
1510             bindWorkspace(synchronousBindPage, false);
1511             // XXX: For now, continue posting the binding of AllApps as there are other issues that
1512             //      arise from that.
1513             onlyBindAllApps();
1514         }
1515 
1516         public void run() {
1517             boolean isUpgrade = false;
1518             synchronized(mLock) {
1519                 mIsLoaderTaskRunning = true;
1520             }
1521             // Optimize for end-user experience: if the Launcher is up and // running with the
1522             // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1523             // workspace first (default).
1524             keep_running : {
1525                 // Elevate priority when Home launches for the first time to avoid
1526                 // starving at boot time. Staring at a blank home is not cool.
1527                 synchronized(mLock) {
1528                     if (DEBUG_LOADERS) {
<abbr title="1529                         Log.d(TAG, &quot;Setting thread priority to &quot; + (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));">1529                         Log.d(TAG, &quot;Setting thread priority to &quot; + (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUN</abbr>
1530                     }
<abbr title="1531                     Process.setThreadPriority(mIsLaunching ? java.lang.Process.THREAD_PRIORITY_DEFAULT : java.lang.Process.THREAD_PRIORITY_BACKGROUND);">1531                     Process.setThreadPriority(mIsLaunching ? java.lang.Process.THREAD_PRIORITY_DEFAULT : </abbr>
1532                 }
1533                 if (DEBUG_LOADERS) {
1534                     Log.d(TAG, &quot;step 1: loading workspace&quot;);
1535                 }
1536                 isUpgrade = loadAndBindWorkspace();
1537                 if (mStopped) {
1538                     break keep_running;
1539                 }
1540                 // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1541                 // settled down.
1542                 synchronized(mLock) {
1543                     if (mIsLaunching) {
1544                         if (DEBUG_LOADERS) {
1545                             Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1546                         }
1547                         Process.setThreadPriority(java.lang.Process.THREAD_PRIORITY_BACKGROUND);
1548                     }
1549                 }
1550                 waitForIdle();
1551                 // second step
1552                 if (DEBUG_LOADERS) {
1553                     Log.d(TAG, &quot;step 2: loading all apps&quot;);
1554                 }
1555                 loadAndBindAllApps();
1556                 // Restore the default thread priority after we are done loading items
1557                 synchronized(mLock) {
1558                     Process.setThreadPriority(java.lang.Process.THREAD_PRIORITY_DEFAULT);
1559                 }
1560             }
1561             // Update the saved icons if necessary
1562             if (DEBUG_LOADERS) {
1563                 Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1564             }
1565             synchronized(sBgLock) {
1566                 for (Object key : sBgDbIconCache.keySet()) {
1567                     updateSavedIcon(mContext, ((ShortcutInfo) (key)), sBgDbIconCache.get(key));
1568                 }
1569                 sBgDbIconCache.clear();
1570             }
1571             if (LauncherAppState.isDisableAllApps()) {
1572                 // Ensure that all the applications that are in the system are
1573                 // represented on the home screen.
1574                 if ((!UPGRADE_USE_MORE_APPS_FOLDER) || (!isUpgrade)) {
1575                     verifyApplications();
1576                 }
1577             }
1578             // Clear out this reference, otherwise we end up holding it until all of the
1579             // callback runnables are done.
1580             mContext = null;
1581             synchronized(mLock) {
1582                 // If we are still the last one to be scheduled, remove ourselves.
1583                 if (mLoaderTask == this) {
1584                     mLoaderTask = null;
1585                 }
1586                 mIsLoaderTaskRunning = false;
1587             }
1588         }
1589 
1590         public void stopLocked() {
1591             synchronized (LoaderTask.this) {
1592                 mStopped = true;
1593                 this.notify();
1594             }
1595         }
1596 
1597         /**
1598          * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1599          * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1600          * object that was around when the deferred message was scheduled, and if there&#x27;s
1601          * a new Callbacks object around then also return null.  This will save us from
1602          * calling onto it with data that will be ignored.
1603          */
1604         Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1605             synchronized (mLock) {
1606                 if (mStopped) {
1607                     return null;
1608                 }
1609 
1610                 if (mCallbacks == null) {
1611                     return null;
1612                 }
1613 
1614                 final Callbacks callbacks = mCallbacks.get();
1615                 if (callbacks != oldCallbacks) {
1616                     return null;
1617                 }
1618                 if (callbacks == null) {
1619                     Log.w(TAG, &quot;no mCallbacks&quot;);
1620                     return null;
1621                 }
1622 
1623                 return callbacks;
1624             }
1625         }
1626 
1627         private void verifyApplications() {
1628             final Context context = mApp.getContext();
1629             // Cross reference all the applications in our apps list with items in the workspace
1630             ArrayList&lt;ItemInfo&gt; tmpInfos;
1631             ArrayList&lt;ItemInfo&gt; added = new ArrayList&lt;ItemInfo&gt;();
1632             synchronized(sBgLock) {
1633                 for (AppInfo app : mBgAllAppsList.data) {
1634                     tmpInfos = getItemInfoForComponentName(app.componentName, app.user);
1635                     if (tmpInfos.isEmpty()) {
1636                         // We are missing an application icon, so add this to the workspace
1637                         added.add(app);
1638                         // This is a rare event, so lets log it
1639                         Log.e(TAG, &quot;Missing Application on load: &quot; + app);
1640                     }
1641                 }
1642             }
1643             if (!added.isEmpty()) {
1644                 addAndBindAddedWorkspaceApps(context, added);
1645             }
1646         }
1647 
1648         // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
<abbr title="1649         private boolean checkItemPlacement(HashMap&lt;Long, ItemInfo[][]&gt; occupied, ItemInfo item, AtomicBoolean deleteOnInvalidPlacement) {">1649         private boolean checkItemPlacement(HashMap&lt;Long, ItemInfo[][]&gt; occupied, ItemInfo item, AtomicBoo</abbr>
1650             LauncherAppState app = LauncherAppState.getInstance();
1651             DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1652             final int countX = ((int) (grid.numColumns));
1653             final int countY = ((int) (grid.numRows));
1654             long containerIndex = item.screenId;
1655             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1656                 // Return early if we detect that an item is under the hotseat button
<abbr title="1657                 if ((mCallbacks == null) || mCallbacks.get().isAllAppsButtonRank(((int) (item.screenId)))) {">1657                 if ((mCallbacks == null) || mCallbacks.get().isAllAppsButtonRank(((int) (item.screenId)))</abbr>
1658                     deleteOnInvalidPlacement.set(true);
<abbr title="1659                     Log.e(TAG, (((((((&quot;Error loading shortcut into hotseat &quot; + item) + &quot; into position (&quot;) + item.screenId) + &quot;:&quot;) + item.cellX) + &quot;,&quot;) + item.cellY) + &quot;) occupied by all apps&quot;);">1659                     Log.e(TAG, (((((((&quot;Error loading shortcut into hotseat &quot; + item) + &quot; into position (&quot;</abbr>
1660                     return false;
1661                 }
<abbr title="1662                 final ItemInfo[][] hotseatItems = occupied.get(((long) (LauncherSettings.Favorites.CONTAINER_HOTSEAT)));">1662                 final ItemInfo[][] hotseatItems = occupied.get(((long) (LauncherSettings.Favorites.CONTAI</abbr>
1663                 if (item.screenId &gt;= grid.numHotseatIcons) {
<abbr title="1664                     Log.e(TAG, (((((&quot;Error loading shortcut &quot; + item) + &quot; into hotseat position &quot;) + item.screenId) + &quot;, position out of bounds: (0 to &quot;) + (grid.numHotseatIcons - 1)) + &quot;)&quot;);">1664                     Log.e(TAG, (((((&quot;Error loading shortcut &quot; + item) + &quot; into hotseat position &quot;) + item</abbr>
1665                     return false;
1666                 }
1667                 if (hotseatItems != null) {
1668                     if (hotseatItems[((int) (item.screenId))][0] != null) {
<abbr title="1669                         Log.e(TAG, ((((((((&quot;Error loading shortcut into hotseat &quot; + item) + &quot; into position (&quot;) + item.screenId) + &quot;:&quot;) + item.cellX) + &quot;,&quot;) + item.cellY) + &quot;) occupied by &quot;) + occupied.get(LauncherSettings.Favorites.CONTAINER_HOTSEAT)[((int) (item.screenId))][0]);">1669                         Log.e(TAG, ((((((((&quot;Error loading shortcut into hotseat &quot; + item) + &quot; into positi</abbr>
1670                         return false;
1671                     } else {
1672                         hotseatItems[((int) (item.screenId))][0] = item;
1673                         return true;
1674                     }
1675                 } else {
1676                     final ItemInfo[][] items = new ItemInfo[((int) (grid.numHotseatIcons))][1];
1677                     items[((int) (item.screenId))][0] = item;
1678                     occupied.put(((long) (LauncherSettings.Favorites.CONTAINER_HOTSEAT)), items);
1679                     return true;
1680                 }
1681             } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1682                 // Skip further checking if it is not the hotseat or workspace container
1683                 return true;
1684             }
1685             if (!occupied.containsKey(item.screenId)) {
1686                 ItemInfo[][] items = new ItemInfo[countX + 1][countY + 1];
1687                 occupied.put(item.screenId, items);
1688             }
1689             final ItemInfo[][] screens = occupied.get(item.screenId);
<abbr title="1690             if (((((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (item.cellX &lt; 0)) || (item.cellY &lt; 0)) || ((item.cellX + item.spanX) &gt; countX)) || ((item.cellY + item.spanY) &gt; countY)) {">1690             if (((((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (item.cellX &lt; 0)) </abbr>
<abbr title="1691                 Log.e(TAG, (((((((((((((&quot;Error loading shortcut &quot; + item) + &quot; into cell (&quot;) + containerIndex) + &quot;-&quot;) + item.screenId) + &quot;:&quot;) + item.cellX) + &quot;,&quot;) + item.cellY) + &quot;) out of screen bounds ( &quot;) + countX) + &quot;x&quot;) + countY) + &quot;)&quot;);">1691                 Log.e(TAG, (((((((((((((&quot;Error loading shortcut &quot; + item) + &quot; into cell (&quot;) + containerIn</abbr>
1692                 return false;
1693             }
1694             // Check if any workspace icons overlap with each other
1695             for (int x = item.cellX; x &lt; (item.cellX + item.spanX); x++) {
1696                 for (int y = item.cellY; y &lt; (item.cellY + item.spanY); y++) {
1697                     if (screens[x][y] != null) {
<abbr title="1698                         Log.e(TAG, ((((((((((&quot;Error loading shortcut &quot; + item) + &quot; into cell (&quot;) + containerIndex) + &quot;-&quot;) + item.screenId) + &quot;:&quot;) + x) + &quot;,&quot;) + y) + &quot;) occupied by &quot;) + screens[x][y]);">1698                         Log.e(TAG, ((((((((((&quot;Error loading shortcut &quot; + item) + &quot; into cell (&quot;) + contai</abbr>
1699                         return false;
1700                     }
1701                 }
1702             }
1703             for (int x = item.cellX; x &lt; (item.cellX + item.spanX); x++) {
1704                 for (int y = item.cellY; y &lt; (item.cellY + item.spanY); y++) {
1705                     screens[x][y] = item;
1706                 }
1707             }
1708             return true;
1709         }
1710 
1711         /** Clears all the sBg data structures */
1712         private void clearSBgDataStructures() {
1713             synchronized (sBgLock) {
1714                 sBgWorkspaceItems.clear();
1715                 sBgAppWidgets.clear();
1716                 sBgFolders.clear();
1717                 sBgItemsIdMap.clear();
1718                 sBgDbIconCache.clear();
1719                 sBgWorkspaceScreens.clear();
1720             }
1721         }
1722 
1723         /** Returns whether this is an upgrade path */
1724         private boolean loadWorkspace() {
1725             // Log to disk
1726             Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspace()&quot;, true);
1727             final long t = (DEBUG_LOADERS) ? SystemClock.uptimeMillis() : 0;
1728             final Context context = mContext;
1729             final ContentResolver contentResolver = context.getContentResolver();
1730             final PackageManager manager = context.getPackageManager();
1731             final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1732             final boolean isSafeMode = manager.isSafeMode();
1733             final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
<abbr title="1734             final boolean isSdCardReady = context.registerReceiver(null, new IntentFilter(StartupReceiver.SYSTEM_READY)) != null;">1734             final boolean isSdCardReady = context.registerReceiver(null, new IntentFilter(StartupReceiver</abbr>
1735             LauncherAppState app = LauncherAppState.getInstance();
1736             DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1737             int countX = ((int) (grid.numColumns));
1738             int countY = ((int) (grid.numRows));
1739             if ((mFlags &amp; LOADER_FLAG_CLEAR_WORKSPACE) != 0) {
1740                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: resetting launcher database&quot;, true);
1741                 LauncherAppState.getLauncherProvider().deleteDatabase();
1742             }
1743             if ((mFlags &amp; LOADER_FLAG_MIGRATE_SHORTCUTS) != 0) {
1744                 // append the user&#x27;s Launcher2 shortcuts
1745                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: migrating from launcher2&quot;, true);
1746                 LauncherAppState.getLauncherProvider().migrateLauncher2Shortcuts();
1747             } else {
1748                 // Make sure the default workspace is loaded
1749                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: loading default favorites&quot;, false);
1750                 LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary();
1751             }
1752             // This code path is for our old migration code and should no longer be exercised
1753             boolean loadedOldDb = false;
1754             // Log to disk
1755             Launcher.addDumpLog(TAG, &quot;11683562 -   loadedOldDb: &quot; + loadedOldDb, true);
1756             synchronized(sBgLock) {
1757                 clearSBgDataStructures();
<abbr title="1758                 final HashSet&lt;String&gt; installingPkgs = PackageInstallerCompat.getInstance(mContext).updateAndGetActiveSessionCache();">1758                 final HashSet&lt;String&gt; installingPkgs = PackageInstallerCompat.getInstance(mContext).updat</abbr>
1759                 final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1760                 final ArrayList&lt;Long&gt; restoredRows = new ArrayList&lt;Long&gt;();
1761                 final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION;
1762                 if (DEBUG_LOADERS) {
1763                     Log.d(TAG, &quot;loading model from &quot; + contentUri);
1764                 }
1765                 final Cursor c = contentResolver.query(contentUri, null, null, null, null);
1766                 // +1 for the hotseat (it can be larger than the workspace)
1767                 // Load workspace in reverse order to ensure that latest items are loaded first (and
1768                 // before any earlier duplicates)
1769                 final HashMap&lt;Long, ItemInfo[][]&gt; occupied = new HashMap&lt;Long, ItemInfo[][]&gt;();
1770                 try {
1771                     final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1772                     final int intentIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.INTENT);
1773                     final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
<abbr title="1774                     final int iconTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_TYPE);">1774                     final int iconTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_TYP</abbr>
1775                     final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
<abbr title="1776                     final int iconPackageIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_PACKAGE);">1776                     final int iconPackageIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_</abbr>
<abbr title="1777                     final int iconResourceIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_RESOURCE);">1777                     final int iconResourceIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON</abbr>
<abbr title="1778                     final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);">1778                     final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAIN</abbr>
<abbr title="1779                     final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);">1779                     final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYP</abbr>
<abbr title="1780                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.APPWIDGET_ID);">1780                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.APPWI</abbr>
<abbr title="1781                     final int appWidgetProviderIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.APPWIDGET_PROVIDER);">1781                     final int appWidgetProviderIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites</abbr>
1782                     final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
1783                     final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
1784                     final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
1785                     final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
1786                     final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
<abbr title="1787                     final int restoredIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.RESTORED);">1787                     final int restoredIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.RESTORED</abbr>
<abbr title="1788                     final int profileIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.PROFILE_ID);">1788                     final int profileIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.PROFILE</abbr>
1789                     //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1790                     //final int displayModeIndex = c.getColumnIndexOrThrow(
1791                     //        LauncherSettings.Favorites.DISPLAY_MODE);
1792                     ShortcutInfo info;
1793                     String intentDescription;
1794                     LauncherAppWidgetInfo appWidgetInfo;
1795                     int container;
1796                     long id;
1797                     Intent intent;
1798                     UserHandleCompat user;
1799                     while ((!mStopped) &amp;&amp; c.moveToNext()) {
1800                         AtomicBoolean deleteOnInvalidPlacement = new AtomicBoolean(false);
1801                         try {
1802                             int itemType = c.getInt(itemTypeIndex);
1803                             boolean restored = 0 != c.getInt(restoredIndex);
1804                             boolean allowMissingTarget = false;
1805                             switch (itemType) {
1806                                 case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION :
1807                                 case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT :
1808                                     id = c.getLong(idIndex);
1809                                     intentDescription = c.getString(intentIndex);
1810                                     long serialNumber = c.getInt(profileIdIndex);
1811                                     user = mUserManager.getUserForSerialNumber(serialNumber);
1812                                     int promiseType = c.getInt(restoredIndex);
1813                                     if (user == null) {
1814                                         // User has been deleted remove the item.
1815                                         itemsToRemove.add(id);
1816                                         continue;
1817                                     }
1818                                     try {
1819                                         intent = Intent.parseUri(intentDescription, 0);
1820                                         ComponentName cn = intent.getComponent();
1821                                         if ((cn != null) &amp;&amp; (cn.getPackageName() != null)) {
<abbr title="1822                                             boolean validPkg = launcherApps.isPackageEnabledForProfile(cn.getPackageName(), user);">1822                                             boolean validPkg = launcherApps.isPackageEnabledForProfile(cn</abbr>
<abbr title="1823                                             boolean validComponent = validPkg &amp;&amp; launcherApps.isActivityEnabledForProfile(cn, user);">1823                                             boolean validComponent = validPkg &amp;&amp; launcherApps.isActivityE</abbr>
1824                                             if (validComponent) {
1825                                                 if (restored) {
1826                                                     // no special handling necessary for this item
1827                                                     restoredRows.add(id);
1828                                                     restored = false;
1829                                                 }
1830                                             } else if (validPkg) {
1831                                                 intent = null;
<abbr title="1832                                                 if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {">1832                                                 if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != </abbr>
1833                                                     // We allow auto install apps to have their intent
1834                                                     // updated after an install.
<abbr title="1835                                                     intent = manager.getLaunchIntentForPackage(cn.getPackageName());">1835                                                     intent = manager.getLaunchIntentForPackage(cn.getPack</abbr>
1836                                                     if (intent != null) {
1837                                                         ContentValues values = new ContentValues();
<abbr title="1838                                                         values.put(LauncherSettings.Favorites.INTENT, intent.toUri(0));">1838                                                         values.put(LauncherSettings.Favorites.INTENT, int</abbr>
1839                                                         String where = BaseColumns._ID + &quot;= ?&quot;;
<abbr title="1840                                                         String[] args = new java.lang.String[]{ Long.toString(id) };">1840                                                         String[] args = new java.lang.String[]{ Long.toSt</abbr>
<abbr title="1841                                                         contentResolver.update(contentUri, values, where, args);">1841                                                         contentResolver.update(contentUri, values, where,</abbr>
1842                                                     }
1843                                                 }
1844                                                 if (intent == null) {
1845                                                     // The app is installed but the component is no
1846                                                 // longer available.
<abbr title="1847                                                     Launcher.addDumpLog(TAG, &quot;Invalid component removed: &quot; + cn, true);">1847                                                     Launcher.addDumpLog(TAG, &quot;Invalid component removed: </abbr>
1848                                                     itemsToRemove.add(id);
1849                                                     continue;
1850                                                 } else {
1851                                                     // no special handling necessary for this item
1852                                                     restoredRows.add(id);
1853                                                     restored = false;
1854                                                 }
1855                                             } else if (restored) {
1856                                             // Package is not yet available but might be
1857                                             // installed later.
<abbr title="1858                                                 Launcher.addDumpLog(TAG, &quot;package not yet restored: &quot; + cn, true);">1858                                                 Launcher.addDumpLog(TAG, &quot;package not yet restored: &quot; + c</abbr>
<abbr title="1859                                                 if ((promiseType &amp; ShortcutInfo.FLAG_RESTORE_STARTED) != 0) {">1859                                                 if ((promiseType &amp; ShortcutInfo.FLAG_RESTORE_STARTED) != </abbr>
1860                                                     // Restore has started once.
<abbr title="1861                                                 } else if (installingPkgs.contains(cn.getPackageName())) {">1861                                                 } else if (installingPkgs.contains(cn.getPackageName())) </abbr>
1862                                                     // App restore has started. Update the flag
1863                                                     promiseType |= ShortcutInfo.FLAG_RESTORE_STARTED;
1864                                                     ContentValues values = new ContentValues();
<abbr title="1865                                                     values.put(LauncherSettings.Favorites.RESTORED, promiseType);">1865                                                     values.put(LauncherSettings.Favorites.RESTORED, promi</abbr>
1866                                                     String where = BaseColumns._ID + &quot;= ?&quot;;
<abbr title="1867                                                     String[] args = new java.lang.String[]{ Long.toString(id) };">1867                                                     String[] args = new java.lang.String[]{ Long.toString</abbr>
<abbr title="1868                                                     contentResolver.update(contentUri, values, where, args);">1868                                                     contentResolver.update(contentUri, values, where, arg</abbr>
1869                                                 } else if (REMOVE_UNRESTORED_ICONS) {
<abbr title="1870                                                     Launcher.addDumpLog(TAG, &quot;Unrestored package removed: &quot; + cn, true);">1870                                                     Launcher.addDumpLog(TAG, &quot;Unrestored package removed:</abbr>
1871                                                     itemsToRemove.add(id);
1872                                                     continue;
1873                                                 }
1874                                             } else if (isSdCardReady) {
1875                                             // Do not wait for external media load anymore.
1876                                                 // Log the invalid package, and remove it
<abbr title="1877                                                 Launcher.addDumpLog(TAG, &quot;Invalid package removed: &quot; + cn, true);">1877                                                 Launcher.addDumpLog(TAG, &quot;Invalid package removed: &quot; + cn</abbr>
1878                                                 itemsToRemove.add(id);
1879                                                 continue;
1880                                             } else {
1881                                                 // SdCard is not ready yet. Package might get available,
1882                                                 // once it is ready.
<abbr title="1883                                                 Launcher.addDumpLog(TAG, (&quot;Invalid package: &quot; + cn) + &quot; (check again later)&quot;, true);">1883                                                 Launcher.addDumpLog(TAG, (&quot;Invalid package: &quot; + cn) + &quot; (</abbr>
1884                                                 HashSet&lt;String&gt; pkgs = sPendingPackages.get(user);
1885                                                 if (pkgs == null) {
1886                                                     pkgs = new HashSet&lt;String&gt;();
1887                                                     sPendingPackages.put(user, pkgs);
1888                                                 }
1889                                                 pkgs.add(cn.getPackageName());
1890                                                 allowMissingTarget = true;
1891                                             // Add the icon on the workspace anyway.
1892                                             }
1893                                         } else if (cn == null) {
1894                                             // For shortcuts with no component, keep them as they are
1895                                             restoredRows.add(id);
1896                                             restored = false;
1897                                         }
1898                                     } catch (URISyntaxException e) {
<abbr title="1899                                         Launcher.addDumpLog(TAG, &quot;Invalid uri: &quot; + intentDescription, true);">1899                                         Launcher.addDumpLog(TAG, &quot;Invalid uri: &quot; + intentDescription, tru</abbr>
1900                                         continue;
1901                                     }
1902                                     if (restored) {
1903                                         if (user.equals(UserHandleCompat.myUserHandle())) {
<abbr title="1904                                             Launcher.addDumpLog(TAG, &quot;constructing info for partially restored package&quot;, true);">1904                                             Launcher.addDumpLog(TAG, &quot;constructing info for partially res</abbr>
<abbr title="1905                                             info = getRestoredItemInfo(c, titleIndex, intent, promiseType);">1905                                             info = getRestoredItemInfo(c, titleIndex, intent, promiseType</abbr>
1906                                             intent = getRestoredItemIntent(c, context, intent);
1907                                         } else {
1908                                             // Don&#x27;t restore items for other profiles.
1909                                             itemsToRemove.add(id);
1910                                             continue;
1911                                         }
<abbr title="1912                                     } else if (itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {">1912                                     } else if (itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATI</abbr>
<abbr title="1913                                         info = getShortcutInfo(manager, intent, user, context, c, iconIndex, titleIndex, mLabelCache, allowMissingTarget);">1913                                         info = getShortcutInfo(manager, intent, user, context, c, iconInd</abbr>
1914                                     } else {
<abbr title="1915                                         info = getShortcutInfo(c, context, iconTypeIndex, iconPackageIndex, iconResourceIndex, iconIndex, titleIndex);">1915                                         info = getShortcutInfo(c, context, iconTypeIndex, iconPackageInde</abbr>
1916                                     // App shortcuts that used to be automatically added to Launcher
1917                                     // didn&#x27;t always have the correct intent flags set, so do that
1918                                     // here
<abbr title="1919                                         if ((((intent.getAction() != null) &amp;&amp; (intent.getCategories() != null)) &amp;&amp; intent.getAction().equals(Intent.ACTION_MAIN)) &amp;&amp; intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {">1919                                         if ((((intent.getAction() != null) &amp;&amp; (intent.getCategories() != </abbr>
<abbr title="1920                                             intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);">1920                                             intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_A</abbr>
1921                                         }
1922                                     }
1923                                     if (info != null) {
1924                                         info.id = id;
1925                                         info.intent = intent;
1926                                         container = c.getInt(containerIndex);
1927                                         info.container = container;
1928                                         info.screenId = c.getInt(screenIndex);
1929                                         info.cellX = c.getInt(cellXIndex);
1930                                         info.cellY = c.getInt(cellYIndex);
1931                                         info.spanX = 1;
1932                                         info.spanY = 1;
1933                                         info.intent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);
<abbr title="1934                                         info.isDisabled = isSafeMode &amp;&amp; (!Utilities.isSystemApp(context, intent));">1934                                         info.isDisabled = isSafeMode &amp;&amp; (!Utilities.isSystemApp(context, </abbr>
1935                                         // check &amp; update map of what&#x27;s occupied
1936                                         deleteOnInvalidPlacement.set(false);
<abbr title="1937                                         if (!checkItemPlacement(occupied, info, deleteOnInvalidPlacement)) {">1937                                         if (!checkItemPlacement(occupied, info, deleteOnInvalidPlacement)</abbr>
1938                                             if (deleteOnInvalidPlacement.get()) {
1939                                                 itemsToRemove.add(id);
1940                                             }
1941                                             break;
1942                                         }
1943                                         switch (container) {
1944                                             case LauncherSettings.Favorites.CONTAINER_DESKTOP :
1945                                             case LauncherSettings.Favorites.CONTAINER_HOTSEAT :
1946                                                 sBgWorkspaceItems.add(info);
1947                                                 break;
1948                                             default :
1949                                         // Item is in a user folder
<abbr title="1950                                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, container);">1950                                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, cont</abbr>
1951                                                 folderInfo.add(info);
1952                                                 break;
1953                                         }
1954                                         sBgItemsIdMap.put(info.id, info);
1955                                         // now that we&#x27;ve loaded everthing re-save it with the
1956                                         // icon in case it disappears somehow.
1957                                         queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
1958                                     } else {
1959                                         throw new RuntimeException(&quot;Unexpected null ShortcutInfo&quot;);
1960                                     }
1961                                     break;
1962                                 case LauncherSettings.Favorites.ITEM_TYPE_FOLDER :
1963                                     id = c.getLong(idIndex);
1964                                     FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
1965                                     folderInfo.title = c.getString(titleIndex);
1966                                     folderInfo.id = id;
1967                                     container = c.getInt(containerIndex);
1968                                     folderInfo.container = container;
1969                                     folderInfo.screenId = c.getInt(screenIndex);
1970                                     folderInfo.cellX = c.getInt(cellXIndex);
1971                                     folderInfo.cellY = c.getInt(cellYIndex);
1972                                     folderInfo.spanX = 1;
1973                                     folderInfo.spanY = 1;
1974                                     // check &amp; update map of what&#x27;s occupied
1975                                     deleteOnInvalidPlacement.set(false);
<abbr title="1976                                     if (!checkItemPlacement(occupied, folderInfo, deleteOnInvalidPlacement)) {">1976                                     if (!checkItemPlacement(occupied, folderInfo, deleteOnInvalidPlacemen</abbr>
1977                                         if (deleteOnInvalidPlacement.get()) {
1978                                             itemsToRemove.add(id);
1979                                         }
1980                                         break;
1981                                     }
1982                                     switch (container) {
1983                                         case LauncherSettings.Favorites.CONTAINER_DESKTOP :
1984                                         case LauncherSettings.Favorites.CONTAINER_HOTSEAT :
1985                                             sBgWorkspaceItems.add(folderInfo);
1986                                             break;
1987                                     }
1988                                     if (restored) {
1989                                         // no special handling required for restored folders
1990                                         restoredRows.add(id);
1991                                     }
1992                                     sBgItemsIdMap.put(folderInfo.id, folderInfo);
1993                                     sBgFolders.put(folderInfo.id, folderInfo);
1994                                     break;
1995                                 case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET :
1996                                     // Read all Launcher-specific widget details
1997                                     int appWidgetId = c.getInt(appWidgetIdIndex);
1998                                     String savedProvider = c.getString(appWidgetProviderIndex);
1999                                     id = c.getLong(idIndex);
<abbr title="2000                                     final ComponentName component = ComponentName.unflattenFromString(savedProvider);">2000                                     final ComponentName component = ComponentName.unflattenFromString(sav</abbr>
2001                                     final int restoreStatus = c.getInt(restoredIndex);
<abbr title="2002                                     final boolean isIdValid = (restoreStatus &amp; LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) == 0;">2002                                     final boolean isIdValid = (restoreStatus &amp; LauncherAppWidgetInfo.FLAG</abbr>
<abbr title="2003                                     final boolean wasProviderReady = (restoreStatus &amp; LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) == 0;">2003                                     final boolean wasProviderReady = (restoreStatus &amp; LauncherAppWidgetIn</abbr>
<abbr title="2004                                     final AppWidgetProviderInfo provider = (isIdValid) ? widgets.getAppWidgetInfo(appWidgetId) : findAppWidgetProviderInfoWithComponent(context, component);">2004                                     final AppWidgetProviderInfo provider = (isIdValid) ? widgets.getAppWi</abbr>
2005                                     final boolean isProviderReady = isValidProvider(provider);
2006                                     if (((!isSafeMode) &amp;&amp; wasProviderReady) &amp;&amp; (!isProviderReady)) {
<abbr title="2007                                         String log = (((&quot;Deleting widget that isn\&#x27;t installed anymore: &quot; + &quot;id=&quot;) + id) + &quot; appWidgetId=&quot;) + appWidgetId;">2007                                         String log = (((&quot;Deleting widget that isn\&#x27;t installed anymore: &quot;</abbr>
2008                                         Log.e(TAG, log);
2009                                         Launcher.addDumpLog(TAG, log, false);
2010                                         itemsToRemove.add(id);
2011                                     } else {
2012                                         if (isProviderReady) {
<abbr title="2013                                             appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId, provider.provider);">2013                                             appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId, provid</abbr>
<abbr title="2014                                             int[] minSpan = Launcher.getMinSpanForWidget(context, provider);">2014                                             int[] minSpan = Launcher.getMinSpanForWidget(context, provide</abbr>
2015                                             appWidgetInfo.minSpanX = minSpan[0];
2016                                             appWidgetInfo.minSpanY = minSpan[1];
2017                                             int status = restoreStatus;
2018                                             if (!wasProviderReady) {
2019                                                 // If provider was not previously ready, update the
2020                                                 // status and UI flag.
<abbr title="2021                                                 // Id would be valid only if the widget restore broadcast was received.">2021                                                 // Id would be valid only if the widget restore broadcast</abbr>
2022                                                 if (isIdValid) {
2023                                                     status = LauncherAppWidgetInfo.RESTORE_COMPLETED;
2024                                                 } else {
<abbr title="2025                                                     status &amp;= ~LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY;">2025                                                     status &amp;= ~LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_RE</abbr>
2026                                                 }
2027                                             }
2028                                             appWidgetInfo.restoreStatus = status;
2029                                         } else {
<abbr title="2030                                             Log.v(TAG, ((((&quot;Widget restore pending id=&quot; + id) + &quot; appWidgetId=&quot;) + appWidgetId) + &quot; status =&quot;) + restoreStatus);">2030                                             Log.v(TAG, ((((&quot;Widget restore pending id=&quot; + id) + &quot; appWidg</abbr>
<abbr title="2031                                             appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId, component);">2031                                             appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId, compon</abbr>
2032                                             appWidgetInfo.restoreStatus = restoreStatus;
<abbr title="2033                                             if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) != 0) {">2033                                             if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_START</abbr>
2034                                                 // Restore has started once.
<abbr title="2035                                             } else if (installingPkgs.contains(component.getPackageName())) {">2035                                             } else if (installingPkgs.contains(component.getPackageName()</abbr>
2036                                                 // App restore has started. Update the flag
<abbr title="2037                                                 appWidgetInfo.restoreStatus |= LauncherAppWidgetInfo.FLAG_RESTORE_STARTED;">2037                                                 appWidgetInfo.restoreStatus |= LauncherAppWidgetInfo.FLAG</abbr>
2038                                             } else if (REMOVE_UNRESTORED_ICONS) {
<abbr title="2039                                                 Launcher.addDumpLog(TAG, &quot;Unrestored widget removed: &quot; + component, true);">2039                                                 Launcher.addDumpLog(TAG, &quot;Unrestored widget removed: &quot; + </abbr>
2040                                                 itemsToRemove.add(id);
2041                                                 continue;
2042                                             }
2043                                         }
2044                                         appWidgetInfo.id = id;
2045                                         appWidgetInfo.screenId = c.getInt(screenIndex);
2046                                         appWidgetInfo.cellX = c.getInt(cellXIndex);
2047                                         appWidgetInfo.cellY = c.getInt(cellYIndex);
2048                                         appWidgetInfo.spanX = c.getInt(spanXIndex);
2049                                         appWidgetInfo.spanY = c.getInt(spanYIndex);
2050                                         container = c.getInt(containerIndex);
<abbr title="2051                                         if ((container != LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (container != LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {">2051                                         if ((container != LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;</abbr>
<abbr title="2052                                             Log.e(TAG, &quot;Widget found where container != &quot; + &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);">2052                                             Log.e(TAG, &quot;Widget found where container != &quot; + &quot;CONTAINER_DE</abbr>
2053                                             continue;
2054                                         }
2055                                         appWidgetInfo.container = c.getInt(containerIndex);
2056                                         // check &amp; update map of what&#x27;s occupied
2057                                         deleteOnInvalidPlacement.set(false);
<abbr title="2058                                         if (!checkItemPlacement(occupied, appWidgetInfo, deleteOnInvalidPlacement)) {">2058                                         if (!checkItemPlacement(occupied, appWidgetInfo, deleteOnInvalidP</abbr>
2059                                             if (deleteOnInvalidPlacement.get()) {
2060                                                 itemsToRemove.add(id);
2061                                             }
2062                                             break;
2063                                         }
<abbr title="2064                                         String providerName = appWidgetInfo.providerName.flattenToString();">2064                                         String providerName = appWidgetInfo.providerName.flattenToString(</abbr>
<abbr title="2065                                         if ((!providerName.equals(savedProvider)) || (appWidgetInfo.restoreStatus != restoreStatus)) {">2065                                         if ((!providerName.equals(savedProvider)) || (appWidgetInfo.resto</abbr>
2066                                             ContentValues values = new ContentValues();
<abbr title="2067                                             values.put(LauncherSettings.Favorites.APPWIDGET_PROVIDER, providerName);">2067                                             values.put(LauncherSettings.Favorites.APPWIDGET_PROVIDER, pro</abbr>
<abbr title="2068                                             values.put(LauncherSettings.Favorites.RESTORED, appWidgetInfo.restoreStatus);">2068                                             values.put(LauncherSettings.Favorites.RESTORED, appWidgetInfo</abbr>
2069                                             String where = BaseColumns._ID + &quot;= ?&quot;;
2070                                             String[] args = new java.lang.String[]{ Long.toString(id) };
2071                                             contentResolver.update(contentUri, values, where, args);
2072                                         }
2073                                         sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
2074                                         sBgAppWidgets.add(appWidgetInfo);
2075                                     }
2076                                     break;
2077                             }
2078                         } catch (java.lang.Exception e) {
2079                             Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;, e, true);
2080                         }
2081                     }
2082                 } finally {
2083                     if (c != null) {
2084                         c.close();
2085                     }
2086                 }
2087                 // Break early if we&#x27;ve stopped loading
2088                 if (mStopped) {
2089                     clearSBgDataStructures();
2090                     return false;
2091                 }
2092                 if (itemsToRemove.size() &gt; 0) {
<abbr title="2093                     ContentProviderClient client = contentResolver.acquireContentProviderClient(contentUri);">2093                     ContentProviderClient client = contentResolver.acquireContentProviderClient(contentUr</abbr>
2094                     // Remove dead items
2095                     for (long id : itemsToRemove) {
2096                         if (DEBUG_LOADERS) {
2097                             Log.d(TAG, &quot;Removed id = &quot; + id);
2098                         }
2099                         // Don&#x27;t notify content observers
2100                         try {
<abbr title="2101                             client.delete(LauncherSettings.Favorites.getContentUri(id, false), null, null);">2101                             client.delete(LauncherSettings.Favorites.getContentUri(id, false), null, null</abbr>
2102                         } catch (RemoteException e) {
2103                             Log.w(TAG, &quot;Could not remove id = &quot; + id);
2104                         }
2105                     }
2106                 }
2107                 if (restoredRows.size() &gt; 0) {
<abbr title="2108                     ContentProviderClient updater = contentResolver.acquireContentProviderClient(contentUri);">2108                     ContentProviderClient updater = contentResolver.acquireContentProviderClient(contentU</abbr>
2109                     // Update restored items that no longer require special handling
2110                     try {
2111                         StringBuilder selectionBuilder = new StringBuilder();
2112                         selectionBuilder.append(LauncherSettings.Favorites._ID);
2113                         selectionBuilder.append(&quot; IN (&quot;);
2114                         selectionBuilder.append(TextUtils.join(&quot;, &quot;, restoredRows));
2115                         selectionBuilder.append(&quot;)&quot;);
2116                         ContentValues values = new ContentValues();
2117                         values.put(LauncherSettings.Favorites.RESTORED, 0);
<abbr title="2118                         updater.update(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values, selectionBuilder.toString(), null);">2118                         updater.update(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values, se</abbr>
2119                     } catch (RemoteException e) {
2120                         Log.w(TAG, &quot;Could not update restored rows&quot;);
2121                     }
2122                 }
2123                 if ((!isSdCardReady) &amp;&amp; (!sPendingPackages.isEmpty())) {
<abbr title="2124                     context.registerReceiver(new AppsAvailabilityCheck(), new IntentFilter(StartupReceiver.SYSTEM_READY), null, sWorker);">2124                     context.registerReceiver(new AppsAvailabilityCheck(), new IntentFilter(StartupReceive</abbr>
2125                 }
2126                 if (loadedOldDb) {
2127                     long maxScreenId = 0;
2128                     // If we&#x27;re importing we use the old screen order.
2129                     for (ItemInfo item : sBgItemsIdMap.values()) {
2130                         long screenId = item.screenId;
<abbr title="2131                         if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (!sBgWorkspaceScreens.contains(screenId))) {">2131                         if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (!sBgWork</abbr>
2132                             sBgWorkspaceScreens.add(screenId);
2133                             if (screenId &gt; maxScreenId) {
2134                                 maxScreenId = screenId;
2135                             }
2136                         }
2137                     }
2138                     Collections.sort(sBgWorkspaceScreens);
2139                     // Log to disk
2140                     Launcher.addDumpLog(TAG, &quot;11683562 -   maxScreenId: &quot; + maxScreenId, true);
<abbr title="2141                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; + TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);">2141                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; + TextUtils.join(&quot;, &quot;, </abbr>
2142                     LauncherAppState.getLauncherProvider().updateMaxScreenId(maxScreenId);
2143                     updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2144                     // Update the max item id after we load an old db
2145                     long maxItemId = 0;
2146                     // If we&#x27;re importing we use the old screen order.
2147                     for (ItemInfo item : sBgItemsIdMap.values()) {
2148                         maxItemId = Math.max(maxItemId, item.id);
2149                     }
2150                     LauncherAppState.getLauncherProvider().updateMaxItemId(maxItemId);
2151                 } else {
2152                     TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(mContext);
2153                     for (Integer i : orderedScreens.keySet()) {
2154                         sBgWorkspaceScreens.add(orderedScreens.get(i));
2155                     }
2156                     // Log to disk
<abbr title="2157                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; + TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);">2157                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; + TextUtils.join(&quot;, &quot;, </abbr>
2158                     // Remove any empty screens
2159                     ArrayList&lt;Long&gt; unusedScreens = new ArrayList&lt;Long&gt;(sBgWorkspaceScreens);
2160                     for (ItemInfo item : sBgItemsIdMap.values()) {
2161                         long screenId = item.screenId;
<abbr title="2162                         if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; unusedScreens.contains(screenId)) {">2162                         if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; unusedScr</abbr>
2163                             unusedScreens.remove(screenId);
2164                         }
2165                     }
2166                     // If there are any empty screens remove them, and update.
2167                     if (unusedScreens.size() != 0) {
2168                         // Log to disk
<abbr title="2169                         Launcher.addDumpLog(TAG, &quot;11683562 -   unusedScreens (to be removed): &quot; + TextUtils.join(&quot;, &quot;, unusedScreens), true);">2169                         Launcher.addDumpLog(TAG, &quot;11683562 -   unusedScreens (to be removed): &quot; + TextUti</abbr>
2170                         sBgWorkspaceScreens.removeAll(unusedScreens);
2171                         updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2172                     }
2173                 }
2174                 if (DEBUG_LOADERS) {
2175                     Log.d(TAG, (&quot;loaded workspace in &quot; + (SystemClock.uptimeMillis() - t)) + &quot;ms&quot;);
2176                     Log.d(TAG, &quot;workspace layout: &quot;);
2177                     int nScreens = occupied.size();
2178                     for (int y = 0; y &lt; countY; y++) {
2179                         String line = &quot;&quot;;
2180                         Iterator&lt;Long&gt; iter = occupied.keySet().iterator();
2181                         while (iter.hasNext()) {
2182                             long screenId = iter.next();
2183                             if (screenId &gt; 0) {
2184                                 line += &quot; | &quot;;
2185                             }
2186                             for (int x = 0; x &lt; countX; x++) {
2187                                 ItemInfo[][] screen = occupied.get(screenId);
2188                                 if ((x &lt; screen.length) &amp;&amp; (y &lt; screen[x].length)) {
2189                                     line += (screen[x][y] != null) ? &quot;#&quot; : &quot;.&quot;;
2190                                 } else {
2191                                     line += &quot;!&quot;;
2192                                 }
2193                             }
2194                         }
2195                         Log.d(TAG, (&quot;[ &quot; + line) + &quot; ]&quot;);
2196                     }
2197                 }
2198             }
2199             return loadedOldDb;
2200         }
2201 
2202         /** Filters the set of items who are directly or indirectly (via another container) on the
2203          * specified screen. */
<abbr title="2204         private void filterCurrentWorkspaceItems(long currentScreenId, ArrayList&lt;ItemInfo&gt; allWorkspaceItems, ArrayList&lt;ItemInfo&gt; currentScreenItems, ArrayList&lt;ItemInfo&gt; otherScreenItems) {">2204         private void filterCurrentWorkspaceItems(long currentScreenId, ArrayList&lt;ItemInfo&gt; allWorkspaceIt</abbr>
2205             // Purge any null ItemInfos
2206             Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
2207             while (iter.hasNext()) {
2208                 ItemInfo i = iter.next();
2209                 if (i == null) {
2210                     iter.remove();
2211                 }
2212             }
2213             // Order the set of items by their containers first, this allows use to walk through the
2214             // list sequentially, build up a list of containers that are in the specified screen,
2215             // as well as all items in those containers.
2216             Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
2217             Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
2218                 @Override
2219                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2220                     return ((int) (lhs.container - rhs.container));
2221                 }
2222             });
2223             for (ItemInfo info : allWorkspaceItems) {
2224                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2225                     if (info.screenId == currentScreenId) {
2226                         currentScreenItems.add(info);
2227                         itemsOnScreen.add(info.id);
2228                     } else {
2229                         otherScreenItems.add(info);
2230                     }
2231                 } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2232                     currentScreenItems.add(info);
2233                     itemsOnScreen.add(info.id);
2234                 } else if (itemsOnScreen.contains(info.container)) {
2235                     currentScreenItems.add(info);
2236                     itemsOnScreen.add(info.id);
2237                 } else {
2238                     otherScreenItems.add(info);
2239                 }
2240             }
2241         }
2242 
2243         /** Filters the set of widgets which are on the specified screen. */
<abbr title="2244         private void filterCurrentAppWidgets(long currentScreenId, ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets, ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets, ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {">2244         private void filterCurrentAppWidgets(long currentScreenId, ArrayList&lt;LauncherAppWidgetInfo&gt; appWi</abbr>
2245             for (LauncherAppWidgetInfo widget : appWidgets) {
2246                 if (widget == null) {
2247                     continue;
2248                 }
<abbr title="2249                 if ((widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (widget.screenId == currentScreenId)) {">2249                 if ((widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (widget.screenI</abbr>
2250                     currentScreenWidgets.add(widget);
2251                 } else {
2252                     otherScreenWidgets.add(widget);
2253                 }
2254             }
2255         }
2256 
2257         /** Filters the set of folders which are on the specified screen. */
<abbr title="2258         private void filterCurrentFolders(long currentScreenId, HashMap&lt;Long, ItemInfo&gt; itemsIdMap, HashMap&lt;Long, FolderInfo&gt; folders, HashMap&lt;Long, FolderInfo&gt; currentScreenFolders, HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {">2258         private void filterCurrentFolders(long currentScreenId, HashMap&lt;Long, ItemInfo&gt; itemsIdMap, HashM</abbr>
2259             for (long id : folders.keySet()) {
2260                 ItemInfo info = itemsIdMap.get(id);
2261                 FolderInfo folder = folders.get(id);
2262                 if ((info == null) || (folder == null)) {
2263                     continue;
2264                 }
<abbr title="2265                 if ((info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (info.screenId == currentScreenId)) {">2265                 if ((info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (info.screenId ==</abbr>
2266                     currentScreenFolders.put(id, folder);
2267                 } else {
2268                     otherScreenFolders.put(id, folder);
2269                 }
2270             }
2271         }
2272 
2273         /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
2274          * right) */
2275         private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
2276             final LauncherAppState app = LauncherAppState.getInstance();
2277             final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2278             // XXX: review this
2279             Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
2280                 @Override
2281                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2282                     int cellCountX = ((int) (grid.numColumns));
2283                     int cellCountY = ((int) (grid.numRows));
2284                     int screenOffset = cellCountX * cellCountY;
2285                     int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1);// +1 hotseat
2286 
<abbr title="2287                     long lr = (((lhs.container * containerOffset) + (lhs.screenId * screenOffset)) + (lhs.cellY * cellCountX)) + lhs.cellX;">2287                     long lr = (((lhs.container * containerOffset) + (lhs.screenId * screenOffset)) + (lhs</abbr>
<abbr title="2288                     long rr = (((rhs.container * containerOffset) + (rhs.screenId * screenOffset)) + (rhs.cellY * cellCountX)) + rhs.cellX;">2288                     long rr = (((rhs.container * containerOffset) + (rhs.screenId * screenOffset)) + (rhs</abbr>
2289                     return ((int) (lr - rr));
2290                 }
2291             });
2292         }
2293 
2294         private void bindWorkspaceScreens(final Callbacks oldCallbacks,
2295                 final ArrayList&lt;Long&gt; orderedScreens) {
2296             final Runnable r = new Runnable() {
2297                 @Override
2298                 public void run() {
2299                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2300                     if (callbacks != null) {
2301                         callbacks.bindScreens(orderedScreens);
2302                     }
2303                 }
2304             };
2305             runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2306         }
2307 
<abbr title="2308         private void bindWorkspaceItems(final Callbacks oldCallbacks, final ArrayList&lt;ItemInfo&gt; workspaceItems, final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets, final HashMap&lt;Long, FolderInfo&gt; folders, ArrayList&lt;Runnable&gt; deferredBindRunnables) {">2308         private void bindWorkspaceItems(final Callbacks oldCallbacks, final ArrayList&lt;ItemInfo&gt; workspace</abbr>
2309             final boolean postOnMainThread = deferredBindRunnables != null;
2310             // Bind the workspace items
2311             int N = workspaceItems.size();
2312             for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
2313                 final int start = i;
2314                 final int chunkSize = ((i + ITEMS_CHUNK) &lt;= N) ? ITEMS_CHUNK : N - i;
2315                 final Runnable r = new Runnable() {
2316                     @Override
2317                     public void run() {
2318                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2319                         if (callbacks != null) {
2320                             callbacks.bindItems(workspaceItems, start, start + chunkSize, false);
2321                         }
2322                     }
2323                 };
2324                 if (postOnMainThread) {
2325                     synchronized(deferredBindRunnables) {
2326                         deferredBindRunnables.add(r);
2327                     }
2328                 } else {
2329                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2330                 }
2331             }
2332             // Bind the folders
2333             if (!folders.isEmpty()) {
2334                 final Runnable r = new Runnable() {
2335                     public void run() {
2336                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2337                         if (callbacks != null) {
2338                             callbacks.bindFolders(folders);
2339                         }
2340                     }
2341                 };
2342                 if (postOnMainThread) {
2343                     synchronized(deferredBindRunnables) {
2344                         deferredBindRunnables.add(r);
2345                     }
2346                 } else {
2347                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2348                 }
2349             }
2350             // Bind the widgets, one at a time
2351             N = appWidgets.size();
2352             for (int i = 0; i &lt; N; i++) {
2353                 final LauncherAppWidgetInfo widget = appWidgets.get(i);
2354                 final Runnable r = new Runnable() {
2355                     public void run() {
2356                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2357                         if (callbacks != null) {
2358                             callbacks.bindAppWidget(widget);
2359                         }
2360                     }
2361                 };
2362                 if (postOnMainThread) {
2363                     deferredBindRunnables.add(r);
2364                 } else {
2365                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2366                 }
2367             }
2368         }
2369 
2370         /**
2371          * Binds all loaded data to actual views on the main thread.
2372          */
2373         private void bindWorkspace(int synchronizeBindPage, final boolean isUpgradePath) {
2374             final long t = SystemClock.uptimeMillis();
2375             Runnable r;
2376             // Don&#x27;t use these two variables in any of the callback runnables.
2377             // Otherwise we hold a reference to them.
2378             final Callbacks oldCallbacks = mCallbacks.get();
2379             if (oldCallbacks == null) {
2380                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2381                 Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
2382                 return;
2383             }
2384             // Save a copy of all the bg-thread collections
2385             ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
2386             ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets = new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2387             HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
2388             HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
2389             ArrayList&lt;Long&gt; orderedScreenIds = new ArrayList&lt;Long&gt;();
2390             synchronized(sBgLock) {
2391                 workspaceItems.addAll(sBgWorkspaceItems);
2392                 appWidgets.addAll(sBgAppWidgets);
2393                 folders.putAll(sBgFolders);
2394                 itemsIdMap.putAll(sBgItemsIdMap);
2395                 orderedScreenIds.addAll(sBgWorkspaceScreens);
2396             }
2397             final boolean isLoadingSynchronously = synchronizeBindPage != PagedView.INVALID_RESTORE_PAGE;
<abbr title="2398             int currScreen = (isLoadingSynchronously) ? synchronizeBindPage : oldCallbacks.getCurrentWorkspaceScreen();">2398             int currScreen = (isLoadingSynchronously) ? synchronizeBindPage : oldCallbacks.getCurrentWork</abbr>
2399             if (currScreen &gt;= orderedScreenIds.size()) {
2400                 // There may be no workspace screens (just hotseat items and an empty page).
2401                 currScreen = PagedView.INVALID_RESTORE_PAGE;
2402             }
2403             final int currentScreen = currScreen;
<abbr title="2404             final long currentScreenId = (currentScreen &lt; 0) ? INVALID_SCREEN_ID : orderedScreenIds.get(currentScreen);">2404             final long currentScreenId = (currentScreen &lt; 0) ? INVALID_SCREEN_ID : orderedScreenIds.get(c</abbr>
2405             // Load all the items that are on the current page first (and in the process, unbind
2406             // all the existing workspace items before we call startBinding() below.
2407             unbindWorkspaceItemsOnMainThread();
2408             // Separate the items that are on the current screen, and all the other remaining items
2409             ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2410             ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2411             ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets = new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2412             ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets = new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2413             HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
2414             HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
<abbr title="2415             filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems, otherWorkspaceItems);">2415             filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems, otherWork</abbr>
2416             filterCurrentAppWidgets(currentScreenId, appWidgets, currentAppWidgets, otherAppWidgets);
2417             filterCurrentFolders(currentScreenId, itemsIdMap, folders, currentFolders, otherFolders);
2418             sortWorkspaceItemsSpatially(currentWorkspaceItems);
2419             sortWorkspaceItemsSpatially(otherWorkspaceItems);
2420             // Tell the workspace that we&#x27;re about to start binding items
2421             r = new Runnable() {
2422                 public void run() {
2423                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2424                     if (callbacks != null) {
2425                         callbacks.startBinding();
2426                     }
2427                 }
2428             };
2429             runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2430             bindWorkspaceScreens(oldCallbacks, orderedScreenIds);
2431             // Load items on the current page
<abbr title="2432             bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets, currentFolders, null);">2432             bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets, currentFolders, nu</abbr>
2433             if (isLoadingSynchronously) {
2434                 r = new Runnable() {
2435                     public void run() {
2436                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2437                         if ((callbacks != null) &amp;&amp; (currentScreen != PagedView.INVALID_RESTORE_PAGE)) {
2438                             callbacks.onPageBoundSynchronously(currentScreen);
2439                         }
2440                     }
2441                 };
2442                 runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2443             }
2444             // Load all the remaining pages (if we are loading synchronously, we want to defer this
2445             // work until after the first render)
2446             synchronized(mDeferredBindRunnables) {
2447                 mDeferredBindRunnables.clear();
2448             }
<abbr title="2449             bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders, isLoadingSynchronously ? mDeferredBindRunnables : null);">2449             bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders, isLoadin</abbr>
2450             // Tell the workspace that we&#x27;re done binding items
2451             r = new Runnable() {
2452                 public void run() {
2453                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2454                     if (callbacks != null) {
2455                         callbacks.finishBindingItems(isUpgradePath);
2456                     }
2457                     // If we&#x27;re profiling, ensure this is the last thing in the queue.
2458                     if (DEBUG_LOADERS) {
2459                         Log.d(TAG, (&quot;bound workspace in &quot; + (SystemClock.uptimeMillis() - t)) + &quot;ms&quot;);
2460                     }
2461                     mIsLoadingAndBindingWorkspace = false;
2462                 }
2463             };
2464             if (isLoadingSynchronously) {
2465                 synchronized(mDeferredBindRunnables) {
2466                     mDeferredBindRunnables.add(r);
2467                 }
2468             } else {
2469                 runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2470             }
2471         }
2472 
2473         private void loadAndBindAllApps() {
2474             if (DEBUG_LOADERS) {
2475                 Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
2476             }
2477             if (!mAllAppsLoaded) {
2478                 loadAllApps();
2479                 synchronized (LoaderTask.this) {
2480                     if (mStopped) {
2481                         return;
2482                     }
2483                     mAllAppsLoaded = true;
2484                 }
2485             } else {
2486                 onlyBindAllApps();
2487             }
2488         }
2489 
2490         private void onlyBindAllApps() {
2491             final Callbacks oldCallbacks = mCallbacks.get();
2492             if (oldCallbacks == null) {
2493                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2494                 Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
2495                 return;
2496             }
2497             // shallow copy
2498             @SuppressWarnings(&quot;unchecked&quot;)
2499             final ArrayList&lt;AppInfo&gt; list = ((ArrayList&lt;AppInfo&gt;) (mBgAllAppsList.data.clone()));
2500             Runnable r = new Runnable() {
2501                 public void run() {
2502                     final long t = SystemClock.uptimeMillis();
2503                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2504                     if (callbacks != null) {
2505                         callbacks.bindAllApplications(list);
2506                     }
2507                     if (DEBUG_LOADERS) {
<abbr title="2508                         Log.d(TAG, (((&quot;bound all &quot; + list.size()) + &quot; apps from cache in &quot;) + (SystemClock.uptimeMillis() - t)) + &quot;ms&quot;);">2508                         Log.d(TAG, (((&quot;bound all &quot; + list.size()) + &quot; apps from cache in &quot;) + (SystemCloc</abbr>
2509                     }
2510                 }
2511             };
2512             boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
2513             if (isRunningOnMainThread) {
2514                 r.run();
2515             } else {
2516                 mHandler.post(r);
2517             }
2518         }
2519 
2520         private void loadAllApps() {
2521             final long loadTime = (DEBUG_LOADERS) ? SystemClock.uptimeMillis() : 0;
2522             final Callbacks oldCallbacks = mCallbacks.get();
2523             if (oldCallbacks == null) {
2524                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2525                 Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllApps)&quot;);
2526                 return;
2527             }
2528             final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
2529             mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2530             final List&lt;UserHandleCompat&gt; profiles = mUserManager.getUserProfiles();
2531             // Clear the list of apps
2532             mBgAllAppsList.clear();
2533             for (UserHandleCompat user : profiles) {
2534                 // Query for the set of apps
2535                 final long qiaTime = (DEBUG_LOADERS) ? SystemClock.uptimeMillis() : 0;
2536                 List&lt;LauncherActivityInfoCompat&gt; apps = mLauncherApps.getActivityList(null, user);
2537                 if (DEBUG_LOADERS) {
<abbr title="2538                     Log.d(TAG, ((&quot;getActivityList took &quot; + (SystemClock.uptimeMillis() - qiaTime)) + &quot;ms for user &quot;) + user);">2538                     Log.d(TAG, ((&quot;getActivityList took &quot; + (SystemClock.uptimeMillis() - qiaTime)) + &quot;ms </abbr>
2539                     Log.d(TAG, ((&quot;getActivityList got &quot; + apps.size()) + &quot; apps for user &quot;) + user);
2540                 }
2541             // Fail if we don&#x27;t have any apps
2542                 if ((apps == null) || apps.isEmpty()) {
2543                     return;
2544                 }
2545                 // Sort the applications by name
2546                 final long sortTime = (DEBUG_LOADERS) ? SystemClock.uptimeMillis() : 0;
2547                 Collections.sort(apps, new LauncherModel.ShortcutNameComparator(mLabelCache));
2548                 if (DEBUG_LOADERS) {
2549                     Log.d(TAG, (&quot;sort took &quot; + (SystemClock.uptimeMillis() - sortTime)) + &quot;ms&quot;);
2550                 }
2551             // Create the ApplicationInfos
2552                 for (int i = 0; i &lt; apps.size(); i++) {
2553                     LauncherActivityInfoCompat app = apps.get(i);
2554                 // This builds the icon bitmaps.
2555                     mBgAllAppsList.add(new AppInfo(mContext, app, user, mIconCache, mLabelCache));
2556                 }
2557             }
2558             // Huh? Shouldn&#x27;t this be inside the Runnable below?
2559             final ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added;
2560             mBgAllAppsList.added = new ArrayList&lt;AppInfo&gt;();
2561             // Post callback on main thread
2562             mHandler.post(new Runnable() {
2563                 public void run() {
2564                     final long bindTime = SystemClock.uptimeMillis();
2565                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2566                     if (callbacks != null) {
2567                         callbacks.bindAllApplications(added);
2568                         if (DEBUG_LOADERS) {
<abbr title="2569                             Log.d(TAG, (((&quot;bound &quot; + added.size()) + &quot; apps in &quot;) + (SystemClock.uptimeMillis() - bindTime)) + &quot;ms&quot;);">2569                             Log.d(TAG, (((&quot;bound &quot; + added.size()) + &quot; apps in &quot;) + (SystemClock.uptimeMi</abbr>
2570                         }
2571                     } else {
2572                         Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
2573                     }
2574                 }
2575             });
2576             if (DEBUG_LOADERS) {
2577                 Log.d(TAG, (&quot;Icons processed in &quot; + (SystemClock.uptimeMillis() - loadTime)) + &quot;ms&quot;);
2578             }
2579         }
2580 
2581         public void dumpState() {
2582             synchronized(sBgLock) {
2583                 Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
2584                 Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
2585                 Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
2586                 Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
2587                 Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
2588             }
2589         }
2590     }
2591 
2592     void enqueuePackageUpdated(PackageUpdatedTask task) {
2593         sWorker.post(task);
2594     }
2595 
2596     private class AppsAvailabilityCheck extends BroadcastReceiver {
2597         @Override
2598         public void onReceive(Context context, Intent intent) {
2599             synchronized(sBgLock) {
<abbr title="2600                 final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(mApp.getContext());">2600                 final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(mApp.getContext())</abbr>
2601                 ArrayList&lt;String&gt; packagesRemoved;
2602                 for (Entry&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; entry : sPendingPackages.entrySet()) {
2603                     UserHandleCompat user = entry.getKey();
2604                     packagesRemoved = new ArrayList&lt;String&gt;();
2605                     for (String pkg : entry.getValue()) {
2606                         if (!launcherApps.isPackageEnabledForProfile(pkg, user)) {
2607                             Launcher.addDumpLog(TAG, &quot;Package not found: &quot; + pkg, true);
2608                             packagesRemoved.add(pkg);
2609                         }
2610                     }
2611                     if (!packagesRemoved.isEmpty()) {
<abbr title="2612                         enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_REMOVE, packagesRemoved.toArray(new String[packagesRemoved.size()]), user));">2612                         enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_REMOVE, packag</abbr>
2613                     }
2614                 }
2615                 sPendingPackages.clear();
2616             }
2617         }
2618     }
2619 
2620     /**
2621      * Workaround to re-check unrestored items, in-case they were installed but the Package-ADD
2622      * runnable was missed by the launcher.
2623      */
2624     public void recheckRestoredItems(final Context context) {
2625         Runnable r = new Runnable() {
2626             @Override
2627             public void run() {
2628                 LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
2629                 HashSet&lt;String&gt; installedPackages = new HashSet&lt;String&gt;();
2630                 UserHandleCompat user = UserHandleCompat.myUserHandle();
2631                 synchronized(sBgLock) {
2632                     for (ItemInfo info : sBgItemsIdMap.values()) {
2633                         if (info instanceof ShortcutInfo) {
2634                             ShortcutInfo si = ((ShortcutInfo) (info));
<abbr title="2635                             if ((si.isPromise() &amp;&amp; (si.getTargetComponent() != null)) &amp;&amp; launcherApps.isPackageEnabledForProfile(si.getTargetComponent().getPackageName(), user)) {">2635                             if ((si.isPromise() &amp;&amp; (si.getTargetComponent() != null)) &amp;&amp; launcherApps.isP</abbr>
2636                                 installedPackages.add(si.getTargetComponent().getPackageName());
2637                             }
2638                         } else if (info instanceof LauncherAppWidgetInfo) {
2639                             LauncherAppWidgetInfo widget = ((LauncherAppWidgetInfo) (info));
<abbr title="2640                             if (widget.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) &amp;&amp; launcherApps.isPackageEnabledForProfile(widget.providerName.getPackageName(), user)) {">2640                             if (widget.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) &amp;&amp; l</abbr>
2641                                 installedPackages.add(widget.providerName.getPackageName());
2642                             }
2643                         }
2644                     }
2645                 }
2646                 if (!installedPackages.isEmpty()) {
2647                     final ArrayList&lt;AppInfo&gt; restoredApps = new ArrayList&lt;AppInfo&gt;();
2648                     for (String pkg : installedPackages) {
2649                         for (LauncherActivityInfoCompat info : launcherApps.getActivityList(pkg, user)) {
2650                             restoredApps.add(new AppInfo(context, info, user, mIconCache, null));
2651                         }
2652                     }
2653                     final Callbacks callbacks = (mCallbacks != null) ? mCallbacks.get() : null;
2654                     if (!restoredApps.isEmpty()) {
2655                         mHandler.post(new Runnable() {
2656                             public void run() {
2657                                 Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
2658                                 if ((callbacks == cb) &amp;&amp; (cb != null)) {
2659                                     callbacks.bindAppsRestored(restoredApps);
2660                                 }
2661                             }
2662                         });
2663                     }
2664                 }
2665             }
2666         };
2667         sWorker.post(r);
2668     }
2669 
2670     private class PackageUpdatedTask implements Runnable {
2671         int mOp;
2672 
2673         String[] mPackages;
2674 
2675         UserHandleCompat mUser;
2676 
2677         public static final int OP_NONE = 0;
2678 
2679         public static final int OP_ADD = 1;
2680 
2681         public static final int OP_UPDATE = 2;
2682 
2683         // uninstlled
2684         public static final int OP_REMOVE = 3; // uninstlled
2685 
2686         // external media unmounted
2687         public static final int OP_UNAVAILABLE = 4; // external media unmounted
2688 
2689         public PackageUpdatedTask(int op, String[] packages, UserHandleCompat user) {
2690             mOp = op;
2691             mPackages = packages;
2692             mUser = user;
2693         }
2694 
2695         public void run() {
2696             final Context context = mApp.getContext();
2697             final String[] packages = mPackages;
2698             final int N = packages.length;
2699             switch (mOp) {
2700                 case OP_ADD :
2701                     for (int i = 0; i &lt; N; i++) {
2702                         if (DEBUG_LOADERS) {
2703                             Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
2704                         }
2705                         mIconCache.remove(packages[i], mUser);
2706                         mBgAllAppsList.addPackage(context, packages[i], mUser);
2707                     }
2708                     break;
2709                 case OP_UPDATE :
2710                     for (int i = 0; i &lt; N; i++) {
2711                         if (DEBUG_LOADERS) {
2712                             Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
2713                         }
2714                         mBgAllAppsList.updatePackage(context, packages[i], mUser);
<abbr title="2715                         WidgetPreviewLoader.removePackageFromDb(mApp.getWidgetPreviewCacheDb(), packages[i]);">2715                         WidgetPreviewLoader.removePackageFromDb(mApp.getWidgetPreviewCacheDb(), packages[</abbr>
2716                     }
2717                     break;
2718                 case OP_REMOVE :
2719                 case OP_UNAVAILABLE :
2720                     for (int i = 0; i &lt; N; i++) {
2721                         if (DEBUG_LOADERS) {
2722                             Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
2723                         }
2724                         mBgAllAppsList.removePackage(packages[i], mUser);
<abbr title="2725                         WidgetPreviewLoader.removePackageFromDb(mApp.getWidgetPreviewCacheDb(), packages[i]);">2725                         WidgetPreviewLoader.removePackageFromDb(mApp.getWidgetPreviewCacheDb(), packages[</abbr>
2726                     }
2727                     break;
2728             }
2729             ArrayList&lt;AppInfo&gt; added = null;
2730             ArrayList&lt;AppInfo&gt; modified = null;
2731             final ArrayList&lt;AppInfo&gt; removedApps = new ArrayList&lt;AppInfo&gt;();
2732             if (mBgAllAppsList.added.size() &gt; 0) {
2733                 added = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.added);
2734                 mBgAllAppsList.added.clear();
2735             }
2736             if (mBgAllAppsList.modified.size() &gt; 0) {
2737                 modified = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.modified);
2738                 mBgAllAppsList.modified.clear();
2739             }
2740             if (mBgAllAppsList.removed.size() &gt; 0) {
2741                 removedApps.addAll(mBgAllAppsList.removed);
2742                 mBgAllAppsList.removed.clear();
2743             }
2744             final Callbacks callbacks = (mCallbacks != null) ? mCallbacks.get() : null;
2745             if (callbacks == null) {
2746                 Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
2747                 return;
2748             }
2749             if (added != null) {
2750                 // Ensure that we add all the workspace applications to the db
2751                 if (LauncherAppState.isDisableAllApps()) {
2752                     final ArrayList&lt;ItemInfo&gt; addedInfos = new ArrayList&lt;ItemInfo&gt;(added);
2753                     addAndBindAddedWorkspaceApps(context, addedInfos);
2754                 } else {
2755                     addAppsToAllApps(context, added);
2756                 }
2757             }
2758             if (modified != null) {
2759                 final ArrayList&lt;AppInfo&gt; modifiedFinal = modified;
2760                 // Update the launcher db to reflect the changes
2761                 for (AppInfo a : modifiedFinal) {
2762                     ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName, mUser);
2763                     for (ItemInfo i : infos) {
2764                         if (isShortcutInfoUpdateable(i)) {
2765                             ShortcutInfo info = ((ShortcutInfo) (i));
2766                             info.title = a.title.toString();
2767                             info.contentDescription = a.contentDescription;
2768                             updateItemInDatabase(context, info);
2769                         }
2770                     }
2771                 }
2772                 mHandler.post(new Runnable() {
2773                     public void run() {
2774                         Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
2775                         if ((callbacks == cb) &amp;&amp; (cb != null)) {
2776                             callbacks.bindAppsUpdated(modifiedFinal);
2777                         }
2778                     }
2779                 });
2780             }
2781             final ArrayList&lt;String&gt; removedPackageNames = new ArrayList&lt;String&gt;();
2782             if (mOp == OP_REMOVE) {
2783                 // Mark all packages in the broadcast to be removed
2784                 removedPackageNames.addAll(Arrays.asList(packages));
2785             } else if (mOp == OP_UPDATE) {
2786                 // Mark disabled packages in the broadcast to be removed
2787                 final PackageManager pm = context.getPackageManager();
2788                 for (int i = 0; i &lt; N; i++) {
2789                     if (isPackageDisabled(context, packages[i], mUser)) {
2790                         removedPackageNames.add(packages[i]);
2791                     }
2792                 }
2793             }
2794             // Remove all the components associated with this package
2795             for (String pn : removedPackageNames) {
2796                 deletePackageFromDatabase(context, pn, mUser);
2797             }
2798             // Remove all the specific components
2799             for (AppInfo a : removedApps) {
2800                 ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName, mUser);
2801                 deleteItemsFromDatabase(context, infos);
2802             }
2803             if ((!removedPackageNames.isEmpty()) || (!removedApps.isEmpty())) {
2804                 // Remove any queued items from the install queue
2805                 String spKey = LauncherAppState.getSharedPreferencesKey();
2806                 SharedPreferences sp = context.getSharedPreferences(spKey, Context.MODE_PRIVATE);
2807                 InstallShortcutReceiver.removeFromInstallQueue(sp, removedPackageNames);
2808                 // Call the components-removed callback
2809                 mHandler.post(new Runnable() {
2810                     public void run() {
2811                         Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
2812                         if ((callbacks == cb) &amp;&amp; (cb != null)) {
2813                             callbacks.bindComponentsRemoved(removedPackageNames, removedApps, mUser);
2814                         }
2815                     }
2816                 });
2817             }
2818             final ArrayList&lt;Object&gt; widgetsAndShortcuts = getSortedWidgetsAndShortcuts(context);
2819             mHandler.post(new Runnable() {
2820                 @Override
2821                 public void run() {
2822                     Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
2823                     if ((callbacks == cb) &amp;&amp; (cb != null)) {
2824                         callbacks.bindPackagesUpdated(widgetsAndShortcuts);
2825                     }
2826                 }
2827             });
2828             // Write all the logs to disk
2829             mHandler.post(new Runnable() {
2830                 public void run() {
2831                     Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
2832                     if ((callbacks == cb) &amp;&amp; (cb != null)) {
2833                         callbacks.dumpLogsToLocalData();
2834                     }
2835                 }
2836             });
2837         }
2838     }
2839 
2840     // Returns a list of ResolveInfos/AppWindowInfos in sorted order
2841     public static ArrayList&lt;Object&gt; getSortedWidgetsAndShortcuts(Context context) {
2842         PackageManager packageManager = context.getPackageManager();
2843         final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();
2844         widgetsAndShortcuts.addAll(AppWidgetManagerCompat.getInstance(context).getAllProviders());
2845         Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
2846         widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));
2847         Collections.sort(widgetsAndShortcuts, new WidgetAndShortcutNameComparator(context));
2848         return widgetsAndShortcuts;
2849     }
2850 
<abbr title="2851     private static boolean isPackageDisabled(Context context, String packageName, UserHandleCompat user) {">2851     private static boolean isPackageDisabled(Context context, String packageName, UserHandleCompat user) </abbr>
2852         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
2853         return !launcherApps.isPackageEnabledForProfile(packageName, user);
2854     }
2855 
<abbr title="2856     public static boolean isValidPackageActivity(Context context, ComponentName cn, UserHandleCompat user) {">2856     public static boolean isValidPackageActivity(Context context, ComponentName cn, UserHandleCompat user</abbr>
2857         if (cn == null) {
2858             return false;
2859         }
2860         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
2861         if (!launcherApps.isPackageEnabledForProfile(cn.getPackageName(), user)) {
2862             return false;
2863         }
2864         return launcherApps.isActivityEnabledForProfile(cn, user);
2865     }
2866 
2867     public static boolean isValidPackage(Context context, String packageName, UserHandleCompat user) {
2868         if (packageName == null) {
2869             return false;
2870         }
2871         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
2872         return launcherApps.isPackageEnabledForProfile(packageName, user);
2873     }
2874 
2875     /**
2876      * Make an ShortcutInfo object for a restored application or shortcut item that points
2877      * to a package that is not yet installed on the system.
2878      */
<abbr title="2879     public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex, Intent intent, int promiseType) {">2879     public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex, Intent intent, int promiseType</abbr>
2880         final ShortcutInfo info = new ShortcutInfo();
2881         info.user = UserHandleCompat.myUserHandle();
2882         mIconCache.getTitleAndIcon(info, intent, info.user, true);
2883         if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_ICON) != 0) {
2884             String title = (cursor != null) ? cursor.getString(titleIndex) : null;
2885             if (!TextUtils.isEmpty(title)) {
2886                 info.title = title;
2887             }
2888             info.status = ShortcutInfo.FLAG_RESTORED_ICON;
2889         } else if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
2890             if (TextUtils.isEmpty(info.title)) {
2891                 info.title = (cursor != null) ? cursor.getString(titleIndex) : &quot;&quot;;
2892             }
2893             info.status = ShortcutInfo.FLAG_AUTOINTALL_ICON;
2894         } else {
2895             throw new InvalidParameterException(&quot;Invalid restoreType &quot; + promiseType);
2896         }
2897         info.contentDescription = mUserManager.getBadgedLabelForUser(info.title.toString(), info.user);
2898         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
2899         info.promisedIntent = intent;
2900         return info;
2901     }
2902 
2903     /**
2904      * Make an Intent object for a restored application or shortcut item that points
2905      * to the market page for the item.
2906      */
2907     private Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {
2908         ComponentName componentName = intent.getComponent();
2909         return getMarketIntent(componentName.getPackageName());
2910     }
2911 
2912     static Intent getMarketIntent(String packageName) {
<abbr title="2913         return new Intent(Intent.ACTION_VIEW).setData(new Uri.Builder().scheme(&quot;market&quot;).authority(&quot;details&quot;).appendQueryParameter(&quot;id&quot;, packageName).build());">2913         return new Intent(Intent.ACTION_VIEW).setData(new Uri.Builder().scheme(&quot;market&quot;).authority(&quot;detai</abbr>
2914     }
2915 
2916     /**
2917      * This is called from the code that adds shortcuts from the intent receiver.  This
2918      * doesn&#x27;t have a Cursor, but
2919      */
<abbr title="2920     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, UserHandleCompat user, Context context) {">2920     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, UserHandleCompat user, Con</abbr>
2921         return getShortcutInfo(manager, intent, user, context, null, -1, -1, null, false);
2922     }
2923 
2924     /**
2925      * Make an ShortcutInfo object for a shortcut that is an application.
2926      *
2927      * If c is not null, then it will be used to fill in missing data like the title and icon.
2928      */
<abbr title="2929     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, UserHandleCompat user, Context context, Cursor c, int iconIndex, int titleIndex, HashMap&lt;Object, CharSequence&gt; labelCache, boolean allowMissingTarget) {">2929     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, UserHandleCompat user, Con</abbr>
2930         if (user == null) {
2931             Log.d(TAG, &quot;Null user found in getShortcutInfo&quot;);
2932             return null;
2933         }
2934         ComponentName componentName = intent.getComponent();
2935         if (componentName == null) {
2936             Log.d(TAG, &quot;Missing component found in getShortcutInfo: &quot; + componentName);
2937             return null;
2938         }
2939         Intent newIntent = new Intent(intent.getAction(), null);
2940         newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2941         newIntent.setComponent(componentName);
2942         LauncherActivityInfoCompat lai = mLauncherApps.resolveActivity(newIntent, user);
2943         if ((lai == null) &amp;&amp; (!allowMissingTarget)) {
2944             Log.d(TAG, &quot;Missing activity found in getShortcutInfo: &quot; + componentName);
2945             return null;
2946         }
2947         final ShortcutInfo info = new ShortcutInfo();
2948         // the resource -- This may implicitly give us back the fallback icon,
2949         // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
2950         // to avoid saving lots of copies of that in the database, and most apps
2951         // have icons anyway.
2952         Bitmap icon = mIconCache.getIcon(componentName, lai, labelCache);
2953         // the db
2954         if (icon == null) {
2955             if (c != null) {
2956                 icon = getIconFromCursor(c, iconIndex, context);
2957             }
2958         }
2959         // the fallback icon
2960         if (icon == null) {
2961             icon = mIconCache.getDefaultIcon(user);
2962             info.usingFallbackIcon = true;
2963         }
2964         info.setIcon(icon);
2965         // From the cache.
2966         if (labelCache != null) {
2967             info.title = labelCache.get(componentName);
2968         }
2969         // from the resource
2970         if ((info.title == null) &amp;&amp; (lai != null)) {
2971             info.title = lai.getLabel();
2972             if (labelCache != null) {
2973                 labelCache.put(componentName, info.title);
2974             }
2975         }
2976         // from the db
2977         if (info.title == null) {
2978             if (c != null) {
2979                 info.title = c.getString(titleIndex);
2980             }
2981         }
2982         // fall back to the class name of the activity
2983         if (info.title == null) {
2984             info.title = componentName.getClassName();
2985         }
2986         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
2987         info.user = user;
2988         info.contentDescription = mUserManager.getBadgedLabelForUser(info.title.toString(), info.user);
2989         return info;
2990     }
2991 
2992     static ArrayList&lt;ItemInfo&gt; filterItemInfos(Collection&lt;ItemInfo&gt; infos, ItemInfoFilter f) {
2993         HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();
2994         for (ItemInfo i : infos) {
2995             if (i instanceof ShortcutInfo) {
2996                 ShortcutInfo info = ((ShortcutInfo) (i));
2997                 ComponentName cn = info.getTargetComponent();
2998                 if ((cn != null) &amp;&amp; f.filterItem(null, info, cn)) {
2999                     filtered.add(info);
3000                 }
3001             } else if (i instanceof FolderInfo) {
3002                 FolderInfo info = ((FolderInfo) (i));
3003                 for (ShortcutInfo s : info.contents) {
3004                     ComponentName cn = s.getTargetComponent();
3005                     if ((cn != null) &amp;&amp; f.filterItem(info, s, cn)) {
3006                         filtered.add(s);
3007                     }
3008                 }
3009             } else if (i instanceof LauncherAppWidgetInfo) {
3010                 LauncherAppWidgetInfo info = ((LauncherAppWidgetInfo) (i));
3011                 ComponentName cn = info.providerName;
3012                 if ((cn != null) &amp;&amp; f.filterItem(null, info, cn)) {
3013                     filtered.add(info);
3014                 }
3015             }
3016         }
3017         return new ArrayList&lt;ItemInfo&gt;(filtered);
3018     }
3019 
<abbr title="3020     private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname, final UserHandleCompat user) {">3020     private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname, final UserHandleCo</abbr>
3021         ItemInfoFilter filter = new ItemInfoFilter() {
3022             @Override
3023             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
3024                 if (info.user == null) {
3025                     return cn.equals(cname);
3026                 } else {
3027                     return cn.equals(cname) &amp;&amp; info.user.equals(user);
3028                 }
3029             }
3030         };
3031         return filterItemInfos(sBgItemsIdMap.values(), filter);
3032     }
3033 
3034     public static boolean isShortcutInfoUpdateable(ItemInfo i) {
3035         if (i instanceof ShortcutInfo) {
3036             ShortcutInfo info = ((ShortcutInfo) (i));
3037             // We need to check for ACTION_MAIN otherwise getComponent() might
3038             // return null for some shortcuts (for instance, for shortcuts to
3039             // web pages.)
3040             Intent intent = info.intent;
3041             ComponentName name = intent.getComponent();
<abbr title="3042             if (((info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) &amp;&amp; Intent.ACTION_MAIN.equals(intent.getAction())) &amp;&amp; (name != null)) {">3042             if (((info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) &amp;&amp; Intent.ACTION_MAI</abbr>
3043                 return true;
3044             }
3045             // placeholder shortcuts get special treatment, let them through too.
3046             if (info.isPromise()) {
3047                 return true;
3048             }
3049         }
3050         return false;
3051     }
3052 
3053     /**
3054      * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
3055      */
<abbr title="3056     private ShortcutInfo getShortcutInfo(Cursor c, Context context, int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex, int titleIndex) {">3056     private ShortcutInfo getShortcutInfo(Cursor c, Context context, int iconTypeIndex, int iconPackageInd</abbr>
3057         Bitmap icon = null;
3058         final ShortcutInfo info = new ShortcutInfo();
3059         // Non-app shortcuts are only supported for current user.
3060         info.user = UserHandleCompat.myUserHandle();
3061         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3062         // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
3063         info.title = c.getString(titleIndex);
3064         int iconType = c.getInt(iconTypeIndex);
3065         switch (iconType) {
3066             case LauncherSettings.Favorites.ICON_TYPE_RESOURCE :
3067                 String packageName = c.getString(iconPackageIndex);
3068                 String resourceName = c.getString(iconResourceIndex);
3069                 PackageManager packageManager = context.getPackageManager();
3070                 info.customIcon = false;
3071             // the resource
3072                 try {
3073                     Resources resources = packageManager.getResourcesForApplication(packageName);
3074                     if (resources != null) {
3075                         final int id = resources.getIdentifier(resourceName, null, null);
<abbr title="3076                         icon = Utilities.createIconBitmap(mIconCache.getFullResIcon(resources, id), context);">3076                         icon = Utilities.createIconBitmap(mIconCache.getFullResIcon(resources, id), conte</abbr>
3077                     }
3078                 } catch (java.lang.Exception e) {
3079                     // drop this.  we have other places to look for icons
3080                 }
3081             // the db
3082                 if (icon == null) {
3083                     icon = getIconFromCursor(c, iconIndex, context);
3084                 }
3085             // the fallback icon
3086                 if (icon == null) {
3087                     icon = mIconCache.getDefaultIcon(info.user);
3088                     info.usingFallbackIcon = true;
3089                 }
3090                 break;
3091             case LauncherSettings.Favorites.ICON_TYPE_BITMAP :
3092                 icon = getIconFromCursor(c, iconIndex, context);
3093                 if (icon == null) {
3094                     icon = mIconCache.getDefaultIcon(info.user);
3095                     info.customIcon = false;
3096                     info.usingFallbackIcon = true;
3097                 } else {
3098                     info.customIcon = true;
3099                 }
3100                 break;
3101             default :
3102                 icon = mIconCache.getDefaultIcon(info.user);
3103                 info.usingFallbackIcon = true;
3104                 info.customIcon = false;
3105                 break;
3106         }
3107         info.setIcon(icon);
3108         return info;
3109     }
3110 
3111     Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
3112         // suppress dead code warning
3113         @SuppressWarnings(&quot;all&quot;)
3114         final boolean debug = false;
3115         if (debug) {
<abbr title="3116             Log.d(TAG, &quot;getIconFromCursor app=&quot; + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));">3116             Log.d(TAG, &quot;getIconFromCursor app=&quot; + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Fa</abbr>
3117         }
3118         byte[] data = c.getBlob(iconIndex);
3119         try {
<abbr title="3120             return Utilities.createIconBitmap(BitmapFactory.decodeByteArray(data, 0, data.length), context);">3120             return Utilities.createIconBitmap(BitmapFactory.decodeByteArray(data, 0, data.length), contex</abbr>
3121         } catch (java.lang.Exception e) {
3122             return null;
3123         }
3124     }
3125 
<abbr title="3126     ShortcutInfo addShortcut(Context context, Intent data, long container, int screen, int cellX, int cellY, boolean notify) {">3126     ShortcutInfo addShortcut(Context context, Intent data, long container, int screen, int cellX, int cel</abbr>
3127         final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
3128         if (info == null) {
3129             return null;
3130         }
3131         addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
3132         return info;
3133     }
3134 
3135     /**
3136      * Attempts to find an AppWidgetProviderInfo that matches the given component.
3137      */
<abbr title="3138     static AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context, ComponentName component) {">3138     static AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context, ComponentName co</abbr>
<abbr title="3139         List&lt;AppWidgetProviderInfo&gt; widgets = AppWidgetManager.getInstance(context).getInstalledProviders();">3139         List&lt;AppWidgetProviderInfo&gt; widgets = AppWidgetManager.getInstance(context).getInstalledProviders</abbr>
3140         for (AppWidgetProviderInfo info : widgets) {
3141             if (info.provider.equals(component)) {
3142                 return info;
3143             }
3144         }
3145         return null;
3146     }
3147 
3148     ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
3149         Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
3150         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
3151         Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
3152         if (intent == null) {
3153             // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
3154             Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
3155             return null;
3156         }
3157         Bitmap icon = null;
3158         boolean customIcon = false;
3159         ShortcutIconResource iconResource = null;
3160         if ((bitmap != null) &amp;&amp; (bitmap instanceof Bitmap)) {
3161             icon = Utilities.createIconBitmap(new FastBitmapDrawable(((Bitmap) (bitmap))), context);
3162             customIcon = true;
3163         } else {
3164             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
3165             if ((extra != null) &amp;&amp; (extra instanceof ShortcutIconResource)) {
3166                 try {
3167                     iconResource = ((ShortcutIconResource) (extra));
3168                     final PackageManager packageManager = context.getPackageManager();
<abbr title="3169                     Resources resources = packageManager.getResourcesForApplication(iconResource.packageName);">3169                     Resources resources = packageManager.getResourcesForApplication(iconResource.packageN</abbr>
3170                     final int id = resources.getIdentifier(iconResource.resourceName, null, null);
3171                     icon = Utilities.createIconBitmap(mIconCache.getFullResIcon(resources, id), context);
3172                 } catch (java.lang.Exception e) {
3173                     Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);
3174                 }
3175             }
3176         }
3177         final ShortcutInfo info = new ShortcutInfo();
3178         // Only support intents for current user for now. Intents sent from other
3179         // users wouldn&#x27;t get here without intent forwarding anyway.
3180         info.user = UserHandleCompat.myUserHandle();
3181         if (icon == null) {
3182             if (fallbackIcon != null) {
3183                 icon = fallbackIcon;
3184             } else {
3185                 icon = mIconCache.getDefaultIcon(info.user);
3186                 info.usingFallbackIcon = true;
3187             }
3188         }
3189         info.setIcon(icon);
3190         info.title = name;
3191         info.contentDescription = mUserManager.getBadgedLabelForUser(info.title.toString(), info.user);
3192         info.intent = intent;
3193         info.customIcon = customIcon;
3194         info.iconResource = iconResource;
3195         return info;
3196     }
3197 
<abbr title="3198     boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c, int iconIndex) {">3198     boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c, int iconInde</abbr>
3199         // If apps can&#x27;t be on SD, don&#x27;t even bother.
3200         if (!mAppsCanBeOnRemoveableStorage) {
3201             return false;
3202         }
3203         // If this icon doesn&#x27;t have a custom icon, check to see
3204         // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
3205         // we&#x27;re going to show, store what we are going to show back
3206         // into the DB.  We do this so when we&#x27;re loading, if the
3207         // package manager can&#x27;t find an icon (for example because
3208         // the app is on SD) then we can use that instead.
3209         if ((!info.customIcon) &amp;&amp; (!info.usingFallbackIcon)) {
3210             cache.put(info, c.getBlob(iconIndex));
3211             return true;
3212         }
3213         return false;
3214     }
3215 
3216     void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
3217         boolean needSave = false;
3218         try {
3219             if (data != null) {
3220                 Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
3221                 Bitmap loaded = info.getIcon(mIconCache);
3222                 needSave = !saved.sameAs(loaded);
3223             } else {
3224                 needSave = true;
3225             }
3226         } catch (java.lang.Exception e) {
3227             needSave = true;
3228         }
3229         if (needSave) {
3230             Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
3231             // This is slower than is ideal, but this only happens once
3232             // or when the app is updated with a new icon.
3233             updateItemInDatabase(context, info);
3234         }
3235     }
3236 
3237     /**
3238      * Return an existing FolderInfo object if we have encountered this ID previously,
3239      * or make a new one.
3240      */
3241     private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
3242         // See if a placeholder was created for us already
3243         FolderInfo folderInfo = folders.get(id);
3244         if (folderInfo == null) {
3245             // No placeholder -- create a new instance
3246             folderInfo = new FolderInfo();
3247             folders.put(id, folderInfo);
3248         }
3249         return folderInfo;
3250     }
3251 
3252     public static final Comparator&lt;AppInfo&gt; getAppNameComparator() {
3253         final Collator collator = Collator.getInstance();
3254         return new Comparator&lt;AppInfo&gt;() {
3255             public final int compare(AppInfo a, AppInfo b) {
3256                 if (a.user.equals(b.user)) {
3257                     int result = collator.compare(a.title.toString().trim(), b.title.toString().trim());
3258                     if (result == 0) {
3259                         result = a.componentName.compareTo(b.componentName);
3260                     }
3261                     return result;
3262                 } else {
3263                     // TODO Need to figure out rules for sorting
3264                     // profiles, this puts work second.
3265                     return a.user.toString().compareTo(b.user.toString());
3266                 }
3267             }
3268         };
3269     }
3270 
3271     public static final Comparator&lt;AppInfo&gt; APP_INSTALL_TIME_COMPARATOR = new Comparator&lt;AppInfo&gt;() {
3272         public final int compare(AppInfo a, AppInfo b) {
3273             if (a.firstInstallTime &lt; b.firstInstallTime) {
3274                 return 1;
3275             }
3276             if (a.firstInstallTime &gt; b.firstInstallTime) {
3277                 return -1;
3278             }
3279             return 0;
3280         }
3281     };
3282 
3283     static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
3284         if (info.activityInfo != null) {
3285             return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
3286         } else {
3287             return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
3288         }
3289     }
3290 
3291     public static class ShortcutNameComparator implements Comparator&lt;LauncherActivityInfoCompat&gt; {
3292         private Collator mCollator;
3293 
3294         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
3295 
3296         ShortcutNameComparator(PackageManager pm) {
3297             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
3298             mCollator = Collator.getInstance();
3299         }
3300 
3301         ShortcutNameComparator(HashMap&lt;Object, CharSequence&gt; labelCache) {
3302             mLabelCache = labelCache;
3303             mCollator = Collator.getInstance();
3304         }
3305 
3306         public final int compare(LauncherActivityInfoCompat a, LauncherActivityInfoCompat b) {
3307             String labelA;
3308             String labelB;
3309             ComponentName keyA = a.getComponentName();
3310             ComponentName keyB = b.getComponentName();
3311             if (mLabelCache.containsKey(keyA)) {
3312                 labelA = mLabelCache.get(keyA).toString();
3313             } else {
3314                 labelA = a.getLabel().toString().trim();
3315                 mLabelCache.put(keyA, labelA);
3316             }
3317             if (mLabelCache.containsKey(keyB)) {
3318                 labelB = mLabelCache.get(keyB).toString();
3319             } else {
3320                 labelB = b.getLabel().toString().trim();
3321                 mLabelCache.put(keyB, labelB);
3322             }
3323             return mCollator.compare(labelA, labelB);
3324         }
3325     }
3326 
3327     public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
3328         private final AppWidgetManagerCompat mManager;
3329 
3330         private final PackageManager mPackageManager;
3331 
3332         private final HashMap&lt;Object, String&gt; mLabelCache;
3333 
3334         private final Collator mCollator;
3335 
3336         WidgetAndShortcutNameComparator(Context context) {
3337             mManager = AppWidgetManagerCompat.getInstance(context);
3338             mPackageManager = context.getPackageManager();
3339             mLabelCache = new HashMap&lt;Object, String&gt;();
3340             mCollator = Collator.getInstance();
3341         }
3342 
3343         public final int compare(Object a, Object b) {
3344             String labelA;
3345             String labelB;
3346             if (mLabelCache.containsKey(a)) {
3347                 labelA = mLabelCache.get(a);
3348             } else {
<abbr title="3349                 labelA = (a instanceof AppWidgetProviderInfo) ? mManager.loadLabel(((AppWidgetProviderInfo) (a))) : ((ResolveInfo) (a)).loadLabel(mPackageManager).toString().trim();">3349                 labelA = (a instanceof AppWidgetProviderInfo) ? mManager.loadLabel(((AppWidgetProviderInf</abbr>
3350                 mLabelCache.put(a, labelA);
3351             }
3352             if (mLabelCache.containsKey(b)) {
3353                 labelB = mLabelCache.get(b);
3354             } else {
<abbr title="3355                 labelB = (b instanceof AppWidgetProviderInfo) ? mManager.loadLabel(((AppWidgetProviderInfo) (b))) : ((ResolveInfo) (b)).loadLabel(mPackageManager).toString().trim();">3355                 labelB = (b instanceof AppWidgetProviderInfo) ? mManager.loadLabel(((AppWidgetProviderInf</abbr>
3356                 mLabelCache.put(b, labelB);
3357             }
3358             return mCollator.compare(labelA, labelB);
3359         }
3360     }
3361 
3362     static boolean isValidProvider(AppWidgetProviderInfo provider) {
<abbr title="3363         return ((provider != null) &amp;&amp; (provider.provider != null)) &amp;&amp; (provider.provider.getPackageName() != null);">3363         return ((provider != null) &amp;&amp; (provider.provider != null)) &amp;&amp; (provider.provider.getPackageName()</abbr>
3364     }
3365 
3366     public void dumpState() {
3367         Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
3368         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
3369         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
3370         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
3371         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
3372         if (mLoaderTask != null) {
3373             mLoaderTask.dumpState();
3374         } else {
3375             Log.d(TAG, &quot;mLoaderTask=null&quot;);
3376         }
3377     }
3378 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher3;
  18  
  19  import android.app.SearchManager;
  20  import android.appwidget.AppWidgetManager;
  21  import android.appwidget.AppWidgetProviderInfo;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  22 -import android.content.*;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  23 +import android.content.BroadcastReceiver;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  24 +import android.content.ComponentName;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  25 +import android.content.ContentProviderClient;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  26 +import android.content.ContentProviderOperation;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  27 +import android.content.ContentResolver;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  28 +import android.content.ContentValues;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 +import android.content.Context;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  30 +import android.content.Intent;</span>
  31  import android.content.Intent.ShortcutIconResource;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  32 -import android.content.pm.ActivityInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  33 -import android.content.pm.PackageInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  34 +import android.content.IntentFilter;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  35 +import android.content.SharedPreferences;</span>
  36  import android.content.pm.PackageManager;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  37 -import android.content.pm.PackageManager.NameNotFoundException;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  38 +import android.content.pm.ProviderInfo;</span>
  39  import android.content.pm.ResolveInfo;
  40  import android.content.res.Configuration;
  41  import android.content.res.Resources;
  42  import android.database.Cursor;
  43  import android.graphics.Bitmap;
  44  import android.graphics.BitmapFactory;
  45  import android.net.Uri;
  46  import android.os.Environment;
  47  import android.os.Handler;
  48  import android.os.HandlerThread;
  49  import android.os.Parcelable;
  50  import android.os.Process;
  51  import android.os.RemoteException;
  52  import android.os.SystemClock;
  53  import android.provider.BaseColumns;
  54  import android.text.TextUtils;
  55  import android.util.Log;
  56  import android.util.Pair;
  57  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  58 -import com.android.launcher3.InstallWidgetReceiver.WidgetMimeTypeHandlerData;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  59 +import com.android.launcher3.compat.AppWidgetManagerCompat;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  60 +import com.android.launcher3.compat.LauncherActivityInfoCompat;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  61 +import com.android.launcher3.compat.LauncherAppsCompat;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  62 +import com.android.launcher3.compat.PackageInstallerCompat;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  63 +import com.android.launcher3.compat.PackageInstallerCompat.PackageInstallInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  64 +import com.android.launcher3.compat.UserHandleCompat;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  65 +import com.android.launcher3.compat.UserManagerCompat;</span>
  66  
  67  import java.lang.ref.WeakReference;
  68  import java.net.URISyntaxException;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  69 +import java.security.InvalidParameterException;</span>
  70  import java.text.Collator;
  71  import java.util.ArrayList;
  72  import java.util.Arrays;
  73  import java.util.Collection;
  74  import java.util.Collections;
  75  import java.util.Comparator;
  76  import java.util.HashMap;
  77  import java.util.HashSet;
  78  import java.util.Iterator;
  79  import java.util.List;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  80 +import java.util.Map.Entry;</span>
  81  import java.util.Set;
  82  import java.util.TreeMap;
  83  import java.util.concurrent.atomic.AtomicBoolean;
  84  
  85  /**
  86   * Maintains in-memory state of the Launcher. It is expected that there should be only one
  87   * LauncherModel object held in a static. Also provide APIs for updating the database state
  88   * for the Launcher.
  89   */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  90 -public class LauncherModel extends BroadcastReceiver {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  91 +public class LauncherModel extends BroadcastReceiver</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  92 +        implements LauncherAppsCompat.OnAppsChangedCallbackCompat {</span>
  93      static final boolean DEBUG_LOADERS = false;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  94 +    private static final boolean DEBUG_RECEIVER = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  95 +    private static final boolean REMOVE_UNRESTORED_ICONS = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  96 +</span>
  97      static final String TAG = &quot;Launcher.Model&quot;;
  98  
  99      // true = use a &quot;More Apps&quot; folder for non-workspace apps on upgrade
 100      // false = strew non-workspace apps across the workspace on upgrade
 101      public static final boolean UPGRADE_USE_MORE_APPS_FOLDER = false;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 102 -</span>
 103      public static final int LOADER_FLAG_NONE = 0;
 104      public static final int LOADER_FLAG_CLEAR_WORKSPACE = 1 &lt;&lt; 0;
 105      public static final int LOADER_FLAG_MIGRATE_SHORTCUTS = 1 &lt;&lt; 1;
 106  
 107      private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
 108      private static final long INVALID_SCREEN_ID = -1L;
 109  
 110      private final boolean mAppsCanBeOnRemoveableStorage;
 111      private final boolean mOldContentProviderExists;
 112  
 113      private final LauncherAppState mApp;
 114      private final Object mLock = new Object();
 115      private DeferredHandler mHandler = new DeferredHandler();
 116      private LoaderTask mLoaderTask;
 117      private boolean mIsLoaderTaskRunning;
 118      private volatile boolean mFlushingWorkerThread;
 119  
 120      // Specific runnable types that are run on the main thread deferred handler, this allows us to
 121      // clear all queued binding runnables when the Launcher activity is destroyed.
 122      private static final int MAIN_THREAD_NORMAL_RUNNABLE = 0;
 123      private static final int MAIN_THREAD_BINDING_RUNNABLE = 1;
 124  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 125 +    private static final String MIGRATE_AUTHORITY = &quot;com.android.launcher2.settings&quot;;</span>
 126  
 127      private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
 128      static {
 129          sWorkerThread.start();
 130      }
 131      private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
 132  
 133      // We start off with everything not loaded.  After that, we assume that
 134      // our monitoring of the package manager provides all updates and we never
 135      // need to do a requery.  These are only ever touched from the loader thread.
 136      private boolean mWorkspaceLoaded;
 137      private boolean mAllAppsLoaded;
 138  
 139      // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
 140      // pages as this delays the rotation process.  Instead, we wait for a callback from the first
 141      // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 142      // a normal load, we also clear this set of Runnables.
 143      static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 144  
 145      private WeakReference&lt;Callbacks&gt; mCallbacks;
 146  
 147      // &lt; only access in worker thread &gt;
 148      AllAppsList mBgAllAppsList;
 149  
 150      // The lock that must be acquired before referencing any static bg data structures.  Unlike
 151      // other locks, this one can generally be held long-term because we never expect any of these
 152      // static data structures to be referenced outside of the worker thread except on the first
 153      // load after configuration change.
 154      static final Object sBgLock = new Object();
 155  
 156      // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 157      // LauncherModel to their ids
 158      static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
 159  
 160      // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 161      //       created by LauncherModel that are directly on the home screen (however, no widgets or
 162      //       shortcuts within folders).
 163      static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 164  
 165      // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 166      static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 167          new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 168  
 169      // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 170      static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 171  
 172      // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 173      static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 174  
 175      // sBgWorkspaceScreens is the ordered set of workspace screens.
 176      static final ArrayList&lt;Long&gt; sBgWorkspaceScreens = new ArrayList&lt;Long&gt;();
 177  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 178 +    // sPendingPackages is a set of packages which could be on sdcard and are not available yet</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 179 +    static final HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; sPendingPackages =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 180 +            new HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 181 +</span>
 182      // &lt;/ only access in worker thread &gt;
 183  
 184      private IconCache mIconCache;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 185 -    private Bitmap mDefaultIcon;</span>
 186  
 187      protected int mPreviousConfigMcc;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 188 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 189 +    private final LauncherAppsCompat mLauncherApps;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 190 +    private final UserManagerCompat mUserManager;</span>
 191  
 192      public interface Callbacks {
 193          public boolean setLoadOnResume();
 194          public int getCurrentWorkspaceScreen();
 195          public void startBinding();
 196          public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end,
 197                                boolean forceAnimateIcons);
 198          public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 199          public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 200          public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 201          public void finishBindingItems(boolean upgradePath);
 202          public void bindAppWidget(LauncherAppWidgetInfo info);
 203          public void bindAllApplications(ArrayList&lt;AppInfo&gt; apps);
 204          public void bindAppsAdded(ArrayList&lt;Long&gt; newScreens,
 205                                    ArrayList&lt;ItemInfo&gt; addNotAnimated,
 206                                    ArrayList&lt;ItemInfo&gt; addAnimated,
 207                                    ArrayList&lt;AppInfo&gt; addedApps);
 208          public void bindAppsUpdated(ArrayList&lt;AppInfo&gt; apps);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 209 +        public void bindAppsRestored(ArrayList&lt;AppInfo&gt; apps);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 210 +        public void updatePackageState(ArrayList&lt;PackageInstallInfo&gt; installInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 211 +        public void updatePackageBadge(String packageName);</span>
 212          public void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 213 -                        ArrayList&lt;AppInfo&gt; appInfos);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 214 +                        ArrayList&lt;AppInfo&gt; appInfos, UserHandleCompat user);</span>
 215          public void bindPackagesUpdated(ArrayList&lt;Object&gt; widgetsAndShortcuts);
 216          public void bindSearchablesChanged();
 217          public boolean isAllAppsButtonRank(int rank);
 218          public void onPageBoundSynchronously(int page);
 219          public void dumpLogsToLocalData();
 220      }
 221  
 222      public interface ItemInfoFilter {
 223          public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn);
 224      }
 225  
 226      LauncherModel(LauncherAppState app, IconCache iconCache, AppFilter appFilter) {
 227          Context context = app.getContext();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 228 -        ContentResolver contentResolver = context.getContentResolver();</span>
 229  
 230          mAppsCanBeOnRemoveableStorage = Environment.isExternalStorageRemovable();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 231 -        mOldContentProviderExists = (contentResolver.acquireContentProviderClient(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 232 -                LauncherSettings.Favorites.OLD_CONTENT_URI) != null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 233 +        String oldProvider = context.getString(R.string.old_launcher_provider_uri);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 234 +        // This may be the same as MIGRATE_AUTHORITY, or it may be replaced by a different</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 235 +        // resource string.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 236 +        String redirectAuthority = Uri.parse(oldProvider).getAuthority();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 237 +        ProviderInfo providerInfo =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 238 +                context.getPackageManager().resolveContentProvider(MIGRATE_AUTHORITY, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 239 +        ProviderInfo redirectProvider =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 240 +                context.getPackageManager().resolveContentProvider(redirectAuthority, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 241 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 242 +        Log.d(TAG, &quot;Old launcher provider: &quot; + oldProvider);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 243 +        mOldContentProviderExists = (providerInfo != null) &amp;&amp; (redirectProvider != null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 244 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 245 +        if (mOldContentProviderExists) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 246 +            Log.d(TAG, &quot;Old launcher provider exists.&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 247 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 248 +            Log.d(TAG, &quot;Old launcher provider does not exist.&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 249 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 250 +</span>
 251          mApp = app;
 252          mBgAllAppsList = new AllAppsList(iconCache, appFilter);
 253          mIconCache = iconCache;
 254  
 255          final Resources res = context.getResources();
 256          Configuration config = res.getConfiguration();
 257          mPreviousConfigMcc = config.mcc;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 258 +        mLauncherApps = LauncherAppsCompat.getInstance(context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 259 +        mUserManager = UserManagerCompat.getInstance(context);</span>
 260      }
 261  
 262      /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 263       * posted on the main thread handler. */
 264      private void runOnMainThread(Runnable r) {
 265          runOnMainThread(r, 0);
 266      }
 267      private void runOnMainThread(Runnable r, int type) {
 268          if (sWorkerThread.getThreadId() == Process.myTid()) {
 269              // If we are on the worker thread, post onto the main handler
 270              mHandler.post(r);
 271          } else {
 272              r.run();
 273          }
 274      }
 275  
 276      /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 277       * posted on the worker thread handler. */
 278      private static void runOnWorkerThread(Runnable r) {
 279          if (sWorkerThread.getThreadId() == Process.myTid()) {
 280              r.run();
 281          } else {
 282              // If we are not on the worker thread, then post to the worker handler
 283              sWorker.post(r);
 284          }
 285      }
 286  
 287      boolean canMigrateFromOldLauncherDb(Launcher launcher) {
 288          return mOldContentProviderExists &amp;&amp; !launcher.isLauncherPreinstalled() ;
 289      }
 290  
 291      static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;ItemInfo&gt; items, int[] xy,
 292                                   long screen) {
 293          LauncherAppState app = LauncherAppState.getInstance();
 294          DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 295          final int xCount = (int) grid.numColumns;
 296          final int yCount = (int) grid.numRows;
 297          boolean[][] occupied = new boolean[xCount][yCount];
 298  
 299          int cellX, cellY, spanX, spanY;
 300          for (int i = 0; i &lt; items.size(); ++i) {
 301              final ItemInfo item = items.get(i);
 302              if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 303                  if (item.screenId == screen) {
 304                      cellX = item.cellX;
 305                      cellY = item.cellY;
 306                      spanX = item.spanX;
 307                      spanY = item.spanY;
 308                      for (int x = cellX; 0 &lt;= x &amp;&amp; x &lt; cellX + spanX &amp;&amp; x &lt; xCount; x++) {
 309                          for (int y = cellY; 0 &lt;= y &amp;&amp; y &lt; cellY + spanY &amp;&amp; y &lt; yCount; y++) {
 310                              occupied[x][y] = true;
 311                          }
 312                      }
 313                  }
 314              }
 315          }
 316  
 317          return CellLayout.findVacantCell(xy, 1, 1, xCount, yCount, occupied);
 318      }
 319      static Pair&lt;Long, int[]&gt; findNextAvailableIconSpace(Context context, String name,
 320                                                          Intent launchIntent,
 321                                                          int firstScreenIndex,
 322                                                          ArrayList&lt;Long&gt; workspaceScreens) {
 323          // Lock on the app so that we don&#x27;t try and get the items while apps are being added
 324          LauncherAppState app = LauncherAppState.getInstance();
 325          LauncherModel model = app.getModel();
 326          boolean found = false;
 327          synchronized (app) {
 328              if (sWorkerThread.getThreadId() != Process.myTid()) {
 329                  // Flush the LauncherModel worker thread, so that if we just did another
 330                  // processInstallShortcut, we give it time for its shortcut to get added to the
 331                  // database (getItemsInLocalCoordinates reads the database)
 332                  model.flushWorkerThread();
 333              }
 334              final ArrayList&lt;ItemInfo&gt; items = LauncherModel.getItemsInLocalCoordinates(context);
 335  
 336              // Try adding to the workspace screens incrementally, starting at the default or center
 337              // screen and alternating between +1, -1, +2, -2, etc. (using ~ ceil(i/2f)*(-1)^(i-1))
 338              firstScreenIndex = Math.min(firstScreenIndex, workspaceScreens.size());
 339              int count = workspaceScreens.size();
 340              for (int screen = firstScreenIndex; screen &lt; count &amp;&amp; !found; screen++) {
 341                  int[] tmpCoordinates = new int[2];
 342                  if (findNextAvailableIconSpaceInScreen(items, tmpCoordinates,
 343                          workspaceScreens.get(screen))) {
 344                      // Update the Launcher db
 345                      return new Pair&lt;Long, int[]&gt;(workspaceScreens.get(screen), tmpCoordinates);
 346                  }
 347              }
 348          }
 349          return null;
 350      }
 351  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 352 -    public void addAndBindAddedApps(final Context context, final ArrayList&lt;ItemInfo&gt; workspaceApps,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 353 -                                    final ArrayList&lt;AppInfo&gt; allAppsApps) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 354 -        Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 355 -        addAndBindAddedApps(context, workspaceApps, cb, allAppsApps);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 356 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 357 -    public void addAndBindAddedApps(final Context context, final ArrayList&lt;ItemInfo&gt; workspaceApps,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 358 -                                final Callbacks callbacks, final ArrayList&lt;AppInfo&gt; allAppsApps) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 359 -        if (workspaceApps == null || allAppsApps == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 360 +    public void setPackageState(final ArrayList&lt;PackageInstallInfo&gt; installInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 361 +        // Process the updated package state</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 362 +        Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 363 +            public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 364 +                Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 365 +                if (callbacks != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 366 +                    callbacks.updatePackageState(installInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 367 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 368 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 369 +        };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 370 +        mHandler.post(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 371 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 372 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 373 +    public void updatePackageBadge(final String packageName) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 374 +        // Process the updated package badge</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 375 +        Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 376 +            public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 377 +                Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 378 +                if (callbacks != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 379 +                    callbacks.updatePackageBadge(packageName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 380 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 381 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 382 +        };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 383 +        mHandler.post(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 384 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 385 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 386 +    public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 387 +        final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 388 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 389 +        if (allAppsApps == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 390 +            throw new RuntimeException(&quot;allAppsApps must not be null&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 391 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 392 +        if (allAppsApps.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 393 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 394 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 395 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 396 +        final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 397 +        Iterator&lt;AppInfo&gt; iter = allAppsApps.iterator();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 398 +        while (iter.hasNext()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 399 +            ItemInfo a = iter.next();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 400 +            if (LauncherModel.appWasPromise(ctx, a.getIntent(), a.user)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 401 +                restoredAppsFinal.add((AppInfo) a);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 402 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 403 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 404 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 405 +        // Process the newly added applications and add them to the database first</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 406 +        Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 407 +            public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 408 +                runOnMainThread(new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 409 +                    public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 410 +                        Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 411 +                        if (callbacks == cb &amp;&amp; cb != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 412 +                            if (!restoredAppsFinal.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 413 +                                for (AppInfo info : restoredAppsFinal) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 414 +                                    final Intent intent = info.getIntent();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 415 +                                    if (intent != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 416 +                                        mIconCache.deletePreloadedIcon(intent.getComponent(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 417 +                                                info.user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 418 +                                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 419 +                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 420 +                                callbacks.bindAppsUpdated(restoredAppsFinal);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 421 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 422 +                            callbacks.bindAppsAdded(null, null, null, allAppsApps);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 423 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 424 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 425 +                });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 426 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 427 +        };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 428 +        runOnWorkerThread(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 429 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 430 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 431 +    public void addAndBindAddedWorkspaceApps(final Context context,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 432 +            final ArrayList&lt;ItemInfo&gt; workspaceApps) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 433 +        final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 434 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 435 +        if (workspaceApps == null) {</span>
 436              throw new RuntimeException(&quot;workspaceApps and allAppsApps must not be null&quot;);
 437          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 438 -        if (workspaceApps.isEmpty() &amp;&amp; allAppsApps.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 439 +        if (workspaceApps.isEmpty()) {</span>
 440              return;
 441          }
 442          // Process the newly added applications and add them to the database first
 443          Runnable r = new Runnable() {
 444              public void run() {
 445                  final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();
 446                  final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 447 +                final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();</span>
 448  
 449                  // Get the list of workspace screens.  We need to append to this list and
 450                  // can not use sBgWorkspaceScreens because loadWorkspace() may not have been
 451                  // called.
 452                  ArrayList&lt;Long&gt; workspaceScreens = new ArrayList&lt;Long&gt;();
 453                  TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(context);
 454                  for (Integer i : orderedScreens.keySet()) {
 455                      long screenId = orderedScreens.get(i);
 456                      workspaceScreens.add(screenId);
 457                  }
 458  
 459                  synchronized(sBgLock) {
 460                      Iterator&lt;ItemInfo&gt; iter = workspaceApps.iterator();
 461                      while (iter.hasNext()) {
 462                          ItemInfo a = iter.next();
 463                          final String name = a.title.toString();
 464                          final Intent launchIntent = a.getIntent();
 465  
 466                          // Short-circuit this logic if the icon exists somewhere on the workspace
 467                          if (LauncherModel.shortcutExists(context, name, launchIntent)) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 468 +                            // Only InstallShortcutReceiver sends us shortcutInfos, ignore them</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 469 +                            if (a instanceof AppInfo &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 470 +                                    LauncherModel.appWasPromise(context, launchIntent, a.user)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 471 +                                restoredAppsFinal.add((AppInfo) a);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 472 +                            }</span>
 473                              continue;
 474                          }
 475  
 476                          // Add this icon to the db, creating a new page if necessary.  If there
 477                          // is only the empty page then we just add items to the first page.
 478                          // Otherwise, we add them to the next pages.
 479                          int startSearchPageIndex = workspaceScreens.isEmpty() ? 0 : 1;
 480                          Pair&lt;Long, int[]&gt; coords = LauncherModel.findNextAvailableIconSpace(context,
 481                                  name, launchIntent, startSearchPageIndex, workspaceScreens);
 482                          if (coords == null) {
 483                              LauncherProvider lp = LauncherAppState.getLauncherProvider();
 484  
 485                              // If we can&#x27;t find a valid position, then just add a new screen.
 486                              // This takes time so we need to re-queue the add until the new
 487                              // page is added.  Create as many screens as necessary to satisfy
 488                              // the startSearchPageIndex.
 489                              int numPagesToAdd = Math.max(1, startSearchPageIndex + 1 -
 490                                      workspaceScreens.size());
 491                              while (numPagesToAdd &gt; 0) {
 492                                  long screenId = lp.generateNewScreenId();
 493                                  // Save the screen id for binding in the workspace
 494                                  workspaceScreens.add(screenId);
 495                                  addedWorkspaceScreensFinal.add(screenId);
 496                                  numPagesToAdd--;
 497                              }
 498  
 499                              // Find the coordinate again
 500                              coords = LauncherModel.findNextAvailableIconSpace(context,
 501                                      name, launchIntent, startSearchPageIndex, workspaceScreens);
 502                          }
 503                          if (coords == null) {
 504                              throw new RuntimeException(&quot;Coordinates should not be null&quot;);
 505                          }
 506  
 507                          ShortcutInfo shortcutInfo;
 508                          if (a instanceof ShortcutInfo) {
 509                              shortcutInfo = (ShortcutInfo) a;
 510                          } else if (a instanceof AppInfo) {
 511                              shortcutInfo = ((AppInfo) a).makeShortcut();
 512                          } else {
 513                              throw new RuntimeException(&quot;Unexpected info type&quot;);
 514                          }
 515  
 516                          // Add the shortcut to the db
 517                          addItemToDatabase(context, shortcutInfo,
 518                                  LauncherSettings.Favorites.CONTAINER_DESKTOP,
 519                                  coords.first, coords.second[0], coords.second[1], false);
 520                          // Save the ShortcutInfo for binding in the workspace
 521                          addedShortcutsFinal.add(shortcutInfo);
 522                      }
 523                  }
 524  
 525                  // Update the workspace screens
 526                  updateWorkspaceScreenOrder(context, workspaceScreens);
 527  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 528 -                if (!addedShortcutsFinal.isEmpty() || !allAppsApps.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 529 +                if (!addedShortcutsFinal.isEmpty()) {</span>
 530                      runOnMainThread(new Runnable() {
 531                          public void run() {
 532                              Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 533                              if (callbacks == cb &amp;&amp; cb != null) {
 534                                  final ArrayList&lt;ItemInfo&gt; addAnimated = new ArrayList&lt;ItemInfo&gt;();
 535                                  final ArrayList&lt;ItemInfo&gt; addNotAnimated = new ArrayList&lt;ItemInfo&gt;();
 536                                  if (!addedShortcutsFinal.isEmpty()) {
 537                                      ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 1);
 538                                      long lastScreenId = info.screenId;
 539                                      for (ItemInfo i : addedShortcutsFinal) {
 540                                          if (i.screenId == lastScreenId) {
 541                                              addAnimated.add(i);
 542                                          } else {
 543                                              addNotAnimated.add(i);
 544                                          }
 545                                      }
 546                                  }
 547                                  callbacks.bindAppsAdded(addedWorkspaceScreensFinal,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 548 -                                        addNotAnimated, addAnimated, allAppsApps);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 549 +                                        addNotAnimated, addAnimated, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 550 +                                if (!restoredAppsFinal.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 551 +                                    callbacks.bindAppsUpdated(restoredAppsFinal);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 552 +                                }</span>
 553                              }
 554                          }
 555                      });
 556                  }
 557              }
 558          };
 559          runOnWorkerThread(r);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 560 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 561 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 562 -    public Bitmap getFallbackIcon() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 563 -        if (mDefaultIcon == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 564 -            final Context context = LauncherAppState.getInstance().getContext();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 565 -            mDefaultIcon = Utilities.createIconBitmap(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 566 -                    mIconCache.getFullResDefaultActivityIcon(), context);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 567 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 568 -        return Bitmap.createBitmap(mDefaultIcon);</span>
 569      }
 570  
 571      public void unbindItemInfosAndClearQueuedBindRunnables() {
 572          if (sWorkerThread.getThreadId() == Process.myTid()) {
 573              throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; +
 574                      &quot;main thread&quot;);
 575          }
 576  
 577          // Clear any deferred bind runnables
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 578 -        mDeferredBindRunnables.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 579 +        synchronized (mDeferredBindRunnables) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 580 +            mDeferredBindRunnables.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 581 +        }</span>
 582          // Remove any queued bind runnables
 583          mHandler.cancelAllRunnablesOfType(MAIN_THREAD_BINDING_RUNNABLE);
 584          // Unbind all the workspace items
 585          unbindWorkspaceItemsOnMainThread();
 586      }
 587  
 588      /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 589      void unbindWorkspaceItemsOnMainThread() {
 590          // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 591          // by making a copy of workspace items first.
 592          final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 593          final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 594          synchronized (sBgLock) {
 595              tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 596              tmpAppWidgets.addAll(sBgAppWidgets);
 597          }
 598          Runnable r = new Runnable() {
 599                  @Override
 600                  public void run() {
 601                     for (ItemInfo item : tmpWorkspaceItems) {
 602                         item.unbind();
 603                     }
 604                     for (ItemInfo item : tmpAppWidgets) {
 605                         item.unbind();
 606                     }
 607                  }
 608              };
 609          runOnMainThread(r);
 610      }
 611  
 612      /**
 613       * Adds an item to the DB if it was not created previously, or move it to a new
 614       * &lt;container, screen, cellX, cellY&gt;
 615       */
 616      static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 617              long screenId, int cellX, int cellY) {
 618          if (item.container == ItemInfo.NO_ID) {
 619              // From all apps
 620              addItemToDatabase(context, item, container, screenId, cellX, cellY, false);
 621          } else {
 622              // From somewhere else
 623              moveItemInDatabase(context, item, container, screenId, cellX, cellY);
 624          }
 625      }
 626  
 627      static void checkItemInfoLocked(
 628              final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {
 629          ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 630          if (modelItem != null &amp;&amp; item != modelItem) {
 631              // check all the data is consistent
 632              if (modelItem instanceof ShortcutInfo &amp;&amp; item instanceof ShortcutInfo) {
 633                  ShortcutInfo modelShortcut = (ShortcutInfo) modelItem;
 634                  ShortcutInfo shortcut = (ShortcutInfo) item;
 635                  if (modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp;
 636                          modelShortcut.intent.filterEquals(shortcut.intent) &amp;&amp;
 637                          modelShortcut.id == shortcut.id &amp;&amp;
 638                          modelShortcut.itemType == shortcut.itemType &amp;&amp;
 639                          modelShortcut.container == shortcut.container &amp;&amp;
 640                          modelShortcut.screenId == shortcut.screenId &amp;&amp;
 641                          modelShortcut.cellX == shortcut.cellX &amp;&amp;
 642                          modelShortcut.cellY == shortcut.cellY &amp;&amp;
 643                          modelShortcut.spanX == shortcut.spanX &amp;&amp;
 644                          modelShortcut.spanY == shortcut.spanY &amp;&amp;
 645                          ((modelShortcut.dropPos == null &amp;&amp; shortcut.dropPos == null) ||
 646                          (modelShortcut.dropPos != null &amp;&amp;
 647                                  shortcut.dropPos != null &amp;&amp;
 648                                  modelShortcut.dropPos[0] == shortcut.dropPos[0] &amp;&amp;
 649                          modelShortcut.dropPos[1] == shortcut.dropPos[1]))) {
 650                      // For all intents and purposes, this is the same object
 651                      return;
 652                  }
 653              }
 654  
 655              // the modelItem needs to match up perfectly with item if our model is
 656              // to be consistent with the database-- for now, just require
 657              // modelItem == item or the equality check above
 658              String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 659                      &quot;modelItem: &quot; +
 660                      ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 661                      &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 662              RuntimeException e = new RuntimeException(msg);
 663              if (stackTrace != null) {
 664                  e.setStackTrace(stackTrace);
 665              }
 666              throw e;
 667          }
 668      }
 669  
 670      static void checkItemInfo(final ItemInfo item) {
 671          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 672          final long itemId = item.id;
 673          Runnable r = new Runnable() {
 674              public void run() {
 675                  synchronized (sBgLock) {
 676                      checkItemInfoLocked(itemId, item, stackTrace);
 677                  }
 678              }
 679          };
 680          runOnWorkerThread(r);
 681      }
 682  
 683      static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 684              final ItemInfo item, final String callingFunction) {
 685          final long itemId = item.id;
 686          final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 687          final ContentResolver cr = context.getContentResolver();
 688  
 689          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 690          Runnable r = new Runnable() {
 691              public void run() {
 692                  cr.update(uri, values, null, null);
 693                  updateItemArrays(item, itemId, stackTrace);
 694              }
 695          };
 696          runOnWorkerThread(r);
 697      }
 698  
 699      static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList,
 700              final ArrayList&lt;ItemInfo&gt; items, final String callingFunction) {
 701          final ContentResolver cr = context.getContentResolver();
 702  
 703          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 704          Runnable r = new Runnable() {
 705              public void run() {
 706                  ArrayList&lt;ContentProviderOperation&gt; ops =
 707                          new ArrayList&lt;ContentProviderOperation&gt;();
 708                  int count = items.size();
 709                  for (int i = 0; i &lt; count; i++) {
 710                      ItemInfo item = items.get(i);
 711                      final long itemId = item.id;
 712                      final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 713                      ContentValues values = valuesList.get(i);
 714  
 715                      ops.add(ContentProviderOperation.newUpdate(uri).withValues(values).build());
 716                      updateItemArrays(item, itemId, stackTrace);
 717  
 718                  }
 719                  try {
 720                      cr.applyBatch(LauncherProvider.AUTHORITY, ops);
 721                  } catch (Exception e) {
 722                      e.printStackTrace();
 723                  }
 724              }
 725          };
 726          runOnWorkerThread(r);
 727      }
 728  
 729      static void updateItemArrays(ItemInfo item, long itemId, StackTraceElement[] stackTrace) {
 730          // Lock on mBgLock *after* the db operation
 731          synchronized (sBgLock) {
 732              checkItemInfoLocked(itemId, item, stackTrace);
 733  
 734              if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
 735                      item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 736                  // Item is in a folder, make sure this folder exists
 737                  if (!sBgFolders.containsKey(item.container)) {
 738                      // An items container is being set to a that of an item which is not in
 739                      // the list of Folders.
 740                      String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +
 741                              item.container + &quot;, not in the list of folders&quot;;
 742                      Log.e(TAG, msg);
 743                  }
 744              }
 745  
 746              // Items are added/removed from the corresponding FolderInfo elsewhere, such
 747              // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 748              // that are on the desktop, as appropriate
 749              ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 750              if (modelItem != null &amp;&amp;
 751                      (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 752                       modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {
 753                  switch (modelItem.itemType) {
 754                      case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 755                      case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 756                      case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 757                          if (!sBgWorkspaceItems.contains(modelItem)) {
 758                              sBgWorkspaceItems.add(modelItem);
 759                          }
 760                          break;
 761                      default:
 762                          break;
 763                  }
 764              } else {
 765                  sBgWorkspaceItems.remove(modelItem);
 766              }
 767          }
 768      }
 769  
 770      public void flushWorkerThread() {
 771          mFlushingWorkerThread = true;
 772          Runnable waiter = new Runnable() {
 773                  public void run() {
 774                      synchronized (this) {
 775                          notifyAll();
 776                          mFlushingWorkerThread = false;
 777                      }
 778                  }
 779              };
 780  
 781          synchronized(waiter) {
 782              runOnWorkerThread(waiter);
 783              if (mLoaderTask != null) {
 784                  synchronized(mLoaderTask) {
 785                      mLoaderTask.notify();
 786                  }
 787              }
 788              boolean success = false;
 789              while (!success) {
 790                  try {
 791                      waiter.wait();
 792                      success = true;
 793                  } catch (InterruptedException e) {
 794                  }
 795              }
 796          }
 797      }
 798  
 799      /**
 800       * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 801       */
 802      static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 803              final long screenId, final int cellX, final int cellY) {
 804          item.container = container;
 805          item.cellX = cellX;
 806          item.cellY = cellY;
 807  
 808          // We store hotseat items in canonical form which is this orientation invariant position
 809          // in the hotseat
 810          if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 811                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 812              item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 813          } else {
 814              item.screenId = screenId;
 815          }
 816  
 817          final ContentValues values = new ContentValues();
 818          values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 819          values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 820          values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 821          values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 822  
 823          updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 824      }
 825  
 826      /**
 827       * Move items in the DB to a new &lt;container, screen, cellX, cellY&gt;. We assume that the
 828       * cellX, cellY have already been updated on the ItemInfos.
 829       */
 830      static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items,
 831              final long container, final int screen) {
 832  
 833          ArrayList&lt;ContentValues&gt; contentValues = new ArrayList&lt;ContentValues&gt;();
 834          int count = items.size();
 835  
 836          for (int i = 0; i &lt; count; i++) {
 837              ItemInfo item = items.get(i);
 838              item.container = container;
 839  
 840              // We store hotseat items in canonical form which is this orientation invariant position
 841              // in the hotseat
 842              if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 843                      container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 844                  item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(item.cellX,
 845                          item.cellY);
 846              } else {
 847                  item.screenId = screen;
 848              }
 849  
 850              final ContentValues values = new ContentValues();
 851              values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 852              values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 853              values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 854              values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 855  
 856              contentValues.add(values);
 857          }
 858          updateItemsInDatabaseHelper(context, contentValues, items, &quot;moveItemInDatabase&quot;);
 859      }
 860  
 861      /**
 862       * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 863       */
 864      static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 865              final long screenId, final int cellX, final int cellY, final int spanX, final int spanY) {
 866          item.container = container;
 867          item.cellX = cellX;
 868          item.cellY = cellY;
 869          item.spanX = spanX;
 870          item.spanY = spanY;
 871  
 872          // We store hotseat items in canonical form which is this orientation invariant position
 873          // in the hotseat
 874          if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 875                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 876              item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 877          } else {
 878              item.screenId = screenId;
 879          }
 880  
 881          final ContentValues values = new ContentValues();
 882          values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 883          values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 884          values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 885          values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 886          values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 887          values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 888  
 889          updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 890      }
 891  
 892      /**
 893       * Update an item to the database in a specified container.
 894       */
 895      static void updateItemInDatabase(Context context, final ItemInfo item) {
 896          final ContentValues values = new ContentValues();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 897 -        item.onAddToDatabase(values);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 898 +        item.onAddToDatabase(context, values);</span>
 899          item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 900          updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 901      }
 902  
 903      /**
 904       * Returns true if the shortcuts already exists in the database.
 905       * we identify a shortcut by its title and intent.
 906       */
 907      static boolean shortcutExists(Context context, String title, Intent intent) {
 908          final ContentResolver cr = context.getContentResolver();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 909 +        final Intent intentWithPkg, intentWithoutPkg;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 910 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 911 +        if (intent.getComponent() != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 912 +            // If component is not null, an intent with null package will produce</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 913 +            // the same result and should also be a match.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 914 +            if (intent.getPackage() != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 915 +                intentWithPkg = intent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 916 +                intentWithoutPkg = new Intent(intent).setPackage(null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 917 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 918 +                intentWithPkg = new Intent(intent).setPackage(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 919 +                        intent.getComponent().getPackageName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 920 +                intentWithoutPkg = intent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 921 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 922 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 923 +            intentWithPkg = intent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 924 +            intentWithoutPkg = intent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 925 +        }</span>
 926          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 927 -            new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and intent=?&quot;,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 928 -            new String[] { title, intent.toUri(0) }, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 929 +            new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and (intent=? or intent=?)&quot;,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 930 +            new String[] { title, intentWithPkg.toUri(0), intentWithoutPkg.toUri(0) }, null);</span>
 931          boolean result = false;
 932          try {
 933              result = c.moveToFirst();
 934          } finally {
 935              c.close();
 936          }
 937          return result;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 938 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 939 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 940 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 941 +     * Returns true if the promise shortcuts with the same package name exists on the workspace.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 942 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 943 +    static boolean appWasPromise(Context context, Intent intent, UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 944 +        final ComponentName component = intent.getComponent();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 945 +        if (component == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 946 +            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 947 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 948 +        return !getItemsByPackageName(component.getPackageName(), user).isEmpty();</span>
 949      }
 950  
 951      /**
 952       * Returns an ItemInfo array containing all the items in the LauncherModel.
 953       * The ItemInfo.id is not set through this function.
 954       */
 955      static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 956          ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 957          final ContentResolver cr = context.getContentResolver();
 958          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
 959                  LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 960 -                LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,"> 960 -                LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CE</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 961 -                LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY }, null, null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 962 +                LauncherSettings.Favorites.SCREEN,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 963 +                LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 964 +                LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 965 +                LauncherSettings.Favorites.PROFILE_ID }, null, null, null);</span>
 966  
 967          final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 968          final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 969          final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 970          final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 971          final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 972          final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 973          final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 974 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 975 +        final int profileIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.PROFILE_ID);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 976 +        UserManagerCompat userManager = UserManagerCompat.getInstance(context);</span>
 977          try {
 978              while (c.moveToNext()) {
 979                  ItemInfo item = new ItemInfo();
 980                  item.cellX = c.getInt(cellXIndex);
 981                  item.cellY = c.getInt(cellYIndex);
 982                  item.spanX = Math.max(1, c.getInt(spanXIndex));
 983                  item.spanY = Math.max(1, c.getInt(spanYIndex));
 984                  item.container = c.getInt(containerIndex);
 985                  item.itemType = c.getInt(itemTypeIndex);
 986                  item.screenId = c.getInt(screenIndex);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 987 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 988 -                items.add(item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 989 +                long serialNumber = c.getInt(profileIdIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 990 +                item.user = userManager.getUserForSerialNumber(serialNumber);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 991 +                // Skip if user has been deleted.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 992 +                if (item.user != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 993 +                    items.add(item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 994 +                }</span>
 995              }
 996          } catch (Exception e) {
 997              items.clear();
 998          } finally {
 999              c.close();
1000          }
1001  
1002          return items;
1003      }
1004  
1005      /**
1006       * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
1007       */
1008      FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
1009          final ContentResolver cr = context.getContentResolver();
1010          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
1011                  &quot;_id=? and (itemType=? or itemType=?)&quot;,
1012                  new String[] { String.valueOf(id),
1013                          String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
1014  
1015          try {
1016              if (c.moveToFirst()) {
1017                  final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
1018                  final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
1019                  final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
1020                  final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
1021                  final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
1022                  final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
1023  
1024                  FolderInfo folderInfo = null;
1025                  switch (c.getInt(itemTypeIndex)) {
1026                      case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1027                          folderInfo = findOrMakeFolder(folderList, id);
1028                          break;
1029                  }
1030  
1031                  folderInfo.title = c.getString(titleIndex);
1032                  folderInfo.id = id;
1033                  folderInfo.container = c.getInt(containerIndex);
1034                  folderInfo.screenId = c.getInt(screenIndex);
1035                  folderInfo.cellX = c.getInt(cellXIndex);
1036                  folderInfo.cellY = c.getInt(cellYIndex);
1037  
1038                  return folderInfo;
1039              }
1040          } finally {
1041              c.close();
1042          }
1043  
1044          return null;
1045      }
1046  
1047      /**
1048       * Add an item to the database in a specified container. Sets the container, screen, cellX and
1049       * cellY fields of the item. Also assigns an ID to the item.
1050       */
1051      static void addItemToDatabase(Context context, final ItemInfo item, final long container,
1052              final long screenId, final int cellX, final int cellY, final boolean notify) {
1053          item.container = container;
1054          item.cellX = cellX;
1055          item.cellY = cellY;
1056          // We store hotseat items in canonical form which is this orientation invariant position
1057          // in the hotseat
1058          if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
1059                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1060              item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
1061          } else {
1062              item.screenId = screenId;
1063          }
1064  
1065          final ContentValues values = new ContentValues();
1066          final ContentResolver cr = context.getContentResolver();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1067 -        item.onAddToDatabase(values);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1068 +        item.onAddToDatabase(context, values);</span>
1069  
1070          item.id = LauncherAppState.getLauncherProvider().generateNewItemId();
1071          values.put(LauncherSettings.Favorites._ID, item.id);
1072          item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
1073  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1074 +        final StackTraceElement[] stackTrace = new Throwable().getStackTrace();</span>
1075          Runnable r = new Runnable() {
1076              public void run() {
1077                  cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
1078                          LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);
1079  
1080                  // Lock on mBgLock *after* the db operation
1081                  synchronized (sBgLock) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1082 -                    checkItemInfoLocked(item.id, item, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1083 +                    checkItemInfoLocked(item.id, item, stackTrace);</span>
1084                      sBgItemsIdMap.put(item.id, item);
1085                      switch (item.itemType) {
1086                          case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1087                              sBgFolders.put(item.id, (FolderInfo) item);
1088                              // Fall through
1089                          case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1090                          case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1091                              if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
1092                                      item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1093                                  sBgWorkspaceItems.add(item);
1094                              } else {
1095                                  if (!sBgFolders.containsKey(item.container)) {
1096                                      // Adding an item to a folder that doesn&#x27;t exist.
1097                                      String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +
1098                                              &quot; doesn&#x27;t exist&quot;;
1099                                      Log.e(TAG, msg);
1100                                  }
1101                              }
1102                              break;
1103                          case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1104                              sBgAppWidgets.add((LauncherAppWidgetInfo) item);
1105                              break;
1106                      }
1107                  }
1108              }
1109          };
1110          runOnWorkerThread(r);
1111      }
1112  
1113      /**
1114       * Creates a new unique child id, for a given cell span across all layouts.
1115       */
1116      static int getCellLayoutChildId(
1117              long container, long screen, int localCellX, int localCellY, int spanX, int spanY) {
1118          return (((int) container &amp; 0xFF) &lt;&lt; 24)
1119                  | ((int) screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
1120      }
1121  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1122 +    private static ArrayList&lt;ItemInfo&gt; getItemsByPackageName(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1123 +            final String pn, final UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1124 +        ItemInfoFilter filter  = new ItemInfoFilter() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1125 +            @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1126 +            public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1127 +                return cn.getPackageName().equals(pn) &amp;&amp; info.user.equals(user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1128 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1129 +        };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1130 +        return filterItemInfos(sBgItemsIdMap.values(), filter);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1131 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1132 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1133 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1134 +     * Removes all the items from the database corresponding to the specified package.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1135 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1136 +    static void deletePackageFromDatabase(Context context, final String pn,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1137 +            final UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1138 +        deleteItemsFromDatabase(context, getItemsByPackageName(pn, user));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1139 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1140 +</span>
1141      /**
1142       * Removes the specified item from the database
1143       * @param context
1144       * @param item
1145       */
1146      static void deleteItemFromDatabase(Context context, final ItemInfo item) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1147 +        ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1148 +        items.add(item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1149 +        deleteItemsFromDatabase(context, items);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1150 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1151 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1152 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1153 +     * Removes the specified items from the database</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1154 +     * @param context</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1155 +     * @param item</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1156 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1157 +    static void deleteItemsFromDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items) {</span>
1158          final ContentResolver cr = context.getContentResolver();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1159 -        final Uri uriToDelete = LauncherSettings.Favorites.getContentUri(item.id, false);</span>
1160  
1161          Runnable r = new Runnable() {
1162              public void run() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1163 -                cr.delete(uriToDelete, null, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1164 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1165 -                // Lock on mBgLock *after* the db operation</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1166 -                synchronized (sBgLock) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1167 -                    switch (item.itemType) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1168 -                        case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1169 -                            sBgFolders.remove(item.id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1170 -                            for (ItemInfo info: sBgItemsIdMap.values()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1171 -                                if (info.container == item.id) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1172 -                                    // We are deleting a folder which still contains items that</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1173 -                                    // think they are contained by that folder.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1174 -                                    String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1175 -                                            &quot;contains items (&quot; + info + &quot;)&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1176 -                                    Log.e(TAG, msg);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1177 +                for (ItemInfo item : items) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1178 +                    final Uri uri = LauncherSettings.Favorites.getContentUri(item.id, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1179 +                    cr.delete(uri, null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1180 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1181 +                    // Lock on mBgLock *after* the db operation</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1182 +                    synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1183 +                        switch (item.itemType) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1184 +                            case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1185 +                                sBgFolders.remove(item.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1186 +                                for (ItemInfo info: sBgItemsIdMap.values()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1187 +                                    if (info.container == item.id) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1188 +                                        // We are deleting a folder which still contains items that</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1189 +                                        // think they are contained by that folder.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1190 +                                        String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1191 +                                                &quot;contains items (&quot; + info + &quot;)&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1192 +                                        Log.e(TAG, msg);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1193 +                                    }</span>
1194                                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1195 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1196 -                            sBgWorkspaceItems.remove(item);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1197 -                            break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1198 -                        case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1199 -                        case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1200 -                            sBgWorkspaceItems.remove(item);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1201 -                            break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1202 -                        case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1203 -                            sBgAppWidgets.remove((LauncherAppWidgetInfo) item);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1204 -                            break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1205 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1206 -                    sBgItemsIdMap.remove(item.id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1207 -                    sBgDbIconCache.remove(item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1208 +                                sBgWorkspaceItems.remove(item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1209 +                                break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1210 +                            case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1211 +                            case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1212 +                                sBgWorkspaceItems.remove(item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1213 +                                break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1214 +                            case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1215 +                                sBgAppWidgets.remove((LauncherAppWidgetInfo) item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1216 +                                break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1217 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1218 +                        sBgItemsIdMap.remove(item.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1219 +                        sBgDbIconCache.remove(item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1220 +                    }</span>
1221                  }
1222              }
1223          };
1224          runOnWorkerThread(r);
1225      }
1226  
1227      /**
1228       * Update the order of the workspace screens in the database. The array list contains
1229       * a list of screen ids in the order that they should appear.
1230       */
1231      void updateWorkspaceScreenOrder(Context context, final ArrayList&lt;Long&gt; screens) {
1232          // Log to disk
1233          Launcher.addDumpLog(TAG, &quot;11683562 - updateWorkspaceScreenOrder()&quot;, true);
1234          Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; + TextUtils.join(&quot;, &quot;, screens), true);
1235  
1236          final ArrayList&lt;Long&gt; screensCopy = new ArrayList&lt;Long&gt;(screens);
1237          final ContentResolver cr = context.getContentResolver();
1238          final Uri uri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1239  
1240          // Remove any negative screen ids -- these aren&#x27;t persisted
1241          Iterator&lt;Long&gt; iter = screensCopy.iterator();
1242          while (iter.hasNext()) {
1243              long id = iter.next();
1244              if (id &lt; 0) {
1245                  iter.remove();
1246              }
1247          }
1248  
1249          Runnable r = new Runnable() {
1250              @Override
1251              public void run() {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1252 +                ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();</span>
1253                  // Clear the table
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1254 -                cr.delete(uri, null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1255 +                ops.add(ContentProviderOperation.newDelete(uri).build());</span>
1256                  int count = screensCopy.size();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1257 -                ContentValues[] values = new ContentValues[count];</span>
1258                  for (int i = 0; i &lt; count; i++) {
1259                      ContentValues v = new ContentValues();
1260                      long screenId = screensCopy.get(i);
1261                      v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1262                      v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1263 -                    values[i] = v;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1264 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1265 -                cr.bulkInsert(uri, values);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1266 +                    ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1267 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1268 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1269 +                try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1270 +                    cr.applyBatch(LauncherProvider.AUTHORITY, ops);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1271 +                } catch (Exception ex) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1272 +                    throw new RuntimeException(ex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1273 +                }</span>
1274  
1275                  synchronized (sBgLock) {
1276                      sBgWorkspaceScreens.clear();
1277                      sBgWorkspaceScreens.addAll(screensCopy);
1278                  }
1279              }
1280          };
1281          runOnWorkerThread(r);
1282      }
1283  
1284      /**
1285       * Remove the contents of the specified folder from the database
1286       */
1287      static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
1288          final ContentResolver cr = context.getContentResolver();
1289  
1290          Runnable r = new Runnable() {
1291              public void run() {
1292                  cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
1293                  // Lock on mBgLock *after* the db operation
1294                  synchronized (sBgLock) {
1295                      sBgItemsIdMap.remove(info.id);
1296                      sBgFolders.remove(info.id);
1297                      sBgDbIconCache.remove(info);
1298                      sBgWorkspaceItems.remove(info);
1299                  }
1300  
1301                  cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
1302                          LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
1303                  // Lock on mBgLock *after* the db operation
1304                  synchronized (sBgLock) {
1305                      for (ItemInfo childInfo : info.contents) {
1306                          sBgItemsIdMap.remove(childInfo.id);
1307                          sBgDbIconCache.remove(childInfo);
1308                      }
1309                  }
1310              }
1311          };
1312          runOnWorkerThread(r);
1313      }
1314  
1315      /**
1316       * Set this as the current Launcher activity object for the loader.
1317       */
1318      public void initialize(Callbacks callbacks) {
1319          synchronized (mLock) {
1320              mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
1321          }
1322      }
1323  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1324 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1325 +    public void onPackageChanged(String packageName, UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1326 +        int op = PackageUpdatedTask.OP_UPDATE;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1327 +        enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1328 +                user));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1329 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1330 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1331 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1332 +    public void onPackageRemoved(String packageName, UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1333 +        int op = PackageUpdatedTask.OP_REMOVE;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1334 +        enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1335 +                user));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1336 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1337 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1338 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1339 +    public void onPackageAdded(String packageName, UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1340 +        int op = PackageUpdatedTask.OP_ADD;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1341 +        enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1342 +                user));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1343 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1344 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1345 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1346 +    public void onPackagesAvailable(String[] packageNames, UserHandleCompat user,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1347 +            boolean replacing) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1348 +        if (!replacing) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1349 +            enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packageNames,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1350 +                    user));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1351 +            if (mAppsCanBeOnRemoveableStorage) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1352 +                // Only rebind if we support removable storage. It catches the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1353 +                // case where</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1354 +                // apps on the external sd card need to be reloaded</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1355 +                startLoaderFromBackground();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1356 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1357 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1358 +            // If we are replacing then just update the packages in the list</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1359 +            enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1360 +                    packageNames, user));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1361 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1362 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1363 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1364 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1365 +    public void onPackagesUnavailable(String[] packageNames, UserHandleCompat user,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1366 +            boolean replacing) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1367 +        if (!replacing) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1368 +            enqueuePackageUpdated(new PackageUpdatedTask(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1369 +                    PackageUpdatedTask.OP_UNAVAILABLE, packageNames,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1370 +                    user));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1371 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1372 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1373 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1374 +</span>
1375      /**
1376       * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
1377       * ACTION_PACKAGE_CHANGED.
1378       */
1379      @Override
1380      public void onReceive(Context context, Intent intent) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1381 -        if (DEBUG_LOADERS) Log.d(TAG, &quot;onReceive intent=&quot; + intent);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1382 +        if (DEBUG_RECEIVER) Log.d(TAG, &quot;onReceive intent=&quot; + intent);</span>
1383  
1384          final String action = intent.getAction();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1385 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1386 -        if (Intent.ACTION_PACKAGE_CHANGED.equals(action)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1387 -                || Intent.ACTION_PACKAGE_REMOVED.equals(action)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1388 -                || Intent.ACTION_PACKAGE_ADDED.equals(action)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1389 -            final String packageName = intent.getData().getSchemeSpecificPart();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1390 -            final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1391 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1392 -            int op = PackageUpdatedTask.OP_NONE;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1393 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1394 -            if (packageName == null || packageName.length() == 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1395 -                // they sent us a bad intent</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1396 -                return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1397 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1398 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1399 -            if (Intent.ACTION_PACKAGE_CHANGED.equals(action)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1400 -                op = PackageUpdatedTask.OP_UPDATE;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1401 -            } else if (Intent.ACTION_PACKAGE_REMOVED.equals(action)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1402 -                if (!replacing) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1403 -                    op = PackageUpdatedTask.OP_REMOVE;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1404 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1405 -                // else, we are replacing the package, so a PACKAGE_ADDED will be sent</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1406 -                // later, we will update the package at this time</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1407 -            } else if (Intent.ACTION_PACKAGE_ADDED.equals(action)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1408 -                if (!replacing) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1409 -                    op = PackageUpdatedTask.OP_ADD;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1410 -                } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1411 -                    op = PackageUpdatedTask.OP_UPDATE;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1412 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1413 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1414 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1415 -            if (op != PackageUpdatedTask.OP_NONE) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1416 -                enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName }));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1417 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1418 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1419 -        } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(action)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1420 -            final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1421 -            String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1422 -            if (!replacing) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1423 -                enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packages));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1424 -                if (mAppsCanBeOnRemoveableStorage) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1425 -                    // Only rebind if we support removable storage.  It catches the case where</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1426 -                    // apps on the external sd card need to be reloaded</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1427 -                    startLoaderFromBackground();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1428 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1429 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1430 -                // If we are replacing then just update the packages in the list</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1431 -                enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1432 -                        packages));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1433 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1434 -        } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(action)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1435 -            final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1436 -            if (!replacing) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1437 -                String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1438 -                enqueuePackageUpdated(new PackageUpdatedTask(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1439 -                            PackageUpdatedTask.OP_UNAVAILABLE, packages));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1440 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1441 -            // else, we are replacing the packages, so ignore this event and wait for</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1442 -            // EXTERNAL_APPLICATIONS_AVAILABLE to update the packages at that time</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1443 -        } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1444 +        if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {</span>
1445              // If we have changed locale we need to clear out the labels in all apps/workspace.
1446              forceReload();
1447          } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
1448               // Check if configuration change was an mcc/mnc change which would affect app resources
1449               // and we would need to clear out the labels in all apps/workspace. Same handling as
1450               // above for ACTION_LOCALE_CHANGED
1451               Configuration currentConfig = context.getResources().getConfiguration();
1452               if (mPreviousConfigMcc != currentConfig.mcc) {
1453                     Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
1454                         + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
1455                     forceReload();
1456               }
1457               // Update previousConfig
1458               mPreviousConfigMcc = currentConfig.mcc;
1459          } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
1460                     SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
1461              if (mCallbacks != null) {
1462                  Callbacks callbacks = mCallbacks.get();
1463                  if (callbacks != null) {
1464                      callbacks.bindSearchablesChanged();
1465                  }
1466              }
1467          }
1468      }
1469  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1470 -    private void forceReload() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1471 +    void forceReload() {</span>
1472          resetLoadedState(true, true);
1473  
1474          // Do this here because if the launcher activity is running it will be restarted.
1475          // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
1476          // to reload.
1477          startLoaderFromBackground();
1478      }
1479  
1480      public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
1481          synchronized (mLock) {
1482              // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
1483              // mWorkspaceLoaded to true later
1484              stopLoaderLocked();
1485              if (resetAllAppsLoaded) mAllAppsLoaded = false;
1486              if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
1487          }
1488      }
1489  
1490      /**
1491       * When the launcher is in the background, it&#x27;s possible for it to miss paired
1492       * configuration changes.  So whenever we trigger the loader from the background
1493       * tell the launcher that it needs to re-run the loader when it comes back instead
1494       * of doing it now.
1495       */
1496      public void startLoaderFromBackground() {
1497          boolean runLoader = false;
1498          if (mCallbacks != null) {
1499              Callbacks callbacks = mCallbacks.get();
1500              if (callbacks != null) {
1501                  // Only actually run the loader if they&#x27;re not paused.
1502                  if (!callbacks.setLoadOnResume()) {
1503                      runLoader = true;
1504                  }
1505              }
1506          }
1507          if (runLoader) {
1508              startLoader(false, PagedView.INVALID_RESTORE_PAGE);
1509          }
1510      }
1511  
1512      // If there is already a loader task running, tell it to stop.
1513      // returns true if isLaunching() was true on the old task
1514      private boolean stopLoaderLocked() {
1515          boolean isLaunching = false;
1516          LoaderTask oldTask = mLoaderTask;
1517          if (oldTask != null) {
1518              if (oldTask.isLaunching()) {
1519                  isLaunching = true;
1520              }
1521              oldTask.stopLocked();
1522          }
1523          return isLaunching;
1524      }
1525  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1526 +    public boolean isCurrentCallbacks(Callbacks callbacks) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1527 +        return (mCallbacks != null &amp;&amp; mCallbacks.get() == callbacks);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1528 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1529 +</span>
1530      public void startLoader(boolean isLaunching, int synchronousBindPage) {
1531          startLoader(isLaunching, synchronousBindPage, LOADER_FLAG_NONE);
1532      }
1533  
1534      public void startLoader(boolean isLaunching, int synchronousBindPage, int loadFlags) {
1535          synchronized (mLock) {
1536              if (DEBUG_LOADERS) {
1537                  Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
1538              }
1539  
1540              // Clear any deferred bind-runnables from the synchronized load process
1541              // We must do this before any loading/binding is scheduled below.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1542 -            mDeferredBindRunnables.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1543 +            synchronized (mDeferredBindRunnables) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1544 +                mDeferredBindRunnables.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1545 +            }</span>
1546  
1547              // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
1548              if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
1549                  // If there is already one running, tell it to stop.
1550                  // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
1551                  isLaunching = isLaunching || stopLoaderLocked();
1552                  mLoaderTask = new LoaderTask(mApp.getContext(), isLaunching, loadFlags);
1553                  if (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE
1554                          &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {
1555                      mLoaderTask.runBindSynchronousPage(synchronousBindPage);
1556                  } else {
1557                      sWorkerThread.setPriority(Thread.NORM_PRIORITY);
1558                      sWorker.post(mLoaderTask);
1559                  }
1560              }
1561          }
1562      }
1563  
1564      void bindRemainingSynchronousPages() {
1565          // Post the remaining side pages to be loaded
1566          if (!mDeferredBindRunnables.isEmpty()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1567 -            for (final Runnable r : mDeferredBindRunnables) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1568 +            Runnable[] deferredBindRunnables = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1569 +            synchronized (mDeferredBindRunnables) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1570 +                deferredBindRunnables = mDeferredBindRunnables.toArray(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1571 +                        new Runnable[mDeferredBindRunnables.size()]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1572 +                mDeferredBindRunnables.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1573 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1574 +            for (final Runnable r : deferredBindRunnables) {</span>
1575                  mHandler.post(r, MAIN_THREAD_BINDING_RUNNABLE);
1576              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1577 -            mDeferredBindRunnables.clear();</span>
1578          }
1579      }
1580  
1581      public void stopLoader() {
1582          synchronized (mLock) {
1583              if (mLoaderTask != null) {
1584                  mLoaderTask.stopLocked();
1585              }
1586          }
1587      }
1588  
1589      /** Loads the workspace screens db into a map of Rank -&gt; ScreenId */
1590      private static TreeMap&lt;Integer, Long&gt; loadWorkspaceScreensDb(Context context) {
1591          final ContentResolver contentResolver = context.getContentResolver();
1592          final Uri screensUri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1593          final Cursor sc = contentResolver.query(screensUri, null, null, null, null);
1594          TreeMap&lt;Integer, Long&gt; orderedScreens = new TreeMap&lt;Integer, Long&gt;();
1595  
1596          try {
1597              final int idIndex = sc.getColumnIndexOrThrow(
1598                      LauncherSettings.WorkspaceScreens._ID);
1599              final int rankIndex = sc.getColumnIndexOrThrow(
1600                      LauncherSettings.WorkspaceScreens.SCREEN_RANK);
1601              while (sc.moveToNext()) {
1602                  try {
1603                      long screenId = sc.getLong(idIndex);
1604                      int rank = sc.getInt(rankIndex);
1605                      orderedScreens.put(rank, screenId);
1606                  } catch (Exception e) {
1607                      Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e, true);
1608                  }
1609              }
1610          } finally {
1611              sc.close();
1612          }
1613  
1614          // Log to disk
1615          Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspaceScreensDb()&quot;, true);
1616          ArrayList&lt;String&gt; orderedScreensPairs= new ArrayList&lt;String&gt;();
1617          for (Integer i : orderedScreens.keySet()) {
1618              orderedScreensPairs.add(&quot;{ &quot; + i + &quot;: &quot; + orderedScreens.get(i) + &quot; }&quot;);
1619          }
1620          Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; +
1621                  TextUtils.join(&quot;, &quot;, orderedScreensPairs), true);
1622          return orderedScreens;
1623      }
1624  
1625      public boolean isAllAppsLoaded() {
1626          return mAllAppsLoaded;
1627      }
1628  
1629      boolean isLoadingWorkspace() {
1630          synchronized (mLock) {
1631              if (mLoaderTask != null) {
1632                  return mLoaderTask.isLoadingWorkspace();
1633              }
1634          }
1635          return false;
1636      }
1637  
1638      /**
1639       * Runnable for the thread that loads the contents of the launcher:
1640       *   - workspace icons
1641       *   - widgets
1642       *   - all apps icons
1643       */
1644      private class LoaderTask implements Runnable {
1645          private Context mContext;
1646          private boolean mIsLaunching;
1647          private boolean mIsLoadingAndBindingWorkspace;
1648          private boolean mStopped;
1649          private boolean mLoadAndBindStepFinished;
1650          private int mFlags;
1651  
1652          private HashMap&lt;Object, CharSequence&gt; mLabelCache;
1653  
1654          LoaderTask(Context context, boolean isLaunching, int flags) {
1655              mContext = context;
1656              mIsLaunching = isLaunching;
1657              mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
1658              mFlags = flags;
1659          }
1660  
1661          boolean isLaunching() {
1662              return mIsLaunching;
1663          }
1664  
1665          boolean isLoadingWorkspace() {
1666              return mIsLoadingAndBindingWorkspace;
1667          }
1668  
1669          /** Returns whether this is an upgrade path */
1670          private boolean loadAndBindWorkspace() {
1671              mIsLoadingAndBindingWorkspace = true;
1672  
1673              // Load the workspace
1674              if (DEBUG_LOADERS) {
1675                  Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1676              }
1677  
1678              boolean isUpgradePath = false;
1679              if (!mWorkspaceLoaded) {
1680                  isUpgradePath = loadWorkspace();
1681                  synchronized (LoaderTask.this) {
1682                      if (mStopped) {
1683                          return isUpgradePath;
1684                      }
1685                      mWorkspaceLoaded = true;
1686                  }
1687              }
1688  
1689              // Bind the workspace
1690              bindWorkspace(-1, isUpgradePath);
1691              return isUpgradePath;
1692          }
1693  
1694          private void waitForIdle() {
1695              // Wait until the either we&#x27;re stopped or the other threads are done.
1696              // This way we don&#x27;t start loading all apps until the workspace has settled
1697              // down.
1698              synchronized (LoaderTask.this) {
1699                  final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1700  
1701                  mHandler.postIdle(new Runnable() {
1702                          public void run() {
1703                              synchronized (LoaderTask.this) {
1704                                  mLoadAndBindStepFinished = true;
1705                                  if (DEBUG_LOADERS) {
1706                                      Log.d(TAG, &quot;done with previous binding step&quot;);
1707                                  }
1708                                  LoaderTask.this.notify();
1709                              }
1710                          }
1711                      });
1712  
1713                  while (!mStopped &amp;&amp; !mLoadAndBindStepFinished &amp;&amp; !mFlushingWorkerThread) {
1714                      try {
1715                          // Just in case mFlushingWorkerThread changes but we aren&#x27;t woken up,
1716                          // wait no longer than 1sec at a time
1717                          this.wait(1000);
1718                      } catch (InterruptedException ex) {
1719                          // Ignore
1720                      }
1721                  }
1722                  if (DEBUG_LOADERS) {
1723                      Log.d(TAG, &quot;waited &quot;
1724                              + (SystemClock.uptimeMillis()-workspaceWaitTime)
1725                              + &quot;ms for previous step to finish binding&quot;);
1726                  }
1727              }
1728          }
1729  
1730          void runBindSynchronousPage(int synchronousBindPage) {
1731              if (synchronousBindPage == PagedView.INVALID_RESTORE_PAGE) {
1732                  // Ensure that we have a valid page index to load synchronously
1733                  throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1734                          &quot;valid page index&quot;);
1735              }
1736              if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1737                  // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1738                  // loaded already (we should load everything asynchronously in that case)
1739                  throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1740              }
1741              synchronized (mLock) {
1742                  if (mIsLoaderTaskRunning) {
1743                      // Ensure that we are never running the background loading at this point since
1744                      // we also touch the background collections
1745                      throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1746                  }
1747              }
1748  
1749              // XXX: Throw an exception if we are already loading (since we touch the worker thread
1750              //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1751              //      this call is synchronous, we can get away with not locking).
1752  
1753              // The LauncherModel is static in the LauncherAppState and mHandler may have queued
1754              // operations from the previous activity.  We need to ensure that all queued operations
1755              // are executed before any synchronous binding work is done.
1756              mHandler.flush();
1757  
1758              // Divide the set of loaded items into those that we are binding synchronously, and
1759              // everything else that is to be bound normally (asynchronously).
1760              bindWorkspace(synchronousBindPage, false);
1761              // XXX: For now, continue posting the binding of AllApps as there are other issues that
1762              //      arise from that.
1763              onlyBindAllApps();
1764          }
1765  
1766          public void run() {
1767              boolean isUpgrade = false;
1768  
1769              synchronized (mLock) {
1770                  mIsLoaderTaskRunning = true;
1771              }
1772              // Optimize for end-user experience: if the Launcher is up and // running with the
1773              // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1774              // workspace first (default).
1775              keep_running: {
1776                  // Elevate priority when Home launches for the first time to avoid
1777                  // starving at boot time. Staring at a blank home is not cool.
1778                  synchronized (mLock) {
1779                      if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1780                              (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1781                      android.os.Process.setThreadPriority(mIsLaunching
1782                              ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1783                  }
1784                  if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1785                  isUpgrade = loadAndBindWorkspace();
1786  
1787                  if (mStopped) {
1788                      break keep_running;
1789                  }
1790  
1791                  // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1792                  // settled down.
1793                  synchronized (mLock) {
1794                      if (mIsLaunching) {
1795                          if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1796                          android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1797                      }
1798                  }
1799                  waitForIdle();
1800  
1801                  // second step
1802                  if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1803                  loadAndBindAllApps();
1804  
1805                  // Restore the default thread priority after we are done loading items
1806                  synchronized (mLock) {
1807                      android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1808                  }
1809              }
1810  
1811              // Update the saved icons if necessary
1812              if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1813              synchronized (sBgLock) {
1814                  for (Object key : sBgDbIconCache.keySet()) {
1815                      updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
1816                  }
1817                  sBgDbIconCache.clear();
1818              }
1819  
1820              if (LauncherAppState.isDisableAllApps()) {
1821                  // Ensure that all the applications that are in the system are
1822                  // represented on the home screen.
1823                  if (!UPGRADE_USE_MORE_APPS_FOLDER || !isUpgrade) {
1824                      verifyApplications();
1825                  }
1826              }
1827  
1828              // Clear out this reference, otherwise we end up holding it until all of the
1829              // callback runnables are done.
1830              mContext = null;
1831  
1832              synchronized (mLock) {
1833                  // If we are still the last one to be scheduled, remove ourselves.
1834                  if (mLoaderTask == this) {
1835                      mLoaderTask = null;
1836                  }
1837                  mIsLoaderTaskRunning = false;
1838              }
1839          }
1840  
1841          public void stopLocked() {
1842              synchronized (LoaderTask.this) {
1843                  mStopped = true;
1844                  this.notify();
1845              }
1846          }
1847  
1848          /**
1849           * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1850           * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1851           * object that was around when the deferred message was scheduled, and if there&#x27;s
1852           * a new Callbacks object around then also return null.  This will save us from
1853           * calling onto it with data that will be ignored.
1854           */
1855          Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1856              synchronized (mLock) {
1857                  if (mStopped) {
1858                      return null;
1859                  }
1860  
1861                  if (mCallbacks == null) {
1862                      return null;
1863                  }
1864  
1865                  final Callbacks callbacks = mCallbacks.get();
1866                  if (callbacks != oldCallbacks) {
1867                      return null;
1868                  }
1869                  if (callbacks == null) {
1870                      Log.w(TAG, &quot;no mCallbacks&quot;);
1871                      return null;
1872                  }
1873  
1874                  return callbacks;
1875              }
1876          }
1877  
1878          private void verifyApplications() {
1879              final Context context = mApp.getContext();
1880  
1881              // Cross reference all the applications in our apps list with items in the workspace
1882              ArrayList&lt;ItemInfo&gt; tmpInfos;
1883              ArrayList&lt;ItemInfo&gt; added = new ArrayList&lt;ItemInfo&gt;();
1884              synchronized (sBgLock) {
1885                  for (AppInfo app : mBgAllAppsList.data) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1886 -                    tmpInfos = getItemInfoForComponentName(app.componentName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1887 +                    tmpInfos = getItemInfoForComponentName(app.componentName, app.user);</span>
1888                      if (tmpInfos.isEmpty()) {
1889                          // We are missing an application icon, so add this to the workspace
1890                          added.add(app);
1891                          // This is a rare event, so lets log it
1892                          Log.e(TAG, &quot;Missing Application on load: &quot; + app);
1893                      }
1894                  }
1895              }
1896              if (!added.isEmpty()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1897 -                Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1898 -                addAndBindAddedApps(context, added, cb, new ArrayList&lt;AppInfo&gt;());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1899 +                addAndBindAddedWorkspaceApps(context, added);</span>
1900              }
1901          }
1902  
1903          // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1904          private boolean checkItemPlacement(HashMap&lt;Long, ItemInfo[][]&gt; occupied, ItemInfo item,
1905                                             AtomicBoolean deleteOnInvalidPlacement) {
1906              LauncherAppState app = LauncherAppState.getInstance();
1907              DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1908              final int countX = (int) grid.numColumns;
1909              final int countY = (int) grid.numRows;
1910  
1911              long containerIndex = item.screenId;
1912              if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1913                  // Return early if we detect that an item is under the hotseat button
1914                  if (mCallbacks == null ||
1915                          mCallbacks.get().isAllAppsButtonRank((int) item.screenId)) {
1916                      deleteOnInvalidPlacement.set(true);
1917                      Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1918                              + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1919                              + item.cellY + &quot;) occupied by all apps&quot;);
1920                      return false;
1921                  }
1922  
1923                  final ItemInfo[][] hotseatItems =
1924                          occupied.get((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT);
1925  
1926                  if (item.screenId &gt;= grid.numHotseatIcons) {
1927                      Log.e(TAG, &quot;Error loading shortcut &quot; + item
1928                              + &quot; into hotseat position &quot; + item.screenId
1929                              + &quot;, position out of bounds: (0 to &quot; + (grid.numHotseatIcons - 1)
1930                              + &quot;)&quot;);
1931                      return false;
1932                  }
1933  
1934                  if (hotseatItems != null) {
1935                      if (hotseatItems[(int) item.screenId][0] != null) {
1936                          Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1937                                  + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1938                                  + item.cellY + &quot;) occupied by &quot;
1939                                  + occupied.get(LauncherSettings.Favorites.CONTAINER_HOTSEAT)
1940                                  [(int) item.screenId][0]);
1941                              return false;
1942                      } else {
1943                          hotseatItems[(int) item.screenId][0] = item;
1944                          return true;
1945                      }
1946                  } else {
1947                      final ItemInfo[][] items = new ItemInfo[(int) grid.numHotseatIcons][1];
1948                      items[(int) item.screenId][0] = item;
1949                      occupied.put((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT, items);
1950                      return true;
1951                  }
1952              } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1953                  // Skip further checking if it is not the hotseat or workspace container
1954                  return true;
1955              }
1956  
1957              if (!occupied.containsKey(item.screenId)) {
1958                  ItemInfo[][] items = new ItemInfo[countX + 1][countY + 1];
1959                  occupied.put(item.screenId, items);
1960              }
1961  
1962              final ItemInfo[][] screens = occupied.get(item.screenId);
1963              if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1964                      item.cellX &lt; 0 || item.cellY &lt; 0 ||
1965                      item.cellX + item.spanX &gt; countX || item.cellY + item.spanY &gt; countY) {
1966                  Log.e(TAG, &quot;Error loading shortcut &quot; + item
1967                          + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1968                          + item.cellX + &quot;,&quot; + item.cellY
1969                          + &quot;) out of screen bounds ( &quot; + countX + &quot;x&quot; + countY + &quot;)&quot;);
1970                  return false;
1971              }
1972  
1973              // Check if any workspace icons overlap with each other
1974              for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1975                  for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1976                      if (screens[x][y] != null) {
1977                          Log.e(TAG, &quot;Error loading shortcut &quot; + item
1978                              + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1979                              + x + &quot;,&quot; + y
1980                              + &quot;) occupied by &quot;
1981                              + screens[x][y]);
1982                          return false;
1983                      }
1984                  }
1985              }
1986              for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1987                  for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1988                      screens[x][y] = item;
1989                  }
1990              }
1991  
1992              return true;
1993          }
1994  
1995          /** Clears all the sBg data structures */
1996          private void clearSBgDataStructures() {
1997              synchronized (sBgLock) {
1998                  sBgWorkspaceItems.clear();
1999                  sBgAppWidgets.clear();
2000                  sBgFolders.clear();
2001                  sBgItemsIdMap.clear();
2002                  sBgDbIconCache.clear();
2003                  sBgWorkspaceScreens.clear();
2004              }
2005          }
2006  
2007          /** Returns whether this is an upgrade path */
2008          private boolean loadWorkspace() {
2009              // Log to disk
2010              Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspace()&quot;, true);
2011  
2012              final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2013  
2014              final Context context = mContext;
2015              final ContentResolver contentResolver = context.getContentResolver();
2016              final PackageManager manager = context.getPackageManager();
2017              final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
2018              final boolean isSafeMode = manager.isSafeMode();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2019 +            final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2020 +            final boolean isSdCardReady = context.registerReceiver(null,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2021 +                    new IntentFilter(StartupReceiver.SYSTEM_READY)) != null;</span>
2022  
2023              LauncherAppState app = LauncherAppState.getInstance();
2024              DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2025              int countX = (int) grid.numColumns;
2026              int countY = (int) grid.numRows;
2027  
2028              if ((mFlags &amp; LOADER_FLAG_CLEAR_WORKSPACE) != 0) {
2029                  Launcher.addDumpLog(TAG, &quot;loadWorkspace: resetting launcher database&quot;, true);
2030                  LauncherAppState.getLauncherProvider().deleteDatabase();
2031              }
2032  
2033              if ((mFlags &amp; LOADER_FLAG_MIGRATE_SHORTCUTS) != 0) {
2034                  // append the user&#x27;s Launcher2 shortcuts
2035                  Launcher.addDumpLog(TAG, &quot;loadWorkspace: migrating from launcher2&quot;, true);
2036                  LauncherAppState.getLauncherProvider().migrateLauncher2Shortcuts();
2037              } else {
2038                  // Make sure the default workspace is loaded
2039                  Launcher.addDumpLog(TAG, &quot;loadWorkspace: loading default favorites&quot;, false);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2040 -                LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary(0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2041 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2042 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2043 -            // Check if we need to do any upgrade-path logic</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2044 -            // (Includes having just imported default favorites)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2045 -            boolean loadedOldDb = LauncherAppState.getLauncherProvider().justLoadedOldDb();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2046 +                LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2047 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2048 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2049 +            // This code path is for our old migration code and should no longer be exercised</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2050 +            boolean loadedOldDb = false;</span>
2051  
2052              // Log to disk
2053              Launcher.addDumpLog(TAG, &quot;11683562 -   loadedOldDb: &quot; + loadedOldDb, true);
2054  
2055              synchronized (sBgLock) {
2056                  clearSBgDataStructures();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2057 +                final HashSet&lt;String&gt; installingPkgs = PackageInstallerCompat</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2058 +                        .getInstance(mContext).updateAndGetActiveSessionCache();</span>
2059  
2060                  final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
2061                  final ArrayList&lt;Long&gt; restoredRows = new ArrayList&lt;Long&gt;();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2062 -                final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2063 +                final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION;</span>
2064                  if (DEBUG_LOADERS) Log.d(TAG, &quot;loading model from &quot; + contentUri);
2065                  final Cursor c = contentResolver.query(contentUri, null, null, null, null);
2066  
2067                  // +1 for the hotseat (it can be larger than the workspace)
2068                  // Load workspace in reverse order to ensure that latest items are loaded first (and
2069                  // before any earlier duplicates)
2070                  final HashMap&lt;Long, ItemInfo[][]&gt; occupied = new HashMap&lt;Long, ItemInfo[][]&gt;();
2071  
2072                  try {
2073                      final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
2074                      final int intentIndex = c.getColumnIndexOrThrow
2075                              (LauncherSettings.Favorites.INTENT);
2076                      final int titleIndex = c.getColumnIndexOrThrow
2077                              (LauncherSettings.Favorites.TITLE);
2078                      final int iconTypeIndex = c.getColumnIndexOrThrow(
2079                              LauncherSettings.Favorites.ICON_TYPE);
2080                      final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
2081                      final int iconPackageIndex = c.getColumnIndexOrThrow(
2082                              LauncherSettings.Favorites.ICON_PACKAGE);
2083                      final int iconResourceIndex = c.getColumnIndexOrThrow(
2084                              LauncherSettings.Favorites.ICON_RESOURCE);
2085                      final int containerIndex = c.getColumnIndexOrThrow(
2086                              LauncherSettings.Favorites.CONTAINER);
2087                      final int itemTypeIndex = c.getColumnIndexOrThrow(
2088                              LauncherSettings.Favorites.ITEM_TYPE);
2089                      final int appWidgetIdIndex = c.getColumnIndexOrThrow(
2090                              LauncherSettings.Favorites.APPWIDGET_ID);
2091                      final int appWidgetProviderIndex = c.getColumnIndexOrThrow(
2092                              LauncherSettings.Favorites.APPWIDGET_PROVIDER);
2093                      final int screenIndex = c.getColumnIndexOrThrow(
2094                              LauncherSettings.Favorites.SCREEN);
2095                      final int cellXIndex = c.getColumnIndexOrThrow
2096                              (LauncherSettings.Favorites.CELLX);
2097                      final int cellYIndex = c.getColumnIndexOrThrow
2098                              (LauncherSettings.Favorites.CELLY);
2099                      final int spanXIndex = c.getColumnIndexOrThrow
2100                              (LauncherSettings.Favorites.SPANX);
2101                      final int spanYIndex = c.getColumnIndexOrThrow(
2102                              LauncherSettings.Favorites.SPANY);
2103                      final int restoredIndex = c.getColumnIndexOrThrow(
2104                              LauncherSettings.Favorites.RESTORED);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2105 +                    final int profileIdIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2106 +                            LauncherSettings.Favorites.PROFILE_ID);</span>
2107                      //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
2108                      //final int displayModeIndex = c.getColumnIndexOrThrow(
2109                      //        LauncherSettings.Favorites.DISPLAY_MODE);
2110  
2111                      ShortcutInfo info;
2112                      String intentDescription;
2113                      LauncherAppWidgetInfo appWidgetInfo;
2114                      int container;
2115                      long id;
2116                      Intent intent;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2117 +                    UserHandleCompat user;</span>
2118  
2119                      while (!mStopped &amp;&amp; c.moveToNext()) {
2120                          AtomicBoolean deleteOnInvalidPlacement = new AtomicBoolean(false);
2121                          try {
2122                              int itemType = c.getInt(itemTypeIndex);
2123                              boolean restored = 0 != c.getInt(restoredIndex);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2124 +                            boolean allowMissingTarget = false;</span>
2125  
2126                              switch (itemType) {
2127                              case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
2128                              case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
2129                                  id = c.getLong(idIndex);
2130                                  intentDescription = c.getString(intentIndex);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2131 +                                long serialNumber = c.getInt(profileIdIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2132 +                                user = mUserManager.getUserForSerialNumber(serialNumber);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2133 +                                int promiseType = c.getInt(restoredIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2134 +                                if (user == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2135 +                                    // User has been deleted remove the item.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2136 +                                    itemsToRemove.add(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2137 +                                    continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2138 +                                }</span>
2139                                  try {
2140                                      intent = Intent.parseUri(intentDescription, 0);
2141                                      ComponentName cn = intent.getComponent();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2142 -                                    if (cn != null &amp;&amp; !isValidPackageComponent(manager, cn)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2143 -                                        if (restored) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2144 -                                            // might be installed later</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2145 +                                    if (cn != null &amp;&amp; cn.getPackageName() != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2146 +                                        boolean validPkg = launcherApps.isPackageEnabledForProfile(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2147 +                                                cn.getPackageName(), user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2148 +                                        boolean validComponent = validPkg &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2149 +                                                launcherApps.isActivityEnabledForProfile(cn, user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2150 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2151 +                                        if (validComponent) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2152 +                                            if (restored) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2153 +                                                // no special handling necessary for this item</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2154 +                                                restoredRows.add(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2155 +                                                restored = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2156 +                                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2157 +                                        } else if (validPkg) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2158 +                                            intent = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2159 +                                            if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2160 +                                                // We allow auto install apps to have their intent</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2161 +                                                // updated after an install.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2162 +                                                intent = manager.getLaunchIntentForPackage(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2163 +                                                        cn.getPackageName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2164 +                                                if (intent != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2165 +                                                    ContentValues values = new ContentValues();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2166 +                                                    values.put(LauncherSettings.Favorites.INTENT,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2167 +                                                            intent.toUri(0));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2168 +                                                    String where = BaseColumns._ID + &quot;= ?&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2169 +                                                    String[] args = {Long.toString(id)};</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2170 +                                                    contentResolver.update(contentUri, values, where, args);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2171 +                                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2172 +                                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2173 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2174 +                                            if (intent == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2175 +                                                // The app is installed but the component is no</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2176 +                                                // longer available.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2177 +                                                Launcher.addDumpLog(TAG,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2178 +                                                        &quot;Invalid component removed: &quot; + cn, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2179 +                                                itemsToRemove.add(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2180 +                                                continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2181 +                                            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2182 +                                                // no special handling necessary for this item</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2183 +                                                restoredRows.add(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2184 +                                                restored = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2185 +                                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2186 +                                        } else if (restored) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2187 +                                            // Package is not yet available but might be</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2188 +                                            // installed later.</span>
2189                                              Launcher.addDumpLog(TAG,
2190                                                      &quot;package not yet restored: &quot; + cn, true);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2191 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2192 +                                            if ((promiseType &amp; ShortcutInfo.FLAG_RESTORE_STARTED) != 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2193 +                                                // Restore has started once.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2194 +                                            } else if (installingPkgs.contains(cn.getPackageName())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2195 +                                                // App restore has started. Update the flag</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2196 +                                                promiseType |= ShortcutInfo.FLAG_RESTORE_STARTED;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2197 +                                                ContentValues values = new ContentValues();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2198 +                                                values.put(LauncherSettings.Favorites.RESTORED,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2199 +                                                        promiseType);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2200 +                                                String where = BaseColumns._ID + &quot;= ?&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2201 +                                                String[] args = {Long.toString(id)};</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2202 +                                                contentResolver.update(contentUri, values, where, args);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2203 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2204 +                                            } else if (REMOVE_UNRESTORED_ICONS) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2205 +                                                Launcher.addDumpLog(TAG,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2206 +                                                        &quot;Unrestored package removed: &quot; + cn, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2207 +                                                itemsToRemove.add(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2208 +                                                continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2209 +                                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2210 +                                        } else if (isSdCardReady) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2211 +                                            // Do not wait for external media load anymore.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2212 +                                            // Log the invalid package, and remove it</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2213 +                                            Launcher.addDumpLog(TAG,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2214 +                                                    &quot;Invalid package removed: &quot; + cn, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2215 +                                            itemsToRemove.add(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2216 +                                            continue;</span>
2217                                          } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2218 -                                            if (!mAppsCanBeOnRemoveableStorage) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2219 -                                                // Log the invalid package, and remove it</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2220 -                                                Launcher.addDumpLog(TAG,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2221 -                                                        &quot;Invalid package removed: &quot; + cn, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2222 -                                                itemsToRemove.add(id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2223 -                                            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2224 -                                                // If apps can be on external storage, then we just</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2225 -                                                // leave them for the user to remove (maybe add</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2226 -                                                // visual treatment to it)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2227 -                                                Launcher.addDumpLog(TAG,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2228 -                                                        &quot;Invalid package found: &quot; + cn, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2229 +                                            // SdCard is not ready yet. Package might get available,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2230 +                                            // once it is ready.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2231 +                                            Launcher.addDumpLog(TAG, &quot;Invalid package: &quot; + cn</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2232 +                                                    + &quot; (check again later)&quot;, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2233 +                                            HashSet&lt;String&gt; pkgs = sPendingPackages.get(user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2234 +                                            if (pkgs == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2235 +                                                pkgs = new HashSet&lt;String&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2236 +                                                sPendingPackages.put(user, pkgs);</span>
2237                                              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2238 -                                            continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2239 +                                            pkgs.add(cn.getPackageName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2240 +                                            allowMissingTarget = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2241 +                                            // Add the icon on the workspace anyway.</span>
2242                                          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2243 -                                    } else if (restored) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2244 -                                        // no special handling necessary for this restored item</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2245 +                                    } else if (cn == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2246 +                                        // For shortcuts with no component, keep them as they are</span>
2247                                          restoredRows.add(id);
2248                                          restored = false;
2249                                      }
2250                                  } catch (URISyntaxException e) {
2251                                      Launcher.addDumpLog(TAG,
2252                                              &quot;Invalid uri: &quot; + intentDescription, true);
2253                                      continue;
2254                                  }
2255  
2256                                  if (restored) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2257 -                                    Launcher.addDumpLog(TAG,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2258 -                                            &quot;constructing info for partially restored package&quot;,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2259 -                                            true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2260 -                                    info = getRestoredItemInfo(c, titleIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2261 -                                    intent = getRestoredItemIntent(c, context, intent);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2262 +                                    if (user.equals(UserHandleCompat.myUserHandle())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2263 +                                        Launcher.addDumpLog(TAG,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2264 +                                                &quot;constructing info for partially restored package&quot;,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2265 +                                                true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2266 +                                        info = getRestoredItemInfo(c, titleIndex, intent, promiseType);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2267 +                                        intent = getRestoredItemIntent(c, context, intent);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2268 +                                    } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2269 +                                        // Don&#x27;t restore items for other profiles.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2270 +                                        itemsToRemove.add(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2271 +                                        continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2272 +                                    }</span>
2273                                  } else if (itemType ==
2274                                          LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2275 -                                    info = getShortcutInfo(manager, intent, context, c, iconIndex,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2276 -                                            titleIndex, mLabelCache);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2277 +                                    info = getShortcutInfo(manager, intent, user, context, c,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2278 +                                            iconIndex, titleIndex, mLabelCache, allowMissingTarget);</span>
2279                                  } else {
2280                                      info = getShortcutInfo(c, context, iconTypeIndex,
2281                                              iconPackageIndex, iconResourceIndex, iconIndex,
2282                                              titleIndex);
2283  
2284                                      // App shortcuts that used to be automatically added to Launcher
2285                                      // didn&#x27;t always have the correct intent flags set, so do that
2286                                      // here
2287                                      if (intent.getAction() != null &amp;&amp;
2288                                          intent.getCategories() != null &amp;&amp;
2289                                          intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
2290                                          intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
2291                                          intent.addFlags(
2292                                              Intent.FLAG_ACTIVITY_NEW_TASK |
2293                                              Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
2294                                      }
2295                                  }
2296  
2297                                  if (info != null) {
2298                                      info.id = id;
2299                                      info.intent = intent;
2300                                      container = c.getInt(containerIndex);
2301                                      info.container = container;
2302                                      info.screenId = c.getInt(screenIndex);
2303                                      info.cellX = c.getInt(cellXIndex);
2304                                      info.cellY = c.getInt(cellYIndex);
2305                                      info.spanX = 1;
2306                                      info.spanY = 1;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2307 +                                    info.intent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2308 +                                    info.isDisabled = isSafeMode</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2309 +                                            &amp;&amp; !Utilities.isSystemApp(context, intent);</span>
2310  
2311                                      // check &amp; update map of what&#x27;s occupied
2312                                      deleteOnInvalidPlacement.set(false);
2313                                      if (!checkItemPlacement(occupied, info, deleteOnInvalidPlacement)) {
2314                                          if (deleteOnInvalidPlacement.get()) {
2315                                              itemsToRemove.add(id);
2316                                          }
2317                                          break;
2318                                      }
2319  
2320                                      switch (container) {
2321                                      case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2322                                      case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2323                                          sBgWorkspaceItems.add(info);
2324                                          break;
2325                                      default:
2326                                          // Item is in a user folder
2327                                          FolderInfo folderInfo =
2328                                                  findOrMakeFolder(sBgFolders, container);
2329                                          folderInfo.add(info);
2330                                          break;
2331                                      }
2332                                      sBgItemsIdMap.put(info.id, info);
2333  
2334                                      // now that we&#x27;ve loaded everthing re-save it with the
2335                                      // icon in case it disappears somehow.
2336                                      queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
2337                                  } else {
2338                                      throw new RuntimeException(&quot;Unexpected null ShortcutInfo&quot;);
2339                                  }
2340                                  break;
2341  
2342                              case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
2343                                  id = c.getLong(idIndex);
2344                                  FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
2345  
2346                                  folderInfo.title = c.getString(titleIndex);
2347                                  folderInfo.id = id;
2348                                  container = c.getInt(containerIndex);
2349                                  folderInfo.container = container;
2350                                  folderInfo.screenId = c.getInt(screenIndex);
2351                                  folderInfo.cellX = c.getInt(cellXIndex);
2352                                  folderInfo.cellY = c.getInt(cellYIndex);
2353                                  folderInfo.spanX = 1;
2354                                  folderInfo.spanY = 1;
2355  
2356                                  // check &amp; update map of what&#x27;s occupied
2357                                  deleteOnInvalidPlacement.set(false);
2358                                  if (!checkItemPlacement(occupied, folderInfo,
2359                                          deleteOnInvalidPlacement)) {
2360                                      if (deleteOnInvalidPlacement.get()) {
2361                                          itemsToRemove.add(id);
2362                                      }
2363                                      break;
2364                                  }
2365  
2366                                  switch (container) {
2367                                      case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2368                                      case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2369                                          sBgWorkspaceItems.add(folderInfo);
2370                                          break;
2371                                  }
2372  
2373                                  if (restored) {
2374                                      // no special handling required for restored folders
2375                                      restoredRows.add(id);
2376                                  }
2377  
2378                                  sBgItemsIdMap.put(folderInfo.id, folderInfo);
2379                                  sBgFolders.put(folderInfo.id, folderInfo);
2380                                  break;
2381  
2382                              case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
2383                                  // Read all Launcher-specific widget details
2384                                  int appWidgetId = c.getInt(appWidgetIdIndex);
2385                                  String savedProvider = c.getString(appWidgetProviderIndex);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2386 -</span>
2387                                  id = c.getLong(idIndex);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2388 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2389 -                                final AppWidgetProviderInfo provider =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2390 -                                        widgets.getAppWidgetInfo(appWidgetId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2391 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2392 -                                if (!isSafeMode &amp;&amp; (provider == null || provider.provider == null ||</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2393 -                                        provider.provider.getPackageName() == null)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2394 -                                    String log = &quot;Deleting widget that isn&#x27;t installed anymore: id=&quot;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2395 -                                        + id + &quot; appWidgetId=&quot; + appWidgetId;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2396 +                                final ComponentName component =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2397 +                                        ComponentName.unflattenFromString(savedProvider);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2398 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2399 +                                final int restoreStatus = c.getInt(restoredIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2400 +                                final boolean isIdValid = (restoreStatus &amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2401 +                                        LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) == 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2402 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2403 +                                final boolean wasProviderReady = (restoreStatus &amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2404 +                                        LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) == 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2405 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2406 +                                final AppWidgetProviderInfo provider = isIdValid</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2407 +                                        ? widgets.getAppWidgetInfo(appWidgetId)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2408 +                                        : findAppWidgetProviderInfoWithComponent(context, component);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2409 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2410 +                                final boolean isProviderReady = isValidProvider(provider);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2411 +                                if (!isSafeMode &amp;&amp; wasProviderReady &amp;&amp; !isProviderReady) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2412 +                                    String log = &quot;Deleting widget that isn&#x27;t installed anymore: &quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2413 +                                            + &quot;id=&quot; + id + &quot; appWidgetId=&quot; + appWidgetId;</span>
2414                                      Log.e(TAG, log);
2415                                      Launcher.addDumpLog(TAG, log, false);
2416                                      itemsToRemove.add(id);
2417                                  } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2418 -                                    appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2419 -                                            provider.provider);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2420 +                                    if (isProviderReady) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2421 +                                        appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2422 +                                                provider.provider);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2423 +                                        int[] minSpan =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2424 +                                                Launcher.getMinSpanForWidget(context, provider);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2425 +                                        appWidgetInfo.minSpanX = minSpan[0];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2426 +                                        appWidgetInfo.minSpanY = minSpan[1];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2427 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2428 +                                        int status = restoreStatus;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2429 +                                        if (!wasProviderReady) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2430 +                                            // If provider was not previously ready, update the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2431 +                                            // status and UI flag.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2432 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="2433 +                                            // Id would be valid only if the widget restore broadcast was received.">2433 +                                            // Id would be valid only if the widget restore broadcast was received</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2434 +                                            if (isIdValid) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2435 +                                                status = LauncherAppWidgetInfo.RESTORE_COMPLETED;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2436 +                                            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2437 +                                                status &amp;= ~LauncherAppWidgetInfo</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2438 +                                                        .FLAG_PROVIDER_NOT_READY;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2439 +                                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2440 +                                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2441 +                                        appWidgetInfo.restoreStatus = status;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2442 +                                    } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2443 +                                        Log.v(TAG, &quot;Widget restore pending id=&quot; + id</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2444 +                                                + &quot; appWidgetId=&quot; + appWidgetId</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2445 +                                                + &quot; status =&quot; + restoreStatus);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2446 +                                        appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2447 +                                                component);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2448 +                                        appWidgetInfo.restoreStatus = restoreStatus;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2449 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2450 +                                        if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) != 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2451 +                                            // Restore has started once.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2452 +                                        } else if (installingPkgs.contains(component.getPackageName())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2453 +                                            // App restore has started. Update the flag</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2454 +                                            appWidgetInfo.restoreStatus |=</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2455 +                                                    LauncherAppWidgetInfo.FLAG_RESTORE_STARTED;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2456 +                                        } else if (REMOVE_UNRESTORED_ICONS) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2457 +                                            Launcher.addDumpLog(TAG,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2458 +                                                    &quot;Unrestored widget removed: &quot; + component, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2459 +                                            itemsToRemove.add(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2460 +                                            continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2461 +                                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2462 +                                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2463 +</span>
2464                                      appWidgetInfo.id = id;
2465                                      appWidgetInfo.screenId = c.getInt(screenIndex);
2466                                      appWidgetInfo.cellX = c.getInt(cellXIndex);
2467                                      appWidgetInfo.cellY = c.getInt(cellYIndex);
2468                                      appWidgetInfo.spanX = c.getInt(spanXIndex);
2469                                      appWidgetInfo.spanY = c.getInt(spanYIndex);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2470 -                                    int[] minSpan = Launcher.getMinSpanForWidget(context, provider);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2471 -                                    appWidgetInfo.minSpanX = minSpan[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2472 -                                    appWidgetInfo.minSpanY = minSpan[1];</span>
2473  
2474                                      container = c.getInt(containerIndex);
2475                                      if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2476                                          container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2477                                          Log.e(TAG, &quot;Widget found where container != &quot; +
2478                                              &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
2479                                          continue;
2480                                      }
2481  
2482                                      appWidgetInfo.container = c.getInt(containerIndex);
2483                                      // check &amp; update map of what&#x27;s occupied
2484                                      deleteOnInvalidPlacement.set(false);
2485                                      if (!checkItemPlacement(occupied, appWidgetInfo,
2486                                              deleteOnInvalidPlacement)) {
2487                                          if (deleteOnInvalidPlacement.get()) {
2488                                              itemsToRemove.add(id);
2489                                          }
2490                                          break;
2491                                      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2492 -                                    String providerName = provider.provider.flattenToString();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2493 -                                    if (!providerName.equals(savedProvider)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2494 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2495 +                                    String providerName = appWidgetInfo.providerName.flattenToString();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2496 +                                    if (!providerName.equals(savedProvider) ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2497 +                                            (appWidgetInfo.restoreStatus != restoreStatus)) {</span>
2498                                          ContentValues values = new ContentValues();
2499                                          values.put(LauncherSettings.Favorites.APPWIDGET_PROVIDER,
2500                                                  providerName);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2501 +                                        values.put(LauncherSettings.Favorites.RESTORED,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2502 +                                                appWidgetInfo.restoreStatus);</span>
2503                                          String where = BaseColumns._ID + &quot;= ?&quot;;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2504 -                                        String[] args = {Integer.toString(c.getInt(idIndex))};</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2505 +                                        String[] args = {Long.toString(id)};</span>
2506                                          contentResolver.update(contentUri, values, where, args);
2507                                      }
2508                                      sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
2509                                      sBgAppWidgets.add(appWidgetInfo);
2510                                  }
2511                                  break;
2512                              }
2513                          } catch (Exception e) {
2514                              Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;, e, true);
2515                          }
2516                      }
2517                  } finally {
2518                      if (c != null) {
2519                          c.close();
2520                      }
2521                  }
2522  
2523                  // Break early if we&#x27;ve stopped loading
2524                  if (mStopped) {
2525                      clearSBgDataStructures();
2526                      return false;
2527                  }
2528  
2529                  if (itemsToRemove.size() &gt; 0) {
2530                      ContentProviderClient client = contentResolver.acquireContentProviderClient(
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2531 -                            LauncherSettings.Favorites.CONTENT_URI);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2532 +                            contentUri);</span>
2533                      // Remove dead items
2534                      for (long id : itemsToRemove) {
2535                          if (DEBUG_LOADERS) {
2536                              Log.d(TAG, &quot;Removed id = &quot; + id);
2537                          }
2538                          // Don&#x27;t notify content observers
2539                          try {
2540                              client.delete(LauncherSettings.Favorites.getContentUri(id, false),
2541                                      null, null);
2542                          } catch (RemoteException e) {
2543                              Log.w(TAG, &quot;Could not remove id = &quot; + id);
2544                          }
2545                      }
2546                  }
2547  
2548                  if (restoredRows.size() &gt; 0) {
2549                      ContentProviderClient updater = contentResolver.acquireContentProviderClient(
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2550 -                            LauncherSettings.Favorites.CONTENT_URI);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2551 +                            contentUri);</span>
2552                      // Update restored items that no longer require special handling
2553                      try {
2554                          StringBuilder selectionBuilder = new StringBuilder();
2555                          selectionBuilder.append(LauncherSettings.Favorites._ID);
2556                          selectionBuilder.append(&quot; IN (&quot;);
2557                          selectionBuilder.append(TextUtils.join(&quot;, &quot;, restoredRows));
2558                          selectionBuilder.append(&quot;)&quot;);
2559                          ContentValues values = new ContentValues();
2560                          values.put(LauncherSettings.Favorites.RESTORED, 0);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2561 -                        updater.update(LauncherSettings.Favorites.CONTENT_URI,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2562 +                        updater.update(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,</span>
2563                                  values, selectionBuilder.toString(), null);
2564                      } catch (RemoteException e) {
2565                          Log.w(TAG, &quot;Could not update restored rows&quot;);
2566                      }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2567 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2568 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2569 +                if (!isSdCardReady &amp;&amp; !sPendingPackages.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2570 +                    context.registerReceiver(new AppsAvailabilityCheck(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2571 +                            new IntentFilter(StartupReceiver.SYSTEM_READY),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2572 +                            null, sWorker);</span>
2573                  }
2574  
2575                  if (loadedOldDb) {
2576                      long maxScreenId = 0;
2577                      // If we&#x27;re importing we use the old screen order.
2578                      for (ItemInfo item: sBgItemsIdMap.values()) {
2579                          long screenId = item.screenId;
2580                          if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2581                                  !sBgWorkspaceScreens.contains(screenId)) {
2582                              sBgWorkspaceScreens.add(screenId);
2583                              if (screenId &gt; maxScreenId) {
2584                                  maxScreenId = screenId;
2585                              }
2586                          }
2587                      }
2588                      Collections.sort(sBgWorkspaceScreens);
2589                      // Log to disk
2590                      Launcher.addDumpLog(TAG, &quot;11683562 -   maxScreenId: &quot; + maxScreenId, true);
2591                      Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2592                              TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2593  
2594                      LauncherAppState.getLauncherProvider().updateMaxScreenId(maxScreenId);
2595                      updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2596  
2597                      // Update the max item id after we load an old db
2598                      long maxItemId = 0;
2599                      // If we&#x27;re importing we use the old screen order.
2600                      for (ItemInfo item: sBgItemsIdMap.values()) {
2601                          maxItemId = Math.max(maxItemId, item.id);
2602                      }
2603                      LauncherAppState.getLauncherProvider().updateMaxItemId(maxItemId);
2604                  } else {
2605                      TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(mContext);
2606                      for (Integer i : orderedScreens.keySet()) {
2607                          sBgWorkspaceScreens.add(orderedScreens.get(i));
2608                      }
2609                      // Log to disk
2610                      Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2611                              TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2612  
2613                      // Remove any empty screens
2614                      ArrayList&lt;Long&gt; unusedScreens = new ArrayList&lt;Long&gt;(sBgWorkspaceScreens);
2615                      for (ItemInfo item: sBgItemsIdMap.values()) {
2616                          long screenId = item.screenId;
2617                          if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2618                                  unusedScreens.contains(screenId)) {
2619                              unusedScreens.remove(screenId);
2620                          }
2621                      }
2622  
2623                      // If there are any empty screens remove them, and update.
2624                      if (unusedScreens.size() != 0) {
2625                          // Log to disk
2626                          Launcher.addDumpLog(TAG, &quot;11683562 -   unusedScreens (to be removed): &quot; +
2627                                  TextUtils.join(&quot;, &quot;, unusedScreens), true);
2628  
2629                          sBgWorkspaceScreens.removeAll(unusedScreens);
2630                          updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2631                      }
2632                  }
2633  
2634                  if (DEBUG_LOADERS) {
2635                      Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2636                      Log.d(TAG, &quot;workspace layout: &quot;);
2637                      int nScreens = occupied.size();
2638                      for (int y = 0; y &lt; countY; y++) {
2639                          String line = &quot;&quot;;
2640  
2641                          Iterator&lt;Long&gt; iter = occupied.keySet().iterator();
2642                          while (iter.hasNext()) {
2643                              long screenId = iter.next();
2644                              if (screenId &gt; 0) {
2645                                  line += &quot; | &quot;;
2646                              }
2647                              for (int x = 0; x &lt; countX; x++) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2648 -                                line += ((occupied.get(screenId)[x][y] != null) ? &quot;#&quot; : &quot;.&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2649 +                                ItemInfo[][] screen = occupied.get(screenId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2650 +                                if (x &lt; screen.length &amp;&amp; y &lt; screen[x].length) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2651 +                                    line += (screen[x][y] != null) ? &quot;#&quot; : &quot;.&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2652 +                                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2653 +                                    line += &quot;!&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2654 +                                }</span>
2655                              }
2656                          }
2657                          Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
2658                      }
2659                  }
2660              }
2661              return loadedOldDb;
2662          }
2663  
2664          /** Filters the set of items who are directly or indirectly (via another container) on the
2665           * specified screen. */
2666          private void filterCurrentWorkspaceItems(long currentScreenId,
2667                  ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
2668                  ArrayList&lt;ItemInfo&gt; currentScreenItems,
2669                  ArrayList&lt;ItemInfo&gt; otherScreenItems) {
2670              // Purge any null ItemInfos
2671              Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
2672              while (iter.hasNext()) {
2673                  ItemInfo i = iter.next();
2674                  if (i == null) {
2675                      iter.remove();
2676                  }
2677              }
2678  
2679              // Order the set of items by their containers first, this allows use to walk through the
2680              // list sequentially, build up a list of containers that are in the specified screen,
2681              // as well as all items in those containers.
2682              Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
2683              Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
2684                  @Override
2685                  public int compare(ItemInfo lhs, ItemInfo rhs) {
2686                      return (int) (lhs.container - rhs.container);
2687                  }
2688              });
2689              for (ItemInfo info : allWorkspaceItems) {
2690                  if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2691                      if (info.screenId == currentScreenId) {
2692                          currentScreenItems.add(info);
2693                          itemsOnScreen.add(info.id);
2694                      } else {
2695                          otherScreenItems.add(info);
2696                      }
2697                  } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2698                      currentScreenItems.add(info);
2699                      itemsOnScreen.add(info.id);
2700                  } else {
2701                      if (itemsOnScreen.contains(info.container)) {
2702                          currentScreenItems.add(info);
2703                          itemsOnScreen.add(info.id);
2704                      } else {
2705                          otherScreenItems.add(info);
2706                      }
2707                  }
2708              }
2709          }
2710  
2711          /** Filters the set of widgets which are on the specified screen. */
2712          private void filterCurrentAppWidgets(long currentScreenId,
2713                  ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2714                  ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
2715                  ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
2716  
2717              for (LauncherAppWidgetInfo widget : appWidgets) {
2718                  if (widget == null) continue;
2719                  if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2720                          widget.screenId == currentScreenId) {
2721                      currentScreenWidgets.add(widget);
2722                  } else {
2723                      otherScreenWidgets.add(widget);
2724                  }
2725              }
2726          }
2727  
2728          /** Filters the set of folders which are on the specified screen. */
2729          private void filterCurrentFolders(long currentScreenId,
2730                  HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
2731                  HashMap&lt;Long, FolderInfo&gt; folders,
2732                  HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
2733                  HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
2734  
2735              for (long id : folders.keySet()) {
2736                  ItemInfo info = itemsIdMap.get(id);
2737                  FolderInfo folder = folders.get(id);
2738                  if (info == null || folder == null) continue;
2739                  if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2740                          info.screenId == currentScreenId) {
2741                      currentScreenFolders.put(id, folder);
2742                  } else {
2743                      otherScreenFolders.put(id, folder);
2744                  }
2745              }
2746          }
2747  
2748          /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
2749           * right) */
2750          private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
2751              final LauncherAppState app = LauncherAppState.getInstance();
2752              final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2753              // XXX: review this
2754              Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
2755                  @Override
2756                  public int compare(ItemInfo lhs, ItemInfo rhs) {
2757                      int cellCountX = (int) grid.numColumns;
2758                      int cellCountY = (int) grid.numRows;
2759                      int screenOffset = cellCountX * cellCountY;
2760                      int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
2761                      long lr = (lhs.container * containerOffset + lhs.screenId * screenOffset +
2762                              lhs.cellY * cellCountX + lhs.cellX);
2763                      long rr = (rhs.container * containerOffset + rhs.screenId * screenOffset +
2764                              rhs.cellY * cellCountX + rhs.cellX);
2765                      return (int) (lr - rr);
2766                  }
2767              });
2768          }
2769  
2770          private void bindWorkspaceScreens(final Callbacks oldCallbacks,
2771                  final ArrayList&lt;Long&gt; orderedScreens) {
2772              final Runnable r = new Runnable() {
2773                  @Override
2774                  public void run() {
2775                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2776                      if (callbacks != null) {
2777                          callbacks.bindScreens(orderedScreens);
2778                      }
2779                  }
2780              };
2781              runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2782          }
2783  
2784          private void bindWorkspaceItems(final Callbacks oldCallbacks,
2785                  final ArrayList&lt;ItemInfo&gt; workspaceItems,
2786                  final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2787                  final HashMap&lt;Long, FolderInfo&gt; folders,
2788                  ArrayList&lt;Runnable&gt; deferredBindRunnables) {
2789  
2790              final boolean postOnMainThread = (deferredBindRunnables != null);
2791  
2792              // Bind the workspace items
2793              int N = workspaceItems.size();
2794              for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
2795                  final int start = i;
2796                  final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
2797                  final Runnable r = new Runnable() {
2798                      @Override
2799                      public void run() {
2800                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2801                          if (callbacks != null) {
2802                              callbacks.bindItems(workspaceItems, start, start+chunkSize,
2803                                      false);
2804                          }
2805                      }
2806                  };
2807                  if (postOnMainThread) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2808 -                    deferredBindRunnables.add(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2809 +                    synchronized (deferredBindRunnables) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2810 +                        deferredBindRunnables.add(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2811 +                    }</span>
2812                  } else {
2813                      runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2814                  }
2815              }
2816  
2817              // Bind the folders
2818              if (!folders.isEmpty()) {
2819                  final Runnable r = new Runnable() {
2820                      public void run() {
2821                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2822                          if (callbacks != null) {
2823                              callbacks.bindFolders(folders);
2824                          }
2825                      }
2826                  };
2827                  if (postOnMainThread) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2828 -                    deferredBindRunnables.add(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2829 +                    synchronized (deferredBindRunnables) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2830 +                        deferredBindRunnables.add(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2831 +                    }</span>
2832                  } else {
2833                      runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2834                  }
2835              }
2836  
2837              // Bind the widgets, one at a time
2838              N = appWidgets.size();
2839              for (int i = 0; i &lt; N; i++) {
2840                  final LauncherAppWidgetInfo widget = appWidgets.get(i);
2841                  final Runnable r = new Runnable() {
2842                      public void run() {
2843                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2844                          if (callbacks != null) {
2845                              callbacks.bindAppWidget(widget);
2846                          }
2847                      }
2848                  };
2849                  if (postOnMainThread) {
2850                      deferredBindRunnables.add(r);
2851                  } else {
2852                      runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2853                  }
2854              }
2855          }
2856  
2857          /**
2858           * Binds all loaded data to actual views on the main thread.
2859           */
2860          private void bindWorkspace(int synchronizeBindPage, final boolean isUpgradePath) {
2861              final long t = SystemClock.uptimeMillis();
2862              Runnable r;
2863  
2864              // Don&#x27;t use these two variables in any of the callback runnables.
2865              // Otherwise we hold a reference to them.
2866              final Callbacks oldCallbacks = mCallbacks.get();
2867              if (oldCallbacks == null) {
2868                  // This launcher has exited and nobody bothered to tell us.  Just bail.
2869                  Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
2870                  return;
2871              }
2872  
2873              // Save a copy of all the bg-thread collections
2874              ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
2875              ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
2876                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2877              HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
2878              HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
2879              ArrayList&lt;Long&gt; orderedScreenIds = new ArrayList&lt;Long&gt;();
2880              synchronized (sBgLock) {
2881                  workspaceItems.addAll(sBgWorkspaceItems);
2882                  appWidgets.addAll(sBgAppWidgets);
2883                  folders.putAll(sBgFolders);
2884                  itemsIdMap.putAll(sBgItemsIdMap);
2885                  orderedScreenIds.addAll(sBgWorkspaceScreens);
2886              }
2887  
2888              final boolean isLoadingSynchronously =
2889                      synchronizeBindPage != PagedView.INVALID_RESTORE_PAGE;
2890              int currScreen = isLoadingSynchronously ? synchronizeBindPage :
2891                  oldCallbacks.getCurrentWorkspaceScreen();
2892              if (currScreen &gt;= orderedScreenIds.size()) {
2893                  // There may be no workspace screens (just hotseat items and an empty page).
2894                  currScreen = PagedView.INVALID_RESTORE_PAGE;
2895              }
2896              final int currentScreen = currScreen;
2897              final long currentScreenId = currentScreen &lt; 0
2898                      ? INVALID_SCREEN_ID : orderedScreenIds.get(currentScreen);
2899  
2900              // Load all the items that are on the current page first (and in the process, unbind
2901              // all the existing workspace items before we call startBinding() below.
2902              unbindWorkspaceItemsOnMainThread();
2903  
2904              // Separate the items that are on the current screen, and all the other remaining items
2905              ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2906              ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2907              ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
2908                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2909              ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
2910                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2911              HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
2912              HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
2913  
2914              filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems,
2915                      otherWorkspaceItems);
2916              filterCurrentAppWidgets(currentScreenId, appWidgets, currentAppWidgets,
2917                      otherAppWidgets);
2918              filterCurrentFolders(currentScreenId, itemsIdMap, folders, currentFolders,
2919                      otherFolders);
2920              sortWorkspaceItemsSpatially(currentWorkspaceItems);
2921              sortWorkspaceItemsSpatially(otherWorkspaceItems);
2922  
2923              // Tell the workspace that we&#x27;re about to start binding items
2924              r = new Runnable() {
2925                  public void run() {
2926                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2927                      if (callbacks != null) {
2928                          callbacks.startBinding();
2929                      }
2930                  }
2931              };
2932              runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2933  
2934              bindWorkspaceScreens(oldCallbacks, orderedScreenIds);
2935  
2936              // Load items on the current page
2937              bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
2938                      currentFolders, null);
2939              if (isLoadingSynchronously) {
2940                  r = new Runnable() {
2941                      public void run() {
2942                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2943                          if (callbacks != null &amp;&amp; currentScreen != PagedView.INVALID_RESTORE_PAGE) {
2944                              callbacks.onPageBoundSynchronously(currentScreen);
2945                          }
2946                      }
2947                  };
2948                  runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2949              }
2950  
2951              // Load all the remaining pages (if we are loading synchronously, we want to defer this
2952              // work until after the first render)
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2953 -            mDeferredBindRunnables.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2954 +            synchronized (mDeferredBindRunnables) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2955 +                mDeferredBindRunnables.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2956 +            }</span>
2957              bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
2958                      (isLoadingSynchronously ? mDeferredBindRunnables : null));
2959  
2960              // Tell the workspace that we&#x27;re done binding items
2961              r = new Runnable() {
2962                  public void run() {
2963                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2964                      if (callbacks != null) {
2965                          callbacks.finishBindingItems(isUpgradePath);
2966                      }
2967  
2968                      // If we&#x27;re profiling, ensure this is the last thing in the queue.
2969                      if (DEBUG_LOADERS) {
2970                          Log.d(TAG, &quot;bound workspace in &quot;
2971                              + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2972                      }
2973  
2974                      mIsLoadingAndBindingWorkspace = false;
2975                  }
2976              };
2977              if (isLoadingSynchronously) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2978 -                mDeferredBindRunnables.add(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2979 +                synchronized (mDeferredBindRunnables) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2980 +                    mDeferredBindRunnables.add(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2981 +                }</span>
2982              } else {
2983                  runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2984              }
2985          }
2986  
2987          private void loadAndBindAllApps() {
2988              if (DEBUG_LOADERS) {
2989                  Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
2990              }
2991              if (!mAllAppsLoaded) {
2992                  loadAllApps();
2993                  synchronized (LoaderTask.this) {
2994                      if (mStopped) {
2995                          return;
2996                      }
2997                      mAllAppsLoaded = true;
2998                  }
2999              } else {
3000                  onlyBindAllApps();
3001              }
3002          }
3003  
3004          private void onlyBindAllApps() {
3005              final Callbacks oldCallbacks = mCallbacks.get();
3006              if (oldCallbacks == null) {
3007                  // This launcher has exited and nobody bothered to tell us.  Just bail.
3008                  Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
3009                  return;
3010              }
3011  
3012              // shallow copy
3013              @SuppressWarnings(&quot;unchecked&quot;)
3014              final ArrayList&lt;AppInfo&gt; list
3015                      = (ArrayList&lt;AppInfo&gt;) mBgAllAppsList.data.clone();
3016              Runnable r = new Runnable() {
3017                  public void run() {
3018                      final long t = SystemClock.uptimeMillis();
3019                      final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
3020                      if (callbacks != null) {
3021                          callbacks.bindAllApplications(list);
3022                      }
3023                      if (DEBUG_LOADERS) {
3024                          Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
3025                                  + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
3026                      }
3027                  }
3028              };
3029              boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
3030              if (isRunningOnMainThread) {
3031                  r.run();
3032              } else {
3033                  mHandler.post(r);
3034              }
3035          }
3036  
3037          private void loadAllApps() {
3038              final long loadTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
3039  
3040              final Callbacks oldCallbacks = mCallbacks.get();
3041              if (oldCallbacks == null) {
3042                  // This launcher has exited and nobody bothered to tell us.  Just bail.
3043                  Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllApps)&quot;);
3044                  return;
3045              }
3046  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3047 -            final PackageManager packageManager = mContext.getPackageManager();</span>
3048              final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
3049              mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
3050  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3051 +            final List&lt;UserHandleCompat&gt; profiles = mUserManager.getUserProfiles();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3052 +</span>
3053              // Clear the list of apps
3054              mBgAllAppsList.clear();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3055 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3056 -            // Query for the set of apps</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3057 -            final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3058 -            List&lt;ResolveInfo&gt; apps = packageManager.queryIntentActivities(mainIntent, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3059 -            if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3060 -                Log.d(TAG, &quot;queryIntentActivities took &quot;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3061 -                        + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3062 -                Log.d(TAG, &quot;queryIntentActivities got &quot; + apps.size() + &quot; apps&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3063 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3064 -            // Fail if we don&#x27;t have any apps</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3065 -            if (apps == null || apps.isEmpty()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3066 -                return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3067 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3068 -            // Sort the applications by name</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3069 -            final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3070 -            Collections.sort(apps,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3071 -                    new LauncherModel.ShortcutNameComparator(packageManager, mLabelCache));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3072 -            if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3073 -                Log.d(TAG, &quot;sort took &quot;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3074 -                        + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3075 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3076 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3077 -            // Create the ApplicationInfos</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3078 -            for (int i = 0; i &lt; apps.size(); i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3079 -                ResolveInfo app = apps.get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3080 -                // This builds the icon bitmaps.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3081 -                mBgAllAppsList.add(new AppInfo(packageManager, app,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3082 -                        mIconCache, mLabelCache));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3083 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3084 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3085 +            for (UserHandleCompat user : profiles) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3086 +                // Query for the set of apps</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3087 +                final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3088 +                List&lt;LauncherActivityInfoCompat&gt; apps = mLauncherApps.getActivityList(null, user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3089 +                if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3090 +                    Log.d(TAG, &quot;getActivityList took &quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3091 +                            + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms for user &quot; + user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3092 +                    Log.d(TAG, &quot;getActivityList got &quot; + apps.size() + &quot; apps for user &quot; + user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3093 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3094 +                // Fail if we don&#x27;t have any apps</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3095 +                if (apps == null || apps.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3096 +                    return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3097 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3098 +                // Sort the applications by name</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3099 +                final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3100 +                Collections.sort(apps,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3101 +                        new LauncherModel.ShortcutNameComparator(mLabelCache));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3102 +                if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3103 +                    Log.d(TAG, &quot;sort took &quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3104 +                            + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3105 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3106 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3107 +                // Create the ApplicationInfos</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3108 +                for (int i = 0; i &lt; apps.size(); i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3109 +                    LauncherActivityInfoCompat app = apps.get(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3110 +                    // This builds the icon bitmaps.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3111 +                    mBgAllAppsList.add(new AppInfo(mContext, app, user, mIconCache, mLabelCache));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3112 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3113 +            }</span>
3114              // Huh? Shouldn&#x27;t this be inside the Runnable below?
3115              final ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added;
3116              mBgAllAppsList.added = new ArrayList&lt;AppInfo&gt;();
3117  
3118              // Post callback on main thread
3119              mHandler.post(new Runnable() {
3120                  public void run() {
3121                      final long bindTime = SystemClock.uptimeMillis();
3122                      final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
3123                      if (callbacks != null) {
3124                          callbacks.bindAllApplications(added);
3125                          if (DEBUG_LOADERS) {
3126                              Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
3127                                  + (SystemClock.uptimeMillis() - bindTime) + &quot;ms&quot;);
3128                          }
3129                      } else {
3130                          Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
3131                      }
3132                  }
3133              });
3134  
3135              if (DEBUG_LOADERS) {
3136                  Log.d(TAG, &quot;Icons processed in &quot;
3137                          + (SystemClock.uptimeMillis() - loadTime) + &quot;ms&quot;);
3138              }
3139          }
3140  
3141          public void dumpState() {
3142              synchronized (sBgLock) {
3143                  Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
3144                  Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
3145                  Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
3146                  Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
3147                  Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
3148              }
3149          }
3150      }
3151  
3152      void enqueuePackageUpdated(PackageUpdatedTask task) {
3153          sWorker.post(task);
3154      }
3155  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3156 +    private class AppsAvailabilityCheck extends BroadcastReceiver {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3157 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3158 +        @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3159 +        public void onReceive(Context context, Intent intent) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3160 +            synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3161 +                final LauncherAppsCompat launcherApps = LauncherAppsCompat</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3162 +                        .getInstance(mApp.getContext());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3163 +                ArrayList&lt;String&gt; packagesRemoved;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3164 +                for (Entry&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; entry : sPendingPackages.entrySet()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3165 +                    UserHandleCompat user = entry.getKey();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3166 +                    packagesRemoved = new ArrayList&lt;String&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3167 +                    for (String pkg : entry.getValue()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3168 +                        if (!launcherApps.isPackageEnabledForProfile(pkg, user)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3169 +                            Launcher.addDumpLog(TAG, &quot;Package not found: &quot; + pkg, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3170 +                            packagesRemoved.add(pkg);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3171 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3172 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3173 +                    if (!packagesRemoved.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3174 +                        enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_REMOVE,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3175 +                                packagesRemoved.toArray(new String[packagesRemoved.size()]), user));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3176 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3177 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3178 +                sPendingPackages.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3179 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3180 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3181 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3182 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3183 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3184 +     * Workaround to re-check unrestored items, in-case they were installed but the Package-ADD</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3185 +     * runnable was missed by the launcher.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3186 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3187 +    public void recheckRestoredItems(final Context context) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3188 +        Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3189 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3190 +            @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3191 +            public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3192 +                LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3193 +                HashSet&lt;String&gt; installedPackages = new HashSet&lt;String&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3194 +                UserHandleCompat user = UserHandleCompat.myUserHandle();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3195 +                synchronized(sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3196 +                    for (ItemInfo info : sBgItemsIdMap.values()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3197 +                        if (info instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3198 +                            ShortcutInfo si = (ShortcutInfo) info;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3199 +                            if (si.isPromise() &amp;&amp; si.getTargetComponent() != null</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3200 +                                    &amp;&amp; launcherApps.isPackageEnabledForProfile(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3201 +                                            si.getTargetComponent().getPackageName(), user)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3202 +                                installedPackages.add(si.getTargetComponent().getPackageName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3203 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3204 +                        } else if (info instanceof LauncherAppWidgetInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3205 +                            LauncherAppWidgetInfo widget = (LauncherAppWidgetInfo) info;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3206 +                            if (widget.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3207 +                                    &amp;&amp; launcherApps.isPackageEnabledForProfile(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3208 +                                            widget.providerName.getPackageName(), user)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3209 +                                installedPackages.add(widget.providerName.getPackageName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3210 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3211 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3212 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3213 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3214 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3215 +                if (!installedPackages.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3216 +                    final ArrayList&lt;AppInfo&gt; restoredApps = new ArrayList&lt;AppInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3217 +                    for (String pkg : installedPackages) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3218 +                        for (LauncherActivityInfoCompat info : launcherApps.getActivityList(pkg, user)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3219 +                            restoredApps.add(new AppInfo(context, info, user, mIconCache, null));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3220 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3221 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3222 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3223 +                    final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3224 +                    if (!restoredApps.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3225 +                        mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3226 +                            public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3227 +                                Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3228 +                                if (callbacks == cb &amp;&amp; cb != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3229 +                                    callbacks.bindAppsRestored(restoredApps);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3230 +                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3231 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3232 +                        });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3233 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3234 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3235 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3236 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3237 +        };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3238 +        sWorker.post(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3239 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3240 +</span>
3241      private class PackageUpdatedTask implements Runnable {
3242          int mOp;
3243          String[] mPackages;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3244 +        UserHandleCompat mUser;</span>
3245  
3246          public static final int OP_NONE = 0;
3247          public static final int OP_ADD = 1;
3248          public static final int OP_UPDATE = 2;
3249          public static final int OP_REMOVE = 3; // uninstlled
3250          public static final int OP_UNAVAILABLE = 4; // external media unmounted
3251  
3252  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3253 -        public PackageUpdatedTask(int op, String[] packages) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3254 +        public PackageUpdatedTask(int op, String[] packages, UserHandleCompat user) {</span>
3255              mOp = op;
3256              mPackages = packages;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3257 +            mUser = user;</span>
3258          }
3259  
3260          public void run() {
3261              final Context context = mApp.getContext();
3262  
3263              final String[] packages = mPackages;
3264              final int N = packages.length;
3265              switch (mOp) {
3266                  case OP_ADD:
3267                      for (int i=0; i&lt;N; i++) {
3268                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3269 -                        mBgAllAppsList.addPackage(context, packages[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3270 +                        mIconCache.remove(packages[i], mUser);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3271 +                        mBgAllAppsList.addPackage(context, packages[i], mUser);</span>
3272                      }
3273                      break;
3274                  case OP_UPDATE:
3275                      for (int i=0; i&lt;N; i++) {
3276                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3277 -                        mBgAllAppsList.updatePackage(context, packages[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3278 +                        mBgAllAppsList.updatePackage(context, packages[i], mUser);</span>
3279                          WidgetPreviewLoader.removePackageFromDb(
3280                                  mApp.getWidgetPreviewCacheDb(), packages[i]);
3281                      }
3282                      break;
3283                  case OP_REMOVE:
3284                  case OP_UNAVAILABLE:
3285                      for (int i=0; i&lt;N; i++) {
3286                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3287 -                        mBgAllAppsList.removePackage(packages[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3288 +                        mBgAllAppsList.removePackage(packages[i], mUser);</span>
3289                          WidgetPreviewLoader.removePackageFromDb(
3290                                  mApp.getWidgetPreviewCacheDb(), packages[i]);
3291                      }
3292                      break;
3293              }
3294  
3295              ArrayList&lt;AppInfo&gt; added = null;
3296              ArrayList&lt;AppInfo&gt; modified = null;
3297              final ArrayList&lt;AppInfo&gt; removedApps = new ArrayList&lt;AppInfo&gt;();
3298  
3299              if (mBgAllAppsList.added.size() &gt; 0) {
3300                  added = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.added);
3301                  mBgAllAppsList.added.clear();
3302              }
3303              if (mBgAllAppsList.modified.size() &gt; 0) {
3304                  modified = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.modified);
3305                  mBgAllAppsList.modified.clear();
3306              }
3307              if (mBgAllAppsList.removed.size() &gt; 0) {
3308                  removedApps.addAll(mBgAllAppsList.removed);
3309                  mBgAllAppsList.removed.clear();
3310              }
3311  
3312              final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
3313              if (callbacks == null) {
3314                  Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
3315                  return;
3316              }
3317  
3318              if (added != null) {
3319                  // Ensure that we add all the workspace applications to the db
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3320 -                Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3321 -                if (!LauncherAppState.isDisableAllApps()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3322 -                    addAndBindAddedApps(context, new ArrayList&lt;ItemInfo&gt;(), cb, added);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3323 +                if (LauncherAppState.isDisableAllApps()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3324 +                    final ArrayList&lt;ItemInfo&gt; addedInfos = new ArrayList&lt;ItemInfo&gt;(added);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3325 +                    addAndBindAddedWorkspaceApps(context, addedInfos);</span>
3326                  } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3327 -                    final ArrayList&lt;ItemInfo&gt; addedInfos = new ArrayList&lt;ItemInfo&gt;(added);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3328 -                    addAndBindAddedApps(context, addedInfos, cb, added);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3329 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3330 -            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3331 +                    addAppsToAllApps(context, added);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3332 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3333 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3334 +</span>
3335              if (modified != null) {
3336                  final ArrayList&lt;AppInfo&gt; modifiedFinal = modified;
3337  
3338                  // Update the launcher db to reflect the changes
3339                  for (AppInfo a : modifiedFinal) {
3340                      ArrayList&lt;ItemInfo&gt; infos =
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3341 -                            getItemInfoForComponentName(a.componentName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3342 +                            getItemInfoForComponentName(a.componentName, mUser);</span>
3343                      for (ItemInfo i : infos) {
3344                          if (isShortcutInfoUpdateable(i)) {
3345                              ShortcutInfo info = (ShortcutInfo) i;
3346                              info.title = a.title.toString();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3347 +                            info.contentDescription = a.contentDescription;</span>
3348                              updateItemInDatabase(context, info);
3349                          }
3350                      }
3351                  }
3352  
3353                  mHandler.post(new Runnable() {
3354                      public void run() {
3355                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3356                          if (callbacks == cb &amp;&amp; cb != null) {
3357                              callbacks.bindAppsUpdated(modifiedFinal);
3358                          }
3359                      }
3360                  });
3361              }
3362  
3363              final ArrayList&lt;String&gt; removedPackageNames =
3364                      new ArrayList&lt;String&gt;();
3365              if (mOp == OP_REMOVE) {
3366                  // Mark all packages in the broadcast to be removed
3367                  removedPackageNames.addAll(Arrays.asList(packages));
3368              } else if (mOp == OP_UPDATE) {
3369                  // Mark disabled packages in the broadcast to be removed
3370                  final PackageManager pm = context.getPackageManager();
3371                  for (int i=0; i&lt;N; i++) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3372 -                    if (isPackageDisabled(pm, packages[i])) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3373 +                    if (isPackageDisabled(context, packages[i], mUser)) {</span>
3374                          removedPackageNames.add(packages[i]);
3375                      }
3376                  }
3377              }
3378              // Remove all the components associated with this package
3379              for (String pn : removedPackageNames) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3380 -                ArrayList&lt;ItemInfo&gt; infos = getItemInfoForPackageName(pn);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3381 -                for (ItemInfo i : infos) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3382 -                    deleteItemFromDatabase(context, i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3383 -                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3384 +                deletePackageFromDatabase(context, pn, mUser);</span>
3385              }
3386              // Remove all the specific components
3387              for (AppInfo a : removedApps) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3388 -                ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3389 -                for (ItemInfo i : infos) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3390 -                    deleteItemFromDatabase(context, i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3391 -                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3392 +                ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName, mUser);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3393 +                deleteItemsFromDatabase(context, infos);</span>
3394              }
3395              if (!removedPackageNames.isEmpty() || !removedApps.isEmpty()) {
3396                  // Remove any queued items from the install queue
3397                  String spKey = LauncherAppState.getSharedPreferencesKey();
3398                  SharedPreferences sp =
3399                          context.getSharedPreferences(spKey, Context.MODE_PRIVATE);
3400                  InstallShortcutReceiver.removeFromInstallQueue(sp, removedPackageNames);
3401                  // Call the components-removed callback
3402                  mHandler.post(new Runnable() {
3403                      public void run() {
3404                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3405                          if (callbacks == cb &amp;&amp; cb != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3406 -                            callbacks.bindComponentsRemoved(removedPackageNames, removedApps);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3407 +                            callbacks.bindComponentsRemoved(removedPackageNames, removedApps, mUser);</span>
3408                          }
3409                      }
3410                  });
3411              }
3412  
3413              final ArrayList&lt;Object&gt; widgetsAndShortcuts =
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3414 -                getSortedWidgetsAndShortcuts(context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3415 +                    getSortedWidgetsAndShortcuts(context);</span>
3416              mHandler.post(new Runnable() {
3417                  @Override
3418                  public void run() {
3419                      Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3420                      if (callbacks == cb &amp;&amp; cb != null) {
3421                          callbacks.bindPackagesUpdated(widgetsAndShortcuts);
3422                      }
3423                  }
3424              });
3425  
3426              // Write all the logs to disk
3427              mHandler.post(new Runnable() {
3428                  public void run() {
3429                      Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3430                      if (callbacks == cb &amp;&amp; cb != null) {
3431                          callbacks.dumpLogsToLocalData();
3432                      }
3433                  }
3434              });
3435          }
3436      }
3437  
3438      // Returns a list of ResolveInfos/AppWindowInfos in sorted order
3439      public static ArrayList&lt;Object&gt; getSortedWidgetsAndShortcuts(Context context) {
3440          PackageManager packageManager = context.getPackageManager();
3441          final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3442 -        widgetsAndShortcuts.addAll(AppWidgetManager.getInstance(context).getInstalledProviders());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3443 +        widgetsAndShortcuts.addAll(AppWidgetManagerCompat.getInstance(context).getAllProviders());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3444 +</span>
3445          Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
3446          widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3447 -        Collections.sort(widgetsAndShortcuts,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3448 -            new LauncherModel.WidgetAndShortcutNameComparator(packageManager));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3449 +        Collections.sort(widgetsAndShortcuts, new WidgetAndShortcutNameComparator(context));</span>
3450          return widgetsAndShortcuts;
3451      }
3452  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3453 -    private static boolean isPackageDisabled(PackageManager pm, String packageName) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3454 -        try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3455 -            PackageInfo pi = pm.getPackageInfo(packageName, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3456 -            return !pi.applicationInfo.enabled;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3457 -        } catch (NameNotFoundException e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3458 -            // Fall through</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3459 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3460 -        return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3461 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3462 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3463 -    public static boolean isValidPackageComponent(PackageManager pm, ComponentName cn) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3464 +    private static boolean isPackageDisabled(Context context, String packageName,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3465 +            UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3466 +        final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3467 +        return !launcherApps.isPackageEnabledForProfile(packageName, user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3468 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3469 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3470 +    public static boolean isValidPackageActivity(Context context, ComponentName cn,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3471 +            UserHandleCompat user) {</span>
3472          if (cn == null) {
3473              return false;
3474          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3475 -        if (isPackageDisabled(pm, cn.getPackageName())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3476 +        final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3477 +        if (!launcherApps.isPackageEnabledForProfile(cn.getPackageName(), user)) {</span>
3478              return false;
3479          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3480 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3481 -        try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3482 -            // Check the activity</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3483 -            PackageInfo pi = pm.getPackageInfo(cn.getPackageName(), 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3484 -            return (pm.getActivityInfo(cn, 0) != null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3485 -        } catch (NameNotFoundException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3486 +        return launcherApps.isActivityEnabledForProfile(cn, user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3487 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3488 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3489 +    public static boolean isValidPackage(Context context, String packageName,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3490 +            UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3491 +        if (packageName == null) {</span>
3492              return false;
3493          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3494 +        final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3495 +        return launcherApps.isPackageEnabledForProfile(packageName, user);</span>
3496      }
3497  
3498      /**
3499       * Make an ShortcutInfo object for a restored application or shortcut item that points
3500       * to a package that is not yet installed on the system.
3501       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3502 -    public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3503 +    public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex, Intent intent,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3504 +            int promiseType) {</span>
3505          final ShortcutInfo info = new ShortcutInfo();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3506 -        info.usingFallbackIcon = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3507 -        info.setIcon(getFallbackIcon());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3508 -        if (cursor != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3509 -            info.title =  cursor.getString(titleIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3510 +        info.user = UserHandleCompat.myUserHandle();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3511 +        mIconCache.getTitleAndIcon(info, intent, info.user, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3512 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3513 +        if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_ICON) != 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3514 +            String title = (cursor != null) ? cursor.getString(titleIndex) : null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3515 +            if (!TextUtils.isEmpty(title)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3516 +                info.title = title;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3517 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3518 +            info.status = ShortcutInfo.FLAG_RESTORED_ICON;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3519 +        } else if  ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3520 +            if (TextUtils.isEmpty(info.title)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3521 +                info.title = (cursor != null) ? cursor.getString(titleIndex) : &quot;&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3522 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3523 +            info.status = ShortcutInfo.FLAG_AUTOINTALL_ICON;</span>
3524          } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3525 -            info.title = &quot;&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3526 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3527 +            throw new InvalidParameterException(&quot;Invalid restoreType &quot; + promiseType);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3528 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3529 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3530 +        info.contentDescription = mUserManager.getBadgedLabelForUser(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3531 +                info.title.toString(), info.user);</span>
3532          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3533 +        info.promisedIntent = intent;</span>
3534          return info;
3535      }
3536  
3537      /**
3538       * Make an Intent object for a restored application or shortcut item that points
3539       * to the market page for the item.
3540       */
3541      private Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {
3542          ComponentName componentName = intent.getComponent();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3543 -        Intent marketIntent = new Intent(Intent.ACTION_VIEW);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3544 -        Uri marketUri = new Uri.Builder()</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3545 +        return getMarketIntent(componentName.getPackageName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3546 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3547 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3548 +    static Intent getMarketIntent(String packageName) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3549 +        return new Intent(Intent.ACTION_VIEW)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3550 +            .setData(new Uri.Builder()</span>
3551                  .scheme(&quot;market&quot;)
3552                  .authority(&quot;details&quot;)
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3553 -                .appendQueryParameter(&quot;id&quot;, componentName.getPackageName())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3554 -                .build();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3555 -        Log.d(TAG, &quot;manufactured intent uri: &quot; + marketUri.toString());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3556 -        marketIntent.setData(marketUri);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3557 -        return marketIntent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3558 +                .appendQueryParameter(&quot;id&quot;, packageName)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3559 +                .build());</span>
3560      }
3561  
3562      /**
3563       * This is called from the code that adds shortcuts from the intent receiver.  This
3564       * doesn&#x27;t have a Cursor, but
3565       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3566 -    public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3567 -        return getShortcutInfo(manager, intent, context, null, -1, -1, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3568 +    public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3569 +            UserHandleCompat user, Context context) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3570 +        return getShortcutInfo(manager, intent, user, context, null, -1, -1, null, false);</span>
3571      }
3572  
3573      /**
3574       * Make an ShortcutInfo object for a shortcut that is an application.
3575       *
3576       * If c is not null, then it will be used to fill in missing data like the title and icon.
3577       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3578 -    public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3579 -            Cursor c, int iconIndex, int titleIndex, HashMap&lt;Object, CharSequence&gt; labelCache) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3580 +    public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3581 +            UserHandleCompat user, Context context, Cursor c, int iconIndex, int titleIndex,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3582 +            HashMap&lt;Object, CharSequence&gt; labelCache, boolean allowMissingTarget) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3583 +        if (user == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3584 +            Log.d(TAG, &quot;Null user found in getShortcutInfo&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3585 +            return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3586 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3587 +</span>
3588          ComponentName componentName = intent.getComponent();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3589 +        if (componentName == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3590 +            Log.d(TAG, &quot;Missing component found in getShortcutInfo: &quot; + componentName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3591 +            return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3592 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3593 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3594 +        Intent newIntent = new Intent(intent.getAction(), null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3595 +        newIntent.addCategory(Intent.CATEGORY_LAUNCHER);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3596 +        newIntent.setComponent(componentName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3597 +        LauncherActivityInfoCompat lai = mLauncherApps.resolveActivity(newIntent, user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3598 +        if ((lai == null) &amp;&amp; !allowMissingTarget) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3599 +            Log.d(TAG, &quot;Missing activity found in getShortcutInfo: &quot; + componentName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3600 +            return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3601 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3602 +</span>
3603          final ShortcutInfo info = new ShortcutInfo();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3604 -        if (componentName != null &amp;&amp; !isValidPackageComponent(manager, componentName)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3605 -            Log.d(TAG, &quot;Invalid package found in getShortcutInfo: &quot; + componentName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3606 -            return null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3607 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3608 -            try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3609 -                PackageInfo pi = manager.getPackageInfo(componentName.getPackageName(), 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3610 -                info.initFlagsAndFirstInstallTime(pi);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3611 -            } catch (NameNotFoundException e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3612 -                Log.d(TAG, &quot;getPackInfo failed for package &quot; +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3613 -                        componentName.getPackageName());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3614 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3615 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3616 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3617 -        // TODO: See if the PackageManager knows about this case.  If it doesn&#x27;t</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3618 -        // then return null &amp; delete this.</span>
3619  
3620          // the resource -- This may implicitly give us back the fallback icon,
3621          // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
3622          // to avoid saving lots of copies of that in the database, and most apps
3623          // have icons anyway.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3624 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3625 -        // Attempt to use queryIntentActivities to get the ResolveInfo (with IntentFilter info) and</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3626 -        // if that fails, or is ambiguious, fallback to the standard way of getting the resolve info</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3627 -        // via resolveActivity().</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3628 -        Bitmap icon = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3629 -        ResolveInfo resolveInfo = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3630 -        ComponentName oldComponent = intent.getComponent();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3631 -        Intent newIntent = new Intent(intent.getAction(), null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3632 -        newIntent.addCategory(Intent.CATEGORY_LAUNCHER);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3633 -        newIntent.setPackage(oldComponent.getPackageName());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3634 -        List&lt;ResolveInfo&gt; infos = manager.queryIntentActivities(newIntent, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3635 -        for (ResolveInfo i : infos) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3636 -            ComponentName cn = new ComponentName(i.activityInfo.packageName,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3637 -                    i.activityInfo.name);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3638 -            if (cn.equals(oldComponent)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3639 -                resolveInfo = i;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3640 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3641 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3642 -        if (resolveInfo == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3643 -            resolveInfo = manager.resolveActivity(intent, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3644 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3645 -        if (resolveInfo != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3646 -            icon = mIconCache.getIcon(componentName, resolveInfo, labelCache);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3647 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3648 +        Bitmap icon = mIconCache.getIcon(componentName, lai, labelCache);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3649 +</span>
3650          // the db
3651          if (icon == null) {
3652              if (c != null) {
3653                  icon = getIconFromCursor(c, iconIndex, context);
3654              }
3655          }
3656          // the fallback icon
3657          if (icon == null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3658 -            icon = getFallbackIcon();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3659 +            icon = mIconCache.getDefaultIcon(user);</span>
3660              info.usingFallbackIcon = true;
3661          }
3662          info.setIcon(icon);
3663  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3664 +        // From the cache.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3665 +        if (labelCache != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3666 +            info.title = labelCache.get(componentName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3667 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3668 +</span>
3669          // from the resource
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3670 -        if (resolveInfo != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3671 -            ComponentName key = LauncherModel.getComponentNameFromResolveInfo(resolveInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3672 -            if (labelCache != null &amp;&amp; labelCache.containsKey(key)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3673 -                info.title = labelCache.get(key);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3674 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3675 -                info.title = resolveInfo.activityInfo.loadLabel(manager);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3676 -                if (labelCache != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3677 -                    labelCache.put(key, info.title);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3678 -                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3679 +        if (info.title == null &amp;&amp; lai != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3680 +            info.title = lai.getLabel();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3681 +            if (labelCache != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3682 +                labelCache.put(componentName, info.title);</span>
3683              }
3684          }
3685          // from the db
3686          if (info.title == null) {
3687              if (c != null) {
3688                  info.title =  c.getString(titleIndex);
3689              }
3690          }
3691          // fall back to the class name of the activity
3692          if (info.title == null) {
3693              info.title = componentName.getClassName();
3694          }
3695          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3696 +        info.user = user;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3697 +        info.contentDescription = mUserManager.getBadgedLabelForUser(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3698 +                info.title.toString(), info.user);</span>
3699          return info;
3700      }
3701  
3702      static ArrayList&lt;ItemInfo&gt; filterItemInfos(Collection&lt;ItemInfo&gt; infos,
3703              ItemInfoFilter f) {
3704          HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();
3705          for (ItemInfo i : infos) {
3706              if (i instanceof ShortcutInfo) {
3707                  ShortcutInfo info = (ShortcutInfo) i;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3708 -                ComponentName cn = info.intent.getComponent();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3709 +                ComponentName cn = info.getTargetComponent();</span>
3710                  if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3711                      filtered.add(info);
3712                  }
3713              } else if (i instanceof FolderInfo) {
3714                  FolderInfo info = (FolderInfo) i;
3715                  for (ShortcutInfo s : info.contents) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3716 -                    ComponentName cn = s.intent.getComponent();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3717 +                    ComponentName cn = s.getTargetComponent();</span>
3718                      if (cn != null &amp;&amp; f.filterItem(info, s, cn)) {
3719                          filtered.add(s);
3720                      }
3721                  }
3722              } else if (i instanceof LauncherAppWidgetInfo) {
3723                  LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) i;
3724                  ComponentName cn = info.providerName;
3725                  if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3726                      filtered.add(info);
3727                  }
3728              }
3729          }
3730          return new ArrayList&lt;ItemInfo&gt;(filtered);
3731      }
3732  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3733 -    private ArrayList&lt;ItemInfo&gt; getItemInfoForPackageName(final String pn) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3734 +    private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3735 +            final UserHandleCompat user) {</span>
3736          ItemInfoFilter filter  = new ItemInfoFilter() {
3737              @Override
3738              public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3739 -                return cn.getPackageName().equals(pn);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3740 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3741 -        };</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3742 -        return filterItemInfos(sBgItemsIdMap.values(), filter);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3743 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3744 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3745 -    private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3746 -        ItemInfoFilter filter  = new ItemInfoFilter() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3747 -            @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3748 -            public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3749 -                return cn.equals(cname);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3750 +                if (info.user == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3751 +                    return cn.equals(cname);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3752 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3753 +                    return cn.equals(cname) &amp;&amp; info.user.equals(user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3754 +                }</span>
3755              }
3756          };
3757          return filterItemInfos(sBgItemsIdMap.values(), filter);
3758      }
3759  
3760      public static boolean isShortcutInfoUpdateable(ItemInfo i) {
3761          if (i instanceof ShortcutInfo) {
3762              ShortcutInfo info = (ShortcutInfo) i;
3763              // We need to check for ACTION_MAIN otherwise getComponent() might
3764              // return null for some shortcuts (for instance, for shortcuts to
3765              // web pages.)
3766              Intent intent = info.intent;
3767              ComponentName name = intent.getComponent();
3768              if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION &amp;&amp;
3769                      Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3770                  return true;
3771              }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3772 +            // placeholder shortcuts get special treatment, let them through too.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3773 +            if (info.isPromise()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3774 +                return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3775 +            }</span>
3776          }
3777          return false;
3778      }
3779  
3780      /**
3781       * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
3782       */
3783      private ShortcutInfo getShortcutInfo(Cursor c, Context context,
3784              int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
3785              int titleIndex) {
3786  
3787          Bitmap icon = null;
3788          final ShortcutInfo info = new ShortcutInfo();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3789 +        // Non-app shortcuts are only supported for current user.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3790 +        info.user = UserHandleCompat.myUserHandle();</span>
3791          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3792  
3793          // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
3794  
3795          info.title = c.getString(titleIndex);
3796  
3797          int iconType = c.getInt(iconTypeIndex);
3798          switch (iconType) {
3799          case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
3800              String packageName = c.getString(iconPackageIndex);
3801              String resourceName = c.getString(iconResourceIndex);
3802              PackageManager packageManager = context.getPackageManager();
3803              info.customIcon = false;
3804              // the resource
3805              try {
3806                  Resources resources = packageManager.getResourcesForApplication(packageName);
3807                  if (resources != null) {
3808                      final int id = resources.getIdentifier(resourceName, null, null);
3809                      icon = Utilities.createIconBitmap(
3810                              mIconCache.getFullResIcon(resources, id), context);
3811                  }
3812              } catch (Exception e) {
3813                  // drop this.  we have other places to look for icons
3814              }
3815              // the db
3816              if (icon == null) {
3817                  icon = getIconFromCursor(c, iconIndex, context);
3818              }
3819              // the fallback icon
3820              if (icon == null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3821 -                icon = getFallbackIcon();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3822 +                icon = mIconCache.getDefaultIcon(info.user);</span>
3823                  info.usingFallbackIcon = true;
3824              }
3825              break;
3826          case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
3827              icon = getIconFromCursor(c, iconIndex, context);
3828              if (icon == null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3829 -                icon = getFallbackIcon();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3830 +                icon = mIconCache.getDefaultIcon(info.user);</span>
3831                  info.customIcon = false;
3832                  info.usingFallbackIcon = true;
3833              } else {
3834                  info.customIcon = true;
3835              }
3836              break;
3837          default:
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3838 -            icon = getFallbackIcon();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3839 +            icon = mIconCache.getDefaultIcon(info.user);</span>
3840              info.usingFallbackIcon = true;
3841              info.customIcon = false;
3842              break;
3843          }
3844          info.setIcon(icon);
3845          return info;
3846      }
3847  
3848      Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
3849          @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
3850          final boolean debug = false;
3851          if (debug) {
3852              Log.d(TAG, &quot;getIconFromCursor app=&quot;
3853                      + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
3854          }
3855          byte[] data = c.getBlob(iconIndex);
3856          try {
3857              return Utilities.createIconBitmap(
3858                      BitmapFactory.decodeByteArray(data, 0, data.length), context);
3859          } catch (Exception e) {
3860              return null;
3861          }
3862      }
3863  
3864      ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
3865              int cellX, int cellY, boolean notify) {
3866          final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
3867          if (info == null) {
3868              return null;
3869          }
3870          addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
3871  
3872          return info;
3873      }
3874  
3875      /**
3876       * Attempts to find an AppWidgetProviderInfo that matches the given component.
3877       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3878 -    AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3879 +    static AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,</span>
3880              ComponentName component) {
3881          List&lt;AppWidgetProviderInfo&gt; widgets =
3882              AppWidgetManager.getInstance(context).getInstalledProviders();
3883          for (AppWidgetProviderInfo info : widgets) {
3884              if (info.provider.equals(component)) {
3885                  return info;
3886              }
3887          }
3888          return null;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3889 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3890 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3891 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3892 -     * Returns a list of all the widgets that can handle configuration with a particular mimeType.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3893 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3894 -    List&lt;WidgetMimeTypeHandlerData&gt; resolveWidgetsForMimeType(Context context, String mimeType) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3895 -        final PackageManager packageManager = context.getPackageManager();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3896 -        final List&lt;WidgetMimeTypeHandlerData&gt; supportedConfigurationActivities =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3897 -            new ArrayList&lt;WidgetMimeTypeHandlerData&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3898 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3899 -        final Intent supportsIntent =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3900 -            new Intent(InstallWidgetReceiver.ACTION_SUPPORTS_CLIPDATA_MIMETYPE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3901 -        supportsIntent.setType(mimeType);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3902 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3903 -        // Create a set of widget configuration components that we can test against</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3904 -        final List&lt;AppWidgetProviderInfo&gt; widgets =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3905 -            AppWidgetManager.getInstance(context).getInstalledProviders();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3906 -        final HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; configurationComponentToWidget =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3907 -            new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3908 -        for (AppWidgetProviderInfo info : widgets) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3909 -            configurationComponentToWidget.put(info.configure, info);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3910 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3911 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3912 -        // Run through each of the intents that can handle this type of clip data, and cross</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3913 -        // reference them with the components that are actual configuration components</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3914 -        final List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(supportsIntent,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3915 -                PackageManager.MATCH_DEFAULT_ONLY);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3916 -        for (ResolveInfo info : activities) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3917 -            final ActivityInfo activityInfo = info.activityInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3918 -            final ComponentName infoComponent = new ComponentName(activityInfo.packageName,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3919 -                    activityInfo.name);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3920 -            if (configurationComponentToWidget.containsKey(infoComponent)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3921 -                supportedConfigurationActivities.add(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3922 -                        new InstallWidgetReceiver.WidgetMimeTypeHandlerData(info,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3923 -                                configurationComponentToWidget.get(infoComponent)));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3924 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3925 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3926 -        return supportedConfigurationActivities;</span>
3927      }
3928  
3929      ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
3930          Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
3931          String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
3932          Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
3933  
3934          if (intent == null) {
3935              // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
3936              Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
3937              return null;
3938          }
3939  
3940          Bitmap icon = null;
3941          boolean customIcon = false;
3942          ShortcutIconResource iconResource = null;
3943  
3944          if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {
3945              icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);
3946              customIcon = true;
3947          } else {
3948              Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
3949              if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {
3950                  try {
3951                      iconResource = (ShortcutIconResource) extra;
3952                      final PackageManager packageManager = context.getPackageManager();
3953                      Resources resources = packageManager.getResourcesForApplication(
3954                              iconResource.packageName);
3955                      final int id = resources.getIdentifier(iconResource.resourceName, null, null);
3956                      icon = Utilities.createIconBitmap(
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3957 -                            mIconCache.getFullResIcon(resources, id), context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3958 +                            mIconCache.getFullResIcon(resources, id),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3959 +                            context);</span>
3960                  } catch (Exception e) {
3961                      Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);
3962                  }
3963              }
3964          }
3965  
3966          final ShortcutInfo info = new ShortcutInfo();
3967  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3968 +        // Only support intents for current user for now. Intents sent from other</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3969 +        // users wouldn&#x27;t get here without intent forwarding anyway.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3970 +        info.user = UserHandleCompat.myUserHandle();</span>
3971          if (icon == null) {
3972              if (fallbackIcon != null) {
3973                  icon = fallbackIcon;
3974              } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3975 -                icon = getFallbackIcon();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3976 +                icon = mIconCache.getDefaultIcon(info.user);</span>
3977                  info.usingFallbackIcon = true;
3978              }
3979          }
3980          info.setIcon(icon);
3981  
3982          info.title = name;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3983 +        info.contentDescription = mUserManager.getBadgedLabelForUser(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3984 +                info.title.toString(), info.user);</span>
3985          info.intent = intent;
3986          info.customIcon = customIcon;
3987          info.iconResource = iconResource;
3988  
3989          return info;
3990      }
3991  
3992      boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
3993              int iconIndex) {
3994          // If apps can&#x27;t be on SD, don&#x27;t even bother.
3995          if (!mAppsCanBeOnRemoveableStorage) {
3996              return false;
3997          }
3998          // If this icon doesn&#x27;t have a custom icon, check to see
3999          // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
4000          // we&#x27;re going to show, store what we are going to show back
4001          // into the DB.  We do this so when we&#x27;re loading, if the
4002          // package manager can&#x27;t find an icon (for example because
4003          // the app is on SD) then we can use that instead.
4004          if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
4005              cache.put(info, c.getBlob(iconIndex));
4006              return true;
4007          }
4008          return false;
4009      }
4010      void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
4011          boolean needSave = false;
4012          try {
4013              if (data != null) {
4014                  Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
4015                  Bitmap loaded = info.getIcon(mIconCache);
4016                  needSave = !saved.sameAs(loaded);
4017              } else {
4018                  needSave = true;
4019              }
4020          } catch (Exception e) {
4021              needSave = true;
4022          }
4023          if (needSave) {
4024              Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
4025              // This is slower than is ideal, but this only happens once
4026              // or when the app is updated with a new icon.
4027              updateItemInDatabase(context, info);
4028          }
4029      }
4030  
4031      /**
4032       * Return an existing FolderInfo object if we have encountered this ID previously,
4033       * or make a new one.
4034       */
4035      private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
4036          // See if a placeholder was created for us already
4037          FolderInfo folderInfo = folders.get(id);
4038          if (folderInfo == null) {
4039              // No placeholder -- create a new instance
4040              folderInfo = new FolderInfo();
4041              folders.put(id, folderInfo);
4042          }
4043          return folderInfo;
4044      }
4045  
4046      public static final Comparator&lt;AppInfo&gt; getAppNameComparator() {
4047          final Collator collator = Collator.getInstance();
4048          return new Comparator&lt;AppInfo&gt;() {
4049              public final int compare(AppInfo a, AppInfo b) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4050 -                int result = collator.compare(a.title.toString().trim(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4051 -                        b.title.toString().trim());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4052 -                if (result == 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4053 -                    result = a.componentName.compareTo(b.componentName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4054 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4055 -                return result;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4056 +                if (a.user.equals(b.user)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4057 +                    int result = collator.compare(a.title.toString().trim(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4058 +                            b.title.toString().trim());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4059 +                    if (result == 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4060 +                        result = a.componentName.compareTo(b.componentName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4061 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4062 +                    return result;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4063 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4064 +                    // TODO Need to figure out rules for sorting</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4065 +                    // profiles, this puts work second.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4066 +                    return a.user.toString().compareTo(b.user.toString());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4067 +                }</span>
4068              }
4069          };
4070      }
4071      public static final Comparator&lt;AppInfo&gt; APP_INSTALL_TIME_COMPARATOR
4072              = new Comparator&lt;AppInfo&gt;() {
4073          public final int compare(AppInfo a, AppInfo b) {
4074              if (a.firstInstallTime &lt; b.firstInstallTime) return 1;
4075              if (a.firstInstallTime &gt; b.firstInstallTime) return -1;
4076              return 0;
4077          }
4078      };
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4079 -    public static final Comparator&lt;AppWidgetProviderInfo&gt; getWidgetNameComparator() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4080 -        final Collator collator = Collator.getInstance();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4081 -        return new Comparator&lt;AppWidgetProviderInfo&gt;() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4082 -            public final int compare(AppWidgetProviderInfo a, AppWidgetProviderInfo b) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4083 -                return collator.compare(a.label.toString().trim(), b.label.toString().trim());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4084 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4085 -        };</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4086 -    }</span>
4087      static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
4088          if (info.activityInfo != null) {
4089              return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
4090          } else {
4091              return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
4092          }
4093      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4094 -    public static class ShortcutNameComparator implements Comparator&lt;ResolveInfo&gt; {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4095 +    public static class ShortcutNameComparator implements Comparator&lt;LauncherActivityInfoCompat&gt; {</span>
4096          private Collator mCollator;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4097 -        private PackageManager mPackageManager;</span>
4098          private HashMap&lt;Object, CharSequence&gt; mLabelCache;
4099          ShortcutNameComparator(PackageManager pm) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4100 -            mPackageManager = pm;</span>
4101              mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
4102              mCollator = Collator.getInstance();
4103          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4104 -        ShortcutNameComparator(PackageManager pm, HashMap&lt;Object, CharSequence&gt; labelCache) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4105 -            mPackageManager = pm;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4106 +        ShortcutNameComparator(HashMap&lt;Object, CharSequence&gt; labelCache) {</span>
4107              mLabelCache = labelCache;
4108              mCollator = Collator.getInstance();
4109          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4110 -        public final int compare(ResolveInfo a, ResolveInfo b) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4111 -            CharSequence labelA, labelB;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4112 -            ComponentName keyA = LauncherModel.getComponentNameFromResolveInfo(a);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4113 -            ComponentName keyB = LauncherModel.getComponentNameFromResolveInfo(b);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4114 +        public final int compare(LauncherActivityInfoCompat a, LauncherActivityInfoCompat b) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4115 +            String labelA, labelB;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4116 +            ComponentName keyA = a.getComponentName();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4117 +            ComponentName keyB = b.getComponentName();</span>
4118              if (mLabelCache.containsKey(keyA)) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4119 -                labelA = mLabelCache.get(keyA);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4120 +                labelA = mLabelCache.get(keyA).toString();</span>
4121              } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4122 -                labelA = a.loadLabel(mPackageManager).toString().trim();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4123 +                labelA = a.getLabel().toString().trim();</span>
4124  
4125                  mLabelCache.put(keyA, labelA);
4126              }
4127              if (mLabelCache.containsKey(keyB)) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4128 -                labelB = mLabelCache.get(keyB);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4129 +                labelB = mLabelCache.get(keyB).toString();</span>
4130              } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4131 -                labelB = b.loadLabel(mPackageManager).toString().trim();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4132 +                labelB = b.getLabel().toString().trim();</span>
4133  
4134                  mLabelCache.put(keyB, labelB);
4135              }
4136              return mCollator.compare(labelA, labelB);
4137          }
4138      };
4139      public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4140 -        private Collator mCollator;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4141 -        private PackageManager mPackageManager;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4142 -        private HashMap&lt;Object, String&gt; mLabelCache;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4143 -        WidgetAndShortcutNameComparator(PackageManager pm) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4144 -            mPackageManager = pm;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4145 +        private final AppWidgetManagerCompat mManager;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4146 +        private final PackageManager mPackageManager;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4147 +        private final HashMap&lt;Object, String&gt; mLabelCache;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4148 +        private final Collator mCollator;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4149 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4150 +        WidgetAndShortcutNameComparator(Context context) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4151 +            mManager = AppWidgetManagerCompat.getInstance(context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4152 +            mPackageManager = context.getPackageManager();</span>
4153              mLabelCache = new HashMap&lt;Object, String&gt;();
4154              mCollator = Collator.getInstance();
4155          }
4156          public final int compare(Object a, Object b) {
4157              String labelA, labelB;
4158              if (mLabelCache.containsKey(a)) {
4159                  labelA = mLabelCache.get(a);
4160              } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4161 -                labelA = (a instanceof AppWidgetProviderInfo) ?</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4162 -                    ((AppWidgetProviderInfo) a).label :</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4163 -                    ((ResolveInfo) a).loadLabel(mPackageManager).toString().trim();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4164 +                labelA = (a instanceof AppWidgetProviderInfo)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4165 +                        ? mManager.loadLabel((AppWidgetProviderInfo) a)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4166 +                        : ((ResolveInfo) a).loadLabel(mPackageManager).toString().trim();</span>
4167                  mLabelCache.put(a, labelA);
4168              }
4169              if (mLabelCache.containsKey(b)) {
4170                  labelB = mLabelCache.get(b);
4171              } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4172 -                labelB = (b instanceof AppWidgetProviderInfo) ?</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4173 -                    ((AppWidgetProviderInfo) b).label :</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4174 -                    ((ResolveInfo) b).loadLabel(mPackageManager).toString().trim();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4175 +                labelB = (b instanceof AppWidgetProviderInfo)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4176 +                        ? mManager.loadLabel((AppWidgetProviderInfo) b)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4177 +                        : ((ResolveInfo) b).loadLabel(mPackageManager).toString().trim();</span>
4178                  mLabelCache.put(b, labelB);
4179              }
4180              return mCollator.compare(labelA, labelB);
4181          }
4182      };
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4183 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4184 +    static boolean isValidProvider(AppWidgetProviderInfo provider) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4185 +        return (provider != null) &amp;&amp; (provider.provider != null)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4186 +                &amp;&amp; (provider.provider.getPackageName() != null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4187 +    }</span>
4188  
4189      public void dumpState() {
4190          Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
4191          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
4192          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
4193          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
4194          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
4195          if (mLoaderTask != null) {
4196              mLoaderTask.dumpState();
4197          } else {
4198              Log.d(TAG, &quot;mLoaderTask=null&quot;);
4199          }
4200      }
4201  }</pre></td>
                            <td><pre></pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            