<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>525</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    525
                    <a href="524.html">prev</a>
                    <a href="526.html">next</a>
                    <a href="525_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_8165f0dd202a2c0fbf0816f7613d66938955dc76_src/com/android/launcher2/AppsCustomizePagedView.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;8165f0dd202a2c0fbf0816f7613d66938955dc76:src/com/android/launcher2/AppsCustomizePagedView.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;8165f0dd202a2c0fbf0816f7613d66938955dc76^1:src/com/android/launcher2/AppsCustomizePagedView.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;8165f0dd202a2c0fbf0816f7613d66938955dc76^2:src/com/android/launcher2/AppsCustomizePagedView.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;0ede734d0780a968c9c345f99a18f9f8b9fc02cd:src/com/android/launcher2/AppsCustomizePagedView.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [s], [s]], subset: [[b], [s], [s]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2011 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher2;
  18 
  19 import android.animation.AnimatorSet;
  20 import android.animation.ValueAnimator;
  21 import android.appwidget.AppWidgetHostView;
  22 import android.appwidget.AppWidgetManager;
  23 import android.appwidget.AppWidgetProviderInfo;
  24 import android.content.ComponentName;
  25 import android.content.Context;
  26 import android.content.Intent;
  27 import android.content.pm.PackageManager;
  28 import android.content.pm.ResolveInfo;
  29 import android.content.res.Configuration;
  30 import android.content.res.Resources;
  31 import android.content.res.TypedArray;
  32 import android.graphics.Bitmap;
  33 import android.graphics.Bitmap.Config;
  34 import android.graphics.Canvas;
  35 import android.graphics.ColorMatrix;
  36 import android.graphics.ColorMatrixColorFilter;
  37 import android.graphics.Matrix;
  38 import android.graphics.Paint;
  39 import android.graphics.PorterDuff;
  40 import android.graphics.Rect;
  41 import android.graphics.RectF;
  42 import android.graphics.Shader;
  43 import android.graphics.drawable.BitmapDrawable;
  44 import android.graphics.drawable.Drawable;
  45 import android.os.AsyncTask;
  46 import android.os.Process;
  47 import android.util.AttributeSet;
  48 import android.util.Log;
  49 import android.view.Gravity;
  50 import android.view.KeyEvent;
  51 import android.view.LayoutInflater;
  52 import android.view.MotionEvent;
  53 import android.view.View;
  54 import android.view.ViewGroup;
  55 import android.view.animation.AccelerateInterpolator;
  56 import android.view.animation.DecelerateInterpolator;
  57 import android.widget.GridLayout;
  58 import android.widget.ImageView;
  59 import android.widget.Toast;
  60 
  61 import com.android.launcher.R;
  62 import com.android.launcher2.DropTarget.DragObject;
  63 
  64 import java.lang.ref.WeakReference;
  65 import java.util.ArrayList;
  66 import java.util.Collections;
  67 import java.util.Iterator;
  68 import java.util.List;
  69 
  70 /**
  71  * A simple callback interface which also provides the results of the task.
  72  */
  73 interface AsyncTaskCallback {
  74     void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data);
  75 }
  76 
  77 /**
  78  * The data needed to perform either of the custom AsyncTasks.
  79  */
  80 class AsyncTaskPageData {
  81     enum Type {
  82         LoadWidgetPreviewData
  83     }
  84 
  85     AsyncTaskPageData(int p, ArrayList&lt;Object&gt; l, ArrayList&lt;Bitmap&gt; si, AsyncTaskCallback bgR,
  86             AsyncTaskCallback postR) {
  87         page = p;
  88         items = l;
  89         sourceImages = si;
  90         generatedImages = new ArrayList&lt;Bitmap&gt;();
  91         maxImageWidth = maxImageHeight = -1;
  92         doInBackgroundCallback = bgR;
  93         postExecuteCallback = postR;
  94     }
  95     AsyncTaskPageData(int p, ArrayList&lt;Object&gt; l, int cw, int ch, AsyncTaskCallback bgR,
  96             AsyncTaskCallback postR) {
  97         page = p;
  98         items = l;
  99         generatedImages = new ArrayList&lt;Bitmap&gt;();
 100         maxImageWidth = cw;
 101         maxImageHeight = ch;
 102         doInBackgroundCallback = bgR;
 103         postExecuteCallback = postR;
 104     }
 105     void cleanup(boolean cancelled) {
 106         // Clean up any references to source/generated bitmaps
 107         if (sourceImages != null) {
 108             if (cancelled) {
 109                 for (Bitmap b : sourceImages) {
 110                     b.recycle();
 111                 }
 112             }
 113             sourceImages.clear();
 114         }
 115         if (generatedImages != null) {
 116             if (cancelled) {
 117                 for (Bitmap b : generatedImages) {
 118                     b.recycle();
 119                 }
 120             }
 121             generatedImages.clear();
 122         }
 123     }
 124     int page;
 125     ArrayList&lt;Object&gt; items;
 126     ArrayList&lt;Bitmap&gt; sourceImages;
 127     ArrayList&lt;Bitmap&gt; generatedImages;
 128     int maxImageWidth;
 129     int maxImageHeight;
 130     AsyncTaskCallback doInBackgroundCallback;
 131     AsyncTaskCallback postExecuteCallback;
 132 }
 133 
 134 /**
 135  * A generic template for an async task used in AppsCustomize.
 136  */
 137 class AppsCustomizeAsyncTask extends AsyncTask&lt;AsyncTaskPageData, Void, AsyncTaskPageData&gt; {
 138     AppsCustomizeAsyncTask(int p, AsyncTaskPageData.Type ty) {
 139         page = p;
 140         threadPriority = Process.THREAD_PRIORITY_DEFAULT;
 141         dataType = ty;
 142     }
 143     @Override
 144     protected AsyncTaskPageData doInBackground(AsyncTaskPageData... params) {
 145         if (params.length != 1) return null;
 146         // Load each of the widget previews in the background
 147         params[0].doInBackgroundCallback.run(this, params[0]);
 148         return params[0];
 149     }
 150     @Override
 151     protected void onPostExecute(AsyncTaskPageData result) {
 152         // All the widget previews are loaded, so we can just callback to inflate the page
 153         result.postExecuteCallback.run(this, result);
 154     }
 155 
 156     void setThreadPriority(int p) {
 157         threadPriority = p;
 158     }
 159     void syncThreadPriority() {
 160         Process.setThreadPriority(threadPriority);
 161     }
 162 
 163     // The page that this async task is associated with
 164     AsyncTaskPageData.Type dataType;
 165     int page;
 166     int threadPriority;
 167 }
 168 
 169 abstract class WeakReferenceThreadLocal&lt;T&gt; {
 170     private ThreadLocal&lt;WeakReference&lt;T&gt;&gt; mThreadLocal;
 171     public WeakReferenceThreadLocal() {
 172         mThreadLocal = new ThreadLocal&lt;WeakReference&lt;T&gt;&gt;();
 173     }
 174 
 175     abstract T initialValue();
 176 
 177     public void set(T t) {
 178         mThreadLocal.set(new WeakReference&lt;T&gt;(t));
 179     }
 180 
 181     public T get() {
 182         WeakReference&lt;T&gt; reference = mThreadLocal.get();
 183         T obj;
 184         if (reference == null) {
 185             obj = initialValue();
 186             mThreadLocal.set(new WeakReference&lt;T&gt;(obj));
 187             return obj;
 188         } else {
 189             obj = reference.get();
 190             if (obj == null) {
 191                 obj = initialValue();
 192                 mThreadLocal.set(new WeakReference&lt;T&gt;(obj));
 193             }
 194             return obj;
 195         }
 196     }
 197 }
 198 
 199 class CanvasCache extends WeakReferenceThreadLocal&lt;Canvas&gt; {
 200     @Override
 201     protected Canvas initialValue() {
 202         return new Canvas();
 203     }
 204 }
 205 
 206 class PaintCache extends WeakReferenceThreadLocal&lt;Paint&gt; {
 207     @Override
 208     protected Paint initialValue() {
 209         return null;
 210     }
 211 }
 212 
 213 class BitmapCache extends WeakReferenceThreadLocal&lt;Bitmap&gt; {
 214     @Override
 215     protected Bitmap initialValue() {
 216         return null;
 217     }
 218 }
 219 
 220 class RectCache extends WeakReferenceThreadLocal&lt;Rect&gt; {
 221     @Override
 222     protected Rect initialValue() {
 223         return new Rect();
 224     }
 225 }
 226 
 227 /**
 228  * The Apps/Customize page that displays all the applications, widgets, and shortcuts.
 229  */
 230 public class AppsCustomizePagedView extends PagedViewWithDraggableItems implements
 231         View.OnClickListener, View.OnKeyListener, DragSource,
 232         PagedViewIcon.PressedCallback, PagedViewWidget.ShortPressListener,
 233         LauncherTransitionable {
 234     static final String TAG = &quot;AppsCustomizePagedView&quot;;
 235 
 236     /**
 237      * The different content types that this paged view can show.
 238      */
 239     public enum ContentType {
 240         Applications,
 241         Widgets
 242     }
 243 
 244     // Refs
 245     private Launcher mLauncher;
 246     private DragController mDragController;
 247     private final LayoutInflater mLayoutInflater;
 248     private final PackageManager mPackageManager;
 249 
 250     // Save and Restore
 251     private int mSaveInstanceStateItemIndex = -1;
 252     private PagedViewIcon mPressedIcon;
 253 
 254     // Content
 255     private ArrayList&lt;ApplicationInfo&gt; mApps;
 256     private ArrayList&lt;Object&gt; mWidgets;
 257 
 258     // Cling
 259     private boolean mHasShownAllAppsCling;
 260     private int mClingFocusedX;
 261     private int mClingFocusedY;
 262 
 263     // Caching
 264     private Canvas mCanvas;
 265     private IconCache mIconCache;
 266 
 267     // Dimens
 268     private int mContentWidth;
 269     private int mAppIconSize;
 270     private int mMaxAppCellCountX, mMaxAppCellCountY;
 271     private int mWidgetCountX, mWidgetCountY;
 272     private int mWidgetWidthGap, mWidgetHeightGap;
 273     private final float sWidgetPreviewIconPaddingPercentage = 0.25f;
 274     private PagedViewCellLayout mWidgetSpacingLayout;
 275     private int mNumAppsPages;
 276     private int mNumWidgetPages;
 277 
 278     // Relating to the scroll and overscroll effects
 279     Workspace.ZInterpolator mZInterpolator = new Workspace.ZInterpolator(0.5f);
 280     private static float CAMERA_DISTANCE = 6500;
 281     private static float TRANSITION_SCALE_FACTOR = 0.74f;
 282     private static float TRANSITION_PIVOT = 0.65f;
 283     private static float TRANSITION_MAX_ROTATION = 22;
 284     private static final boolean PERFORM_OVERSCROLL_ROTATION = true;
 285     private AccelerateInterpolator mAlphaInterpolator = new AccelerateInterpolator(0.9f);
 286     private DecelerateInterpolator mLeftScreenAlphaInterpolator = new DecelerateInterpolator(4);
 287 
 288     // Previews &amp; outlines
 289     ArrayList&lt;AppsCustomizeAsyncTask&gt; mRunningTasks;
 290     private static final int sPageSleepDelay = 200;
 291 
 292     private Runnable mInflateWidgetRunnable = null;
 293     private Runnable mBindWidgetRunnable = null;
 294     static final int WIDGET_NO_CLEANUP_REQUIRED = -1;
 295     static final int WIDGET_PRELOAD_PENDING = 0;
 296     static final int WIDGET_BOUND = 1;
 297     static final int WIDGET_INFLATED = 2;
 298     int mWidgetCleanupState = WIDGET_NO_CLEANUP_REQUIRED;
 299     int mWidgetLoadingId = -1;
 300     PendingAddWidgetInfo mCreateWidgetInfo = null;
 301     private boolean mDraggingWidget = false;
 302 
 303     private Toast mWidgetInstructionToast;
 304 
 305     // Deferral of loading widget previews during launcher transitions
 306     private boolean mInTransition;
 307     private ArrayList&lt;AsyncTaskPageData&gt; mDeferredSyncWidgetPageItems =
 308         new ArrayList&lt;AsyncTaskPageData&gt;();
 309     private ArrayList&lt;Runnable&gt; mDeferredPrepareLoadWidgetPreviewsTasks =
 310         new ArrayList&lt;Runnable&gt;();
 311 
 312     // Used for drawing shortcut previews
 313     BitmapCache mCachedShortcutPreviewBitmap = new BitmapCache();
 314     PaintCache mCachedShortcutPreviewPaint = new PaintCache();
 315     CanvasCache mCachedShortcutPreviewCanvas = new CanvasCache();
 316 
 317     // Used for drawing widget previews
 318     CanvasCache mCachedAppWidgetPreviewCanvas = new CanvasCache();
 319     RectCache mCachedAppWidgetPreviewSrcRect = new RectCache();
 320     RectCache mCachedAppWidgetPreviewDestRect = new RectCache();
 321     PaintCache mCachedAppWidgetPreviewPaint = new PaintCache();
 322 
 323     public AppsCustomizePagedView(Context context, AttributeSet attrs) {
 324         super(context, attrs);
 325         mLayoutInflater = LayoutInflater.from(context);
 326         mPackageManager = context.getPackageManager();
 327         mApps = new ArrayList&lt;ApplicationInfo&gt;();
 328         mWidgets = new ArrayList&lt;Object&gt;();
 329         mIconCache = ((LauncherApplication) context.getApplicationContext()).getIconCache();
 330         mCanvas = new Canvas();
 331         mRunningTasks = new ArrayList&lt;AppsCustomizeAsyncTask&gt;();
 332 
 333         // Save the default widget preview background
 334         Resources resources = context.getResources();
 335         mAppIconSize = resources.getDimensionPixelSize(R.dimen.app_icon_size);
 336 
 337         TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.AppsCustomizePagedView, 0, 0);
 338         mMaxAppCellCountX = a.getInt(R.styleable.AppsCustomizePagedView_maxAppCellCountX, -1);
 339         mMaxAppCellCountY = a.getInt(R.styleable.AppsCustomizePagedView_maxAppCellCountY, -1);
 340         mWidgetWidthGap =
 341             a.getDimensionPixelSize(R.styleable.AppsCustomizePagedView_widgetCellWidthGap, 0);
 342         mWidgetHeightGap =
 343             a.getDimensionPixelSize(R.styleable.AppsCustomizePagedView_widgetCellHeightGap, 0);
 344         mWidgetCountX = a.getInt(R.styleable.AppsCustomizePagedView_widgetCountX, 2);
 345         mWidgetCountY = a.getInt(R.styleable.AppsCustomizePagedView_widgetCountY, 2);
 346         mClingFocusedX = a.getInt(R.styleable.AppsCustomizePagedView_clingFocusedX, 0);
 347         mClingFocusedY = a.getInt(R.styleable.AppsCustomizePagedView_clingFocusedY, 0);
 348         a.recycle();
 349         mWidgetSpacingLayout = new PagedViewCellLayout(getContext());
 350 
 351         // The padding on the non-matched dimension for the default widget preview icons
 352         // (top + bottom)
 353         mFadeInAdjacentScreens = false;
 354 
 355         // Unless otherwise specified this view is important for accessibility.
 356         if (getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
 357             setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
 358         }
 359     }
 360 
 361     @Override
 362     protected void init() {
 363         super.init();
 364         mCenterPagesVertically = false;
 365 
 366         Context context = getContext();
 367         Resources r = context.getResources();
 368         setDragSlopeThreshold(r.getInteger(R.integer.config_appsCustomizeDragSlopeThreshold)/100f);
 369     }
 370 
 371     @Override
 372     protected void onUnhandledTap(MotionEvent ev) {
 373         if (LauncherApplication.isScreenLarge()) {
 374             // Dismiss AppsCustomize if we tap
 375             mLauncher.showWorkspace(true);
 376         }
 377     }
 378 
 379     /** Returns the item index of the center item on this page so that we can restore to this
 380      *  item index when we rotate. */
 381     private int getMiddleComponentIndexOnCurrentPage() {
 382         int i = -1;
 383         if (getPageCount() &gt; 0) {
 384             int currentPage = getCurrentPage();
 385             if (currentPage &lt; mNumAppsPages) {
 386                 PagedViewCellLayout layout = (PagedViewCellLayout) getPageAt(currentPage);
 387                 PagedViewCellLayoutChildren childrenLayout = layout.getChildrenLayout();
 388                 int numItemsPerPage = mCellCountX * mCellCountY;
 389                 int childCount = childrenLayout.getChildCount();
 390                 if (childCount &gt; 0) {
 391                     i = (currentPage * numItemsPerPage) + (childCount / 2);
 392                 }
 393             } else {
 394                 int numApps = mApps.size();
 395                 PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(currentPage);
 396                 int numItemsPerPage = mWidgetCountX * mWidgetCountY;
 397                 int childCount = layout.getChildCount();
 398                 if (childCount &gt; 0) {
 399                     i = numApps +
 400                         ((currentPage - mNumAppsPages) * numItemsPerPage) + (childCount / 2);
 401                 }
 402             }
 403         }
 404         return i;
 405     }
 406 
 407     /** Get the index of the item to restore to if we need to restore the current page. */
 408     int getSaveInstanceStateIndex() {
 409         if (mSaveInstanceStateItemIndex == -1) {
 410             mSaveInstanceStateItemIndex = getMiddleComponentIndexOnCurrentPage();
 411         }
 412         return mSaveInstanceStateItemIndex;
 413     }
 414 
 415     /** Returns the page in the current orientation which is expected to contain the specified
 416      *  item index. */
 417     int getPageForComponent(int index) {
 418         if (index &lt; 0) return 0;
 419 
 420         if (index &lt; mApps.size()) {
 421             int numItemsPerPage = mCellCountX * mCellCountY;
 422             return (index / numItemsPerPage);
 423         } else {
 424             int numItemsPerPage = mWidgetCountX * mWidgetCountY;
 425             return mNumAppsPages + ((index - mApps.size()) / numItemsPerPage);
 426         }
 427     }
 428 
 429     /** Restores the page for an item at the specified index */
 430     void restorePageForIndex(int index) {
 431         if (index &lt; 0) return;
 432         mSaveInstanceStateItemIndex = index;
 433     }
 434 
 435     private void updatePageCounts() {
 436         mNumWidgetPages = (int) Math.ceil(mWidgets.size() /
 437                 (float) (mWidgetCountX * mWidgetCountY));
 438         mNumAppsPages = (int) Math.ceil((float) mApps.size() / (mCellCountX * mCellCountY));
 439     }
 440 
 441     protected void onDataReady(int width, int height) {
 442         // Note that we transpose the counts in portrait so that we get a similar layout
 443         boolean isLandscape = getResources().getConfiguration().orientation ==
 444             Configuration.ORIENTATION_LANDSCAPE;
 445         int maxCellCountX = Integer.MAX_VALUE;
 446         int maxCellCountY = Integer.MAX_VALUE;
 447         if (LauncherApplication.isScreenLarge()) {
 448             maxCellCountX = (isLandscape ? LauncherModel.getCellCountX() :
 449                 LauncherModel.getCellCountY());
 450             maxCellCountY = (isLandscape ? LauncherModel.getCellCountY() :
 451                 LauncherModel.getCellCountX());
 452         }
 453         if (mMaxAppCellCountX &gt; -1) {
 454             maxCellCountX = Math.min(maxCellCountX, mMaxAppCellCountX);
 455         }
 456         if (mMaxAppCellCountY &gt; -1) {
 457             maxCellCountY = Math.min(maxCellCountY, mMaxAppCellCountY);
 458         }
 459 
 460         // Now that the data is ready, we can calculate the content width, the number of cells to
 461         // use for each page
 462         mWidgetSpacingLayout.setGap(mPageLayoutWidthGap, mPageLayoutHeightGap);
 463         mWidgetSpacingLayout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
 464                 mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
 465         mWidgetSpacingLayout.calculateCellCount(width, height, maxCellCountX, maxCellCountY);
 466         mCellCountX = mWidgetSpacingLayout.getCellCountX();
 467         mCellCountY = mWidgetSpacingLayout.getCellCountY();
 468         updatePageCounts();
 469 
 470         // Force a measure to update recalculate the gaps
 471         int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
 472         int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
 473         mWidgetSpacingLayout.measure(widthSpec, heightSpec);
 474         mContentWidth = mWidgetSpacingLayout.getContentWidth();
 475 
 476         AppsCustomizeTabHost host = (AppsCustomizeTabHost) getTabHost();
 477         final boolean hostIsTransitioning = host.isTransitioning();
 478 
 479         // Restore the page
 480         int page = getPageForComponent(mSaveInstanceStateItemIndex);
 481         invalidatePageData(Math.max(0, page), hostIsTransitioning);
 482 
 483         // Show All Apps cling if we are finished transitioning, otherwise, we will try again when
 484         // the transition completes in AppsCustomizeTabHost (otherwise the wrong offsets will be
 485         // returned while animating)
 486         if (!hostIsTransitioning) {
 487             post(new Runnable() {
 488                 @Override
 489                 public void run() {
 490                     showAllAppsCling();
 491                 }
 492             });
 493         }
 494     }
 495 
 496     void showAllAppsCling() {
 497         if (!mHasShownAllAppsCling &amp;&amp; isDataReady()) {
 498             mHasShownAllAppsCling = true;
 499             // Calculate the position for the cling punch through
 500             int[] offset = new int[2];
 501             int[] pos = mWidgetSpacingLayout.estimateCellPosition(mClingFocusedX, mClingFocusedY);
 502             mLauncher.getDragLayer().getLocationInDragLayer(this, offset);
 503             // PagedViews are centered horizontally but top aligned
 504             pos[0] += (getMeasuredWidth() - mWidgetSpacingLayout.getMeasuredWidth()) / 2 +
 505                     offset[0];
 506             pos[1] += offset[1];
 507             mLauncher.showFirstRunAllAppsCling(pos);
 508         }
 509     }
 510 
 511     @Override
 512     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 513         int width = MeasureSpec.getSize(widthMeasureSpec);
 514         int height = MeasureSpec.getSize(heightMeasureSpec);
 515         if (!isDataReady()) {
 516             if (!mApps.isEmpty() &amp;&amp; !mWidgets.isEmpty()) {
 517                 setDataIsReady();
 518                 setMeasuredDimension(width, height);
 519                 onDataReady(width, height);
 520             }
 521         }
 522 
 523         super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 524     }
 525 
 526 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 527     public void onPackagesUpdated() {</span>
 528 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 529         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 530 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 531         super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 532     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 533 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 534     public void onPackagesUpdated() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 535         // TODO: this isn&#x27;t ideal, but we actually need to delay here. This call is triggered</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 536         // by a broadcast receiver, and in order for it to work correctly, we need to know that</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 537         // the AppWidgetService has already received and processed the same broadcast. Since there</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 538         // is no guarantee about ordering of broadcast receipt, we just delay here. This is a</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 539         // workaround until we add a callback from AppWidgetService to AppWidgetHost when widget</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 540         // packages are added, updated or removed.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 541         postDelayed(new Runnable() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 542            public void run() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 543                updatePackages();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 544            }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 545         }, 1500);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 546     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 547 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 548     public void updatePackages() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 549         // Get the list of widgets and shortcuts</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 550         mWidgets.clear();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 551         List&lt;AppWidgetProviderInfo&gt; widgets =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 552             AppWidgetManager.getInstance(mLauncher).getInstalledProviders();</span>
 553 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 554     public void onPackagesUpdated(boolean immediate) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 555         if (immediate) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 556             updatePackages();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 557         } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 558             // TODO: this isn&#x27;t ideal, but we actually need to delay here. This call is triggered</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 559             // by a broadcast receiver, and in order for it to work correctly, we need to know that</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 560             // the AppWidgetService has already received and processed the same broadcast. Since there</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 561             // is no guarantee about ordering of broadcast receipt, we just delay here. This is a</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 562             // workaround until we add a callback from AppWidgetService to AppWidgetHost when widget</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 563             // packages are added, updated or removed.</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 564             postDelayed(new Runnable() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 565                public void run() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 566                    updatePackages();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 567                }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 568             }, 1500);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 569         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 570     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 571 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 572     public void updatePackages() {</span>
 573 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 574         // Get the list of widgets and shortcuts
 575         mWidgets.clear();
 576         List&lt;AppWidgetProviderInfo&gt; widgets =
 577             AppWidgetManager.getInstance(mLauncher).getInstalledProviders();
 578         Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
 579         List&lt;ResolveInfo&gt; shortcuts = mPackageManager.queryIntentActivities(shortcutsIntent, 0);
 580         for (AppWidgetProviderInfo widget : widgets) {
 581             if (widget.minWidth &gt; 0 &amp;&amp; widget.minHeight &gt; 0) {
 582                 // Ensure that all widgets we show can be added on a workspace of this size
 583                 int[] spanXY = Launcher.getSpanForWidget(mLauncher, widget);
 584                 int[] minSpanXY = Launcher.getMinSpanForWidget(mLauncher, widget);
 585                 int minSpanX = Math.min(spanXY[0], minSpanXY[0]);
 586                 int minSpanY = Math.min(spanXY[1], minSpanXY[1]);
 587                 if (minSpanX &lt;= LauncherModel.getCellCountX() &amp;&amp;
 588                         minSpanY &lt;= LauncherModel.getCellCountY()) {
 589                     mWidgets.add(widget);
 590                 } else {
 591                     Log.e(TAG, &quot;Widget &quot; + widget.provider + &quot; can not fit on this device (&quot; +
 592                             widget.minWidth + &quot;, &quot; + widget.minHeight + &quot;)&quot;);
 593                 }
 594             } else {
 595                 Log.e(TAG, &quot;Widget &quot; + widget.provider + &quot; has invalid dimensions (&quot; +
 596                         widget.minWidth + &quot;, &quot; + widget.minHeight + &quot;)&quot;);
 597             }
 598         }
 599         mWidgets.addAll(shortcuts);
 600         Collections.sort(mWidgets,
 601                 new LauncherModel.WidgetAndShortcutNameComparator(mPackageManager));
 602         updatePageCounts();
 603         invalidateOnDataChange();
 604     }
 605 
 606     @Override
 607     public void onClick(View v) {
 608         // When we have exited all apps or are in transition, disregard clicks
 609         if (!mLauncher.isAllAppsVisible() ||
 610                 mLauncher.getWorkspace().isSwitchingState()) return;
 611 
 612         if (v instanceof PagedViewIcon) {
 613             // Animate some feedback to the click
 614             final ApplicationInfo appInfo = (ApplicationInfo) v.getTag();
 615 
 616             // Lock the drawable state to pressed until we return to Launcher
 617             if (mPressedIcon != null) {
 618                 mPressedIcon.lockDrawableState();
 619             }
 620 
 621             // NOTE: We want all transitions from launcher to act as if the wallpaper were enabled
 622             // to be consistent.  So re-enable the flag here, and we will re-disable it as necessary
 623             // when Launcher resumes and we are still in AllApps.
 624             mLauncher.updateWallpaperVisibility(true);
 625             mLauncher.startActivitySafely(v, appInfo.intent, appInfo);
 626 
 627         } else if (v instanceof PagedViewWidget) {
 628             // Let the user know that they have to long press to add a widget
 629             if (mWidgetInstructionToast != null) {
 630                 mWidgetInstructionToast.cancel();
 631             }
 632             mWidgetInstructionToast = Toast.makeText(getContext(),R.string.long_press_widget_to_add,
 633                 Toast.LENGTH_SHORT);
 634             mWidgetInstructionToast.show();
 635 
 636             // Create a little animation to show that the widget can move
 637             float offsetY = getResources().getDimensionPixelSize(R.dimen.dragViewOffsetY);
 638             final ImageView p = (ImageView) v.findViewById(R.id.widget_preview);
 639             AnimatorSet bounce = LauncherAnimUtils.createAnimatorSet();
 640             ValueAnimator tyuAnim = LauncherAnimUtils.ofFloat(p, &quot;translationY&quot;, offsetY);
 641             tyuAnim.setDuration(125);
 642             ValueAnimator tydAnim = LauncherAnimUtils.ofFloat(p, &quot;translationY&quot;, 0f);
 643             tydAnim.setDuration(100);
 644             bounce.play(tyuAnim).before(tydAnim);
 645             bounce.setInterpolator(new AccelerateInterpolator());
 646             bounce.start();
 647         }
 648     }
 649 
 650     public boolean onKey(View v, int keyCode, KeyEvent event) {
 651         return FocusHelper.handleAppsCustomizeKeyEvent(v,  keyCode, event);
 652     }
 653 
 654     /*
 655      * PagedViewWithDraggableItems implementation
 656      */
 657     @Override
 658     protected void determineDraggingStart(android.view.MotionEvent ev) {
 659         // Disable dragging by pulling an app down for now.
 660     }
 661 
 662     private void beginDraggingApplication(View v) {
 663         mLauncher.getWorkspace().onDragStartedWithItem(v);
 664         mLauncher.getWorkspace().beginDragShared(v, this);
 665     }
 666 
 667     private void preloadWidget(final PendingAddWidgetInfo info) {
 668         final AppWidgetProviderInfo pInfo = info.info;
 669         if (pInfo.configure != null) {
 670             return;
 671         }
 672 
 673         mWidgetCleanupState = WIDGET_PRELOAD_PENDING;
 674         mBindWidgetRunnable = new Runnable() {
 675             @Override
 676             public void run() {
 677                 mWidgetLoadingId = mLauncher.getAppWidgetHost().allocateAppWidgetId();
 678                 if (AppWidgetManager.getInstance(mLauncher)
 679                             .bindAppWidgetIdIfAllowed(mWidgetLoadingId, info.componentName)) {
 680                     mWidgetCleanupState = WIDGET_BOUND;
 681                 }
 682             }
 683         };
 684         post(mBindWidgetRunnable);
 685 
 686         mInflateWidgetRunnable = new Runnable() {
 687             @Override
 688             public void run() {
 689                 AppWidgetHostView hostView = mLauncher.
 690                         getAppWidgetHost().createView(getContext(), mWidgetLoadingId, pInfo);
 691                 info.boundWidget = hostView;
 692                 mWidgetCleanupState = WIDGET_INFLATED;
 693                 hostView.setVisibility(INVISIBLE);
 694                 int[] unScaledSize = mLauncher.getWorkspace().estimateItemSize(info.spanX,
 695                         info.spanY, info, false);
 696 
 697                 // We want the first widget layout to be the correct size. This will be important
 698                 // for width size reporting to the AppWidgetManager.
 699                 DragLayer.LayoutParams lp = new DragLayer.LayoutParams(unScaledSize[0],
 700                         unScaledSize[1]);
 701                 lp.x = lp.y = 0;
 702                 lp.customPosition = true;
 703                 hostView.setLayoutParams(lp);
 704                 mLauncher.getDragLayer().addView(hostView);
 705             }
 706         };
 707         post(mInflateWidgetRunnable);
 708     }
 709 
 710     @Override
 711     public void onShortPress(View v) {
 712         // We are anticipating a long press, and we use this time to load bind and instantiate
 713         // the widget. This will need to be cleaned up if it turns out no long press occurs.
 714         if (mCreateWidgetInfo != null) {
 715             // Just in case the cleanup process wasn&#x27;t properly executed. This shouldn&#x27;t happen.
 716             cleanupWidgetPreloading(false);
 717         }
 718         mCreateWidgetInfo = new PendingAddWidgetInfo((PendingAddWidgetInfo) v.getTag());
 719         preloadWidget(mCreateWidgetInfo);
 720     }
 721 
 722     private void cleanupWidgetPreloading(boolean widgetWasAdded) {
 723         if (!widgetWasAdded) {
 724             // If the widget was not added, we may need to do further cleanup.
 725             PendingAddWidgetInfo info = mCreateWidgetInfo;
 726             mCreateWidgetInfo = null;
 727 
 728             if (mWidgetCleanupState == WIDGET_PRELOAD_PENDING) {
 729                 // We never did any preloading, so just remove pending callbacks to do so
 730                 removeCallbacks(mBindWidgetRunnable);
 731                 removeCallbacks(mInflateWidgetRunnable);
 732             } else if (mWidgetCleanupState == WIDGET_BOUND) {
 733                  // Delete the widget id which was allocated
 734                 if (mWidgetLoadingId != -1) {
 735                     mLauncher.getAppWidgetHost().deleteAppWidgetId(mWidgetLoadingId);
 736                 }
 737 
 738                 // We never got around to inflating the widget, so remove the callback to do so.
 739                 removeCallbacks(mInflateWidgetRunnable);
 740             } else if (mWidgetCleanupState == WIDGET_INFLATED) {
 741                 // Delete the widget id which was allocated
 742                 if (mWidgetLoadingId != -1) {
 743                     mLauncher.getAppWidgetHost().deleteAppWidgetId(mWidgetLoadingId);
 744                 }
 745 
 746                 // The widget was inflated and added to the DragLayer -- remove it.
 747                 AppWidgetHostView widget = info.boundWidget;
 748                 mLauncher.getDragLayer().removeView(widget);
 749             }
 750         }
 751         mWidgetCleanupState = WIDGET_NO_CLEANUP_REQUIRED;
 752         mWidgetLoadingId = -1;
 753         mCreateWidgetInfo = null;
 754         PagedViewWidget.resetShortPressTarget();
 755     }
 756 
 757     @Override
 758     public void cleanUpShortPress(View v) {
 759         if (!mDraggingWidget) {
 760             cleanupWidgetPreloading(false);
 761         }
 762     }
 763 
 764     private boolean beginDraggingWidget(View v) {
 765         mDraggingWidget = true;
 766         // Get the widget preview as the drag representation
 767         ImageView image = (ImageView) v.findViewById(R.id.widget_preview);
 768         PendingAddItemInfo createItemInfo = (PendingAddItemInfo) v.getTag();
 769 
 770         // If the ImageView doesn&#x27;t have a drawable yet, the widget preview hasn&#x27;t been loaded and
 771         // we abort the drag.
 772         if (image.getDrawable() == null) {
 773             mDraggingWidget = false;
 774             return false;
 775         }
 776 
 777         // Compose the drag image
 778         Bitmap preview;
 779         Bitmap outline;
 780         float scale = 1f;
 781         if (createItemInfo instanceof PendingAddWidgetInfo) {
 782             // This can happen in some weird cases involving multi-touch. We can&#x27;t start dragging
 783             // the widget if this is null, so we break out.
 784             if (mCreateWidgetInfo == null) {
 785                 return false;
 786             }
 787 
 788             PendingAddWidgetInfo createWidgetInfo = mCreateWidgetInfo;
 789             createItemInfo = createWidgetInfo;
 790             int spanX = createItemInfo.spanX;
 791             int spanY = createItemInfo.spanY;
 792             int[] size = mLauncher.getWorkspace().estimateItemSize(spanX, spanY,
 793                     createWidgetInfo, true);
 794 
 795             FastBitmapDrawable previewDrawable = (FastBitmapDrawable) image.getDrawable();
 796             float minScale = 1.25f;
 797             int maxWidth, maxHeight;
 798             maxWidth = Math.min((int) (previewDrawable.getIntrinsicWidth() * minScale), size[0]);
 799             maxHeight = Math.min((int) (previewDrawable.getIntrinsicHeight() * minScale), size[1]);
 800             preview = getWidgetPreview(createWidgetInfo.componentName, createWidgetInfo.previewImage,
 801                     createWidgetInfo.icon, spanX, spanY, maxWidth, maxHeight);
 802 
 803             // Determine the image view drawable scale relative to the preview
 804             float[] mv = new float[9];
 805             Matrix m = new Matrix();
 806             m.setRectToRect(
 807                     new RectF(0f, 0f, (float) preview.getWidth(), (float) preview.getHeight()),
 808                     new RectF(0f, 0f, (float) previewDrawable.getIntrinsicWidth(),
 809                             (float) previewDrawable.getIntrinsicHeight()),
 810                     Matrix.ScaleToFit.START);
 811             m.getValues(mv);
 812             scale = (float) mv[0];
 813         } else {
 814             PendingAddShortcutInfo createShortcutInfo = (PendingAddShortcutInfo) v.getTag();
 815             Drawable icon = mIconCache.getFullResIcon(createShortcutInfo.shortcutActivityInfo);
 816             preview = Bitmap.createBitmap(icon.getIntrinsicWidth(),
 817                     icon.getIntrinsicHeight(), Bitmap.Config.ARGB_8888);
 818 
 819             mCanvas.setBitmap(preview);
 820             mCanvas.save();
 821             renderDrawableToBitmap(icon, preview, 0, 0,
 822                     icon.getIntrinsicWidth(), icon.getIntrinsicHeight());
 823             mCanvas.restore();
 824             mCanvas.setBitmap(null);
 825             createItemInfo.spanX = createItemInfo.spanY = 1;
 826         }
 827 
 828         // Don&#x27;t clip alpha values for the drag outline if we&#x27;re using the default widget preview
 829         boolean clipAlpha = !(createItemInfo instanceof PendingAddWidgetInfo &amp;&amp;
 830                 (((PendingAddWidgetInfo) createItemInfo).previewImage == 0));
 831 
 832         // Save the preview for the outline generation, then dim the preview
 833         outline = Bitmap.createScaledBitmap(preview, preview.getWidth(), preview.getHeight(),
 834                 false);
 835 
 836         // Start the drag
 837         mLauncher.lockScreenOrientation();
 838         mLauncher.getWorkspace().onDragStartedWithItem(createItemInfo, outline, clipAlpha);
 839         mDragController.startDrag(image, preview, this, createItemInfo,
 840                 DragController.DRAG_ACTION_COPY, null, scale);
 841         outline.recycle();
 842         preview.recycle();
 843         return true;
 844     }
 845 
 846     @Override
 847     protected boolean beginDragging(final View v) {
 848         if (!super.beginDragging(v)) return false;
 849 
 850         if (v instanceof PagedViewIcon) {
 851             beginDraggingApplication(v);
 852         } else if (v instanceof PagedViewWidget) {
 853             if (!beginDraggingWidget(v)) {
 854                 return false;
 855             }
 856         }
 857 
 858         // We delay entering spring-loaded mode slightly to make sure the UI
 859         // thready is free of any work.
 860         postDelayed(new Runnable() {
 861             @Override
 862             public void run() {
 863                 // We don&#x27;t enter spring-loaded mode if the drag has been cancelled
 864                 if (mLauncher.getDragController().isDragging()) {
 865                     // Dismiss the cling
 866                     mLauncher.dismissAllAppsCling(null);
 867 
 868                     // Reset the alpha on the dragged icon before we drag
 869                     resetDrawableState();
 870 
 871                     // Go into spring loaded mode (must happen before we startDrag())
 872                     mLauncher.enterSpringLoadedDragMode();
 873                 }
 874             }
 875         }, 150);
 876 
 877         return true;
 878     }
 879 
 880     /**
 881      * Clean up after dragging.
 882      *
 883      * @param target where the item was dragged to (can be null if the item was flung)
 884      */
 885     private void endDragging(View target, boolean isFlingToDelete, boolean success) {
 886         if (isFlingToDelete || !success || (target != mLauncher.getWorkspace() &amp;&amp;
 887                 !(target instanceof DeleteDropTarget))) {
 888             // Exit spring loaded mode if we have not successfully dropped or have not handled the
 889             // drop in Workspace
 890             mLauncher.exitSpringLoadedDragMode();
 891         }
 892         mLauncher.unlockScreenOrientation(false);
 893     }
 894 
 895     @Override
 896     public View getContent() {
 897         return null;
 898     }
 899 
 900     @Override
 901     public void onLauncherTransitionPrepare(Launcher l, boolean animated, boolean toWorkspace) {
 902         mInTransition = true;
 903         if (toWorkspace) {
 904             cancelAllTasks();
 905         }
 906     }
 907 
 908     @Override
 909     public void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace) {
 910     }
 911 
 912     @Override
 913     public void onLauncherTransitionStep(Launcher l, float t) {
 914     }
 915 
 916     @Override
 917     public void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace) {
 918         mInTransition = false;
 919         for (AsyncTaskPageData d : mDeferredSyncWidgetPageItems) {
 920             onSyncWidgetPageItems(d);
 921         }
 922         mDeferredSyncWidgetPageItems.clear();
 923         for (Runnable r : mDeferredPrepareLoadWidgetPreviewsTasks) {
 924             r.run();
 925         }
 926         mDeferredPrepareLoadWidgetPreviewsTasks.clear();
 927         mForceDrawAllChildrenNextFrame = !toWorkspace;
 928     }
 929 
 930     @Override
 931     public void onDropCompleted(View target, DragObject d, boolean isFlingToDelete,
 932             boolean success) {
 933         // Return early and wait for onFlingToDeleteCompleted if this was the result of a fling
 934         if (isFlingToDelete) return;
 935 
 936         endDragging(target, false, success);
 937 
 938         // Display an error message if the drag failed due to there not being enough space on the
 939         // target layout we were dropping on.
 940         if (!success) {
 941             boolean showOutOfSpaceMessage = false;
 942             if (target instanceof Workspace) {
 943                 int currentScreen = mLauncher.getCurrentWorkspaceScreen();
 944                 Workspace workspace = (Workspace) target;
 945                 CellLayout layout = (CellLayout) workspace.getChildAt(currentScreen);
 946                 ItemInfo itemInfo = (ItemInfo) d.dragInfo;
 947                 if (layout != null) {
 948                     layout.calculateSpans(itemInfo);
 949                     showOutOfSpaceMessage =
 950                             !layout.findCellForSpan(null, itemInfo.spanX, itemInfo.spanY);
 951                 }
 952             }
 953             if (showOutOfSpaceMessage) {
 954                 mLauncher.showOutOfSpaceMessage(false);
 955             }
 956 
 957             d.deferDragViewCleanupPostAnimation = false;
 958         }
 959         cleanupWidgetPreloading(success);
 960         mDraggingWidget = false;
 961     }
 962 
 963     @Override
 964     public void onFlingToDeleteCompleted() {
 965         // We just dismiss the drag when we fling, so cleanup here
 966         endDragging(null, true, true);
 967         cleanupWidgetPreloading(false);
 968         mDraggingWidget = false;
 969     }
 970 
 971     @Override
 972     public boolean supportsFlingToDelete() {
 973         return true;
 974     }
 975 
 976     @Override
 977     protected void onDetachedFromWindow() {
 978         super.onDetachedFromWindow();
 979         cancelAllTasks();
 980     }
 981 
 982     public void clearAllWidgetPages() {
 983         cancelAllTasks();
 984         int count = getChildCount();
 985         for (int i = 0; i &lt; count; i++) {
 986             View v = getPageAt(i);
 987             if (v instanceof PagedViewGridLayout) {
 988                 ((PagedViewGridLayout) v).removeAllViewsOnPage();
 989                 mDirtyPageContent.set(i, true);
 990             }
 991         }
 992     }
 993 
 994     private void cancelAllTasks() {
 995         // Clean up all the async tasks
 996         Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
 997         while (iter.hasNext()) {
 998             AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
 999             task.cancel(false);
1000             iter.remove();
1001             mDirtyPageContent.set(task.page, true);
1002 
1003             // We&#x27;ve already preallocated the views for the data to load into, so clear them as well
1004             View v = getPageAt(task.page);
1005             if (v instanceof PagedViewGridLayout) {
1006                 ((PagedViewGridLayout) v).removeAllViewsOnPage();
1007             }
1008         }
1009         mDeferredSyncWidgetPageItems.clear();
1010         mDeferredPrepareLoadWidgetPreviewsTasks.clear();
1011     }
1012 
1013     public void setContentType(ContentType type) {
1014         if (type == ContentType.Widgets) {
1015             invalidatePageData(mNumAppsPages, true);
1016         } else if (type == ContentType.Applications) {
1017             invalidatePageData(0, true);
1018         }
1019     }
1020 
1021     protected void snapToPage(int whichPage, int delta, int duration) {
1022         super.snapToPage(whichPage, delta, duration);
1023         updateCurrentTab(whichPage);
1024 
1025         // Update the thread priorities given the direction lookahead
1026         Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1027         while (iter.hasNext()) {
1028             AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1029             int pageIndex = task.page;
1030             if ((mNextPage &gt; mCurrentPage &amp;&amp; pageIndex &gt;= mCurrentPage) ||
1031                 (mNextPage &lt; mCurrentPage &amp;&amp; pageIndex &lt;= mCurrentPage)) {
1032                 task.setThreadPriority(getThreadPriorityForPage(pageIndex));
1033             } else {
1034                 task.setThreadPriority(Process.THREAD_PRIORITY_LOWEST);
1035             }
1036         }
1037     }
1038 
1039     private void updateCurrentTab(int currentPage) {
1040         AppsCustomizeTabHost tabHost = getTabHost();
1041         if (tabHost != null) {
1042             String tag = tabHost.getCurrentTabTag();
1043             if (tag != null) {
1044                 if (currentPage &gt;= mNumAppsPages &amp;&amp;
1045                         !tag.equals(tabHost.getTabTagForContentType(ContentType.Widgets))) {
1046                     tabHost.setCurrentTabFromContent(ContentType.Widgets);
1047                 } else if (currentPage &lt; mNumAppsPages &amp;&amp;
1048                         !tag.equals(tabHost.getTabTagForContentType(ContentType.Applications))) {
1049                     tabHost.setCurrentTabFromContent(ContentType.Applications);
1050                 }
1051             }
1052         }
1053     }
1054 
1055     /*
1056      * Apps PagedView implementation
1057      */
1058     private void setVisibilityOnChildren(ViewGroup layout, int visibility) {
1059         int childCount = layout.getChildCount();
1060         for (int i = 0; i &lt; childCount; ++i) {
1061             layout.getChildAt(i).setVisibility(visibility);
1062         }
1063     }
1064     private void setupPage(PagedViewCellLayout layout) {
1065         layout.setCellCount(mCellCountX, mCellCountY);
1066         layout.setGap(mPageLayoutWidthGap, mPageLayoutHeightGap);
1067         layout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
1068                 mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
1069 
1070         // Note: We force a measure here to get around the fact that when we do layout calculations
1071         // immediately after syncing, we don&#x27;t have a proper width.  That said, we already know the
1072         // expected page width, so we can actually optimize by hiding all the TextView-based
1073         // children that are expensive to measure, and let that happen naturally later.
1074         setVisibilityOnChildren(layout, View.GONE);
1075         int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
1076         int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
1077         layout.setMinimumWidth(getPageContentWidth());
1078         layout.measure(widthSpec, heightSpec);
1079         setVisibilityOnChildren(layout, View.VISIBLE);
1080     }
1081 
1082     public void syncAppsPageItems(int page, boolean immediate) {
1083         // ensure that we have the right number of items on the pages
1084         int numCells = mCellCountX * mCellCountY;
1085         int startIndex = page * numCells;
1086         int endIndex = Math.min(startIndex + numCells, mApps.size());
1087         PagedViewCellLayout layout = (PagedViewCellLayout) getPageAt(page);
1088 
1089         layout.removeAllViewsOnPage();
1090         ArrayList&lt;Object&gt; items = new ArrayList&lt;Object&gt;();
1091         ArrayList&lt;Bitmap&gt; images = new ArrayList&lt;Bitmap&gt;();
1092         for (int i = startIndex; i &lt; endIndex; ++i) {
1093             ApplicationInfo info = mApps.get(i);
1094             PagedViewIcon icon = (PagedViewIcon) mLayoutInflater.inflate(
1095                     R.layout.apps_customize_application, layout, false);
1096             icon.applyFromApplicationInfo(info, true, this);
1097             icon.setOnClickListener(this);
1098             icon.setOnLongClickListener(this);
1099             icon.setOnTouchListener(this);
1100             icon.setOnKeyListener(this);
1101 
1102             int index = i - startIndex;
1103             int x = index % mCellCountX;
1104             int y = index / mCellCountX;
1105             layout.addViewToCellLayout(icon, -1, i, new PagedViewCellLayout.LayoutParams(x,y, 1,1));
1106 
1107             items.add(info);
1108             images.add(info.iconBitmap);
1109         }
1110 
1111         layout.createHardwareLayers();
1112     }
1113 
1114     /**
1115      * A helper to return the priority for loading of the specified widget page.
1116      */
1117     private int getWidgetPageLoadPriority(int page) {
1118         // If we are snapping to another page, use that index as the target page index
1119         int toPage = mCurrentPage;
1120         if (mNextPage &gt; -1) {
1121             toPage = mNextPage;
1122         }
1123 
1124         // We use the distance from the target page as an initial guess of priority, but if there
1125         // are no pages of higher priority than the page specified, then bump up the priority of
1126         // the specified page.
1127         Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1128         int minPageDiff = Integer.MAX_VALUE;
1129         while (iter.hasNext()) {
1130             AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1131             minPageDiff = Math.abs(task.page - toPage);
1132         }
1133 
1134         int rawPageDiff = Math.abs(page - toPage);
1135         return rawPageDiff - Math.min(rawPageDiff, minPageDiff);
1136     }
1137     /**
1138      * Return the appropriate thread priority for loading for a given page (we give the current
1139      * page much higher priority)
1140      */
1141     private int getThreadPriorityForPage(int page) {
1142         // TODO-APPS_CUSTOMIZE: detect number of cores and set thread priorities accordingly below
1143         int pageDiff = getWidgetPageLoadPriority(page);
1144         if (pageDiff &lt;= 0) {
1145             return Process.THREAD_PRIORITY_LESS_FAVORABLE;
1146         } else if (pageDiff &lt;= 1) {
1147             return Process.THREAD_PRIORITY_LOWEST;
1148         } else {
1149             return Process.THREAD_PRIORITY_LOWEST;
1150         }
1151     }
1152     private int getSleepForPage(int page) {
1153         int pageDiff = getWidgetPageLoadPriority(page);
1154         return Math.max(0, pageDiff * sPageSleepDelay);
1155     }
1156     /**
1157      * Creates and executes a new AsyncTask to load a page of widget previews.
1158      */
1159     private void prepareLoadWidgetPreviewsTask(int page, ArrayList&lt;Object&gt; widgets,
1160             int cellWidth, int cellHeight, int cellCountX) {
1161 
1162         // Prune all tasks that are no longer needed
1163         Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1164         while (iter.hasNext()) {
1165             AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1166             int taskPage = task.page;
1167             if (taskPage &lt; getAssociatedLowerPageBound(mCurrentPage) ||
1168                     taskPage &gt; getAssociatedUpperPageBound(mCurrentPage)) {
1169                 task.cancel(false);
1170                 iter.remove();
1171             } else {
1172                 task.setThreadPriority(getThreadPriorityForPage(taskPage));
1173             }
1174         }
1175 
1176         // We introduce a slight delay to order the loading of side pages so that we don&#x27;t thrash
1177         final int sleepMs = getSleepForPage(page);
1178         AsyncTaskPageData pageData = new AsyncTaskPageData(page, widgets, cellWidth, cellHeight,
1179             new AsyncTaskCallback() {
1180                 @Override
1181                 public void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data) {
1182                     try {
1183                         try {
1184                             Thread.sleep(sleepMs);
1185                         } catch (Exception e) {}
1186                         loadWidgetPreviewsInBackground(task, data);
1187                     } finally {
1188                         if (task.isCancelled()) {
1189                             data.cleanup(true);
1190                         }
1191                     }
1192                 }
1193             },
1194             new AsyncTaskCallback() {
1195                 @Override
1196                 public void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data) {
1197                     mRunningTasks.remove(task);
1198                     if (task.isCancelled()) return;
1199                     // do cleanup inside onSyncWidgetPageItems
1200                     onSyncWidgetPageItems(data);
1201                 }
1202             });
1203 
1204         // Ensure that the task is appropriately prioritized and runs in parallel
1205         AppsCustomizeAsyncTask t = new AppsCustomizeAsyncTask(page,
1206                 AsyncTaskPageData.Type.LoadWidgetPreviewData);
1207         t.setThreadPriority(getThreadPriorityForPage(page));
1208         t.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, pageData);
1209         mRunningTasks.add(t);
1210     }
1211 
1212     /*
1213      * Widgets PagedView implementation
1214      */
1215     private void setupPage(PagedViewGridLayout layout) {
1216         layout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
1217                 mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
1218 
1219         // Note: We force a measure here to get around the fact that when we do layout calculations
1220         // immediately after syncing, we don&#x27;t have a proper width.
1221         int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
1222         int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
1223         layout.setMinimumWidth(getPageContentWidth());
1224         layout.measure(widthSpec, heightSpec);
1225     }
1226 
1227     private void renderDrawableToBitmap(Drawable d, Bitmap bitmap, int x, int y, int w, int h) {
1228         renderDrawableToBitmap(d, bitmap, x, y, w, h, 1f);
1229     }
1230 
1231     private void renderDrawableToBitmap(Drawable d, Bitmap bitmap, int x, int y, int w, int h,
1232             float scale) {
1233         if (bitmap != null) {
1234             Canvas c = new Canvas(bitmap);
1235             c.scale(scale, scale);
1236             Rect oldBounds = d.copyBounds();
1237             d.setBounds(x, y, x + w, y + h);
1238             d.draw(c);
1239             d.setBounds(oldBounds); // Restore the bounds
1240             c.setBitmap(null);
1241         }
1242     }
1243 
1244     private Bitmap getShortcutPreview(ResolveInfo info, int maxWidth, int maxHeight) {
1245         Bitmap tempBitmap = mCachedShortcutPreviewBitmap.get();
1246         final Canvas c = mCachedShortcutPreviewCanvas.get();
1247         if (tempBitmap == null ||
1248                 tempBitmap.getWidth() != maxWidth ||
1249                 tempBitmap.getHeight() != maxHeight) {
1250             tempBitmap = Bitmap.createBitmap(maxWidth, maxHeight, Config.ARGB_8888);
1251             mCachedShortcutPreviewBitmap.set(tempBitmap);
1252         } else {
1253             c.setBitmap(tempBitmap);
1254             c.drawColor(0, PorterDuff.Mode.CLEAR);
1255             c.setBitmap(null);
1256         }
1257         // Render the icon
1258         Drawable icon = mIconCache.getFullResIcon(info);
1259 
1260         int paddingTop =
1261                 getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_top);
1262         int paddingLeft =
1263                 getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_left);
1264         int paddingRight =
1265                 getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_right);
1266 
1267         int scaledIconWidth = (maxWidth - paddingLeft - paddingRight);
1268 
1269         renderDrawableToBitmap(
1270                 icon, tempBitmap, paddingLeft, paddingTop, scaledIconWidth, scaledIconWidth);
1271 
1272         Bitmap preview = Bitmap.createBitmap(maxWidth, maxHeight, Config.ARGB_8888);
1273         c.setBitmap(preview);
1274         Paint p = mCachedShortcutPreviewPaint.get();
1275         if (p == null) {
1276             p = new Paint();
1277             ColorMatrix colorMatrix = new ColorMatrix();
1278             colorMatrix.setSaturation(0);
1279             p.setColorFilter(new ColorMatrixColorFilter(colorMatrix));
1280             p.setAlpha((int) (255 * 0.06f));
1281             //float density = 1f;
1282             //p.setMaskFilter(new BlurMaskFilter(15*density, BlurMaskFilter.Blur.NORMAL));
1283             mCachedShortcutPreviewPaint.set(p);
1284         }
1285         c.drawBitmap(tempBitmap, 0, 0, p);
1286         c.setBitmap(null);
1287 
1288         renderDrawableToBitmap(icon, preview, 0, 0, mAppIconSize, mAppIconSize);
1289 
1290         return preview;
1291     }
1292 
1293     private Bitmap getWidgetPreview(ComponentName provider, int previewImage,
1294             int iconId, int cellHSpan, int cellVSpan, int maxWidth,
1295             int maxHeight) {
1296         // Load the preview image if possible
1297         String packageName = provider.getPackageName();
1298         if (maxWidth &lt; 0) maxWidth = Integer.MAX_VALUE;
1299         if (maxHeight &lt; 0) maxHeight = Integer.MAX_VALUE;
1300 
1301         Drawable drawable = null;
1302         if (previewImage != 0) {
1303             drawable = mPackageManager.getDrawable(packageName, previewImage, null);
1304             if (drawable == null) {
1305                 Log.w(TAG, &quot;Can&#x27;t load widget preview drawable 0x&quot; +
1306                         Integer.toHexString(previewImage) + &quot; for provider: &quot; + provider);
1307             }
1308         }
1309 
1310         int bitmapWidth;
1311         int bitmapHeight;
1312         Bitmap defaultPreview = null;
1313         boolean widgetPreviewExists = (drawable != null);
1314         if (widgetPreviewExists) {
1315             bitmapWidth = drawable.getIntrinsicWidth();
1316             bitmapHeight = drawable.getIntrinsicHeight();
1317         } else {
1318             // Generate a preview image if we couldn&#x27;t load one
1319             if (cellHSpan &lt; 1) cellHSpan = 1;
1320             if (cellVSpan &lt; 1) cellVSpan = 1;
1321 
1322             BitmapDrawable previewDrawable = (BitmapDrawable) getResources()
1323                     .getDrawable(R.drawable.widget_preview_tile);
1324             final int previewDrawableWidth = previewDrawable
1325                     .getIntrinsicWidth();
1326             final int previewDrawableHeight = previewDrawable
1327                     .getIntrinsicHeight();
1328             bitmapWidth = previewDrawableWidth * cellHSpan; // subtract 2 dips
1329             bitmapHeight = previewDrawableHeight * cellVSpan;
1330 
1331             defaultPreview = Bitmap.createBitmap(bitmapWidth, bitmapHeight,
1332                     Config.ARGB_8888);
1333             final Canvas c = mCachedAppWidgetPreviewCanvas.get();
1334             c.setBitmap(defaultPreview);
1335             previewDrawable.setBounds(0, 0, bitmapWidth, bitmapHeight);
1336             previewDrawable.setTileModeXY(Shader.TileMode.REPEAT,
1337                     Shader.TileMode.REPEAT);
1338             previewDrawable.draw(c);
1339             c.setBitmap(null);
1340 
1341             // Draw the icon in the top left corner
1342             int minOffset = (int) (mAppIconSize * sWidgetPreviewIconPaddingPercentage);
1343             int smallestSide = Math.min(bitmapWidth, bitmapHeight);
1344             float iconScale = Math.min((float) smallestSide
1345                     / (mAppIconSize + 2 * minOffset), 1f);
1346 
1347             try {
1348                 Drawable icon = null;
1349                 int hoffset =
1350                         (int) ((previewDrawableWidth - mAppIconSize * iconScale) / 2);
1351                 int yoffset =
1352                         (int) ((previewDrawableHeight - mAppIconSize * iconScale) / 2);
1353                 if (iconId &gt; 0)
1354                     icon = mIconCache.getFullResIcon(packageName, iconId);
1355                 if (icon != null) {
1356                     renderDrawableToBitmap(icon, defaultPreview, hoffset,
1357                             yoffset, (int) (mAppIconSize * iconScale),
1358                             (int) (mAppIconSize * iconScale));
1359                 }
1360             } catch (Resources.NotFoundException e) {
1361             }
1362         }
1363 
1364         // Scale to fit width only - let the widget preview be clipped in the
1365         // vertical dimension
1366         float scale = 1f;
1367         if (bitmapWidth &gt; maxWidth) {
1368             scale = maxWidth / (float) bitmapWidth;
1369         }
1370         if (scale != 1f) {
1371             bitmapWidth = (int) (scale * bitmapWidth);
1372             bitmapHeight = (int) (scale * bitmapHeight);
1373         }
1374 
1375         Bitmap preview = Bitmap.createBitmap(bitmapWidth, bitmapHeight,
1376                 Config.ARGB_8888);
1377 
1378         // Draw the scaled preview into the final bitmap
1379         if (widgetPreviewExists) {
1380             renderDrawableToBitmap(drawable, preview, 0, 0, bitmapWidth,
1381                     bitmapHeight);
1382         } else {
1383             final Canvas c = mCachedAppWidgetPreviewCanvas.get();
1384             final Rect src = mCachedAppWidgetPreviewSrcRect.get();
1385             final Rect dest = mCachedAppWidgetPreviewDestRect.get();
1386             c.setBitmap(preview);
1387             src.set(0, 0, defaultPreview.getWidth(), defaultPreview.getHeight());
1388             dest.set(0, 0, preview.getWidth(), preview.getHeight());
1389 
1390             Paint p = mCachedAppWidgetPreviewPaint.get();
1391             if (p == null) {
1392                 p = new Paint();
1393                 p.setFilterBitmap(true);
1394                 mCachedAppWidgetPreviewPaint.set(p);
1395             }
1396             c.drawBitmap(defaultPreview, src, dest, p);
1397             c.setBitmap(null);
1398         }
1399         return preview;
1400     }
1401 
1402     public void syncWidgetPageItems(final int page, final boolean immediate) {
1403         int numItemsPerPage = mWidgetCountX * mWidgetCountY;
1404 
1405         // Calculate the dimensions of each cell we are giving to each widget
1406         final ArrayList&lt;Object&gt; items = new ArrayList&lt;Object&gt;();
1407         int contentWidth = mWidgetSpacingLayout.getContentWidth();
1408         final int cellWidth = ((contentWidth - mPageLayoutPaddingLeft - mPageLayoutPaddingRight
1409                 - ((mWidgetCountX - 1) * mWidgetWidthGap)) / mWidgetCountX);
1410         int contentHeight = mWidgetSpacingLayout.getContentHeight();
1411         final int cellHeight = ((contentHeight - mPageLayoutPaddingTop - mPageLayoutPaddingBottom
1412                 - ((mWidgetCountY - 1) * mWidgetHeightGap)) / mWidgetCountY);
1413 
1414         // Prepare the set of widgets to load previews for in the background
1415         int offset = (page - mNumAppsPages) * numItemsPerPage;
1416         for (int i = offset; i &lt; Math.min(offset + numItemsPerPage, mWidgets.size()); ++i) {
1417             items.add(mWidgets.get(i));
1418         }
1419 
1420         // Prepopulate the pages with the other widget info, and fill in the previews later
1421         final PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(page);
1422         layout.setColumnCount(layout.getCellCountX());
1423         for (int i = 0; i &lt; items.size(); ++i) {
1424             Object rawInfo = items.get(i);
1425             PendingAddItemInfo createItemInfo = null;
1426             PagedViewWidget widget = (PagedViewWidget) mLayoutInflater.inflate(
1427                     R.layout.apps_customize_widget, layout, false);
1428             if (rawInfo instanceof AppWidgetProviderInfo) {
1429                 // Fill in the widget information
1430                 AppWidgetProviderInfo info = (AppWidgetProviderInfo) rawInfo;
1431                 createItemInfo = new PendingAddWidgetInfo(info, null, null);
1432 
1433                 // Determine the widget spans and min resize spans.
1434                 int[] spanXY = Launcher.getSpanForWidget(mLauncher, info);
1435                 createItemInfo.spanX = spanXY[0];
1436                 createItemInfo.spanY = spanXY[1];
1437                 int[] minSpanXY = Launcher.getMinSpanForWidget(mLauncher, info);
1438                 createItemInfo.minSpanX = minSpanXY[0];
1439                 createItemInfo.minSpanY = minSpanXY[1];
1440 
1441                 widget.applyFromAppWidgetProviderInfo(info, -1, spanXY);
1442                 widget.setTag(createItemInfo);
1443                 widget.setShortPressListener(this);
1444             } else if (rawInfo instanceof ResolveInfo) {
1445                 // Fill in the shortcuts information
1446                 ResolveInfo info = (ResolveInfo) rawInfo;
1447                 createItemInfo = new PendingAddShortcutInfo(info.activityInfo);
1448                 createItemInfo.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
1449                 createItemInfo.componentName = new ComponentName(info.activityInfo.packageName,
1450                         info.activityInfo.name);
1451                 widget.applyFromResolveInfo(mPackageManager, info);
1452                 widget.setTag(createItemInfo);
1453             }
1454             widget.setOnClickListener(this);
1455             widget.setOnLongClickListener(this);
1456             widget.setOnTouchListener(this);
1457             widget.setOnKeyListener(this);
1458 
1459             // Layout each widget
1460             int ix = i % mWidgetCountX;
1461             int iy = i / mWidgetCountX;
1462             GridLayout.LayoutParams lp = new GridLayout.LayoutParams(
1463                     GridLayout.spec(iy, GridLayout.LEFT),
1464                     GridLayout.spec(ix, GridLayout.TOP));
1465             lp.width = cellWidth;
1466             lp.height = cellHeight;
1467             lp.setGravity(Gravity.TOP | Gravity.LEFT);
1468             if (ix &gt; 0) lp.leftMargin = mWidgetWidthGap;
1469             if (iy &gt; 0) lp.topMargin = mWidgetHeightGap;
1470             layout.addView(widget, lp);
1471         }
1472 
1473         // wait until a call on onLayout to start loading, because
1474         // PagedViewWidget.getPreviewSize() will return 0 if it hasn&#x27;t been laid out
1475         // TODO: can we do a measure/layout immediately?
1476         layout.setOnLayoutListener(new Runnable() {
1477             public void run() {
1478                 // Load the widget previews
1479                 int maxPreviewWidth = cellWidth;
1480                 int maxPreviewHeight = cellHeight;
1481                 if (layout.getChildCount() &gt; 0) {
1482                     PagedViewWidget w = (PagedViewWidget) layout.getChildAt(0);
1483                     int[] maxSize = w.getPreviewSize();
1484                     maxPreviewWidth = maxSize[0];
1485                     maxPreviewHeight = maxSize[1];
1486                 }
1487                 if (immediate) {
1488                     AsyncTaskPageData data = new AsyncTaskPageData(page, items,
1489                             maxPreviewWidth, maxPreviewHeight, null, null);
1490                     loadWidgetPreviewsInBackground(null, data);
1491                     onSyncWidgetPageItems(data);
1492                 } else {
1493                     if (mInTransition) {
1494                         mDeferredPrepareLoadWidgetPreviewsTasks.add(this);
1495                     } else {
1496                         prepareLoadWidgetPreviewsTask(page, items,
1497                                 maxPreviewWidth, maxPreviewHeight, mWidgetCountX);
1498                     }
1499                 }
1500             }
1501         });
1502     }
1503     private void loadWidgetPreviewsInBackground(AppsCustomizeAsyncTask task,
1504             AsyncTaskPageData data) {
1505         // loadWidgetPreviewsInBackground can be called without a task to load a set of widget
1506         // previews synchronously
1507         if (task != null) {
1508             // Ensure that this task starts running at the correct priority
1509             task.syncThreadPriority();
1510         }
1511 
1512         // Load each of the widget/shortcut previews
1513         ArrayList&lt;Object&gt; items = data.items;
1514         ArrayList&lt;Bitmap&gt; images = data.generatedImages;
1515         int count = items.size();
1516         for (int i = 0; i &lt; count; ++i) {
1517             if (task != null) {
1518                 // Ensure we haven&#x27;t been cancelled yet
1519                 if (task.isCancelled()) break;
1520                 // Before work on each item, ensure that this task is running at the correct
1521                 // priority
1522                 task.syncThreadPriority();
1523             }
1524 
1525             Object rawInfo = items.get(i);
1526             if (rawInfo instanceof AppWidgetProviderInfo) {
1527                 AppWidgetProviderInfo info = (AppWidgetProviderInfo) rawInfo;
1528                 int[] cellSpans = Launcher.getSpanForWidget(mLauncher, info);
1529 
1530                 int maxWidth = Math.min(data.maxImageWidth,
1531                         mWidgetSpacingLayout.estimateCellWidth(cellSpans[0]));
1532                 int maxHeight = Math.min(data.maxImageHeight,
1533                         mWidgetSpacingLayout.estimateCellHeight(cellSpans[1]));
1534                 Bitmap b = getWidgetPreview(info.provider, info.previewImage, info.icon,
1535                         cellSpans[0], cellSpans[1], maxWidth, maxHeight);
1536                 images.add(b);
1537             } else if (rawInfo instanceof ResolveInfo) {
1538                 // Fill in the shortcuts information
1539                 ResolveInfo info = (ResolveInfo) rawInfo;
1540                 images.add(getShortcutPreview(info, data.maxImageWidth, data.maxImageHeight));
1541             }
1542         }
1543     }
1544 
1545     private void onSyncWidgetPageItems(AsyncTaskPageData data) {
1546         if (mInTransition) {
1547             mDeferredSyncWidgetPageItems.add(data);
1548             return;
1549         }
1550         try {
1551             int page = data.page;
1552             PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(page);
1553 
1554             ArrayList&lt;Object&gt; items = data.items;
1555             int count = items.size();
1556             for (int i = 0; i &lt; count; ++i) {
1557                 PagedViewWidget widget = (PagedViewWidget) layout.getChildAt(i);
1558                 if (widget != null) {
1559                     Bitmap preview = data.generatedImages.get(i);
1560                     widget.applyPreview(new FastBitmapDrawable(preview), i);
1561                 }
1562             }
1563 
1564             layout.createHardwareLayer();
1565             invalidate();
1566 
1567             // Update all thread priorities
1568             Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1569             while (iter.hasNext()) {
1570                 AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1571                 int pageIndex = task.page;
1572                 task.setThreadPriority(getThreadPriorityForPage(pageIndex));
1573             }
1574         } finally {
1575             data.cleanup(false);
1576         }
1577     }
1578 
1579     @Override
1580     public void syncPages() {
1581         removeAllViews();
1582         cancelAllTasks();
1583 
1584         Context context = getContext();
1585         for (int j = 0; j &lt; mNumWidgetPages; ++j) {
1586             PagedViewGridLayout layout = new PagedViewGridLayout(context, mWidgetCountX,
1587                     mWidgetCountY);
1588             setupPage(layout);
1589             addView(layout, new PagedView.LayoutParams(LayoutParams.MATCH_PARENT,
1590                     LayoutParams.MATCH_PARENT));
1591         }
1592 
1593         for (int i = 0; i &lt; mNumAppsPages; ++i) {
1594             PagedViewCellLayout layout = new PagedViewCellLayout(context);
1595             setupPage(layout);
1596             addView(layout);
1597         }
1598     }
1599 
1600     @Override
1601     public void syncPageItems(int page, boolean immediate) {
1602         if (page &lt; mNumAppsPages) {
1603             syncAppsPageItems(page, immediate);
1604         } else {
1605             syncWidgetPageItems(page, immediate);
1606         }
1607     }
1608 
1609     // We want our pages to be z-ordered such that the further a page is to the left, the higher
1610     // it is in the z-order. This is important to insure touch events are handled correctly.
1611     View getPageAt(int index) {
1612         return getChildAt(indexToPage(index));
1613     }
1614 
1615     @Override
1616     protected int indexToPage(int index) {
1617         return getChildCount() - index - 1;
1618     }
1619 
1620     // In apps customize, we have a scrolling effect which emulates pulling cards off of a stack.
1621     @Override
1622     protected void screenScrolled(int screenCenter) {
1623         super.screenScrolled(screenCenter);
1624 
1625         for (int i = 0; i &lt; getChildCount(); i++) {
1626             View v = getPageAt(i);
1627             if (v != null) {
1628                 float scrollProgress = getScrollProgress(screenCenter, v, i);
1629 
1630                 float interpolatedProgress =
1631                         mZInterpolator.getInterpolation(Math.abs(Math.min(scrollProgress, 0)));
1632                 float scale = (1 - interpolatedProgress) +
1633                         interpolatedProgress * TRANSITION_SCALE_FACTOR;
1634                 float translationX = Math.min(0, scrollProgress) * v.getMeasuredWidth();
1635 
1636                 float alpha;
1637 
1638                 if (scrollProgress &lt; 0) {
1639                     alpha = scrollProgress &lt; 0 ? mAlphaInterpolator.getInterpolation(
1640                         1 - Math.abs(scrollProgress)) : 1.0f;
1641                 } else {
1642                     // On large screens we need to fade the page as it nears its leftmost position
1643                     alpha = mLeftScreenAlphaInterpolator.getInterpolation(1 - scrollProgress);
1644                 }
1645 
1646                 v.setCameraDistance(mDensity * CAMERA_DISTANCE);
1647                 int pageWidth = v.getMeasuredWidth();
1648                 int pageHeight = v.getMeasuredHeight();
1649 
1650                 if (PERFORM_OVERSCROLL_ROTATION) {
1651                     if (i == 0 &amp;&amp; scrollProgress &lt; 0) {
1652                         // Overscroll to the left
1653                         v.setPivotX(TRANSITION_PIVOT * pageWidth);
1654                         v.setRotationY(-TRANSITION_MAX_ROTATION * scrollProgress);
1655                         scale = 1.0f;
1656                         alpha = 1.0f;
1657                         // On the first page, we don&#x27;t want the page to have any lateral motion
1658                         translationX = 0;
1659                     } else if (i == getChildCount() - 1 &amp;&amp; scrollProgress &gt; 0) {
1660                         // Overscroll to the right
1661                         v.setPivotX((1 - TRANSITION_PIVOT) * pageWidth);
1662                         v.setRotationY(-TRANSITION_MAX_ROTATION * scrollProgress);
1663                         scale = 1.0f;
1664                         alpha = 1.0f;
1665                         // On the last page, we don&#x27;t want the page to have any lateral motion.
1666                         translationX = 0;
1667                     } else {
1668                         v.setPivotY(pageHeight / 2.0f);
1669                         v.setPivotX(pageWidth / 2.0f);
1670                         v.setRotationY(0f);
1671                     }
1672                 }
1673 
1674                 v.setTranslationX(translationX);
1675                 v.setScaleX(scale);
1676                 v.setScaleY(scale);
1677                 v.setAlpha(alpha);
1678 
1679                 // If the view has 0 alpha, we set it to be invisible so as to prevent
1680                 // it from accepting touches
1681                 if (alpha == 0) {
1682                     v.setVisibility(INVISIBLE);
1683                 } else if (v.getVisibility() != VISIBLE) {
1684                     v.setVisibility(VISIBLE);
1685                 }
1686             }
1687         }
1688     }
1689 
1690     protected void overScroll(float amount) {
1691         acceleratedOverScroll(amount);
1692     }
1693 
1694     /**
1695      * Used by the parent to get the content width to set the tab bar to
1696      * @return
1697      */
1698     public int getPageContentWidth() {
1699         return mContentWidth;
1700     }
1701 
1702     @Override
1703     protected void onPageEndMoving() {
1704         super.onPageEndMoving();
1705         mForceDrawAllChildrenNextFrame = true;
1706         // We reset the save index when we change pages so that it will be recalculated on next
1707         // rotation
1708         mSaveInstanceStateItemIndex = -1;
1709     }
1710 
1711     /*
1712      * AllAppsView implementation
1713      */
1714     public void setup(Launcher launcher, DragController dragController) {
1715         mLauncher = launcher;
1716         mDragController = dragController;
1717     }
1718 
1719     /**
1720      * We should call thise method whenever the core data changes (mApps, mWidgets) so that we can
1721      * appropriately determine when to invalidate the PagedView page data.  In cases where the data
1722      * has yet to be set, we can requestLayout() and wait for onDataReady() to be called in the
1723      * next onMeasure() pass, which will trigger an invalidatePageData() itself.
1724      */
1725     private void invalidateOnDataChange() {
1726         if (!isDataReady()) {
1727             // The next layout pass will trigger data-ready if both widgets and apps are set, so
1728             // request a layout to trigger the page data when ready.
1729             requestLayout();
1730         } else {
1731             cancelAllTasks();
1732             invalidatePageData();
1733         }
1734     }
1735 
1736     public void setApps(ArrayList&lt;ApplicationInfo&gt; list) {
1737         mApps = list;
1738         Collections.sort(mApps, LauncherModel.APP_NAME_COMPARATOR);
1739         updatePageCounts();
1740         invalidateOnDataChange();
1741     }
1742     private void addAppsWithoutInvalidate(ArrayList&lt;ApplicationInfo&gt; list) {
1743         // We add it in place, in alphabetical order
1744         int count = list.size();
1745         for (int i = 0; i &lt; count; ++i) {
1746             ApplicationInfo info = list.get(i);
1747             int index = Collections.binarySearch(mApps, info, LauncherModel.APP_NAME_COMPARATOR);
1748             if (index &lt; 0) {
1749                 mApps.add(-(index + 1), info);
1750             }
1751         }
1752     }
1753     public void addApps(ArrayList&lt;ApplicationInfo&gt; list) {
1754         addAppsWithoutInvalidate(list);
1755         updatePageCounts();
1756         invalidateOnDataChange();
1757     }
1758     private int findAppByComponent(List&lt;ApplicationInfo&gt; list, ApplicationInfo item) {
1759         ComponentName removeComponent = item.intent.getComponent();
1760         int length = list.size();
1761         for (int i = 0; i &lt; length; ++i) {
1762             ApplicationInfo info = list.get(i);
1763             if (info.intent.getComponent().equals(removeComponent)) {
1764                 return i;
1765             }
1766         }
1767         return -1;
1768     }
1769     private int findAppByPackage(List&lt;ApplicationInfo&gt; list, String packageName) {
1770         int length = list.size();
1771         for (int i = 0; i &lt; length; ++i) {
1772             ApplicationInfo info = list.get(i);
1773             if (ItemInfo.getPackageName(info.intent).equals(packageName)) {
1774                 return i;
1775             }
1776         }
1777         return -1;
1778     }
1779     private void removeAppsWithoutInvalidate(ArrayList&lt;ApplicationInfo&gt; list) {
1780         // loop through all the apps and remove apps that have the same component
1781         int length = list.size();
1782         for (int i = 0; i &lt; length; ++i) {
1783             ApplicationInfo info = list.get(i);
1784             int removeIndex = findAppByComponent(mApps, info);
1785             if (removeIndex &gt; -1) {
1786                 mApps.remove(removeIndex);
1787             }
1788         }
1789     }
1790     private void removeAppsWithPackageNameWithoutInvalidate(ArrayList&lt;String&gt; packageNames) {
1791         // loop through all the package names and remove apps that have the same package name
1792         for (String pn : packageNames) {
1793             int removeIndex = findAppByPackage(mApps, pn);
1794             while (removeIndex &gt; -1) {
1795                 mApps.remove(removeIndex);
1796                 removeIndex = findAppByPackage(mApps, pn);
1797             }
1798         }
1799     }
1800     public void removeApps(ArrayList&lt;String&gt; packageNames) {
1801         removeAppsWithPackageNameWithoutInvalidate(packageNames);
1802         updatePageCounts();
1803         invalidateOnDataChange();
1804     }
1805     public void updateApps(ArrayList&lt;ApplicationInfo&gt; list) {
1806         // We remove and re-add the updated applications list because it&#x27;s properties may have
1807         // changed (ie. the title), and this will ensure that the items will be in their proper
1808         // place in the list.
1809         removeAppsWithoutInvalidate(list);
1810         addAppsWithoutInvalidate(list);
1811         updatePageCounts();
1812         invalidateOnDataChange();
1813     }
1814 
1815     public void reset() {
1816         // If we have reset, then we should not continue to restore the previous state
1817         mSaveInstanceStateItemIndex = -1;
1818 
1819         AppsCustomizeTabHost tabHost = getTabHost();
1820         String tag = tabHost.getCurrentTabTag();
1821         if (tag != null) {
1822             if (!tag.equals(tabHost.getTabTagForContentType(ContentType.Applications))) {
1823                 tabHost.setCurrentTabFromContent(ContentType.Applications);
1824             }
1825         }
1826 
1827         if (mCurrentPage != 0) {
1828             invalidatePageData(0);
1829         }
1830     }
1831 
1832     private AppsCustomizeTabHost getTabHost() {
1833         return (AppsCustomizeTabHost) mLauncher.findViewById(R.id.apps_customize_pane);
1834     }
1835 
1836     public void dumpState() {
1837         // TODO: Dump information related to current list of Applications, Widgets, etc.
1838         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mApps&quot;, mApps);
1839         dumpAppWidgetProviderInfoList(TAG, &quot;mWidgets&quot;, mWidgets);
1840     }
1841 
1842     private void dumpAppWidgetProviderInfoList(String tag, String label,
1843             ArrayList&lt;Object&gt; list) {
1844         Log.d(tag, label + &quot; size=&quot; + list.size());
1845         for (Object i: list) {
1846             if (i instanceof AppWidgetProviderInfo) {
1847                 AppWidgetProviderInfo info = (AppWidgetProviderInfo) i;
1848                 Log.d(tag, &quot;   label=\&quot;&quot; + info.label + &quot;\&quot; previewImage=&quot; + info.previewImage
1849                         + &quot; resizeMode=&quot; + info.resizeMode + &quot; configure=&quot; + info.configure
1850                         + &quot; initialLayout=&quot; + info.initialLayout
1851                         + &quot; minWidth=&quot; + info.minWidth + &quot; minHeight=&quot; + info.minHeight);
1852             } else if (i instanceof ResolveInfo) {
1853                 ResolveInfo info = (ResolveInfo) i;
1854                 Log.d(tag, &quot;   label=\&quot;&quot; + info.loadLabel(mPackageManager) + &quot;\&quot; icon=&quot;
1855                         + info.icon);
1856             }
1857         }
1858     }
1859 
1860     public void surrender() {
1861         // TODO: If we are in the middle of any process (ie. for holographic outlines, etc) we
1862         // should stop this now.
1863 
1864         // Stop all background tasks
1865         cancelAllTasks();
1866     }
1867 
1868     @Override
1869     public void iconPressed(PagedViewIcon icon) {
1870         // Reset the previously pressed icon and store a reference to the pressed icon so that
1871         // we can reset it on return to Launcher (in Launcher.onResume())
1872         if (mPressedIcon != null) {
1873             mPressedIcon.resetDrawableState();
1874         }
1875         mPressedIcon = icon;
1876     }
1877 
1878     public void resetDrawableState() {
1879         if (mPressedIcon != null) {
1880             mPressedIcon.resetDrawableState();
1881             mPressedIcon = null;
1882         }
1883     }
1884 
1885     /*
1886      * We load an extra page on each side to prevent flashes from scrolling and loading of the
1887      * widget previews in the background with the AsyncTasks.
1888      */
1889     final static int sLookBehindPageCount = 2;
1890     final static int sLookAheadPageCount = 2;
1891     protected int getAssociatedLowerPageBound(int page) {
1892         final int count = getChildCount();
1893         int windowSize = Math.min(count, sLookBehindPageCount + sLookAheadPageCount + 1);
1894         int windowMinIndex = Math.max(Math.min(page - sLookBehindPageCount, count - windowSize), 0);
1895         return windowMinIndex;
1896     }
1897     protected int getAssociatedUpperPageBound(int page) {
1898         final int count = getChildCount();
1899         int windowSize = Math.min(count, sLookBehindPageCount + sLookAheadPageCount + 1);
1900         int windowMaxIndex = Math.min(Math.max(page + sLookAheadPageCount, windowSize - 1),
1901                 count - 1);
1902         return windowMaxIndex;
1903     }
1904 
1905     @Override
1906     protected String getCurrentPageDescription() {
1907         int page = (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
1908         int stringId = R.string.default_scroll_format;
1909         int count = 0;
1910         
1911         if (page &lt; mNumAppsPages) {
1912             stringId = R.string.apps_customize_apps_scroll_format;
1913             count = mNumAppsPages;
1914         } else {
1915             page -= mNumAppsPages;
1916             stringId = R.string.apps_customize_widgets_scroll_format;
1917             count = mNumWidgetPages;
1918         }
1919 
1920         return String.format(getContext().getString(stringId), page + 1, count);
1921     }
1922 }
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2011 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher2;
  18 
  19 import android.animation.AnimatorSet;
  20 import android.animation.ValueAnimator;
  21 import android.appwidget.AppWidgetHostView;
  22 import android.appwidget.AppWidgetManager;
  23 import android.appwidget.AppWidgetProviderInfo;
  24 import android.content.ComponentName;
  25 import android.content.Context;
  26 import android.content.Intent;
  27 import android.content.pm.PackageManager;
  28 import android.content.pm.ResolveInfo;
  29 import android.content.res.Configuration;
  30 import android.content.res.Resources;
  31 import android.content.res.TypedArray;
  32 import android.graphics.Bitmap;
  33 import android.graphics.Bitmap.Config;
  34 import android.graphics.Canvas;
  35 import android.graphics.ColorMatrix;
  36 import android.graphics.ColorMatrixColorFilter;
  37 import android.graphics.Matrix;
  38 import android.graphics.Paint;
  39 import android.graphics.PorterDuff;
  40 import android.graphics.Rect;
  41 import android.graphics.RectF;
  42 import android.graphics.Shader;
  43 import android.graphics.drawable.BitmapDrawable;
  44 import android.graphics.drawable.Drawable;
  45 import android.os.AsyncTask;
  46 import android.os.Process;
  47 import android.util.AttributeSet;
  48 import android.util.Log;
  49 import android.view.Gravity;
  50 import android.view.KeyEvent;
  51 import android.view.LayoutInflater;
  52 import android.view.MotionEvent;
  53 import android.view.View;
  54 import android.view.ViewGroup;
  55 import android.view.animation.AccelerateInterpolator;
  56 import android.view.animation.DecelerateInterpolator;
  57 import android.widget.GridLayout;
  58 import android.widget.ImageView;
  59 import android.widget.Toast;
  60 
  61 import com.android.launcher.R;
  62 import com.android.launcher2.DropTarget.DragObject;
  63 import java.util.ArrayList;
  64 import java.util.Collections;
  65 import java.util.Iterator;
  66 import java.util.List;
  67 
  68 import java.lang.ref.WeakReference;
  69 
  70 /**
  71  * A simple callback interface which also provides the results of the task.
  72  */
  73 
  74 
  75 /**
  76  * A simple callback interface which also provides the results of the task.
  77  */
  78 interface AsyncTaskCallback {
  79     void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data);
  80 }
  81 
  82 /**
  83  * The data needed to perform either of the custom AsyncTasks.
  84  */
  85 
  86 
  87 /**
  88  * The data needed to perform either of the custom AsyncTasks.
  89  */
  90 class AsyncTaskPageData {
  91     enum Type {
  92         LoadWidgetPreviewData
  93     }
  94 
  95     AsyncTaskPageData(int p, ArrayList&lt;Object&gt; l, ArrayList&lt;Bitmap&gt; si, AsyncTaskCallback bgR,
  96             AsyncTaskCallback postR) {
  97         page = p;
  98         items = l;
  99         sourceImages = si;
 100         generatedImages = new ArrayList&lt;Bitmap&gt;();
 101         maxImageWidth = maxImageHeight = -1;
 102         doInBackgroundCallback = bgR;
 103         postExecuteCallback = postR;
 104     }
 105     AsyncTaskPageData(int p, ArrayList&lt;Object&gt; l, int cw, int ch, AsyncTaskCallback bgR,
 106             AsyncTaskCallback postR) {
 107         page = p;
 108         items = l;
 109         generatedImages = new ArrayList&lt;Bitmap&gt;();
 110         maxImageWidth = cw;
 111         maxImageHeight = ch;
 112         doInBackgroundCallback = bgR;
 113         postExecuteCallback = postR;
 114     }
 115     void cleanup(boolean cancelled) {
 116         // Clean up any references to source/generated bitmaps
 117         if (sourceImages != null) {
 118             if (cancelled) {
 119                 for (Bitmap b : sourceImages) {
 120                     b.recycle();
 121                 }
 122             }
 123             sourceImages.clear();
 124         }
 125         if (generatedImages != null) {
 126             if (cancelled) {
 127                 for (Bitmap b : generatedImages) {
 128                     b.recycle();
 129                 }
 130             }
 131             generatedImages.clear();
 132         }
 133     }
 134     int page;
 135     ArrayList&lt;Object&gt; items;
 136     ArrayList&lt;Bitmap&gt; sourceImages;
 137     ArrayList&lt;Bitmap&gt; generatedImages;
 138     int maxImageWidth;
 139     int maxImageHeight;
 140     AsyncTaskCallback doInBackgroundCallback;
 141     AsyncTaskCallback postExecuteCallback;
 142 }
 143 
 144 /**
 145  * A generic template for an async task used in AppsCustomize.
 146  */
 147 
 148 
 149 /**
 150  * A generic template for an async task used in AppsCustomize.
 151  */
 152 class AppsCustomizeAsyncTask extends AsyncTask&lt;AsyncTaskPageData, Void, AsyncTaskPageData&gt; {
 153     AppsCustomizeAsyncTask(int p, AsyncTaskPageData.Type ty) {
 154         page = p;
 155         threadPriority = Process.THREAD_PRIORITY_DEFAULT;
 156         dataType = ty;
 157     }
 158     @Override
 159     protected AsyncTaskPageData doInBackground(AsyncTaskPageData... params) {
 160         if (params.length != 1) return null;
 161         // Load each of the widget previews in the background
 162         params[0].doInBackgroundCallback.run(this, params[0]);
 163         return params[0];
 164     }
 165     @Override
 166     protected void onPostExecute(AsyncTaskPageData result) {
 167         // All the widget previews are loaded, so we can just callback to inflate the page
 168         result.postExecuteCallback.run(this, result);
 169     }
 170 
 171     void setThreadPriority(int p) {
 172         threadPriority = p;
 173     }
 174     void syncThreadPriority() {
 175         Process.setThreadPriority(threadPriority);
 176     }
 177 
 178     // The page that this async task is associated with
 179     AsyncTaskPageData.Type dataType;
 180     int page;
 181     int threadPriority;
 182 }
 183 
 184 abstract class WeakReferenceThreadLocal&lt;T&gt; {
 185     private ThreadLocal&lt;WeakReference&lt;T&gt;&gt; mThreadLocal;
 186     public WeakReferenceThreadLocal() {
 187         mThreadLocal = new ThreadLocal&lt;WeakReference&lt;T&gt;&gt;();
 188     }
 189     @Override
 190     protected Paint initialValue() {
 191         return null;
 192     }
 193 
 194     public void set(T t) {
 195         mThreadLocal.set(new WeakReference&lt;T&gt;(t));
 196     }
 197 
 198     public T get() {
 199         WeakReference&lt;T&gt; reference = mThreadLocal.get();
 200         T obj;
 201         if (reference == null) {
 202             obj = initialValue();
 203             mThreadLocal.set(new WeakReference&lt;T&gt;(obj));
 204             return obj;
 205         } else {
 206             obj = reference.get();
 207             if (obj == null) {
 208                 obj = initialValue();
 209                 mThreadLocal.set(new WeakReference&lt;T&gt;(obj));
 210             }
 211             return obj;
 212         }
 213     }
 214 }
 215 
 216 class CanvasCache extends WeakReferenceThreadLocal&lt;Canvas&gt; {
 217     @Override
 218     protected Canvas initialValue() {
 219         return new Canvas();
 220     }
 221 }
 222 
 223 class PaintCache extends WeakReferenceThreadLocal&lt;Paint&gt; {
 224     @Override
 225     protected Paint initialValue() {
 226         return null;
 227     }
 228 }
 229 
 230 class BitmapCache extends WeakReferenceThreadLocal&lt;Bitmap&gt; {
 231     @Override
 232     protected Bitmap initialValue() {
 233         return null;
 234     }
 235 }
 236 
 237 class RectCache extends WeakReferenceThreadLocal&lt;Rect&gt; {
 238     @Override
 239     protected Rect initialValue() {
 240         return new Rect();
 241     }
 242 }
 243 
 244 /**
 245  * The Apps/Customize page that displays all the applications, widgets, and shortcuts.
 246  */
 247 public class AppsCustomizePagedView extends PagedViewWithDraggableItems implements
 248         View.OnClickListener, View.OnKeyListener, DragSource,
 249         PagedViewIcon.PressedCallback, PagedViewWidget.ShortPressListener,
 250         LauncherTransitionable {
 251     static final String TAG = &quot;AppsCustomizePagedView&quot;;
 252 
 253     /**
 254      * The different content types that this paged view can show.
 255      */
 256     public enum ContentType {
 257         Applications,
 258         Widgets
 259     }
 260 
 261     // Refs
 262     private Launcher mLauncher;
 263     private DragController mDragController;
 264     private final LayoutInflater mLayoutInflater;
 265     private final PackageManager mPackageManager;
 266 
 267     // Save and Restore
 268     private int mSaveInstanceStateItemIndex = -1;
 269     private PagedViewIcon mPressedIcon;
 270 
 271     // Content
 272     private ArrayList&lt;ApplicationInfo&gt; mApps;
 273     private ArrayList&lt;Object&gt; mWidgets;
 274 
 275     // Cling
 276     private boolean mHasShownAllAppsCling;
 277     private int mClingFocusedX;
 278     private int mClingFocusedY;
 279 
 280     // Caching
 281     private Canvas mCanvas;
 282     private IconCache mIconCache;
 283 
 284     // Dimens
 285     private int mContentWidth;
 286     private int mAppIconSize;
 287     private int mMaxAppCellCountX, mMaxAppCellCountY;
 288     private int mWidgetCountX, mWidgetCountY;
 289     private int mWidgetWidthGap, mWidgetHeightGap;
 290     private final float sWidgetPreviewIconPaddingPercentage = 0.25f;
 291     private PagedViewCellLayout mWidgetSpacingLayout;
 292     private int mNumAppsPages;
 293     private int mNumWidgetPages;
 294 
 295     // Relating to the scroll and overscroll effects
 296     Workspace.ZInterpolator mZInterpolator = new Workspace.ZInterpolator(0.5f);
 297     private static float CAMERA_DISTANCE = 6500;
 298     private static float TRANSITION_SCALE_FACTOR = 0.74f;
 299     private static float TRANSITION_PIVOT = 0.65f;
 300     private static float TRANSITION_MAX_ROTATION = 22;
 301     private static final boolean PERFORM_OVERSCROLL_ROTATION = true;
 302     private AccelerateInterpolator mAlphaInterpolator = new AccelerateInterpolator(0.9f);
 303     private DecelerateInterpolator mLeftScreenAlphaInterpolator = new DecelerateInterpolator(4);
 304 
 305     // Previews &amp; outlines
 306     ArrayList&lt;AppsCustomizeAsyncTask&gt; mRunningTasks;
 307     private static final int sPageSleepDelay = 200;
 308 
 309     private Runnable mInflateWidgetRunnable = null;
 310     private Runnable mBindWidgetRunnable = null;
 311     static final int WIDGET_NO_CLEANUP_REQUIRED = -1;
 312     static final int WIDGET_PRELOAD_PENDING = 0;
 313     static final int WIDGET_BOUND = 1;
 314     static final int WIDGET_INFLATED = 2;
 315     int mWidgetCleanupState = WIDGET_NO_CLEANUP_REQUIRED;
 316     int mWidgetLoadingId = -1;
 317     PendingAddWidgetInfo mCreateWidgetInfo = null;
 318     private boolean mDraggingWidget = false;
 319 
 320     private Toast mWidgetInstructionToast;
 321 
 322     // Deferral of loading widget previews during launcher transitions
 323     private boolean mInTransition;
 324     private ArrayList&lt;AsyncTaskPageData&gt; mDeferredSyncWidgetPageItems =
 325         new ArrayList&lt;AsyncTaskPageData&gt;();
 326     private ArrayList&lt;Runnable&gt; mDeferredPrepareLoadWidgetPreviewsTasks =
 327         new ArrayList&lt;Runnable&gt;();
 328 
 329     // Used for drawing shortcut previews
 330     BitmapCache mCachedShortcutPreviewBitmap = new BitmapCache();
 331     PaintCache mCachedShortcutPreviewPaint = new PaintCache();
 332     CanvasCache mCachedShortcutPreviewCanvas = new CanvasCache();
 333 
 334     // Used for drawing widget previews
 335     CanvasCache mCachedAppWidgetPreviewCanvas = new CanvasCache();
 336     RectCache mCachedAppWidgetPreviewSrcRect = new RectCache();
 337     RectCache mCachedAppWidgetPreviewDestRect = new RectCache();
 338     PaintCache mCachedAppWidgetPreviewPaint = new PaintCache();
 339 
 340     public AppsCustomizePagedView(Context context, AttributeSet attrs) {
 341         super(context, attrs);
 342         mLayoutInflater = LayoutInflater.from(context);
 343         mPackageManager = context.getPackageManager();
 344         mApps = new ArrayList&lt;ApplicationInfo&gt;();
 345         mWidgets = new ArrayList&lt;Object&gt;();
 346         mIconCache = ((LauncherApplication) context.getApplicationContext()).getIconCache();
 347         mCanvas = new Canvas();
 348         mRunningTasks = new ArrayList&lt;AppsCustomizeAsyncTask&gt;();
 349 
 350         // Save the default widget preview background
 351         Resources resources = context.getResources();
 352         mAppIconSize = resources.getDimensionPixelSize(R.dimen.app_icon_size);
 353 
 354         TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.AppsCustomizePagedView, 0, 0);
 355         mMaxAppCellCountX = a.getInt(R.styleable.AppsCustomizePagedView_maxAppCellCountX, -1);
 356         mMaxAppCellCountY = a.getInt(R.styleable.AppsCustomizePagedView_maxAppCellCountY, -1);
 357         mWidgetWidthGap =
 358             a.getDimensionPixelSize(R.styleable.AppsCustomizePagedView_widgetCellWidthGap, 0);
 359         mWidgetHeightGap =
 360             a.getDimensionPixelSize(R.styleable.AppsCustomizePagedView_widgetCellHeightGap, 0);
 361         mWidgetCountX = a.getInt(R.styleable.AppsCustomizePagedView_widgetCountX, 2);
 362         mWidgetCountY = a.getInt(R.styleable.AppsCustomizePagedView_widgetCountY, 2);
 363         mClingFocusedX = a.getInt(R.styleable.AppsCustomizePagedView_clingFocusedX, 0);
 364         mClingFocusedY = a.getInt(R.styleable.AppsCustomizePagedView_clingFocusedY, 0);
 365         a.recycle();
 366         mWidgetSpacingLayout = new PagedViewCellLayout(getContext());
 367 
 368         // The padding on the non-matched dimension for the default widget preview icons
 369         // (top + bottom)
 370         mFadeInAdjacentScreens = false;
 371 
 372         // Unless otherwise specified this view is important for accessibility.
 373         if (getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
 374             setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
 375         }
 376     }
 377 
 378     @Override
 379     protected void init() {
 380         super.init();
 381         mCenterPagesVertically = false;
 382 
 383         Context context = getContext();
 384         Resources r = context.getResources();
 385         setDragSlopeThreshold(r.getInteger(R.integer.config_appsCustomizeDragSlopeThreshold)/100f);
 386     }
 387 
 388     @Override
 389     protected void onUnhandledTap(MotionEvent ev) {
 390         if (LauncherApplication.isScreenLarge()) {
 391             // Dismiss AppsCustomize if we tap
 392             mLauncher.showWorkspace(true);
 393         }
 394     }
 395 
 396     /** Returns the item index of the center item on this page so that we can restore to this
 397      *  item index when we rotate. */
 398     private int getMiddleComponentIndexOnCurrentPage() {
 399         int i = -1;
 400         if (getPageCount() &gt; 0) {
 401             int currentPage = getCurrentPage();
 402             if (currentPage &lt; mNumAppsPages) {
 403                 PagedViewCellLayout layout = (PagedViewCellLayout) getPageAt(currentPage);
 404                 PagedViewCellLayoutChildren childrenLayout = layout.getChildrenLayout();
 405                 int numItemsPerPage = mCellCountX * mCellCountY;
 406                 int childCount = childrenLayout.getChildCount();
 407                 if (childCount &gt; 0) {
 408                     i = (currentPage * numItemsPerPage) + (childCount / 2);
 409                 }
 410             } else {
 411                 int numApps = mApps.size();
 412                 PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(currentPage);
 413                 int numItemsPerPage = mWidgetCountX * mWidgetCountY;
 414                 int childCount = layout.getChildCount();
 415                 if (childCount &gt; 0) {
 416                     i = numApps +
 417                         ((currentPage - mNumAppsPages) * numItemsPerPage) + (childCount / 2);
 418                 }
 419             }
 420         }
 421         return i;
 422     }
 423 
 424     /** Get the index of the item to restore to if we need to restore the current page. */
 425     int getSaveInstanceStateIndex() {
 426         if (mSaveInstanceStateItemIndex == -1) {
 427             mSaveInstanceStateItemIndex = getMiddleComponentIndexOnCurrentPage();
 428         }
 429         return mSaveInstanceStateItemIndex;
 430     }
 431 
 432     /** Returns the page in the current orientation which is expected to contain the specified
 433      *  item index. */
 434     int getPageForComponent(int index) {
 435         if (index &lt; 0) return 0;
 436 
 437         if (index &lt; mApps.size()) {
 438             int numItemsPerPage = mCellCountX * mCellCountY;
 439             return (index / numItemsPerPage);
 440         } else {
 441             int numItemsPerPage = mWidgetCountX * mWidgetCountY;
 442             return mNumAppsPages + ((index - mApps.size()) / numItemsPerPage);
 443         }
 444     }
 445 
 446     /** Restores the page for an item at the specified index */
 447     void restorePageForIndex(int index) {
 448         if (index &lt; 0) return;
 449         mSaveInstanceStateItemIndex = index;
 450     }
 451 
 452     private void updatePageCounts() {
 453         mNumWidgetPages = (int) Math.ceil(mWidgets.size() /
 454                 (float) (mWidgetCountX * mWidgetCountY));
 455         mNumAppsPages = (int) Math.ceil((float) mApps.size() / (mCellCountX * mCellCountY));
 456     }
 457 
 458     protected void onDataReady(int width, int height) {
 459         // Note that we transpose the counts in portrait so that we get a similar layout
 460         boolean isLandscape = getResources().getConfiguration().orientation ==
 461             Configuration.ORIENTATION_LANDSCAPE;
 462         int maxCellCountX = Integer.MAX_VALUE;
 463         int maxCellCountY = Integer.MAX_VALUE;
 464         if (LauncherApplication.isScreenLarge()) {
 465             maxCellCountX = (isLandscape ? LauncherModel.getCellCountX() :
 466                 LauncherModel.getCellCountY());
 467             maxCellCountY = (isLandscape ? LauncherModel.getCellCountY() :
 468                 LauncherModel.getCellCountX());
 469         }
 470         if (mMaxAppCellCountX &gt; -1) {
 471             maxCellCountX = Math.min(maxCellCountX, mMaxAppCellCountX);
 472         }
 473         if (mMaxAppCellCountY &gt; -1) {
 474             maxCellCountY = Math.min(maxCellCountY, mMaxAppCellCountY);
 475         }
 476 
 477         // Now that the data is ready, we can calculate the content width, the number of cells to
 478         // use for each page
 479         mWidgetSpacingLayout.setGap(mPageLayoutWidthGap, mPageLayoutHeightGap);
 480         mWidgetSpacingLayout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
 481                 mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
 482         mWidgetSpacingLayout.calculateCellCount(width, height, maxCellCountX, maxCellCountY);
 483         mCellCountX = mWidgetSpacingLayout.getCellCountX();
 484         mCellCountY = mWidgetSpacingLayout.getCellCountY();
 485         updatePageCounts();
 486 
 487         // Force a measure to update recalculate the gaps
 488         int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
 489         int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
 490         mWidgetSpacingLayout.measure(widthSpec, heightSpec);
 491         mContentWidth = mWidgetSpacingLayout.getContentWidth();
 492 
 493         AppsCustomizeTabHost host = (AppsCustomizeTabHost) getTabHost();
 494         final boolean hostIsTransitioning = host.isTransitioning();
 495 
 496         // Restore the page
 497         int page = getPageForComponent(mSaveInstanceStateItemIndex);
 498         invalidatePageData(Math.max(0, page), hostIsTransitioning);
 499 
 500         // Show All Apps cling if we are finished transitioning, otherwise, we will try again when
 501         // the transition completes in AppsCustomizeTabHost (otherwise the wrong offsets will be
 502         // returned while animating)
 503         if (!hostIsTransitioning) {
 504             post(new Runnable() {
 505                 @Override
 506                 public void run() {
 507                     showAllAppsCling();
 508                 }
 509             });
 510         }
 511     }
 512 
 513     void showAllAppsCling() {
 514         if (!mHasShownAllAppsCling &amp;&amp; isDataReady()) {
 515             mHasShownAllAppsCling = true;
 516             // Calculate the position for the cling punch through
 517             int[] offset = new int[2];
 518             int[] pos = mWidgetSpacingLayout.estimateCellPosition(mClingFocusedX, mClingFocusedY);
 519             mLauncher.getDragLayer().getLocationInDragLayer(this, offset);
 520             // PagedViews are centered horizontally but top aligned
 521             pos[0] += (getMeasuredWidth() - mWidgetSpacingLayout.getMeasuredWidth()) / 2 +
 522                     offset[0];
 523             pos[1] += offset[1];
 524             mLauncher.showFirstRunAllAppsCling(pos);
 525         }
 526     }
 527 
 528     @Override
 529     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 530         int width = MeasureSpec.getSize(widthMeasureSpec);
 531         int height = MeasureSpec.getSize(heightMeasureSpec);
 532         if (!isDataReady()) {
 533             if (!mApps.isEmpty() &amp;&amp; !mWidgets.isEmpty()) {
 534                 setDataIsReady();
 535                 setMeasuredDimension(width, height);
 536                 onDataReady(width, height);
 537             }
 538         }
 539 
 540         super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 541     }
 542 
 543     public void onPackagesUpdated() {
 544         // Get the list of widgets and shortcuts
 545         mWidgets.clear();
 546         List&lt;AppWidgetProviderInfo&gt; widgets =
 547             AppWidgetManager.getInstance(mLauncher).getInstalledProviders();
 548         Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
 549         List&lt;ResolveInfo&gt; shortcuts = mPackageManager.queryIntentActivities(shortcutsIntent, 0);
 550         for (AppWidgetProviderInfo widget : widgets) {
 551             if (widget.minWidth &gt; 0 &amp;&amp; widget.minHeight &gt; 0) {
 552                 // Ensure that all widgets we show can be added on a workspace of this size
 553                 int[] spanXY = Launcher.getSpanForWidget(mLauncher, widget);
 554                 int[] minSpanXY = Launcher.getMinSpanForWidget(mLauncher, widget);
 555                 int minSpanX = Math.min(spanXY[0], minSpanXY[0]);
 556                 int minSpanY = Math.min(spanXY[1], minSpanXY[1]);
 557                 if (minSpanX &lt;= LauncherModel.getCellCountX() &amp;&amp;
 558                         minSpanY &lt;= LauncherModel.getCellCountY()) {
 559                     mWidgets.add(widget);
 560                 } else {
 561                     Log.e(TAG, &quot;Widget &quot; + widget.provider + &quot; can not fit on this device (&quot; +
 562                             widget.minWidth + &quot;, &quot; + widget.minHeight + &quot;)&quot;);
 563                 }
 564             } else {
 565                 Log.e(TAG, &quot;Widget &quot; + widget.provider + &quot; has invalid dimensions (&quot; +
 566                         widget.minWidth + &quot;, &quot; + widget.minHeight + &quot;)&quot;);
 567             }
 568         }
 569         mWidgets.addAll(shortcuts);
 570         Collections.sort(mWidgets,
 571                 new LauncherModel.WidgetAndShortcutNameComparator(mPackageManager));
 572         updatePageCounts();
 573         invalidateOnDataChange();
 574     }
 575 
 576     @Override
 577     public void onClick(View v) {
 578         // When we have exited all apps or are in transition, disregard clicks
 579         if (!mLauncher.isAllAppsVisible() ||
 580                 mLauncher.getWorkspace().isSwitchingState()) return;
 581 
 582         if (v instanceof PagedViewIcon) {
 583             // Animate some feedback to the click
 584             final ApplicationInfo appInfo = (ApplicationInfo) v.getTag();
 585 
 586             // Lock the drawable state to pressed until we return to Launcher
 587             if (mPressedIcon != null) {
 588                 mPressedIcon.lockDrawableState();
 589             }
 590 
 591             // NOTE: We want all transitions from launcher to act as if the wallpaper were enabled
 592             // to be consistent.  So re-enable the flag here, and we will re-disable it as necessary
 593             // when Launcher resumes and we are still in AllApps.
 594             mLauncher.updateWallpaperVisibility(true);
 595             mLauncher.startActivitySafely(v, appInfo.intent, appInfo);
 596 
 597         } else if (v instanceof PagedViewWidget) {
 598             // Let the user know that they have to long press to add a widget
 599             if (mWidgetInstructionToast != null) {
 600                 mWidgetInstructionToast.cancel();
 601             }
 602             mWidgetInstructionToast = Toast.makeText(getContext(),R.string.long_press_widget_to_add,
 603                 Toast.LENGTH_SHORT);
 604             mWidgetInstructionToast.show();
 605 
 606             // Create a little animation to show that the widget can move
 607             float offsetY = getResources().getDimensionPixelSize(R.dimen.dragViewOffsetY);
 608             final ImageView p = (ImageView) v.findViewById(R.id.widget_preview);
 609             AnimatorSet bounce = LauncherAnimUtils.createAnimatorSet();
 610             ValueAnimator tyuAnim = LauncherAnimUtils.ofFloat(p, &quot;translationY&quot;, offsetY);
 611             tyuAnim.setDuration(125);
 612             ValueAnimator tydAnim = LauncherAnimUtils.ofFloat(p, &quot;translationY&quot;, 0f);
 613             tydAnim.setDuration(100);
 614             bounce.play(tyuAnim).before(tydAnim);
 615             bounce.setInterpolator(new AccelerateInterpolator());
 616             bounce.start();
 617         }
 618     }
 619 
 620     public boolean onKey(View v, int keyCode, KeyEvent event) {
 621         return FocusHelper.handleAppsCustomizeKeyEvent(v,  keyCode, event);
 622     }
 623 
 624     /*
 625      * PagedViewWithDraggableItems implementation
 626      */
 627     @Override
 628     protected void determineDraggingStart(android.view.MotionEvent ev) {
 629         // Disable dragging by pulling an app down for now.
 630     }
 631 
 632     private void beginDraggingApplication(View v) {
 633         mLauncher.getWorkspace().onDragStartedWithItem(v);
 634         mLauncher.getWorkspace().beginDragShared(v, this);
 635     }
 636 
 637     private void preloadWidget(final PendingAddWidgetInfo info) {
 638         final AppWidgetProviderInfo pInfo = info.info;
 639         if (pInfo.configure != null) {
 640             return;
 641         }
 642 
 643         mWidgetCleanupState = WIDGET_PRELOAD_PENDING;
 644         mBindWidgetRunnable = new Runnable() {
 645             @Override
 646             public void run() {
 647                 mWidgetLoadingId = mLauncher.getAppWidgetHost().allocateAppWidgetId();
 648                 if (AppWidgetManager.getInstance(mLauncher)
 649                             .bindAppWidgetIdIfAllowed(mWidgetLoadingId, info.componentName)) {
 650                     mWidgetCleanupState = WIDGET_BOUND;
 651                 }
 652             }
 653         };
 654         post(mBindWidgetRunnable);
 655 
 656         mInflateWidgetRunnable = new Runnable() {
 657             @Override
 658             public void run() {
 659                 AppWidgetHostView hostView = mLauncher.
 660                         getAppWidgetHost().createView(getContext(), mWidgetLoadingId, pInfo);
 661                 info.boundWidget = hostView;
 662                 mWidgetCleanupState = WIDGET_INFLATED;
 663                 hostView.setVisibility(INVISIBLE);
 664                 int[] unScaledSize = mLauncher.getWorkspace().estimateItemSize(info.spanX,
 665                         info.spanY, info, false);
 666 
 667                 // We want the first widget layout to be the correct size. This will be important
 668                 // for width size reporting to the AppWidgetManager.
 669                 DragLayer.LayoutParams lp = new DragLayer.LayoutParams(unScaledSize[0],
 670                         unScaledSize[1]);
 671                 lp.x = lp.y = 0;
 672                 lp.customPosition = true;
 673                 hostView.setLayoutParams(lp);
 674                 mLauncher.getDragLayer().addView(hostView);
 675             }
 676         };
 677         post(mInflateWidgetRunnable);
 678     }
 679 
 680     @Override
 681     public void onShortPress(View v) {
 682         // We are anticipating a long press, and we use this time to load bind and instantiate
 683         // the widget. This will need to be cleaned up if it turns out no long press occurs.
 684         if (mCreateWidgetInfo != null) {
 685             // Just in case the cleanup process wasn&#x27;t properly executed. This shouldn&#x27;t happen.
 686             cleanupWidgetPreloading(false);
 687         }
 688         mCreateWidgetInfo = new PendingAddWidgetInfo((PendingAddWidgetInfo) v.getTag());
 689         preloadWidget(mCreateWidgetInfo);
 690     }
 691 
 692     private void cleanupWidgetPreloading(boolean widgetWasAdded) {
 693         if (!widgetWasAdded) {
 694             // If the widget was not added, we may need to do further cleanup.
 695             PendingAddWidgetInfo info = mCreateWidgetInfo;
 696             mCreateWidgetInfo = null;
 697 
 698             if (mWidgetCleanupState == WIDGET_PRELOAD_PENDING) {
 699                 // We never did any preloading, so just remove pending callbacks to do so
 700                 removeCallbacks(mBindWidgetRunnable);
 701                 removeCallbacks(mInflateWidgetRunnable);
 702             } else if (mWidgetCleanupState == WIDGET_BOUND) {
 703                  // Delete the widget id which was allocated
 704                 if (mWidgetLoadingId != -1) {
 705                     mLauncher.getAppWidgetHost().deleteAppWidgetId(mWidgetLoadingId);
 706                 }
 707 
 708                 // We never got around to inflating the widget, so remove the callback to do so.
 709                 removeCallbacks(mInflateWidgetRunnable);
 710             } else if (mWidgetCleanupState == WIDGET_INFLATED) {
 711                 // Delete the widget id which was allocated
 712                 if (mWidgetLoadingId != -1) {
 713                     mLauncher.getAppWidgetHost().deleteAppWidgetId(mWidgetLoadingId);
 714                 }
 715 
 716                 // The widget was inflated and added to the DragLayer -- remove it.
 717                 AppWidgetHostView widget = info.boundWidget;
 718                 mLauncher.getDragLayer().removeView(widget);
 719             }
 720         }
 721         mWidgetCleanupState = WIDGET_NO_CLEANUP_REQUIRED;
 722         mWidgetLoadingId = -1;
 723         mCreateWidgetInfo = null;
 724         PagedViewWidget.resetShortPressTarget();
 725     }
 726 
 727     @Override
 728     public void cleanUpShortPress(View v) {
 729         if (!mDraggingWidget) {
 730             cleanupWidgetPreloading(false);
 731         }
 732     }
 733 
 734     private boolean beginDraggingWidget(View v) {
 735         mDraggingWidget = true;
 736         // Get the widget preview as the drag representation
 737         ImageView image = (ImageView) v.findViewById(R.id.widget_preview);
 738         PendingAddItemInfo createItemInfo = (PendingAddItemInfo) v.getTag();
 739 
 740         // If the ImageView doesn&#x27;t have a drawable yet, the widget preview hasn&#x27;t been loaded and
 741         // we abort the drag.
 742         if (image.getDrawable() == null) {
 743             mDraggingWidget = false;
 744             return false;
 745         }
 746 
 747         // Compose the drag image
 748         Bitmap preview;
 749         Bitmap outline;
 750         float scale = 1f;
 751         if (createItemInfo instanceof PendingAddWidgetInfo) {
 752             // This can happen in some weird cases involving multi-touch. We can&#x27;t start dragging
 753             // the widget if this is null, so we break out.
 754             if (mCreateWidgetInfo == null) {
 755                 return false;
 756             }
 757 
 758             PendingAddWidgetInfo createWidgetInfo = mCreateWidgetInfo;
 759             createItemInfo = createWidgetInfo;
 760             int spanX = createItemInfo.spanX;
 761             int spanY = createItemInfo.spanY;
 762             int[] size = mLauncher.getWorkspace().estimateItemSize(spanX, spanY,
 763                     createWidgetInfo, true);
 764 
 765             FastBitmapDrawable previewDrawable = (FastBitmapDrawable) image.getDrawable();
 766             float minScale = 1.25f;
 767             int maxWidth, maxHeight;
 768             maxWidth = Math.min((int) (previewDrawable.getIntrinsicWidth() * minScale), size[0]);
 769             maxHeight = Math.min((int) (previewDrawable.getIntrinsicHeight() * minScale), size[1]);
 770             preview = getWidgetPreview(createWidgetInfo.componentName, createWidgetInfo.previewImage,
 771                     createWidgetInfo.icon, spanX, spanY, maxWidth, maxHeight);
 772 
 773             // Determine the image view drawable scale relative to the preview
 774             float[] mv = new float[9];
 775             Matrix m = new Matrix();
 776             m.setRectToRect(
 777                     new RectF(0f, 0f, (float) preview.getWidth(), (float) preview.getHeight()),
 778                     new RectF(0f, 0f, (float) previewDrawable.getIntrinsicWidth(),
 779                             (float) previewDrawable.getIntrinsicHeight()),
 780                     Matrix.ScaleToFit.START);
 781             m.getValues(mv);
 782             scale = (float) mv[0];
 783         } else {
 784             PendingAddShortcutInfo createShortcutInfo = (PendingAddShortcutInfo) v.getTag();
 785             Drawable icon = mIconCache.getFullResIcon(createShortcutInfo.shortcutActivityInfo);
 786             preview = Bitmap.createBitmap(icon.getIntrinsicWidth(),
 787                     icon.getIntrinsicHeight(), Bitmap.Config.ARGB_8888);
 788 
 789             mCanvas.setBitmap(preview);
 790             mCanvas.save();
 791             renderDrawableToBitmap(icon, preview, 0, 0,
 792                     icon.getIntrinsicWidth(), icon.getIntrinsicHeight());
 793             mCanvas.restore();
 794             mCanvas.setBitmap(null);
 795             createItemInfo.spanX = createItemInfo.spanY = 1;
 796         }
 797 
 798         // Don&#x27;t clip alpha values for the drag outline if we&#x27;re using the default widget preview
 799         boolean clipAlpha = !(createItemInfo instanceof PendingAddWidgetInfo &amp;&amp;
 800                 (((PendingAddWidgetInfo) createItemInfo).previewImage == 0));
 801 
 802         // Save the preview for the outline generation, then dim the preview
 803         outline = Bitmap.createScaledBitmap(preview, preview.getWidth(), preview.getHeight(),
 804                 false);
 805 
 806         // Start the drag
 807         mLauncher.lockScreenOrientation();
 808         mLauncher.getWorkspace().onDragStartedWithItem(createItemInfo, outline, clipAlpha);
 809         mDragController.startDrag(image, preview, this, createItemInfo,
 810                 DragController.DRAG_ACTION_COPY, null, scale);
 811         outline.recycle();
 812         preview.recycle();
 813         return true;
 814     }
 815 
 816     @Override
 817     protected boolean beginDragging(final View v) {
 818         if (!super.beginDragging(v)) return false;
 819 
 820         if (v instanceof PagedViewIcon) {
 821             beginDraggingApplication(v);
 822         } else if (v instanceof PagedViewWidget) {
 823             if (!beginDraggingWidget(v)) {
 824                 return false;
 825             }
 826         }
 827 
 828         // We delay entering spring-loaded mode slightly to make sure the UI
 829         // thready is free of any work.
 830         postDelayed(new Runnable() {
 831             @Override
 832             public void run() {
 833                 // We don&#x27;t enter spring-loaded mode if the drag has been cancelled
 834                 if (mLauncher.getDragController().isDragging()) {
 835                     // Dismiss the cling
 836                     mLauncher.dismissAllAppsCling(null);
 837 
 838                     // Reset the alpha on the dragged icon before we drag
 839                     resetDrawableState();
 840 
 841                     // Go into spring loaded mode (must happen before we startDrag())
 842                     mLauncher.enterSpringLoadedDragMode();
 843                 }
 844             }
 845         }, 150);
 846 
 847         return true;
 848     }
 849 
 850     /**
 851      * Clean up after dragging.
 852      *
 853      * @param target where the item was dragged to (can be null if the item was flung)
 854      */
 855     private void endDragging(View target, boolean isFlingToDelete, boolean success) {
 856         if (isFlingToDelete || !success || (target != mLauncher.getWorkspace() &amp;&amp;
 857                 !(target instanceof DeleteDropTarget))) {
 858             // Exit spring loaded mode if we have not successfully dropped or have not handled the
 859             // drop in Workspace
 860             mLauncher.exitSpringLoadedDragMode();
 861         }
 862         mLauncher.unlockScreenOrientation(false);
 863     }
 864 
 865     @Override
 866     public View getContent() {
 867         return null;
 868     }
 869 
 870     @Override
 871     public void onLauncherTransitionPrepare(Launcher l, boolean animated, boolean toWorkspace) {
 872         mInTransition = true;
 873         if (toWorkspace) {
 874             cancelAllTasks();
 875         }
 876     }
 877 
 878     @Override
 879     public void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace) {
 880     }
 881 
 882     @Override
 883     public void onLauncherTransitionStep(Launcher l, float t) {
 884     }
 885 
 886     @Override
 887     public void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace) {
 888         mInTransition = false;
 889         for (AsyncTaskPageData d : mDeferredSyncWidgetPageItems) {
 890             onSyncWidgetPageItems(d);
 891         }
 892         mDeferredSyncWidgetPageItems.clear();
 893         for (Runnable r : mDeferredPrepareLoadWidgetPreviewsTasks) {
 894             r.run();
 895         }
 896         mDeferredPrepareLoadWidgetPreviewsTasks.clear();
 897         mForceDrawAllChildrenNextFrame = !toWorkspace;
 898     }
 899 
 900     @Override
 901     public void onDropCompleted(View target, DragObject d, boolean isFlingToDelete,
 902             boolean success) {
 903         // Return early and wait for onFlingToDeleteCompleted if this was the result of a fling
 904         if (isFlingToDelete) return;
 905 
 906         endDragging(target, false, success);
 907 
 908         // Display an error message if the drag failed due to there not being enough space on the
 909         // target layout we were dropping on.
 910         if (!success) {
 911             boolean showOutOfSpaceMessage = false;
 912             if (target instanceof Workspace) {
 913                 int currentScreen = mLauncher.getCurrentWorkspaceScreen();
 914                 Workspace workspace = (Workspace) target;
 915                 CellLayout layout = (CellLayout) workspace.getChildAt(currentScreen);
 916                 ItemInfo itemInfo = (ItemInfo) d.dragInfo;
 917                 if (layout != null) {
 918                     layout.calculateSpans(itemInfo);
 919                     showOutOfSpaceMessage =
 920                             !layout.findCellForSpan(null, itemInfo.spanX, itemInfo.spanY);
 921                 }
 922             }
 923             if (showOutOfSpaceMessage) {
 924                 mLauncher.showOutOfSpaceMessage(false);
 925             }
 926 
 927             d.deferDragViewCleanupPostAnimation = false;
 928         }
 929         cleanupWidgetPreloading(success);
 930         mDraggingWidget = false;
 931     }
 932 
 933     @Override
 934     public void onFlingToDeleteCompleted() {
 935         // We just dismiss the drag when we fling, so cleanup here
 936         endDragging(null, true, true);
 937         cleanupWidgetPreloading(false);
 938         mDraggingWidget = false;
 939     }
 940 
 941     @Override
 942     public boolean supportsFlingToDelete() {
 943         return true;
 944     }
 945 
 946     @Override
 947     protected void onDetachedFromWindow() {
 948         super.onDetachedFromWindow();
 949         cancelAllTasks();
 950     }
 951 
 952     public void clearAllWidgetPages() {
 953         cancelAllTasks();
 954         int count = getChildCount();
 955         for (int i = 0; i &lt; count; i++) {
 956             View v = getPageAt(i);
 957             if (v instanceof PagedViewGridLayout) {
 958                 ((PagedViewGridLayout) v).removeAllViewsOnPage();
 959                 mDirtyPageContent.set(i, true);
 960             }
 961         }
 962     }
 963 
 964     private void cancelAllTasks() {
 965         // Clean up all the async tasks
 966         Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
 967         while (iter.hasNext()) {
 968             AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
 969             task.cancel(false);
 970             iter.remove();
 971             mDirtyPageContent.set(task.page, true);
 972 
 973             // We&#x27;ve already preallocated the views for the data to load into, so clear them as well
 974             View v = getPageAt(task.page);
 975             if (v instanceof PagedViewGridLayout) {
 976                 ((PagedViewGridLayout) v).removeAllViewsOnPage();
 977             }
 978         }
 979         mDeferredSyncWidgetPageItems.clear();
 980         mDeferredPrepareLoadWidgetPreviewsTasks.clear();
 981     }
 982 
 983     public void setContentType(ContentType type) {
 984         if (type == ContentType.Widgets) {
 985             invalidatePageData(mNumAppsPages, true);
 986         } else if (type == ContentType.Applications) {
 987             invalidatePageData(0, true);
 988         }
 989     }
 990 
 991     protected void snapToPage(int whichPage, int delta, int duration) {
 992         super.snapToPage(whichPage, delta, duration);
 993         updateCurrentTab(whichPage);
 994 
 995         // Update the thread priorities given the direction lookahead
 996         Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
 997         while (iter.hasNext()) {
 998             AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
 999             int pageIndex = task.page;
1000             if ((mNextPage &gt; mCurrentPage &amp;&amp; pageIndex &gt;= mCurrentPage) ||
1001                 (mNextPage &lt; mCurrentPage &amp;&amp; pageIndex &lt;= mCurrentPage)) {
1002                 task.setThreadPriority(getThreadPriorityForPage(pageIndex));
1003             } else {
1004                 task.setThreadPriority(Process.THREAD_PRIORITY_LOWEST);
1005             }
1006         }
1007     }
1008 
1009     private void updateCurrentTab(int currentPage) {
1010         AppsCustomizeTabHost tabHost = getTabHost();
1011         if (tabHost != null) {
1012             String tag = tabHost.getCurrentTabTag();
1013             if (tag != null) {
1014                 if (currentPage &gt;= mNumAppsPages &amp;&amp;
1015                         !tag.equals(tabHost.getTabTagForContentType(ContentType.Widgets))) {
1016                     tabHost.setCurrentTabFromContent(ContentType.Widgets);
1017                 } else if (currentPage &lt; mNumAppsPages &amp;&amp;
1018                         !tag.equals(tabHost.getTabTagForContentType(ContentType.Applications))) {
1019                     tabHost.setCurrentTabFromContent(ContentType.Applications);
1020                 }
1021             }
1022         }
1023     }
1024 
1025     /*
1026      * Apps PagedView implementation
1027      */
1028     private void setVisibilityOnChildren(ViewGroup layout, int visibility) {
1029         int childCount = layout.getChildCount();
1030         for (int i = 0; i &lt; childCount; ++i) {
1031             layout.getChildAt(i).setVisibility(visibility);
1032         }
1033     }
1034     private void setupPage(PagedViewCellLayout layout) {
1035         layout.setCellCount(mCellCountX, mCellCountY);
1036         layout.setGap(mPageLayoutWidthGap, mPageLayoutHeightGap);
1037         layout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
1038                 mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
1039 
1040         // Note: We force a measure here to get around the fact that when we do layout calculations
1041         // immediately after syncing, we don&#x27;t have a proper width.  That said, we already know the
1042         // expected page width, so we can actually optimize by hiding all the TextView-based
1043         // children that are expensive to measure, and let that happen naturally later.
1044         setVisibilityOnChildren(layout, View.GONE);
1045         int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
1046         int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
1047         layout.setMinimumWidth(getPageContentWidth());
1048         layout.measure(widthSpec, heightSpec);
1049         setVisibilityOnChildren(layout, View.VISIBLE);
1050     }
1051 
1052     public void syncAppsPageItems(int page, boolean immediate) {
1053         // ensure that we have the right number of items on the pages
1054         int numCells = mCellCountX * mCellCountY;
1055         int startIndex = page * numCells;
1056         int endIndex = Math.min(startIndex + numCells, mApps.size());
1057         PagedViewCellLayout layout = (PagedViewCellLayout) getPageAt(page);
1058 
1059         layout.removeAllViewsOnPage();
1060         ArrayList&lt;Object&gt; items = new ArrayList&lt;Object&gt;();
1061         ArrayList&lt;Bitmap&gt; images = new ArrayList&lt;Bitmap&gt;();
1062         for (int i = startIndex; i &lt; endIndex; ++i) {
1063             ApplicationInfo info = mApps.get(i);
1064             PagedViewIcon icon = (PagedViewIcon) mLayoutInflater.inflate(
1065                     R.layout.apps_customize_application, layout, false);
1066             icon.applyFromApplicationInfo(info, true, this);
1067             icon.setOnClickListener(this);
1068             icon.setOnLongClickListener(this);
1069             icon.setOnTouchListener(this);
1070             icon.setOnKeyListener(this);
1071 
1072             int index = i - startIndex;
1073             int x = index % mCellCountX;
1074             int y = index / mCellCountX;
1075             layout.addViewToCellLayout(icon, -1, i, new PagedViewCellLayout.LayoutParams(x,y, 1,1));
1076 
1077             items.add(info);
1078             images.add(info.iconBitmap);
1079         }
1080 
1081         layout.createHardwareLayers();
1082     }
1083 
1084     /**
1085      * A helper to return the priority for loading of the specified widget page.
1086      */
1087     private int getWidgetPageLoadPriority(int page) {
1088         // If we are snapping to another page, use that index as the target page index
1089         int toPage = mCurrentPage;
1090         if (mNextPage &gt; -1) {
1091             toPage = mNextPage;
1092         }
1093 
1094         // We use the distance from the target page as an initial guess of priority, but if there
1095         // are no pages of higher priority than the page specified, then bump up the priority of
1096         // the specified page.
1097         Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1098         int minPageDiff = Integer.MAX_VALUE;
1099         while (iter.hasNext()) {
1100             AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1101             minPageDiff = Math.abs(task.page - toPage);
1102         }
1103 
1104         int rawPageDiff = Math.abs(page - toPage);
1105         return rawPageDiff - Math.min(rawPageDiff, minPageDiff);
1106     }
1107     /**
1108      * Return the appropriate thread priority for loading for a given page (we give the current
1109      * page much higher priority)
1110      */
1111     private int getThreadPriorityForPage(int page) {
1112         // TODO-APPS_CUSTOMIZE: detect number of cores and set thread priorities accordingly below
1113         int pageDiff = getWidgetPageLoadPriority(page);
1114         if (pageDiff &lt;= 0) {
1115             return Process.THREAD_PRIORITY_LESS_FAVORABLE;
1116         } else if (pageDiff &lt;= 1) {
1117             return Process.THREAD_PRIORITY_LOWEST;
1118         } else {
1119             return Process.THREAD_PRIORITY_LOWEST;
1120         }
1121     }
1122     private int getSleepForPage(int page) {
1123         int pageDiff = getWidgetPageLoadPriority(page);
1124         return Math.max(0, pageDiff * sPageSleepDelay);
1125     }
1126     /**
1127      * Creates and executes a new AsyncTask to load a page of widget previews.
1128      */
1129     private void prepareLoadWidgetPreviewsTask(int page, ArrayList&lt;Object&gt; widgets,
1130             int cellWidth, int cellHeight, int cellCountX) {
1131 
1132         // Prune all tasks that are no longer needed
1133         Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1134         while (iter.hasNext()) {
1135             AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1136             int taskPage = task.page;
1137             if (taskPage &lt; getAssociatedLowerPageBound(mCurrentPage) ||
1138                     taskPage &gt; getAssociatedUpperPageBound(mCurrentPage)) {
1139                 task.cancel(false);
1140                 iter.remove();
1141             } else {
1142                 task.setThreadPriority(getThreadPriorityForPage(taskPage));
1143             }
1144         }
1145 
1146         // We introduce a slight delay to order the loading of side pages so that we don&#x27;t thrash
1147         final int sleepMs = getSleepForPage(page);
1148         AsyncTaskPageData pageData = new AsyncTaskPageData(page, widgets, cellWidth, cellHeight,
1149             new AsyncTaskCallback() {
1150                 @Override
1151                 public void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data) {
1152                     try {
1153                         try {
1154                             Thread.sleep(sleepMs);
1155                         } catch (Exception e) {}
1156                         loadWidgetPreviewsInBackground(task, data);
1157                     } finally {
1158                         if (task.isCancelled()) {
1159                             data.cleanup(true);
1160                         }
1161                     }
1162                 }
1163             },
1164             new AsyncTaskCallback() {
1165                 @Override
1166                 public void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data) {
1167                     mRunningTasks.remove(task);
1168                     if (task.isCancelled()) return;
1169                     // do cleanup inside onSyncWidgetPageItems
1170                     onSyncWidgetPageItems(data);
1171                 }
1172             });
1173 
1174         // Ensure that the task is appropriately prioritized and runs in parallel
1175         AppsCustomizeAsyncTask t = new AppsCustomizeAsyncTask(page,
1176                 AsyncTaskPageData.Type.LoadWidgetPreviewData);
1177         t.setThreadPriority(getThreadPriorityForPage(page));
1178         t.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, pageData);
1179         mRunningTasks.add(t);
1180     }
1181 
1182     /*
1183      * Widgets PagedView implementation
1184      */
1185     private void setupPage(PagedViewGridLayout layout) {
1186         layout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
1187                 mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
1188 
1189         // Note: We force a measure here to get around the fact that when we do layout calculations
1190         // immediately after syncing, we don&#x27;t have a proper width.
1191         int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
1192         int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
1193         layout.setMinimumWidth(getPageContentWidth());
1194         layout.measure(widthSpec, heightSpec);
1195     }
1196 
1197     private void renderDrawableToBitmap(Drawable d, Bitmap bitmap, int x, int y, int w, int h) {
1198         renderDrawableToBitmap(d, bitmap, x, y, w, h, 1f);
1199     }
1200 
1201     private void renderDrawableToBitmap(Drawable d, Bitmap bitmap, int x, int y, int w, int h,
1202             float scale) {
1203         if (bitmap != null) {
1204             Canvas c = new Canvas(bitmap);
1205             c.scale(scale, scale);
1206             Rect oldBounds = d.copyBounds();
1207             d.setBounds(x, y, x + w, y + h);
1208             d.draw(c);
1209             d.setBounds(oldBounds); // Restore the bounds
1210             c.setBitmap(null);
1211         }
1212     }
1213 
1214     private Bitmap getShortcutPreview(ResolveInfo info, int maxWidth, int maxHeight) {
1215         Bitmap tempBitmap = mCachedShortcutPreviewBitmap.get();
1216         final Canvas c = mCachedShortcutPreviewCanvas.get();
1217         if (tempBitmap == null ||
1218                 tempBitmap.getWidth() != maxWidth ||
1219                 tempBitmap.getHeight() != maxHeight) {
1220             tempBitmap = Bitmap.createBitmap(maxWidth, maxHeight, Config.ARGB_8888);
1221             mCachedShortcutPreviewBitmap.set(tempBitmap);
1222         } else {
1223             c.setBitmap(tempBitmap);
1224             c.drawColor(0, PorterDuff.Mode.CLEAR);
1225             c.setBitmap(null);
1226         }
1227         // Render the icon
1228         Drawable icon = mIconCache.getFullResIcon(info);
1229 
1230         int paddingTop =
1231                 getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_top);
1232         int paddingLeft =
1233                 getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_left);
1234         int paddingRight =
1235                 getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_right);
1236 
1237         int scaledIconWidth = (maxWidth - paddingLeft - paddingRight);
1238 
1239         renderDrawableToBitmap(
1240                 icon, tempBitmap, paddingLeft, paddingTop, scaledIconWidth, scaledIconWidth);
1241 
1242         Bitmap preview = Bitmap.createBitmap(maxWidth, maxHeight, Config.ARGB_8888);
1243         c.setBitmap(preview);
1244         Paint p = mCachedShortcutPreviewPaint.get();
1245         if (p == null) {
1246             p = new Paint();
1247             ColorMatrix colorMatrix = new ColorMatrix();
1248             colorMatrix.setSaturation(0);
1249             p.setColorFilter(new ColorMatrixColorFilter(colorMatrix));
1250             p.setAlpha((int) (255 * 0.06f));
1251             //float density = 1f;
1252             //p.setMaskFilter(new BlurMaskFilter(15*density, BlurMaskFilter.Blur.NORMAL));
1253             mCachedShortcutPreviewPaint.set(p);
1254         }
1255         c.drawBitmap(tempBitmap, 0, 0, p);
1256         c.setBitmap(null);
1257 
1258         renderDrawableToBitmap(icon, preview, 0, 0, mAppIconSize, mAppIconSize);
1259 
1260         return preview;
1261     }
1262 
1263     private Bitmap getWidgetPreview(ComponentName provider, int previewImage,
1264             int iconId, int cellHSpan, int cellVSpan, int maxWidth,
1265             int maxHeight) {
1266         // Load the preview image if possible
1267         String packageName = provider.getPackageName();
1268         if (maxWidth &lt; 0) maxWidth = Integer.MAX_VALUE;
1269         if (maxHeight &lt; 0) maxHeight = Integer.MAX_VALUE;
1270 
1271         Drawable drawable = null;
1272         if (previewImage != 0) {
1273             drawable = mPackageManager.getDrawable(packageName, previewImage, null);
1274             if (drawable == null) {
1275                 Log.w(TAG, &quot;Can&#x27;t load widget preview drawable 0x&quot; +
1276                         Integer.toHexString(previewImage) + &quot; for provider: &quot; + provider);
1277             }
1278         }
1279 
1280         int bitmapWidth;
1281         int bitmapHeight;
1282         Bitmap defaultPreview = null;
1283         boolean widgetPreviewExists = (drawable != null);
1284         if (widgetPreviewExists) {
1285             bitmapWidth = drawable.getIntrinsicWidth();
1286             bitmapHeight = drawable.getIntrinsicHeight();
1287         } else {
1288             // Generate a preview image if we couldn&#x27;t load one
1289             if (cellHSpan &lt; 1) cellHSpan = 1;
1290             if (cellVSpan &lt; 1) cellVSpan = 1;
1291 
1292             BitmapDrawable previewDrawable = (BitmapDrawable) getResources()
1293                     .getDrawable(R.drawable.widget_preview_tile);
1294             final int previewDrawableWidth = previewDrawable
1295                     .getIntrinsicWidth();
1296             final int previewDrawableHeight = previewDrawable
1297                     .getIntrinsicHeight();
1298             bitmapWidth = previewDrawableWidth * cellHSpan; // subtract 2 dips
1299             bitmapHeight = previewDrawableHeight * cellVSpan;
1300 
1301             defaultPreview = Bitmap.createBitmap(bitmapWidth, bitmapHeight,
1302                     Config.ARGB_8888);
1303             final Canvas c = mCachedAppWidgetPreviewCanvas.get();
1304             c.setBitmap(defaultPreview);
1305             previewDrawable.setBounds(0, 0, bitmapWidth, bitmapHeight);
1306             previewDrawable.setTileModeXY(Shader.TileMode.REPEAT,
1307                     Shader.TileMode.REPEAT);
1308             previewDrawable.draw(c);
1309             c.setBitmap(null);
1310 
1311             // Draw the icon in the top left corner
1312             int minOffset = (int) (mAppIconSize * sWidgetPreviewIconPaddingPercentage);
1313             int smallestSide = Math.min(bitmapWidth, bitmapHeight);
1314             float iconScale = Math.min((float) smallestSide
1315                     / (mAppIconSize + 2 * minOffset), 1f);
1316 
1317             try {
1318                 Drawable icon = null;
1319                 int hoffset =
1320                         (int) ((previewDrawableWidth - mAppIconSize * iconScale) / 2);
1321                 int yoffset =
1322                         (int) ((previewDrawableHeight - mAppIconSize * iconScale) / 2);
1323                 if (iconId &gt; 0)
1324                     icon = mIconCache.getFullResIcon(packageName, iconId);
1325                 if (icon != null) {
1326                     renderDrawableToBitmap(icon, defaultPreview, hoffset,
1327                             yoffset, (int) (mAppIconSize * iconScale),
1328                             (int) (mAppIconSize * iconScale));
1329                 }
1330             } catch (Resources.NotFoundException e) {
1331             }
1332         }
1333 
1334         // Scale to fit width only - let the widget preview be clipped in the
1335         // vertical dimension
1336         float scale = 1f;
1337         if (bitmapWidth &gt; maxWidth) {
1338             scale = maxWidth / (float) bitmapWidth;
1339         }
1340         if (scale != 1f) {
1341             bitmapWidth = (int) (scale * bitmapWidth);
1342             bitmapHeight = (int) (scale * bitmapHeight);
1343         }
1344 
1345         Bitmap preview = Bitmap.createBitmap(bitmapWidth, bitmapHeight,
1346                 Config.ARGB_8888);
1347 
1348         // Draw the scaled preview into the final bitmap
1349         if (widgetPreviewExists) {
1350             renderDrawableToBitmap(drawable, preview, 0, 0, bitmapWidth,
1351                     bitmapHeight);
1352         } else {
1353             final Canvas c = mCachedAppWidgetPreviewCanvas.get();
1354             final Rect src = mCachedAppWidgetPreviewSrcRect.get();
1355             final Rect dest = mCachedAppWidgetPreviewDestRect.get();
1356             c.setBitmap(preview);
1357             src.set(0, 0, defaultPreview.getWidth(), defaultPreview.getHeight());
1358             dest.set(0, 0, preview.getWidth(), preview.getHeight());
1359 
1360             Paint p = mCachedAppWidgetPreviewPaint.get();
1361             if (p == null) {
1362                 p = new Paint();
1363                 p.setFilterBitmap(true);
1364                 mCachedAppWidgetPreviewPaint.set(p);
1365             }
1366             c.drawBitmap(defaultPreview, src, dest, p);
1367             c.setBitmap(null);
1368         }
1369         return preview;
1370     }
1371 
1372     public void syncWidgetPageItems(final int page, final boolean immediate) {
1373         int numItemsPerPage = mWidgetCountX * mWidgetCountY;
1374 
1375         // Calculate the dimensions of each cell we are giving to each widget
1376         final ArrayList&lt;Object&gt; items = new ArrayList&lt;Object&gt;();
1377         int contentWidth = mWidgetSpacingLayout.getContentWidth();
1378         final int cellWidth = ((contentWidth - mPageLayoutPaddingLeft - mPageLayoutPaddingRight
1379                 - ((mWidgetCountX - 1) * mWidgetWidthGap)) / mWidgetCountX);
1380         int contentHeight = mWidgetSpacingLayout.getContentHeight();
1381         final int cellHeight = ((contentHeight - mPageLayoutPaddingTop - mPageLayoutPaddingBottom
1382                 - ((mWidgetCountY - 1) * mWidgetHeightGap)) / mWidgetCountY);
1383 
1384         // Prepare the set of widgets to load previews for in the background
1385         int offset = (page - mNumAppsPages) * numItemsPerPage;
1386         for (int i = offset; i &lt; Math.min(offset + numItemsPerPage, mWidgets.size()); ++i) {
1387             items.add(mWidgets.get(i));
1388         }
1389 
1390         // Prepopulate the pages with the other widget info, and fill in the previews later
1391         final PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(page);
1392         layout.setColumnCount(layout.getCellCountX());
1393         for (int i = 0; i &lt; items.size(); ++i) {
1394             Object rawInfo = items.get(i);
1395             PendingAddItemInfo createItemInfo = null;
1396             PagedViewWidget widget = (PagedViewWidget) mLayoutInflater.inflate(
1397                     R.layout.apps_customize_widget, layout, false);
1398             if (rawInfo instanceof AppWidgetProviderInfo) {
1399                 // Fill in the widget information
1400                 AppWidgetProviderInfo info = (AppWidgetProviderInfo) rawInfo;
1401                 createItemInfo = new PendingAddWidgetInfo(info, null, null);
1402 
1403                 // Determine the widget spans and min resize spans.
1404                 int[] spanXY = Launcher.getSpanForWidget(mLauncher, info);
1405                 createItemInfo.spanX = spanXY[0];
1406                 createItemInfo.spanY = spanXY[1];
1407                 int[] minSpanXY = Launcher.getMinSpanForWidget(mLauncher, info);
1408                 createItemInfo.minSpanX = minSpanXY[0];
1409                 createItemInfo.minSpanY = minSpanXY[1];
1410 
1411                 widget.applyFromAppWidgetProviderInfo(info, -1, spanXY);
1412                 widget.setTag(createItemInfo);
1413                 widget.setShortPressListener(this);
1414             } else if (rawInfo instanceof ResolveInfo) {
1415                 // Fill in the shortcuts information
1416                 ResolveInfo info = (ResolveInfo) rawInfo;
1417                 createItemInfo = new PendingAddShortcutInfo(info.activityInfo);
1418                 createItemInfo.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
1419                 createItemInfo.componentName = new ComponentName(info.activityInfo.packageName,
1420                         info.activityInfo.name);
1421                 widget.applyFromResolveInfo(mPackageManager, info);
1422                 widget.setTag(createItemInfo);
1423             }
1424             widget.setOnClickListener(this);
1425             widget.setOnLongClickListener(this);
1426             widget.setOnTouchListener(this);
1427             widget.setOnKeyListener(this);
1428 
1429             // Layout each widget
1430             int ix = i % mWidgetCountX;
1431             int iy = i / mWidgetCountX;
1432             GridLayout.LayoutParams lp = new GridLayout.LayoutParams(
1433                     GridLayout.spec(iy, GridLayout.LEFT),
1434                     GridLayout.spec(ix, GridLayout.TOP));
1435             lp.width = cellWidth;
1436             lp.height = cellHeight;
1437             lp.setGravity(Gravity.TOP | Gravity.LEFT);
1438             if (ix &gt; 0) lp.leftMargin = mWidgetWidthGap;
1439             if (iy &gt; 0) lp.topMargin = mWidgetHeightGap;
1440             layout.addView(widget, lp);
1441         }
1442 
1443         // wait until a call on onLayout to start loading, because
1444         // PagedViewWidget.getPreviewSize() will return 0 if it hasn&#x27;t been laid out
1445         // TODO: can we do a measure/layout immediately?
1446         layout.setOnLayoutListener(new Runnable() {
1447             public void run() {
1448                 // Load the widget previews
1449                 int maxPreviewWidth = cellWidth;
1450                 int maxPreviewHeight = cellHeight;
1451                 if (layout.getChildCount() &gt; 0) {
1452                     PagedViewWidget w = (PagedViewWidget) layout.getChildAt(0);
1453                     int[] maxSize = w.getPreviewSize();
1454                     maxPreviewWidth = maxSize[0];
1455                     maxPreviewHeight = maxSize[1];
1456                 }
1457                 if (immediate) {
1458                     AsyncTaskPageData data = new AsyncTaskPageData(page, items,
1459                             maxPreviewWidth, maxPreviewHeight, null, null);
1460                     loadWidgetPreviewsInBackground(null, data);
1461                     onSyncWidgetPageItems(data);
1462                 } else {
1463                     if (mInTransition) {
1464                         mDeferredPrepareLoadWidgetPreviewsTasks.add(this);
1465                     } else {
1466                         prepareLoadWidgetPreviewsTask(page, items,
1467                                 maxPreviewWidth, maxPreviewHeight, mWidgetCountX);
1468                     }
1469                 }
1470             }
1471         });
1472     }
1473     private void loadWidgetPreviewsInBackground(AppsCustomizeAsyncTask task,
1474             AsyncTaskPageData data) {
1475         // loadWidgetPreviewsInBackground can be called without a task to load a set of widget
1476         // previews synchronously
1477         if (task != null) {
1478             // Ensure that this task starts running at the correct priority
1479             task.syncThreadPriority();
1480         }
1481 
1482         // Load each of the widget/shortcut previews
1483         ArrayList&lt;Object&gt; items = data.items;
1484         ArrayList&lt;Bitmap&gt; images = data.generatedImages;
1485         int count = items.size();
1486         for (int i = 0; i &lt; count; ++i) {
1487             if (task != null) {
1488                 // Ensure we haven&#x27;t been cancelled yet
1489                 if (task.isCancelled()) break;
1490                 // Before work on each item, ensure that this task is running at the correct
1491                 // priority
1492                 task.syncThreadPriority();
1493             }
1494 
1495             Object rawInfo = items.get(i);
1496             if (rawInfo instanceof AppWidgetProviderInfo) {
1497                 AppWidgetProviderInfo info = (AppWidgetProviderInfo) rawInfo;
1498                 int[] cellSpans = Launcher.getSpanForWidget(mLauncher, info);
1499 
1500                 int maxWidth = Math.min(data.maxImageWidth,
1501                         mWidgetSpacingLayout.estimateCellWidth(cellSpans[0]));
1502                 int maxHeight = Math.min(data.maxImageHeight,
1503                         mWidgetSpacingLayout.estimateCellHeight(cellSpans[1]));
1504                 Bitmap b = getWidgetPreview(info.provider, info.previewImage, info.icon,
1505                         cellSpans[0], cellSpans[1], maxWidth, maxHeight);
1506                 images.add(b);
1507             } else if (rawInfo instanceof ResolveInfo) {
1508                 // Fill in the shortcuts information
1509                 ResolveInfo info = (ResolveInfo) rawInfo;
1510                 images.add(getShortcutPreview(info, data.maxImageWidth, data.maxImageHeight));
1511             }
1512         }
1513     }
1514 
1515     private void onSyncWidgetPageItems(AsyncTaskPageData data) {
1516         if (mInTransition) {
1517             mDeferredSyncWidgetPageItems.add(data);
1518             return;
1519         }
1520         try {
1521             int page = data.page;
1522             PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(page);
1523 
1524             ArrayList&lt;Object&gt; items = data.items;
1525             int count = items.size();
1526             for (int i = 0; i &lt; count; ++i) {
1527                 PagedViewWidget widget = (PagedViewWidget) layout.getChildAt(i);
1528                 if (widget != null) {
1529                     Bitmap preview = data.generatedImages.get(i);
1530                     widget.applyPreview(new FastBitmapDrawable(preview), i);
1531                 }
1532             }
1533 
1534             layout.createHardwareLayer();
1535             invalidate();
1536 
1537             // Update all thread priorities
1538             Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1539             while (iter.hasNext()) {
1540                 AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1541                 int pageIndex = task.page;
1542                 task.setThreadPriority(getThreadPriorityForPage(pageIndex));
1543             }
1544         } finally {
1545             data.cleanup(false);
1546         }
1547     }
1548 
1549     @Override
1550     public void syncPages() {
1551         removeAllViews();
1552         cancelAllTasks();
1553 
1554         Context context = getContext();
1555         for (int j = 0; j &lt; mNumWidgetPages; ++j) {
1556             PagedViewGridLayout layout = new PagedViewGridLayout(context, mWidgetCountX,
1557                     mWidgetCountY);
1558             setupPage(layout);
1559             addView(layout, new PagedView.LayoutParams(LayoutParams.MATCH_PARENT,
1560                     LayoutParams.MATCH_PARENT));
1561         }
1562 
1563         for (int i = 0; i &lt; mNumAppsPages; ++i) {
1564             PagedViewCellLayout layout = new PagedViewCellLayout(context);
1565             setupPage(layout);
1566             addView(layout);
1567         }
1568     }
1569 
1570     @Override
1571     public void syncPageItems(int page, boolean immediate) {
1572         if (page &lt; mNumAppsPages) {
1573             syncAppsPageItems(page, immediate);
1574         } else {
1575             syncWidgetPageItems(page, immediate);
1576         }
1577     }
1578 
1579     // We want our pages to be z-ordered such that the further a page is to the left, the higher
1580     // it is in the z-order. This is important to insure touch events are handled correctly.
1581     View getPageAt(int index) {
1582         return getChildAt(indexToPage(index));
1583     }
1584 
1585     @Override
1586     protected int indexToPage(int index) {
1587         return getChildCount() - index - 1;
1588     }
1589 
1590     // In apps customize, we have a scrolling effect which emulates pulling cards off of a stack.
1591     @Override
1592     protected void screenScrolled(int screenCenter) {
1593         super.screenScrolled(screenCenter);
1594 
1595         for (int i = 0; i &lt; getChildCount(); i++) {
1596             View v = getPageAt(i);
1597             if (v != null) {
1598                 float scrollProgress = getScrollProgress(screenCenter, v, i);
1599 
1600                 float interpolatedProgress =
1601                         mZInterpolator.getInterpolation(Math.abs(Math.min(scrollProgress, 0)));
1602                 float scale = (1 - interpolatedProgress) +
1603                         interpolatedProgress * TRANSITION_SCALE_FACTOR;
1604                 float translationX = Math.min(0, scrollProgress) * v.getMeasuredWidth();
1605 
1606                 float alpha;
1607 
1608                 if (scrollProgress &lt; 0) {
1609                     alpha = scrollProgress &lt; 0 ? mAlphaInterpolator.getInterpolation(
1610                         1 - Math.abs(scrollProgress)) : 1.0f;
1611                 } else {
1612                     // On large screens we need to fade the page as it nears its leftmost position
1613                     alpha = mLeftScreenAlphaInterpolator.getInterpolation(1 - scrollProgress);
1614                 }
1615 
1616                 v.setCameraDistance(mDensity * CAMERA_DISTANCE);
1617                 int pageWidth = v.getMeasuredWidth();
1618                 int pageHeight = v.getMeasuredHeight();
1619 
1620                 if (PERFORM_OVERSCROLL_ROTATION) {
1621                     if (i == 0 &amp;&amp; scrollProgress &lt; 0) {
1622                         // Overscroll to the left
1623                         v.setPivotX(TRANSITION_PIVOT * pageWidth);
1624                         v.setRotationY(-TRANSITION_MAX_ROTATION * scrollProgress);
1625                         scale = 1.0f;
1626                         alpha = 1.0f;
1627                         // On the first page, we don&#x27;t want the page to have any lateral motion
1628                         translationX = 0;
1629                     } else if (i == getChildCount() - 1 &amp;&amp; scrollProgress &gt; 0) {
1630                         // Overscroll to the right
1631                         v.setPivotX((1 - TRANSITION_PIVOT) * pageWidth);
1632                         v.setRotationY(-TRANSITION_MAX_ROTATION * scrollProgress);
1633                         scale = 1.0f;
1634                         alpha = 1.0f;
1635                         // On the last page, we don&#x27;t want the page to have any lateral motion.
1636                         translationX = 0;
1637                     } else {
1638                         v.setPivotY(pageHeight / 2.0f);
1639                         v.setPivotX(pageWidth / 2.0f);
1640                         v.setRotationY(0f);
1641                     }
1642                 }
1643 
1644                 v.setTranslationX(translationX);
1645                 v.setScaleX(scale);
1646                 v.setScaleY(scale);
1647                 v.setAlpha(alpha);
1648 
1649                 // If the view has 0 alpha, we set it to be invisible so as to prevent
1650                 // it from accepting touches
1651                 if (alpha == 0) {
1652                     v.setVisibility(INVISIBLE);
1653                 } else if (v.getVisibility() != VISIBLE) {
1654                     v.setVisibility(VISIBLE);
1655                 }
1656             }
1657         }
1658     }
1659 
1660     protected void overScroll(float amount) {
1661         acceleratedOverScroll(amount);
1662     }
1663 
1664     /**
1665      * Used by the parent to get the content width to set the tab bar to
1666      * @return
1667      */
1668     public int getPageContentWidth() {
1669         return mContentWidth;
1670     }
1671 
1672     @Override
1673     protected void onPageEndMoving() {
1674         super.onPageEndMoving();
1675         mForceDrawAllChildrenNextFrame = true;
1676         // We reset the save index when we change pages so that it will be recalculated on next
1677         // rotation
1678         mSaveInstanceStateItemIndex = -1;
1679     }
1680 
1681     /*
1682      * AllAppsView implementation
1683      */
1684         public void setup(Launcher launcher, DragController dragController) {
1685         mLauncher = launcher;
1686         mDragController = dragController;
1687     }
1688 
1689     /**
1690      * We should call thise method whenever the core data changes (mApps, mWidgets) so that we can
1691      * appropriately determine when to invalidate the PagedView page data.  In cases where the data
1692      * has yet to be set, we can requestLayout() and wait for onDataReady() to be called in the
1693      * next onMeasure() pass, which will trigger an invalidatePageData() itself.
1694      */
1695     private void invalidateOnDataChange() {
1696         if (!isDataReady()) {
1697             // The next layout pass will trigger data-ready if both widgets and apps are set, so
1698             // request a layout to trigger the page data when ready.
1699             requestLayout();
1700         } else {
1701             cancelAllTasks();
1702             invalidatePageData();
1703         }
1704     }
1705 
1706         public void setApps(ArrayList&lt;ApplicationInfo&gt; list) {
1707         mApps = list;
1708         Collections.sort(mApps, LauncherModel.APP_NAME_COMPARATOR);
1709         updatePageCounts();
1710         invalidateOnDataChange();
1711     }
1712     private void addAppsWithoutInvalidate(ArrayList&lt;ApplicationInfo&gt; list) {
1713         // We add it in place, in alphabetical order
1714         int count = list.size();
1715         for (int i = 0; i &lt; count; ++i) {
1716             ApplicationInfo info = list.get(i);
1717             int index = Collections.binarySearch(mApps, info, LauncherModel.APP_NAME_COMPARATOR);
1718             if (index &lt; 0) {
1719                 mApps.add(-(index + 1), info);
1720             }
1721         }
1722     }
1723     public void addApps(ArrayList&lt;ApplicationInfo&gt; list) {
1724         addAppsWithoutInvalidate(list);
1725         updatePageCounts();
1726         invalidateOnDataChange();
1727     }
1728     private int findAppByComponent(List&lt;ApplicationInfo&gt; list, ApplicationInfo item) {
1729         ComponentName removeComponent = item.intent.getComponent();
1730         int length = list.size();
1731         for (int i = 0; i &lt; length; ++i) {
1732             ApplicationInfo info = list.get(i);
1733             if (info.intent.getComponent().equals(removeComponent)) {
1734                 return i;
1735             }
1736         }
1737         return -1;
1738     }
1739     private int findAppByPackage(List&lt;ApplicationInfo&gt; list, String packageName) {
1740         int length = list.size();
1741         for (int i = 0; i &lt; length; ++i) {
1742             ApplicationInfo info = list.get(i);
1743             if (ItemInfo.getPackageName(info.intent).equals(packageName)) {
1744                 return i;
1745             }
1746         }
1747         return -1;
1748     }
1749     private void removeAppsWithoutInvalidate(ArrayList&lt;ApplicationInfo&gt; list) {
1750         // loop through all the apps and remove apps that have the same component
1751         int length = list.size();
1752         for (int i = 0; i &lt; length; ++i) {
1753             ApplicationInfo info = list.get(i);
1754             int removeIndex = findAppByComponent(mApps, info);
1755             if (removeIndex &gt; -1) {
1756                 mApps.remove(removeIndex);
1757             }
1758         }
1759     }
1760     private void removeAppsWithPackageNameWithoutInvalidate(ArrayList&lt;String&gt; packageNames) {
1761         // loop through all the package names and remove apps that have the same package name
1762         for (String pn : packageNames) {
1763             int removeIndex = findAppByPackage(mApps, pn);
1764             while (removeIndex &gt; -1) {
1765                 mApps.remove(removeIndex);
1766                 removeIndex = findAppByPackage(mApps, pn);
1767             }
1768         }
1769     }
1770     public void removeApps(ArrayList&lt;String&gt; packageNames) {
1771         removeAppsWithPackageNameWithoutInvalidate(packageNames);
1772         updatePageCounts();
1773         invalidateOnDataChange();
1774     }
1775         public void updateApps(ArrayList&lt;ApplicationInfo&gt; list) {
1776         // We remove and re-add the updated applications list because it&#x27;s properties may have
1777         // changed (ie. the title), and this will ensure that the items will be in their proper
1778         // place in the list.
1779         removeAppsWithoutInvalidate(list);
1780         addAppsWithoutInvalidate(list);
1781         updatePageCounts();
1782         invalidateOnDataChange();
1783     }
1784 
1785         public void reset() {
1786         // If we have reset, then we should not continue to restore the previous state
1787         mSaveInstanceStateItemIndex = -1;
1788 
1789         AppsCustomizeTabHost tabHost = getTabHost();
1790         String tag = tabHost.getCurrentTabTag();
1791         if (tag != null) {
1792             if (!tag.equals(tabHost.getTabTagForContentType(ContentType.Applications))) {
1793                 tabHost.setCurrentTabFromContent(ContentType.Applications);
1794             }
1795         }
1796 
1797         if (mCurrentPage != 0) {
1798             invalidatePageData(0);
1799         }
1800     }
1801 
1802     private AppsCustomizeTabHost getTabHost() {
1803         return (AppsCustomizeTabHost) mLauncher.findViewById(R.id.apps_customize_pane);
1804     }
1805 
1806         public void dumpState() {
1807         // TODO: Dump information related to current list of Applications, Widgets, etc.
1808         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mApps&quot;, mApps);
1809         dumpAppWidgetProviderInfoList(TAG, &quot;mWidgets&quot;, mWidgets);
1810     }
1811 
1812     private void dumpAppWidgetProviderInfoList(String tag, String label,
1813             ArrayList&lt;Object&gt; list) {
1814         Log.d(tag, label + &quot; size=&quot; + list.size());
1815         for (Object i: list) {
1816             if (i instanceof AppWidgetProviderInfo) {
1817                 AppWidgetProviderInfo info = (AppWidgetProviderInfo) i;
1818                 Log.d(tag, &quot;   label=\&quot;&quot; + info.label + &quot;\&quot; previewImage=&quot; + info.previewImage
1819                         + &quot; resizeMode=&quot; + info.resizeMode + &quot; configure=&quot; + info.configure
1820                         + &quot; initialLayout=&quot; + info.initialLayout
1821                         + &quot; minWidth=&quot; + info.minWidth + &quot; minHeight=&quot; + info.minHeight);
1822             } else if (i instanceof ResolveInfo) {
1823                 ResolveInfo info = (ResolveInfo) i;
1824                 Log.d(tag, &quot;   label=\&quot;&quot; + info.loadLabel(mPackageManager) + &quot;\&quot; icon=&quot;
1825                         + info.icon);
1826             }
1827         }
1828     }
1829 
1830         public void surrender() {
1831         // TODO: If we are in the middle of any process (ie. for holographic outlines, etc) we
1832         // should stop this now.
1833 
1834         // Stop all background tasks
1835         cancelAllTasks();
1836     }
1837 
1838     @Override
1839     public void iconPressed(PagedViewIcon icon) {
1840         // Reset the previously pressed icon and store a reference to the pressed icon so that
1841         // we can reset it on return to Launcher (in Launcher.onResume())
1842         if (mPressedIcon != null) {
1843             mPressedIcon.resetDrawableState();
1844         }
1845         mPressedIcon = icon;
1846     }
1847 
1848     public void resetDrawableState() {
1849         if (mPressedIcon != null) {
1850             mPressedIcon.resetDrawableState();
1851             mPressedIcon = null;
1852         }
1853     }
1854 
1855     /*
1856      * We load an extra page on each side to prevent flashes from scrolling and loading of the
1857      * widget previews in the background with the AsyncTasks.
1858      */
1859     final static int sLookBehindPageCount = 2;
1860     final static int sLookAheadPageCount = 2;
1861     protected int getAssociatedLowerPageBound(int page) {
1862         final int count = getChildCount();
1863         int windowSize = Math.min(count, sLookBehindPageCount + sLookAheadPageCount + 1);
1864         int windowMinIndex = Math.max(Math.min(page - sLookBehindPageCount, count - windowSize), 0);
1865         return windowMinIndex;
1866     }
1867     protected int getAssociatedUpperPageBound(int page) {
1868         final int count = getChildCount();
1869         int windowSize = Math.min(count, sLookBehindPageCount + sLookAheadPageCount + 1);
1870         int windowMaxIndex = Math.min(Math.max(page + sLookAheadPageCount, windowSize - 1),
1871                 count - 1);
1872         return windowMaxIndex;
1873     }
1874 
1875     @Override
1876     protected String getCurrentPageDescription() {
1877         int page = (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
1878         int stringId = R.string.default_scroll_format;
1879         int count = 0;
1880 
1881         if (page &lt; mNumAppsPages) {
1882             stringId = R.string.apps_customize_apps_scroll_format;
1883             count = mNumAppsPages;
1884         } else {
1885             page -= mNumAppsPages;
1886             stringId = R.string.apps_customize_widgets_scroll_format;
1887             count = mNumWidgetPages;
1888         }
1889 
1890         return String.format(getContext().getString(stringId), page + 1, count);
1891     }
1892 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2011 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher2;
  17 
  18 import android.animation.AnimatorSet;
  19 import android.animation.ValueAnimator;
  20 import android.appwidget.AppWidgetHostView;
  21 import android.appwidget.AppWidgetManager;
  22 import android.appwidget.AppWidgetProviderInfo;
  23 import android.content.ComponentName;
  24 import android.content.Context;
  25 import android.content.Intent;
  26 import android.content.pm.PackageManager;
  27 import android.content.pm.ResolveInfo;
  28 import android.content.res.Configuration;
  29 import android.content.res.Resources;
  30 import android.content.res.TypedArray;
  31 import android.graphics.Bitmap.Config;
  32 import android.graphics.Bitmap;
  33 import android.graphics.Canvas;
  34 import android.graphics.ColorMatrix;
  35 import android.graphics.ColorMatrixColorFilter;
  36 import android.graphics.Matrix;
  37 import android.graphics.Paint;
  38 import android.graphics.PorterDuff;
  39 import android.graphics.Rect;
  40 import android.graphics.RectF;
  41 import android.graphics.Shader;
  42 import android.graphics.drawable.BitmapDrawable;
  43 import android.graphics.drawable.Drawable;
  44 import android.os.AsyncTask;
  45 import android.os.Process;
  46 import android.util.AttributeSet;
  47 import android.util.Log;
  48 import android.view.Gravity;
  49 import android.view.KeyEvent;
  50 import android.view.LayoutInflater;
  51 import android.view.MotionEvent;
  52 import android.view.View;
  53 import android.view.ViewGroup;
  54 import android.view.animation.AccelerateInterpolator;
  55 import android.view.animation.DecelerateInterpolator;
  56 import android.widget.GridLayout;
  57 import android.widget.ImageView;
  58 import android.widget.Toast;
  59 import com.android.launcher.R;
  60 import com.android.launcher2.DropTarget.DragObject;
  61 import java.lang.ref.WeakReference;
  62 import java.util.ArrayList;
  63 import java.util.Collections;
  64 import java.util.Iterator;
  65 import java.util.List;
  66 
  67 
  68 /**
  69  * A generic template for an async task used in AppsCustomize.
  70  */
  71 class AppsCustomizeAsyncTask extends AsyncTask&lt;AsyncTaskPageData, Void, AsyncTaskPageData&gt; {
  72     AppsCustomizeAsyncTask(int p, AsyncTaskPageData.Type ty) {
  73         page = p;
  74         threadPriority = java.lang.Process.THREAD_PRIORITY_DEFAULT;
  75         dataType = ty;
  76     }
  77 
  78     @Override
  79     protected AsyncTaskPageData doInBackground(AsyncTaskPageData... params) {
  80         if (params.length != 1) {
  81             return null;
  82         }
  83         // Load each of the widget previews in the background
  84         params[0].doInBackgroundCallback.run(this, params[0]);
  85         return params[0];
  86     }
  87 
  88     @Override
  89     protected void onPostExecute(AsyncTaskPageData result) {
  90         // All the widget previews are loaded, so we can just callback to inflate the page
  91         result.postExecuteCallback.run(this, result);
  92     }
  93 
  94     void setThreadPriority(int p) {
  95         threadPriority = p;
  96     }
  97 
  98     void syncThreadPriority() {
  99         Process.setThreadPriority(threadPriority);
 100     }
 101 
 102     // The page that this async task is associated with
 103     AsyncTaskPageData.Type dataType;
 104 
 105     int page;
 106 
 107     int threadPriority;
 108 }
 109 
 110 /**
 111  * The Apps/Customize page that displays all the applications, widgets, and shortcuts.
 112  */
<abbr title=" 113 public class AppsCustomizePagedView extends PagedViewWithDraggableItems implements View.OnClickListener , View.OnKeyListener , DragSource , PagedViewIcon.PressedCallback , PagedViewWidget.ShortPressListener , LauncherTransitionable {"> 113 public class AppsCustomizePagedView extends PagedViewWithDraggableItems implements View.OnClickListener ,</abbr>
 114     static final String TAG = &quot;AppsCustomizePagedView&quot;;
 115 
 116     /**
 117      * The different content types that this paged view can show.
 118      */
 119     public enum ContentType {
 120 
 121         Applications,
 122         Widgets;}
 123 
 124     // Refs
 125     // Refs
 126     private Launcher mLauncher;
 127 
 128     private DragController mDragController;
 129 
 130     private final LayoutInflater mLayoutInflater;
 131 
 132     private final PackageManager mPackageManager;
 133 
 134     // Save and Restore
 135     // Save and Restore
 136     private int mSaveInstanceStateItemIndex = -1;
 137 
 138     private PagedViewIcon mPressedIcon;
 139 
 140     // Content
 141     // Content
 142     private ArrayList&lt;ApplicationInfo&gt; mApps;
 143 
 144     private ArrayList&lt;Object&gt; mWidgets;
 145 
 146     // Cling
 147     // Cling
 148     private boolean mHasShownAllAppsCling;
 149 
 150     private int mClingFocusedX;
 151 
 152     private int mClingFocusedY;
 153 
 154     // Caching
 155     // Caching
 156     private Canvas mCanvas;
 157 
 158     private IconCache mIconCache;
 159 
 160     // Dimens
 161     // Dimens
 162     private int mContentWidth;
 163 
 164     private int mAppIconSize;
 165 
 166     private int mMaxAppCellCountX;
 167 
 168     private int mMaxAppCellCountY;
 169 
 170     private int mWidgetCountX;
 171 
 172     private int mWidgetCountY;
 173 
 174     private int mWidgetWidthGap;
 175 
 176     private int mWidgetHeightGap;
 177 
 178     private final float sWidgetPreviewIconPaddingPercentage = 0.25f;
 179 
 180     private PagedViewCellLayout mWidgetSpacingLayout;
 181 
 182     private int mNumAppsPages;
 183 
 184     private int mNumWidgetPages;
 185 
 186     // Relating to the scroll and overscroll effects
 187     // Relating to the scroll and overscroll effects
 188     Workspace.ZInterpolator mZInterpolator = new Workspace.ZInterpolator(0.5f);
 189 
 190     private static float CAMERA_DISTANCE = 6500;
 191 
 192     private static float TRANSITION_SCALE_FACTOR = 0.74f;
 193 
 194     private static float TRANSITION_PIVOT = 0.65f;
 195 
 196     private static float TRANSITION_MAX_ROTATION = 22;
 197 
 198     private static final boolean PERFORM_OVERSCROLL_ROTATION = true;
 199 
 200     private AccelerateInterpolator mAlphaInterpolator = new AccelerateInterpolator(0.9f);
 201 
 202     private DecelerateInterpolator mLeftScreenAlphaInterpolator = new DecelerateInterpolator(4);
 203 
 204     // Previews &amp; outlines
 205     // Previews &amp; outlines
 206     ArrayList&lt;AppsCustomizeAsyncTask&gt; mRunningTasks;
 207 
 208     private static final int sPageSleepDelay = 200;
 209 
 210     private Runnable mInflateWidgetRunnable = null;
 211 
 212     private Runnable mBindWidgetRunnable = null;
 213 
 214     static final int WIDGET_NO_CLEANUP_REQUIRED = -1;
 215 
 216     static final int WIDGET_PRELOAD_PENDING = 0;
 217 
 218     static final int WIDGET_BOUND = 1;
 219 
 220     static final int WIDGET_INFLATED = 2;
 221 
 222     int mWidgetCleanupState = WIDGET_NO_CLEANUP_REQUIRED;
 223 
 224     int mWidgetLoadingId = -1;
 225 
 226     PendingAddWidgetInfo mCreateWidgetInfo = null;
 227 
 228     private boolean mDraggingWidget = false;
 229 
 230     private Toast mWidgetInstructionToast;
 231 
 232     // Deferral of loading widget previews during launcher transitions
 233     // Deferral of loading widget previews during launcher transitions
 234     private boolean mInTransition;
 235 
 236     private ArrayList&lt;AsyncTaskPageData&gt; mDeferredSyncWidgetPageItems =
 237         new ArrayList&lt;AsyncTaskPageData&gt;();
 238 
 239     private ArrayList&lt;Runnable&gt; mDeferredPrepareLoadWidgetPreviewsTasks =
 240         new ArrayList&lt;Runnable&gt;();
 241 
 242     // Used for drawing shortcut previews
 243     // Used for drawing shortcut previews
 244     BitmapCache mCachedShortcutPreviewBitmap = new BitmapCache();
 245 
 246     PaintCache mCachedShortcutPreviewPaint = new PaintCache();
 247 
 248     CanvasCache mCachedShortcutPreviewCanvas = new CanvasCache();
 249 
 250     // Used for drawing widget previews
 251     // Used for drawing widget previews
 252     CanvasCache mCachedAppWidgetPreviewCanvas = new CanvasCache();
 253 
 254     RectCache mCachedAppWidgetPreviewSrcRect = new RectCache();
 255 
 256     RectCache mCachedAppWidgetPreviewDestRect = new RectCache();
 257 
 258     PaintCache mCachedAppWidgetPreviewPaint = new PaintCache();
 259 
 260     public AppsCustomizePagedView(Context context, AttributeSet attrs) {
 261         super(context, attrs);
 262         mLayoutInflater = LayoutInflater.from(context);
 263         mPackageManager = context.getPackageManager();
 264         mApps = new ArrayList&lt;ApplicationInfo&gt;();
 265         mWidgets = new ArrayList&lt;Object&gt;();
 266         mIconCache = ((LauncherApplication) (context.getApplicationContext())).getIconCache();
 267         mCanvas = new Canvas();
 268         mRunningTasks = new ArrayList&lt;AppsCustomizeAsyncTask&gt;();
 269         // Save the default widget preview background
 270         Resources resources = context.getResources();
 271         mAppIconSize = resources.getDimensionPixelSize(R.dimen.app_icon_size);
 272         TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.AppsCustomizePagedView, 0, 0);
 273         mMaxAppCellCountX = a.getInt(R.styleable.AppsCustomizePagedView_maxAppCellCountX, -1);
 274         mMaxAppCellCountY = a.getInt(R.styleable.AppsCustomizePagedView_maxAppCellCountY, -1);
<abbr title=" 275         mWidgetWidthGap = a.getDimensionPixelSize(R.styleable.AppsCustomizePagedView_widgetCellWidthGap, 0);"> 275         mWidgetWidthGap = a.getDimensionPixelSize(R.styleable.AppsCustomizePagedView_widgetCellWidthGap, </abbr>
<abbr title=" 276         mWidgetHeightGap = a.getDimensionPixelSize(R.styleable.AppsCustomizePagedView_widgetCellHeightGap, 0);"> 276         mWidgetHeightGap = a.getDimensionPixelSize(R.styleable.AppsCustomizePagedView_widgetCellHeightGap</abbr>
 277         mWidgetCountX = a.getInt(R.styleable.AppsCustomizePagedView_widgetCountX, 2);
 278         mWidgetCountY = a.getInt(R.styleable.AppsCustomizePagedView_widgetCountY, 2);
 279         mClingFocusedX = a.getInt(R.styleable.AppsCustomizePagedView_clingFocusedX, 0);
 280         mClingFocusedY = a.getInt(R.styleable.AppsCustomizePagedView_clingFocusedY, 0);
 281         a.recycle();
 282         mWidgetSpacingLayout = new PagedViewCellLayout(getContext());
 283         // The padding on the non-matched dimension for the default widget preview icons
 284         // (top + bottom)
 285         mFadeInAdjacentScreens = false;
 286         // Unless otherwise specified this view is important for accessibility.
 287         if (getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
 288             setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
 289         }
 290     }
 291 
 292     @Override
 293     protected void init() {
 294         super.init();
 295         mCenterPagesVertically = false;
 296 
 297         Context context = getContext();
 298         Resources r = context.getResources();
 299         setDragSlopeThreshold(r.getInteger(R.integer.config_appsCustomizeDragSlopeThreshold)/100f);
 300     }
 301 
 302     @Override
 303     protected void onUnhandledTap(MotionEvent ev) {
 304         if (LauncherApplication.isScreenLarge()) {
 305             // Dismiss AppsCustomize if we tap
 306             mLauncher.showWorkspace(true);
 307         }
 308     }
 309 
 310     /** Returns the item index of the center item on this page so that we can restore to this
 311      *  item index when we rotate. */
 312     private int getMiddleComponentIndexOnCurrentPage() {
 313         int i = -1;
 314         if (getPageCount() &gt; 0) {
 315             int currentPage = getCurrentPage();
 316             if (currentPage &lt; mNumAppsPages) {
 317                 PagedViewCellLayout layout = (PagedViewCellLayout) getPageAt(currentPage);
 318                 PagedViewCellLayoutChildren childrenLayout = layout.getChildrenLayout();
 319                 int numItemsPerPage = mCellCountX * mCellCountY;
 320                 int childCount = childrenLayout.getChildCount();
 321                 if (childCount &gt; 0) {
 322                     i = (currentPage * numItemsPerPage) + (childCount / 2);
 323                 }
 324             } else {
 325                 int numApps = mApps.size();
 326                 PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(currentPage);
 327                 int numItemsPerPage = mWidgetCountX * mWidgetCountY;
 328                 int childCount = layout.getChildCount();
 329                 if (childCount &gt; 0) {
 330                     i = numApps +
 331                         ((currentPage - mNumAppsPages) * numItemsPerPage) + (childCount / 2);
 332                 }
 333             }
 334         }
 335         return i;
 336     }
 337 
 338     /** Get the index of the item to restore to if we need to restore the current page. */
 339     int getSaveInstanceStateIndex() {
 340         if (mSaveInstanceStateItemIndex == -1) {
 341             mSaveInstanceStateItemIndex = getMiddleComponentIndexOnCurrentPage();
 342         }
 343         return mSaveInstanceStateItemIndex;
 344     }
 345 
 346     /** Returns the page in the current orientation which is expected to contain the specified
 347      *  item index. */
 348     int getPageForComponent(int index) {
 349         if (index &lt; 0) return 0;
 350 
 351         if (index &lt; mApps.size()) {
 352             int numItemsPerPage = mCellCountX * mCellCountY;
 353             return (index / numItemsPerPage);
 354         } else {
 355             int numItemsPerPage = mWidgetCountX * mWidgetCountY;
 356             return mNumAppsPages + ((index - mApps.size()) / numItemsPerPage);
 357         }
 358     }
 359 
 360     /** Restores the page for an item at the specified index */
 361     void restorePageForIndex(int index) {
 362         if (index &lt; 0) return;
 363         mSaveInstanceStateItemIndex = index;
 364     }
 365 
 366     private void updatePageCounts() {
 367         mNumWidgetPages = (int) Math.ceil(mWidgets.size() /
 368                 (float) (mWidgetCountX * mWidgetCountY));
 369         mNumAppsPages = (int) Math.ceil((float) mApps.size() / (mCellCountX * mCellCountY));
 370     }
 371 
 372     protected void onDataReady(int width, int height) {
 373         // Note that we transpose the counts in portrait so that we get a similar layout
 374         boolean isLandscape = getResources().getConfiguration().orientation ==
 375             Configuration.ORIENTATION_LANDSCAPE;
 376         int maxCellCountX = Integer.MAX_VALUE;
 377         int maxCellCountY = Integer.MAX_VALUE;
 378         if (LauncherApplication.isScreenLarge()) {
 379             maxCellCountX = (isLandscape ? LauncherModel.getCellCountX() :
 380                 LauncherModel.getCellCountY());
 381             maxCellCountY = (isLandscape ? LauncherModel.getCellCountY() :
 382                 LauncherModel.getCellCountX());
 383         }
 384         if (mMaxAppCellCountX &gt; -1) {
 385             maxCellCountX = Math.min(maxCellCountX, mMaxAppCellCountX);
 386         }
 387         if (mMaxAppCellCountY &gt; -1) {
 388             maxCellCountY = Math.min(maxCellCountY, mMaxAppCellCountY);
 389         }
 390 
 391         // Now that the data is ready, we can calculate the content width, the number of cells to
 392         // use for each page
 393         mWidgetSpacingLayout.setGap(mPageLayoutWidthGap, mPageLayoutHeightGap);
 394         mWidgetSpacingLayout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
 395                 mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
 396         mWidgetSpacingLayout.calculateCellCount(width, height, maxCellCountX, maxCellCountY);
 397         mCellCountX = mWidgetSpacingLayout.getCellCountX();
 398         mCellCountY = mWidgetSpacingLayout.getCellCountY();
 399         updatePageCounts();
 400 
 401         // Force a measure to update recalculate the gaps
 402         int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
 403         int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
 404         mWidgetSpacingLayout.measure(widthSpec, heightSpec);
 405         mContentWidth = mWidgetSpacingLayout.getContentWidth();
 406 
 407         AppsCustomizeTabHost host = (AppsCustomizeTabHost) getTabHost();
 408         final boolean hostIsTransitioning = host.isTransitioning();
 409 
 410         // Restore the page
 411         int page = getPageForComponent(mSaveInstanceStateItemIndex);
 412         invalidatePageData(Math.max(0, page), hostIsTransitioning);
 413 
 414         // Show All Apps cling if we are finished transitioning, otherwise, we will try again when
 415         // the transition completes in AppsCustomizeTabHost (otherwise the wrong offsets will be
 416         // returned while animating)
 417         if (!hostIsTransitioning) {
 418             post(new Runnable() {
 419                 @Override
 420                 public void run() {
 421                     showAllAppsCling();
 422                 }
 423             });
 424         }
 425     }
 426 
 427     void showAllAppsCling() {
 428         if (!mHasShownAllAppsCling &amp;&amp; isDataReady()) {
 429             mHasShownAllAppsCling = true;
 430             // Calculate the position for the cling punch through
 431             int[] offset = new int[2];
 432             int[] pos = mWidgetSpacingLayout.estimateCellPosition(mClingFocusedX, mClingFocusedY);
 433             mLauncher.getDragLayer().getLocationInDragLayer(this, offset);
 434             // PagedViews are centered horizontally but top aligned
 435             pos[0] += (getMeasuredWidth() - mWidgetSpacingLayout.getMeasuredWidth()) / 2 +
 436                     offset[0];
 437             pos[1] += offset[1];
 438             mLauncher.showFirstRunAllAppsCling(pos);
 439         }
 440     }
 441 
 442     @Override
 443     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 444         int width = MeasureSpec.getSize(widthMeasureSpec);
 445         int height = MeasureSpec.getSize(heightMeasureSpec);
 446         if (!isDataReady()) {
 447             if (!mApps.isEmpty() &amp;&amp; !mWidgets.isEmpty()) {
 448                 setDataIsReady();
 449                 setMeasuredDimension(width, height);
 450                 onDataReady(width, height);
 451             }
 452         }
 453 
 454         super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 455     }
 456 
 457     public void onPackagesUpdated() {
 458         // Get the list of widgets and shortcuts
 459         mWidgets.clear();
<abbr title=" 460         List&lt;AppWidgetProviderInfo&gt; widgets = AppWidgetManager.getInstance(mLauncher).getInstalledProviders();"> 460         List&lt;AppWidgetProviderInfo&gt; widgets = AppWidgetManager.getInstance(mLauncher).getInstalledProvide</abbr>
 461         Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
 462         List&lt;ResolveInfo&gt; shortcuts = mPackageManager.queryIntentActivities(shortcutsIntent, 0);
 463         for (AppWidgetProviderInfo widget : widgets) {
 464             if ((widget.minWidth &gt; 0) &amp;&amp; (widget.minHeight &gt; 0)) {
 465                 // Ensure that all widgets we show can be added on a workspace of this size
 466                 int[] spanXY = Launcher.getSpanForWidget(mLauncher, widget);
 467                 int[] minSpanXY = Launcher.getMinSpanForWidget(mLauncher, widget);
 468                 int minSpanX = Math.min(spanXY[0], minSpanXY[0]);
 469                 int minSpanY = Math.min(spanXY[1], minSpanXY[1]);
<abbr title=" 470                 if ((minSpanX &lt;= LauncherModel.getCellCountX()) &amp;&amp; (minSpanY &lt;= LauncherModel.getCellCountY())) {"> 470                 if ((minSpanX &lt;= LauncherModel.getCellCountX()) &amp;&amp; (minSpanY &lt;= LauncherModel.getCellCoun</abbr>
 471                     mWidgets.add(widget);
 472                 } else {
<abbr title=" 473                     Log.e(TAG, (((((&quot;Widget &quot; + widget.provider) + &quot; can not fit on this device (&quot;) + widget.minWidth) + &quot;, &quot;) + widget.minHeight) + &quot;)&quot;);"> 473                     Log.e(TAG, (((((&quot;Widget &quot; + widget.provider) + &quot; can not fit on this device (&quot;) + wid</abbr>
 474                 }
 475             } else {
<abbr title=" 476                 Log.e(TAG, (((((&quot;Widget &quot; + widget.provider) + &quot; has invalid dimensions (&quot;) + widget.minWidth) + &quot;, &quot;) + widget.minHeight) + &quot;)&quot;);"> 476                 Log.e(TAG, (((((&quot;Widget &quot; + widget.provider) + &quot; has invalid dimensions (&quot;) + widget.minW</abbr>
 477             }
 478         }
 479         mWidgets.addAll(shortcuts);
 480         Collections.sort(mWidgets, new LauncherModel.WidgetAndShortcutNameComparator(mPackageManager));
 481         updatePageCounts();
 482         invalidateOnDataChange();
 483     }
 484 
 485     @Override
 486     public void onClick(View v) {
 487         // When we have exited all apps or are in transition, disregard clicks
 488         if ((!mLauncher.isAllAppsVisible()) || mLauncher.getWorkspace().isSwitchingState()) {
 489             return;
 490         }
 491         if (v instanceof PagedViewIcon) {
 492             // Animate some feedback to the click
 493             final ApplicationInfo appInfo = ((ApplicationInfo) (v.getTag()));
 494             // Lock the drawable state to pressed until we return to Launcher
 495             if (mPressedIcon != null) {
 496                 mPressedIcon.lockDrawableState();
 497             }
 498             // NOTE: We want all transitions from launcher to act as if the wallpaper were enabled
 499             // to be consistent.  So re-enable the flag here, and we will re-disable it as necessary
 500             // when Launcher resumes and we are still in AllApps.
 501             mLauncher.updateWallpaperVisibility(true);
 502             mLauncher.startActivitySafely(v, appInfo.intent, appInfo);
 503         } else if (v instanceof PagedViewWidget) {
 504             // Let the user know that they have to long press to add a widget
 505             if (mWidgetInstructionToast != null) {
 506                 mWidgetInstructionToast.cancel();
 507             }
<abbr title=" 508             mWidgetInstructionToast = Toast.makeText(getContext(), R.string.long_press_widget_to_add, Toast.LENGTH_SHORT);"> 508             mWidgetInstructionToast = Toast.makeText(getContext(), R.string.long_press_widget_to_add, Toa</abbr>
 509             mWidgetInstructionToast.show();
 510             // Create a little animation to show that the widget can move
 511             float offsetY = getResources().getDimensionPixelSize(R.dimen.dragViewOffsetY);
 512             final ImageView p = ((ImageView) (v.findViewById(R.id.widget_preview)));
 513             AnimatorSet bounce = LauncherAnimUtils.createAnimatorSet();
 514             ValueAnimator tyuAnim = LauncherAnimUtils.ofFloat(p, &quot;translationY&quot;, offsetY);
 515             tyuAnim.setDuration(125);
 516             ValueAnimator tydAnim = LauncherAnimUtils.ofFloat(p, &quot;translationY&quot;, 0.0F);
 517             tydAnim.setDuration(100);
 518             bounce.play(tyuAnim).before(tydAnim);
 519             bounce.setInterpolator(new AccelerateInterpolator());
 520             bounce.start();
 521         }
 522     }
 523 
 524     public boolean onKey(View v, int keyCode, KeyEvent event) {
 525         return FocusHelper.handleAppsCustomizeKeyEvent(v,  keyCode, event);
 526     }
 527 
 528     /*
 529      * PagedViewWithDraggableItems implementation
 530      */
 531     @Override
 532     protected void determineDraggingStart(android.view.MotionEvent ev) {
 533         // Disable dragging by pulling an app down for now.
 534     }
 535 
 536     private void beginDraggingApplication(View v) {
 537         mLauncher.getWorkspace().onDragStartedWithItem(v);
 538         mLauncher.getWorkspace().beginDragShared(v, this);
 539     }
 540 
 541     private void preloadWidget(final PendingAddWidgetInfo info) {
 542         final AppWidgetProviderInfo pInfo = info.info;
 543         if (pInfo.configure != null) {
 544             return;
 545         }
 546 
 547         mWidgetCleanupState = WIDGET_PRELOAD_PENDING;
 548         mBindWidgetRunnable = new Runnable() {
 549             @Override
 550             public void run() {
 551                 mWidgetLoadingId = mLauncher.getAppWidgetHost().allocateAppWidgetId();
 552                 if (AppWidgetManager.getInstance(mLauncher)
 553                             .bindAppWidgetIdIfAllowed(mWidgetLoadingId, info.componentName)) {
 554                     mWidgetCleanupState = WIDGET_BOUND;
 555                 }
 556             }
 557         };
 558         post(mBindWidgetRunnable);
 559 
 560         mInflateWidgetRunnable = new Runnable() {
 561             @Override
 562             public void run() {
 563                 AppWidgetHostView hostView = mLauncher.
 564                         getAppWidgetHost().createView(getContext(), mWidgetLoadingId, pInfo);
 565                 info.boundWidget = hostView;
 566                 mWidgetCleanupState = WIDGET_INFLATED;
 567                 hostView.setVisibility(INVISIBLE);
 568                 int[] unScaledSize = mLauncher.getWorkspace().estimateItemSize(info.spanX,
 569                         info.spanY, info, false);
 570 
 571                 // We want the first widget layout to be the correct size. This will be important
 572                 // for width size reporting to the AppWidgetManager.
 573                 DragLayer.LayoutParams lp = new DragLayer.LayoutParams(unScaledSize[0],
 574                         unScaledSize[1]);
 575                 lp.x = lp.y = 0;
 576                 lp.customPosition = true;
 577                 hostView.setLayoutParams(lp);
 578                 mLauncher.getDragLayer().addView(hostView);
 579             }
 580         };
 581         post(mInflateWidgetRunnable);
 582     }
 583 
 584     @Override
 585     public void onShortPress(View v) {
 586         // We are anticipating a long press, and we use this time to load bind and instantiate
 587         // the widget. This will need to be cleaned up if it turns out no long press occurs.
 588         if (mCreateWidgetInfo != null) {
 589             // Just in case the cleanup process wasn&#x27;t properly executed. This shouldn&#x27;t happen.
 590             cleanupWidgetPreloading(false);
 591         }
 592         mCreateWidgetInfo = new PendingAddWidgetInfo((PendingAddWidgetInfo) v.getTag());
 593         preloadWidget(mCreateWidgetInfo);
 594     }
 595 
 596     private void cleanupWidgetPreloading(boolean widgetWasAdded) {
 597         if (!widgetWasAdded) {
 598             // If the widget was not added, we may need to do further cleanup.
 599             PendingAddWidgetInfo info = mCreateWidgetInfo;
 600             mCreateWidgetInfo = null;
 601 
 602             if (mWidgetCleanupState == WIDGET_PRELOAD_PENDING) {
 603                 // We never did any preloading, so just remove pending callbacks to do so
 604                 removeCallbacks(mBindWidgetRunnable);
 605                 removeCallbacks(mInflateWidgetRunnable);
 606             } else if (mWidgetCleanupState == WIDGET_BOUND) {
 607                  // Delete the widget id which was allocated
 608                 if (mWidgetLoadingId != -1) {
 609                     mLauncher.getAppWidgetHost().deleteAppWidgetId(mWidgetLoadingId);
 610                 }
 611 
 612                 // We never got around to inflating the widget, so remove the callback to do so.
 613                 removeCallbacks(mInflateWidgetRunnable);
 614             } else if (mWidgetCleanupState == WIDGET_INFLATED) {
 615                 // Delete the widget id which was allocated
 616                 if (mWidgetLoadingId != -1) {
 617                     mLauncher.getAppWidgetHost().deleteAppWidgetId(mWidgetLoadingId);
 618                 }
 619 
 620                 // The widget was inflated and added to the DragLayer -- remove it.
 621                 AppWidgetHostView widget = info.boundWidget;
 622                 mLauncher.getDragLayer().removeView(widget);
 623             }
 624         }
 625         mWidgetCleanupState = WIDGET_NO_CLEANUP_REQUIRED;
 626         mWidgetLoadingId = -1;
 627         mCreateWidgetInfo = null;
 628         PagedViewWidget.resetShortPressTarget();
 629     }
 630 
 631     @Override
 632     public void cleanUpShortPress(View v) {
 633         if (!mDraggingWidget) {
 634             cleanupWidgetPreloading(false);
 635         }
 636     }
 637 
 638     private boolean beginDraggingWidget(View v) {
 639         mDraggingWidget = true;
 640         // Get the widget preview as the drag representation
 641         ImageView image = ((ImageView) (v.findViewById(R.id.widget_preview)));
 642         PendingAddItemInfo createItemInfo = ((PendingAddItemInfo) (v.getTag()));
 643         // If the ImageView doesn&#x27;t have a drawable yet, the widget preview hasn&#x27;t been loaded and
 644         // we abort the drag.
 645         if (image.getDrawable() == null) {
 646             mDraggingWidget = false;
 647             return false;
 648         }
 649         // Compose the drag image
 650         Bitmap preview;
 651         Bitmap outline;
 652         float scale = 1.0F;
 653         if (createItemInfo instanceof PendingAddWidgetInfo) {
 654             // This can happen in some weird cases involving multi-touch. We can&#x27;t start dragging
 655             // the widget if this is null, so we break out.
 656             if (mCreateWidgetInfo == null) {
 657                 return false;
 658             }
 659             PendingAddWidgetInfo createWidgetInfo = mCreateWidgetInfo;
 660             createItemInfo = createWidgetInfo;
 661             int spanX = createItemInfo.spanX;
 662             int spanY = createItemInfo.spanY;
 663             int[] size = mLauncher.getWorkspace().estimateItemSize(spanX, spanY, createWidgetInfo, true);
 664             FastBitmapDrawable previewDrawable = ((FastBitmapDrawable) (image.getDrawable()));
 665             float minScale = 1.25F;
 666             int maxWidth;
 667             int maxHeight;
 668             maxWidth = Math.min(((int) (previewDrawable.getIntrinsicWidth() * minScale)), size[0]);
 669             maxHeight = Math.min(((int) (previewDrawable.getIntrinsicHeight() * minScale)), size[1]);
<abbr title=" 670             preview = getWidgetPreview(createWidgetInfo.componentName, createWidgetInfo.previewImage, createWidgetInfo.icon, spanX, spanY, maxWidth, maxHeight);"> 670             preview = getWidgetPreview(createWidgetInfo.componentName, createWidgetInfo.previewImage, cre</abbr>
 671             // Determine the image view drawable scale relative to the preview
 672             float[] mv = new float[9];
 673             Matrix m = new Matrix();
<abbr title=" 674             m.setRectToRect(new RectF(0.0F, 0.0F, ((float) (preview.getWidth())), ((float) (preview.getHeight()))), new RectF(0.0F, 0.0F, ((float) (previewDrawable.getIntrinsicWidth())), ((float) (previewDrawable.getIntrinsicHeight()))), Matrix.ScaleToFit.START);"> 674             m.setRectToRect(new RectF(0.0F, 0.0F, ((float) (preview.getWidth())), ((float) (preview.getHe</abbr>
 675             m.getValues(mv);
 676             scale = ((float) (mv[0]));
 677         } else {
 678             PendingAddShortcutInfo createShortcutInfo = ((PendingAddShortcutInfo) (v.getTag()));
 679             Drawable icon = mIconCache.getFullResIcon(createShortcutInfo.shortcutActivityInfo);
<abbr title=" 680             preview = Bitmap.createBitmap(icon.getIntrinsicWidth(), icon.getIntrinsicHeight(), Bitmap.Config.ARGB_8888);"> 680             preview = Bitmap.createBitmap(icon.getIntrinsicWidth(), icon.getIntrinsicHeight(), Bitmap.Con</abbr>
 681             mCanvas.setBitmap(preview);
 682             mCanvas.save();
<abbr title=" 683             renderDrawableToBitmap(icon, preview, 0, 0, icon.getIntrinsicWidth(), icon.getIntrinsicHeight());"> 683             renderDrawableToBitmap(icon, preview, 0, 0, icon.getIntrinsicWidth(), icon.getIntrinsicHeight</abbr>
 684             mCanvas.restore();
 685             mCanvas.setBitmap(null);
 686             createItemInfo.spanX = createItemInfo.spanY = 1;
 687         }
 688         // Don&#x27;t clip alpha values for the drag outline if we&#x27;re using the default widget preview
<abbr title=" 689         boolean clipAlpha = !((createItemInfo instanceof PendingAddWidgetInfo) &amp;&amp; (((PendingAddWidgetInfo) (createItemInfo)).previewImage == 0));"> 689         boolean clipAlpha = !((createItemInfo instanceof PendingAddWidgetInfo) &amp;&amp; (((PendingAddWidgetInfo</abbr>
 690         // Save the preview for the outline generation, then dim the preview
 691         outline = Bitmap.createScaledBitmap(preview, preview.getWidth(), preview.getHeight(), false);
 692         // Start the drag
 693         mLauncher.lockScreenOrientation();
 694         mLauncher.getWorkspace().onDragStartedWithItem(createItemInfo, outline, clipAlpha);
<abbr title=" 695         mDragController.startDrag(image, preview, this, createItemInfo, DragController.DRAG_ACTION_COPY, null, scale);"> 695         mDragController.startDrag(image, preview, this, createItemInfo, DragController.DRAG_ACTION_COPY, </abbr>
 696         outline.recycle();
 697         preview.recycle();
 698         return true;
 699     }
 700 
 701     @Override
 702     protected boolean beginDragging(final View v) {
 703         if (!super.beginDragging(v)) return false;
 704 
 705         if (v instanceof PagedViewIcon) {
 706             beginDraggingApplication(v);
 707         } else if (v instanceof PagedViewWidget) {
 708             if (!beginDraggingWidget(v)) {
 709                 return false;
 710             }
 711         }
 712 
 713         // We delay entering spring-loaded mode slightly to make sure the UI
 714         // thready is free of any work.
 715         postDelayed(new Runnable() {
 716             @Override
 717             public void run() {
 718                 // We don&#x27;t enter spring-loaded mode if the drag has been cancelled
 719                 if (mLauncher.getDragController().isDragging()) {
 720                     // Dismiss the cling
 721                     mLauncher.dismissAllAppsCling(null);
 722 
 723                     // Reset the alpha on the dragged icon before we drag
 724                     resetDrawableState();
 725 
 726                     // Go into spring loaded mode (must happen before we startDrag())
 727                     mLauncher.enterSpringLoadedDragMode();
 728                 }
 729             }
 730         }, 150);
 731 
 732         return true;
 733     }
 734 
 735     /**
 736      * Clean up after dragging.
 737      *
 738      * @param target where the item was dragged to (can be null if the item was flung)
 739      */
 740     private void endDragging(View target, boolean isFlingToDelete, boolean success) {
 741         if (isFlingToDelete || !success || (target != mLauncher.getWorkspace() &amp;&amp;
 742                 !(target instanceof DeleteDropTarget))) {
 743             // Exit spring loaded mode if we have not successfully dropped or have not handled the
 744             // drop in Workspace
 745             mLauncher.exitSpringLoadedDragMode();
 746         }
 747         mLauncher.unlockScreenOrientation(false);
 748     }
 749 
 750     @Override
 751     public View getContent() {
 752         return null;
 753     }
 754 
 755     @Override
 756     public void onLauncherTransitionPrepare(Launcher l, boolean animated, boolean toWorkspace) {
 757         mInTransition = true;
 758         if (toWorkspace) {
 759             cancelAllTasks();
 760         }
 761     }
 762 
 763     @Override
 764     public void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace) {
 765     }
 766 
 767     @Override
 768     public void onLauncherTransitionStep(Launcher l, float t) {
 769     }
 770 
 771     @Override
 772     public void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace) {
 773         mInTransition = false;
 774         for (AsyncTaskPageData d : mDeferredSyncWidgetPageItems) {
 775             onSyncWidgetPageItems(d);
 776         }
 777         mDeferredSyncWidgetPageItems.clear();
 778         for (Runnable r : mDeferredPrepareLoadWidgetPreviewsTasks) {
 779             r.run();
 780         }
 781         mDeferredPrepareLoadWidgetPreviewsTasks.clear();
 782         mForceDrawAllChildrenNextFrame = !toWorkspace;
 783     }
 784 
 785     @Override
 786     public void onDropCompleted(View target, DragObject d, boolean isFlingToDelete,
 787             boolean success) {
 788         // Return early and wait for onFlingToDeleteCompleted if this was the result of a fling
 789         if (isFlingToDelete) return;
 790 
 791         endDragging(target, false, success);
 792 
 793         // Display an error message if the drag failed due to there not being enough space on the
 794         // target layout we were dropping on.
 795         if (!success) {
 796             boolean showOutOfSpaceMessage = false;
 797             if (target instanceof Workspace) {
 798                 int currentScreen = mLauncher.getCurrentWorkspaceScreen();
 799                 Workspace workspace = (Workspace) target;
 800                 CellLayout layout = (CellLayout) workspace.getChildAt(currentScreen);
 801                 ItemInfo itemInfo = (ItemInfo) d.dragInfo;
 802                 if (layout != null) {
 803                     layout.calculateSpans(itemInfo);
 804                     showOutOfSpaceMessage =
 805                             !layout.findCellForSpan(null, itemInfo.spanX, itemInfo.spanY);
 806                 }
 807             }
 808             if (showOutOfSpaceMessage) {
 809                 mLauncher.showOutOfSpaceMessage(false);
 810             }
 811 
 812             d.deferDragViewCleanupPostAnimation = false;
 813         }
 814         cleanupWidgetPreloading(success);
 815         mDraggingWidget = false;
 816     }
 817 
 818     @Override
 819     public void onFlingToDeleteCompleted() {
 820         // We just dismiss the drag when we fling, so cleanup here
 821         endDragging(null, true, true);
 822         cleanupWidgetPreloading(false);
 823         mDraggingWidget = false;
 824     }
 825 
 826     @Override
 827     public boolean supportsFlingToDelete() {
 828         return true;
 829     }
 830 
 831     @Override
 832     protected void onDetachedFromWindow() {
 833         super.onDetachedFromWindow();
 834         cancelAllTasks();
 835     }
 836 
 837     public void clearAllWidgetPages() {
 838         cancelAllTasks();
 839         int count = getChildCount();
 840         for (int i = 0; i &lt; count; i++) {
 841             View v = getPageAt(i);
 842             if (v instanceof PagedViewGridLayout) {
 843                 ((PagedViewGridLayout) v).removeAllViewsOnPage();
 844                 mDirtyPageContent.set(i, true);
 845             }
 846         }
 847     }
 848 
 849     private void cancelAllTasks() {
 850         // Clean up all the async tasks
 851         Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
 852         while (iter.hasNext()) {
 853             AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
 854             task.cancel(false);
 855             iter.remove();
 856             mDirtyPageContent.set(task.page, true);
 857 
 858             // We&#x27;ve already preallocated the views for the data to load into, so clear them as well
 859             View v = getPageAt(task.page);
 860             if (v instanceof PagedViewGridLayout) {
 861                 ((PagedViewGridLayout) v).removeAllViewsOnPage();
 862             }
 863         }
 864         mDeferredSyncWidgetPageItems.clear();
 865         mDeferredPrepareLoadWidgetPreviewsTasks.clear();
 866     }
 867 
 868     public void setContentType(ContentType type) {
 869         if (type == ContentType.Widgets) {
 870             invalidatePageData(mNumAppsPages, true);
 871         } else if (type == ContentType.Applications) {
 872             invalidatePageData(0, true);
 873         }
 874     }
 875 
 876     protected void snapToPage(int whichPage, int delta, int duration) {
 877         super.snapToPage(whichPage, delta, duration);
 878         updateCurrentTab(whichPage);
 879 
 880         // Update the thread priorities given the direction lookahead
 881         Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
 882         while (iter.hasNext()) {
 883             AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
 884             int pageIndex = task.page;
 885             if ((mNextPage &gt; mCurrentPage &amp;&amp; pageIndex &gt;= mCurrentPage) ||
 886                 (mNextPage &lt; mCurrentPage &amp;&amp; pageIndex &lt;= mCurrentPage)) {
 887                 task.setThreadPriority(getThreadPriorityForPage(pageIndex));
 888             } else {
 889                 task.setThreadPriority(Process.THREAD_PRIORITY_LOWEST);
 890             }
 891         }
 892     }
 893 
 894     private void updateCurrentTab(int currentPage) {
 895         AppsCustomizeTabHost tabHost = getTabHost();
 896         if (tabHost != null) {
 897             String tag = tabHost.getCurrentTabTag();
 898             if (tag != null) {
 899                 if (currentPage &gt;= mNumAppsPages &amp;&amp;
 900                         !tag.equals(tabHost.getTabTagForContentType(ContentType.Widgets))) {
 901                     tabHost.setCurrentTabFromContent(ContentType.Widgets);
 902                 } else if (currentPage &lt; mNumAppsPages &amp;&amp;
 903                         !tag.equals(tabHost.getTabTagForContentType(ContentType.Applications))) {
 904                     tabHost.setCurrentTabFromContent(ContentType.Applications);
 905                 }
 906             }
 907         }
 908     }
 909 
 910     /*
 911      * Apps PagedView implementation
 912      */
 913     private void setVisibilityOnChildren(ViewGroup layout, int visibility) {
 914         int childCount = layout.getChildCount();
 915         for (int i = 0; i &lt; childCount; ++i) {
 916             layout.getChildAt(i).setVisibility(visibility);
 917         }
 918     }
 919 
 920     private void setupPage(PagedViewCellLayout layout) {
 921         layout.setCellCount(mCellCountX, mCellCountY);
 922         layout.setGap(mPageLayoutWidthGap, mPageLayoutHeightGap);
 923         layout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
 924                 mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
 925 
 926         // Note: We force a measure here to get around the fact that when we do layout calculations
 927         // immediately after syncing, we don&#x27;t have a proper width.  That said, we already know the
 928         // expected page width, so we can actually optimize by hiding all the TextView-based
 929         // children that are expensive to measure, and let that happen naturally later.
 930         setVisibilityOnChildren(layout, View.GONE);
 931         int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
 932         int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
 933         layout.setMinimumWidth(getPageContentWidth());
 934         layout.measure(widthSpec, heightSpec);
 935         setVisibilityOnChildren(layout, View.VISIBLE);
 936     }
 937 
 938     public void syncAppsPageItems(int page, boolean immediate) {
 939         // ensure that we have the right number of items on the pages
 940         int numCells = mCellCountX * mCellCountY;
 941         int startIndex = page * numCells;
 942         int endIndex = Math.min(startIndex + numCells, mApps.size());
 943         PagedViewCellLayout layout = (PagedViewCellLayout) getPageAt(page);
 944 
 945         layout.removeAllViewsOnPage();
 946         ArrayList&lt;Object&gt; items = new ArrayList&lt;Object&gt;();
 947         ArrayList&lt;Bitmap&gt; images = new ArrayList&lt;Bitmap&gt;();
 948         for (int i = startIndex; i &lt; endIndex; ++i) {
 949             ApplicationInfo info = mApps.get(i);
 950             PagedViewIcon icon = (PagedViewIcon) mLayoutInflater.inflate(
 951                     R.layout.apps_customize_application, layout, false);
 952             icon.applyFromApplicationInfo(info, true, this);
 953             icon.setOnClickListener(this);
 954             icon.setOnLongClickListener(this);
 955             icon.setOnTouchListener(this);
 956             icon.setOnKeyListener(this);
 957 
 958             int index = i - startIndex;
 959             int x = index % mCellCountX;
 960             int y = index / mCellCountX;
 961             layout.addViewToCellLayout(icon, -1, i, new PagedViewCellLayout.LayoutParams(x,y, 1,1));
 962 
 963             items.add(info);
 964             images.add(info.iconBitmap);
 965         }
 966 
 967         layout.createHardwareLayers();
 968     }
 969 
 970     /**
 971      * A helper to return the priority for loading of the specified widget page.
 972      */
 973     private int getWidgetPageLoadPriority(int page) {
 974         // If we are snapping to another page, use that index as the target page index
 975         int toPage = mCurrentPage;
 976         if (mNextPage &gt; -1) {
 977             toPage = mNextPage;
 978         }
 979 
 980         // We use the distance from the target page as an initial guess of priority, but if there
 981         // are no pages of higher priority than the page specified, then bump up the priority of
 982         // the specified page.
 983         Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
 984         int minPageDiff = Integer.MAX_VALUE;
 985         while (iter.hasNext()) {
 986             AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
 987             minPageDiff = Math.abs(task.page - toPage);
 988         }
 989 
 990         int rawPageDiff = Math.abs(page - toPage);
 991         return rawPageDiff - Math.min(rawPageDiff, minPageDiff);
 992     }
 993 
 994     /**
 995      * Return the appropriate thread priority for loading for a given page (we give the current
 996      * page much higher priority)
 997      */
 998     private int getThreadPriorityForPage(int page) {
 999         // TODO-APPS_CUSTOMIZE: detect number of cores and set thread priorities accordingly below
1000         int pageDiff = getWidgetPageLoadPriority(page);
1001         if (pageDiff &lt;= 0) {
1002             return Process.THREAD_PRIORITY_LESS_FAVORABLE;
1003         } else if (pageDiff &lt;= 1) {
1004             return Process.THREAD_PRIORITY_LOWEST;
1005         } else {
1006             return Process.THREAD_PRIORITY_LOWEST;
1007         }
1008     }
1009 
1010     private int getSleepForPage(int page) {
1011         int pageDiff = getWidgetPageLoadPriority(page);
1012         return Math.max(0, pageDiff * sPageSleepDelay);
1013     }
1014 
1015     /**
1016      * Creates and executes a new AsyncTask to load a page of widget previews.
1017      */
1018     private void prepareLoadWidgetPreviewsTask(int page, ArrayList&lt;Object&gt; widgets,
1019             int cellWidth, int cellHeight, int cellCountX) {
1020 
1021         // Prune all tasks that are no longer needed
1022         Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1023         while (iter.hasNext()) {
1024             AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1025             int taskPage = task.page;
1026             if (taskPage &lt; getAssociatedLowerPageBound(mCurrentPage) ||
1027                     taskPage &gt; getAssociatedUpperPageBound(mCurrentPage)) {
1028                 task.cancel(false);
1029                 iter.remove();
1030             } else {
1031                 task.setThreadPriority(getThreadPriorityForPage(taskPage));
1032             }
1033         }
1034 
1035         // We introduce a slight delay to order the loading of side pages so that we don&#x27;t thrash
1036         final int sleepMs = getSleepForPage(page);
1037         AsyncTaskPageData pageData = new AsyncTaskPageData(page, widgets, cellWidth, cellHeight,
1038             new AsyncTaskCallback() {
1039                 @Override
1040                 public void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data) {
1041                     try {
1042                         try {
1043                             Thread.sleep(sleepMs);
1044                         } catch (Exception e) {}
1045                         loadWidgetPreviewsInBackground(task, data);
1046                     } finally {
1047                         if (task.isCancelled()) {
1048                             data.cleanup(true);
1049                         }
1050                     }
1051                 }
1052             },
1053             new AsyncTaskCallback() {
1054                 @Override
1055                 public void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data) {
1056                     mRunningTasks.remove(task);
1057                     if (task.isCancelled()) return;
1058                     // do cleanup inside onSyncWidgetPageItems
1059                     onSyncWidgetPageItems(data);
1060                 }
1061             });
1062 
1063         // Ensure that the task is appropriately prioritized and runs in parallel
1064         AppsCustomizeAsyncTask t = new AppsCustomizeAsyncTask(page,
1065                 AsyncTaskPageData.Type.LoadWidgetPreviewData);
1066         t.setThreadPriority(getThreadPriorityForPage(page));
1067         t.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, pageData);
1068         mRunningTasks.add(t);
1069     }
1070 
1071     /*
1072      * Widgets PagedView implementation
1073      */
1074     private void setupPage(PagedViewGridLayout layout) {
1075         layout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
1076                 mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
1077 
1078         // Note: We force a measure here to get around the fact that when we do layout calculations
1079         // immediately after syncing, we don&#x27;t have a proper width.
1080         int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
1081         int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
1082         layout.setMinimumWidth(getPageContentWidth());
1083         layout.measure(widthSpec, heightSpec);
1084     }
1085 
1086     private void renderDrawableToBitmap(Drawable d, Bitmap bitmap, int x, int y, int w, int h) {
1087         renderDrawableToBitmap(d, bitmap, x, y, w, h, 1f);
1088     }
1089 
1090     private void renderDrawableToBitmap(Drawable d, Bitmap bitmap, int x, int y, int w, int h,
1091             float scale) {
1092         if (bitmap != null) {
1093             Canvas c = new Canvas(bitmap);
1094             c.scale(scale, scale);
1095             Rect oldBounds = d.copyBounds();
1096             d.setBounds(x, y, x + w, y + h);
1097             d.draw(c);
1098             d.setBounds(oldBounds); // Restore the bounds
1099             c.setBitmap(null);
1100         }
1101     }
1102 
1103     private Bitmap getShortcutPreview(ResolveInfo info, int maxWidth, int maxHeight) {
1104         Bitmap tempBitmap = mCachedShortcutPreviewBitmap.get();
1105         final Canvas c = mCachedShortcutPreviewCanvas.get();
<abbr title="1106         if (((tempBitmap == null) || (tempBitmap.getWidth() != maxWidth)) || (tempBitmap.getHeight() != maxHeight)) {">1106         if (((tempBitmap == null) || (tempBitmap.getWidth() != maxWidth)) || (tempBitmap.getHeight() != m</abbr>
1107             tempBitmap = Bitmap.createBitmap(maxWidth, maxHeight, Config.ARGB_8888);
1108             mCachedShortcutPreviewBitmap.set(tempBitmap);
1109         } else {
1110             c.setBitmap(tempBitmap);
1111             c.drawColor(0, PorterDuff.Mode.CLEAR);
1112             c.setBitmap(null);
1113         }
1114         // Render the icon
1115         Drawable icon = mIconCache.getFullResIcon(info);
1116         int paddingTop = getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_top);
1117         int paddingLeft = getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_left);
<abbr title="1118         int paddingRight = getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_right);">1118         int paddingRight = getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_right)</abbr>
1119         int scaledIconWidth = (maxWidth - paddingLeft) - paddingRight;
<abbr title="1120         renderDrawableToBitmap(icon, tempBitmap, paddingLeft, paddingTop, scaledIconWidth, scaledIconWidth);">1120         renderDrawableToBitmap(icon, tempBitmap, paddingLeft, paddingTop, scaledIconWidth, scaledIconWidt</abbr>
1121         Bitmap preview = Bitmap.createBitmap(maxWidth, maxHeight, Config.ARGB_8888);
1122         c.setBitmap(preview);
1123         Paint p = mCachedShortcutPreviewPaint.get();
1124         if (p == null) {
1125             p = new Paint();
1126             ColorMatrix colorMatrix = new ColorMatrix();
1127             colorMatrix.setSaturation(0);
1128             p.setColorFilter(new ColorMatrixColorFilter(colorMatrix));
1129             p.setAlpha(((int) (255 * 0.06F)));
1130             // float density = 1f;
1131             // p.setMaskFilter(new BlurMaskFilter(15*density, BlurMaskFilter.Blur.NORMAL));
1132             mCachedShortcutPreviewPaint.set(p);
1133         }
1134         c.drawBitmap(tempBitmap, 0, 0, p);
1135         c.setBitmap(null);
1136         renderDrawableToBitmap(icon, preview, 0, 0, mAppIconSize, mAppIconSize);
1137         return preview;
1138     }
1139 
<abbr title="1140     private Bitmap getWidgetPreview(ComponentName provider, int previewImage, int iconId, int cellHSpan, int cellVSpan, int maxWidth, int maxHeight) {">1140     private Bitmap getWidgetPreview(ComponentName provider, int previewImage, int iconId, int cellHSpan, </abbr>
1141         // Load the preview image if possible
1142         String packageName = provider.getPackageName();
1143         if (maxWidth &lt; 0) {
1144             maxWidth = Integer.MAX_VALUE;
1145         }
1146         if (maxHeight &lt; 0) {
1147             maxHeight = Integer.MAX_VALUE;
1148         }
1149         Drawable drawable = null;
1150         if (previewImage != 0) {
1151             drawable = mPackageManager.getDrawable(packageName, previewImage, null);
1152             if (drawable == null) {
<abbr title="1153                 Log.w(TAG, ((&quot;Can&#x27;t load widget preview drawable 0x&quot; + Integer.toHexString(previewImage)) + &quot; for provider: &quot;) + provider);">1153                 Log.w(TAG, ((&quot;Can&#x27;t load widget preview drawable 0x&quot; + Integer.toHexString(previewImage))</abbr>
1154             }
1155         }
1156         int bitmapWidth;
1157         int bitmapHeight;
1158         Bitmap defaultPreview = null;
1159         boolean widgetPreviewExists = drawable != null;
1160         if (widgetPreviewExists) {
1161             bitmapWidth = drawable.getIntrinsicWidth();
1162             bitmapHeight = drawable.getIntrinsicHeight();
1163         } else {
1164             // Generate a preview image if we couldn&#x27;t load one
1165             if (cellHSpan &lt; 1) {
1166                 cellHSpan = 1;
1167             }
1168             if (cellVSpan &lt; 1) {
1169                 cellVSpan = 1;
1170             }
<abbr title="1171             BitmapDrawable previewDrawable = ((BitmapDrawable) (getResources().getDrawable(R.drawable.widget_preview_tile)));">1171             BitmapDrawable previewDrawable = ((BitmapDrawable) (getResources().getDrawable(R.drawable.wid</abbr>
1172             final int previewDrawableWidth = previewDrawable.getIntrinsicWidth();
1173             final int previewDrawableHeight = previewDrawable.getIntrinsicHeight();
1174             bitmapWidth = previewDrawableWidth * cellHSpan;// subtract 2 dips
1175 
1176             bitmapHeight = previewDrawableHeight * cellVSpan;
1177             defaultPreview = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Config.ARGB_8888);
1178             final Canvas c = mCachedAppWidgetPreviewCanvas.get();
1179             c.setBitmap(defaultPreview);
1180             previewDrawable.setBounds(0, 0, bitmapWidth, bitmapHeight);
1181             previewDrawable.setTileModeXY(Shader.TileMode.REPEAT, Shader.TileMode.REPEAT);
1182             previewDrawable.draw(c);
1183             c.setBitmap(null);
1184             // Draw the icon in the top left corner
1185             int minOffset = ((int) (mAppIconSize * sWidgetPreviewIconPaddingPercentage));
1186             int smallestSide = Math.min(bitmapWidth, bitmapHeight);
<abbr title="1187             float iconScale = Math.min(((float) (smallestSide)) / (mAppIconSize + (2 * minOffset)), 1.0F);">1187             float iconScale = Math.min(((float) (smallestSide)) / (mAppIconSize + (2 * minOffset)), 1.0F)</abbr>
1188             try {
1189                 Drawable icon = null;
1190                 int hoffset = ((int) ((previewDrawableWidth - (mAppIconSize * iconScale)) / 2));
1191                 int yoffset = ((int) ((previewDrawableHeight - (mAppIconSize * iconScale)) / 2));
1192                 if (iconId &gt; 0) {
1193                     icon = mIconCache.getFullResIcon(packageName, iconId);
1194                 }
1195                 if (icon != null) {
<abbr title="1196                     renderDrawableToBitmap(icon, defaultPreview, hoffset, yoffset, ((int) (mAppIconSize * iconScale)), ((int) (mAppIconSize * iconScale)));">1196                     renderDrawableToBitmap(icon, defaultPreview, hoffset, yoffset, ((int) (mAppIconSize *</abbr>
1197                 }
1198             } catch (Resources e) {
1199             }
1200         }
1201         // Scale to fit width only - let the widget preview be clipped in the
1202         // vertical dimension
1203         float scale = 1.0F;
1204         if (bitmapWidth &gt; maxWidth) {
1205             scale = maxWidth / ((float) (bitmapWidth));
1206         }
1207         if (scale != 1.0F) {
1208             bitmapWidth = ((int) (scale * bitmapWidth));
1209             bitmapHeight = ((int) (scale * bitmapHeight));
1210         }
1211         Bitmap preview = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Config.ARGB_8888);
1212         // Draw the scaled preview into the final bitmap
1213         if (widgetPreviewExists) {
1214             renderDrawableToBitmap(drawable, preview, 0, 0, bitmapWidth, bitmapHeight);
1215         } else {
1216             final Canvas c = mCachedAppWidgetPreviewCanvas.get();
1217             final Rect src = mCachedAppWidgetPreviewSrcRect.get();
1218             final Rect dest = mCachedAppWidgetPreviewDestRect.get();
1219             c.setBitmap(preview);
1220             src.set(0, 0, defaultPreview.getWidth(), defaultPreview.getHeight());
1221             dest.set(0, 0, preview.getWidth(), preview.getHeight());
1222             Paint p = mCachedAppWidgetPreviewPaint.get();
1223             if (p == null) {
1224                 p = new Paint();
1225                 p.setFilterBitmap(true);
1226                 mCachedAppWidgetPreviewPaint.set(p);
1227             }
1228             c.drawBitmap(defaultPreview, src, dest, p);
1229             c.setBitmap(null);
1230         }
1231         return preview;
1232     }
1233 
1234     public void syncWidgetPageItems(final int page, final boolean immediate) {
1235         int numItemsPerPage = mWidgetCountX * mWidgetCountY;
1236 
1237         // Calculate the dimensions of each cell we are giving to each widget
1238         final ArrayList&lt;Object&gt; items = new ArrayList&lt;Object&gt;();
1239         int contentWidth = mWidgetSpacingLayout.getContentWidth();
1240         final int cellWidth = ((contentWidth - mPageLayoutPaddingLeft - mPageLayoutPaddingRight
1241                 - ((mWidgetCountX - 1) * mWidgetWidthGap)) / mWidgetCountX);
1242         int contentHeight = mWidgetSpacingLayout.getContentHeight();
1243         final int cellHeight = ((contentHeight - mPageLayoutPaddingTop - mPageLayoutPaddingBottom
1244                 - ((mWidgetCountY - 1) * mWidgetHeightGap)) / mWidgetCountY);
1245 
1246         // Prepare the set of widgets to load previews for in the background
1247         int offset = (page - mNumAppsPages) * numItemsPerPage;
1248         for (int i = offset; i &lt; Math.min(offset + numItemsPerPage, mWidgets.size()); ++i) {
1249             items.add(mWidgets.get(i));
1250         }
1251 
1252         // Prepopulate the pages with the other widget info, and fill in the previews later
1253         final PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(page);
1254         layout.setColumnCount(layout.getCellCountX());
1255         for (int i = 0; i &lt; items.size(); ++i) {
1256             Object rawInfo = items.get(i);
1257             PendingAddItemInfo createItemInfo = null;
1258             PagedViewWidget widget = (PagedViewWidget) mLayoutInflater.inflate(
1259                     R.layout.apps_customize_widget, layout, false);
1260             if (rawInfo instanceof AppWidgetProviderInfo) {
1261                 // Fill in the widget information
1262                 AppWidgetProviderInfo info = (AppWidgetProviderInfo) rawInfo;
1263                 createItemInfo = new PendingAddWidgetInfo(info, null, null);
1264 
1265                 // Determine the widget spans and min resize spans.
1266                 int[] spanXY = Launcher.getSpanForWidget(mLauncher, info);
1267                 createItemInfo.spanX = spanXY[0];
1268                 createItemInfo.spanY = spanXY[1];
1269                 int[] minSpanXY = Launcher.getMinSpanForWidget(mLauncher, info);
1270                 createItemInfo.minSpanX = minSpanXY[0];
1271                 createItemInfo.minSpanY = minSpanXY[1];
1272 
1273                 widget.applyFromAppWidgetProviderInfo(info, -1, spanXY);
1274                 widget.setTag(createItemInfo);
1275                 widget.setShortPressListener(this);
1276             } else if (rawInfo instanceof ResolveInfo) {
1277                 // Fill in the shortcuts information
1278                 ResolveInfo info = (ResolveInfo) rawInfo;
1279                 createItemInfo = new PendingAddShortcutInfo(info.activityInfo);
1280                 createItemInfo.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
1281                 createItemInfo.componentName = new ComponentName(info.activityInfo.packageName,
1282                         info.activityInfo.name);
1283                 widget.applyFromResolveInfo(mPackageManager, info);
1284                 widget.setTag(createItemInfo);
1285             }
1286             widget.setOnClickListener(this);
1287             widget.setOnLongClickListener(this);
1288             widget.setOnTouchListener(this);
1289             widget.setOnKeyListener(this);
1290 
1291             // Layout each widget
1292             int ix = i % mWidgetCountX;
1293             int iy = i / mWidgetCountX;
1294             GridLayout.LayoutParams lp = new GridLayout.LayoutParams(
1295                     GridLayout.spec(iy, GridLayout.LEFT),
1296                     GridLayout.spec(ix, GridLayout.TOP));
1297             lp.width = cellWidth;
1298             lp.height = cellHeight;
1299             lp.setGravity(Gravity.TOP | Gravity.LEFT);
1300             if (ix &gt; 0) lp.leftMargin = mWidgetWidthGap;
1301             if (iy &gt; 0) lp.topMargin = mWidgetHeightGap;
1302             layout.addView(widget, lp);
1303         }
1304 
1305         // wait until a call on onLayout to start loading, because
1306         // PagedViewWidget.getPreviewSize() will return 0 if it hasn&#x27;t been laid out
1307         // TODO: can we do a measure/layout immediately?
1308         layout.setOnLayoutListener(new Runnable() {
1309             public void run() {
1310                 // Load the widget previews
1311                 int maxPreviewWidth = cellWidth;
1312                 int maxPreviewHeight = cellHeight;
1313                 if (layout.getChildCount() &gt; 0) {
1314                     PagedViewWidget w = (PagedViewWidget) layout.getChildAt(0);
1315                     int[] maxSize = w.getPreviewSize();
1316                     maxPreviewWidth = maxSize[0];
1317                     maxPreviewHeight = maxSize[1];
1318                 }
1319                 if (immediate) {
1320                     AsyncTaskPageData data = new AsyncTaskPageData(page, items,
1321                             maxPreviewWidth, maxPreviewHeight, null, null);
1322                     loadWidgetPreviewsInBackground(null, data);
1323                     onSyncWidgetPageItems(data);
1324                 } else {
1325                     if (mInTransition) {
1326                         mDeferredPrepareLoadWidgetPreviewsTasks.add(this);
1327                     } else {
1328                         prepareLoadWidgetPreviewsTask(page, items,
1329                                 maxPreviewWidth, maxPreviewHeight, mWidgetCountX);
1330                     }
1331                 }
1332             }
1333         });
1334     }
1335 
1336     private void loadWidgetPreviewsInBackground(AppsCustomizeAsyncTask task,
1337             AsyncTaskPageData data) {
1338         // loadWidgetPreviewsInBackground can be called without a task to load a set of widget
1339         // previews synchronously
1340         if (task != null) {
1341             // Ensure that this task starts running at the correct priority
1342             task.syncThreadPriority();
1343         }
1344 
1345         // Load each of the widget/shortcut previews
1346         ArrayList&lt;Object&gt; items = data.items;
1347         ArrayList&lt;Bitmap&gt; images = data.generatedImages;
1348         int count = items.size();
1349         for (int i = 0; i &lt; count; ++i) {
1350             if (task != null) {
1351                 // Ensure we haven&#x27;t been cancelled yet
1352                 if (task.isCancelled()) break;
1353                 // Before work on each item, ensure that this task is running at the correct
1354                 // priority
1355                 task.syncThreadPriority();
1356             }
1357 
1358             Object rawInfo = items.get(i);
1359             if (rawInfo instanceof AppWidgetProviderInfo) {
1360                 AppWidgetProviderInfo info = (AppWidgetProviderInfo) rawInfo;
1361                 int[] cellSpans = Launcher.getSpanForWidget(mLauncher, info);
1362 
1363                 int maxWidth = Math.min(data.maxImageWidth,
1364                         mWidgetSpacingLayout.estimateCellWidth(cellSpans[0]));
1365                 int maxHeight = Math.min(data.maxImageHeight,
1366                         mWidgetSpacingLayout.estimateCellHeight(cellSpans[1]));
1367                 Bitmap b = getWidgetPreview(info.provider, info.previewImage, info.icon,
1368                         cellSpans[0], cellSpans[1], maxWidth, maxHeight);
1369                 images.add(b);
1370             } else if (rawInfo instanceof ResolveInfo) {
1371                 // Fill in the shortcuts information
1372                 ResolveInfo info = (ResolveInfo) rawInfo;
1373                 images.add(getShortcutPreview(info, data.maxImageWidth, data.maxImageHeight));
1374             }
1375         }
1376     }
1377 
1378     private void onSyncWidgetPageItems(AsyncTaskPageData data) {
1379         if (mInTransition) {
1380             mDeferredSyncWidgetPageItems.add(data);
1381             return;
1382         }
1383         try {
1384             int page = data.page;
1385             PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(page);
1386 
1387             ArrayList&lt;Object&gt; items = data.items;
1388             int count = items.size();
1389             for (int i = 0; i &lt; count; ++i) {
1390                 PagedViewWidget widget = (PagedViewWidget) layout.getChildAt(i);
1391                 if (widget != null) {
1392                     Bitmap preview = data.generatedImages.get(i);
1393                     widget.applyPreview(new FastBitmapDrawable(preview), i);
1394                 }
1395             }
1396 
1397             layout.createHardwareLayer();
1398             invalidate();
1399 
1400             // Update all thread priorities
1401             Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1402             while (iter.hasNext()) {
1403                 AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1404                 int pageIndex = task.page;
1405                 task.setThreadPriority(getThreadPriorityForPage(pageIndex));
1406             }
1407         } finally {
1408             data.cleanup(false);
1409         }
1410     }
1411 
1412     @Override
1413     public void syncPages() {
1414         removeAllViews();
1415         cancelAllTasks();
1416 
1417         Context context = getContext();
1418         for (int j = 0; j &lt; mNumWidgetPages; ++j) {
1419             PagedViewGridLayout layout = new PagedViewGridLayout(context, mWidgetCountX,
1420                     mWidgetCountY);
1421             setupPage(layout);
1422             addView(layout, new PagedView.LayoutParams(LayoutParams.MATCH_PARENT,
1423                     LayoutParams.MATCH_PARENT));
1424         }
1425 
1426         for (int i = 0; i &lt; mNumAppsPages; ++i) {
1427             PagedViewCellLayout layout = new PagedViewCellLayout(context);
1428             setupPage(layout);
1429             addView(layout);
1430         }
1431     }
1432 
1433     @Override
1434     public void syncPageItems(int page, boolean immediate) {
1435         if (page &lt; mNumAppsPages) {
1436             syncAppsPageItems(page, immediate);
1437         } else {
1438             syncWidgetPageItems(page, immediate);
1439         }
1440     }
1441 
1442     // We want our pages to be z-ordered such that the further a page is to the left, the higher
1443     // it is in the z-order. This is important to insure touch events are handled correctly.
1444     View getPageAt(int index) {
1445         return getChildAt(indexToPage(index));
1446     }
1447 
1448     @Override
1449     protected int indexToPage(int index) {
1450         return getChildCount() - index - 1;
1451     }
1452 
1453     // In apps customize, we have a scrolling effect which emulates pulling cards off of a stack.
1454     @Override
1455     protected void screenScrolled(int screenCenter) {
1456         super.screenScrolled(screenCenter);
1457 
1458         for (int i = 0; i &lt; getChildCount(); i++) {
1459             View v = getPageAt(i);
1460             if (v != null) {
1461                 float scrollProgress = getScrollProgress(screenCenter, v, i);
1462 
1463                 float interpolatedProgress =
1464                         mZInterpolator.getInterpolation(Math.abs(Math.min(scrollProgress, 0)));
1465                 float scale = (1 - interpolatedProgress) +
1466                         interpolatedProgress * TRANSITION_SCALE_FACTOR;
1467                 float translationX = Math.min(0, scrollProgress) * v.getMeasuredWidth();
1468 
1469                 float alpha;
1470 
1471                 if (scrollProgress &lt; 0) {
1472                     alpha = scrollProgress &lt; 0 ? mAlphaInterpolator.getInterpolation(
1473                         1 - Math.abs(scrollProgress)) : 1.0f;
1474                 } else {
1475                     // On large screens we need to fade the page as it nears its leftmost position
1476                     alpha = mLeftScreenAlphaInterpolator.getInterpolation(1 - scrollProgress);
1477                 }
1478 
1479                 v.setCameraDistance(mDensity * CAMERA_DISTANCE);
1480                 int pageWidth = v.getMeasuredWidth();
1481                 int pageHeight = v.getMeasuredHeight();
1482 
1483                 if (PERFORM_OVERSCROLL_ROTATION) {
1484                     if (i == 0 &amp;&amp; scrollProgress &lt; 0) {
1485                         // Overscroll to the left
1486                         v.setPivotX(TRANSITION_PIVOT * pageWidth);
1487                         v.setRotationY(-TRANSITION_MAX_ROTATION * scrollProgress);
1488                         scale = 1.0f;
1489                         alpha = 1.0f;
1490                         // On the first page, we don&#x27;t want the page to have any lateral motion
1491                         translationX = 0;
1492                     } else if (i == getChildCount() - 1 &amp;&amp; scrollProgress &gt; 0) {
1493                         // Overscroll to the right
1494                         v.setPivotX((1 - TRANSITION_PIVOT) * pageWidth);
1495                         v.setRotationY(-TRANSITION_MAX_ROTATION * scrollProgress);
1496                         scale = 1.0f;
1497                         alpha = 1.0f;
1498                         // On the last page, we don&#x27;t want the page to have any lateral motion.
1499                         translationX = 0;
1500                     } else {
1501                         v.setPivotY(pageHeight / 2.0f);
1502                         v.setPivotX(pageWidth / 2.0f);
1503                         v.setRotationY(0f);
1504                     }
1505                 }
1506 
1507                 v.setTranslationX(translationX);
1508                 v.setScaleX(scale);
1509                 v.setScaleY(scale);
1510                 v.setAlpha(alpha);
1511 
1512                 // If the view has 0 alpha, we set it to be invisible so as to prevent
1513                 // it from accepting touches
1514                 if (alpha == 0) {
1515                     v.setVisibility(INVISIBLE);
1516                 } else if (v.getVisibility() != VISIBLE) {
1517                     v.setVisibility(VISIBLE);
1518                 }
1519             }
1520         }
1521     }
1522 
1523     protected void overScroll(float amount) {
1524         acceleratedOverScroll(amount);
1525     }
1526 
1527     /**
1528      * Used by the parent to get the content width to set the tab bar to
1529      * @return
1530      */
1531     public int getPageContentWidth() {
1532         return mContentWidth;
1533     }
1534 
1535     @Override
1536     protected void onPageEndMoving() {
1537         super.onPageEndMoving();
1538         mForceDrawAllChildrenNextFrame = true;
1539         // We reset the save index when we change pages so that it will be recalculated on next
1540         // rotation
1541         mSaveInstanceStateItemIndex = -1;
1542     }
1543 
1544     /*
1545      * AllAppsView implementation
1546      */
1547     public void setup(Launcher launcher, DragController dragController) {
1548         mLauncher = launcher;
1549         mDragController = dragController;
1550     }
1551 
1552     /**
1553      * We should call thise method whenever the core data changes (mApps, mWidgets) so that we can
1554      * appropriately determine when to invalidate the PagedView page data.  In cases where the data
1555      * has yet to be set, we can requestLayout() and wait for onDataReady() to be called in the
1556      * next onMeasure() pass, which will trigger an invalidatePageData() itself.
1557      */
1558     private void invalidateOnDataChange() {
1559         if (!isDataReady()) {
1560             // The next layout pass will trigger data-ready if both widgets and apps are set, so
1561             // request a layout to trigger the page data when ready.
1562             requestLayout();
1563         } else {
1564             cancelAllTasks();
1565             invalidatePageData();
1566         }
1567     }
1568 
1569     public void setApps(ArrayList&lt;ApplicationInfo&gt; list) {
1570         mApps = list;
1571         Collections.sort(mApps, LauncherModel.APP_NAME_COMPARATOR);
1572         updatePageCounts();
1573         invalidateOnDataChange();
1574     }
1575 
1576     private void addAppsWithoutInvalidate(ArrayList&lt;ApplicationInfo&gt; list) {
1577         // We add it in place, in alphabetical order
1578         int count = list.size();
1579         for (int i = 0; i &lt; count; ++i) {
1580             ApplicationInfo info = list.get(i);
1581             int index = Collections.binarySearch(mApps, info, LauncherModel.APP_NAME_COMPARATOR);
1582             if (index &lt; 0) {
1583                 mApps.add(-(index + 1), info);
1584             }
1585         }
1586     }
1587 
1588     public void addApps(ArrayList&lt;ApplicationInfo&gt; list) {
1589         addAppsWithoutInvalidate(list);
1590         updatePageCounts();
1591         invalidateOnDataChange();
1592     }
1593 
1594     private int findAppByComponent(List&lt;ApplicationInfo&gt; list, ApplicationInfo item) {
1595         ComponentName removeComponent = item.intent.getComponent();
1596         int length = list.size();
1597         for (int i = 0; i &lt; length; ++i) {
1598             ApplicationInfo info = list.get(i);
1599             if (info.intent.getComponent().equals(removeComponent)) {
1600                 return i;
1601             }
1602         }
1603         return -1;
1604     }
1605 
1606     private int findAppByPackage(
1607 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1608 List&lt;ApplicationInfo&gt; list, String packageName</span>
1609 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="1610 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/">1610 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw</abbr></span>
1611 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1612 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1613 boolean immediate</span>
1614 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
1615     ) {
1616 
1617 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1618         int length = list.size();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1619         for (int i = 0; i &lt; length; ++i) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1620             ApplicationInfo info = list.get(i);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1621             if (ItemInfo.getPackageName(info.intent).equals(packageName)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1622                 return i;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1623             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1624         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1625         return -1;</span>
1626 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="1627 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/">1627 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw</abbr></span>
1628 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1629 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1630         if (immediate) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1631             updatePackages();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1632         } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1633             // TODO: this isn&#x27;t ideal, but we actually need to delay here. This call is triggered</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1634             // by a broadcast receiver, and in order for it to work correctly, we need to know that</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1635             // the AppWidgetService has already received and processed the same broadcast. Since there</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1636             // is no guarantee about ordering of broadcast receipt, we just delay here. This is a</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1637             // workaround until we add a callback from AppWidgetService to AppWidgetHost when widget</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1638             // packages are added, updated or removed.</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1639             postDelayed(new Runnable() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1640                public void run() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1641                    updatePackages();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1642                }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1643             }, 1500);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1644         }</span>
1645 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
1646 
1647     }
1648 
1649     private void removeAppsWithoutInvalidate(ArrayList&lt;ApplicationInfo&gt; list) {
1650         // loop through all the apps and remove apps that have the same component
1651         int length = list.size();
1652         for (int i = 0; i &lt; length; ++i) {
1653             ApplicationInfo info = list.get(i);
1654             int removeIndex = findAppByComponent(mApps, info);
1655             if (removeIndex &gt; -1) {
1656                 mApps.remove(removeIndex);
1657             }
1658         }
1659     }
1660 
1661     private void removeAppsWithPackageNameWithoutInvalidate(ArrayList&lt;String&gt; packageNames) {
1662         // loop through all the package names and remove apps that have the same package name
1663         for (String pn : packageNames) {
1664             int removeIndex = findAppByPackage(mApps, pn);
1665             while (removeIndex &gt; (-1)) {
1666                 mApps.remove(removeIndex);
1667                 removeIndex = findAppByPackage(mApps, pn);
1668             }
1669         }
1670     }
1671 
1672     public void removeApps(ArrayList&lt;String&gt; packageNames) {
1673         removeAppsWithPackageNameWithoutInvalidate(packageNames);
1674         updatePageCounts();
1675         invalidateOnDataChange();
1676     }
1677 
1678     public void updateApps(ArrayList&lt;ApplicationInfo&gt; list) {
1679         // We remove and re-add the updated applications list because it&#x27;s properties may have
1680         // changed (ie. the title), and this will ensure that the items will be in their proper
1681         // place in the list.
1682         removeAppsWithoutInvalidate(list);
1683         addAppsWithoutInvalidate(list);
1684         updatePageCounts();
1685         invalidateOnDataChange();
1686     }
1687 
1688     public void reset() {
1689         // If we have reset, then we should not continue to restore the previous state
1690         mSaveInstanceStateItemIndex = -1;
1691         AppsCustomizeTabHost tabHost = getTabHost();
1692         String tag = tabHost.getCurrentTabTag();
1693         if (tag != null) {
1694             if (!tag.equals(tabHost.getTabTagForContentType(ContentType.Applications))) {
1695                 tabHost.setCurrentTabFromContent(ContentType.Applications);
1696             }
1697         }
1698         if (mCurrentPage != 0) {
1699             invalidatePageData(0);
1700         }
1701     }
1702 
1703     private AppsCustomizeTabHost getTabHost() {
1704         return (AppsCustomizeTabHost) mLauncher.findViewById(R.id.apps_customize_pane);
1705     }
1706 
1707     public void dumpState() {
1708         // TODO: Dump information related to current list of Applications, Widgets, etc.
1709         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mApps&quot;, mApps);
1710         dumpAppWidgetProviderInfoList(TAG, &quot;mWidgets&quot;, mWidgets);
1711     }
1712 
1713     private void dumpAppWidgetProviderInfoList(String tag, String label,
1714             ArrayList&lt;Object&gt; list) {
1715         Log.d(tag, label + &quot; size=&quot; + list.size());
1716         for (Object i: list) {
1717             if (i instanceof AppWidgetProviderInfo) {
1718                 AppWidgetProviderInfo info = (AppWidgetProviderInfo) i;
1719                 Log.d(tag, &quot;   label=\&quot;&quot; + info.label + &quot;\&quot; previewImage=&quot; + info.previewImage
1720                         + &quot; resizeMode=&quot; + info.resizeMode + &quot; configure=&quot; + info.configure
1721                         + &quot; initialLayout=&quot; + info.initialLayout
1722                         + &quot; minWidth=&quot; + info.minWidth + &quot; minHeight=&quot; + info.minHeight);
1723             } else if (i instanceof ResolveInfo) {
1724                 ResolveInfo info = (ResolveInfo) i;
1725                 Log.d(tag, &quot;   label=\&quot;&quot; + info.loadLabel(mPackageManager) + &quot;\&quot; icon=&quot;
1726                         + info.icon);
1727             }
1728         }
1729     }
1730 
1731     public void surrender() {
1732         // TODO: If we are in the middle of any process (ie. for holographic outlines, etc) we
1733         // should stop this now.
1734         // Stop all background tasks
1735         cancelAllTasks();
1736     }
1737 
1738     @Override
1739     public void iconPressed(PagedViewIcon icon) {
1740         // Reset the previously pressed icon and store a reference to the pressed icon so that
1741         // we can reset it on return to Launcher (in Launcher.onResume())
1742         if (mPressedIcon != null) {
1743             mPressedIcon.resetDrawableState();
1744         }
1745         mPressedIcon = icon;
1746     }
1747 
1748     public void resetDrawableState() {
1749         if (mPressedIcon != null) {
1750             mPressedIcon.resetDrawableState();
1751             mPressedIcon = null;
1752         }
1753     }
1754 
1755     /*
1756      * We load an extra page on each side to prevent flashes from scrolling and loading of the
1757      * widget previews in the background with the AsyncTasks.
1758      */
1759     final static int sLookBehindPageCount = 2;
1760 
1761     final static int sLookAheadPageCount = 2;
1762 
1763     protected int getAssociatedLowerPageBound(int page) {
1764         final int count = getChildCount();
1765         int windowSize = Math.min(count, sLookBehindPageCount + sLookAheadPageCount + 1);
1766         int windowMinIndex = Math.max(Math.min(page - sLookBehindPageCount, count - windowSize), 0);
1767         return windowMinIndex;
1768     }
1769 
1770     protected int getAssociatedUpperPageBound(int page) {
1771         final int count = getChildCount();
1772         int windowSize = Math.min(count, sLookBehindPageCount + sLookAheadPageCount + 1);
1773         int windowMaxIndex = Math.min(Math.max(page + sLookAheadPageCount, windowSize - 1),
1774                 count - 1);
1775         return windowMaxIndex;
1776     }
1777 
1778     @Override
1779     protected String getCurrentPageDescription() {
1780         int page = (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
1781         int stringId = R.string.default_scroll_format;
1782         int count = 0;
1783 
1784         if (page &lt; mNumAppsPages) {
1785             stringId = R.string.apps_customize_apps_scroll_format;
1786             count = mNumAppsPages;
1787         } else {
1788             page -= mNumAppsPages;
1789             stringId = R.string.apps_customize_widgets_scroll_format;
1790             count = mNumWidgetPages;
1791         }
1792 
1793         return String.format(getContext().getString(stringId), page + 1, count);
1794     }
1795 }
1796 
1797 /**
1798  * A simple callback interface which also provides the results of the task.
1799  */
1800 interface AsyncTaskCallback {
1801     public abstract void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data);
1802 }
1803 
1804 /**
1805  * The data needed to perform either of the custom AsyncTasks.
1806  */
1807 class AsyncTaskPageData {
1808     enum Type {
1809 
1810         LoadWidgetPreviewData;}
1811 
<abbr title="1812     AsyncTaskPageData(int p, ArrayList&lt;Object&gt; l, ArrayList&lt;Bitmap&gt; si, AsyncTaskCallback bgR, AsyncTaskCallback postR) {">1812     AsyncTaskPageData(int p, ArrayList&lt;Object&gt; l, ArrayList&lt;Bitmap&gt; si, AsyncTaskCallback bgR, AsyncTaskC</abbr>
1813         page = p;
1814         items = l;
1815         sourceImages = si;
1816         generatedImages = new ArrayList&lt;Bitmap&gt;();
1817         maxImageWidth = maxImageHeight = -1;
1818         doInBackgroundCallback = bgR;
1819         postExecuteCallback = postR;
1820     }
1821 
<abbr title="1822     AsyncTaskPageData(int p, ArrayList&lt;Object&gt; l, int cw, int ch, AsyncTaskCallback bgR, AsyncTaskCallback postR) {">1822     AsyncTaskPageData(int p, ArrayList&lt;Object&gt; l, int cw, int ch, AsyncTaskCallback bgR, AsyncTaskCallbac</abbr>
1823         page = p;
1824         items = l;
1825         generatedImages = new ArrayList&lt;Bitmap&gt;();
1826         maxImageWidth = cw;
1827         maxImageHeight = ch;
1828         doInBackgroundCallback = bgR;
1829         postExecuteCallback = postR;
1830     }
1831 
1832     void cleanup(boolean cancelled) {
1833         // Clean up any references to source/generated bitmaps
1834         if (sourceImages != null) {
1835             if (cancelled) {
1836                 for (Bitmap b : sourceImages) {
1837                     b.recycle();
1838                 }
1839             }
1840             sourceImages.clear();
1841         }
1842         if (generatedImages != null) {
1843             if (cancelled) {
1844                 for (Bitmap b : generatedImages) {
1845                     b.recycle();
1846                 }
1847             }
1848             generatedImages.clear();
1849         }
1850     }
1851 
1852     int page;
1853 
1854     ArrayList&lt;Object&gt; items;
1855 
1856     ArrayList&lt;Bitmap&gt; sourceImages;
1857 
1858     ArrayList&lt;Bitmap&gt; generatedImages;
1859 
1860     int maxImageWidth;
1861 
1862     int maxImageHeight;
1863 
1864     AsyncTaskCallback doInBackgroundCallback;
1865 
1866     AsyncTaskCallback postExecuteCallback;
1867 }
1868 
1869 class BitmapCache extends WeakReferenceThreadLocal&lt;Bitmap&gt; {
1870     @Override
1871     protected Bitmap initialValue() {
1872         return null;
1873     }
1874 }
1875 
1876 class CanvasCache extends WeakReferenceThreadLocal&lt;Canvas&gt; {
1877     @Override
1878     protected Canvas initialValue() {
1879         return new Canvas();
1880     }
1881 }
1882 
1883 class PaintCache extends WeakReferenceThreadLocal&lt;Paint&gt; {
1884     @Override
1885     protected Paint initialValue() {
1886         return null;
1887     }
1888 }
1889 
1890 class RectCache extends WeakReferenceThreadLocal&lt;Rect&gt; {
1891     @Override
1892     protected Rect initialValue() {
1893         return new Rect();
1894     }
1895 }
1896 
1897 abstract class WeakReferenceThreadLocal&lt;T&gt; {
1898     private ThreadLocal&lt;WeakReference&lt;T&gt;&gt; mThreadLocal;
1899 
1900     public WeakReferenceThreadLocal() {
1901         mThreadLocal = new ThreadLocal&lt;WeakReference&lt;T&gt;&gt;();
1902     }
1903 
1904     abstract T initialValue();
1905 
1906     public void set(T t) {
1907         mThreadLocal.set(new WeakReference&lt;T&gt;(t));
1908     }
1909 
1910     public T get() {
1911         WeakReference&lt;T&gt; reference = mThreadLocal.get();
1912         T obj;
1913         if (reference == null) {
1914             obj = initialValue();
1915             mThreadLocal.set(new WeakReference&lt;T&gt;(obj));
1916             return obj;
1917         } else {
1918             obj = reference.get();
1919             if (obj == null) {
1920                 obj = initialValue();
1921                 mThreadLocal.set(new WeakReference&lt;T&gt;(obj));
1922             }
1923             return obj;
1924         }
1925     }
1926 }</pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2011 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher2;
  18  
  19  import android.animation.AnimatorSet;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  20 -import android.animation.ObjectAnimator;</span>
  21  import android.animation.ValueAnimator;
  22  import android.appwidget.AppWidgetHostView;
  23  import android.appwidget.AppWidgetManager;
  24  import android.appwidget.AppWidgetProviderInfo;
  25  import android.content.ComponentName;
  26  import android.content.Context;
  27  import android.content.Intent;
  28  import android.content.pm.PackageManager;
  29  import android.content.pm.ResolveInfo;
  30  import android.content.res.Configuration;
  31  import android.content.res.Resources;
  32  import android.content.res.TypedArray;
  33  import android.graphics.Bitmap;
  34  import android.graphics.Bitmap.Config;
  35  import android.graphics.Canvas;
  36  import android.graphics.ColorMatrix;
  37  import android.graphics.ColorMatrixColorFilter;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  38 -import android.graphics.Insets;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  39 -import android.graphics.MaskFilter;</span>
  40  import android.graphics.Matrix;
  41  import android.graphics.Paint;
  42  import android.graphics.PorterDuff;
  43  import android.graphics.Rect;
  44  import android.graphics.RectF;
  45  import android.graphics.Shader;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  46 -import android.graphics.TableMaskFilter;</span>
  47  import android.graphics.drawable.BitmapDrawable;
  48  import android.graphics.drawable.Drawable;
  49  import android.os.AsyncTask;
  50  import android.os.Process;
  51  import android.util.AttributeSet;
  52  import android.util.Log;
  53  import android.view.Gravity;
  54  import android.view.KeyEvent;
  55  import android.view.LayoutInflater;
  56  import android.view.MotionEvent;
  57  import android.view.View;
  58  import android.view.ViewGroup;
  59  import android.view.animation.AccelerateInterpolator;
  60  import android.view.animation.DecelerateInterpolator;
  61  import android.widget.GridLayout;
  62  import android.widget.ImageView;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  63 -import android.widget.LinearLayout;</span>
  64  import android.widget.Toast;
  65  
  66  import com.android.launcher.R;
  67  import com.android.launcher2.DropTarget.DragObject;
  68  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  69 +import java.lang.ref.WeakReference;</span>
  70  import java.util.ArrayList;
  71  import java.util.Collections;
  72  import java.util.Iterator;
  73  import java.util.List;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  74 -import java.lang.ref.WeakReference;</span>
  75  
  76  /**
  77   * A simple callback interface which also provides the results of the task.
  78   */
  79  interface AsyncTaskCallback {
  80      void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data);
  81  }
  82  
  83  /**
  84   * The data needed to perform either of the custom AsyncTasks.
  85   */
  86  class AsyncTaskPageData {
  87      enum Type {
  88          LoadWidgetPreviewData
  89      }
  90  
  91      AsyncTaskPageData(int p, ArrayList&lt;Object&gt; l, ArrayList&lt;Bitmap&gt; si, AsyncTaskCallback bgR,
  92              AsyncTaskCallback postR) {
  93          page = p;
  94          items = l;
  95          sourceImages = si;
  96          generatedImages = new ArrayList&lt;Bitmap&gt;();
  97          maxImageWidth = maxImageHeight = -1;
  98          doInBackgroundCallback = bgR;
  99          postExecuteCallback = postR;
 100      }
 101      AsyncTaskPageData(int p, ArrayList&lt;Object&gt; l, int cw, int ch, AsyncTaskCallback bgR,
 102              AsyncTaskCallback postR) {
 103          page = p;
 104          items = l;
 105          generatedImages = new ArrayList&lt;Bitmap&gt;();
 106          maxImageWidth = cw;
 107          maxImageHeight = ch;
 108          doInBackgroundCallback = bgR;
 109          postExecuteCallback = postR;
 110      }
 111      void cleanup(boolean cancelled) {
 112          // Clean up any references to source/generated bitmaps
 113          if (sourceImages != null) {
 114              if (cancelled) {
 115                  for (Bitmap b : sourceImages) {
 116                      b.recycle();
 117                  }
 118              }
 119              sourceImages.clear();
 120          }
 121          if (generatedImages != null) {
 122              if (cancelled) {
 123                  for (Bitmap b : generatedImages) {
 124                      b.recycle();
 125                  }
 126              }
 127              generatedImages.clear();
 128          }
 129      }
 130      int page;
 131      ArrayList&lt;Object&gt; items;
 132      ArrayList&lt;Bitmap&gt; sourceImages;
 133      ArrayList&lt;Bitmap&gt; generatedImages;
 134      int maxImageWidth;
 135      int maxImageHeight;
 136      AsyncTaskCallback doInBackgroundCallback;
 137      AsyncTaskCallback postExecuteCallback;
 138  }
 139  
 140  /**
 141   * A generic template for an async task used in AppsCustomize.
 142   */
 143  class AppsCustomizeAsyncTask extends AsyncTask&lt;AsyncTaskPageData, Void, AsyncTaskPageData&gt; {
 144      AppsCustomizeAsyncTask(int p, AsyncTaskPageData.Type ty) {
 145          page = p;
 146          threadPriority = Process.THREAD_PRIORITY_DEFAULT;
 147          dataType = ty;
 148      }
 149      @Override
 150      protected AsyncTaskPageData doInBackground(AsyncTaskPageData... params) {
 151          if (params.length != 1) return null;
 152          // Load each of the widget previews in the background
 153          params[0].doInBackgroundCallback.run(this, params[0]);
 154          return params[0];
 155      }
 156      @Override
 157      protected void onPostExecute(AsyncTaskPageData result) {
 158          // All the widget previews are loaded, so we can just callback to inflate the page
 159          result.postExecuteCallback.run(this, result);
 160      }
 161  
 162      void setThreadPriority(int p) {
 163          threadPriority = p;
 164      }
 165      void syncThreadPriority() {
 166          Process.setThreadPriority(threadPriority);
 167      }
 168  
 169      // The page that this async task is associated with
 170      AsyncTaskPageData.Type dataType;
 171      int page;
 172      int threadPriority;
 173  }
 174  
 175  abstract class WeakReferenceThreadLocal&lt;T&gt; {
 176      private ThreadLocal&lt;WeakReference&lt;T&gt;&gt; mThreadLocal;
 177      public WeakReferenceThreadLocal() {
 178          mThreadLocal = new ThreadLocal&lt;WeakReference&lt;T&gt;&gt;();
 179      }
 180  
 181      abstract T initialValue();
 182  
 183      public void set(T t) {
 184          mThreadLocal.set(new WeakReference&lt;T&gt;(t));
 185      }
 186  
 187      public T get() {
 188          WeakReference&lt;T&gt; reference = mThreadLocal.get();
 189          T obj;
 190          if (reference == null) {
 191              obj = initialValue();
 192              mThreadLocal.set(new WeakReference&lt;T&gt;(obj));
 193              return obj;
 194          } else {
 195              obj = reference.get();
 196              if (obj == null) {
 197                  obj = initialValue();
 198                  mThreadLocal.set(new WeakReference&lt;T&gt;(obj));
 199              }
 200              return obj;
 201          }
 202      }
 203  }
 204  
 205  class CanvasCache extends WeakReferenceThreadLocal&lt;Canvas&gt; {
 206      @Override
 207      protected Canvas initialValue() {
 208          return new Canvas();
 209      }
 210  }
 211  
 212  class PaintCache extends WeakReferenceThreadLocal&lt;Paint&gt; {
 213      @Override
 214      protected Paint initialValue() {
 215          return null;
 216      }
 217  }
 218  
 219  class BitmapCache extends WeakReferenceThreadLocal&lt;Bitmap&gt; {
 220      @Override
 221      protected Bitmap initialValue() {
 222          return null;
 223      }
 224  }
 225  
 226  class RectCache extends WeakReferenceThreadLocal&lt;Rect&gt; {
 227      @Override
 228      protected Rect initialValue() {
 229          return new Rect();
 230      }
 231  }
 232  
 233  /**
 234   * The Apps/Customize page that displays all the applications, widgets, and shortcuts.
 235   */
 236  public class AppsCustomizePagedView extends PagedViewWithDraggableItems implements
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 237 -        AllAppsView, View.OnClickListener, View.OnKeyListener, DragSource,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 238 +        View.OnClickListener, View.OnKeyListener, DragSource,</span>
 239          PagedViewIcon.PressedCallback, PagedViewWidget.ShortPressListener,
 240          LauncherTransitionable {
 241      static final String TAG = &quot;AppsCustomizePagedView&quot;;
 242  
 243      /**
 244       * The different content types that this paged view can show.
 245       */
 246      public enum ContentType {
 247          Applications,
 248          Widgets
 249      }
 250  
 251      // Refs
 252      private Launcher mLauncher;
 253      private DragController mDragController;
 254      private final LayoutInflater mLayoutInflater;
 255      private final PackageManager mPackageManager;
 256  
 257      // Save and Restore
 258      private int mSaveInstanceStateItemIndex = -1;
 259      private PagedViewIcon mPressedIcon;
 260  
 261      // Content
 262      private ArrayList&lt;ApplicationInfo&gt; mApps;
 263      private ArrayList&lt;Object&gt; mWidgets;
 264  
 265      // Cling
 266      private boolean mHasShownAllAppsCling;
 267      private int mClingFocusedX;
 268      private int mClingFocusedY;
 269  
 270      // Caching
 271      private Canvas mCanvas;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 272 -    private Drawable mDefaultWidgetBackground;</span>
 273      private IconCache mIconCache;
 274  
 275      // Dimens
 276      private int mContentWidth;
 277      private int mAppIconSize;
 278      private int mMaxAppCellCountX, mMaxAppCellCountY;
 279      private int mWidgetCountX, mWidgetCountY;
 280      private int mWidgetWidthGap, mWidgetHeightGap;
 281      private final float sWidgetPreviewIconPaddingPercentage = 0.25f;
 282      private PagedViewCellLayout mWidgetSpacingLayout;
 283      private int mNumAppsPages;
 284      private int mNumWidgetPages;
 285  
 286      // Relating to the scroll and overscroll effects
 287      Workspace.ZInterpolator mZInterpolator = new Workspace.ZInterpolator(0.5f);
 288      private static float CAMERA_DISTANCE = 6500;
 289      private static float TRANSITION_SCALE_FACTOR = 0.74f;
 290      private static float TRANSITION_PIVOT = 0.65f;
 291      private static float TRANSITION_MAX_ROTATION = 22;
 292      private static final boolean PERFORM_OVERSCROLL_ROTATION = true;
 293      private AccelerateInterpolator mAlphaInterpolator = new AccelerateInterpolator(0.9f);
 294      private DecelerateInterpolator mLeftScreenAlphaInterpolator = new DecelerateInterpolator(4);
 295  
 296      // Previews &amp; outlines
 297      ArrayList&lt;AppsCustomizeAsyncTask&gt; mRunningTasks;
 298      private static final int sPageSleepDelay = 200;
 299  
 300      private Runnable mInflateWidgetRunnable = null;
 301      private Runnable mBindWidgetRunnable = null;
 302      static final int WIDGET_NO_CLEANUP_REQUIRED = -1;
 303      static final int WIDGET_PRELOAD_PENDING = 0;
 304      static final int WIDGET_BOUND = 1;
 305      static final int WIDGET_INFLATED = 2;
 306      int mWidgetCleanupState = WIDGET_NO_CLEANUP_REQUIRED;
 307      int mWidgetLoadingId = -1;
 308      PendingAddWidgetInfo mCreateWidgetInfo = null;
 309      private boolean mDraggingWidget = false;
 310  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 311 +    private Toast mWidgetInstructionToast;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 312 +</span>
 313      // Deferral of loading widget previews during launcher transitions
 314      private boolean mInTransition;
 315      private ArrayList&lt;AsyncTaskPageData&gt; mDeferredSyncWidgetPageItems =
 316          new ArrayList&lt;AsyncTaskPageData&gt;();
 317      private ArrayList&lt;Runnable&gt; mDeferredPrepareLoadWidgetPreviewsTasks =
 318          new ArrayList&lt;Runnable&gt;();
 319  
 320      // Used for drawing shortcut previews
 321      BitmapCache mCachedShortcutPreviewBitmap = new BitmapCache();
 322      PaintCache mCachedShortcutPreviewPaint = new PaintCache();
 323      CanvasCache mCachedShortcutPreviewCanvas = new CanvasCache();
 324  
 325      // Used for drawing widget previews
 326      CanvasCache mCachedAppWidgetPreviewCanvas = new CanvasCache();
 327      RectCache mCachedAppWidgetPreviewSrcRect = new RectCache();
 328      RectCache mCachedAppWidgetPreviewDestRect = new RectCache();
 329      PaintCache mCachedAppWidgetPreviewPaint = new PaintCache();
 330  
 331      public AppsCustomizePagedView(Context context, AttributeSet attrs) {
 332          super(context, attrs);
 333          mLayoutInflater = LayoutInflater.from(context);
 334          mPackageManager = context.getPackageManager();
 335          mApps = new ArrayList&lt;ApplicationInfo&gt;();
 336          mWidgets = new ArrayList&lt;Object&gt;();
 337          mIconCache = ((LauncherApplication) context.getApplicationContext()).getIconCache();
 338          mCanvas = new Canvas();
 339          mRunningTasks = new ArrayList&lt;AppsCustomizeAsyncTask&gt;();
 340  
 341          // Save the default widget preview background
 342          Resources resources = context.getResources();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 343 -        mDefaultWidgetBackground = resources.getDrawable(R.drawable.default_widget_preview_holo);</span>
 344          mAppIconSize = resources.getDimensionPixelSize(R.dimen.app_icon_size);
 345  
 346          TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.AppsCustomizePagedView, 0, 0);
 347          mMaxAppCellCountX = a.getInt(R.styleable.AppsCustomizePagedView_maxAppCellCountX, -1);
 348          mMaxAppCellCountY = a.getInt(R.styleable.AppsCustomizePagedView_maxAppCellCountY, -1);
 349          mWidgetWidthGap =
 350              a.getDimensionPixelSize(R.styleable.AppsCustomizePagedView_widgetCellWidthGap, 0);
 351          mWidgetHeightGap =
 352              a.getDimensionPixelSize(R.styleable.AppsCustomizePagedView_widgetCellHeightGap, 0);
 353          mWidgetCountX = a.getInt(R.styleable.AppsCustomizePagedView_widgetCountX, 2);
 354          mWidgetCountY = a.getInt(R.styleable.AppsCustomizePagedView_widgetCountY, 2);
 355          mClingFocusedX = a.getInt(R.styleable.AppsCustomizePagedView_clingFocusedX, 0);
 356          mClingFocusedY = a.getInt(R.styleable.AppsCustomizePagedView_clingFocusedY, 0);
 357          a.recycle();
 358          mWidgetSpacingLayout = new PagedViewCellLayout(getContext());
 359  
 360          // The padding on the non-matched dimension for the default widget preview icons
 361          // (top + bottom)
 362          mFadeInAdjacentScreens = false;
 363  
 364          // Unless otherwise specified this view is important for accessibility.
 365          if (getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
 366              setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
 367          }
 368      }
 369  
 370      @Override
 371      protected void init() {
 372          super.init();
 373          mCenterPagesVertically = false;
 374  
 375          Context context = getContext();
 376          Resources r = context.getResources();
 377          setDragSlopeThreshold(r.getInteger(R.integer.config_appsCustomizeDragSlopeThreshold)/100f);
 378      }
 379  
 380      @Override
 381      protected void onUnhandledTap(MotionEvent ev) {
 382          if (LauncherApplication.isScreenLarge()) {
 383              // Dismiss AppsCustomize if we tap
 384              mLauncher.showWorkspace(true);
 385          }
 386      }
 387  
 388      /** Returns the item index of the center item on this page so that we can restore to this
 389       *  item index when we rotate. */
 390      private int getMiddleComponentIndexOnCurrentPage() {
 391          int i = -1;
 392          if (getPageCount() &gt; 0) {
 393              int currentPage = getCurrentPage();
 394              if (currentPage &lt; mNumAppsPages) {
 395                  PagedViewCellLayout layout = (PagedViewCellLayout) getPageAt(currentPage);
 396                  PagedViewCellLayoutChildren childrenLayout = layout.getChildrenLayout();
 397                  int numItemsPerPage = mCellCountX * mCellCountY;
 398                  int childCount = childrenLayout.getChildCount();
 399                  if (childCount &gt; 0) {
 400                      i = (currentPage * numItemsPerPage) + (childCount / 2);
 401                  }
 402              } else {
 403                  int numApps = mApps.size();
 404                  PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(currentPage);
 405                  int numItemsPerPage = mWidgetCountX * mWidgetCountY;
 406                  int childCount = layout.getChildCount();
 407                  if (childCount &gt; 0) {
 408                      i = numApps +
 409                          ((currentPage - mNumAppsPages) * numItemsPerPage) + (childCount / 2);
 410                  }
 411              }
 412          }
 413          return i;
 414      }
 415  
 416      /** Get the index of the item to restore to if we need to restore the current page. */
 417      int getSaveInstanceStateIndex() {
 418          if (mSaveInstanceStateItemIndex == -1) {
 419              mSaveInstanceStateItemIndex = getMiddleComponentIndexOnCurrentPage();
 420          }
 421          return mSaveInstanceStateItemIndex;
 422      }
 423  
 424      /** Returns the page in the current orientation which is expected to contain the specified
 425       *  item index. */
 426      int getPageForComponent(int index) {
 427          if (index &lt; 0) return 0;
 428  
 429          if (index &lt; mApps.size()) {
 430              int numItemsPerPage = mCellCountX * mCellCountY;
 431              return (index / numItemsPerPage);
 432          } else {
 433              int numItemsPerPage = mWidgetCountX * mWidgetCountY;
 434              return mNumAppsPages + ((index - mApps.size()) / numItemsPerPage);
 435          }
 436      }
 437  
 438      /** Restores the page for an item at the specified index */
 439      void restorePageForIndex(int index) {
 440          if (index &lt; 0) return;
 441          mSaveInstanceStateItemIndex = index;
 442      }
 443  
 444      private void updatePageCounts() {
 445          mNumWidgetPages = (int) Math.ceil(mWidgets.size() /
 446                  (float) (mWidgetCountX * mWidgetCountY));
 447          mNumAppsPages = (int) Math.ceil((float) mApps.size() / (mCellCountX * mCellCountY));
 448      }
 449  
 450      protected void onDataReady(int width, int height) {
 451          // Note that we transpose the counts in portrait so that we get a similar layout
 452          boolean isLandscape = getResources().getConfiguration().orientation ==
 453              Configuration.ORIENTATION_LANDSCAPE;
 454          int maxCellCountX = Integer.MAX_VALUE;
 455          int maxCellCountY = Integer.MAX_VALUE;
 456          if (LauncherApplication.isScreenLarge()) {
 457              maxCellCountX = (isLandscape ? LauncherModel.getCellCountX() :
 458                  LauncherModel.getCellCountY());
 459              maxCellCountY = (isLandscape ? LauncherModel.getCellCountY() :
 460                  LauncherModel.getCellCountX());
 461          }
 462          if (mMaxAppCellCountX &gt; -1) {
 463              maxCellCountX = Math.min(maxCellCountX, mMaxAppCellCountX);
 464          }
 465          if (mMaxAppCellCountY &gt; -1) {
 466              maxCellCountY = Math.min(maxCellCountY, mMaxAppCellCountY);
 467          }
 468  
 469          // Now that the data is ready, we can calculate the content width, the number of cells to
 470          // use for each page
 471          mWidgetSpacingLayout.setGap(mPageLayoutWidthGap, mPageLayoutHeightGap);
 472          mWidgetSpacingLayout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
 473                  mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
 474          mWidgetSpacingLayout.calculateCellCount(width, height, maxCellCountX, maxCellCountY);
 475          mCellCountX = mWidgetSpacingLayout.getCellCountX();
 476          mCellCountY = mWidgetSpacingLayout.getCellCountY();
 477          updatePageCounts();
 478  
 479          // Force a measure to update recalculate the gaps
 480          int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
 481          int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
 482          mWidgetSpacingLayout.measure(widthSpec, heightSpec);
 483          mContentWidth = mWidgetSpacingLayout.getContentWidth();
 484  
 485          AppsCustomizeTabHost host = (AppsCustomizeTabHost) getTabHost();
 486          final boolean hostIsTransitioning = host.isTransitioning();
 487  
 488          // Restore the page
 489          int page = getPageForComponent(mSaveInstanceStateItemIndex);
 490          invalidatePageData(Math.max(0, page), hostIsTransitioning);
 491  
 492          // Show All Apps cling if we are finished transitioning, otherwise, we will try again when
 493          // the transition completes in AppsCustomizeTabHost (otherwise the wrong offsets will be
 494          // returned while animating)
 495          if (!hostIsTransitioning) {
 496              post(new Runnable() {
 497                  @Override
 498                  public void run() {
 499                      showAllAppsCling();
 500                  }
 501              });
 502          }
 503      }
 504  
 505      void showAllAppsCling() {
 506          if (!mHasShownAllAppsCling &amp;&amp; isDataReady()) {
 507              mHasShownAllAppsCling = true;
 508              // Calculate the position for the cling punch through
 509              int[] offset = new int[2];
 510              int[] pos = mWidgetSpacingLayout.estimateCellPosition(mClingFocusedX, mClingFocusedY);
 511              mLauncher.getDragLayer().getLocationInDragLayer(this, offset);
 512              // PagedViews are centered horizontally but top aligned
 513              pos[0] += (getMeasuredWidth() - mWidgetSpacingLayout.getMeasuredWidth()) / 2 +
 514                      offset[0];
 515              pos[1] += offset[1];
 516              mLauncher.showFirstRunAllAppsCling(pos);
 517          }
 518      }
 519  
 520      @Override
 521      protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 522          int width = MeasureSpec.getSize(widthMeasureSpec);
 523          int height = MeasureSpec.getSize(heightMeasureSpec);
 524          if (!isDataReady()) {
 525              if (!mApps.isEmpty() &amp;&amp; !mWidgets.isEmpty()) {
 526                  setDataIsReady();
 527                  setMeasuredDimension(width, height);
 528                  onDataReady(width, height);
 529              }
 530          }
 531  
 532          super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 533      }
 534  
 535      public void onPackagesUpdated() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 536 -        // TODO: this isn&#x27;t ideal, but we actually need to delay here. This call is triggered</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 537 -        // by a broadcast receiver, and in order for it to work correctly, we need to know that</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 538 -        // the AppWidgetService has already received and processed the same broadcast. Since there</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 539 -        // is no guarantee about ordering of broadcast receipt, we just delay here. This is a</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 540 -        // workaround until we add a callback from AppWidgetService to AppWidgetHost when widget</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 541 -        // packages are added, updated or removed.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 542 -        postDelayed(new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 543 -           public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 544 -               updatePackages();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 545 -           }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 546 -        }, 1500);</span>
















<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 547 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 548 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 549 -    public void updatePackages() {</span>
 550          // Get the list of widgets and shortcuts
 551          mWidgets.clear();
 552          List&lt;AppWidgetProviderInfo&gt; widgets =
 553              AppWidgetManager.getInstance(mLauncher).getInstalledProviders();
 554          Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
 555          List&lt;ResolveInfo&gt; shortcuts = mPackageManager.queryIntentActivities(shortcutsIntent, 0);
 556          for (AppWidgetProviderInfo widget : widgets) {
 557              if (widget.minWidth &gt; 0 &amp;&amp; widget.minHeight &gt; 0) {
 558                  // Ensure that all widgets we show can be added on a workspace of this size
 559                  int[] spanXY = Launcher.getSpanForWidget(mLauncher, widget);
 560                  int[] minSpanXY = Launcher.getMinSpanForWidget(mLauncher, widget);
 561                  int minSpanX = Math.min(spanXY[0], minSpanXY[0]);
 562                  int minSpanY = Math.min(spanXY[1], minSpanXY[1]);
 563                  if (minSpanX &lt;= LauncherModel.getCellCountX() &amp;&amp;
 564                          minSpanY &lt;= LauncherModel.getCellCountY()) {
 565                      mWidgets.add(widget);
 566                  } else {
 567                      Log.e(TAG, &quot;Widget &quot; + widget.provider + &quot; can not fit on this device (&quot; +
 568                              widget.minWidth + &quot;, &quot; + widget.minHeight + &quot;)&quot;);
 569                  }
 570              } else {
 571                  Log.e(TAG, &quot;Widget &quot; + widget.provider + &quot; has invalid dimensions (&quot; +
 572                          widget.minWidth + &quot;, &quot; + widget.minHeight + &quot;)&quot;);
 573              }
 574          }
 575          mWidgets.addAll(shortcuts);
 576          Collections.sort(mWidgets,
 577                  new LauncherModel.WidgetAndShortcutNameComparator(mPackageManager));
 578          updatePageCounts();
 579          invalidateOnDataChange();
 580      }
 581  
 582      @Override
 583      public void onClick(View v) {
 584          // When we have exited all apps or are in transition, disregard clicks
 585          if (!mLauncher.isAllAppsCustomizeOpen() ||

 586                  mLauncher.getWorkspace().isSwitchingState()) return;
 587  
 588          if (v instanceof PagedViewIcon) {
 589              // Animate some feedback to the click
 590              final ApplicationInfo appInfo = (ApplicationInfo) v.getTag();
 591  
 592              // Lock the drawable state to pressed until we return to Launcher
 593              if (mPressedIcon != null) {
 594                  mPressedIcon.lockDrawableState();
 595              }
 596  
 597              // NOTE: We want all transitions from launcher to act as if the wallpaper were enabled
 598              // to be consistent.  So re-enable the flag here, and we will re-disable it as necessary
 599              // when Launcher resumes and we are still in AllApps.
 600              mLauncher.updateWallpaperVisibility(true);
 601              mLauncher.startActivitySafely(v, appInfo.intent, appInfo);
 602  
 603          } else if (v instanceof PagedViewWidget) {
 604              // Let the user know that they have to long press to add a widget
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 605 -            Toast.makeText(getContext(), R.string.long_press_widget_to_add,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 606 -                    Toast.LENGTH_SHORT).show();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 607 +            if (mWidgetInstructionToast != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 608 +                mWidgetInstructionToast.cancel();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 609 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 610 +            mWidgetInstructionToast = Toast.makeText(getContext(),R.string.long_press_widget_to_add,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 611 +                Toast.LENGTH_SHORT);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 612 +            mWidgetInstructionToast.show();</span>
 613  
 614              // Create a little animation to show that the widget can move
 615              float offsetY = getResources().getDimensionPixelSize(R.dimen.dragViewOffsetY);
 616              final ImageView p = (ImageView) v.findViewById(R.id.widget_preview);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 617 -            AnimatorSet bounce = new AnimatorSet();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 618 -            ValueAnimator tyuAnim = ObjectAnimator.ofFloat(p, &quot;translationY&quot;, offsetY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 619 +            AnimatorSet bounce = LauncherAnimUtils.createAnimatorSet();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 620 +            ValueAnimator tyuAnim = LauncherAnimUtils.ofFloat(p, &quot;translationY&quot;, offsetY);</span>
 621              tyuAnim.setDuration(125);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 622 -            ValueAnimator tydAnim = ObjectAnimator.ofFloat(p, &quot;translationY&quot;, 0f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 623 +            ValueAnimator tydAnim = LauncherAnimUtils.ofFloat(p, &quot;translationY&quot;, 0f);</span>
 624              tydAnim.setDuration(100);
 625              bounce.play(tyuAnim).before(tydAnim);
 626              bounce.setInterpolator(new AccelerateInterpolator());
 627              bounce.start();
 628          }
 629      }
 630  
 631      public boolean onKey(View v, int keyCode, KeyEvent event) {
 632          return FocusHelper.handleAppsCustomizeKeyEvent(v,  keyCode, event);
 633      }
 634  
 635      /*
 636       * PagedViewWithDraggableItems implementation
 637       */
 638      @Override
 639      protected void determineDraggingStart(android.view.MotionEvent ev) {
 640          // Disable dragging by pulling an app down for now.
 641      }
 642  
 643      private void beginDraggingApplication(View v) {
 644          mLauncher.getWorkspace().onDragStartedWithItem(v);
 645          mLauncher.getWorkspace().beginDragShared(v, this);
 646      }
 647  
 648      private void preloadWidget(final PendingAddWidgetInfo info) {
 649          final AppWidgetProviderInfo pInfo = info.info;
 650          if (pInfo.configure != null) {
 651              return;
 652          }
 653  
 654          mWidgetCleanupState = WIDGET_PRELOAD_PENDING;
 655          mBindWidgetRunnable = new Runnable() {
 656              @Override
 657              public void run() {
 658                  mWidgetLoadingId = mLauncher.getAppWidgetHost().allocateAppWidgetId();
 659                  if (AppWidgetManager.getInstance(mLauncher)
 660                              .bindAppWidgetIdIfAllowed(mWidgetLoadingId, info.componentName)) {
 661                      mWidgetCleanupState = WIDGET_BOUND;
 662                  }
 663              }
 664          };
 665          post(mBindWidgetRunnable);
 666  
 667          mInflateWidgetRunnable = new Runnable() {
 668              @Override
 669              public void run() {
 670                  AppWidgetHostView hostView = mLauncher.
 671                          getAppWidgetHost().createView(getContext(), mWidgetLoadingId, pInfo);
 672                  info.boundWidget = hostView;
 673                  mWidgetCleanupState = WIDGET_INFLATED;
 674                  hostView.setVisibility(INVISIBLE);
 675                  int[] unScaledSize = mLauncher.getWorkspace().estimateItemSize(info.spanX,
 676                          info.spanY, info, false);
 677  
 678                  // We want the first widget layout to be the correct size. This will be important
 679                  // for width size reporting to the AppWidgetManager.
 680                  DragLayer.LayoutParams lp = new DragLayer.LayoutParams(unScaledSize[0],
 681                          unScaledSize[1]);
 682                  lp.x = lp.y = 0;
 683                  lp.customPosition = true;
 684                  hostView.setLayoutParams(lp);
 685                  mLauncher.getDragLayer().addView(hostView);
 686              }
 687          };
 688          post(mInflateWidgetRunnable);
 689      }
 690  
 691      @Override
 692      public void onShortPress(View v) {
 693          // We are anticipating a long press, and we use this time to load bind and instantiate
 694          // the widget. This will need to be cleaned up if it turns out no long press occurs.
 695          if (mCreateWidgetInfo != null) {
 696              // Just in case the cleanup process wasn&#x27;t properly executed. This shouldn&#x27;t happen.
 697              cleanupWidgetPreloading(false);
 698          }
 699          mCreateWidgetInfo = new PendingAddWidgetInfo((PendingAddWidgetInfo) v.getTag());
 700          preloadWidget(mCreateWidgetInfo);
 701      }
 702  
 703      private void cleanupWidgetPreloading(boolean widgetWasAdded) {
 704          if (!widgetWasAdded) {
 705              // If the widget was not added, we may need to do further cleanup.
 706              PendingAddWidgetInfo info = mCreateWidgetInfo;
 707              mCreateWidgetInfo = null;
 708  
 709              if (mWidgetCleanupState == WIDGET_PRELOAD_PENDING) {
 710                  // We never did any preloading, so just remove pending callbacks to do so
 711                  removeCallbacks(mBindWidgetRunnable);
 712                  removeCallbacks(mInflateWidgetRunnable);
 713              } else if (mWidgetCleanupState == WIDGET_BOUND) {
 714                   // Delete the widget id which was allocated
 715                  if (mWidgetLoadingId != -1) {
 716                      mLauncher.getAppWidgetHost().deleteAppWidgetId(mWidgetLoadingId);
 717                  }
 718  
 719                  // We never got around to inflating the widget, so remove the callback to do so.
 720                  removeCallbacks(mInflateWidgetRunnable);
 721              } else if (mWidgetCleanupState == WIDGET_INFLATED) {
 722                  // Delete the widget id which was allocated
 723                  if (mWidgetLoadingId != -1) {
 724                      mLauncher.getAppWidgetHost().deleteAppWidgetId(mWidgetLoadingId);
 725                  }
 726  
 727                  // The widget was inflated and added to the DragLayer -- remove it.
 728                  AppWidgetHostView widget = info.boundWidget;
 729                  mLauncher.getDragLayer().removeView(widget);
 730              }
 731          }
 732          mWidgetCleanupState = WIDGET_NO_CLEANUP_REQUIRED;
 733          mWidgetLoadingId = -1;
 734          mCreateWidgetInfo = null;
 735          PagedViewWidget.resetShortPressTarget();
 736      }
 737  
 738      @Override
 739      public void cleanUpShortPress(View v) {
 740          if (!mDraggingWidget) {
 741              cleanupWidgetPreloading(false);
 742          }
 743      }
 744  
 745      private boolean beginDraggingWidget(View v) {
 746          mDraggingWidget = true;
 747          // Get the widget preview as the drag representation
 748          ImageView image = (ImageView) v.findViewById(R.id.widget_preview);
 749          PendingAddItemInfo createItemInfo = (PendingAddItemInfo) v.getTag();
 750  
 751          // If the ImageView doesn&#x27;t have a drawable yet, the widget preview hasn&#x27;t been loaded and
 752          // we abort the drag.
 753          if (image.getDrawable() == null) {
 754              mDraggingWidget = false;
 755              return false;
 756          }
 757  
 758          // Compose the drag image
 759          Bitmap preview;
 760          Bitmap outline;
 761          float scale = 1f;
 762          if (createItemInfo instanceof PendingAddWidgetInfo) {
 763              // This can happen in some weird cases involving multi-touch. We can&#x27;t start dragging
 764              // the widget if this is null, so we break out.
 765              if (mCreateWidgetInfo == null) {
 766                  return false;
 767              }
 768  
 769              PendingAddWidgetInfo createWidgetInfo = mCreateWidgetInfo;
 770              createItemInfo = createWidgetInfo;
 771              int spanX = createItemInfo.spanX;
 772              int spanY = createItemInfo.spanY;
 773              int[] size = mLauncher.getWorkspace().estimateItemSize(spanX, spanY,
 774                      createWidgetInfo, true);
 775  
 776              FastBitmapDrawable previewDrawable = (FastBitmapDrawable) image.getDrawable();
 777              float minScale = 1.25f;
 778              int maxWidth, maxHeight;
 779              maxWidth = Math.min((int) (previewDrawable.getIntrinsicWidth() * minScale), size[0]);
 780              maxHeight = Math.min((int) (previewDrawable.getIntrinsicHeight() * minScale), size[1]);
 781              preview = getWidgetPreview(createWidgetInfo.componentName, createWidgetInfo.previewImage,
 782                      createWidgetInfo.icon, spanX, spanY, maxWidth, maxHeight);
 783  
 784              // Determine the image view drawable scale relative to the preview
 785              float[] mv = new float[9];
 786              Matrix m = new Matrix();
 787              m.setRectToRect(
 788                      new RectF(0f, 0f, (float) preview.getWidth(), (float) preview.getHeight()),
 789                      new RectF(0f, 0f, (float) previewDrawable.getIntrinsicWidth(),
 790                              (float) previewDrawable.getIntrinsicHeight()),
 791                      Matrix.ScaleToFit.START);
 792              m.getValues(mv);
 793              scale = (float) mv[0];
 794          } else {
 795              PendingAddShortcutInfo createShortcutInfo = (PendingAddShortcutInfo) v.getTag();
 796              Drawable icon = mIconCache.getFullResIcon(createShortcutInfo.shortcutActivityInfo);
 797              preview = Bitmap.createBitmap(icon.getIntrinsicWidth(),
 798                      icon.getIntrinsicHeight(), Bitmap.Config.ARGB_8888);
 799  
 800              mCanvas.setBitmap(preview);
 801              mCanvas.save();
 802              renderDrawableToBitmap(icon, preview, 0, 0,
 803                      icon.getIntrinsicWidth(), icon.getIntrinsicHeight());
 804              mCanvas.restore();
 805              mCanvas.setBitmap(null);
 806              createItemInfo.spanX = createItemInfo.spanY = 1;
 807          }
 808  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 809 -        // We use a custom alpha clip table for the default widget previews</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 810 -        Paint alphaClipPaint = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 811 -        if (createItemInfo instanceof PendingAddWidgetInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 812 -            if (((PendingAddWidgetInfo) createItemInfo).previewImage != 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 813 -                MaskFilter alphaClipTable = TableMaskFilter.CreateClipTable(0, 255);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 814 -                alphaClipPaint = new Paint();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 815 -                alphaClipPaint.setMaskFilter(alphaClipTable);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 816 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 817 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 818 +        // Don&#x27;t clip alpha values for the drag outline if we&#x27;re using the default widget preview</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 819 +        boolean clipAlpha = !(createItemInfo instanceof PendingAddWidgetInfo &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 820 +                (((PendingAddWidgetInfo) createItemInfo).previewImage == 0));</span>
 821  
 822          // Save the preview for the outline generation, then dim the preview
 823          outline = Bitmap.createScaledBitmap(preview, preview.getWidth(), preview.getHeight(),
 824                  false);
 825  
 826          // Start the drag
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 827 -        alphaClipPaint = null;</span>
 828          mLauncher.lockScreenOrientation();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 829 -        mLauncher.getWorkspace().onDragStartedWithItem(createItemInfo, outline, alphaClipPaint);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 830 +        mLauncher.getWorkspace().onDragStartedWithItem(createItemInfo, outline, clipAlpha);</span>
 831          mDragController.startDrag(image, preview, this, createItemInfo,
 832                  DragController.DRAG_ACTION_COPY, null, scale);
 833          outline.recycle();
 834          preview.recycle();
 835          return true;
 836      }
 837  
 838      @Override
 839      protected boolean beginDragging(final View v) {
 840          if (!super.beginDragging(v)) return false;
 841  
 842          if (v instanceof PagedViewIcon) {
 843              beginDraggingApplication(v);
 844          } else if (v instanceof PagedViewWidget) {
 845              if (!beginDraggingWidget(v)) {
 846                  return false;
 847              }
 848          }
 849  
 850          // We delay entering spring-loaded mode slightly to make sure the UI
 851          // thready is free of any work.
 852          postDelayed(new Runnable() {
 853              @Override
 854              public void run() {
 855                  // We don&#x27;t enter spring-loaded mode if the drag has been cancelled
 856                  if (mLauncher.getDragController().isDragging()) {
 857                      // Dismiss the cling
 858                      mLauncher.dismissAllAppsCling(null);
 859  
 860                      // Reset the alpha on the dragged icon before we drag
 861                      resetDrawableState();
 862  
 863                      // Go into spring loaded mode (must happen before we startDrag())
 864                      mLauncher.enterSpringLoadedDragMode();
 865                  }
 866              }
 867          }, 150);
 868  
 869          return true;
 870      }
 871  
 872      /**
 873       * Clean up after dragging.
 874       *
 875       * @param target where the item was dragged to (can be null if the item was flung)
 876       */
 877      private void endDragging(View target, boolean isFlingToDelete, boolean success) {
 878          if (isFlingToDelete || !success || (target != mLauncher.getWorkspace() &amp;&amp;
 879                  !(target instanceof DeleteDropTarget))) {
 880              // Exit spring loaded mode if we have not successfully dropped or have not handled the
 881              // drop in Workspace
 882              mLauncher.exitSpringLoadedDragMode();
 883          }
 884          mLauncher.unlockScreenOrientation(false);
 885      }
 886  
 887      @Override
 888      public View getContent() {
 889          return null;
 890      }
 891  
 892      @Override
 893      public void onLauncherTransitionPrepare(Launcher l, boolean animated, boolean toWorkspace) {
 894          mInTransition = true;
 895          if (toWorkspace) {
 896              cancelAllTasks();
 897          }
 898      }
 899  
 900      @Override
 901      public void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace) {
 902      }
 903  
 904      @Override
 905      public void onLauncherTransitionStep(Launcher l, float t) {
 906      }
 907  
 908      @Override
 909      public void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace) {
 910          mInTransition = false;
 911          for (AsyncTaskPageData d : mDeferredSyncWidgetPageItems) {
 912              onSyncWidgetPageItems(d);
 913          }
 914          mDeferredSyncWidgetPageItems.clear();
 915          for (Runnable r : mDeferredPrepareLoadWidgetPreviewsTasks) {
 916              r.run();
 917          }
 918          mDeferredPrepareLoadWidgetPreviewsTasks.clear();
 919          mForceDrawAllChildrenNextFrame = !toWorkspace;
 920      }
 921  
 922      @Override
 923      public void onDropCompleted(View target, DragObject d, boolean isFlingToDelete,
 924              boolean success) {
 925          // Return early and wait for onFlingToDeleteCompleted if this was the result of a fling
 926          if (isFlingToDelete) return;
 927  
 928          endDragging(target, false, success);
 929  
 930          // Display an error message if the drag failed due to there not being enough space on the
 931          // target layout we were dropping on.
 932          if (!success) {
 933              boolean showOutOfSpaceMessage = false;
 934              if (target instanceof Workspace) {
 935                  int currentScreen = mLauncher.getCurrentWorkspaceScreen();
 936                  Workspace workspace = (Workspace) target;
 937                  CellLayout layout = (CellLayout) workspace.getChildAt(currentScreen);
 938                  ItemInfo itemInfo = (ItemInfo) d.dragInfo;
 939                  if (layout != null) {
 940                      layout.calculateSpans(itemInfo);
 941                      showOutOfSpaceMessage =
 942                              !layout.findCellForSpan(null, itemInfo.spanX, itemInfo.spanY);
 943                  }
 944              }
 945              if (showOutOfSpaceMessage) {
 946                  mLauncher.showOutOfSpaceMessage(false);
 947              }
 948  
 949              d.deferDragViewCleanupPostAnimation = false;
 950          }
 951          cleanupWidgetPreloading(success);
 952          mDraggingWidget = false;
 953      }
 954  
 955      @Override
 956      public void onFlingToDeleteCompleted() {
 957          // We just dismiss the drag when we fling, so cleanup here
 958          endDragging(null, true, true);
 959          cleanupWidgetPreloading(false);
 960          mDraggingWidget = false;
 961      }
 962  
 963      @Override
 964      public boolean supportsFlingToDelete() {
 965          return true;
 966      }
 967  
 968      @Override
 969      protected void onDetachedFromWindow() {
 970          super.onDetachedFromWindow();
 971          cancelAllTasks();
 972      }
 973  
 974      public void clearAllWidgetPages() {
 975          cancelAllTasks();
 976          int count = getChildCount();
 977          for (int i = 0; i &lt; count; i++) {
 978              View v = getPageAt(i);
 979              if (v instanceof PagedViewGridLayout) {
 980                  ((PagedViewGridLayout) v).removeAllViewsOnPage();
 981                  mDirtyPageContent.set(i, true);
 982              }
 983          }
 984      }
 985  
 986      private void cancelAllTasks() {
 987          // Clean up all the async tasks
 988          Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
 989          while (iter.hasNext()) {
 990              AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
 991              task.cancel(false);
 992              iter.remove();
 993              mDirtyPageContent.set(task.page, true);
 994  
 995              // We&#x27;ve already preallocated the views for the data to load into, so clear them as well
 996              View v = getPageAt(task.page);
 997              if (v instanceof PagedViewGridLayout) {
 998                  ((PagedViewGridLayout) v).removeAllViewsOnPage();
 999              }
1000          }
1001          mDeferredSyncWidgetPageItems.clear();
1002          mDeferredPrepareLoadWidgetPreviewsTasks.clear();
1003      }
1004  
1005      public void setContentType(ContentType type) {
1006          if (type == ContentType.Widgets) {
1007              invalidatePageData(mNumAppsPages, true);
1008          } else if (type == ContentType.Applications) {
1009              invalidatePageData(0, true);
1010          }
1011      }
1012  
1013      protected void snapToPage(int whichPage, int delta, int duration) {
1014          super.snapToPage(whichPage, delta, duration);
1015          updateCurrentTab(whichPage);
1016  
1017          // Update the thread priorities given the direction lookahead
1018          Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1019          while (iter.hasNext()) {
1020              AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1021              int pageIndex = task.page;
1022              if ((mNextPage &gt; mCurrentPage &amp;&amp; pageIndex &gt;= mCurrentPage) ||
1023                  (mNextPage &lt; mCurrentPage &amp;&amp; pageIndex &lt;= mCurrentPage)) {
1024                  task.setThreadPriority(getThreadPriorityForPage(pageIndex));
1025              } else {
1026                  task.setThreadPriority(Process.THREAD_PRIORITY_LOWEST);
1027              }
1028          }
1029      }
1030  
1031      private void updateCurrentTab(int currentPage) {
1032          AppsCustomizeTabHost tabHost = getTabHost();
1033          if (tabHost != null) {
1034              String tag = tabHost.getCurrentTabTag();
1035              if (tag != null) {
1036                  if (currentPage &gt;= mNumAppsPages &amp;&amp;
1037                          !tag.equals(tabHost.getTabTagForContentType(ContentType.Widgets))) {
1038                      tabHost.setCurrentTabFromContent(ContentType.Widgets);
1039                  } else if (currentPage &lt; mNumAppsPages &amp;&amp;
1040                          !tag.equals(tabHost.getTabTagForContentType(ContentType.Applications))) {
1041                      tabHost.setCurrentTabFromContent(ContentType.Applications);
1042                  }
1043              }
1044          }
1045      }
1046  
1047      /*
1048       * Apps PagedView implementation
1049       */
1050      private void setVisibilityOnChildren(ViewGroup layout, int visibility) {
1051          int childCount = layout.getChildCount();
1052          for (int i = 0; i &lt; childCount; ++i) {
1053              layout.getChildAt(i).setVisibility(visibility);
1054          }
1055      }
1056      private void setupPage(PagedViewCellLayout layout) {
1057          layout.setCellCount(mCellCountX, mCellCountY);
1058          layout.setGap(mPageLayoutWidthGap, mPageLayoutHeightGap);
1059          layout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
1060                  mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
1061  
1062          // Note: We force a measure here to get around the fact that when we do layout calculations
1063          // immediately after syncing, we don&#x27;t have a proper width.  That said, we already know the
1064          // expected page width, so we can actually optimize by hiding all the TextView-based
1065          // children that are expensive to measure, and let that happen naturally later.
1066          setVisibilityOnChildren(layout, View.GONE);
1067          int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
1068          int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
1069          layout.setMinimumWidth(getPageContentWidth());
1070          layout.measure(widthSpec, heightSpec);
1071          setVisibilityOnChildren(layout, View.VISIBLE);
1072      }
1073  
1074      public void syncAppsPageItems(int page, boolean immediate) {
1075          // ensure that we have the right number of items on the pages
1076          int numCells = mCellCountX * mCellCountY;
1077          int startIndex = page * numCells;
1078          int endIndex = Math.min(startIndex + numCells, mApps.size());
1079          PagedViewCellLayout layout = (PagedViewCellLayout) getPageAt(page);
1080  
1081          layout.removeAllViewsOnPage();
1082          ArrayList&lt;Object&gt; items = new ArrayList&lt;Object&gt;();
1083          ArrayList&lt;Bitmap&gt; images = new ArrayList&lt;Bitmap&gt;();
1084          for (int i = startIndex; i &lt; endIndex; ++i) {
1085              ApplicationInfo info = mApps.get(i);
1086              PagedViewIcon icon = (PagedViewIcon) mLayoutInflater.inflate(
1087                      R.layout.apps_customize_application, layout, false);
1088              icon.applyFromApplicationInfo(info, true, this);
1089              icon.setOnClickListener(this);
1090              icon.setOnLongClickListener(this);
1091              icon.setOnTouchListener(this);
1092              icon.setOnKeyListener(this);
1093  
1094              int index = i - startIndex;
1095              int x = index % mCellCountX;
1096              int y = index / mCellCountX;
1097              layout.addViewToCellLayout(icon, -1, i, new PagedViewCellLayout.LayoutParams(x,y, 1,1));
1098  
1099              items.add(info);
1100              images.add(info.iconBitmap);
1101          }
1102  
1103          layout.createHardwareLayers();
1104      }
1105  
1106      /**
1107       * A helper to return the priority for loading of the specified widget page.
1108       */
1109      private int getWidgetPageLoadPriority(int page) {
1110          // If we are snapping to another page, use that index as the target page index
1111          int toPage = mCurrentPage;
1112          if (mNextPage &gt; -1) {
1113              toPage = mNextPage;
1114          }
1115  
1116          // We use the distance from the target page as an initial guess of priority, but if there
1117          // are no pages of higher priority than the page specified, then bump up the priority of
1118          // the specified page.
1119          Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1120          int minPageDiff = Integer.MAX_VALUE;
1121          while (iter.hasNext()) {
1122              AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1123              minPageDiff = Math.abs(task.page - toPage);
1124          }
1125  
1126          int rawPageDiff = Math.abs(page - toPage);
1127          return rawPageDiff - Math.min(rawPageDiff, minPageDiff);
1128      }
1129      /**
1130       * Return the appropriate thread priority for loading for a given page (we give the current
1131       * page much higher priority)
1132       */
1133      private int getThreadPriorityForPage(int page) {
1134          // TODO-APPS_CUSTOMIZE: detect number of cores and set thread priorities accordingly below
1135          int pageDiff = getWidgetPageLoadPriority(page);
1136          if (pageDiff &lt;= 0) {
1137              return Process.THREAD_PRIORITY_LESS_FAVORABLE;
1138          } else if (pageDiff &lt;= 1) {
1139              return Process.THREAD_PRIORITY_LOWEST;
1140          } else {
1141              return Process.THREAD_PRIORITY_LOWEST;
1142          }
1143      }
1144      private int getSleepForPage(int page) {
1145          int pageDiff = getWidgetPageLoadPriority(page);
1146          return Math.max(0, pageDiff * sPageSleepDelay);
1147      }
1148      /**
1149       * Creates and executes a new AsyncTask to load a page of widget previews.
1150       */
1151      private void prepareLoadWidgetPreviewsTask(int page, ArrayList&lt;Object&gt; widgets,
1152              int cellWidth, int cellHeight, int cellCountX) {
1153  
1154          // Prune all tasks that are no longer needed
1155          Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1156          while (iter.hasNext()) {
1157              AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1158              int taskPage = task.page;
1159              if (taskPage &lt; getAssociatedLowerPageBound(mCurrentPage) ||
1160                      taskPage &gt; getAssociatedUpperPageBound(mCurrentPage)) {
1161                  task.cancel(false);
1162                  iter.remove();
1163              } else {
1164                  task.setThreadPriority(getThreadPriorityForPage(taskPage));
1165              }
1166          }
1167  
1168          // We introduce a slight delay to order the loading of side pages so that we don&#x27;t thrash
1169          final int sleepMs = getSleepForPage(page);
1170          AsyncTaskPageData pageData = new AsyncTaskPageData(page, widgets, cellWidth, cellHeight,
1171              new AsyncTaskCallback() {
1172                  @Override
1173                  public void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data) {
1174                      try {
1175                          try {
1176                              Thread.sleep(sleepMs);
1177                          } catch (Exception e) {}
1178                          loadWidgetPreviewsInBackground(task, data);
1179                      } finally {
1180                          if (task.isCancelled()) {
1181                              data.cleanup(true);
1182                          }
1183                      }
1184                  }
1185              },
1186              new AsyncTaskCallback() {
1187                  @Override
1188                  public void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data) {
1189                      mRunningTasks.remove(task);
1190                      if (task.isCancelled()) return;
1191                      // do cleanup inside onSyncWidgetPageItems
1192                      onSyncWidgetPageItems(data);
1193                  }
1194              });
1195  
1196          // Ensure that the task is appropriately prioritized and runs in parallel
1197          AppsCustomizeAsyncTask t = new AppsCustomizeAsyncTask(page,
1198                  AsyncTaskPageData.Type.LoadWidgetPreviewData);
1199          t.setThreadPriority(getThreadPriorityForPage(page));
1200          t.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, pageData);
1201          mRunningTasks.add(t);
1202      }
1203  
1204      /*
1205       * Widgets PagedView implementation
1206       */
1207      private void setupPage(PagedViewGridLayout layout) {
1208          layout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
1209                  mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
1210  
1211          // Note: We force a measure here to get around the fact that when we do layout calculations
1212          // immediately after syncing, we don&#x27;t have a proper width.
1213          int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
1214          int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
1215          layout.setMinimumWidth(getPageContentWidth());
1216          layout.measure(widthSpec, heightSpec);
1217      }
1218  
1219      private void renderDrawableToBitmap(Drawable d, Bitmap bitmap, int x, int y, int w, int h) {
1220          renderDrawableToBitmap(d, bitmap, x, y, w, h, 1f);
1221      }
1222  
1223      private void renderDrawableToBitmap(Drawable d, Bitmap bitmap, int x, int y, int w, int h,
1224              float scale) {
1225          if (bitmap != null) {
1226              Canvas c = new Canvas(bitmap);
1227              c.scale(scale, scale);
1228              Rect oldBounds = d.copyBounds();
1229              d.setBounds(x, y, x + w, y + h);
1230              d.draw(c);
1231              d.setBounds(oldBounds); // Restore the bounds
1232              c.setBitmap(null);
1233          }
1234      }
1235  
1236      private Bitmap getShortcutPreview(ResolveInfo info, int maxWidth, int maxHeight) {
1237          Bitmap tempBitmap = mCachedShortcutPreviewBitmap.get();
1238          final Canvas c = mCachedShortcutPreviewCanvas.get();
1239          if (tempBitmap == null ||
1240                  tempBitmap.getWidth() != maxWidth ||
1241                  tempBitmap.getHeight() != maxHeight) {
1242              tempBitmap = Bitmap.createBitmap(maxWidth, maxHeight, Config.ARGB_8888);
1243              mCachedShortcutPreviewBitmap.set(tempBitmap);
1244          } else {
1245              c.setBitmap(tempBitmap);
1246              c.drawColor(0, PorterDuff.Mode.CLEAR);
1247              c.setBitmap(null);
1248          }
1249          // Render the icon
1250          Drawable icon = mIconCache.getFullResIcon(info);
1251  
1252          int paddingTop =
1253                  getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_top);
1254          int paddingLeft =
1255                  getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_left);
1256          int paddingRight =
1257                  getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_right);
1258  
1259          int scaledIconWidth = (maxWidth - paddingLeft - paddingRight);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1260 -        float scaleSize = scaledIconWidth / (float) mAppIconSize;</span>
1261  
1262          renderDrawableToBitmap(
1263                  icon, tempBitmap, paddingLeft, paddingTop, scaledIconWidth, scaledIconWidth);
1264  
1265          Bitmap preview = Bitmap.createBitmap(maxWidth, maxHeight, Config.ARGB_8888);
1266          c.setBitmap(preview);
1267          Paint p = mCachedShortcutPreviewPaint.get();
1268          if (p == null) {
1269              p = new Paint();
1270              ColorMatrix colorMatrix = new ColorMatrix();
1271              colorMatrix.setSaturation(0);
1272              p.setColorFilter(new ColorMatrixColorFilter(colorMatrix));
1273              p.setAlpha((int) (255 * 0.06f));
1274              //float density = 1f;
1275              //p.setMaskFilter(new BlurMaskFilter(15*density, BlurMaskFilter.Blur.NORMAL));
1276              mCachedShortcutPreviewPaint.set(p);
1277          }
1278          c.drawBitmap(tempBitmap, 0, 0, p);
1279          c.setBitmap(null);
1280  
1281          renderDrawableToBitmap(icon, preview, 0, 0, mAppIconSize, mAppIconSize);
1282  
1283          return preview;
1284      }
1285  
1286      private Bitmap getWidgetPreview(ComponentName provider, int previewImage,
1287              int iconId, int cellHSpan, int cellVSpan, int maxWidth,
1288              int maxHeight) {
1289          // Load the preview image if possible
1290          String packageName = provider.getPackageName();
1291          if (maxWidth &lt; 0) maxWidth = Integer.MAX_VALUE;
1292          if (maxHeight &lt; 0) maxHeight = Integer.MAX_VALUE;
1293  
1294          Drawable drawable = null;
1295          if (previewImage != 0) {
1296              drawable = mPackageManager.getDrawable(packageName, previewImage, null);
1297              if (drawable == null) {
1298                  Log.w(TAG, &quot;Can&#x27;t load widget preview drawable 0x&quot; +
1299                          Integer.toHexString(previewImage) + &quot; for provider: &quot; + provider);
1300              }
1301          }
1302  
1303          int bitmapWidth;
1304          int bitmapHeight;
1305          Bitmap defaultPreview = null;
1306          boolean widgetPreviewExists = (drawable != null);
1307          if (widgetPreviewExists) {
1308              bitmapWidth = drawable.getIntrinsicWidth();
1309              bitmapHeight = drawable.getIntrinsicHeight();
1310          } else {
1311              // Generate a preview image if we couldn&#x27;t load one
1312              if (cellHSpan &lt; 1) cellHSpan = 1;
1313              if (cellVSpan &lt; 1) cellVSpan = 1;
1314  
1315              BitmapDrawable previewDrawable = (BitmapDrawable) getResources()
1316                      .getDrawable(R.drawable.widget_preview_tile);
1317              final int previewDrawableWidth = previewDrawable
1318                      .getIntrinsicWidth();
1319              final int previewDrawableHeight = previewDrawable
1320                      .getIntrinsicHeight();
1321              bitmapWidth = previewDrawableWidth * cellHSpan; // subtract 2 dips
1322              bitmapHeight = previewDrawableHeight * cellVSpan;
1323  
1324              defaultPreview = Bitmap.createBitmap(bitmapWidth, bitmapHeight,
1325                      Config.ARGB_8888);
1326              final Canvas c = mCachedAppWidgetPreviewCanvas.get();
1327              c.setBitmap(defaultPreview);
1328              previewDrawable.setBounds(0, 0, bitmapWidth, bitmapHeight);
1329              previewDrawable.setTileModeXY(Shader.TileMode.REPEAT,
1330                      Shader.TileMode.REPEAT);
1331              previewDrawable.draw(c);
1332              c.setBitmap(null);
1333  
1334              // Draw the icon in the top left corner
1335              int minOffset = (int) (mAppIconSize * sWidgetPreviewIconPaddingPercentage);
1336              int smallestSide = Math.min(bitmapWidth, bitmapHeight);
1337              float iconScale = Math.min((float) smallestSide
1338                      / (mAppIconSize + 2 * minOffset), 1f);
1339  
1340              try {
1341                  Drawable icon = null;
1342                  int hoffset =
1343                          (int) ((previewDrawableWidth - mAppIconSize * iconScale) / 2);
1344                  int yoffset =
1345                          (int) ((previewDrawableHeight - mAppIconSize * iconScale) / 2);
1346                  if (iconId &gt; 0)
1347                      icon = mIconCache.getFullResIcon(packageName, iconId);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1348 -                Resources resources = mLauncher.getResources();</span>
1349                  if (icon != null) {
1350                      renderDrawableToBitmap(icon, defaultPreview, hoffset,
1351                              yoffset, (int) (mAppIconSize * iconScale),
1352                              (int) (mAppIconSize * iconScale));
1353                  }
1354              } catch (Resources.NotFoundException e) {
1355              }
1356          }
1357  
1358          // Scale to fit width only - let the widget preview be clipped in the
1359          // vertical dimension
1360          float scale = 1f;
1361          if (bitmapWidth &gt; maxWidth) {
1362              scale = maxWidth / (float) bitmapWidth;
1363          }
1364          if (scale != 1f) {
1365              bitmapWidth = (int) (scale * bitmapWidth);
1366              bitmapHeight = (int) (scale * bitmapHeight);
1367          }
1368  
1369          Bitmap preview = Bitmap.createBitmap(bitmapWidth, bitmapHeight,
1370                  Config.ARGB_8888);
1371  
1372          // Draw the scaled preview into the final bitmap
1373          if (widgetPreviewExists) {
1374              renderDrawableToBitmap(drawable, preview, 0, 0, bitmapWidth,
1375                      bitmapHeight);
1376          } else {
1377              final Canvas c = mCachedAppWidgetPreviewCanvas.get();
1378              final Rect src = mCachedAppWidgetPreviewSrcRect.get();
1379              final Rect dest = mCachedAppWidgetPreviewDestRect.get();
1380              c.setBitmap(preview);
1381              src.set(0, 0, defaultPreview.getWidth(), defaultPreview.getHeight());
1382              dest.set(0, 0, preview.getWidth(), preview.getHeight());
1383  
1384              Paint p = mCachedAppWidgetPreviewPaint.get();
1385              if (p == null) {
1386                  p = new Paint();
1387                  p.setFilterBitmap(true);
1388                  mCachedAppWidgetPreviewPaint.set(p);
1389              }
1390              c.drawBitmap(defaultPreview, src, dest, p);
1391              c.setBitmap(null);
1392          }
1393          return preview;
1394      }
1395  
1396      public void syncWidgetPageItems(final int page, final boolean immediate) {
1397          int numItemsPerPage = mWidgetCountX * mWidgetCountY;
1398  
1399          // Calculate the dimensions of each cell we are giving to each widget
1400          final ArrayList&lt;Object&gt; items = new ArrayList&lt;Object&gt;();
1401          int contentWidth = mWidgetSpacingLayout.getContentWidth();
1402          final int cellWidth = ((contentWidth - mPageLayoutPaddingLeft - mPageLayoutPaddingRight
1403                  - ((mWidgetCountX - 1) * mWidgetWidthGap)) / mWidgetCountX);
1404          int contentHeight = mWidgetSpacingLayout.getContentHeight();
1405          final int cellHeight = ((contentHeight - mPageLayoutPaddingTop - mPageLayoutPaddingBottom
1406                  - ((mWidgetCountY - 1) * mWidgetHeightGap)) / mWidgetCountY);
1407  
1408          // Prepare the set of widgets to load previews for in the background
1409          int offset = (page - mNumAppsPages) * numItemsPerPage;
1410          for (int i = offset; i &lt; Math.min(offset + numItemsPerPage, mWidgets.size()); ++i) {
1411              items.add(mWidgets.get(i));
1412          }
1413  
1414          // Prepopulate the pages with the other widget info, and fill in the previews later
1415          final PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(page);
1416          layout.setColumnCount(layout.getCellCountX());
1417          for (int i = 0; i &lt; items.size(); ++i) {
1418              Object rawInfo = items.get(i);
1419              PendingAddItemInfo createItemInfo = null;
1420              PagedViewWidget widget = (PagedViewWidget) mLayoutInflater.inflate(
1421                      R.layout.apps_customize_widget, layout, false);
1422              if (rawInfo instanceof AppWidgetProviderInfo) {
1423                  // Fill in the widget information
1424                  AppWidgetProviderInfo info = (AppWidgetProviderInfo) rawInfo;
1425                  createItemInfo = new PendingAddWidgetInfo(info, null, null);
1426  
1427                  // Determine the widget spans and min resize spans.
1428                  int[] spanXY = Launcher.getSpanForWidget(mLauncher, info);
1429                  createItemInfo.spanX = spanXY[0];
1430                  createItemInfo.spanY = spanXY[1];
1431                  int[] minSpanXY = Launcher.getMinSpanForWidget(mLauncher, info);
1432                  createItemInfo.minSpanX = minSpanXY[0];
1433                  createItemInfo.minSpanY = minSpanXY[1];
1434  
1435                  widget.applyFromAppWidgetProviderInfo(info, -1, spanXY);
1436                  widget.setTag(createItemInfo);
1437                  widget.setShortPressListener(this);
1438              } else if (rawInfo instanceof ResolveInfo) {
1439                  // Fill in the shortcuts information
1440                  ResolveInfo info = (ResolveInfo) rawInfo;
1441                  createItemInfo = new PendingAddShortcutInfo(info.activityInfo);
1442                  createItemInfo.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
1443                  createItemInfo.componentName = new ComponentName(info.activityInfo.packageName,
1444                          info.activityInfo.name);
1445                  widget.applyFromResolveInfo(mPackageManager, info);
1446                  widget.setTag(createItemInfo);
1447              }
1448              widget.setOnClickListener(this);
1449              widget.setOnLongClickListener(this);
1450              widget.setOnTouchListener(this);
1451              widget.setOnKeyListener(this);
1452  
1453              // Layout each widget
1454              int ix = i % mWidgetCountX;
1455              int iy = i / mWidgetCountX;
1456              GridLayout.LayoutParams lp = new GridLayout.LayoutParams(
1457                      GridLayout.spec(iy, GridLayout.LEFT),
1458                      GridLayout.spec(ix, GridLayout.TOP));
1459              lp.width = cellWidth;
1460              lp.height = cellHeight;
1461              lp.setGravity(Gravity.TOP | Gravity.LEFT);
1462              if (ix &gt; 0) lp.leftMargin = mWidgetWidthGap;
1463              if (iy &gt; 0) lp.topMargin = mWidgetHeightGap;
1464              layout.addView(widget, lp);
1465          }
1466  
1467          // wait until a call on onLayout to start loading, because
1468          // PagedViewWidget.getPreviewSize() will return 0 if it hasn&#x27;t been laid out
1469          // TODO: can we do a measure/layout immediately?
1470          layout.setOnLayoutListener(new Runnable() {
1471              public void run() {
1472                  // Load the widget previews
1473                  int maxPreviewWidth = cellWidth;
1474                  int maxPreviewHeight = cellHeight;
1475                  if (layout.getChildCount() &gt; 0) {
1476                      PagedViewWidget w = (PagedViewWidget) layout.getChildAt(0);
1477                      int[] maxSize = w.getPreviewSize();
1478                      maxPreviewWidth = maxSize[0];
1479                      maxPreviewHeight = maxSize[1];
1480                  }
1481                  if (immediate) {
1482                      AsyncTaskPageData data = new AsyncTaskPageData(page, items,
1483                              maxPreviewWidth, maxPreviewHeight, null, null);
1484                      loadWidgetPreviewsInBackground(null, data);
1485                      onSyncWidgetPageItems(data);
1486                  } else {
1487                      if (mInTransition) {
1488                          mDeferredPrepareLoadWidgetPreviewsTasks.add(this);
1489                      } else {
1490                          prepareLoadWidgetPreviewsTask(page, items,
1491                                  maxPreviewWidth, maxPreviewHeight, mWidgetCountX);
1492                      }
1493                  }
1494              }
1495          });
1496      }
1497      private void loadWidgetPreviewsInBackground(AppsCustomizeAsyncTask task,
1498              AsyncTaskPageData data) {
1499          // loadWidgetPreviewsInBackground can be called without a task to load a set of widget
1500          // previews synchronously
1501          if (task != null) {
1502              // Ensure that this task starts running at the correct priority
1503              task.syncThreadPriority();
1504          }
1505  
1506          // Load each of the widget/shortcut previews
1507          ArrayList&lt;Object&gt; items = data.items;
1508          ArrayList&lt;Bitmap&gt; images = data.generatedImages;
1509          int count = items.size();
1510          for (int i = 0; i &lt; count; ++i) {
1511              if (task != null) {
1512                  // Ensure we haven&#x27;t been cancelled yet
1513                  if (task.isCancelled()) break;
1514                  // Before work on each item, ensure that this task is running at the correct
1515                  // priority
1516                  task.syncThreadPriority();
1517              }
1518  
1519              Object rawInfo = items.get(i);
1520              if (rawInfo instanceof AppWidgetProviderInfo) {
1521                  AppWidgetProviderInfo info = (AppWidgetProviderInfo) rawInfo;
1522                  int[] cellSpans = Launcher.getSpanForWidget(mLauncher, info);
1523  
1524                  int maxWidth = Math.min(data.maxImageWidth,
1525                          mWidgetSpacingLayout.estimateCellWidth(cellSpans[0]));
1526                  int maxHeight = Math.min(data.maxImageHeight,
1527                          mWidgetSpacingLayout.estimateCellHeight(cellSpans[1]));
1528                  Bitmap b = getWidgetPreview(info.provider, info.previewImage, info.icon,
1529                          cellSpans[0], cellSpans[1], maxWidth, maxHeight);
1530                  images.add(b);
1531              } else if (rawInfo instanceof ResolveInfo) {
1532                  // Fill in the shortcuts information
1533                  ResolveInfo info = (ResolveInfo) rawInfo;
1534                  images.add(getShortcutPreview(info, data.maxImageWidth, data.maxImageHeight));
1535              }
1536          }
1537      }
1538  
1539      private void onSyncWidgetPageItems(AsyncTaskPageData data) {
1540          if (mInTransition) {
1541              mDeferredSyncWidgetPageItems.add(data);
1542              return;
1543          }
1544          try {
1545              int page = data.page;
1546              PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(page);
1547  
1548              ArrayList&lt;Object&gt; items = data.items;
1549              int count = items.size();
1550              for (int i = 0; i &lt; count; ++i) {
1551                  PagedViewWidget widget = (PagedViewWidget) layout.getChildAt(i);
1552                  if (widget != null) {
1553                      Bitmap preview = data.generatedImages.get(i);
1554                      widget.applyPreview(new FastBitmapDrawable(preview), i);
1555                  }
1556              }
1557  
1558              layout.createHardwareLayer();
1559              invalidate();
1560  
1561              // Update all thread priorities
1562              Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1563              while (iter.hasNext()) {
1564                  AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1565                  int pageIndex = task.page;
1566                  task.setThreadPriority(getThreadPriorityForPage(pageIndex));
1567              }
1568          } finally {
1569              data.cleanup(false);
1570          }
1571      }
1572  
1573      @Override
1574      public void syncPages() {
1575          removeAllViews();
1576          cancelAllTasks();
1577  
1578          Context context = getContext();
1579          for (int j = 0; j &lt; mNumWidgetPages; ++j) {
1580              PagedViewGridLayout layout = new PagedViewGridLayout(context, mWidgetCountX,
1581                      mWidgetCountY);
1582              setupPage(layout);
1583              addView(layout, new PagedView.LayoutParams(LayoutParams.MATCH_PARENT,
1584                      LayoutParams.MATCH_PARENT));
1585          }
1586  
1587          for (int i = 0; i &lt; mNumAppsPages; ++i) {
1588              PagedViewCellLayout layout = new PagedViewCellLayout(context);
1589              setupPage(layout);
1590              addView(layout);
1591          }
1592      }
1593  
1594      @Override
1595      public void syncPageItems(int page, boolean immediate) {
1596          if (page &lt; mNumAppsPages) {
1597              syncAppsPageItems(page, immediate);
1598          } else {
1599              syncWidgetPageItems(page, immediate);
1600          }
1601      }
1602  
1603      // We want our pages to be z-ordered such that the further a page is to the left, the higher
1604      // it is in the z-order. This is important to insure touch events are handled correctly.
1605      View getPageAt(int index) {
1606          return getChildAt(indexToPage(index));
1607      }
1608  
1609      @Override
1610      protected int indexToPage(int index) {
1611          return getChildCount() - index - 1;
1612      }
1613  
1614      // In apps customize, we have a scrolling effect which emulates pulling cards off of a stack.
1615      @Override
1616      protected void screenScrolled(int screenCenter) {
1617          super.screenScrolled(screenCenter);
1618  
1619          for (int i = 0; i &lt; getChildCount(); i++) {
1620              View v = getPageAt(i);
1621              if (v != null) {
1622                  float scrollProgress = getScrollProgress(screenCenter, v, i);
1623  
1624                  float interpolatedProgress =
1625                          mZInterpolator.getInterpolation(Math.abs(Math.min(scrollProgress, 0)));
1626                  float scale = (1 - interpolatedProgress) +
1627                          interpolatedProgress * TRANSITION_SCALE_FACTOR;
1628                  float translationX = Math.min(0, scrollProgress) * v.getMeasuredWidth();
1629  
1630                  float alpha;
1631  
1632                  if (scrollProgress &lt; 0) {
1633                      alpha = scrollProgress &lt; 0 ? mAlphaInterpolator.getInterpolation(
1634                          1 - Math.abs(scrollProgress)) : 1.0f;
1635                  } else {
1636                      // On large screens we need to fade the page as it nears its leftmost position
1637                      alpha = mLeftScreenAlphaInterpolator.getInterpolation(1 - scrollProgress);
1638                  }
1639  
1640                  v.setCameraDistance(mDensity * CAMERA_DISTANCE);
1641                  int pageWidth = v.getMeasuredWidth();
1642                  int pageHeight = v.getMeasuredHeight();
1643  
1644                  if (PERFORM_OVERSCROLL_ROTATION) {
1645                      if (i == 0 &amp;&amp; scrollProgress &lt; 0) {
1646                          // Overscroll to the left
1647                          v.setPivotX(TRANSITION_PIVOT * pageWidth);
1648                          v.setRotationY(-TRANSITION_MAX_ROTATION * scrollProgress);
1649                          scale = 1.0f;
1650                          alpha = 1.0f;
1651                          // On the first page, we don&#x27;t want the page to have any lateral motion
1652                          translationX = 0;
1653                      } else if (i == getChildCount() - 1 &amp;&amp; scrollProgress &gt; 0) {
1654                          // Overscroll to the right
1655                          v.setPivotX((1 - TRANSITION_PIVOT) * pageWidth);
1656                          v.setRotationY(-TRANSITION_MAX_ROTATION * scrollProgress);
1657                          scale = 1.0f;
1658                          alpha = 1.0f;
1659                          // On the last page, we don&#x27;t want the page to have any lateral motion.
1660                          translationX = 0;
1661                      } else {
1662                          v.setPivotY(pageHeight / 2.0f);
1663                          v.setPivotX(pageWidth / 2.0f);
1664                          v.setRotationY(0f);
1665                      }
1666                  }
1667  
1668                  v.setTranslationX(translationX);
1669                  v.setScaleX(scale);
1670                  v.setScaleY(scale);
1671                  v.setAlpha(alpha);
1672  
1673                  // If the view has 0 alpha, we set it to be invisible so as to prevent
1674                  // it from accepting touches
1675                  if (alpha == 0) {
1676                      v.setVisibility(INVISIBLE);
1677                  } else if (v.getVisibility() != VISIBLE) {
1678                      v.setVisibility(VISIBLE);
1679                  }
1680              }
1681          }
1682      }
1683  
1684      protected void overScroll(float amount) {
1685          acceleratedOverScroll(amount);
1686      }
1687  
1688      /**
1689       * Used by the parent to get the content width to set the tab bar to
1690       * @return
1691       */
1692      public int getPageContentWidth() {
1693          return mContentWidth;
1694      }
1695  
1696      @Override
1697      protected void onPageEndMoving() {
1698          super.onPageEndMoving();
1699          mForceDrawAllChildrenNextFrame = true;
1700          // We reset the save index when we change pages so that it will be recalculated on next
1701          // rotation
1702          mSaveInstanceStateItemIndex = -1;
1703      }
1704  
1705      /*
1706       * AllAppsView implementation
1707       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1708 -    @Override</span>
1709      public void setup(Launcher launcher, DragController dragController) {
1710          mLauncher = launcher;
1711          mDragController = dragController;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1712 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1713 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1714 -    public void zoom(float zoom, boolean animate) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1715 -        // TODO-APPS_CUSTOMIZE: Call back to mLauncher.zoomed()</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1716 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1717 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1718 -    public boolean isVisible() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1719 -        return (getVisibility() == VISIBLE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1720 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1721 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1722 -    public boolean isAnimating() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1723 -        return false;</span>
1724      }
1725  
1726      /**
1727       * We should call thise method whenever the core data changes (mApps, mWidgets) so that we can
1728       * appropriately determine when to invalidate the PagedView page data.  In cases where the data
1729       * has yet to be set, we can requestLayout() and wait for onDataReady() to be called in the
1730       * next onMeasure() pass, which will trigger an invalidatePageData() itself.
1731       */
1732      private void invalidateOnDataChange() {
1733          if (!isDataReady()) {
1734              // The next layout pass will trigger data-ready if both widgets and apps are set, so
1735              // request a layout to trigger the page data when ready.
1736              requestLayout();
1737          } else {
1738              cancelAllTasks();
1739              invalidatePageData();
1740          }
1741      }
1742  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1743 -    @Override</span>
1744      public void setApps(ArrayList&lt;ApplicationInfo&gt; list) {
1745          mApps = list;
1746          Collections.sort(mApps, LauncherModel.APP_NAME_COMPARATOR);
1747          updatePageCounts();
1748          invalidateOnDataChange();
1749      }
1750      private void addAppsWithoutInvalidate(ArrayList&lt;ApplicationInfo&gt; list) {
1751          // We add it in place, in alphabetical order
1752          int count = list.size();
1753          for (int i = 0; i &lt; count; ++i) {
1754              ApplicationInfo info = list.get(i);
1755              int index = Collections.binarySearch(mApps, info, LauncherModel.APP_NAME_COMPARATOR);
1756              if (index &lt; 0) {
1757                  mApps.add(-(index + 1), info);
1758              }
1759          }
1760      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1761 -    @Override</span>
1762      public void addApps(ArrayList&lt;ApplicationInfo&gt; list) {
1763          addAppsWithoutInvalidate(list);
1764          updatePageCounts();
1765          invalidateOnDataChange();
1766      }
1767      private int findAppByComponent(List&lt;ApplicationInfo&gt; list, ApplicationInfo item) {
1768          ComponentName removeComponent = item.intent.getComponent();
1769          int length = list.size();
1770          for (int i = 0; i &lt; length; ++i) {
1771              ApplicationInfo info = list.get(i);
1772              if (info.intent.getComponent().equals(removeComponent)) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1773 +                return i;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1774 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1775 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1776 +        return -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1777 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1778 +    private int findAppByPackage(List&lt;ApplicationInfo&gt; list, String packageName) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1779 +        int length = list.size();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1780 +        for (int i = 0; i &lt; length; ++i) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1781 +            ApplicationInfo info = list.get(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1782 +            if (ItemInfo.getPackageName(info.intent).equals(packageName)) {</span>
1783                  return i;
1784              }
1785          }
1786          return -1;
1787      }
1788      private void removeAppsWithoutInvalidate(ArrayList&lt;ApplicationInfo&gt; list) {
1789          // loop through all the apps and remove apps that have the same component
1790          int length = list.size();
1791          for (int i = 0; i &lt; length; ++i) {
1792              ApplicationInfo info = list.get(i);
1793              int removeIndex = findAppByComponent(mApps, info);
1794              if (removeIndex &gt; -1) {
1795                  mApps.remove(removeIndex);
1796              }
1797          }
1798      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1799 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1800 -    public void removeApps(ArrayList&lt;ApplicationInfo&gt; list) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1801 -        removeAppsWithoutInvalidate(list);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1802 +    private void removeAppsWithPackageNameWithoutInvalidate(ArrayList&lt;String&gt; packageNames) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1803 +        // loop through all the package names and remove apps that have the same package name</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1804 +        for (String pn : packageNames) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1805 +            int removeIndex = findAppByPackage(mApps, pn);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1806 +            while (removeIndex &gt; -1) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1807 +                mApps.remove(removeIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1808 +                removeIndex = findAppByPackage(mApps, pn);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1809 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1810 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1811 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1812 +    public void removeApps(ArrayList&lt;String&gt; packageNames) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1813 +        removeAppsWithPackageNameWithoutInvalidate(packageNames);</span>
1814          updatePageCounts();
1815          invalidateOnDataChange();
1816      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1817 -    @Override</span>
1818      public void updateApps(ArrayList&lt;ApplicationInfo&gt; list) {
1819          // We remove and re-add the updated applications list because it&#x27;s properties may have
1820          // changed (ie. the title), and this will ensure that the items will be in their proper
1821          // place in the list.
1822          removeAppsWithoutInvalidate(list);
1823          addAppsWithoutInvalidate(list);
1824          updatePageCounts();
1825          invalidateOnDataChange();
1826      }
1827  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1828 -    @Override</span>
1829      public void reset() {
1830          // If we have reset, then we should not continue to restore the previous state
1831          mSaveInstanceStateItemIndex = -1;
1832  
1833          AppsCustomizeTabHost tabHost = getTabHost();
1834          String tag = tabHost.getCurrentTabTag();
1835          if (tag != null) {
1836              if (!tag.equals(tabHost.getTabTagForContentType(ContentType.Applications))) {
1837                  tabHost.setCurrentTabFromContent(ContentType.Applications);
1838              }
1839          }
1840  
1841          if (mCurrentPage != 0) {
1842              invalidatePageData(0);
1843          }
1844      }
1845  
1846      private AppsCustomizeTabHost getTabHost() {
1847          return (AppsCustomizeTabHost) mLauncher.findViewById(R.id.apps_customize_pane);
1848      }
1849  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1850 -    @Override</span>
1851      public void dumpState() {
1852          // TODO: Dump information related to current list of Applications, Widgets, etc.
1853          ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mApps&quot;, mApps);
1854          dumpAppWidgetProviderInfoList(TAG, &quot;mWidgets&quot;, mWidgets);
1855      }
1856  
1857      private void dumpAppWidgetProviderInfoList(String tag, String label,
1858              ArrayList&lt;Object&gt; list) {
1859          Log.d(tag, label + &quot; size=&quot; + list.size());
1860          for (Object i: list) {
1861              if (i instanceof AppWidgetProviderInfo) {
1862                  AppWidgetProviderInfo info = (AppWidgetProviderInfo) i;
1863                  Log.d(tag, &quot;   label=\&quot;&quot; + info.label + &quot;\&quot; previewImage=&quot; + info.previewImage
1864                          + &quot; resizeMode=&quot; + info.resizeMode + &quot; configure=&quot; + info.configure
1865                          + &quot; initialLayout=&quot; + info.initialLayout
1866                          + &quot; minWidth=&quot; + info.minWidth + &quot; minHeight=&quot; + info.minHeight);
1867              } else if (i instanceof ResolveInfo) {
1868                  ResolveInfo info = (ResolveInfo) i;
1869                  Log.d(tag, &quot;   label=\&quot;&quot; + info.loadLabel(mPackageManager) + &quot;\&quot; icon=&quot;
1870                          + info.icon);
1871              }
1872          }
1873      }
1874  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1875 -    @Override</span>
1876      public void surrender() {
1877          // TODO: If we are in the middle of any process (ie. for holographic outlines, etc) we
1878          // should stop this now.
1879  
1880          // Stop all background tasks
1881          cancelAllTasks();
1882      }
1883  
1884      @Override
1885      public void iconPressed(PagedViewIcon icon) {
1886          // Reset the previously pressed icon and store a reference to the pressed icon so that
1887          // we can reset it on return to Launcher (in Launcher.onResume())
1888          if (mPressedIcon != null) {
1889              mPressedIcon.resetDrawableState();
1890          }
1891          mPressedIcon = icon;
1892      }
1893  
1894      public void resetDrawableState() {
1895          if (mPressedIcon != null) {
1896              mPressedIcon.resetDrawableState();
1897              mPressedIcon = null;
1898          }
1899      }
1900  
1901      /*
1902       * We load an extra page on each side to prevent flashes from scrolling and loading of the
1903       * widget previews in the background with the AsyncTasks.
1904       */
1905      final static int sLookBehindPageCount = 2;
1906      final static int sLookAheadPageCount = 2;
1907      protected int getAssociatedLowerPageBound(int page) {
1908          final int count = getChildCount();
1909          int windowSize = Math.min(count, sLookBehindPageCount + sLookAheadPageCount + 1);
1910          int windowMinIndex = Math.max(Math.min(page - sLookBehindPageCount, count - windowSize), 0);
1911          return windowMinIndex;
1912      }
1913      protected int getAssociatedUpperPageBound(int page) {
1914          final int count = getChildCount();
1915          int windowSize = Math.min(count, sLookBehindPageCount + sLookAheadPageCount + 1);
1916          int windowMaxIndex = Math.min(Math.max(page + sLookAheadPageCount, windowSize - 1),
1917                  count - 1);
1918          return windowMaxIndex;
1919      }
1920  
1921      @Override
1922      protected String getCurrentPageDescription() {
1923          int page = (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
1924          int stringId = R.string.default_scroll_format;
1925          int count = 0;
1926  
1927          if (page &lt; mNumAppsPages) {
1928              stringId = R.string.apps_customize_apps_scroll_format;
1929              count = mNumAppsPages;
1930          } else {
1931              page -= mNumAppsPages;
1932              stringId = R.string.apps_customize_widgets_scroll_format;
1933              count = mNumWidgetPages;
1934          }
1935  
1936          return String.format(getContext().getString(stringId), page + 1, count);
1937      }
1938  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2011 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher2;
  18  
  19  import android.animation.AnimatorSet;
  20  import android.animation.ObjectAnimator;
  21  import android.animation.ValueAnimator;
  22  import android.appwidget.AppWidgetHostView;
  23  import android.appwidget.AppWidgetManager;
  24  import android.appwidget.AppWidgetProviderInfo;
  25  import android.content.ComponentName;
  26  import android.content.Context;
  27  import android.content.Intent;
  28  import android.content.pm.PackageManager;
  29  import android.content.pm.ResolveInfo;
  30  import android.content.res.Configuration;
  31  import android.content.res.Resources;
  32  import android.content.res.TypedArray;
  33  import android.graphics.Bitmap;
  34  import android.graphics.Bitmap.Config;
  35  import android.graphics.Canvas;
  36  import android.graphics.ColorMatrix;
  37  import android.graphics.ColorMatrixColorFilter;
  38  import android.graphics.Insets;
  39  import android.graphics.MaskFilter;
  40  import android.graphics.Matrix;
  41  import android.graphics.Paint;
  42  import android.graphics.PorterDuff;
  43  import android.graphics.Rect;
  44  import android.graphics.RectF;
  45  import android.graphics.Shader;
  46  import android.graphics.TableMaskFilter;
  47  import android.graphics.drawable.BitmapDrawable;
  48  import android.graphics.drawable.Drawable;
  49  import android.os.AsyncTask;
  50  import android.os.Process;
  51  import android.util.AttributeSet;
  52  import android.util.Log;
  53  import android.view.Gravity;
  54  import android.view.KeyEvent;
  55  import android.view.LayoutInflater;
  56  import android.view.MotionEvent;
  57  import android.view.View;
  58  import android.view.ViewGroup;
  59  import android.view.animation.AccelerateInterpolator;
  60  import android.view.animation.DecelerateInterpolator;
  61  import android.widget.GridLayout;
  62  import android.widget.ImageView;
  63  import android.widget.LinearLayout;
  64  import android.widget.Toast;
  65  
  66  import com.android.launcher.R;
  67  import com.android.launcher2.DropTarget.DragObject;
  68  

  69  import java.util.ArrayList;
  70  import java.util.Collections;
  71  import java.util.Iterator;
  72  import java.util.List;
  73  import java.lang.ref.WeakReference;
  74  
  75  /**
  76   * A simple callback interface which also provides the results of the task.
  77   */
  78  interface AsyncTaskCallback {
  79      void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data);
  80  }
  81  
  82  /**
  83   * The data needed to perform either of the custom AsyncTasks.
  84   */
  85  class AsyncTaskPageData {
  86      enum Type {
  87          LoadWidgetPreviewData
  88      }
  89  
  90      AsyncTaskPageData(int p, ArrayList&lt;Object&gt; l, ArrayList&lt;Bitmap&gt; si, AsyncTaskCallback bgR,
  91              AsyncTaskCallback postR) {
  92          page = p;
  93          items = l;
  94          sourceImages = si;
  95          generatedImages = new ArrayList&lt;Bitmap&gt;();
  96          maxImageWidth = maxImageHeight = -1;
  97          doInBackgroundCallback = bgR;
  98          postExecuteCallback = postR;
  99      }
 100      AsyncTaskPageData(int p, ArrayList&lt;Object&gt; l, int cw, int ch, AsyncTaskCallback bgR,
 101              AsyncTaskCallback postR) {
 102          page = p;
 103          items = l;
 104          generatedImages = new ArrayList&lt;Bitmap&gt;();
 105          maxImageWidth = cw;
 106          maxImageHeight = ch;
 107          doInBackgroundCallback = bgR;
 108          postExecuteCallback = postR;
 109      }
 110      void cleanup(boolean cancelled) {
 111          // Clean up any references to source/generated bitmaps
 112          if (sourceImages != null) {
 113              if (cancelled) {
 114                  for (Bitmap b : sourceImages) {
 115                      b.recycle();
 116                  }
 117              }
 118              sourceImages.clear();
 119          }
 120          if (generatedImages != null) {
 121              if (cancelled) {
 122                  for (Bitmap b : generatedImages) {
 123                      b.recycle();
 124                  }
 125              }
 126              generatedImages.clear();
 127          }
 128      }
 129      int page;
 130      ArrayList&lt;Object&gt; items;
 131      ArrayList&lt;Bitmap&gt; sourceImages;
 132      ArrayList&lt;Bitmap&gt; generatedImages;
 133      int maxImageWidth;
 134      int maxImageHeight;
 135      AsyncTaskCallback doInBackgroundCallback;
 136      AsyncTaskCallback postExecuteCallback;
 137  }
 138  
 139  /**
 140   * A generic template for an async task used in AppsCustomize.
 141   */
 142  class AppsCustomizeAsyncTask extends AsyncTask&lt;AsyncTaskPageData, Void, AsyncTaskPageData&gt; {
 143      AppsCustomizeAsyncTask(int p, AsyncTaskPageData.Type ty) {
 144          page = p;
 145          threadPriority = Process.THREAD_PRIORITY_DEFAULT;
 146          dataType = ty;
 147      }
 148      @Override
 149      protected AsyncTaskPageData doInBackground(AsyncTaskPageData... params) {
 150          if (params.length != 1) return null;
 151          // Load each of the widget previews in the background
 152          params[0].doInBackgroundCallback.run(this, params[0]);
 153          return params[0];
 154      }
 155      @Override
 156      protected void onPostExecute(AsyncTaskPageData result) {
 157          // All the widget previews are loaded, so we can just callback to inflate the page
 158          result.postExecuteCallback.run(this, result);
 159      }
 160  
 161      void setThreadPriority(int p) {
 162          threadPriority = p;
 163      }
 164      void syncThreadPriority() {
 165          Process.setThreadPriority(threadPriority);
 166      }
 167  
 168      // The page that this async task is associated with
 169      AsyncTaskPageData.Type dataType;
 170      int page;
 171      int threadPriority;
 172  }
 173  
 174  abstract class WeakReferenceThreadLocal&lt;T&gt; {
 175      private ThreadLocal&lt;WeakReference&lt;T&gt;&gt; mThreadLocal;
 176      public WeakReferenceThreadLocal() {
 177          mThreadLocal = new ThreadLocal&lt;WeakReference&lt;T&gt;&gt;();
 178      }
 179  
 180      abstract T initialValue();
 181  
 182      public void set(T t) {
 183          mThreadLocal.set(new WeakReference&lt;T&gt;(t));
 184      }
 185  
 186      public T get() {
 187          WeakReference&lt;T&gt; reference = mThreadLocal.get();
 188          T obj;
 189          if (reference == null) {
 190              obj = initialValue();
 191              mThreadLocal.set(new WeakReference&lt;T&gt;(obj));
 192              return obj;
 193          } else {
 194              obj = reference.get();
 195              if (obj == null) {
 196                  obj = initialValue();
 197                  mThreadLocal.set(new WeakReference&lt;T&gt;(obj));
 198              }
 199              return obj;
 200          }
 201      }
 202  }
 203  
 204  class CanvasCache extends WeakReferenceThreadLocal&lt;Canvas&gt; {
 205      @Override
 206      protected Canvas initialValue() {
 207          return new Canvas();
 208      }
 209  }
 210  
 211  class PaintCache extends WeakReferenceThreadLocal&lt;Paint&gt; {
 212      @Override
 213      protected Paint initialValue() {
 214          return null;
 215      }
 216  }
 217  
 218  class BitmapCache extends WeakReferenceThreadLocal&lt;Bitmap&gt; {
 219      @Override
 220      protected Bitmap initialValue() {
 221          return null;
 222      }
 223  }
 224  
 225  class RectCache extends WeakReferenceThreadLocal&lt;Rect&gt; {
 226      @Override
 227      protected Rect initialValue() {
 228          return new Rect();
 229      }
 230  }
 231  
 232  /**
 233   * The Apps/Customize page that displays all the applications, widgets, and shortcuts.
 234   */
 235  public class AppsCustomizePagedView extends PagedViewWithDraggableItems implements
 236          AllAppsView, View.OnClickListener, View.OnKeyListener, DragSource,

 237          PagedViewIcon.PressedCallback, PagedViewWidget.ShortPressListener,
 238          LauncherTransitionable {
 239      static final String TAG = &quot;AppsCustomizePagedView&quot;;
 240  
 241      /**
 242       * The different content types that this paged view can show.
 243       */
 244      public enum ContentType {
 245          Applications,
 246          Widgets
 247      }
 248  
 249      // Refs
 250      private Launcher mLauncher;
 251      private DragController mDragController;
 252      private final LayoutInflater mLayoutInflater;
 253      private final PackageManager mPackageManager;
 254  
 255      // Save and Restore
 256      private int mSaveInstanceStateItemIndex = -1;
 257      private PagedViewIcon mPressedIcon;
 258  
 259      // Content
 260      private ArrayList&lt;ApplicationInfo&gt; mApps;
 261      private ArrayList&lt;Object&gt; mWidgets;
 262  
 263      // Cling
 264      private boolean mHasShownAllAppsCling;
 265      private int mClingFocusedX;
 266      private int mClingFocusedY;
 267  
 268      // Caching
 269      private Canvas mCanvas;
 270      private Drawable mDefaultWidgetBackground;
 271      private IconCache mIconCache;
 272  
 273      // Dimens
 274      private int mContentWidth;
 275      private int mAppIconSize;
 276      private int mMaxAppCellCountX, mMaxAppCellCountY;
 277      private int mWidgetCountX, mWidgetCountY;
 278      private int mWidgetWidthGap, mWidgetHeightGap;
 279      private final float sWidgetPreviewIconPaddingPercentage = 0.25f;
 280      private PagedViewCellLayout mWidgetSpacingLayout;
 281      private int mNumAppsPages;
 282      private int mNumWidgetPages;
 283  
 284      // Relating to the scroll and overscroll effects
 285      Workspace.ZInterpolator mZInterpolator = new Workspace.ZInterpolator(0.5f);
 286      private static float CAMERA_DISTANCE = 6500;
 287      private static float TRANSITION_SCALE_FACTOR = 0.74f;
 288      private static float TRANSITION_PIVOT = 0.65f;
 289      private static float TRANSITION_MAX_ROTATION = 22;
 290      private static final boolean PERFORM_OVERSCROLL_ROTATION = true;
 291      private AccelerateInterpolator mAlphaInterpolator = new AccelerateInterpolator(0.9f);
 292      private DecelerateInterpolator mLeftScreenAlphaInterpolator = new DecelerateInterpolator(4);
 293  
 294      // Previews &amp; outlines
 295      ArrayList&lt;AppsCustomizeAsyncTask&gt; mRunningTasks;
 296      private static final int sPageSleepDelay = 200;
 297  
 298      private Runnable mInflateWidgetRunnable = null;
 299      private Runnable mBindWidgetRunnable = null;
 300      static final int WIDGET_NO_CLEANUP_REQUIRED = -1;
 301      static final int WIDGET_PRELOAD_PENDING = 0;
 302      static final int WIDGET_BOUND = 1;
 303      static final int WIDGET_INFLATED = 2;
 304      int mWidgetCleanupState = WIDGET_NO_CLEANUP_REQUIRED;
 305      int mWidgetLoadingId = -1;
 306      PendingAddWidgetInfo mCreateWidgetInfo = null;
 307      private boolean mDraggingWidget = false;
 308  


 309      // Deferral of loading widget previews during launcher transitions
 310      private boolean mInTransition;
 311      private ArrayList&lt;AsyncTaskPageData&gt; mDeferredSyncWidgetPageItems =
 312          new ArrayList&lt;AsyncTaskPageData&gt;();
 313      private ArrayList&lt;Runnable&gt; mDeferredPrepareLoadWidgetPreviewsTasks =
 314          new ArrayList&lt;Runnable&gt;();
 315  
 316      // Used for drawing shortcut previews
 317      BitmapCache mCachedShortcutPreviewBitmap = new BitmapCache();
 318      PaintCache mCachedShortcutPreviewPaint = new PaintCache();
 319      CanvasCache mCachedShortcutPreviewCanvas = new CanvasCache();
 320  
 321      // Used for drawing widget previews
 322      CanvasCache mCachedAppWidgetPreviewCanvas = new CanvasCache();
 323      RectCache mCachedAppWidgetPreviewSrcRect = new RectCache();
 324      RectCache mCachedAppWidgetPreviewDestRect = new RectCache();
 325      PaintCache mCachedAppWidgetPreviewPaint = new PaintCache();
 326  
 327      public AppsCustomizePagedView(Context context, AttributeSet attrs) {
 328          super(context, attrs);
 329          mLayoutInflater = LayoutInflater.from(context);
 330          mPackageManager = context.getPackageManager();
 331          mApps = new ArrayList&lt;ApplicationInfo&gt;();
 332          mWidgets = new ArrayList&lt;Object&gt;();
 333          mIconCache = ((LauncherApplication) context.getApplicationContext()).getIconCache();
 334          mCanvas = new Canvas();
 335          mRunningTasks = new ArrayList&lt;AppsCustomizeAsyncTask&gt;();
 336  
 337          // Save the default widget preview background
 338          Resources resources = context.getResources();
 339          mDefaultWidgetBackground = resources.getDrawable(R.drawable.default_widget_preview_holo);
 340          mAppIconSize = resources.getDimensionPixelSize(R.dimen.app_icon_size);
 341  
 342          TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.AppsCustomizePagedView, 0, 0);
 343          mMaxAppCellCountX = a.getInt(R.styleable.AppsCustomizePagedView_maxAppCellCountX, -1);
 344          mMaxAppCellCountY = a.getInt(R.styleable.AppsCustomizePagedView_maxAppCellCountY, -1);
 345          mWidgetWidthGap =
 346              a.getDimensionPixelSize(R.styleable.AppsCustomizePagedView_widgetCellWidthGap, 0);
 347          mWidgetHeightGap =
 348              a.getDimensionPixelSize(R.styleable.AppsCustomizePagedView_widgetCellHeightGap, 0);
 349          mWidgetCountX = a.getInt(R.styleable.AppsCustomizePagedView_widgetCountX, 2);
 350          mWidgetCountY = a.getInt(R.styleable.AppsCustomizePagedView_widgetCountY, 2);
 351          mClingFocusedX = a.getInt(R.styleable.AppsCustomizePagedView_clingFocusedX, 0);
 352          mClingFocusedY = a.getInt(R.styleable.AppsCustomizePagedView_clingFocusedY, 0);
 353          a.recycle();
 354          mWidgetSpacingLayout = new PagedViewCellLayout(getContext());
 355  
 356          // The padding on the non-matched dimension for the default widget preview icons
 357          // (top + bottom)
 358          mFadeInAdjacentScreens = false;
 359  
 360          // Unless otherwise specified this view is important for accessibility.
 361          if (getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
 362              setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
 363          }
 364      }
 365  
 366      @Override
 367      protected void init() {
 368          super.init();
 369          mCenterPagesVertically = false;
 370  
 371          Context context = getContext();
 372          Resources r = context.getResources();
 373          setDragSlopeThreshold(r.getInteger(R.integer.config_appsCustomizeDragSlopeThreshold)/100f);
 374      }
 375  
 376      @Override
 377      protected void onUnhandledTap(MotionEvent ev) {
 378          if (LauncherApplication.isScreenLarge()) {
 379              // Dismiss AppsCustomize if we tap
 380              mLauncher.showWorkspace(true);
 381          }
 382      }
 383  
 384      /** Returns the item index of the center item on this page so that we can restore to this
 385       *  item index when we rotate. */
 386      private int getMiddleComponentIndexOnCurrentPage() {
 387          int i = -1;
 388          if (getPageCount() &gt; 0) {
 389              int currentPage = getCurrentPage();
 390              if (currentPage &lt; mNumAppsPages) {
 391                  PagedViewCellLayout layout = (PagedViewCellLayout) getPageAt(currentPage);
 392                  PagedViewCellLayoutChildren childrenLayout = layout.getChildrenLayout();
 393                  int numItemsPerPage = mCellCountX * mCellCountY;
 394                  int childCount = childrenLayout.getChildCount();
 395                  if (childCount &gt; 0) {
 396                      i = (currentPage * numItemsPerPage) + (childCount / 2);
 397                  }
 398              } else {
 399                  int numApps = mApps.size();
 400                  PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(currentPage);
 401                  int numItemsPerPage = mWidgetCountX * mWidgetCountY;
 402                  int childCount = layout.getChildCount();
 403                  if (childCount &gt; 0) {
 404                      i = numApps +
 405                          ((currentPage - mNumAppsPages) * numItemsPerPage) + (childCount / 2);
 406                  }
 407              }
 408          }
 409          return i;
 410      }
 411  
 412      /** Get the index of the item to restore to if we need to restore the current page. */
 413      int getSaveInstanceStateIndex() {
 414          if (mSaveInstanceStateItemIndex == -1) {
 415              mSaveInstanceStateItemIndex = getMiddleComponentIndexOnCurrentPage();
 416          }
 417          return mSaveInstanceStateItemIndex;
 418      }
 419  
 420      /** Returns the page in the current orientation which is expected to contain the specified
 421       *  item index. */
 422      int getPageForComponent(int index) {
 423          if (index &lt; 0) return 0;
 424  
 425          if (index &lt; mApps.size()) {
 426              int numItemsPerPage = mCellCountX * mCellCountY;
 427              return (index / numItemsPerPage);
 428          } else {
 429              int numItemsPerPage = mWidgetCountX * mWidgetCountY;
 430              return mNumAppsPages + ((index - mApps.size()) / numItemsPerPage);
 431          }
 432      }
 433  
 434      /** Restores the page for an item at the specified index */
 435      void restorePageForIndex(int index) {
 436          if (index &lt; 0) return;
 437          mSaveInstanceStateItemIndex = index;
 438      }
 439  
 440      private void updatePageCounts() {
 441          mNumWidgetPages = (int) Math.ceil(mWidgets.size() /
 442                  (float) (mWidgetCountX * mWidgetCountY));
 443          mNumAppsPages = (int) Math.ceil((float) mApps.size() / (mCellCountX * mCellCountY));
 444      }
 445  
 446      protected void onDataReady(int width, int height) {
 447          // Note that we transpose the counts in portrait so that we get a similar layout
 448          boolean isLandscape = getResources().getConfiguration().orientation ==
 449              Configuration.ORIENTATION_LANDSCAPE;
 450          int maxCellCountX = Integer.MAX_VALUE;
 451          int maxCellCountY = Integer.MAX_VALUE;
 452          if (LauncherApplication.isScreenLarge()) {
 453              maxCellCountX = (isLandscape ? LauncherModel.getCellCountX() :
 454                  LauncherModel.getCellCountY());
 455              maxCellCountY = (isLandscape ? LauncherModel.getCellCountY() :
 456                  LauncherModel.getCellCountX());
 457          }
 458          if (mMaxAppCellCountX &gt; -1) {
 459              maxCellCountX = Math.min(maxCellCountX, mMaxAppCellCountX);
 460          }
 461          if (mMaxAppCellCountY &gt; -1) {
 462              maxCellCountY = Math.min(maxCellCountY, mMaxAppCellCountY);
 463          }
 464  
 465          // Now that the data is ready, we can calculate the content width, the number of cells to
 466          // use for each page
 467          mWidgetSpacingLayout.setGap(mPageLayoutWidthGap, mPageLayoutHeightGap);
 468          mWidgetSpacingLayout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
 469                  mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
 470          mWidgetSpacingLayout.calculateCellCount(width, height, maxCellCountX, maxCellCountY);
 471          mCellCountX = mWidgetSpacingLayout.getCellCountX();
 472          mCellCountY = mWidgetSpacingLayout.getCellCountY();
 473          updatePageCounts();
 474  
 475          // Force a measure to update recalculate the gaps
 476          int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
 477          int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
 478          mWidgetSpacingLayout.measure(widthSpec, heightSpec);
 479          mContentWidth = mWidgetSpacingLayout.getContentWidth();
 480  
 481          AppsCustomizeTabHost host = (AppsCustomizeTabHost) getTabHost();
 482          final boolean hostIsTransitioning = host.isTransitioning();
 483  
 484          // Restore the page
 485          int page = getPageForComponent(mSaveInstanceStateItemIndex);
 486          invalidatePageData(Math.max(0, page), hostIsTransitioning);
 487  
 488          // Show All Apps cling if we are finished transitioning, otherwise, we will try again when
 489          // the transition completes in AppsCustomizeTabHost (otherwise the wrong offsets will be
 490          // returned while animating)
 491          if (!hostIsTransitioning) {
 492              post(new Runnable() {
 493                  @Override
 494                  public void run() {
 495                      showAllAppsCling();
 496                  }
 497              });
 498          }
 499      }
 500  
 501      void showAllAppsCling() {
 502          if (!mHasShownAllAppsCling &amp;&amp; isDataReady()) {
 503              mHasShownAllAppsCling = true;
 504              // Calculate the position for the cling punch through
 505              int[] offset = new int[2];
 506              int[] pos = mWidgetSpacingLayout.estimateCellPosition(mClingFocusedX, mClingFocusedY);
 507              mLauncher.getDragLayer().getLocationInDragLayer(this, offset);
 508              // PagedViews are centered horizontally but top aligned
 509              pos[0] += (getMeasuredWidth() - mWidgetSpacingLayout.getMeasuredWidth()) / 2 +
 510                      offset[0];
 511              pos[1] += offset[1];
 512              mLauncher.showFirstRunAllAppsCling(pos);
 513          }
 514      }
 515  
 516      @Override
 517      protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 518          int width = MeasureSpec.getSize(widthMeasureSpec);
 519          int height = MeasureSpec.getSize(heightMeasureSpec);
 520          if (!isDataReady()) {
 521              if (!mApps.isEmpty() &amp;&amp; !mWidgets.isEmpty()) {
 522                  setDataIsReady();
 523                  setMeasuredDimension(width, height);
 524                  onDataReady(width, height);
 525              }
 526          }
 527  
 528          super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 529      }
 530  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 531 -    public void onPackagesUpdated() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 532 -        // TODO: this isn&#x27;t ideal, but we actually need to delay here. This call is triggered</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 533 -        // by a broadcast receiver, and in order for it to work correctly, we need to know that</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 534 -        // the AppWidgetService has already received and processed the same broadcast. Since there</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 535 -        // is no guarantee about ordering of broadcast receipt, we just delay here. This is a</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 536 -        // workaround until we add a callback from AppWidgetService to AppWidgetHost when widget</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 537 -        // packages are added, updated or removed.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 538 -        postDelayed(new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 539 -           public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 540 -               updatePackages();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 541 -           }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 542 -        }, 1500);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 543 +    public void onPackagesUpdated(boolean immediate) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 544 +        if (immediate) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 545 +            updatePackages();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 546 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 547 +            // TODO: this isn&#x27;t ideal, but we actually need to delay here. This call is triggered</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 548 +            // by a broadcast receiver, and in order for it to work correctly, we need to know that</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 549 +            // the AppWidgetService has already received and processed the same broadcast. Since there</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 550 +            // is no guarantee about ordering of broadcast receipt, we just delay here. This is a</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 551 +            // workaround until we add a callback from AppWidgetService to AppWidgetHost when widget</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 552 +            // packages are added, updated or removed.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 553 +            postDelayed(new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 554 +               public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 555 +                   updatePackages();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 556 +               }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 557 +            }, 1500);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 558 +        }</span>
 559      }
 560  
 561      public void updatePackages() {
 562          // Get the list of widgets and shortcuts
 563          mWidgets.clear();
 564          List&lt;AppWidgetProviderInfo&gt; widgets =
 565              AppWidgetManager.getInstance(mLauncher).getInstalledProviders();
 566          Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
 567          List&lt;ResolveInfo&gt; shortcuts = mPackageManager.queryIntentActivities(shortcutsIntent, 0);
 568          for (AppWidgetProviderInfo widget : widgets) {
 569              if (widget.minWidth &gt; 0 &amp;&amp; widget.minHeight &gt; 0) {
 570                  // Ensure that all widgets we show can be added on a workspace of this size
 571                  int[] spanXY = Launcher.getSpanForWidget(mLauncher, widget);
 572                  int[] minSpanXY = Launcher.getMinSpanForWidget(mLauncher, widget);
 573                  int minSpanX = Math.min(spanXY[0], minSpanXY[0]);
 574                  int minSpanY = Math.min(spanXY[1], minSpanXY[1]);
 575                  if (minSpanX &lt;= LauncherModel.getCellCountX() &amp;&amp;
 576                          minSpanY &lt;= LauncherModel.getCellCountY()) {
 577                      mWidgets.add(widget);
 578                  } else {
 579                      Log.e(TAG, &quot;Widget &quot; + widget.provider + &quot; can not fit on this device (&quot; +
 580                              widget.minWidth + &quot;, &quot; + widget.minHeight + &quot;)&quot;);
 581                  }
 582              } else {
 583                  Log.e(TAG, &quot;Widget &quot; + widget.provider + &quot; has invalid dimensions (&quot; +
 584                          widget.minWidth + &quot;, &quot; + widget.minHeight + &quot;)&quot;);
 585              }
 586          }
 587          mWidgets.addAll(shortcuts);
 588          Collections.sort(mWidgets,
 589                  new LauncherModel.WidgetAndShortcutNameComparator(mPackageManager));
 590          updatePageCounts();
 591          invalidateOnDataChange();
 592      }
 593  
 594      @Override
 595      public void onClick(View v) {
 596          // When we have exited all apps or are in transition, disregard clicks
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 597 -        if (!mLauncher.isAllAppsCustomizeOpen() ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 598 +        if (!mLauncher.isAllAppsVisible() ||</span>
 599                  mLauncher.getWorkspace().isSwitchingState()) return;
 600  
 601          if (v instanceof PagedViewIcon) {
 602              // Animate some feedback to the click
 603              final ApplicationInfo appInfo = (ApplicationInfo) v.getTag();
 604  
 605              // Lock the drawable state to pressed until we return to Launcher
 606              if (mPressedIcon != null) {
 607                  mPressedIcon.lockDrawableState();
 608              }
 609  
 610              // NOTE: We want all transitions from launcher to act as if the wallpaper were enabled
 611              // to be consistent.  So re-enable the flag here, and we will re-disable it as necessary
 612              // when Launcher resumes and we are still in AllApps.
 613              mLauncher.updateWallpaperVisibility(true);
 614              mLauncher.startActivitySafely(v, appInfo.intent, appInfo);
 615  
 616          } else if (v instanceof PagedViewWidget) {
 617              // Let the user know that they have to long press to add a widget
 618              Toast.makeText(getContext(), R.string.long_press_widget_to_add,
 619                      Toast.LENGTH_SHORT).show();






 620  
 621              // Create a little animation to show that the widget can move
 622              float offsetY = getResources().getDimensionPixelSize(R.dimen.dragViewOffsetY);
 623              final ImageView p = (ImageView) v.findViewById(R.id.widget_preview);
 624              AnimatorSet bounce = new AnimatorSet();
 625              ValueAnimator tyuAnim = ObjectAnimator.ofFloat(p, &quot;translationY&quot;, offsetY);


 626              tyuAnim.setDuration(125);
 627              ValueAnimator tydAnim = ObjectAnimator.ofFloat(p, &quot;translationY&quot;, 0f);

 628              tydAnim.setDuration(100);
 629              bounce.play(tyuAnim).before(tydAnim);
 630              bounce.setInterpolator(new AccelerateInterpolator());
 631              bounce.start();
 632          }
 633      }
 634  
 635      public boolean onKey(View v, int keyCode, KeyEvent event) {
 636          return FocusHelper.handleAppsCustomizeKeyEvent(v,  keyCode, event);
 637      }
 638  
 639      /*
 640       * PagedViewWithDraggableItems implementation
 641       */
 642      @Override
 643      protected void determineDraggingStart(android.view.MotionEvent ev) {
 644          // Disable dragging by pulling an app down for now.
 645      }
 646  
 647      private void beginDraggingApplication(View v) {
 648          mLauncher.getWorkspace().onDragStartedWithItem(v);
 649          mLauncher.getWorkspace().beginDragShared(v, this);
 650      }
 651  
 652      private void preloadWidget(final PendingAddWidgetInfo info) {
 653          final AppWidgetProviderInfo pInfo = info.info;
 654          if (pInfo.configure != null) {
 655              return;
 656          }
 657  
 658          mWidgetCleanupState = WIDGET_PRELOAD_PENDING;
 659          mBindWidgetRunnable = new Runnable() {
 660              @Override
 661              public void run() {
 662                  mWidgetLoadingId = mLauncher.getAppWidgetHost().allocateAppWidgetId();
 663                  if (AppWidgetManager.getInstance(mLauncher)
 664                              .bindAppWidgetIdIfAllowed(mWidgetLoadingId, info.componentName)) {
 665                      mWidgetCleanupState = WIDGET_BOUND;
 666                  }
 667              }
 668          };
 669          post(mBindWidgetRunnable);
 670  
 671          mInflateWidgetRunnable = new Runnable() {
 672              @Override
 673              public void run() {
 674                  AppWidgetHostView hostView = mLauncher.
 675                          getAppWidgetHost().createView(getContext(), mWidgetLoadingId, pInfo);
 676                  info.boundWidget = hostView;
 677                  mWidgetCleanupState = WIDGET_INFLATED;
 678                  hostView.setVisibility(INVISIBLE);
 679                  int[] unScaledSize = mLauncher.getWorkspace().estimateItemSize(info.spanX,
 680                          info.spanY, info, false);
 681  
 682                  // We want the first widget layout to be the correct size. This will be important
 683                  // for width size reporting to the AppWidgetManager.
 684                  DragLayer.LayoutParams lp = new DragLayer.LayoutParams(unScaledSize[0],
 685                          unScaledSize[1]);
 686                  lp.x = lp.y = 0;
 687                  lp.customPosition = true;
 688                  hostView.setLayoutParams(lp);
 689                  mLauncher.getDragLayer().addView(hostView);
 690              }
 691          };
 692          post(mInflateWidgetRunnable);
 693      }
 694  
 695      @Override
 696      public void onShortPress(View v) {
 697          // We are anticipating a long press, and we use this time to load bind and instantiate
 698          // the widget. This will need to be cleaned up if it turns out no long press occurs.
 699          if (mCreateWidgetInfo != null) {
 700              // Just in case the cleanup process wasn&#x27;t properly executed. This shouldn&#x27;t happen.
 701              cleanupWidgetPreloading(false);
 702          }
 703          mCreateWidgetInfo = new PendingAddWidgetInfo((PendingAddWidgetInfo) v.getTag());
 704          preloadWidget(mCreateWidgetInfo);
 705      }
 706  
 707      private void cleanupWidgetPreloading(boolean widgetWasAdded) {
 708          if (!widgetWasAdded) {
 709              // If the widget was not added, we may need to do further cleanup.
 710              PendingAddWidgetInfo info = mCreateWidgetInfo;
 711              mCreateWidgetInfo = null;
 712  
 713              if (mWidgetCleanupState == WIDGET_PRELOAD_PENDING) {
 714                  // We never did any preloading, so just remove pending callbacks to do so
 715                  removeCallbacks(mBindWidgetRunnable);
 716                  removeCallbacks(mInflateWidgetRunnable);
 717              } else if (mWidgetCleanupState == WIDGET_BOUND) {
 718                   // Delete the widget id which was allocated
 719                  if (mWidgetLoadingId != -1) {
 720                      mLauncher.getAppWidgetHost().deleteAppWidgetId(mWidgetLoadingId);
 721                  }
 722  
 723                  // We never got around to inflating the widget, so remove the callback to do so.
 724                  removeCallbacks(mInflateWidgetRunnable);
 725              } else if (mWidgetCleanupState == WIDGET_INFLATED) {
 726                  // Delete the widget id which was allocated
 727                  if (mWidgetLoadingId != -1) {
 728                      mLauncher.getAppWidgetHost().deleteAppWidgetId(mWidgetLoadingId);
 729                  }
 730  
 731                  // The widget was inflated and added to the DragLayer -- remove it.
 732                  AppWidgetHostView widget = info.boundWidget;
 733                  mLauncher.getDragLayer().removeView(widget);
 734              }
 735          }
 736          mWidgetCleanupState = WIDGET_NO_CLEANUP_REQUIRED;
 737          mWidgetLoadingId = -1;
 738          mCreateWidgetInfo = null;
 739          PagedViewWidget.resetShortPressTarget();
 740      }
 741  
 742      @Override
 743      public void cleanUpShortPress(View v) {
 744          if (!mDraggingWidget) {
 745              cleanupWidgetPreloading(false);
 746          }
 747      }
 748  
 749      private boolean beginDraggingWidget(View v) {
 750          mDraggingWidget = true;
 751          // Get the widget preview as the drag representation
 752          ImageView image = (ImageView) v.findViewById(R.id.widget_preview);
 753          PendingAddItemInfo createItemInfo = (PendingAddItemInfo) v.getTag();
 754  
 755          // If the ImageView doesn&#x27;t have a drawable yet, the widget preview hasn&#x27;t been loaded and
 756          // we abort the drag.
 757          if (image.getDrawable() == null) {
 758              mDraggingWidget = false;
 759              return false;
 760          }
 761  
 762          // Compose the drag image
 763          Bitmap preview;
 764          Bitmap outline;
 765          float scale = 1f;
 766          if (createItemInfo instanceof PendingAddWidgetInfo) {
 767              // This can happen in some weird cases involving multi-touch. We can&#x27;t start dragging
 768              // the widget if this is null, so we break out.
 769              if (mCreateWidgetInfo == null) {
 770                  return false;
 771              }
 772  
 773              PendingAddWidgetInfo createWidgetInfo = mCreateWidgetInfo;
 774              createItemInfo = createWidgetInfo;
 775              int spanX = createItemInfo.spanX;
 776              int spanY = createItemInfo.spanY;
 777              int[] size = mLauncher.getWorkspace().estimateItemSize(spanX, spanY,
 778                      createWidgetInfo, true);
 779  
 780              FastBitmapDrawable previewDrawable = (FastBitmapDrawable) image.getDrawable();
 781              float minScale = 1.25f;
 782              int maxWidth, maxHeight;
 783              maxWidth = Math.min((int) (previewDrawable.getIntrinsicWidth() * minScale), size[0]);
 784              maxHeight = Math.min((int) (previewDrawable.getIntrinsicHeight() * minScale), size[1]);
 785              preview = getWidgetPreview(createWidgetInfo.componentName, createWidgetInfo.previewImage,
 786                      createWidgetInfo.icon, spanX, spanY, maxWidth, maxHeight);
 787  
 788              // Determine the image view drawable scale relative to the preview
 789              float[] mv = new float[9];
 790              Matrix m = new Matrix();
 791              m.setRectToRect(
 792                      new RectF(0f, 0f, (float) preview.getWidth(), (float) preview.getHeight()),
 793                      new RectF(0f, 0f, (float) previewDrawable.getIntrinsicWidth(),
 794                              (float) previewDrawable.getIntrinsicHeight()),
 795                      Matrix.ScaleToFit.START);
 796              m.getValues(mv);
 797              scale = (float) mv[0];
 798          } else {
 799              PendingAddShortcutInfo createShortcutInfo = (PendingAddShortcutInfo) v.getTag();
 800              Drawable icon = mIconCache.getFullResIcon(createShortcutInfo.shortcutActivityInfo);
 801              preview = Bitmap.createBitmap(icon.getIntrinsicWidth(),
 802                      icon.getIntrinsicHeight(), Bitmap.Config.ARGB_8888);
 803  
 804              mCanvas.setBitmap(preview);
 805              mCanvas.save();
 806              renderDrawableToBitmap(icon, preview, 0, 0,
 807                      icon.getIntrinsicWidth(), icon.getIntrinsicHeight());
 808              mCanvas.restore();
 809              mCanvas.setBitmap(null);
 810              createItemInfo.spanX = createItemInfo.spanY = 1;
 811          }
 812  
 813          // We use a custom alpha clip table for the default widget previews
 814          Paint alphaClipPaint = null;
 815          if (createItemInfo instanceof PendingAddWidgetInfo) {
 816              if (((PendingAddWidgetInfo) createItemInfo).previewImage != 0) {
 817                  MaskFilter alphaClipTable = TableMaskFilter.CreateClipTable(0, 255);
 818                  alphaClipPaint = new Paint();
 819                  alphaClipPaint.setMaskFilter(alphaClipTable);
 820              }
 821          }



 822  
 823          // Save the preview for the outline generation, then dim the preview
 824          outline = Bitmap.createScaledBitmap(preview, preview.getWidth(), preview.getHeight(),
 825                  false);
 826  
 827          // Start the drag
 828          alphaClipPaint = null;
 829          mLauncher.lockScreenOrientation();
 830          mLauncher.getWorkspace().onDragStartedWithItem(createItemInfo, outline, alphaClipPaint);

 831          mDragController.startDrag(image, preview, this, createItemInfo,
 832                  DragController.DRAG_ACTION_COPY, null, scale);
 833          outline.recycle();
 834          preview.recycle();
 835          return true;
 836      }
 837  
 838      @Override
 839      protected boolean beginDragging(final View v) {
 840          if (!super.beginDragging(v)) return false;
 841  
 842          if (v instanceof PagedViewIcon) {
 843              beginDraggingApplication(v);
 844          } else if (v instanceof PagedViewWidget) {
 845              if (!beginDraggingWidget(v)) {
 846                  return false;
 847              }
 848          }
 849  
 850          // We delay entering spring-loaded mode slightly to make sure the UI
 851          // thready is free of any work.
 852          postDelayed(new Runnable() {
 853              @Override
 854              public void run() {
 855                  // We don&#x27;t enter spring-loaded mode if the drag has been cancelled
 856                  if (mLauncher.getDragController().isDragging()) {
 857                      // Dismiss the cling
 858                      mLauncher.dismissAllAppsCling(null);
 859  
 860                      // Reset the alpha on the dragged icon before we drag
 861                      resetDrawableState();
 862  
 863                      // Go into spring loaded mode (must happen before we startDrag())
 864                      mLauncher.enterSpringLoadedDragMode();
 865                  }
 866              }
 867          }, 150);
 868  
 869          return true;
 870      }
 871  
 872      /**
 873       * Clean up after dragging.
 874       *
 875       * @param target where the item was dragged to (can be null if the item was flung)
 876       */
 877      private void endDragging(View target, boolean isFlingToDelete, boolean success) {
 878          if (isFlingToDelete || !success || (target != mLauncher.getWorkspace() &amp;&amp;
 879                  !(target instanceof DeleteDropTarget))) {
 880              // Exit spring loaded mode if we have not successfully dropped or have not handled the
 881              // drop in Workspace
 882              mLauncher.exitSpringLoadedDragMode();
 883          }
 884          mLauncher.unlockScreenOrientation(false);
 885      }
 886  
 887      @Override
 888      public View getContent() {
 889          return null;
 890      }
 891  
 892      @Override
 893      public void onLauncherTransitionPrepare(Launcher l, boolean animated, boolean toWorkspace) {
 894          mInTransition = true;
 895          if (toWorkspace) {
 896              cancelAllTasks();
 897          }
 898      }
 899  
 900      @Override
 901      public void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace) {
 902      }
 903  
 904      @Override
 905      public void onLauncherTransitionStep(Launcher l, float t) {
 906      }
 907  
 908      @Override
 909      public void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace) {
 910          mInTransition = false;
 911          for (AsyncTaskPageData d : mDeferredSyncWidgetPageItems) {
 912              onSyncWidgetPageItems(d);
 913          }
 914          mDeferredSyncWidgetPageItems.clear();
 915          for (Runnable r : mDeferredPrepareLoadWidgetPreviewsTasks) {
 916              r.run();
 917          }
 918          mDeferredPrepareLoadWidgetPreviewsTasks.clear();
 919          mForceDrawAllChildrenNextFrame = !toWorkspace;
 920      }
 921  
 922      @Override
 923      public void onDropCompleted(View target, DragObject d, boolean isFlingToDelete,
 924              boolean success) {
 925          // Return early and wait for onFlingToDeleteCompleted if this was the result of a fling
 926          if (isFlingToDelete) return;
 927  
 928          endDragging(target, false, success);
 929  
 930          // Display an error message if the drag failed due to there not being enough space on the
 931          // target layout we were dropping on.
 932          if (!success) {
 933              boolean showOutOfSpaceMessage = false;
 934              if (target instanceof Workspace) {
 935                  int currentScreen = mLauncher.getCurrentWorkspaceScreen();
 936                  Workspace workspace = (Workspace) target;
 937                  CellLayout layout = (CellLayout) workspace.getChildAt(currentScreen);
 938                  ItemInfo itemInfo = (ItemInfo) d.dragInfo;
 939                  if (layout != null) {
 940                      layout.calculateSpans(itemInfo);
 941                      showOutOfSpaceMessage =
 942                              !layout.findCellForSpan(null, itemInfo.spanX, itemInfo.spanY);
 943                  }
 944              }
 945              if (showOutOfSpaceMessage) {
 946                  mLauncher.showOutOfSpaceMessage(false);
 947              }
 948  
 949              d.deferDragViewCleanupPostAnimation = false;
 950          }
 951          cleanupWidgetPreloading(success);
 952          mDraggingWidget = false;
 953      }
 954  
 955      @Override
 956      public void onFlingToDeleteCompleted() {
 957          // We just dismiss the drag when we fling, so cleanup here
 958          endDragging(null, true, true);
 959          cleanupWidgetPreloading(false);
 960          mDraggingWidget = false;
 961      }
 962  
 963      @Override
 964      public boolean supportsFlingToDelete() {
 965          return true;
 966      }
 967  
 968      @Override
 969      protected void onDetachedFromWindow() {
 970          super.onDetachedFromWindow();
 971          cancelAllTasks();
 972      }
 973  
 974      public void clearAllWidgetPages() {
 975          cancelAllTasks();
 976          int count = getChildCount();
 977          for (int i = 0; i &lt; count; i++) {
 978              View v = getPageAt(i);
 979              if (v instanceof PagedViewGridLayout) {
 980                  ((PagedViewGridLayout) v).removeAllViewsOnPage();
 981                  mDirtyPageContent.set(i, true);
 982              }
 983          }
 984      }
 985  
 986      private void cancelAllTasks() {
 987          // Clean up all the async tasks
 988          Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
 989          while (iter.hasNext()) {
 990              AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
 991              task.cancel(false);
 992              iter.remove();
 993              mDirtyPageContent.set(task.page, true);
 994  
 995              // We&#x27;ve already preallocated the views for the data to load into, so clear them as well
 996              View v = getPageAt(task.page);
 997              if (v instanceof PagedViewGridLayout) {
 998                  ((PagedViewGridLayout) v).removeAllViewsOnPage();
 999              }
1000          }
1001          mDeferredSyncWidgetPageItems.clear();
1002          mDeferredPrepareLoadWidgetPreviewsTasks.clear();
1003      }
1004  
1005      public void setContentType(ContentType type) {
1006          if (type == ContentType.Widgets) {
1007              invalidatePageData(mNumAppsPages, true);
1008          } else if (type == ContentType.Applications) {
1009              invalidatePageData(0, true);
1010          }
1011      }
1012  
1013      protected void snapToPage(int whichPage, int delta, int duration) {
1014          super.snapToPage(whichPage, delta, duration);
1015          updateCurrentTab(whichPage);
1016  
1017          // Update the thread priorities given the direction lookahead
1018          Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1019          while (iter.hasNext()) {
1020              AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1021              int pageIndex = task.page;
1022              if ((mNextPage &gt; mCurrentPage &amp;&amp; pageIndex &gt;= mCurrentPage) ||
1023                  (mNextPage &lt; mCurrentPage &amp;&amp; pageIndex &lt;= mCurrentPage)) {
1024                  task.setThreadPriority(getThreadPriorityForPage(pageIndex));
1025              } else {
1026                  task.setThreadPriority(Process.THREAD_PRIORITY_LOWEST);
1027              }
1028          }
1029      }
1030  
1031      private void updateCurrentTab(int currentPage) {
1032          AppsCustomizeTabHost tabHost = getTabHost();
1033          if (tabHost != null) {
1034              String tag = tabHost.getCurrentTabTag();
1035              if (tag != null) {
1036                  if (currentPage &gt;= mNumAppsPages &amp;&amp;
1037                          !tag.equals(tabHost.getTabTagForContentType(ContentType.Widgets))) {
1038                      tabHost.setCurrentTabFromContent(ContentType.Widgets);
1039                  } else if (currentPage &lt; mNumAppsPages &amp;&amp;
1040                          !tag.equals(tabHost.getTabTagForContentType(ContentType.Applications))) {
1041                      tabHost.setCurrentTabFromContent(ContentType.Applications);
1042                  }
1043              }
1044          }
1045      }
1046  
1047      /*
1048       * Apps PagedView implementation
1049       */
1050      private void setVisibilityOnChildren(ViewGroup layout, int visibility) {
1051          int childCount = layout.getChildCount();
1052          for (int i = 0; i &lt; childCount; ++i) {
1053              layout.getChildAt(i).setVisibility(visibility);
1054          }
1055      }
1056      private void setupPage(PagedViewCellLayout layout) {
1057          layout.setCellCount(mCellCountX, mCellCountY);
1058          layout.setGap(mPageLayoutWidthGap, mPageLayoutHeightGap);
1059          layout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
1060                  mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
1061  
1062          // Note: We force a measure here to get around the fact that when we do layout calculations
1063          // immediately after syncing, we don&#x27;t have a proper width.  That said, we already know the
1064          // expected page width, so we can actually optimize by hiding all the TextView-based
1065          // children that are expensive to measure, and let that happen naturally later.
1066          setVisibilityOnChildren(layout, View.GONE);
1067          int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
1068          int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
1069          layout.setMinimumWidth(getPageContentWidth());
1070          layout.measure(widthSpec, heightSpec);
1071          setVisibilityOnChildren(layout, View.VISIBLE);
1072      }
1073  
1074      public void syncAppsPageItems(int page, boolean immediate) {
1075          // ensure that we have the right number of items on the pages
1076          int numCells = mCellCountX * mCellCountY;
1077          int startIndex = page * numCells;
1078          int endIndex = Math.min(startIndex + numCells, mApps.size());
1079          PagedViewCellLayout layout = (PagedViewCellLayout) getPageAt(page);
1080  
1081          layout.removeAllViewsOnPage();
1082          ArrayList&lt;Object&gt; items = new ArrayList&lt;Object&gt;();
1083          ArrayList&lt;Bitmap&gt; images = new ArrayList&lt;Bitmap&gt;();
1084          for (int i = startIndex; i &lt; endIndex; ++i) {
1085              ApplicationInfo info = mApps.get(i);
1086              PagedViewIcon icon = (PagedViewIcon) mLayoutInflater.inflate(
1087                      R.layout.apps_customize_application, layout, false);
1088              icon.applyFromApplicationInfo(info, true, this);
1089              icon.setOnClickListener(this);
1090              icon.setOnLongClickListener(this);
1091              icon.setOnTouchListener(this);
1092              icon.setOnKeyListener(this);
1093  
1094              int index = i - startIndex;
1095              int x = index % mCellCountX;
1096              int y = index / mCellCountX;
1097              layout.addViewToCellLayout(icon, -1, i, new PagedViewCellLayout.LayoutParams(x,y, 1,1));
1098  
1099              items.add(info);
1100              images.add(info.iconBitmap);
1101          }
1102  
1103          layout.createHardwareLayers();
1104      }
1105  
1106      /**
1107       * A helper to return the priority for loading of the specified widget page.
1108       */
1109      private int getWidgetPageLoadPriority(int page) {
1110          // If we are snapping to another page, use that index as the target page index
1111          int toPage = mCurrentPage;
1112          if (mNextPage &gt; -1) {
1113              toPage = mNextPage;
1114          }
1115  
1116          // We use the distance from the target page as an initial guess of priority, but if there
1117          // are no pages of higher priority than the page specified, then bump up the priority of
1118          // the specified page.
1119          Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1120          int minPageDiff = Integer.MAX_VALUE;
1121          while (iter.hasNext()) {
1122              AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1123              minPageDiff = Math.abs(task.page - toPage);
1124          }
1125  
1126          int rawPageDiff = Math.abs(page - toPage);
1127          return rawPageDiff - Math.min(rawPageDiff, minPageDiff);
1128      }
1129      /**
1130       * Return the appropriate thread priority for loading for a given page (we give the current
1131       * page much higher priority)
1132       */
1133      private int getThreadPriorityForPage(int page) {
1134          // TODO-APPS_CUSTOMIZE: detect number of cores and set thread priorities accordingly below
1135          int pageDiff = getWidgetPageLoadPriority(page);
1136          if (pageDiff &lt;= 0) {
1137              return Process.THREAD_PRIORITY_LESS_FAVORABLE;
1138          } else if (pageDiff &lt;= 1) {
1139              return Process.THREAD_PRIORITY_LOWEST;
1140          } else {
1141              return Process.THREAD_PRIORITY_LOWEST;
1142          }
1143      }
1144      private int getSleepForPage(int page) {
1145          int pageDiff = getWidgetPageLoadPriority(page);
1146          return Math.max(0, pageDiff * sPageSleepDelay);
1147      }
1148      /**
1149       * Creates and executes a new AsyncTask to load a page of widget previews.
1150       */
1151      private void prepareLoadWidgetPreviewsTask(int page, ArrayList&lt;Object&gt; widgets,
1152              int cellWidth, int cellHeight, int cellCountX) {
1153  
1154          // Prune all tasks that are no longer needed
1155          Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1156          while (iter.hasNext()) {
1157              AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1158              int taskPage = task.page;
1159              if (taskPage &lt; getAssociatedLowerPageBound(mCurrentPage) ||
1160                      taskPage &gt; getAssociatedUpperPageBound(mCurrentPage)) {
1161                  task.cancel(false);
1162                  iter.remove();
1163              } else {
1164                  task.setThreadPriority(getThreadPriorityForPage(taskPage));
1165              }
1166          }
1167  
1168          // We introduce a slight delay to order the loading of side pages so that we don&#x27;t thrash
1169          final int sleepMs = getSleepForPage(page);
1170          AsyncTaskPageData pageData = new AsyncTaskPageData(page, widgets, cellWidth, cellHeight,
1171              new AsyncTaskCallback() {
1172                  @Override
1173                  public void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data) {
1174                      try {
1175                          try {
1176                              Thread.sleep(sleepMs);
1177                          } catch (Exception e) {}
1178                          loadWidgetPreviewsInBackground(task, data);
1179                      } finally {
1180                          if (task.isCancelled()) {
1181                              data.cleanup(true);
1182                          }
1183                      }
1184                  }
1185              },
1186              new AsyncTaskCallback() {
1187                  @Override
1188                  public void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data) {
1189                      mRunningTasks.remove(task);
1190                      if (task.isCancelled()) return;
1191                      // do cleanup inside onSyncWidgetPageItems
1192                      onSyncWidgetPageItems(data);
1193                  }
1194              });
1195  
1196          // Ensure that the task is appropriately prioritized and runs in parallel
1197          AppsCustomizeAsyncTask t = new AppsCustomizeAsyncTask(page,
1198                  AsyncTaskPageData.Type.LoadWidgetPreviewData);
1199          t.setThreadPriority(getThreadPriorityForPage(page));
1200          t.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, pageData);
1201          mRunningTasks.add(t);
1202      }
1203  
1204      /*
1205       * Widgets PagedView implementation
1206       */
1207      private void setupPage(PagedViewGridLayout layout) {
1208          layout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
1209                  mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
1210  
1211          // Note: We force a measure here to get around the fact that when we do layout calculations
1212          // immediately after syncing, we don&#x27;t have a proper width.
1213          int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
1214          int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
1215          layout.setMinimumWidth(getPageContentWidth());
1216          layout.measure(widthSpec, heightSpec);
1217      }
1218  
1219      private void renderDrawableToBitmap(Drawable d, Bitmap bitmap, int x, int y, int w, int h) {
1220          renderDrawableToBitmap(d, bitmap, x, y, w, h, 1f);
1221      }
1222  
1223      private void renderDrawableToBitmap(Drawable d, Bitmap bitmap, int x, int y, int w, int h,
1224              float scale) {
1225          if (bitmap != null) {
1226              Canvas c = new Canvas(bitmap);
1227              c.scale(scale, scale);
1228              Rect oldBounds = d.copyBounds();
1229              d.setBounds(x, y, x + w, y + h);
1230              d.draw(c);
1231              d.setBounds(oldBounds); // Restore the bounds
1232              c.setBitmap(null);
1233          }
1234      }
1235  
1236      private Bitmap getShortcutPreview(ResolveInfo info, int maxWidth, int maxHeight) {
1237          Bitmap tempBitmap = mCachedShortcutPreviewBitmap.get();
1238          final Canvas c = mCachedShortcutPreviewCanvas.get();
1239          if (tempBitmap == null ||
1240                  tempBitmap.getWidth() != maxWidth ||
1241                  tempBitmap.getHeight() != maxHeight) {
1242              tempBitmap = Bitmap.createBitmap(maxWidth, maxHeight, Config.ARGB_8888);
1243              mCachedShortcutPreviewBitmap.set(tempBitmap);
1244          } else {
1245              c.setBitmap(tempBitmap);
1246              c.drawColor(0, PorterDuff.Mode.CLEAR);
1247              c.setBitmap(null);
1248          }
1249          // Render the icon
1250          Drawable icon = mIconCache.getFullResIcon(info);
1251  
1252          int paddingTop =
1253                  getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_top);
1254          int paddingLeft =
1255                  getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_left);
1256          int paddingRight =
1257                  getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_right);
1258  
1259          int scaledIconWidth = (maxWidth - paddingLeft - paddingRight);
1260          float scaleSize = scaledIconWidth / (float) mAppIconSize;
1261  
1262          renderDrawableToBitmap(
1263                  icon, tempBitmap, paddingLeft, paddingTop, scaledIconWidth, scaledIconWidth);
1264  
1265          Bitmap preview = Bitmap.createBitmap(maxWidth, maxHeight, Config.ARGB_8888);
1266          c.setBitmap(preview);
1267          Paint p = mCachedShortcutPreviewPaint.get();
1268          if (p == null) {
1269              p = new Paint();
1270              ColorMatrix colorMatrix = new ColorMatrix();
1271              colorMatrix.setSaturation(0);
1272              p.setColorFilter(new ColorMatrixColorFilter(colorMatrix));
1273              p.setAlpha((int) (255 * 0.06f));
1274              //float density = 1f;
1275              //p.setMaskFilter(new BlurMaskFilter(15*density, BlurMaskFilter.Blur.NORMAL));
1276              mCachedShortcutPreviewPaint.set(p);
1277          }
1278          c.drawBitmap(tempBitmap, 0, 0, p);
1279          c.setBitmap(null);
1280  
1281          renderDrawableToBitmap(icon, preview, 0, 0, mAppIconSize, mAppIconSize);
1282  
1283          return preview;
1284      }
1285  
1286      private Bitmap getWidgetPreview(ComponentName provider, int previewImage,
1287              int iconId, int cellHSpan, int cellVSpan, int maxWidth,
1288              int maxHeight) {
1289          // Load the preview image if possible
1290          String packageName = provider.getPackageName();
1291          if (maxWidth &lt; 0) maxWidth = Integer.MAX_VALUE;
1292          if (maxHeight &lt; 0) maxHeight = Integer.MAX_VALUE;
1293  
1294          Drawable drawable = null;
1295          if (previewImage != 0) {
1296              drawable = mPackageManager.getDrawable(packageName, previewImage, null);
1297              if (drawable == null) {
1298                  Log.w(TAG, &quot;Can&#x27;t load widget preview drawable 0x&quot; +
1299                          Integer.toHexString(previewImage) + &quot; for provider: &quot; + provider);
1300              }
1301          }
1302  
1303          int bitmapWidth;
1304          int bitmapHeight;
1305          Bitmap defaultPreview = null;
1306          boolean widgetPreviewExists = (drawable != null);
1307          if (widgetPreviewExists) {
1308              bitmapWidth = drawable.getIntrinsicWidth();
1309              bitmapHeight = drawable.getIntrinsicHeight();
1310          } else {
1311              // Generate a preview image if we couldn&#x27;t load one
1312              if (cellHSpan &lt; 1) cellHSpan = 1;
1313              if (cellVSpan &lt; 1) cellVSpan = 1;
1314  
1315              BitmapDrawable previewDrawable = (BitmapDrawable) getResources()
1316                      .getDrawable(R.drawable.widget_preview_tile);
1317              final int previewDrawableWidth = previewDrawable
1318                      .getIntrinsicWidth();
1319              final int previewDrawableHeight = previewDrawable
1320                      .getIntrinsicHeight();
1321              bitmapWidth = previewDrawableWidth * cellHSpan; // subtract 2 dips
1322              bitmapHeight = previewDrawableHeight * cellVSpan;
1323  
1324              defaultPreview = Bitmap.createBitmap(bitmapWidth, bitmapHeight,
1325                      Config.ARGB_8888);
1326              final Canvas c = mCachedAppWidgetPreviewCanvas.get();
1327              c.setBitmap(defaultPreview);
1328              previewDrawable.setBounds(0, 0, bitmapWidth, bitmapHeight);
1329              previewDrawable.setTileModeXY(Shader.TileMode.REPEAT,
1330                      Shader.TileMode.REPEAT);
1331              previewDrawable.draw(c);
1332              c.setBitmap(null);
1333  
1334              // Draw the icon in the top left corner
1335              int minOffset = (int) (mAppIconSize * sWidgetPreviewIconPaddingPercentage);
1336              int smallestSide = Math.min(bitmapWidth, bitmapHeight);
1337              float iconScale = Math.min((float) smallestSide
1338                      / (mAppIconSize + 2 * minOffset), 1f);
1339  
1340              try {
1341                  Drawable icon = null;
1342                  int hoffset =
1343                          (int) ((previewDrawableWidth - mAppIconSize * iconScale) / 2);
1344                  int yoffset =
1345                          (int) ((previewDrawableHeight - mAppIconSize * iconScale) / 2);
1346                  if (iconId &gt; 0)
1347                      icon = mIconCache.getFullResIcon(packageName, iconId);
1348                  Resources resources = mLauncher.getResources();
1349                  if (icon != null) {
1350                      renderDrawableToBitmap(icon, defaultPreview, hoffset,
1351                              yoffset, (int) (mAppIconSize * iconScale),
1352                              (int) (mAppIconSize * iconScale));
1353                  }
1354              } catch (Resources.NotFoundException e) {
1355              }
1356          }
1357  
1358          // Scale to fit width only - let the widget preview be clipped in the
1359          // vertical dimension
1360          float scale = 1f;
1361          if (bitmapWidth &gt; maxWidth) {
1362              scale = maxWidth / (float) bitmapWidth;
1363          }
1364          if (scale != 1f) {
1365              bitmapWidth = (int) (scale * bitmapWidth);
1366              bitmapHeight = (int) (scale * bitmapHeight);
1367          }
1368  
1369          Bitmap preview = Bitmap.createBitmap(bitmapWidth, bitmapHeight,
1370                  Config.ARGB_8888);
1371  
1372          // Draw the scaled preview into the final bitmap
1373          if (widgetPreviewExists) {
1374              renderDrawableToBitmap(drawable, preview, 0, 0, bitmapWidth,
1375                      bitmapHeight);
1376          } else {
1377              final Canvas c = mCachedAppWidgetPreviewCanvas.get();
1378              final Rect src = mCachedAppWidgetPreviewSrcRect.get();
1379              final Rect dest = mCachedAppWidgetPreviewDestRect.get();
1380              c.setBitmap(preview);
1381              src.set(0, 0, defaultPreview.getWidth(), defaultPreview.getHeight());
1382              dest.set(0, 0, preview.getWidth(), preview.getHeight());
1383  
1384              Paint p = mCachedAppWidgetPreviewPaint.get();
1385              if (p == null) {
1386                  p = new Paint();
1387                  p.setFilterBitmap(true);
1388                  mCachedAppWidgetPreviewPaint.set(p);
1389              }
1390              c.drawBitmap(defaultPreview, src, dest, p);
1391              c.setBitmap(null);
1392          }
1393          return preview;
1394      }
1395  
1396      public void syncWidgetPageItems(final int page, final boolean immediate) {
1397          int numItemsPerPage = mWidgetCountX * mWidgetCountY;
1398  
1399          // Calculate the dimensions of each cell we are giving to each widget
1400          final ArrayList&lt;Object&gt; items = new ArrayList&lt;Object&gt;();
1401          int contentWidth = mWidgetSpacingLayout.getContentWidth();
1402          final int cellWidth = ((contentWidth - mPageLayoutPaddingLeft - mPageLayoutPaddingRight
1403                  - ((mWidgetCountX - 1) * mWidgetWidthGap)) / mWidgetCountX);
1404          int contentHeight = mWidgetSpacingLayout.getContentHeight();
1405          final int cellHeight = ((contentHeight - mPageLayoutPaddingTop - mPageLayoutPaddingBottom
1406                  - ((mWidgetCountY - 1) * mWidgetHeightGap)) / mWidgetCountY);
1407  
1408          // Prepare the set of widgets to load previews for in the background
1409          int offset = (page - mNumAppsPages) * numItemsPerPage;
1410          for (int i = offset; i &lt; Math.min(offset + numItemsPerPage, mWidgets.size()); ++i) {
1411              items.add(mWidgets.get(i));
1412          }
1413  
1414          // Prepopulate the pages with the other widget info, and fill in the previews later
1415          final PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(page);
1416          layout.setColumnCount(layout.getCellCountX());
1417          for (int i = 0; i &lt; items.size(); ++i) {
1418              Object rawInfo = items.get(i);
1419              PendingAddItemInfo createItemInfo = null;
1420              PagedViewWidget widget = (PagedViewWidget) mLayoutInflater.inflate(
1421                      R.layout.apps_customize_widget, layout, false);
1422              if (rawInfo instanceof AppWidgetProviderInfo) {
1423                  // Fill in the widget information
1424                  AppWidgetProviderInfo info = (AppWidgetProviderInfo) rawInfo;
1425                  createItemInfo = new PendingAddWidgetInfo(info, null, null);
1426  
1427                  // Determine the widget spans and min resize spans.
1428                  int[] spanXY = Launcher.getSpanForWidget(mLauncher, info);
1429                  createItemInfo.spanX = spanXY[0];
1430                  createItemInfo.spanY = spanXY[1];
1431                  int[] minSpanXY = Launcher.getMinSpanForWidget(mLauncher, info);
1432                  createItemInfo.minSpanX = minSpanXY[0];
1433                  createItemInfo.minSpanY = minSpanXY[1];
1434  
1435                  widget.applyFromAppWidgetProviderInfo(info, -1, spanXY);
1436                  widget.setTag(createItemInfo);
1437                  widget.setShortPressListener(this);
1438              } else if (rawInfo instanceof ResolveInfo) {
1439                  // Fill in the shortcuts information
1440                  ResolveInfo info = (ResolveInfo) rawInfo;
1441                  createItemInfo = new PendingAddShortcutInfo(info.activityInfo);
1442                  createItemInfo.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
1443                  createItemInfo.componentName = new ComponentName(info.activityInfo.packageName,
1444                          info.activityInfo.name);
1445                  widget.applyFromResolveInfo(mPackageManager, info);
1446                  widget.setTag(createItemInfo);
1447              }
1448              widget.setOnClickListener(this);
1449              widget.setOnLongClickListener(this);
1450              widget.setOnTouchListener(this);
1451              widget.setOnKeyListener(this);
1452  
1453              // Layout each widget
1454              int ix = i % mWidgetCountX;
1455              int iy = i / mWidgetCountX;
1456              GridLayout.LayoutParams lp = new GridLayout.LayoutParams(
1457                      GridLayout.spec(iy, GridLayout.LEFT),
1458                      GridLayout.spec(ix, GridLayout.TOP));
1459              lp.width = cellWidth;
1460              lp.height = cellHeight;
1461              lp.setGravity(Gravity.TOP | Gravity.LEFT);
1462              if (ix &gt; 0) lp.leftMargin = mWidgetWidthGap;
1463              if (iy &gt; 0) lp.topMargin = mWidgetHeightGap;
1464              layout.addView(widget, lp);
1465          }
1466  
1467          // wait until a call on onLayout to start loading, because
1468          // PagedViewWidget.getPreviewSize() will return 0 if it hasn&#x27;t been laid out
1469          // TODO: can we do a measure/layout immediately?
1470          layout.setOnLayoutListener(new Runnable() {
1471              public void run() {
1472                  // Load the widget previews
1473                  int maxPreviewWidth = cellWidth;
1474                  int maxPreviewHeight = cellHeight;
1475                  if (layout.getChildCount() &gt; 0) {
1476                      PagedViewWidget w = (PagedViewWidget) layout.getChildAt(0);
1477                      int[] maxSize = w.getPreviewSize();
1478                      maxPreviewWidth = maxSize[0];
1479                      maxPreviewHeight = maxSize[1];
1480                  }
1481                  if (immediate) {
1482                      AsyncTaskPageData data = new AsyncTaskPageData(page, items,
1483                              maxPreviewWidth, maxPreviewHeight, null, null);
1484                      loadWidgetPreviewsInBackground(null, data);
1485                      onSyncWidgetPageItems(data);
1486                  } else {
1487                      if (mInTransition) {
1488                          mDeferredPrepareLoadWidgetPreviewsTasks.add(this);
1489                      } else {
1490                          prepareLoadWidgetPreviewsTask(page, items,
1491                                  maxPreviewWidth, maxPreviewHeight, mWidgetCountX);
1492                      }
1493                  }
1494              }
1495          });
1496      }
1497      private void loadWidgetPreviewsInBackground(AppsCustomizeAsyncTask task,
1498              AsyncTaskPageData data) {
1499          // loadWidgetPreviewsInBackground can be called without a task to load a set of widget
1500          // previews synchronously
1501          if (task != null) {
1502              // Ensure that this task starts running at the correct priority
1503              task.syncThreadPriority();
1504          }
1505  
1506          // Load each of the widget/shortcut previews
1507          ArrayList&lt;Object&gt; items = data.items;
1508          ArrayList&lt;Bitmap&gt; images = data.generatedImages;
1509          int count = items.size();
1510          for (int i = 0; i &lt; count; ++i) {
1511              if (task != null) {
1512                  // Ensure we haven&#x27;t been cancelled yet
1513                  if (task.isCancelled()) break;
1514                  // Before work on each item, ensure that this task is running at the correct
1515                  // priority
1516                  task.syncThreadPriority();
1517              }
1518  
1519              Object rawInfo = items.get(i);
1520              if (rawInfo instanceof AppWidgetProviderInfo) {
1521                  AppWidgetProviderInfo info = (AppWidgetProviderInfo) rawInfo;
1522                  int[] cellSpans = Launcher.getSpanForWidget(mLauncher, info);
1523  
1524                  int maxWidth = Math.min(data.maxImageWidth,
1525                          mWidgetSpacingLayout.estimateCellWidth(cellSpans[0]));
1526                  int maxHeight = Math.min(data.maxImageHeight,
1527                          mWidgetSpacingLayout.estimateCellHeight(cellSpans[1]));
1528                  Bitmap b = getWidgetPreview(info.provider, info.previewImage, info.icon,
1529                          cellSpans[0], cellSpans[1], maxWidth, maxHeight);
1530                  images.add(b);
1531              } else if (rawInfo instanceof ResolveInfo) {
1532                  // Fill in the shortcuts information
1533                  ResolveInfo info = (ResolveInfo) rawInfo;
1534                  images.add(getShortcutPreview(info, data.maxImageWidth, data.maxImageHeight));
1535              }
1536          }
1537      }
1538  
1539      private void onSyncWidgetPageItems(AsyncTaskPageData data) {
1540          if (mInTransition) {
1541              mDeferredSyncWidgetPageItems.add(data);
1542              return;
1543          }
1544          try {
1545              int page = data.page;
1546              PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(page);
1547  
1548              ArrayList&lt;Object&gt; items = data.items;
1549              int count = items.size();
1550              for (int i = 0; i &lt; count; ++i) {
1551                  PagedViewWidget widget = (PagedViewWidget) layout.getChildAt(i);
1552                  if (widget != null) {
1553                      Bitmap preview = data.generatedImages.get(i);
1554                      widget.applyPreview(new FastBitmapDrawable(preview), i);
1555                  }
1556              }
1557  
1558              layout.createHardwareLayer();
1559              invalidate();
1560  
1561              // Update all thread priorities
1562              Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1563              while (iter.hasNext()) {
1564                  AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1565                  int pageIndex = task.page;
1566                  task.setThreadPriority(getThreadPriorityForPage(pageIndex));
1567              }
1568          } finally {
1569              data.cleanup(false);
1570          }
1571      }
1572  
1573      @Override
1574      public void syncPages() {
1575          removeAllViews();
1576          cancelAllTasks();
1577  
1578          Context context = getContext();
1579          for (int j = 0; j &lt; mNumWidgetPages; ++j) {
1580              PagedViewGridLayout layout = new PagedViewGridLayout(context, mWidgetCountX,
1581                      mWidgetCountY);
1582              setupPage(layout);
1583              addView(layout, new PagedView.LayoutParams(LayoutParams.MATCH_PARENT,
1584                      LayoutParams.MATCH_PARENT));
1585          }
1586  
1587          for (int i = 0; i &lt; mNumAppsPages; ++i) {
1588              PagedViewCellLayout layout = new PagedViewCellLayout(context);
1589              setupPage(layout);
1590              addView(layout);
1591          }
1592      }
1593  
1594      @Override
1595      public void syncPageItems(int page, boolean immediate) {
1596          if (page &lt; mNumAppsPages) {
1597              syncAppsPageItems(page, immediate);
1598          } else {
1599              syncWidgetPageItems(page, immediate);
1600          }
1601      }
1602  
1603      // We want our pages to be z-ordered such that the further a page is to the left, the higher
1604      // it is in the z-order. This is important to insure touch events are handled correctly.
1605      View getPageAt(int index) {
1606          return getChildAt(indexToPage(index));
1607      }
1608  
1609      @Override
1610      protected int indexToPage(int index) {
1611          return getChildCount() - index - 1;
1612      }
1613  
1614      // In apps customize, we have a scrolling effect which emulates pulling cards off of a stack.
1615      @Override
1616      protected void screenScrolled(int screenCenter) {
1617          super.screenScrolled(screenCenter);
1618  
1619          for (int i = 0; i &lt; getChildCount(); i++) {
1620              View v = getPageAt(i);
1621              if (v != null) {
1622                  float scrollProgress = getScrollProgress(screenCenter, v, i);
1623  
1624                  float interpolatedProgress =
1625                          mZInterpolator.getInterpolation(Math.abs(Math.min(scrollProgress, 0)));
1626                  float scale = (1 - interpolatedProgress) +
1627                          interpolatedProgress * TRANSITION_SCALE_FACTOR;
1628                  float translationX = Math.min(0, scrollProgress) * v.getMeasuredWidth();
1629  
1630                  float alpha;
1631  
1632                  if (scrollProgress &lt; 0) {
1633                      alpha = scrollProgress &lt; 0 ? mAlphaInterpolator.getInterpolation(
1634                          1 - Math.abs(scrollProgress)) : 1.0f;
1635                  } else {
1636                      // On large screens we need to fade the page as it nears its leftmost position
1637                      alpha = mLeftScreenAlphaInterpolator.getInterpolation(1 - scrollProgress);
1638                  }
1639  
1640                  v.setCameraDistance(mDensity * CAMERA_DISTANCE);
1641                  int pageWidth = v.getMeasuredWidth();
1642                  int pageHeight = v.getMeasuredHeight();
1643  
1644                  if (PERFORM_OVERSCROLL_ROTATION) {
1645                      if (i == 0 &amp;&amp; scrollProgress &lt; 0) {
1646                          // Overscroll to the left
1647                          v.setPivotX(TRANSITION_PIVOT * pageWidth);
1648                          v.setRotationY(-TRANSITION_MAX_ROTATION * scrollProgress);
1649                          scale = 1.0f;
1650                          alpha = 1.0f;
1651                          // On the first page, we don&#x27;t want the page to have any lateral motion
1652                          translationX = 0;
1653                      } else if (i == getChildCount() - 1 &amp;&amp; scrollProgress &gt; 0) {
1654                          // Overscroll to the right
1655                          v.setPivotX((1 - TRANSITION_PIVOT) * pageWidth);
1656                          v.setRotationY(-TRANSITION_MAX_ROTATION * scrollProgress);
1657                          scale = 1.0f;
1658                          alpha = 1.0f;
1659                          // On the last page, we don&#x27;t want the page to have any lateral motion.
1660                          translationX = 0;
1661                      } else {
1662                          v.setPivotY(pageHeight / 2.0f);
1663                          v.setPivotX(pageWidth / 2.0f);
1664                          v.setRotationY(0f);
1665                      }
1666                  }
1667  
1668                  v.setTranslationX(translationX);
1669                  v.setScaleX(scale);
1670                  v.setScaleY(scale);
1671                  v.setAlpha(alpha);
1672  
1673                  // If the view has 0 alpha, we set it to be invisible so as to prevent
1674                  // it from accepting touches
1675                  if (alpha == 0) {
1676                      v.setVisibility(INVISIBLE);
1677                  } else if (v.getVisibility() != VISIBLE) {
1678                      v.setVisibility(VISIBLE);
1679                  }
1680              }
1681          }
1682      }
1683  
1684      protected void overScroll(float amount) {
1685          acceleratedOverScroll(amount);
1686      }
1687  
1688      /**
1689       * Used by the parent to get the content width to set the tab bar to
1690       * @return
1691       */
1692      public int getPageContentWidth() {
1693          return mContentWidth;
1694      }
1695  
1696      @Override
1697      protected void onPageEndMoving() {
1698          super.onPageEndMoving();
1699          mForceDrawAllChildrenNextFrame = true;
1700          // We reset the save index when we change pages so that it will be recalculated on next
1701          // rotation
1702          mSaveInstanceStateItemIndex = -1;
1703      }
1704  
1705      /*
1706       * AllAppsView implementation
1707       */
1708      @Override
1709      public void setup(Launcher launcher, DragController dragController) {
1710          mLauncher = launcher;
1711          mDragController = dragController;
1712      }
1713      @Override
1714      public void zoom(float zoom, boolean animate) {
1715          // TODO-APPS_CUSTOMIZE: Call back to mLauncher.zoomed()
1716      }
1717      @Override
1718      public boolean isVisible() {
1719          return (getVisibility() == VISIBLE);
1720      }
1721      @Override
1722      public boolean isAnimating() {
1723          return false;
1724      }
1725  
1726      /**
1727       * We should call thise method whenever the core data changes (mApps, mWidgets) so that we can
1728       * appropriately determine when to invalidate the PagedView page data.  In cases where the data
1729       * has yet to be set, we can requestLayout() and wait for onDataReady() to be called in the
1730       * next onMeasure() pass, which will trigger an invalidatePageData() itself.
1731       */
1732      private void invalidateOnDataChange() {
1733          if (!isDataReady()) {
1734              // The next layout pass will trigger data-ready if both widgets and apps are set, so
1735              // request a layout to trigger the page data when ready.
1736              requestLayout();
1737          } else {
1738              cancelAllTasks();
1739              invalidatePageData();
1740          }
1741      }
1742  
1743      @Override
1744      public void setApps(ArrayList&lt;ApplicationInfo&gt; list) {
1745          mApps = list;
1746          Collections.sort(mApps, LauncherModel.APP_NAME_COMPARATOR);
1747          updatePageCounts();
1748          invalidateOnDataChange();
1749      }
1750      private void addAppsWithoutInvalidate(ArrayList&lt;ApplicationInfo&gt; list) {
1751          // We add it in place, in alphabetical order
1752          int count = list.size();
1753          for (int i = 0; i &lt; count; ++i) {
1754              ApplicationInfo info = list.get(i);
1755              int index = Collections.binarySearch(mApps, info, LauncherModel.APP_NAME_COMPARATOR);
1756              if (index &lt; 0) {
1757                  mApps.add(-(index + 1), info);
1758              }
1759          }
1760      }
1761      @Override
1762      public void addApps(ArrayList&lt;ApplicationInfo&gt; list) {
1763          addAppsWithoutInvalidate(list);
1764          updatePageCounts();
1765          invalidateOnDataChange();
1766      }
1767      private int findAppByComponent(List&lt;ApplicationInfo&gt; list, ApplicationInfo item) {
1768          ComponentName removeComponent = item.intent.getComponent();
1769          int length = list.size();
1770          for (int i = 0; i &lt; length; ++i) {
1771              ApplicationInfo info = list.get(i);
1772              if (info.intent.getComponent().equals(removeComponent)) {










1773                  return i;
1774              }
1775          }
1776          return -1;
1777      }
1778      private void removeAppsWithoutInvalidate(ArrayList&lt;ApplicationInfo&gt; list) {
1779          // loop through all the apps and remove apps that have the same component
1780          int length = list.size();
1781          for (int i = 0; i &lt; length; ++i) {
1782              ApplicationInfo info = list.get(i);
1783              int removeIndex = findAppByComponent(mApps, info);
1784              if (removeIndex &gt; -1) {
1785                  mApps.remove(removeIndex);
1786              }
1787          }
1788      }
1789      @Override
1790      public void removeApps(ArrayList&lt;ApplicationInfo&gt; list) {
1791          removeAppsWithoutInvalidate(list);












1792          updatePageCounts();
1793          invalidateOnDataChange();
1794      }
1795      @Override
1796      public void updateApps(ArrayList&lt;ApplicationInfo&gt; list) {
1797          // We remove and re-add the updated applications list because it&#x27;s properties may have
1798          // changed (ie. the title), and this will ensure that the items will be in their proper
1799          // place in the list.
1800          removeAppsWithoutInvalidate(list);
1801          addAppsWithoutInvalidate(list);
1802          updatePageCounts();
1803          invalidateOnDataChange();
1804      }
1805  
1806      @Override
1807      public void reset() {
1808          // If we have reset, then we should not continue to restore the previous state
1809          mSaveInstanceStateItemIndex = -1;
1810  
1811          AppsCustomizeTabHost tabHost = getTabHost();
1812          String tag = tabHost.getCurrentTabTag();
1813          if (tag != null) {
1814              if (!tag.equals(tabHost.getTabTagForContentType(ContentType.Applications))) {
1815                  tabHost.setCurrentTabFromContent(ContentType.Applications);
1816              }
1817          }
1818  
1819          if (mCurrentPage != 0) {
1820              invalidatePageData(0);
1821          }
1822      }
1823  
1824      private AppsCustomizeTabHost getTabHost() {
1825          return (AppsCustomizeTabHost) mLauncher.findViewById(R.id.apps_customize_pane);
1826      }
1827  
1828      @Override
1829      public void dumpState() {
1830          // TODO: Dump information related to current list of Applications, Widgets, etc.
1831          ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mApps&quot;, mApps);
1832          dumpAppWidgetProviderInfoList(TAG, &quot;mWidgets&quot;, mWidgets);
1833      }
1834  
1835      private void dumpAppWidgetProviderInfoList(String tag, String label,
1836              ArrayList&lt;Object&gt; list) {
1837          Log.d(tag, label + &quot; size=&quot; + list.size());
1838          for (Object i: list) {
1839              if (i instanceof AppWidgetProviderInfo) {
1840                  AppWidgetProviderInfo info = (AppWidgetProviderInfo) i;
1841                  Log.d(tag, &quot;   label=\&quot;&quot; + info.label + &quot;\&quot; previewImage=&quot; + info.previewImage
1842                          + &quot; resizeMode=&quot; + info.resizeMode + &quot; configure=&quot; + info.configure
1843                          + &quot; initialLayout=&quot; + info.initialLayout
1844                          + &quot; minWidth=&quot; + info.minWidth + &quot; minHeight=&quot; + info.minHeight);
1845              } else if (i instanceof ResolveInfo) {
1846                  ResolveInfo info = (ResolveInfo) i;
1847                  Log.d(tag, &quot;   label=\&quot;&quot; + info.loadLabel(mPackageManager) + &quot;\&quot; icon=&quot;
1848                          + info.icon);
1849              }
1850          }
1851      }
1852  
1853      @Override
1854      public void surrender() {
1855          // TODO: If we are in the middle of any process (ie. for holographic outlines, etc) we
1856          // should stop this now.
1857  
1858          // Stop all background tasks
1859          cancelAllTasks();
1860      }
1861  
1862      @Override
1863      public void iconPressed(PagedViewIcon icon) {
1864          // Reset the previously pressed icon and store a reference to the pressed icon so that
1865          // we can reset it on return to Launcher (in Launcher.onResume())
1866          if (mPressedIcon != null) {
1867              mPressedIcon.resetDrawableState();
1868          }
1869          mPressedIcon = icon;
1870      }
1871  
1872      public void resetDrawableState() {
1873          if (mPressedIcon != null) {
1874              mPressedIcon.resetDrawableState();
1875              mPressedIcon = null;
1876          }
1877      }
1878  
1879      /*
1880       * We load an extra page on each side to prevent flashes from scrolling and loading of the
1881       * widget previews in the background with the AsyncTasks.
1882       */
1883      final static int sLookBehindPageCount = 2;
1884      final static int sLookAheadPageCount = 2;
1885      protected int getAssociatedLowerPageBound(int page) {
1886          final int count = getChildCount();
1887          int windowSize = Math.min(count, sLookBehindPageCount + sLookAheadPageCount + 1);
1888          int windowMinIndex = Math.max(Math.min(page - sLookBehindPageCount, count - windowSize), 0);
1889          return windowMinIndex;
1890      }
1891      protected int getAssociatedUpperPageBound(int page) {
1892          final int count = getChildCount();
1893          int windowSize = Math.min(count, sLookBehindPageCount + sLookAheadPageCount + 1);
1894          int windowMaxIndex = Math.min(Math.max(page + sLookAheadPageCount, windowSize - 1),
1895                  count - 1);
1896          return windowMaxIndex;
1897      }
1898  
1899      @Override
1900      protected String getCurrentPageDescription() {
1901          int page = (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
1902          int stringId = R.string.default_scroll_format;
1903          int count = 0;
1904  
1905          if (page &lt; mNumAppsPages) {
1906              stringId = R.string.apps_customize_apps_scroll_format;
1907              count = mNumAppsPages;
1908          } else {
1909              page -= mNumAppsPages;
1910              stringId = R.string.apps_customize_widgets_scroll_format;
1911              count = mNumWidgetPages;
1912          }
1913  
1914          return String.format(getContext().getString(stringId), page + 1, count);
1915      }
1916  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            