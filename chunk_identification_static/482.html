<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>482</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    482
                    <a href="481.html">prev</a>
                    <a href="483.html">next</a>
                    <a href="482_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_d05422642ce1f3a62d990ae9e88d6c3496835126_rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/async/RdbAsyncReqRow.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;d05422642ce1f3a62d990ae9e88d6c3496835126:rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/async/RdbAsyncReqRow.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;d05422642ce1f3a62d990ae9e88d6c3496835126^1:rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/async/RdbAsyncReqRow.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;d05422642ce1f3a62d990ae9e88d6c3496835126^2:rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/async/RdbAsyncReqRow.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;3df78d7ec37de341c5abef90d10a1abd2bd348f5:rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/async/RdbAsyncReqRow.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 package com.dtstack.flink.sql.side.rdb.async;
  21 
  22 import com.dtstack.flink.sql.enums.ECacheContentType;
  23 import com.dtstack.flink.sql.side.*;
  24 import com.dtstack.flink.sql.side.cache.CacheObj;
  25 import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
  26 import com.dtstack.flink.sql.util.DateUtil;
  27 import io.vertx.core.json.JsonArray;
  28 import io.vertx.core.json.JsonObject;
  29 import io.vertx.ext.sql.SQLClient;
  30 import io.vertx.ext.sql.SQLConnection;
  31 import com.google.common.collect.Lists;
  32 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  33 import org.apache.flink.table.runtime.types.CRow;
  34 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  35 import org.apache.flink.types.Row;
  36 import org.slf4j.Logger;
  37 import org.slf4j.LoggerFactory;
  38 
  39 import java.math.BigDecimal;
  40 import java.sql.Timestamp;
  41 import java.time.Instant;
  42 import java.util.List;
  43 import java.util.Map;
  44 
  45 /**
  46  * Date: 2018/11/26
  47  * Company: www.dtstack.com
  48  *
  49  * @author maqi
  50  */
  51 
  52 public class RdbAsyncReqRow extends AsyncReqRow {
  53 
  54     private static final long serialVersionUID = 2098635244857937720L;
  55 
  56     private static final Logger LOG = LoggerFactory.getLogger(RdbAsyncReqRow.class);
  57 
  58     public final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 1;
  59 
<abbr title="  60     public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() * 2;">  60     public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() *ðŸ”µ</abbr>
  61 
<abbr title="  62     public final static int DEFAULT_MAX_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_POOL_SIZE;">  62     public final static int DEFAULT_MAX_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_ðŸ”µ</abbr>
  63 
  64     public final static int DEFAULT_IDLE_CONNECTION_TEST_PEROID = 60;
  65 
  66     public final static boolean DEFAULT_TEST_CONNECTION_ON_CHECKIN = true;
  67 
<abbr title="  68     public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvider&quot;;">  68     public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSouðŸ”µ</abbr>
  69 
  70     public final static String PREFERRED_TEST_QUERY_SQL = &quot;select 1 from dual&quot;;
  71 
  72     private transient SQLClient rdbSQLClient;
  73 
  74     public RdbAsyncReqRow(SideInfo sideInfo) {
  75         super(sideInfo);
  76     }
  77 
  78     @Override
  79     public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {
  80         CRow copyCrow = new CRow(input.row(), input.change());
  81         JsonArray inputParams = new JsonArray();
  82         for (Integer conValIndex : sideInfo.getEqualValIndex()) {
  83             Object equalObj = copyCrow.row().getField(conValIndex);
  84             if (equalObj == null) {
  85                 dealMissKey(copyCrow, resultFuture);
  86                 return;
  87             }
  88             inputParams.add(convertDataType(equalObj));
  89         }
  90 
  91         String key = buildCacheKey(inputParams);
  92         if (openCache()) {
  93             CacheObj val = getFromCache(key);
  94             if (val != null) {
  95                 if (ECacheContentType.MissVal == val.getType()) {
  96                     dealMissKey(copyCrow, resultFuture);
  97                     return;
  98                 } else if (ECacheContentType.MultiLine == val.getType()) {
  99                     try {
 100                         List&lt;CRow&gt; rowList = getRows(copyCrow, null, (List) val.getContent());
 101                         resultFuture.complete(rowList);
 102                     } catch (Exception e) {
 103                         dealFillDataError(resultFuture, e, copyCrow);
 104                     }
 105                 } else {
<abbr title=" 106                     resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot; + val.getType()));"> 106                     resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot;ðŸ”µ</abbr>
 107                 }
 108                 return;
 109             }
 110         }
 111 
 112         rdbSQLClient.getConnection(conn -&gt; {
 113             if (conn.failed()) {
 114                 //Treatment failures
 115                 resultFuture.completeExceptionally(conn.cause());
 116                 return;
 117             }
 118 
 119             final SQLConnection connection = conn.result();
 120             String sqlCondition = sideInfo.getSqlCondition();
 121             connection.queryWithParams(sqlCondition, inputParams, rs -&gt; {
 122                 if (rs.failed()) {
 123                     LOG.error(&quot;Cannot retrieve the data from the database&quot;, rs.cause());
 124                     resultFuture.completeExceptionally(rs.cause());
 125                     return;
 126                 }
 127                 List&lt;JsonArray&gt; cacheContent = Lists.newArrayList();
 128                 List&lt;JsonArray&gt; results = rs.result().getResults();
 129                 if (results.size() &gt; 0) {
 130                     try {
 131                         List&lt;CRow&gt; rowList = getRows(copyCrow, cacheContent, results);
<abbr title=" 132                         dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));"> 132                         dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheConteðŸ”µ</abbr>
 133                         resultFuture.complete(rowList);
 134                     } catch (Exception e){
 135                         dealFillDataError(resultFuture, e, copyCrow);
 136                     }
 137                 } else {
 138                     dealMissKey(copyCrow, resultFuture);
 139                     dealCacheData(key, CacheMissVal.getMissKeyObj());
 140                 }
 141 
 142                 // and close the connection
 143                 connection.close(done -&gt; {
 144                     if (done.failed()) {
 145                         throw new RuntimeException(done.cause());
 146                     }
 147                 });
 148             });
 149         });
 150     }
 151 
 152 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 153     protected List&lt;CRow&gt; getRows(CRow inputRow, List&lt;JsonArray&gt; cacheContent, List&lt;JsonArray&gt; results) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 154         List&lt;CRow&gt; rowList = Lists.newArrayList();</span>
 155 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 156             });</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 157         });</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 158     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 159 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 160     protected List&lt;Row&gt; getRows(Row inputRow, List&lt;JsonArray&gt; cacheContent, List&lt;JsonArray&gt; results) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 161         List&lt;Row&gt; rowList = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 162         for (JsonArray line : results) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 163             Row row = fillData(inputRow, line);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 164             if (null != cacheContent &amp;&amp; openCache()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 165                 cacheContent.add(line);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 166             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 167             rowList.add(row);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 168         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 169         return rowList;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 170     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 171 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 172     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 173     public Row fillData(Row input, Object line) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 174         JsonArray jsonArray = (JsonArray) line;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 175         Row row = new Row(sideInfo.getOutFieldInfoList().size());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 176         String[] fields = sideInfo.getSideTableInfo().getFieldTypes();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 177         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 178             Object obj = input.getField(entry.getValue());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 179             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 179             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRoðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 180             if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 181                 obj = ((Timestamp) obj).getTime();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 182             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 183 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 184             row.setField(entry.getKey(), obj);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 185         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 186 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 187         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 188             if (jsonArray == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 189                 row.setField(entry.getKey(), null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 190             } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 191                 Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.getValue()]);"> 191                 Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.gðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 192                 row.setField(entry.getKey(), object);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 193             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 194         }</span>
 195 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 196 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 197     private Object convertDataType(Object val) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 198         if (val == null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 199             // OK</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 200         } else if (val instanceof Number &amp;&amp; !(val instanceof BigDecimal)) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 201             // OK</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 202         } else if (val instanceof Boolean) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 203             // OK</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 204         } else if (val instanceof String) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 205             // OK</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 206         } else if (val instanceof Character) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 207             // OK</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 208         } else if (val instanceof CharSequence) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 209 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 210         } else if (val instanceof JsonObject) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 211 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 212         } else if (val instanceof JsonArray) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 213 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 214         } else if (val instanceof Map) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 215 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 216         } else if (val instanceof List) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 217 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 218         } else if (val instanceof byte[]) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 219 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 220         } else if (val instanceof Instant) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 221 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 222         } else if (val instanceof Timestamp) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 223             val = DateUtil.getStringFromTimestamp((Timestamp) val);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 224         } else if (val instanceof java.util.Date) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 225             val = DateUtil.getStringFromDate((java.sql.Date) val);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 226         } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 227             val = val.toString();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 228         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 229         return val;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 230     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 231 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 232 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 233     protected List&lt;Row&gt; getRows(Row inputRow, List&lt;JsonArray&gt; cacheContent, List&lt;JsonArray&gt; results) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 234         List&lt;Row&gt; rowList = Lists.newArrayList();</span>
 235 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 236         for (JsonArray line : results) {
 237             Row row = fillData(inputRow.row(), line);
 238             if (null != cacheContent &amp;&amp; openCache()) {
 239                 cacheContent.add(line);
 240             }
 241             rowList.add(new CRow(row, inputRow.change()));
 242         }
 243         return rowList;
 244     }
 245 
 246     @Override
 247     public Row fillData(Row input, Object line) {
 248         JsonArray jsonArray = (JsonArray) line;
 249         Row row = new Row(sideInfo.getOutFieldInfoList().size());
 250         String[] fields = sideInfo.getSideTableInfo().getFieldTypes();
 251         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 252             Object obj = input.getField(entry.getValue());
<abbr title=" 253             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 253             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRoðŸ”µ</abbr>
 254             if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {
 255                 obj = ((Timestamp) obj).getTime();
 256             }
 257 
 258             row.setField(entry.getKey(), obj);
 259         }
 260 
 261         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 262             if (jsonArray == null) {
 263                 row.setField(entry.getKey(), null);
 264             } else {
<abbr title=" 265                 Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.getValue()]);"> 265                 Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.gðŸ”µ</abbr>
 266                 row.setField(entry.getKey(), object);
 267             }
 268         }
 269 
 270         return row;
 271     }
 272 
 273     @Override
 274     public void close() throws Exception {
 275         super.close();
 276         if (rdbSQLClient != null) {
 277             rdbSQLClient.close();
 278         }
 279 
 280     }
 281 
 282     public String buildCacheKey(JsonArray jsonArray) {
 283         StringBuilder sb = new StringBuilder();
 284         for (Object ele : jsonArray.getList()) {
 285             sb.append(ele.toString())
 286                     .append(&quot;_&quot;);
 287         }
 288 
 289         return sb.toString();
 290     }
 291 
 292     public void setRdbSQLClient(SQLClient rdbSQLClient) {
 293         this.rdbSQLClient = rdbSQLClient;
 294     }
 295 
 296 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 package com.dtstack.flink.sql.side.rdb.async;
  21 
  22 import com.dtstack.flink.sql.enums.ECacheContentType;
  23 import com.dtstack.flink.sql.side.*;
  24 import com.dtstack.flink.sql.side.cache.CacheObj;
  25 import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
  26 import com.dtstack.flink.sql.util.DateUtil;
  27 import io.vertx.core.json.JsonArray;
  28 import io.vertx.core.json.JsonObject;
  29 import io.vertx.ext.sql.SQLClient;
  30 import io.vertx.ext.sql.SQLConnection;
  31 import com.google.common.collect.Lists;
  32 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  33 import org.apache.flink.table.runtime.types.CRow;
  34 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  35 import org.apache.flink.types.Row;
  36 import org.slf4j.Logger;
  37 import org.slf4j.LoggerFactory;
  38 
  39 import java.math.BigDecimal;
  40 import java.sql.Timestamp;
  41 import java.time.Instant;
  42 import java.util.List;
  43 import java.util.Map;
  44 
  45 /**
  46  * Date: 2018/11/26
  47  * Company: www.dtstack.com
  48  *
  49  * @author maqi
  50  */
  51 
  52 public class RdbAsyncReqRow extends AsyncReqRow {
  53 
  54     private static final long serialVersionUID = 2098635244857937720L;
  55 
  56     private static final Logger LOG = LoggerFactory.getLogger(RdbAsyncReqRow.class);
  57 
  58     public final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 1;
  59 
<abbr title="  60     public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() * 2;">  60     public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() *ðŸ”µ</abbr>
  61 
<abbr title="  62     public final static int DEFAULT_MAX_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_POOL_SIZE;">  62     public final static int DEFAULT_MAX_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_ðŸ”µ</abbr>
  63 
  64     public final static int DEFAULT_IDLE_CONNECTION_TEST_PEROID = 60;
  65 
  66     public final static boolean DEFAULT_TEST_CONNECTION_ON_CHECKIN = true;
  67 
<abbr title="  68     public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvider&quot;;">  68     public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSouðŸ”µ</abbr>
  69 
  70     public final static String PREFERRED_TEST_QUERY_SQL = &quot;select 1 from dual&quot;;
  71 
  72     private transient SQLClient rdbSQLClient;
  73 
  74     public RdbAsyncReqRow(SideInfo sideInfo) {
  75         super(sideInfo);
  76     }
  77 
  78     @Override
  79     public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {
  80         CRow copyCrow = new CRow(input.row(), input.change());
  81         JsonArray inputParams = new JsonArray();
  82         for (Integer conValIndex : sideInfo.getEqualValIndex()) {
  83             Object equalObj = copyCrow.row().getField(conValIndex);
  84             if (equalObj == null) {
  85                 dealMissKey(copyCrow, resultFuture);
  86                 return;
  87             }
  88             inputParams.add(convertDataType(equalObj));
  89         }
  90 
  91         String key = buildCacheKey(inputParams);
  92         if (openCache()) {
  93             CacheObj val = getFromCache(key);
  94             if (val != null) {
  95                 if (ECacheContentType.MissVal == val.getType()) {
  96                     dealMissKey(copyCrow, resultFuture);
  97                     return;
  98                 } else if (ECacheContentType.MultiLine == val.getType()) {
  99                     try {
 100                         List&lt;CRow&gt; rowList = getRows(copyCrow, null, (List) val.getContent());
 101                         resultFuture.complete(rowList);
 102                     } catch (Exception e) {
 103                         dealFillDataError(resultFuture, e, copyCrow);
 104                     }
 105                 } else {
<abbr title=" 106                     resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot; + val.getType()));"> 106                     resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot;ðŸ”µ</abbr>
 107                 }
 108                 return;
 109             }
 110         }
 111 
 112         rdbSQLClient.getConnection(conn -&gt; {
 113             if (conn.failed()) {
 114                 //Treatment failures
 115                 resultFuture.completeExceptionally(conn.cause());
 116                 return;
 117             }
 118 
 119             final SQLConnection connection = conn.result();
 120             String sqlCondition = sideInfo.getSqlCondition();
 121             connection.queryWithParams(sqlCondition, inputParams, rs -&gt; {
 122                 if (rs.failed()) {
 123                     LOG.error(&quot;Cannot retrieve the data from the database&quot;, rs.cause());
 124                     resultFuture.completeExceptionally(rs.cause());
 125                     return;
 126                 }
 127                 List&lt;JsonArray&gt; cacheContent = Lists.newArrayList();
 128                 List&lt;JsonArray&gt; results = rs.result().getResults();
 129                 if (results.size() &gt; 0) {
 130                     try {
 131                         List&lt;CRow&gt; rowList = getRows(copyCrow, cacheContent, results);
<abbr title=" 132                         dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));"> 132                         dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheConteðŸ”µ</abbr>
 133                         resultFuture.complete(rowList);
 134                     } catch (Exception e){
 135                         dealFillDataError(resultFuture, e, copyCrow);
 136                     }
 137                 } else {
 138                     dealMissKey(copyCrow, resultFuture);
 139                     dealCacheData(key, CacheMissVal.getMissKeyObj());
 140                 }
 141 
 142                 // and close the connection
 143                 connection.close(done -&gt; {
 144                     if (done.failed()) {
 145                         throw new RuntimeException(done.cause());
 146                     }
 147                 });
 148             });
 149         });
 150     }
 151 
 152 
 153     protected List&lt;CRow&gt; getRows(CRow inputRow, List&lt;JsonArray&gt; cacheContent, List&lt;JsonArray&gt; results) {
 154         List&lt;CRow&gt; rowList = Lists.newArrayList();
 155         for (JsonArray line : results) {
 156             Row row = fillData(inputRow.row(), line);
 157             if (null != cacheContent &amp;&amp; openCache()) {
 158                 cacheContent.add(line);
 159             }
 160             rowList.add(new CRow(row, inputRow.change()));
 161         }
 162         return rowList;
 163     }
 164 
 165 
 166     private Object convertDataType(Object val) {
 167         if (val == null) {
 168             // OK
 169         } else if (val instanceof Number &amp;&amp; !(val instanceof BigDecimal)) {
 170             // OK
 171         } else if (val instanceof Boolean) {
 172             // OK
 173         } else if (val instanceof String) {
 174             // OK
 175         } else if (val instanceof Character) {
 176             // OK
 177         } else if (val instanceof CharSequence) {
 178 
 179         } else if (val instanceof JsonObject) {
 180 
 181         } else if (val instanceof JsonArray) {
 182 
 183         } else if (val instanceof Map) {
 184 
 185         } else if (val instanceof List) {
 186 
 187         } else if (val instanceof byte[]) {
 188 
 189         } else if (val instanceof Instant) {
 190 
 191         } else if (val instanceof Timestamp) {
 192             val = DateUtil.getStringFromTimestamp((Timestamp) val);
 193         } else if (val instanceof java.util.Date) {
 194             val = DateUtil.getStringFromDate((java.sql.Date) val);
 195         } else {
 196             val = val.toString();
 197         }
 198         return val;
 199     }
 200 
 201     @Override
 202     public Row fillData(Row input, Object line) {
 203         JsonArray jsonArray = (JsonArray) line;
 204         Row row = new Row(sideInfo.getOutFieldInfoList().size());
 205         String[] fields = sideInfo.getSideTableInfo().getFieldTypes();
 206         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 207             Object obj = input.getField(entry.getValue());
<abbr title=" 208             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 208             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRoðŸ”µ</abbr>
 209             if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {
 210                 obj = ((Timestamp) obj).getTime();
 211             }
 212 
 213             row.setField(entry.getKey(), obj);
 214         }
 215 
 216         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 217             if (jsonArray == null) {
 218                 row.setField(entry.getKey(), null);
 219             } else {
<abbr title=" 220                 Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.getValue()]);"> 220                 Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.gðŸ”µ</abbr>
 221                 row.setField(entry.getKey(), object);
 222             }
 223         }
 224 
 225         return row;
 226     }
 227 
 228     @Override
 229     public void close() throws Exception {
 230         super.close();
 231         if (rdbSQLClient != null) {
 232             rdbSQLClient.close();
 233         }
 234 
 235     }
 236 
 237     public String buildCacheKey(JsonArray jsonArray) {
 238         StringBuilder sb = new StringBuilder();
 239         for (Object ele : jsonArray.getList()) {
 240             sb.append(ele.toString())
 241                     .append(&quot;_&quot;);
 242         }
 243 
 244         return sb.toString();
 245     }
 246 
 247     public void setRdbSQLClient(SQLClient rdbSQLClient) {
 248         this.rdbSQLClient = rdbSQLClient;
 249     }
 250 
 251 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side.rdb.async;
  19 
  20 import com.dtstack.flink.sql.enums.ECacheContentType;
  21 import com.dtstack.flink.sql.side.*;
  22 import com.dtstack.flink.sql.side.cache.CacheObj;
  23 import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
  24 import com.dtstack.flink.sql.util.DateUtil;
  25 import com.google.common.collect.Lists;
  26 import io.vertx.core.json.JsonArray;
  27 import io.vertx.core.json.JsonObject;
  28 import io.vertx.ext.sql.SQLClient;
  29 import io.vertx.ext.sql.SQLConnection;
  30 import java.math.BigDecimal;
  31 import java.sql.Timestamp;
  32 import java.time.Instant;
  33 import java.util.List;
  34 import java.util.Map;
  35 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  36 import org.apache.flink.table.runtime.types.CRow;
  37 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  38 import org.apache.flink.types.Row;
  39 import org.slf4j.Logger;
  40 import org.slf4j.LoggerFactory;
  41 
  42 
  43 /**
  44  * Date: 2018/11/26
  45  * Company: www.dtstack.com
  46  *
  47  * @author maqi
  48  */
  49 public class RdbAsyncReqRow extends AsyncReqRow {
  50     private static final long serialVersionUID = 2098635244857937720L;
  51 
  52     private static final Logger LOG = LoggerFactory.getLogger(RdbAsyncReqRow.class);
  53 
  54     public final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 1;
  55 
<abbr title="  56     public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() * 2;">  56     public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() *ðŸ”µ</abbr>
  57 
<abbr title="  58     public final static int DEFAULT_MAX_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_POOL_SIZE;">  58     public final static int DEFAULT_MAX_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_ðŸ”µ</abbr>
  59 
  60     public final static int DEFAULT_IDLE_CONNECTION_TEST_PEROID = 60;
  61 
  62     public final static boolean DEFAULT_TEST_CONNECTION_ON_CHECKIN = true;
  63 
<abbr title="  64     public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvider&quot;;">  64     public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSouðŸ”µ</abbr>
  65 
  66     public final static String PREFERRED_TEST_QUERY_SQL = &quot;select 1 from dual&quot;;
  67 
  68     private transient SQLClient rdbSQLClient;
  69 
  70     public RdbAsyncReqRow(SideInfo sideInfo) {
  71         super(sideInfo);
  72     }
  73 
  74     @Override
  75     public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {
  76         CRow copyCrow = new CRow(input.row(), input.change());
  77         JsonArray inputParams = new JsonArray();
  78         for (Integer conValIndex : sideInfo.getEqualValIndex()) {
  79             Object equalObj = copyCrow.row().getField(conValIndex);
  80             if (equalObj == null) {
  81                 dealMissKey(copyCrow, resultFuture);
  82                 return;
  83             }
  84             inputParams.add(convertDataType(equalObj));
  85         }
  86         String key = buildCacheKey(inputParams);
  87         if (openCache()) {
  88             CacheObj val = getFromCache(key);
  89             if (val != null) {
  90                 if (ECacheContentType.MissVal == val.getType()) {
  91                     dealMissKey(copyCrow, resultFuture);
  92                     return;
  93                 } else if (ECacheContentType.MultiLine == val.getType()) {
  94                     try {
  95                         List&lt;CRow&gt; rowList = getRows(copyCrow, null, ((List) (val.getContent())));
  96                         resultFuture.complete(rowList);
  97                     } catch (java.lang.Exception e) {
  98                         dealFillDataError(resultFuture, e, copyCrow);
  99                     }
 100                 } else {
<abbr title=" 101                     resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot; + val.getType()));"> 101                     resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot;ðŸ”µ</abbr>
 102                 }
 103                 return;
 104             }
 105         }
 106         rdbSQLClient.getConnection(( conn) -&gt; {
 107             if (conn.failed()) {
 108                 // Treatment failures
 109                 resultFuture.completeExceptionally(conn.cause());
 110                 return;
 111             }
 112             final SQLConnection connection = conn.result();
 113             String sqlCondition = sideInfo.getSqlCondition();
 114             connection.queryWithParams(sqlCondition, inputParams, ( rs) -&gt; {
 115                 if (rs.failed()) {
 116                     LOG.error(&quot;Cannot retrieve the data from the database&quot;, rs.cause());
 117                     resultFuture.completeExceptionally(rs.cause());
 118                     return;
 119                 }
 120                 List&lt;JsonArray&gt; cacheContent = Lists.newArrayList();
 121                 List&lt;JsonArray&gt; results = rs.result().getResults();
 122                 if (results.size() &gt; 0) {
 123                     try {
 124                         List&lt;CRow&gt; rowList = getRows(copyCrow, cacheContent, results);
<abbr title=" 125                         dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));"> 125                         dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheConteðŸ”µ</abbr>
 126                         resultFuture.complete(rowList);
 127                     } catch ( e) {
 128                         dealFillDataError(resultFuture, e, copyCrow);
 129                     }
 130                 } else {
 131                     dealMissKey(copyCrow, resultFuture);
 132                     dealCacheData(key, CacheMissVal.getMissKeyObj());
 133                 }
 134                 // and close the connection
 135                 connection.close(( done) -&gt; {
 136                     if (done.failed()) {
 137                         throw new RuntimeException(done.cause());
 138                     }
 139                 });
 140             });
 141         });
 142     }
 143 
 144     private Object convertDataType(Object val) {
 145         if (val == null) {
 146             // OK
 147         } else if (val instanceof Number &amp;&amp; !(val instanceof BigDecimal)) {
 148             // OK
 149         } else if (val instanceof Boolean) {
 150             // OK
 151         } else if (val instanceof String) {
 152             // OK
 153         } else if (val instanceof Character) {
 154             // OK
 155         } else if (val instanceof CharSequence) {
 156 
 157         } else if (val instanceof JsonObject) {
 158 
 159         } else if (val instanceof JsonArray) {
 160 
 161         } else if (val instanceof Map) {
 162 
 163         } else if (val instanceof List) {
 164 
 165         } else if (val instanceof byte[]) {
 166 
 167         } else if (val instanceof Instant) {
 168 
 169         } else if (val instanceof Timestamp) {
 170             val = DateUtil.getStringFromTimestamp((Timestamp) val);
 171         } else if (val instanceof java.util.Date) {
 172             val = DateUtil.getStringFromDate((java.sql.Date) val);
 173         } else {
 174             val = val.toString();
 175         }
 176         return val;
 177     }
 178 
 179     protected List&lt;CRow&gt; getRows(CRow inputRow, List&lt;JsonArray&gt; cacheContent, List&lt;JsonArray&gt; results) {
 180         List&lt;CRow&gt; rowList = Lists.newArrayList();
 181         for (JsonArray line : results) {
 182             Row row = fillData(inputRow.row(), line);
 183             if ((null != cacheContent) &amp;&amp; openCache()) {
 184                 cacheContent.add(line);
 185             }
 186             rowList.add(new CRow(row, inputRow.change()));
 187         }
 188         return rowList;
 189     }
 190 
 191     @Override
 192     public Row fillData(Row input, Object line) {
 193         JsonArray jsonArray = (JsonArray) line;
 194         Row row = new Row(sideInfo.getOutFieldInfoList().size());
 195         String[] fields = sideInfo.getSideTableInfo().getFieldTypes();
 196         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 197             Object obj = input.getField(entry.getValue());
<abbr title=" 198             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 198             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRoðŸ”µ</abbr>
 199             if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {
 200                 obj = ((Timestamp) obj).getTime();
 201             }
 202 
 203             row.setField(entry.getKey(), obj);
 204         }
 205 
 206         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 207             if (jsonArray == null) {
 208                 row.setField(entry.getKey(), null);
 209             } else {
<abbr title=" 210                 Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.getValue()]);"> 210                 Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.gðŸ”µ</abbr>
 211                 row.setField(entry.getKey(), object);
 212             }
 213         }
 214 
 215         return row;
 216     }
 217 
 218     @Override
 219     public void close() throws Exception {
 220         super.close();
 221         if (rdbSQLClient != null) {
 222             rdbSQLClient.close();
 223         }
 224 
 225     }
 226 
 227     public String buildCacheKey(JsonArray jsonArray) {
 228         StringBuilder sb = new StringBuilder();
 229         for (Object ele : jsonArray.getList()) {
 230             sb.append(ele.toString())
 231                     .append(&quot;_&quot;);
 232         }
 233 
 234         return sb.toString();
 235     }
 236 
 237     public void setRdbSQLClient(SQLClient rdbSQLClient) {
 238         this.rdbSQLClient = rdbSQLClient;
 239     }
 240 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  package com.dtstack.flink.sql.side.rdb.async;
  21  
  22  import com.dtstack.flink.sql.enums.ECacheContentType;
  23  import com.dtstack.flink.sql.side.*;
  24  import com.dtstack.flink.sql.side.cache.CacheObj;
  25  import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
  26  import io.vertx.core.AsyncResult;
  27  import io.vertx.core.Handler;
  28  import io.vertx.core.Vertx;
  29  import io.vertx.core.VertxOptions;

  30  import io.vertx.core.json.JsonArray;
  31  import io.vertx.core.json.JsonObject;
  32  import io.vertx.ext.jdbc.JDBCClient;
  33  import io.vertx.ext.sql.SQLClient;
  34  import io.vertx.ext.sql.SQLConnection;
  35  import com.google.common.collect.Lists;
  36  import org.apache.flink.streaming.api.functions.async.ResultFuture;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  37 +import org.apache.flink.table.runtime.types.CRow;</span>
  38  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  39  import org.apache.flink.types.Row;
  40  import org.slf4j.Logger;
  41  import org.slf4j.LoggerFactory;
  42  

  43  import java.sql.Timestamp;
  44  import java.util.Collection;
  45  import java.util.Collections;

  46  import java.util.List;
  47  import java.util.Map;
  48  
  49  /**
  50   * Date: 2018/11/26
  51   * Company: www.dtstack.com
  52   *
  53   * @author maqi
  54   */
  55  
  56  public class RdbAsyncReqRow extends AsyncReqRow {
  57  
  58      private static final long serialVersionUID = 2098635244857937720L;
  59  
  60      private static final Logger LOG = LoggerFactory.getLogger(RdbAsyncReqRow.class);
  61  
  62      public final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 1;
  63  
  64      public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() * 2;
  65  
<abbr title="  66      public final static int DEFAULT_MAX_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_POOL_SIZE;">  66      public final static int DEFAULT_MAX_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORðŸ”µ</abbr>
  67  
  68      public final static int DEFAULT_IDLE_CONNECTION_TEST_PEROID = 60;
  69  
  70      public final static boolean DEFAULT_TEST_CONNECTION_ON_CHECKIN = true;
  71  
<abbr title="  72      public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvider&quot;;">  72      public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvidðŸ”µ</abbr>
  73  
  74      public final static String PREFERRED_TEST_QUERY_SQL = &quot;select 1 from dual&quot;;
  75  
  76      private transient SQLClient rdbSQLClient;
  77  
  78      public RdbAsyncReqRow(SideInfo sideInfo) {
  79          super(sideInfo);
  80      }
  81  
  82      @Override
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  83 -    public void asyncInvoke(Row input, ResultFuture&lt;Row&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  84 -        Row inputRow = Row.copy(input);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  85 +    public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  86 +        CRow copyCrow = new CRow(input.row(), input.change());</span>
  87          JsonArray inputParams = new JsonArray();
  88          for (Integer conValIndex : sideInfo.getEqualValIndex()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  89 -            Object equalObj = inputRow.getField(conValIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  90 +            Object equalObj = copyCrow.row().getField(conValIndex);</span>
  91              if (equalObj == null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  92 -                dealMissKey(inputRow, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  93 +                dealMissKey(copyCrow, resultFuture);</span>
  94                  return;
  95              }
  96              inputParams.add(equalObj);

  97          }
  98  
  99          String key = buildCacheKey(inputParams);
 100          if (openCache()) {
 101              CacheObj val = getFromCache(key);
 102              if (val != null) {
 103                  if (ECacheContentType.MissVal == val.getType()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 104 -                    dealMissKey(inputRow, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 105 +                    dealMissKey(copyCrow, resultFuture);</span>
 106                      return;
 107                  } else if (ECacheContentType.MultiLine == val.getType()) {
 108                      try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 109 -                        List&lt;Row&gt; rowList = getRows(inputRow, null, (List) val.getContent());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 110 +                        List&lt;CRow&gt; rowList = getRows(copyCrow, null, (List) val.getContent());</span>
 111                          resultFuture.complete(rowList);
 112                      } catch (Exception e) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 113 -                        dealFillDataError(resultFuture, e, inputRow);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 114 +                        dealFillDataError(resultFuture, e, copyCrow);</span>
 115                      }
 116                  } else {
<abbr title=" 117                      resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot; + val.getType()));"> 117                      resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot; + val.geðŸ”µ</abbr>
 118                  }
 119                  return;
 120              }
 121          }
 122  
 123          rdbSQLClient.getConnection(conn -&gt; {
 124              if (conn.failed()) {
 125                  //Treatment failures
 126                  resultFuture.completeExceptionally(conn.cause());
 127                  return;
 128              }
 129  
 130              final SQLConnection connection = conn.result();
 131              String sqlCondition = sideInfo.getSqlCondition();
 132              connection.queryWithParams(sqlCondition, inputParams, rs -&gt; {
 133                  if (rs.failed()) {
 134                      LOG.error(&quot;Cannot retrieve the data from the database&quot;, rs.cause());
 135                      resultFuture.completeExceptionally(rs.cause());
 136                      return;
 137                  }
 138                  List&lt;JsonArray&gt; cacheContent = Lists.newArrayList();
 139                  List&lt;JsonArray&gt; results = rs.result().getResults();
 140                  if (results.size() &gt; 0) {
 141                      try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 142 -                        List&lt;Row&gt; rowList = getRows(inputRow, cacheContent, results);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 143 +                        List&lt;CRow&gt; rowList = getRows(copyCrow, cacheContent, results);</span>
 144                          dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));
 145                          resultFuture.complete(rowList);
 146                      } catch (Exception e){
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 147 -                        dealFillDataError(resultFuture, e, inputRow);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 148 +                        dealFillDataError(resultFuture, e, copyCrow);</span>
 149                      }
 150                  } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 151 -                    dealMissKey(inputRow, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 152 +                    dealMissKey(copyCrow, resultFuture);</span>
 153                      dealCacheData(key, CacheMissVal.getMissKeyObj());
 154                  }
 155  
 156                  // and close the connection
 157                  connection.close(done -&gt; {
 158                      if (done.failed()) {
 159                          throw new RuntimeException(done.cause());
 160                      }
 161                  });
 162              });
 163          });
 164      }
 165  





































<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 166 -    protected List&lt;Row&gt; getRows(Row inputRow, List&lt;JsonArray&gt; cacheContent, List&lt;JsonArray&gt; results) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 167 -        List&lt;Row&gt; rowList = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 168 +    protected List&lt;CRow&gt; getRows(CRow inputRow, List&lt;JsonArray&gt; cacheContent, List&lt;JsonArray&gt; results) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 169 +        List&lt;CRow&gt; rowList = Lists.newArrayList();</span>
 170          for (JsonArray line : results) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 171 -            Row row = fillData(inputRow, line);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 172 +            Row row = fillData(inputRow.row(), line);</span>
 173              if (null != cacheContent &amp;&amp; openCache()) {
 174                  cacheContent.add(line);
 175              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 176 -            rowList.add(row);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 177 +            rowList.add(new CRow(row, inputRow.change()));</span>
 178          }
 179          return rowList;
 180      }
 181  
 182      @Override
 183      public Row fillData(Row input, Object line) {
 184          JsonArray jsonArray = (JsonArray) line;
 185          Row row = new Row(sideInfo.getOutFieldInfoList().size());
 186          String[] fields = sideInfo.getSideTableInfo().getFieldTypes();
 187          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 188              Object obj = input.getField(entry.getValue());
<abbr title=" 189              boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 189              boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfoðŸ”µ</abbr>
 190              if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {
 191                  obj = ((Timestamp) obj).getTime();
 192              }
 193  
 194              row.setField(entry.getKey(), obj);
 195          }
 196  
 197          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 198              if (jsonArray == null) {
 199                  row.setField(entry.getKey(), null);
 200              } else {
<abbr title=" 201                  Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.getValue()]);"> 201                  Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.getValue()ðŸ”µ</abbr>
 202                  row.setField(entry.getKey(), object);
 203              }
 204          }
 205  
 206          return row;
 207      }
 208  
 209      @Override
 210      public void close() throws Exception {
 211          super.close();
 212          if (rdbSQLClient != null) {
 213              rdbSQLClient.close();
 214          }
 215  
 216      }
 217  
 218      public String buildCacheKey(JsonArray jsonArray) {
 219          StringBuilder sb = new StringBuilder();
 220          for (Object ele : jsonArray.getList()) {
 221              sb.append(ele.toString())
 222                      .append(&quot;_&quot;);
 223          }
 224  
 225          return sb.toString();
 226      }
 227  
 228      public void setRdbSQLClient(SQLClient rdbSQLClient) {
 229          this.rdbSQLClient = rdbSQLClient;
 230      }
 231  
 232  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  package com.dtstack.flink.sql.side.rdb.async;
  21  
  22  import com.dtstack.flink.sql.enums.ECacheContentType;
  23  import com.dtstack.flink.sql.side.*;
  24  import com.dtstack.flink.sql.side.cache.CacheObj;
  25  import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  26 -import io.vertx.core.AsyncResult;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  27 -import io.vertx.core.Handler;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  28 -import io.vertx.core.Vertx;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  29 -import io.vertx.core.VertxOptions;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  30 +import com.dtstack.flink.sql.util.DateUtil;</span>
  31  import io.vertx.core.json.JsonArray;
  32  import io.vertx.core.json.JsonObject;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  33 -import io.vertx.ext.jdbc.JDBCClient;</span>
  34  import io.vertx.ext.sql.SQLClient;
  35  import io.vertx.ext.sql.SQLConnection;
  36  import com.google.common.collect.Lists;
  37  import org.apache.flink.streaming.api.functions.async.ResultFuture;

  38  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  39  import org.apache.flink.types.Row;
  40  import org.slf4j.Logger;
  41  import org.slf4j.LoggerFactory;
  42  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  43 +import java.math.BigDecimal;</span>
  44  import java.sql.Timestamp;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  45 -import java.util.Collection;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  46 -import java.util.Collections;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  47 +import java.time.Instant;</span>
  48  import java.util.List;
  49  import java.util.Map;
  50  
  51  /**
  52   * Date: 2018/11/26
  53   * Company: www.dtstack.com
  54   *
  55   * @author maqi
  56   */
  57  
  58  public class RdbAsyncReqRow extends AsyncReqRow {
  59  
  60      private static final long serialVersionUID = 2098635244857937720L;
  61  
  62      private static final Logger LOG = LoggerFactory.getLogger(RdbAsyncReqRow.class);
  63  
  64      public final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 1;
  65  
  66      public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() * 2;
  67  
<abbr title="  68      public final static int DEFAULT_MAX_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_POOL_SIZE;">  68      public final static int DEFAULT_MAX_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORðŸ”µ</abbr>
  69  
  70      public final static int DEFAULT_IDLE_CONNECTION_TEST_PEROID = 60;
  71  
  72      public final static boolean DEFAULT_TEST_CONNECTION_ON_CHECKIN = true;
  73  
<abbr title="  74      public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvider&quot;;">  74      public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvidðŸ”µ</abbr>
  75  
  76      public final static String PREFERRED_TEST_QUERY_SQL = &quot;select 1 from dual&quot;;
  77  
  78      private transient SQLClient rdbSQLClient;
  79  
  80      public RdbAsyncReqRow(SideInfo sideInfo) {
  81          super(sideInfo);
  82      }
  83  
  84      @Override
  85      public void asyncInvoke(Row input, ResultFuture&lt;Row&gt; resultFuture) throws Exception {
  86          Row inputRow = Row.copy(input);


  87          JsonArray inputParams = new JsonArray();
  88          for (Integer conValIndex : sideInfo.getEqualValIndex()) {
  89              Object equalObj = inputRow.getField(conValIndex);

  90              if (equalObj == null) {
  91                  dealMissKey(inputRow, resultFuture);

  92                  return;
  93              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  94 -            inputParams.add(equalObj);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  95 +            inputParams.add(convertDataType(equalObj));</span>
  96          }
  97  
  98          String key = buildCacheKey(inputParams);
  99          if (openCache()) {
 100              CacheObj val = getFromCache(key);
 101              if (val != null) {
 102                  if (ECacheContentType.MissVal == val.getType()) {
 103                      dealMissKey(inputRow, resultFuture);

 104                      return;
 105                  } else if (ECacheContentType.MultiLine == val.getType()) {
 106                      try {
 107                          List&lt;Row&gt; rowList = getRows(inputRow, null, (List) val.getContent());

 108                          resultFuture.complete(rowList);
 109                      } catch (Exception e) {
 110                          dealFillDataError(resultFuture, e, inputRow);

 111                      }
 112                  } else {
<abbr title=" 113                      resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot; + val.getType()));"> 113                      resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot; + val.geðŸ”µ</abbr>
 114                  }
 115                  return;
 116              }
 117          }
 118  
 119          rdbSQLClient.getConnection(conn -&gt; {
 120              if (conn.failed()) {
 121                  //Treatment failures
 122                  resultFuture.completeExceptionally(conn.cause());
 123                  return;
 124              }
 125  
 126              final SQLConnection connection = conn.result();
 127              String sqlCondition = sideInfo.getSqlCondition();
 128              connection.queryWithParams(sqlCondition, inputParams, rs -&gt; {
 129                  if (rs.failed()) {
 130                      LOG.error(&quot;Cannot retrieve the data from the database&quot;, rs.cause());
 131                      resultFuture.completeExceptionally(rs.cause());
 132                      return;
 133                  }
 134                  List&lt;JsonArray&gt; cacheContent = Lists.newArrayList();
 135                  List&lt;JsonArray&gt; results = rs.result().getResults();
 136                  if (results.size() &gt; 0) {
 137                      try {
 138                          List&lt;Row&gt; rowList = getRows(inputRow, cacheContent, results);

 139                          dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));
 140                          resultFuture.complete(rowList);
 141                      } catch (Exception e){
 142                          dealFillDataError(resultFuture, e, inputRow);

 143                      }
 144                  } else {
 145                      dealMissKey(inputRow, resultFuture);

 146                      dealCacheData(key, CacheMissVal.getMissKeyObj());
 147                  }
 148  
 149                  // and close the connection
 150                  connection.close(done -&gt; {
 151                      if (done.failed()) {
 152                          throw new RuntimeException(done.cause());
 153                      }
 154                  });
 155              });
 156          });
 157      }
 158  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 159 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 160 +    private Object convertDataType(Object val) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 161 +        if (val == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 162 +            // OK</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 163 +        } else if (val instanceof Number &amp;&amp; !(val instanceof BigDecimal)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 164 +            // OK</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 165 +        } else if (val instanceof Boolean) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 166 +            // OK</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 167 +        } else if (val instanceof String) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 168 +            // OK</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 169 +        } else if (val instanceof Character) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 170 +            // OK</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 171 +        } else if (val instanceof CharSequence) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 172 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 173 +        } else if (val instanceof JsonObject) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 174 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 175 +        } else if (val instanceof JsonArray) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 176 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 177 +        } else if (val instanceof Map) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 178 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 179 +        } else if (val instanceof List) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 180 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 181 +        } else if (val instanceof byte[]) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 182 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 183 +        } else if (val instanceof Instant) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 184 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 185 +        } else if (val instanceof Timestamp) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 186 +            val = DateUtil.getStringFromTimestamp((Timestamp) val);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 187 +        } else if (val instanceof java.util.Date) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 188 +            val = DateUtil.getStringFromDate((java.sql.Date) val);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 189 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 190 +            val = val.toString();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 191 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 192 +        return val;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 193 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 194 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 195 +</span>
 196      protected List&lt;Row&gt; getRows(Row inputRow, List&lt;JsonArray&gt; cacheContent, List&lt;JsonArray&gt; results) {
 197          List&lt;Row&gt; rowList = Lists.newArrayList();


 198          for (JsonArray line : results) {
 199              Row row = fillData(inputRow, line);

 200              if (null != cacheContent &amp;&amp; openCache()) {
 201                  cacheContent.add(line);
 202              }
 203              rowList.add(row);

 204          }
 205          return rowList;
 206      }
 207  
 208      @Override
 209      public Row fillData(Row input, Object line) {
 210          JsonArray jsonArray = (JsonArray) line;
 211          Row row = new Row(sideInfo.getOutFieldInfoList().size());
 212          String[] fields = sideInfo.getSideTableInfo().getFieldTypes();
 213          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 214              Object obj = input.getField(entry.getValue());
<abbr title=" 215              boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 215              boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfoðŸ”µ</abbr>
 216              if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {
 217                  obj = ((Timestamp) obj).getTime();
 218              }
 219  
 220              row.setField(entry.getKey(), obj);
 221          }
 222  
 223          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 224              if (jsonArray == null) {
 225                  row.setField(entry.getKey(), null);
 226              } else {
<abbr title=" 227                  Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.getValue()]);"> 227                  Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fields[entry.getValue()ðŸ”µ</abbr>
 228                  row.setField(entry.getKey(), object);
 229              }
 230          }
 231  
 232          return row;
 233      }
 234  
 235      @Override
 236      public void close() throws Exception {
 237          super.close();
 238          if (rdbSQLClient != null) {
 239              rdbSQLClient.close();
 240          }
 241  
 242      }
 243  
 244      public String buildCacheKey(JsonArray jsonArray) {
 245          StringBuilder sb = new StringBuilder();
 246          for (Object ele : jsonArray.getList()) {
 247              sb.append(ele.toString())
 248                      .append(&quot;_&quot;);
 249          }
 250  
 251          return sb.toString();
 252      }
 253  
 254      public void setRdbSQLClient(SQLClient rdbSQLClient) {
 255          this.rdbSQLClient = rdbSQLClient;
 256      }
 257  
 258  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            