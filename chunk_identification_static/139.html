<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>139</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    139
                    <a href="138.html">prev</a>
                    <a href="140.html">next</a>
                    <a href="139_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    Automattic/simplenote-android_7428c4d038363290d1a1a253552b709df5d5ebcb_Simplenote/src/main/java/com/automattic/simplenote/NoteListFragment.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;7428c4d038363290d1a1a253552b709df5d5ebcb:Simplenote/src/main/java/com/automattic/simplenote/NoteListFragment.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;7428c4d038363290d1a1a253552b709df5d5ebcb^1:Simplenote/src/main/java/com/automattic/simplenote/NoteListFragment.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;7428c4d038363290d1a1a253552b709df5d5ebcb^2:Simplenote/src/main/java/com/automattic/simplenote/NoteListFragment.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;e1d7aa5181efabb67e0c3c0de85f788cc7efcfcf:Simplenote/src/main/java/com/automattic/simplenote/NoteListFragment.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 package com.automattic.simplenote;
   2 
   3 import android.animation.ObjectAnimator;
   4 import android.annotation.SuppressLint;
   5 import android.content.Context;
   6 import android.content.Intent;
   7 import android.content.SharedPreferences;
   8 import android.database.Cursor;
   9 import android.database.sqlite.SQLiteException;
  10 import android.os.AsyncTask;
  11 import android.os.Bundle;
  12 import android.os.Handler;
  13 import android.text.SpannableString;
  14 import android.text.SpannableStringBuilder;
  15 import android.text.TextUtils;
  16 import android.text.style.AbsoluteSizeSpan;
  17 import android.text.style.TextAppearanceSpan;
  18 import android.util.Log;
  19 import android.util.SparseBooleanArray;
  20 import android.util.TypedValue;
  21 import android.view.ActionMode;
  22 import android.view.Gravity;
  23 import android.view.HapticFeedbackConstants;
  24 import android.view.LayoutInflater;
  25 import android.view.Menu;
  26 import android.view.MenuInflater;
  27 import android.view.MenuItem;
  28 import android.view.MotionEvent;
  29 import android.view.View;
  30 import android.view.ViewGroup;
  31 import android.widget.AbsListView;
  32 import android.widget.AdapterView;
  33 import android.widget.CursorAdapter;
  34 import android.widget.ImageButton;
  35 import android.widget.ImageView;
  36 import android.widget.LinearLayout;
  37 import android.widget.ListView;
  38 import android.widget.RelativeLayout;
  39 import android.widget.TextView;
  40 import android.widget.Toast;
  41 
  42 import androidx.annotation.DrawableRes;
  43 import androidx.annotation.NonNull;
  44 import androidx.annotation.StringRes;
  45 import androidx.appcompat.widget.PopupMenu;
  46 import androidx.fragment.app.ListFragment;
  47 import androidx.preference.PreferenceManager;
  48 import androidx.recyclerview.widget.DiffUtil;
  49 import androidx.recyclerview.widget.LinearLayoutManager;
  50 import androidx.recyclerview.widget.RecyclerView;
  51 
  52 import com.automattic.simplenote.analytics.AnalyticsTracker;
  53 import com.automattic.simplenote.models.Note;
  54 import com.automattic.simplenote.models.Preferences;
  55 import com.automattic.simplenote.models.Suggestion;
  56 import com.automattic.simplenote.models.Tag;
  57 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  58 import com.automattic.simplenote.utils.BrowserUtils;</span>
  59 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  60 import com.automattic.simplenote.utils.ChecklistUtils;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  61 import com.automattic.simplenote.utils.DateTimeUtils;</span>
  62 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  63 import com.automattic.simplenote.utils.AppLog;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  64 import com.automattic.simplenote.utils.AppLog.Type;</span>
  65 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  66 import com.automattic.simplenote.utils.ChecklistUtils;
  67 import com.automattic.simplenote.utils.DateTimeUtils;
  68 import com.automattic.simplenote.utils.DisplayUtils;
  69 import com.automattic.simplenote.utils.DrawableUtils;
  70 import com.automattic.simplenote.utils.NetworkUtils;
  71 import com.automattic.simplenote.utils.PrefUtils;
  72 import com.automattic.simplenote.utils.SearchSnippetFormatter;
  73 import com.automattic.simplenote.utils.SearchTokenizer;
  74 import com.automattic.simplenote.utils.SimplenoteLinkify;
  75 import com.automattic.simplenote.utils.StrUtils;
  76 import com.automattic.simplenote.utils.TextHighlighter;
  77 import com.automattic.simplenote.utils.ThemeUtils;
  78 import com.automattic.simplenote.utils.WidgetUtils;
  79 import com.google.android.material.floatingactionbutton.FloatingActionButton;
  80 import com.google.android.material.snackbar.Snackbar;
  81 import com.simperium.client.Bucket;
  82 import com.simperium.client.Bucket.ObjectCursor;
  83 import com.simperium.client.BucketObjectMissingException;
  84 import com.simperium.client.BucketObjectNameInvalid;
  85 import com.simperium.client.Query;
  86 
  87 import java.lang.ref.SoftReference;
  88 import java.util.ArrayList;
  89 import java.util.Calendar;
  90 import java.util.List;
  91 import java.util.regex.Matcher;
  92 import java.util.regex.Pattern;
  93 
  94 import static com.automattic.simplenote.analytics.AnalyticsTracker.CATEGORY_SEARCH;
  95 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.RECENT_SEARCH_TAPPED;
  96 import static com.automattic.simplenote.models.Note.TAGS_PROPERTY;
  97 import static com.automattic.simplenote.models.Preferences.MAX_RECENT_SEARCHES;
  98 import static com.automattic.simplenote.models.Preferences.PREFERENCES_OBJECT_KEY;
  99 import static com.automattic.simplenote.models.Suggestion.Type.HISTORY;
 100 import static com.automattic.simplenote.models.Suggestion.Type.QUERY;
 101 import static com.automattic.simplenote.models.Suggestion.Type.TAG;
 102 import static com.automattic.simplenote.models.Tag.NAME_PROPERTY;
 103 import static com.automattic.simplenote.utils.PrefUtils.ALPHABETICAL_ASCENDING;
 104 import static com.automattic.simplenote.utils.PrefUtils.ALPHABETICAL_DESCENDING;
 105 import static com.automattic.simplenote.utils.PrefUtils.DATE_CREATED_ASCENDING;
 106 import static com.automattic.simplenote.utils.PrefUtils.DATE_CREATED_DESCENDING;
 107 import static com.automattic.simplenote.utils.PrefUtils.DATE_MODIFIED_ASCENDING;
 108 import static com.automattic.simplenote.utils.PrefUtils.DATE_MODIFIED_DESCENDING;
 109 
 110 /**
 111  * A list fragment representing a list of Notes. This fragment also supports
 112  * tablet devices by allowing list items to be given an &#x27;activated&#x27; state upon
 113  * selection. This helps indicate which item is currently being viewed in a
 114  * {@link NoteEditorFragment}.
 115  * &lt;p&gt;
 116  * Activities containing this fragment MUST implement the {@link Callbacks}
 117  * interface.
 118  */
<abbr title=" 119 public class NoteListFragment extends ListFragment implements AdapterView.OnItemLongClickListener, AbsListView.MultiChoiceModeListener, Bucket.Listener&lt;Preferences&gt; {"> 119 public class NoteListFragment extends ListFragment implements AdapterView.OnItemLongClickListener, AbsLisðŸ”µ</abbr>
 120     public static final String TAG_PREFIX = &quot;tag:&quot;;
 121 
 122     /**
 123      * The preferences key representing the activated item position. Only used on tablets.
 124      */
 125     private static final String STATE_ACTIVATED_POSITION = &quot;activated_position&quot;;
 126     private static final int POPUP_MENU_FIRST_ITEM_POSITION = 0;
 127     public static final String ACTION_NEW_NOTE = &quot;com.automattic.simplenote.NEW_NOTE&quot;;
 128     /**
 129      * A dummy implementation of the {@link Callbacks} interface that does
 130      * nothing. Used only when this fragment is not attached to an activity.
 131      */
 132     private static Callbacks sCallbacks = new Callbacks() {
 133         @Override
 134         public void onActionModeCreated() {
 135         }
 136 
 137         @Override
 138         public void onActionModeDestroyed() {
 139         }
 140 
 141         @Override
<abbr title=" 142         public void onNoteSelected(String noteID, String matchOffsets, boolean isMarkdownEnabled, boolean isPreviewEnabled) {"> 142         public void onNoteSelected(String noteID, String matchOffsets, boolean isMarkdownEnabled, booleanðŸ”µ</abbr>
 143         }
 144     };
 145     protected NotesCursorAdapter mNotesAdapter;
 146     protected String mSearchString;
 147     private Bucket&lt;Preferences&gt; mBucketPreferences;
 148     private Bucket&lt;Tag&gt; mBucketTag;
 149     private ActionMode mActionMode;
 150     private View mRootView;
 151     private ImageView mEmptyViewImage;
 152     private TextView mEmptyViewText;
 153     private View mDividerLine;
 154     private FloatingActionButton mFloatingActionButton;
 155     private boolean mIsCondensedNoteList;
 156     private boolean mIsSearching;
 157     private ImageView mSortDirection;
 158     private ListView mList;
 159     private ObjectAnimator mSortDirectionAnimation;
 160     private RecyclerView mSuggestionList;
 161     private RelativeLayout mSortLayoutContent;
 162     private RelativeLayout mSuggestionLayout;
 163     private SharedPreferences mPreferences;
 164     private String mSelectedNoteId;
 165     private SuggestionAdapter mSuggestionAdapter;
 166     private TextView mSortOrder;
 167     private RefreshListTask mRefreshListTask;
 168     private RefreshListForSearchTask mRefreshListForSearchTask;
 169     private int mDeletedItemIndex;
 170     private int mPreferenceSortOrder;
 171     private int mTitleFontSize;
 172     private int mPreviewFontSize;
 173     private boolean mIsSortDown;
 174     private boolean mIsSortReverse;
 175     /**
 176      * The fragment&#x27;s current callback object, which is notified of list item
 177      * clicks.
 178      */
 179     private Callbacks mCallbacks = sCallbacks;
 180     /**
 181      * The current activated item position. Only used on tablets.
 182      */
 183     private int mActivatedPosition = ListView.INVALID_POSITION;
 184 
 185     /**
 186      * Mandatory empty constructor for the fragment manager to instantiate the
 187      * fragment (e.g. upon screen orientation changes).
 188      */
 189     public NoteListFragment() {
 190     }
 191 
 192     @Override
 193     public boolean onItemLongClick(AdapterView&lt;?&gt; adapterView, View view, int position, long l) {
 194         getListView().setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);
 195         getListView().setItemChecked(position, true);
 196 
 197         if (mActionMode == null) {
 198             requireActivity().startActionMode(this);
 199         }
 200 
 201         return true;
 202     }
 203 
 204     @Override
 205     public boolean onCreateActionMode(ActionMode actionMode, Menu menu) {
 206         mCallbacks.onActionModeCreated();
 207         MenuInflater inflater = actionMode.getMenuInflater();
 208         inflater.inflate(R.menu.bulk_edit, menu);
 209         DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.actionModeTextColor);
 210         mActionMode = actionMode;
<abbr title=" 211         int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.background_dark;"> 211         int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.bðŸ”µ</abbr>
<abbr title=" 212         requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().getTheme()));"> 212         requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActiviðŸ”µ</abbr>
 213         return true;
 214     }
 215 
 216     @Override
 217     public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 218         return false;
 219     }
 220 
 221     @Override
 222     public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 223         if (getListView().getCheckedItemIds().length &gt; 0) {
 224             switch (item.getItemId()) {
 225                 case R.id.menu_link:
 226                     BrowserUtils.copyToClipboard(requireContext(), getSelectedNoteLinks());
 227                     mode.finish();
 228                     break;
 229                 case R.id.menu_trash:
 230                     new TrashNotesTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 231                     break;
 232                 case R.id.menu_pin:
 233                     new PinNotesTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 234                     break;
 235             }
 236         }
 237 
 238         return false;
 239     }
 240 
 241     private String getSelectedNoteLinks() {
 242         SparseBooleanArray checkedPositions = getListView().getCheckedItemPositions();
 243         StringBuilder links = new StringBuilder();
 244 
 245         for (int i = 0; i &lt; checkedPositions.size(); i++) {
 246             if (checkedPositions.valueAt(i)) {
 247                 Note note = mNotesAdapter.getItem(checkedPositions.keyAt(i));
<abbr title=" 248                 links.append(SimplenoteLinkify.getNoteLinkWithTitle(note.getTitle(), note.getSimperiumKey())).append(&quot;\n&quot;);"> 248                 links.append(SimplenoteLinkify.getNoteLinkWithTitle(note.getTitle(), note.getSimperiumKeyðŸ”µ</abbr>
 249             }
 250         }
 251 
 252         return links.toString();
 253     }
 254 
 255     @Override
 256     public void onDestroyActionMode(ActionMode mode) {
 257         mCallbacks.onActionModeDestroyed();
 258         mActionMode = null;
 259         new Handler().postDelayed(
 260             new Runnable() {
 261                 @Override
 262                 public void run() {
 263                     if (getActivity() != null) {
 264                         NotesActivity notesActivity = (NotesActivity) getActivity();
 265                         setActivateOnItemClick(DisplayUtils.isLargeScreenLandscape(notesActivity));
 266                         notesActivity.showDetailPlaceholder();
 267                     }
 268 
<abbr title=" 269                     requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 269                     requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.colðŸ”µ</abbr>
 270                 }
 271             },
 272             requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime)
 273         );
 274     }
 275 
 276     @Override
<abbr title=" 277     public void onItemCheckedStateChanged(ActionMode actionMode, int position, long id, boolean checked) {"> 277     public void onItemCheckedStateChanged(ActionMode actionMode, int position, long id, boolean checked) ðŸ”µ</abbr>
 278         int checkedCount = getListView().getCheckedItemCount();
 279 
 280         if (checkedCount == 0) {
 281             actionMode.setTitle(&quot;&quot;);
 282         } else {
<abbr title=" 283             actionMode.setTitle(getResources().getQuantityString(R.plurals.selected_notes, checkedCount, checkedCount));"> 283             actionMode.setTitle(getResources().getQuantityString(R.plurals.selected_notes, checkedCount, ðŸ”µ</abbr>
 284         }
 285 
 286         actionMode.invalidate();
 287     }
 288 
 289     @Override
 290     public void onCreate(Bundle savedInstanceState) {
 291         super.onCreate(savedInstanceState);
 292         AppLog.add(Type.NETWORK, NetworkUtils.getNetworkInfo(requireContext()));
 293         AppLog.add(Type.SCREEN, &quot;Created (NoteListFragment)&quot;);
 294         mBucketPreferences = ((Simplenote) requireActivity().getApplication()).getPreferencesBucket();
 295         mBucketTag = ((Simplenote) requireActivity().getApplication()).getTagsBucket();
 296     }
 297 
 298     protected void getPrefs() {
 299         mPreferenceSortOrder = PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER);
<abbr title=" 300         mIsCondensedNoteList = PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_CONDENSED_LIST, false);"> 300         mIsCondensedNoteList = PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_CONDENSED_LIST, false)ðŸ”µ</abbr>
 301         mTitleFontSize = PrefUtils.getFontSize(getActivity());
 302         mPreviewFontSize = mTitleFontSize - 2;
 303     }
 304 
 305     @Override
<abbr title=" 306     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {"> 306     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceSðŸ”µ</abbr>
 307         return inflater.inflate(R.layout.fragment_notes_list, container, false);
 308     }
 309 
 310     @Override
 311     public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
 312         super.onViewCreated(view, savedInstanceState);
 313 
 314         NotesActivity notesActivity = (NotesActivity) requireActivity();
 315 
 316         if (ACTION_NEW_NOTE.equals(notesActivity.getIntent().getAction()) &amp;&amp;
 317                 !notesActivity.userIsUnauthorized()){
 318             //if user tap on &quot;app shortcut&quot;, create a new note
 319             createNewNote(&quot;new_note_shortcut&quot;);
 320         }
 321 
 322         mPreferences = PreferenceManager.getDefaultSharedPreferences(requireContext());
 323         mRootView = view.findViewById(R.id.list_root);
 324 
 325         LinearLayout emptyView = view.findViewById(android.R.id.empty);
 326         emptyView.setVisibility(View.GONE);
 327         mEmptyViewImage = emptyView.findViewById(R.id.image);
 328         mEmptyViewText = emptyView.findViewById(R.id.text);
 329         setEmptyListImage(R.drawable.ic_notes_24dp);
 330         setEmptyListMessage(getString(R.string.empty_notes_all));
 331         mDividerLine = view.findViewById(R.id.divider_line);
 332 
 333         if (DisplayUtils.isLargeScreenLandscape(notesActivity)) {
 334             setActivateOnItemClick(true);
 335             mDividerLine.setVisibility(View.VISIBLE);
 336         }
 337 
 338         mFloatingActionButton = view.findViewById(R.id.fab_button);
 339         mFloatingActionButton.setOnClickListener(new View.OnClickListener() {
 340             @Override
 341             public void onClick(View v) {
 342                 createNewNote(&quot;action_bar_button&quot;);
 343             }
 344         });
 345         mFloatingActionButton.setOnLongClickListener(new View.OnLongClickListener() {
 346             @Override
 347             public boolean onLongClick(View v) {
 348                 if (v.isHapticFeedbackEnabled()) {
 349                     v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
 350                 }
 351 
<abbr title=" 352                 Toast.makeText(getContext(), requireContext().getString(R.string.new_note), Toast.LENGTH_SHORT).show();"> 352                 Toast.makeText(getContext(), requireContext().getString(R.string.new_note), Toast.LENGTH_ðŸ”µ</abbr>
 353                 return true;
 354             }
 355         });
 356 
 357         mSuggestionLayout = view.findViewById(R.id.suggestion_layout);
 358         mSuggestionList = view.findViewById(R.id.suggestion_list);
 359         mSuggestionAdapter = new SuggestionAdapter(new ArrayList&lt;Suggestion&gt;());
 360         mSuggestionList.setAdapter(mSuggestionAdapter);
 361         mSuggestionList.setLayoutManager(new LinearLayoutManager(requireContext()));
 362         @SuppressLint(&quot;InflateParams&quot;)
<abbr title=" 363         LinearLayout sortLayoutContainer = (LinearLayout) getLayoutInflater().inflate(R.layout.search_sort, null, false);"> 363         LinearLayout sortLayoutContainer = (LinearLayout) getLayoutInflater().inflate(R.layout.search_sorðŸ”µ</abbr>
 364         mSortLayoutContent = sortLayoutContainer.findViewById(R.id.sort_content);
 365         mSortLayoutContent.setVisibility(mIsSearching ? View.VISIBLE : View.GONE);
 366         mSortOrder = sortLayoutContainer.findViewById(R.id.sort_order);
 367         mSortLayoutContent.setOnClickListener(new View.OnClickListener() {
 368             @Override
 369             public void onClick(View v) {
 370                 PopupMenu popup = new PopupMenu(mSortOrder.getContext(), mSortOrder, Gravity.START);
 371                 MenuInflater inflater = popup.getMenuInflater();
 372                 inflater.inflate(R.menu.search_sort, popup.getMenu());
 373                 popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {
 374                     @Override
 375                     public boolean onMenuItemClick(MenuItem item) {
 376                         // Do nothing when same sort is selected.
 377                         if (mSortOrder.getText().equals(item.getTitle())) {
 378                             return false;
 379                         }
 380 
 381                         mSortOrder.setText(item.getTitle());
 382 
 383                         switch (item.getItemId()) {
 384                             case R.id.search_alphabetically:
 385                                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER,
 386                                     String.valueOf(ALPHABETICAL_ASCENDING)
 387                                 ).apply();
 388 
 389                                 // If arrow is down, rotate it up for ascending direction.
 390                                 if (mIsSortDown &amp;&amp; !mIsSortReverse) {
 391                                     mSortDirectionAnimation.start();
 392                                     mIsSortReverse = true;
 393                                 } else if (!mIsSortDown &amp;&amp; mIsSortReverse) {
 394                                     mSortDirectionAnimation.reverse();
 395                                     mIsSortReverse = false;
 396                                 }
 397 
 398                                 refreshListForSearch();
 399                                 return true;
 400                             case R.id.search_created:
 401                                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER,
 402                                     String.valueOf(DATE_CREATED_DESCENDING)
 403                                 ).apply();
 404 
 405                                 // If arrow is up, rotate it down for descending direction.
 406                                 if (mIsSortDown &amp;&amp; mIsSortReverse) {
 407                                     mSortDirectionAnimation.reverse();
 408                                     mIsSortReverse = false;
 409                                 } else if (!mIsSortDown &amp;&amp; !mIsSortReverse) {
 410                                     mSortDirectionAnimation.start();
 411                                     mIsSortReverse = true;
 412                                 }
 413 
 414                                 refreshListForSearch();
 415                                 return true;
 416                             case R.id.search_modified:
 417                                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER,
 418                                     String.valueOf(DATE_MODIFIED_DESCENDING)
 419                                 ).apply();
 420 
 421                                 // If arrow is up, rotate it down for descending direction.
 422                                 if (mIsSortDown &amp;&amp; mIsSortReverse) {
 423                                     mSortDirectionAnimation.reverse();
 424                                     mIsSortReverse = false;
 425                                 } else if (!mIsSortDown &amp;&amp; !mIsSortReverse) {
 426                                     mSortDirectionAnimation.start();
 427                                     mIsSortReverse = true;
 428                                 }
 429 
 430                                 refreshListForSearch();
 431                                 return true;
 432                             default:
 433                                 return false;
 434                         }
 435                     }
 436                 });
 437                 popup.show();
 438             }
 439         });
 440         mList = view.findViewById(android.R.id.list);
 441         mList.addHeaderView(sortLayoutContainer);
 442 
 443         mNotesAdapter = new NotesCursorAdapter(requireActivity().getBaseContext(), null, 0);
 444         setListAdapter(mNotesAdapter);
 445 
 446         getListView().setOnItemLongClickListener(this);
 447         getListView().setMultiChoiceModeListener(this);
 448 
 449         mSortDirection = sortLayoutContainer.findViewById(R.id.sort_direction);
 450         ImageView sortDirectionSwitch = sortLayoutContainer.findViewById(R.id.sort_direction_switch);
 451         sortDirectionSwitch.setImageResource(R.drawable.ic_sort_order_24dp);
 452         sortDirectionSwitch.setOnClickListener(new View.OnClickListener() {
 453             @Override
 454             public void onClick(View v) {
 455                 if (mIsSortReverse) {
 456                     mSortDirectionAnimation.reverse();
 457                 } else {
 458                     mSortDirectionAnimation.start();
 459                 }
 460 
 461                 mIsSortReverse = !mIsSortReverse;
 462                 switchSortDirection();
 463                 refreshListForSearch();
 464             }
 465         });
 466         sortDirectionSwitch.setOnLongClickListener(new View.OnLongClickListener() {
 467             @Override
 468             public boolean onLongClick(View v) {
 469                 if (v.isHapticFeedbackEnabled()) {
 470                     v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
 471                 }
 472 
<abbr title=" 473                 Toast.makeText(requireContext(), requireContext().getString(R.string.sort_search_reverse_order), Toast.LENGTH_SHORT).show();"> 473                 Toast.makeText(requireContext(), requireContext().getString(R.string.sort_search_reverse_ðŸ”µ</abbr>
 474                 return true;
 475             }
 476         });
 477     }
 478 
 479     public void showListPadding(boolean show) {
 480         mList.setPadding(
 481             mList.getPaddingLeft(),
 482             mList.getPaddingTop(),
 483             mList.getPaddingRight(),
 484             show ? (int) getResources().getDimension(R.dimen.note_list_item_padding_bottom_button) : 0
 485         );
 486     }
 487 
 488     private @StringRes int getSortOrderText() {
 489         switch (PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER)) {
 490             case ALPHABETICAL_ASCENDING:
 491             case ALPHABETICAL_DESCENDING:
 492                 return R.string.sort_search_alphabetically;
 493             case DATE_CREATED_ASCENDING:
 494             case DATE_CREATED_DESCENDING:
 495                 return R.string.sort_search_created;
 496             case DATE_MODIFIED_ASCENDING:
 497             case DATE_MODIFIED_DESCENDING:
 498             default:
 499                 return R.string.sort_search_modified;
 500         }
 501     }
 502 
 503     private void setSortDirection() {
 504         if (mIsSortReverse) {
 505             mSortDirectionAnimation.reverse();
 506             mIsSortReverse = false;
 507         }
 508 
 509         switch (PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER)) {
 510             case ALPHABETICAL_ASCENDING:
 511             case DATE_CREATED_ASCENDING:
 512             case DATE_MODIFIED_ASCENDING:
 513                 mSortDirection.setContentDescription(getString(R.string.description_up));
 514                 mSortDirection.setImageResource(R.drawable.ic_arrow_up_16dp);
 515                 mIsSortDown = false;
 516                 break;
 517             case ALPHABETICAL_DESCENDING:
 518             case DATE_CREATED_DESCENDING:
 519             case DATE_MODIFIED_DESCENDING:
 520             default:
 521                 mSortDirection.setContentDescription(getString(R.string.description_down));
 522                 mSortDirection.setImageResource(R.drawable.ic_arrow_down_16dp);
 523                 mIsSortDown = true;
 524                 break;
 525         }
 526 
 527         mSortDirectionAnimation = ObjectAnimator.ofFloat(
 528             mSortDirection,
 529             View.ROTATION,
 530             0f,
 531             mIsSortDown ? -180f : 180f
 532         ).setDuration(getResources().getInteger(android.R.integer.config_shortAnimTime));
 533     }
 534 
 535     private void switchSortDirection() {
 536         switch (PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER)) {
 537             case DATE_MODIFIED_DESCENDING:
<abbr title=" 538                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_MODIFIED_ASCENDING)).apply();"> 538                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_MODIFIED_ASCðŸ”µ</abbr>
 539                 break;
 540             case DATE_MODIFIED_ASCENDING:
<abbr title=" 541                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_MODIFIED_DESCENDING)).apply();"> 541                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_MODIFIED_DESðŸ”µ</abbr>
 542                 break;
 543             case DATE_CREATED_DESCENDING:
<abbr title=" 544                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_CREATED_ASCENDING)).apply();"> 544                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_CREATED_ASCEðŸ”µ</abbr>
 545                 break;
 546             case DATE_CREATED_ASCENDING:
<abbr title=" 547                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_CREATED_DESCENDING)).apply();"> 547                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_CREATED_DESCðŸ”µ</abbr>
 548                 break;
 549             case ALPHABETICAL_ASCENDING:
<abbr title=" 550                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(ALPHABETICAL_DESCENDING)).apply();"> 550                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(ALPHABETICAL_DESCðŸ”µ</abbr>
 551                 break;
 552             case ALPHABETICAL_DESCENDING:
<abbr title=" 553                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(ALPHABETICAL_ASCENDING)).apply();"> 553                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(ALPHABETICAL_ASCEðŸ”µ</abbr>
 554                 break;
 555         }
 556     }
 557 
 558     public void createNewNote(String label){
 559         if (!isAdded()) return;
 560 
 561         addNote();
 562         AnalyticsTracker.track(
 563                 AnalyticsTracker.Stat.LIST_NOTE_CREATED,
 564                 AnalyticsTracker.CATEGORY_NOTE,
 565                 label
 566         );
 567     }
 568 
 569     @Override
 570     public void onAttach(@NonNull Context activity) {
 571         super.onAttach(activity);
 572 
 573         // Activities containing this fragment must implement its callbacks.
 574         if (!(activity instanceof Callbacks)) {
 575             throw new IllegalStateException(&quot;Activity must implement fragment&#x27;s callbacks.&quot;);
 576         }
 577 
 578         mCallbacks = (Callbacks) activity;
 579     }
 580 
 581     @Override
 582     public void onResume() {
 583         super.onResume();
 584         getPrefs();
 585 
 586         if (mIsSearching) {
 587             refreshListForSearch();
 588         } else {
 589             refreshList();
 590         }
 591 
 592         mBucketPreferences.start();
 593         mBucketPreferences.addOnDeleteObjectListener(this);
 594         mBucketPreferences.addOnNetworkChangeListener(this);
 595         mBucketPreferences.addOnSaveObjectListener(this);
 596     }
 597 
 598     @Override
 599     public void onPause() {
 600         super.onPause();
 601         mBucketPreferences.removeOnDeleteObjectListener(this);
 602         mBucketPreferences.removeOnNetworkChangeListener(this);
 603         mBucketPreferences.removeOnSaveObjectListener(this);
 604         mBucketPreferences.stop();
 605         AppLog.add(Type.SCREEN, &quot;Paused (NoteListFragment)&quot;);
 606     }
 607 
 608     @Override
 609     public void onDetach() {
 610         super.onDetach();
 611         // Restore sort order from Settings.
<abbr title=" 612         mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(mPreferenceSortOrder)).apply();"> 612         mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(mPreferenceSortOrder)).apðŸ”µ</abbr>
 613         // Reset the active callbacks interface to the dummy implementation.
 614         mCallbacks = sCallbacks;
 615     }
 616 
 617     public void setEmptyListImage(@DrawableRes int image) {
 618         if (mEmptyViewImage != null) {
 619             if (image != -1) {
 620                 mEmptyViewImage.setVisibility(View.VISIBLE);
 621                 mEmptyViewImage.setImageResource(image);
 622             } else {
 623                 mEmptyViewImage.setVisibility(View.GONE);
 624             }
 625         }
 626     }
 627 
 628     public void setEmptyListMessage(String message) {
 629         if (mEmptyViewText != null &amp;&amp; message != null) {
 630             mEmptyViewText.setText(message);
 631         }
 632     }
 633 
 634     @Override
 635     public void onListItemClick(@NonNull ListView listView, @NonNull View view, int position, long id) {
 636         if (!isAdded()) return;
 637         super.onListItemClick(listView, view, position, id);
 638 
 639         NoteViewHolder holder = (NoteViewHolder) view.getTag();
 640         String noteID = holder.getNoteId();
 641 
 642         if (noteID != null) {
 643             Note note = mNotesAdapter.getItem(position);
<abbr title=" 644             mCallbacks.onNoteSelected(noteID, holder.mMatchOffsets, note.isMarkdownEnabled(), note.isPreviewEnabled());"> 644             mCallbacks.onNoteSelected(noteID, holder.mMatchOffsets, note.isMarkdownEnabled(), note.isPrevðŸ”µ</abbr>
 645         }
 646 
 647         mActivatedPosition = position;
 648     }
 649 
 650     /**
 651      * Selects first row in the list if available
 652      */
 653     public void selectFirstNote() {
 654         if (mNotesAdapter.getCount() &gt; 0) {
 655             Note selectedNote = mNotesAdapter.getItem(mList.getHeaderViewsCount());
<abbr title=" 656             mCallbacks.onNoteSelected(selectedNote.getSimperiumKey(), null, selectedNote.isMarkdownEnabled(), selectedNote.isPreviewEnabled());"> 656             mCallbacks.onNoteSelected(selectedNote.getSimperiumKey(), null, selectedNote.isMarkdownEnableðŸ”µ</abbr>
 657         }
 658     }
 659 
 660     @Override
 661     public void onSaveInstanceState(@NonNull Bundle outState) {
 662         super.onSaveInstanceState(outState);
 663         if (mActivatedPosition != ListView.INVALID_POSITION) {
 664             // Serialize and persist the activated item position.
 665             outState.putInt(STATE_ACTIVATED_POSITION, mActivatedPosition);
 666         }
 667     }
 668 
 669     public View getRootView() {
 670         return mRootView;
 671     }
 672 
 673     /**
 674      * Turns on activate-on-click mode. When this mode is on, list items will be
 675      * given the &#x27;activated&#x27; state when touched.
 676      */
 677     public void setActivateOnItemClick(boolean activateOnItemClick) {
 678         // When setting CHOICE_MODE_SINGLE, ListView will automatically
 679         // give items the &#x27;activated&#x27; state when touched.
<abbr title=" 680         getListView().setChoiceMode(activateOnItemClick ? ListView.CHOICE_MODE_SINGLE : ListView.CHOICE_MODE_NONE);"> 680         getListView().setChoiceMode(activateOnItemClick ? ListView.CHOICE_MODE_SINGLE : ListView.CHOICE_MðŸ”µ</abbr>
 681     }
 682 
 683     public void setActivatedPosition(int position) {
 684         if (getListView() != null) {
 685             if (position == ListView.INVALID_POSITION) {
 686                 getListView().setItemChecked(mActivatedPosition, false);
 687             } else {
 688                 getListView().setItemChecked(position, true);
 689             }
 690 
 691             mActivatedPosition = position;
 692         }
 693     }
 694 
 695     public void setDividerVisible(boolean visible) {
 696         mDividerLine.setVisibility(visible ? View.VISIBLE : View.GONE);
 697     }
 698 
 699     public void setFloatingActionButtonVisible(boolean visible) {
 700         if (mFloatingActionButton == null) return;
 701 
 702         if (visible) {
 703             mFloatingActionButton.show();
 704         } else {
 705             mFloatingActionButton.hide();
 706         }
 707     }
 708 
 709     public void refreshList() {
 710         mSortOrder.setText(getSortOrderText());
 711         setSortDirection();
 712         refreshList(false);
 713     }
 714 
 715     public void refreshList(boolean fromNav) {
 716         if (mRefreshListTask != null &amp;&amp; mRefreshListTask.getStatus() != AsyncTask.Status.FINISHED)
 717             mRefreshListTask.cancel(true);
 718 
 719         mRefreshListTask = new RefreshListTask(this);
 720         mRefreshListTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, fromNav);
 721 
 722         WidgetUtils.updateNoteWidgets(requireActivity().getApplicationContext());
 723     }
 724 
 725     private void refreshListForSearch() {
<abbr title=" 726         if (mRefreshListForSearchTask != null &amp;&amp; mRefreshListForSearchTask.getStatus() != AsyncTask.Status.FINISHED) {"> 726         if (mRefreshListForSearchTask != null &amp;&amp; mRefreshListForSearchTask.getStatus() != AsyncTask.StatuðŸ”µ</abbr>
 727             mRefreshListForSearchTask.cancel(true);
 728         }
 729 
 730         mRefreshListForSearchTask = new RefreshListForSearchTask(this);
 731         mRefreshListForSearchTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 732     }
 733 
 734     public void refreshListFromNavSelect() {
 735         refreshList(true);
 736     }
 737 
 738     public ObjectCursor&lt;Note&gt; queryNotes() {
 739         if (!isAdded()) return null;
 740 
 741         NotesActivity notesActivity = (NotesActivity) requireActivity();
 742         Query&lt;Note&gt; query = notesActivity.getSelectedTag().query();
 743 
 744         String searchString = mSearchString;
 745         if (hasSearchQuery()) {
 746             searchString = queryTags(query, mSearchString);
 747         }
 748         if (!TextUtils.isEmpty(searchString)) {
 749             query.where(new Query.FullTextMatch(new SearchTokenizer(searchString)));
 750             query.include(new Query.FullTextOffsets(&quot;match_offsets&quot;));
<abbr title=" 751             query.include(new Query.FullTextSnippet(Note.MATCHED_TITLE_INDEX_NAME, Note.TITLE_INDEX_NAME));"> 751             query.include(new Query.FullTextSnippet(Note.MATCHED_TITLE_INDEX_NAME, Note.TITLE_INDEX_NAME)ðŸ”µ</abbr>
<abbr title=" 752             query.include(new Query.FullTextSnippet(Note.MATCHED_CONTENT_INDEX_NAME, Note.CONTENT_PROPERTY));"> 752             query.include(new Query.FullTextSnippet(Note.MATCHED_CONTENT_INDEX_NAME, Note.CONTENT_PROPERTðŸ”µ</abbr>
 753             query.include(Note.TITLE_INDEX_NAME, Note.CONTENT_PREVIEW_INDEX_NAME);
 754         } else {
 755             query.include(Note.TITLE_INDEX_NAME, Note.CONTENT_PREVIEW_INDEX_NAME);
 756         }
 757 
 758         query.include(Note.PINNED_INDEX_NAME);
 759         PrefUtils.sortNoteQuery(query, requireContext(), true);
 760         return query.execute();
 761     }
 762 
 763     private ObjectCursor&lt;Note&gt; queryNotesForSearch() {
 764         if (!isAdded()) {
 765             return null;
 766         }
 767 
 768         Query&lt;Note&gt; query = Note.all(((Simplenote) requireActivity().getApplication()).getNotesBucket());
 769         String searchString = mSearchString;
 770 
 771         if (hasSearchQuery()) {
 772             searchString = queryTags(query, mSearchString);
 773         }
 774 
 775         if (!TextUtils.isEmpty(searchString)) {
 776             query.where(new Query.FullTextMatch(new SearchTokenizer(searchString)));
 777             query.include(new Query.FullTextOffsets(&quot;match_offsets&quot;));
<abbr title=" 778             query.include(new Query.FullTextSnippet(Note.MATCHED_TITLE_INDEX_NAME, Note.TITLE_INDEX_NAME));"> 778             query.include(new Query.FullTextSnippet(Note.MATCHED_TITLE_INDEX_NAME, Note.TITLE_INDEX_NAME)ðŸ”µ</abbr>
<abbr title=" 779             query.include(new Query.FullTextSnippet(Note.MATCHED_CONTENT_INDEX_NAME, Note.CONTENT_PROPERTY));"> 779             query.include(new Query.FullTextSnippet(Note.MATCHED_CONTENT_INDEX_NAME, Note.CONTENT_PROPERTðŸ”µ</abbr>
 780             query.include(Note.TITLE_INDEX_NAME, Note.CONTENT_PREVIEW_INDEX_NAME);
 781         } else {
 782             query.include(Note.TITLE_INDEX_NAME, Note.CONTENT_PREVIEW_INDEX_NAME);
 783         }
 784 
 785         PrefUtils.sortNoteQuery(query, requireContext(), false);
 786         return query.execute();
 787     }
 788 
 789     private String queryTags(Query&lt;Note&gt; query, String searchString) {
 790         Pattern pattern = Pattern.compile(TAG_PREFIX + &quot;(.*?)( |$)&quot;);
 791         Matcher matcher = pattern.matcher(searchString);
 792         while (matcher.find()) {
 793             query.where(TAGS_PROPERTY, Query.ComparisonType.LIKE, matcher.group(1));
 794         }
 795         return matcher.replaceAll(&quot;&quot;);
 796     }
 797 
 798     public void addNote() {
 799 
 800         // Prevents jarring &#x27;New note...&#x27; from showing in the list view when creating a new note
 801         NotesActivity notesActivity = (NotesActivity) requireActivity();
 802         if (!DisplayUtils.isLargeScreenLandscape(notesActivity))
 803             notesActivity.stopListeningToNotesBucket();
 804 
 805         // Create &amp; save new note
 806         Simplenote simplenote = (Simplenote) requireActivity().getApplication();
 807         Bucket&lt;Note&gt; notesBucket = simplenote.getNotesBucket();
 808         final Note note = notesBucket.newObject();
 809         note.setCreationDate(Calendar.getInstance());
 810         note.setModificationDate(note.getCreationDate());
<abbr title=" 811         note.setMarkdownEnabled(PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_MARKDOWN_ENABLED, false));"> 811         note.setMarkdownEnabled(PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_MARKDOWN_ENABLED, falðŸ”µ</abbr>
 812 
 813         if (notesActivity.getSelectedTag() != null &amp;&amp; notesActivity.getSelectedTag().name != null) {
 814             String tagName = notesActivity.getSelectedTag().name;
<abbr title=" 815             if (!tagName.equals(getString(R.string.all_notes)) &amp;&amp; !tagName.equals(getString(R.string.trash)) &amp;&amp; !tagName.equals(getString(R.string.untagged_notes)))"> 815             if (!tagName.equals(getString(R.string.all_notes)) &amp;&amp; !tagName.equals(getString(R.string.trasðŸ”µ</abbr>
 816                 note.setTagString(tagName);
 817         }
 818 
 819         note.save();
 820 
 821         if (DisplayUtils.isLargeScreenLandscape(getActivity())) {
 822             // Hack: Simperium saves async so we add a small delay to ensure the new note is truly
 823             // saved before proceeding.
 824             new Handler().postDelayed(new Runnable() {
 825                 @Override
 826                 public void run() {
<abbr title=" 827                     mCallbacks.onNoteSelected(note.getSimperiumKey(), null, note.isMarkdownEnabled(), note.isPreviewEnabled());"> 827                     mCallbacks.onNoteSelected(note.getSimperiumKey(), null, note.isMarkdownEnabled(), notðŸ”µ</abbr>
 828                 }
 829             }, 50);
 830         } else {
 831             Bundle arguments = new Bundle();
 832             arguments.putString(NoteEditorFragment.ARG_ITEM_ID, note.getSimperiumKey());
 833             arguments.putBoolean(NoteEditorFragment.ARG_NEW_NOTE, true);
 834             arguments.putBoolean(NoteEditorFragment.ARG_MARKDOWN_ENABLED, note.isMarkdownEnabled());
 835             arguments.putBoolean(NoteEditorFragment.ARG_PREVIEW_ENABLED, note.isPreviewEnabled());
 836             Intent editNoteIntent = new Intent(getActivity(), NoteEditorActivity.class);
 837             editNoteIntent.putExtras(arguments);
 838 
 839             requireActivity().startActivityForResult(editNoteIntent, Simplenote.INTENT_EDIT_NOTE);
 840         }
 841     }
 842 
 843     public void setNoteSelected(String selectedNoteID) {
 844         // Loop through notes and set note selected if found
 845         //noinspection unchecked
 846         ObjectCursor&lt;Note&gt; cursor = (ObjectCursor&lt;Note&gt;) mNotesAdapter.getCursor();
 847         if (cursor != null) {
 848             for (int i = 0; i &lt; cursor.getCount(); i++) {
 849                 cursor.moveToPosition(i);
 850                 String noteKey = cursor.getSimperiumKey();
 851                 if (noteKey != null &amp;&amp; noteKey.equals(selectedNoteID)) {
 852                     setActivatedPosition(i + mList.getHeaderViewsCount());
 853                     return;
 854                 }
 855             }
 856         }
 857 
 858         // Didn&#x27;t find the note, let&#x27;s try again after the cursor updates (see RefreshListTask)
 859         mSelectedNoteId = selectedNoteID;
 860     }
 861 
 862     public void searchNotes(String searchString, boolean isSubmit) {
 863         mIsSearching = true;
 864         mSortLayoutContent.setVisibility(View.VISIBLE);
 865         mSuggestionLayout.setVisibility(View.VISIBLE);
 866         mSortOrder.setText(getSortOrderText());
 867 
 868         if (!searchString.equals(mSearchString)) {
 869             mSearchString = searchString;
 870         }
 871 
 872         if (searchString.isEmpty()) {
 873             getSearchItems();
 874         } else {
 875             getTagSuggestions(searchString);
 876         }
 877 
 878         if (isSubmit) {
 879             mSuggestionLayout.setVisibility(View.GONE);
 880             refreshListForSearch();
 881         }
 882     }
 883 
 884     /**
 885      * Clear search and load all notes
 886      */
 887     public void clearSearch() {
 888         mIsSearching = false;
 889         mSortLayoutContent.setVisibility(View.GONE);
 890         mSuggestionLayout.setVisibility(View.GONE);
 891         // Restore sort order from Settings.
<abbr title=" 892         mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(mPreferenceSortOrder)).apply();"> 892         mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(mPreferenceSortOrder)).apðŸ”µ</abbr>
 893         refreshList();
 894 
 895         if (mSearchString != null &amp;&amp; !mSearchString.equals(&quot;&quot;)) {
 896             mSearchString = null;
 897             refreshList();
 898         }
 899     }
 900 
 901     public boolean hasSearchQuery() {
 902         return mSearchString != null &amp;&amp; !mSearchString.equals(&quot;&quot;);
 903     }
 904 
 905     public void addSearchItem(String item, int index) {
 906         Preferences preferences = getPreferences();
 907 
 908         if (preferences != null) {
 909             List&lt;String&gt; recents = preferences.getRecentSearches();
 910             recents.remove(item);
 911             recents.add(index, item);
<abbr title=" 912             // Trim recent searches to MAX_RECENT_SEARCHES (currently 5) if size is greater than MAX_RECENT_SEARCHES."> 912             // Trim recent searches to MAX_RECENT_SEARCHES (currently 5) if size is greater than MAX_RECEðŸ”µ</abbr>
<abbr title=" 913             preferences.setRecentSearches(recents.subList(0, recents.size() &gt; MAX_RECENT_SEARCHES ? MAX_RECENT_SEARCHES : recents.size()));"> 913             preferences.setRecentSearches(recents.subList(0, recents.size() &gt; MAX_RECENT_SEARCHES ? MAX_RðŸ”µ</abbr>
 914             preferences.save();
 915         } else {
 916             Log.e(&quot;addSearchItem&quot;, &quot;Could not get preferences entity&quot;);
 917         }
 918     }
 919 
 920     private void deleteSearchItem(String item) {
 921         Preferences preferences = getPreferences();
 922 
 923         if (preferences != null) {
 924             List&lt;String&gt; recents = preferences.getRecentSearches();
 925             mDeletedItemIndex = recents.indexOf(item);
 926             recents.remove(item);
 927             preferences.setRecentSearches(recents);
 928             preferences.save();
 929         } else {
 930             Log.e(&quot;deleteSearchItem&quot;, &quot;Could not get preferences entity&quot;);
 931         }
 932     }
 933 
 934     private Preferences getPreferences() {
 935         try {
 936             return mBucketPreferences.get(PREFERENCES_OBJECT_KEY);
 937         } catch (BucketObjectMissingException exception) {
 938             try {
 939                 Preferences preferences = mBucketPreferences.newObject(PREFERENCES_OBJECT_KEY);
 940                 preferences.save();
 941                 return preferences;
 942             } catch (BucketObjectNameInvalid invalid) {
 943                 Log.e(&quot;getPreferences&quot;, &quot;Could not create preferences entity&quot;, invalid);
 944                 return null;
 945             }
 946         }
 947     }
 948 
 949     private void getSearchItems() {
 950         Preferences preferences = getPreferences();
 951 
 952         if (preferences != null) {
 953             ArrayList&lt;Suggestion&gt; suggestions = new ArrayList&lt;&gt;();
 954 
 955             for (String recent : preferences.getRecentSearches()) {
 956                 suggestions.add(new Suggestion(recent, HISTORY));
 957             }
 958 
 959             mSuggestionAdapter.updateItems(suggestions);
 960         } else {
 961             Log.e(&quot;getSearchItems&quot;, &quot;Could not get preferences entity&quot;);
 962         }
 963     }
 964 
 965     private void getTagSuggestions(String query) {
 966         ArrayList&lt;Suggestion&gt; suggestions = new ArrayList&lt;&gt;();
 967         suggestions.add(new Suggestion(query, QUERY));
<abbr title=" 968         Query&lt;Tag&gt; tags = Tag.all(mBucketTag).reorder().order(Tag.NOTE_COUNT_INDEX_NAME, Query.SortType.DESCENDING);"> 968         Query&lt;Tag&gt; tags = Tag.all(mBucketTag).reorder().order(Tag.NOTE_COUNT_INDEX_NAME, Query.SortType.DðŸ”µ</abbr>
 969 
 970         if (!query.endsWith(TAG_PREFIX)) {
 971             tags.where(NAME_PROPERTY, Query.ComparisonType.LIKE, &quot;%&quot; + query + &quot;%&quot;);
 972         }
 973 
 974         try (ObjectCursor&lt;Tag&gt; cursor = tags.execute()) {
 975             while (cursor.moveToNext()) {
 976                 suggestions.add(new Suggestion(cursor.getObject().getName(), TAG));
 977             }
 978         }
 979 
 980         mSuggestionAdapter = new SuggestionAdapter(suggestions);
 981         mSuggestionList.setAdapter(mSuggestionAdapter);
 982     }
 983 
 984     /**
 985      * A callback interface that all activities containing this fragment must
 986      * implement. This mechanism allows activities to be notified of item
 987      * selections.
 988      */
 989     public interface Callbacks {
 990         /**
 991          * Callback for when action mode is created.
 992          */
 993         void onActionModeCreated();
 994         /**
 995          * Callback for when action mode is destroyed.
 996          */
 997         void onActionModeDestroyed();
 998         /**
 999          * Callback for when a note has been selected.
1000          */
<abbr title="1001         void onNoteSelected(String noteID, String matchOffsets, boolean isMarkdownEnabled, boolean isPreviewEnabled);">1001         void onNoteSelected(String noteID, String matchOffsets, boolean isMarkdownEnabled, boolean isPrevðŸ”µ</abbr>
1002     }
1003 
1004     // view holder for NotesCursorAdapter
1005     private static class NoteViewHolder {
1006         private ImageView mPinned;
1007         private ImageView mPublished;
1008         private TextView mContent;
1009         private TextView mDate;
1010         private TextView mTitle;
1011         private String mMatchOffsets;
1012         private String mNoteId;
1013         private View mStatus;
1014 
1015         public String getNoteId() {
1016             return mNoteId;
1017         }
1018 
1019         public void setNoteId(String noteId) {
1020             mNoteId = noteId;
1021         }
1022     }
1023 
1024     public class NotesCursorAdapter extends CursorAdapter {
1025         private ObjectCursor&lt;Note&gt; mCursor;
1026 
<abbr title="1027         private SearchSnippetFormatter.SpanFactory mSnippetHighlighter = new TextHighlighter(requireActivity(),">1027         private SearchSnippetFormatter.SpanFactory mSnippetHighlighter = new TextHighlighter(requireActivðŸ”µ</abbr>
1028                 R.attr.listSearchHighlightForegroundColor, R.attr.listSearchHighlightBackgroundColor);
1029 
1030         public NotesCursorAdapter(Context context, ObjectCursor&lt;Note&gt; c, int flags) {
1031             super(context, c, flags);
1032             mCursor = c;
1033         }
1034 
1035         public void changeCursor(ObjectCursor&lt;Note&gt; cursor) {
1036             mCursor = cursor;
1037             super.changeCursor(cursor);
1038         }
1039 
1040         @Override
1041         public Note getItem(int position) {
1042             mCursor.moveToPosition(position - mList.getHeaderViewsCount());
1043             return mCursor.getObject();
1044         }
1045 
1046         /*
1047          *  nbradbury - implemented &quot;holder pattern&quot; to boost performance with large note lists
1048          */
1049         @Override
1050         public View getView(final int position, View view, ViewGroup parent) {
1051             final NoteViewHolder holder;
1052 
1053             if (view == null) {
1054                 view = View.inflate(requireActivity().getBaseContext(), R.layout.note_list_row, null);
1055                 holder = new NoteViewHolder();
1056                 holder.mTitle = view.findViewById(R.id.note_title);
1057                 holder.mContent = view.findViewById(R.id.note_content);
1058                 holder.mDate = view.findViewById(R.id.note_date);
1059                 holder.mPinned = view.findViewById(R.id.note_pinned);
1060                 holder.mPublished = view.findViewById(R.id.note_published);
1061                 holder.mStatus = view.findViewById(R.id.note_status);
1062                 view.setTag(holder);
1063             } else {
1064                 holder = (NoteViewHolder) view.getTag();
1065             }
1066 
1067             if (holder.mTitle.getTextSize() != mTitleFontSize) {
1068                 holder.mTitle.setTextSize(TypedValue.COMPLEX_UNIT_SP, mTitleFontSize);
1069                 holder.mContent.setTextSize(TypedValue.COMPLEX_UNIT_SP, mPreviewFontSize);
1070                 holder.mDate.setTextSize(TypedValue.COMPLEX_UNIT_SP, mPreviewFontSize);
1071             }
1072 
1073             if (position == getListView().getCheckedItemPosition())
1074                 view.setActivated(true);
1075             else
1076                 view.setActivated(false);
1077 
1078             // for performance reasons we are going to get indexed values
1079             // from the cursor instead of instantiating the entire bucket object
1080             holder.mContent.setVisibility(mIsCondensedNoteList ? View.GONE : View.VISIBLE);
1081             mCursor.moveToPosition(position);
1082             holder.setNoteId(mCursor.getSimperiumKey());
1083             Calendar date = getDateByPreference(mCursor.getObject());
1084             holder.mDate.setText(date != null ? DateTimeUtils.getDateTextNumeric(date) : &quot;&quot;);
1085             holder.mDate.setVisibility(mIsSearching &amp;&amp; date != null ? View.VISIBLE : View.GONE);
1086             boolean isPinned = mCursor.getObject().isPinned();
1087             holder.mPinned.setVisibility(!isPinned || mIsSearching ? View.GONE : View.VISIBLE);
1088             boolean isPublished = !mCursor.getObject().getPublishedUrl().isEmpty();
1089             holder.mPublished.setVisibility(!isPublished || mIsSearching ? View.GONE : View.VISIBLE);
1090             boolean showIcons = isPinned || isPublished;
1091             boolean showDate = mIsSearching &amp;&amp; date != null;
1092             holder.mStatus.setVisibility(showIcons || showDate ? View.VISIBLE : View.GONE);
1093             String title = mCursor.getString(mCursor.getColumnIndex(Note.TITLE_INDEX_NAME));
1094 
1095             if (TextUtils.isEmpty(title)) {
1096                 SpannableString newNoteString = new SpannableString(getString(R.string.new_note_list));
<abbr title="1097                 newNoteString.setSpan(new TextAppearanceSpan(getActivity(),R.style.UntitledNoteAppearance),">1097                 newNoteString.setSpan(new TextAppearanceSpan(getActivity(),R.style.UntitledNoteAppearanceðŸ”µ</abbr>
1098                         0,
1099                         newNoteString.length(),
1100                         SpannableString.SPAN_EXCLUSIVE_EXCLUSIVE
1101                 );
1102                 newNoteString.setSpan(new AbsoluteSizeSpan(mTitleFontSize, true),
1103                         0,
1104                         newNoteString.length(),
1105                         SpannableString.SPAN_EXCLUSIVE_EXCLUSIVE
1106                 );
1107                 holder.mTitle.setText(newNoteString);
1108             } else {
1109                 SpannableStringBuilder titleChecklistString = new SpannableStringBuilder(title);
<abbr title="1110                 titleChecklistString = (SpannableStringBuilder) ChecklistUtils.addChecklistSpansForRegexAndColor(">1110                 titleChecklistString = (SpannableStringBuilder) ChecklistUtils.addChecklistSpansForRegexAðŸ”µ</abbr>
1111                         getContext(),
1112                         titleChecklistString,
1113                         ChecklistUtils.CHECKLIST_REGEX,
1114                         ThemeUtils.getThemeTextColorId(getContext()));
1115                 holder.mTitle.setText(titleChecklistString);
1116             }
1117 
1118             holder.mMatchOffsets = null;
1119             int matchOffsetsIndex = mCursor.getColumnIndex(&quot;match_offsets&quot;);
1120 
1121             if (hasSearchQuery() &amp;&amp; matchOffsetsIndex != -1) {
1122                 title = mCursor.getString(mCursor.getColumnIndex(Note.MATCHED_TITLE_INDEX_NAME));
<abbr title="1123                 String snippet = mCursor.getString(mCursor.getColumnIndex(Note.MATCHED_CONTENT_INDEX_NAME));">1123                 String snippet = mCursor.getString(mCursor.getColumnIndex(Note.MATCHED_CONTENT_INDEX_NAMEðŸ”µ</abbr>
1124                 holder.mMatchOffsets = mCursor.getString(matchOffsetsIndex);
1125 
1126                 try {
1127                     holder.mContent.setText(SearchSnippetFormatter.formatString(
1128                             getContext(),
1129                             snippet,
1130                             mSnippetHighlighter,
1131                             R.color.text_title_disabled));
1132                     holder.mTitle.setText(SearchSnippetFormatter.formatString(
1133                             getContext(),
1134                             title,
1135                             mSnippetHighlighter, ThemeUtils.getThemeTextColorId(getContext())));
1136                 } catch (NullPointerException e) {
<abbr title="1137                     title = StrUtils.notNullStr(mCursor.getString(mCursor.getColumnIndex(Note.TITLE_INDEX_NAME)));">1137                     title = StrUtils.notNullStr(mCursor.getString(mCursor.getColumnIndex(Note.TITLE_INDEXðŸ”µ</abbr>
1138                     holder.mTitle.setText(title);
<abbr title="1139                     String matchedContentPreview = StrUtils.notNullStr(mCursor.getString(mCursor.getColumnIndex(Note.CONTENT_PREVIEW_INDEX_NAME)));">1139                     String matchedContentPreview = StrUtils.notNullStr(mCursor.getString(mCursor.getColumðŸ”µ</abbr>
1140                     holder.mContent.setText(matchedContentPreview);
1141                 }
1142             } else if (!mIsCondensedNoteList) {
<abbr title="1143                 String contentPreview = mCursor.getString(mCursor.getColumnIndex(Note.CONTENT_PREVIEW_INDEX_NAME));">1143                 String contentPreview = mCursor.getString(mCursor.getColumnIndex(Note.CONTENT_PREVIEW_INDðŸ”µ</abbr>
1144 
<abbr title="1145                 if (title == null || title.equals(contentPreview) || title.equals(getString(R.string.new_note_list)))">1145                 if (title == null || title.equals(contentPreview) || title.equals(getString(R.string.new_ðŸ”µ</abbr>
1146                     holder.mContent.setVisibility(View.GONE);
1147                 else {
1148                     holder.mContent.setText(contentPreview);
1149                     SpannableStringBuilder checklistString = new SpannableStringBuilder(contentPreview);
<abbr title="1150                     checklistString = (SpannableStringBuilder) ChecklistUtils.addChecklistSpansForRegexAndColor(">1150                     checklistString = (SpannableStringBuilder) ChecklistUtils.addChecklistSpansForRegexAnðŸ”µ</abbr>
1151                             getContext(),
1152                             checklistString,
1153                             ChecklistUtils.CHECKLIST_REGEX,
1154                             R.color.text_title_disabled);
1155                     holder.mContent.setText(checklistString);
1156                 }
1157             }
1158 
1159             // Add mouse right click support for showing a popup menu
1160             view.setOnTouchListener(new View.OnTouchListener() {
1161                 @SuppressLint(&quot;ClickableViewAccessibility&quot;)
1162                 @Override
1163                 public boolean onTouch(View view, MotionEvent event) {
<abbr title="1164                     if (event.getButtonState() == MotionEvent.BUTTON_SECONDARY &amp;&amp; event.getAction() == MotionEvent.ACTION_DOWN) {">1164                     if (event.getButtonState() == MotionEvent.BUTTON_SECONDARY &amp;&amp; event.getAction() == MoðŸ”µ</abbr>
1165                         showPopupMenuAtPosition(view, position);
1166                         return true;
1167                     }
1168 
1169                     return false;
1170                 }
1171             });
1172 
1173             return view;
1174         }
1175 
1176         @Override
1177         public View newView(Context context, Cursor cursor, ViewGroup viewGroup) {
1178             return null;
1179         }
1180 
1181         @Override
1182         public void bindView(View view, Context context, Cursor cursor) {
1183         }
1184     }
1185 
1186     @Override
1187     public void onBeforeUpdateObject(Bucket&lt;Preferences&gt; bucket, Preferences object) {
1188     }
1189 
1190     @Override
1191     public void onDeleteObject(Bucket&lt;Preferences&gt; bucket, Preferences object) {
1192         if (isAdded()) {
1193             requireActivity().runOnUiThread(new Runnable() {
1194                 @Override
1195                 public void run() {
1196                     getSearchItems();
1197                 }
1198             });
1199         }
1200     }
1201 
1202     @Override
1203     public void onNetworkChange(Bucket&lt;Preferences&gt; bucket, Bucket.ChangeType type, String key) {
1204         if (isAdded()) {
1205             requireActivity().runOnUiThread(new Runnable() {
1206                 @Override
1207                 public void run() {
1208                     getSearchItems();
1209                 }
1210             });
1211         }
1212     }
1213 
1214     @Override
1215     public void onSaveObject(Bucket&lt;Preferences&gt; bucket, Preferences object) {
1216         if (isAdded()) {
1217             requireActivity().runOnUiThread(new Runnable() {
1218                 @Override
1219                 public void run() {
1220                     getSearchItems();
1221                 }
1222             });
1223         }
1224     }
1225 
1226     private class SuggestionAdapter extends RecyclerView.Adapter&lt;SuggestionAdapter.ViewHolder&gt; {
1227         private final List&lt;Suggestion&gt; mSuggestions;
1228 
1229         private SuggestionAdapter(List&lt;Suggestion&gt; suggestions) {
1230             mSuggestions = new ArrayList&lt;&gt;(suggestions);
1231         }
1232 
1233         @Override
1234         public int getItemCount() {
1235             return mSuggestions.size();
1236         }
1237 
1238         @Override
1239         public int getItemViewType(int position) {
1240             return mSuggestions.get(position).getType();
1241         }
1242 
1243         @SuppressLint(&quot;SetTextI18n&quot;)
1244         @Override
1245         public void onBindViewHolder(@NonNull final ViewHolder holder, final int position) {
1246             switch (holder.mViewType) {
1247                 case HISTORY:
1248                     holder.mSuggestionText.setText(mSuggestions.get(position).getName());
1249                     holder.mSuggestionIcon.setImageResource(R.drawable.ic_history_24dp);
1250                     holder.mButtonDelete.setVisibility(View.VISIBLE);
1251                     break;
1252                 case QUERY:
1253                     holder.mSuggestionText.setText(mSuggestions.get(position).getName());
1254                     holder.mSuggestionIcon.setImageResource(R.drawable.ic_search_24dp);
1255                     holder.mButtonDelete.setVisibility(View.GONE);
1256                     break;
1257                 case TAG:
1258                     holder.mSuggestionText.setText(TAG_PREFIX + mSuggestions.get(position).getName());
1259                     holder.mSuggestionIcon.setImageResource(R.drawable.ic_tag_24dp);
1260                     holder.mButtonDelete.setVisibility(View.GONE);
1261                     break;
1262             }
1263 
1264             holder.mButtonDelete.setOnClickListener(new View.OnClickListener() {
1265                 @Override
1266                 public void onClick(View view) {
1267                     if (!isAdded()) {
1268                         return;
1269                     }
1270 
1271                     final String item = holder.mSuggestionText.getText().toString();
1272                     deleteSearchItem(item);
1273                     Snackbar
<abbr title="1274                         .make(getRootView(), R.string.snackbar_deleted_recent_search, Snackbar.LENGTH_LONG)">1274                         .make(getRootView(), R.string.snackbar_deleted_recent_search, Snackbar.LENGTH_LONðŸ”µ</abbr>
1275                         .setAction(
1276                             getString(R.string.undo),
1277                             new View.OnClickListener() {
1278                                 @Override
1279                                 public void onClick(View view) {
1280                                     addSearchItem(item, mDeletedItemIndex);
1281                                 }
1282                             }
1283                         )
1284                         .show();
1285                 }
1286             });
1287             holder.mButtonDelete.setOnLongClickListener(new View.OnLongClickListener() {
1288                 @Override
1289                 public boolean onLongClick(View v) {
1290                     if (v.isHapticFeedbackEnabled()) {
1291                         v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
1292                     }
1293 
<abbr title="1294                     Toast.makeText(getContext(), requireContext().getString(R.string.description_delete_item), Toast.LENGTH_SHORT).show();">1294                     Toast.makeText(getContext(), requireContext().getString(R.string.description_delete_iðŸ”µ</abbr>
1295                     return true;
1296                 }
1297             });
1298 
1299             holder.mView.setOnClickListener(new View.OnClickListener() {
1300                 @Override
1301                 public void onClick(View view) {
<abbr title="1302                     ((NotesActivity) requireActivity()).submitSearch(holder.mSuggestionText.getText().toString());">1302                     ((NotesActivity) requireActivity()).submitSearch(holder.mSuggestionText.getText().toSðŸ”µ</abbr>
1303 
1304                     if (holder.mViewType == HISTORY) {
1305                         AnalyticsTracker.track(
1306                             RECENT_SEARCH_TAPPED,
1307                             CATEGORY_SEARCH,
1308                             &quot;recent_search_tapped&quot;
1309                         );
1310                     }
1311                 }
1312             });
1313         }
1314 
1315         @NonNull
1316         @Override
1317         public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
<abbr title="1318             return new ViewHolder(LayoutInflater.from(requireContext()).inflate(R.layout.search_suggestion, parent, false), viewType);">1318             return new ViewHolder(LayoutInflater.from(requireContext()).inflate(R.layout.search_suggestioðŸ”µ</abbr>
1319         }
1320 
1321         private class ViewHolder extends RecyclerView.ViewHolder {
1322             private ImageButton mButtonDelete;
1323             private ImageView mSuggestionIcon;
1324             private TextView mSuggestionText;
1325             private View mView;
1326             private int mViewType;
1327 
1328             private ViewHolder(View itemView, int viewType) {
1329                 super(itemView);
1330                 mView = itemView;
1331                 mViewType = viewType;
1332                 mSuggestionText = itemView.findViewById(R.id.suggestion_text);
1333                 mSuggestionIcon = itemView.findViewById(R.id.suggestion_icon);
1334                 mButtonDelete = itemView.findViewById(R.id.suggestion_delete);
1335             }
1336         }
1337 
1338         private void updateItems(List&lt;Suggestion&gt; suggestions) {
<abbr title="1339             DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new SuggestionDiffCallback(mSuggestions, suggestions));">1339             DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new SuggestionDiffCallback(mSuggestioðŸ”µ</abbr>
1340             mSuggestions.clear();
1341             mSuggestions.addAll(suggestions);
1342             diffResult.dispatchUpdatesTo(this);
1343         }
1344     }
1345 
1346     private class SuggestionDiffCallback extends DiffUtil.Callback {
1347         private List&lt;Suggestion&gt; mListNew;
1348         private List&lt;Suggestion&gt; mListOld;
1349 
1350         private SuggestionDiffCallback(List&lt;Suggestion&gt; oldList, List&lt;Suggestion&gt; newList) {
1351             mListOld = oldList;
1352             mListNew = newList;
1353         }
1354 
1355         @Override
1356         public boolean areContentsTheSame(int itemPositionOld, int itemPositionNew) {
1357             Suggestion itemOld = mListOld.get(itemPositionOld);
1358             Suggestion itemNew = mListNew.get(itemPositionNew);
1359             return itemOld.getName().equalsIgnoreCase(itemNew.getName());
1360         }
1361 
1362         @Override
1363         public boolean areItemsTheSame(int itemPositionOld, int itemPositionNew) {
1364             Suggestion itemOld = mListOld.get(itemPositionOld);
1365             Suggestion itemNew = mListNew.get(itemPositionNew);
1366             return itemOld.getName().equalsIgnoreCase(itemNew.getName());
1367         }
1368 
1369         @Override
1370         public int getNewListSize() {
1371             return mListNew.size();
1372         }
1373 
1374         @Override
1375         public int getOldListSize() {
1376             return mListOld.size();
1377         }
1378     }
1379 
1380     private Calendar getDateByPreference(Note note) {
1381         switch (PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER)) {
1382             case DATE_CREATED_ASCENDING:
1383             case DATE_CREATED_DESCENDING:
1384                 return note.getCreationDate();
1385             case DATE_MODIFIED_ASCENDING:
1386             case DATE_MODIFIED_DESCENDING:
1387                 return note.getModificationDate();
1388             case ALPHABETICAL_ASCENDING:
1389             case ALPHABETICAL_DESCENDING:
1390             default:
1391                 return null;
1392         }
1393     }
1394 
1395     private void showPopupMenuAtPosition(View view, int position) {
1396         if (view.getContext() == null) {
1397             return;
1398         }
1399 
1400         final Note note = mNotesAdapter.getItem(position + mList.getHeaderViewsCount());
1401         if (note == null) {
1402             return;
1403         }
1404 
1405         PopupMenu popup = new PopupMenu(view.getContext(), view, Gravity.END);
1406         MenuInflater inflater = popup.getMenuInflater();
1407         inflater.inflate(R.menu.bulk_edit, popup.getMenu());
1408 
1409         if (!getListView().isLongClickable()) {
1410             // If viewing the trash, remove pin menu item and change trash menu title to &#x27;Restore&#x27;
1411             popup.getMenu().removeItem(R.id.menu_pin);
1412             if (popup.getMenu().getItem(POPUP_MENU_FIRST_ITEM_POSITION) != null) {
1413                 popup.getMenu().getItem(POPUP_MENU_FIRST_ITEM_POSITION).setTitle(R.string.restore);
1414             }
1415         } else if (popup.getMenu().getItem(POPUP_MENU_FIRST_ITEM_POSITION) != null) {
1416             // If not viewing the trash, set pin menu title based on note pin state
1417             int pinTitle = note.isPinned() ? R.string.unpin_from_top : R.string.pin_to_top;
1418             popup.getMenu().getItem(POPUP_MENU_FIRST_ITEM_POSITION).setTitle(pinTitle);
1419         }
1420 
1421         popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {
1422             @Override
1423             public boolean onMenuItemClick(MenuItem item) {
1424                 switch (item.getItemId()) {
1425                     case R.id.menu_pin:
1426                         note.setPinned(!note.isPinned());
1427                         note.setModificationDate(Calendar.getInstance());
1428                         note.save();
1429                         refreshList();
1430                         return true;
1431                     case R.id.menu_trash:
1432                         note.setDeleted(!note.isDeleted());
1433                         note.setModificationDate(Calendar.getInstance());
1434                         note.save();
1435                         if (getActivity() != null) {
1436                             ((NotesActivity) getActivity()).updateViewsAfterTrashAction(note);
1437                         }
1438                         return true;
1439                     default:
1440                         return false;
1441                 }
1442             }
1443         });
1444 
1445         popup.show();
1446     }
1447 
1448     private static class RefreshListTask extends AsyncTask&lt;Boolean, Void, ObjectCursor&lt;Note&gt;&gt; {
1449         private SoftReference&lt;NoteListFragment&gt; mNoteListFragmentReference;
1450         private boolean mIsFromNavSelect;
1451 
1452         private RefreshListTask(NoteListFragment context) {
1453             mNoteListFragmentReference = new SoftReference&lt;&gt;(context);
1454         }
1455 
1456         @Override
1457         protected ObjectCursor&lt;Note&gt; doInBackground(Boolean... args) {
1458             NoteListFragment fragment = mNoteListFragmentReference.get();
1459             mIsFromNavSelect = args[0];
1460             return fragment.queryNotes();
1461         }
1462 
1463         @Override
1464         protected void onPostExecute(ObjectCursor&lt;Note&gt; cursor) {
1465             NoteListFragment fragment = mNoteListFragmentReference.get();
1466 
<abbr title="1467             if (cursor == null || fragment.getActivity() == null || fragment.getActivity().isFinishing()) {">1467             if (cursor == null || fragment.getActivity() == null || fragment.getActivity().isFinishing())ðŸ”µ</abbr>
1468                 return;
1469             }
1470 
<abbr title="1471             // While using a Query.FullTextMatch it&#x27;s easy to enter an invalid term so catch the error and clear the cursor">1471             // While using a Query.FullTextMatch it&#x27;s easy to enter an invalid term so catch the error anðŸ”µ</abbr>
1472             int count;
1473 
1474             try {
1475                 fragment.mNotesAdapter.changeCursor(cursor);
1476                 count = fragment.mNotesAdapter.getCount();
1477             } catch (SQLiteException e) {
1478                 count = 0;
1479                 Log.e(Simplenote.TAG, &quot;Invalid SQL statement&quot;, e);
1480                 fragment.mNotesAdapter.changeCursor(null);
1481             }
1482 
1483             NotesActivity notesActivity = (NotesActivity) fragment.getActivity();
1484 
1485             if (notesActivity != null) {
1486                 if (mIsFromNavSelect &amp;&amp; DisplayUtils.isLargeScreenLandscape(notesActivity)) {
1487                     if (count == 0) {
1488                         notesActivity.showDetailPlaceholder();
1489                     } else {
1490                         // Select the first note
1491                         fragment.selectFirstNote();
1492                     }
1493                 }
1494 
1495                 notesActivity.updateTrashMenuItem(true);
1496             }
1497 
1498             if (fragment.mSelectedNoteId != null) {
1499                 fragment.setNoteSelected(fragment.mSelectedNoteId);
1500                 fragment.mSelectedNoteId = null;
1501             }
1502         }
1503     }
1504 
1505     private static class RefreshListForSearchTask extends AsyncTask&lt;Void, Void, ObjectCursor&lt;Note&gt;&gt; {
1506         private SoftReference&lt;NoteListFragment&gt; mNoteListFragmentReference;
1507 
1508         private RefreshListForSearchTask(NoteListFragment context) {
1509             mNoteListFragmentReference = new SoftReference&lt;&gt;(context);
1510         }
1511 
1512         @Override
1513         protected ObjectCursor&lt;Note&gt; doInBackground(Void... args) {
1514             NoteListFragment fragment = mNoteListFragmentReference.get();
1515             return fragment.queryNotesForSearch();
1516         }
1517 
1518         @Override
1519         protected void onPostExecute(ObjectCursor&lt;Note&gt; cursor) {
1520             NoteListFragment fragment = mNoteListFragmentReference.get();
1521 
<abbr title="1522             if (cursor == null || fragment.getActivity() == null || fragment.getActivity().isFinishing()) {">1522             if (cursor == null || fragment.getActivity() == null || fragment.getActivity().isFinishing())ðŸ”µ</abbr>
1523                 return;
1524             }
1525 
<abbr title="1526             // While using Query.FullTextMatch, it&#x27;s easy to enter an invalid term so catch the error and clear the cursor.">1526             // While using Query.FullTextMatch, it&#x27;s easy to enter an invalid term so catch the error andðŸ”µ</abbr>
1527             try {
1528                 fragment.mNotesAdapter.changeCursor(cursor);
1529             } catch (SQLiteException e) {
1530                 Log.e(Simplenote.TAG, &quot;Invalid SQL statement&quot;, e);
1531                 fragment.mNotesAdapter.changeCursor(null);
1532             }
1533 
1534             NotesActivity notesActivity = (NotesActivity) fragment.requireActivity();
1535             notesActivity.updateTrashMenuItem(true);
1536 
1537             if (fragment.mSelectedNoteId != null) {
1538                 fragment.setNoteSelected(fragment.mSelectedNoteId);
1539                 fragment.mSelectedNoteId = null;
1540             }
1541         }
1542     }
1543 
1544     private static class PinNotesTask extends AsyncTask&lt;Void, Void, Void&gt; {
1545         private SoftReference&lt;NoteListFragment&gt; mNoteListFragmentReference;
1546         private SparseBooleanArray mSelectedRows = new SparseBooleanArray();
1547 
1548         private PinNotesTask(NoteListFragment context) {
1549             mNoteListFragmentReference = new SoftReference&lt;&gt;(context);
1550         }
1551 
1552         @Override
1553         protected void onPreExecute() {
1554             NoteListFragment fragment = mNoteListFragmentReference.get();
1555             mSelectedRows = fragment.getListView().getCheckedItemPositions();
1556         }
1557 
1558         @Override
1559         protected Void doInBackground(Void... args) {
1560             NoteListFragment fragment = mNoteListFragmentReference.get();
1561             // Get the checked notes and add them to the pinnedNotesList
1562             // We can&#x27;t modify the note in this loop because the adapter could change
1563             List&lt;Note&gt; pinnedNotesList = new ArrayList&lt;&gt;();
1564 
1565             for (int i = 0; i &lt; mSelectedRows.size(); i++) {
1566                 if (mSelectedRows.valueAt(i)) {
1567                     pinnedNotesList.add(fragment.mNotesAdapter.getItem(mSelectedRows.keyAt(i)));
1568                 }
1569             }
1570 
1571             // Now loop through the notes list and mark them as pinned
1572             for (Note pinnedNote : pinnedNotesList) {
1573                 pinnedNote.setPinned(!pinnedNote.isPinned());
1574                 pinnedNote.setModificationDate(Calendar.getInstance());
1575                 pinnedNote.save();
1576             }
1577 
1578             return null;
1579         }
1580 
1581         @Override
1582         protected void onPostExecute(Void aVoid) {
1583             NoteListFragment fragment = mNoteListFragmentReference.get();
1584             fragment.mActionMode.finish();
1585             fragment.refreshList();
1586         }
1587     }
1588 
1589     private static class TrashNotesTask extends AsyncTask&lt;Void, Void, Void&gt; {
1590         private List&lt;String&gt; mDeletedNoteIds = new ArrayList&lt;&gt;();
1591         private SoftReference&lt;NoteListFragment&gt; mNoteListFragmentReference;
1592         private SparseBooleanArray mSelectedRows = new SparseBooleanArray();
1593 
1594         private TrashNotesTask(NoteListFragment context) {
1595             mNoteListFragmentReference = new SoftReference&lt;&gt;(context);
1596         }
1597 
1598         @Override
1599         protected void onPreExecute() {
1600             NoteListFragment fragment = mNoteListFragmentReference.get();
1601             mSelectedRows = fragment.getListView().getCheckedItemPositions();
1602         }
1603 
1604         @Override
1605         protected Void doInBackground(Void... args) {
1606             NoteListFragment fragment = mNoteListFragmentReference.get();
1607             // Get the checked notes and add them to the deletedNotesList
1608             // We can&#x27;t modify the note in this loop because the adapter could change
1609             List&lt;Note&gt; deletedNotesList = new ArrayList&lt;&gt;();
1610 
1611             for (int i = 0; i &lt; mSelectedRows.size(); i++) {
1612                 if (mSelectedRows.valueAt(i)) {
1613                     deletedNotesList.add(fragment.mNotesAdapter.getItem(mSelectedRows.keyAt(i)));
1614                 }
1615             }
1616 
1617             // Now loop through the notes list and mark them as deleted
1618             for (Note deletedNote : deletedNotesList) {
1619                 mDeletedNoteIds.add(deletedNote.getSimperiumKey());
1620                 deletedNote.setDeleted(!deletedNote.isDeleted());
1621                 deletedNote.setModificationDate(Calendar.getInstance());
1622                 deletedNote.save();
1623             }
1624 
1625             return null;
1626         }
1627 
1628         @Override
1629         protected void onPostExecute(Void aVoid) {
1630             NoteListFragment fragment = mNoteListFragmentReference.get();
1631             NotesActivity notesActivity = ((NotesActivity) fragment.getActivity());
1632 
1633             if (notesActivity != null) {
1634                 notesActivity.showUndoBarWithNoteIds(mDeletedNoteIds);
1635             }
1636 
1637             fragment.refreshList();
1638         }
1639     }
1640 }</pre></td>
                            <td><pre>   1 package com.automattic.simplenote;
   2 
   3 import android.animation.ObjectAnimator;
   4 import android.annotation.SuppressLint;
   5 import android.content.Context;
   6 import android.content.Intent;
   7 import android.content.SharedPreferences;
   8 import android.database.Cursor;
   9 import android.database.sqlite.SQLiteException;
  10 import android.os.AsyncTask;
  11 import android.os.Bundle;
  12 import android.os.Handler;
  13 import android.text.SpannableString;
  14 import android.text.SpannableStringBuilder;
  15 import android.text.TextUtils;
  16 import android.text.style.AbsoluteSizeSpan;
  17 import android.text.style.TextAppearanceSpan;
  18 import android.util.Log;
  19 import android.util.SparseBooleanArray;
  20 import android.util.TypedValue;
  21 import android.view.ActionMode;
  22 import android.view.Gravity;
  23 import android.view.HapticFeedbackConstants;
  24 import android.view.LayoutInflater;
  25 import android.view.Menu;
  26 import android.view.MenuInflater;
  27 import android.view.MenuItem;
  28 import android.view.MotionEvent;
  29 import android.view.View;
  30 import android.view.ViewGroup;
  31 import android.widget.AbsListView;
  32 import android.widget.AdapterView;
  33 import android.widget.CursorAdapter;
  34 import android.widget.ImageButton;
  35 import android.widget.ImageView;
  36 import android.widget.LinearLayout;
  37 import android.widget.ListView;
  38 import android.widget.RelativeLayout;
  39 import android.widget.TextView;
  40 import android.widget.Toast;
  41 
  42 import androidx.annotation.DrawableRes;
  43 import androidx.annotation.NonNull;
  44 import androidx.annotation.StringRes;
  45 import androidx.appcompat.widget.PopupMenu;
  46 import androidx.fragment.app.ListFragment;
  47 import androidx.preference.PreferenceManager;
  48 import androidx.recyclerview.widget.DiffUtil;
  49 import androidx.recyclerview.widget.LinearLayoutManager;
  50 import androidx.recyclerview.widget.RecyclerView;
  51 
  52 import com.automattic.simplenote.analytics.AnalyticsTracker;
  53 import com.automattic.simplenote.models.Note;
  54 import com.automattic.simplenote.models.Preferences;
  55 import com.automattic.simplenote.models.Suggestion;
  56 import com.automattic.simplenote.models.Tag;
  57 import com.automattic.simplenote.utils.BrowserUtils;
  58 import com.automattic.simplenote.utils.AppLog;
  59 import com.automattic.simplenote.utils.AppLog.Type;
  60 import com.automattic.simplenote.utils.ChecklistUtils;
  61 import com.automattic.simplenote.utils.DateTimeUtils;
  62 import com.automattic.simplenote.utils.DisplayUtils;
  63 import com.automattic.simplenote.utils.DrawableUtils;
  64 import com.automattic.simplenote.utils.NetworkUtils;
  65 import com.automattic.simplenote.utils.PrefUtils;
  66 import com.automattic.simplenote.utils.SearchSnippetFormatter;
  67 import com.automattic.simplenote.utils.SearchTokenizer;
  68 import com.automattic.simplenote.utils.SimplenoteLinkify;
  69 import com.automattic.simplenote.utils.StrUtils;
  70 import com.automattic.simplenote.utils.TextHighlighter;
  71 import com.automattic.simplenote.utils.ThemeUtils;
  72 import com.automattic.simplenote.utils.WidgetUtils;
  73 import com.google.android.material.floatingactionbutton.FloatingActionButton;
  74 import com.google.android.material.snackbar.Snackbar;
  75 import com.simperium.client.Bucket;
  76 import com.simperium.client.Bucket.ObjectCursor;
  77 import com.simperium.client.BucketObjectMissingException;
  78 import com.simperium.client.BucketObjectNameInvalid;
  79 import com.simperium.client.Query;
  80 
  81 import java.lang.ref.SoftReference;
  82 import java.util.ArrayList;
  83 import java.util.Calendar;
  84 import java.util.List;
  85 import java.util.regex.Matcher;
  86 import java.util.regex.Pattern;
  87 
  88 import static com.automattic.simplenote.analytics.AnalyticsTracker.CATEGORY_SEARCH;
  89 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.RECENT_SEARCH_TAPPED;
  90 import static com.automattic.simplenote.models.Note.TAGS_PROPERTY;
  91 import static com.automattic.simplenote.models.Preferences.MAX_RECENT_SEARCHES;
  92 import static com.automattic.simplenote.models.Preferences.PREFERENCES_OBJECT_KEY;
  93 import static com.automattic.simplenote.models.Suggestion.Type.HISTORY;
  94 import static com.automattic.simplenote.models.Suggestion.Type.QUERY;
  95 import static com.automattic.simplenote.models.Suggestion.Type.TAG;
  96 import static com.automattic.simplenote.models.Tag.NAME_PROPERTY;
  97 import static com.automattic.simplenote.utils.PrefUtils.ALPHABETICAL_ASCENDING;
  98 import static com.automattic.simplenote.utils.PrefUtils.ALPHABETICAL_DESCENDING;
  99 import static com.automattic.simplenote.utils.PrefUtils.DATE_CREATED_ASCENDING;
 100 import static com.automattic.simplenote.utils.PrefUtils.DATE_CREATED_DESCENDING;
 101 import static com.automattic.simplenote.utils.PrefUtils.DATE_MODIFIED_ASCENDING;
 102 import static com.automattic.simplenote.utils.PrefUtils.DATE_MODIFIED_DESCENDING;
 103 
 104 /**
 105  * A list fragment representing a list of Notes. This fragment also supports
 106  * tablet devices by allowing list items to be given an &#x27;activated&#x27; state upon
 107  * selection. This helps indicate which item is currently being viewed in a
 108  * {@link NoteEditorFragment}.
 109  * &lt;p&gt;
 110  * Activities containing this fragment MUST implement the {@link Callbacks}
 111  * interface.
 112  */
<abbr title=" 113 public class NoteListFragment extends ListFragment implements AdapterView.OnItemLongClickListener, AbsListView.MultiChoiceModeListener, Bucket.Listener&lt;Preferences&gt; {"> 113 public class NoteListFragment extends ListFragment implements AdapterView.OnItemLongClickListener, AbsLisðŸ”µ</abbr>
 114     public static final String TAG_PREFIX = &quot;tag:&quot;;
 115 
 116     /**
 117      * The preferences key representing the activated item position. Only used on tablets.
 118      */
 119     private static final String STATE_ACTIVATED_POSITION = &quot;activated_position&quot;;
 120     private static final int POPUP_MENU_FIRST_ITEM_POSITION = 0;
 121     public static final String ACTION_NEW_NOTE = &quot;com.automattic.simplenote.NEW_NOTE&quot;;
 122     /**
 123      * A dummy implementation of the {@link Callbacks} interface that does
 124      * nothing. Used only when this fragment is not attached to an activity.
 125      */
 126     private static Callbacks sCallbacks = new Callbacks() {
 127         @Override
 128         public void onActionModeCreated() {
 129         }
 130 
 131         @Override
 132         public void onActionModeDestroyed() {
 133         }
 134 
 135         @Override
<abbr title=" 136         public void onNoteSelected(String noteID, String matchOffsets, boolean isMarkdownEnabled, boolean isPreviewEnabled) {"> 136         public void onNoteSelected(String noteID, String matchOffsets, boolean isMarkdownEnabled, booleanðŸ”µ</abbr>
 137         }
 138     };
 139     protected NotesCursorAdapter mNotesAdapter;
 140     protected String mSearchString;
 141     private Bucket&lt;Preferences&gt; mBucketPreferences;
 142     private Bucket&lt;Tag&gt; mBucketTag;
 143     private ActionMode mActionMode;
 144     private View mRootView;
 145     private ImageView mEmptyViewImage;
 146     private TextView mEmptyViewText;
 147     private View mDividerLine;
 148     private FloatingActionButton mFloatingActionButton;
 149     private boolean mIsCondensedNoteList;
 150     private boolean mIsSearching;
 151     private ImageView mSortDirection;
 152     private ListView mList;
 153     private ObjectAnimator mSortDirectionAnimation;
 154     private RecyclerView mSuggestionList;
 155     private RelativeLayout mSortLayoutContent;
 156     private RelativeLayout mSuggestionLayout;
 157     private SharedPreferences mPreferences;
 158     private String mSelectedNoteId;
 159     private SuggestionAdapter mSuggestionAdapter;
 160     private TextView mSortOrder;
 161     private RefreshListTask mRefreshListTask;
 162     private RefreshListForSearchTask mRefreshListForSearchTask;
 163     private int mDeletedItemIndex;
 164     private int mPreferenceSortOrder;
 165     private int mTitleFontSize;
 166     private int mPreviewFontSize;
 167     private boolean mIsSortDown;
 168     private boolean mIsSortReverse;
 169     /**
 170      * The fragment&#x27;s current callback object, which is notified of list item
 171      * clicks.
 172      */
 173     private Callbacks mCallbacks = sCallbacks;
 174     /**
 175      * The current activated item position. Only used on tablets.
 176      */
 177     private int mActivatedPosition = ListView.INVALID_POSITION;
 178 
 179     /**
 180      * Mandatory empty constructor for the fragment manager to instantiate the
 181      * fragment (e.g. upon screen orientation changes).
 182      */
 183     public NoteListFragment() {
 184     }
 185 
 186     @Override
 187     public boolean onItemLongClick(AdapterView&lt;?&gt; adapterView, View view, int position, long l) {
 188         getListView().setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);
 189         getListView().setItemChecked(position, true);
 190 
 191         if (mActionMode == null) {
 192             requireActivity().startActionMode(this);
 193         }
 194 
 195         return true;
 196     }
 197 
 198     @Override
 199     public boolean onCreateActionMode(ActionMode actionMode, Menu menu) {
 200         mCallbacks.onActionModeCreated();
 201         MenuInflater inflater = actionMode.getMenuInflater();
 202         inflater.inflate(R.menu.bulk_edit, menu);
 203         DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.actionModeTextColor);
 204         mActionMode = actionMode;
<abbr title=" 205         int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.background_dark;"> 205         int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.bðŸ”µ</abbr>
<abbr title=" 206         requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().getTheme()));"> 206         requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActiviðŸ”µ</abbr>
 207         return true;
 208     }
 209 
 210     @Override
 211     public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 212         return false;
 213     }
 214 
 215     @Override
 216     public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 217         if (getListView().getCheckedItemIds().length &gt; 0) {
 218             switch (item.getItemId()) {
 219                 case R.id.menu_link:
 220                     BrowserUtils.copyToClipboard(requireContext(), getSelectedNoteLinks());
 221                     mode.finish();
 222                     break;
 223                 case R.id.menu_trash:
 224                     new TrashNotesTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 225                     break;
 226                 case R.id.menu_pin:
 227                     new PinNotesTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 228                     break;
 229             }
 230         }
 231 
 232         return false;
 233     }
 234 
 235     private String getSelectedNoteLinks() {
 236         SparseBooleanArray checkedPositions = getListView().getCheckedItemPositions();
 237         StringBuilder links = new StringBuilder();
 238 
 239         for (int i = 0; i &lt; checkedPositions.size(); i++) {
 240             if (checkedPositions.valueAt(i)) {
 241                 Note note = mNotesAdapter.getItem(checkedPositions.keyAt(i));
<abbr title=" 242                 links.append(SimplenoteLinkify.getNoteLinkWithTitle(note.getTitle(), note.getSimperiumKey())).append(&quot;\n&quot;);"> 242                 links.append(SimplenoteLinkify.getNoteLinkWithTitle(note.getTitle(), note.getSimperiumKeyðŸ”µ</abbr>
 243             }
 244         }
 245 
 246         return links.toString();
 247     }
 248 
 249     @Override
 250     public void onDestroyActionMode(ActionMode mode) {
 251         mCallbacks.onActionModeDestroyed();
 252         mActionMode = null;
 253         new Handler().postDelayed(
 254             new Runnable() {
 255                 @Override
 256                 public void run() {
 257                     if (getActivity() != null) {
 258                         NotesActivity notesActivity = (NotesActivity) getActivity();
 259                         setActivateOnItemClick(DisplayUtils.isLargeScreenLandscape(notesActivity));
 260                         notesActivity.showDetailPlaceholder();
 261                     }
 262 
<abbr title=" 263                     requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 263                     requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.colðŸ”µ</abbr>
 264                 }
 265             },
 266             requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime)
 267         );
 268     }
 269 
 270     @Override
<abbr title=" 271     public void onItemCheckedStateChanged(ActionMode actionMode, int position, long id, boolean checked) {"> 271     public void onItemCheckedStateChanged(ActionMode actionMode, int position, long id, boolean checked) ðŸ”µ</abbr>
 272         int checkedCount = getListView().getCheckedItemCount();
 273 
 274         if (checkedCount == 0) {
 275             actionMode.setTitle(&quot;&quot;);
 276         } else {
<abbr title=" 277             actionMode.setTitle(getResources().getQuantityString(R.plurals.selected_notes, checkedCount, checkedCount));"> 277             actionMode.setTitle(getResources().getQuantityString(R.plurals.selected_notes, checkedCount, ðŸ”µ</abbr>
 278     }
 279 
 280         actionMode.invalidate();
 281     }
 282 
 283     @Override
 284     public void onCreate(Bundle savedInstanceState) {
 285         super.onCreate(savedInstanceState);
 286         AppLog.add(Type.NETWORK, NetworkUtils.getNetworkInfo(requireContext()));
 287         AppLog.add(Type.SCREEN, &quot;Created (NoteListFragment)&quot;);
 288         mBucketPreferences = ((Simplenote) requireActivity().getApplication()).getPreferencesBucket();
 289         mBucketTag = ((Simplenote) requireActivity().getApplication()).getTagsBucket();
 290     }
 291 
 292     protected void getPrefs() {
 293         mPreferenceSortOrder = PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER);
<abbr title=" 294         mIsCondensedNoteList = PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_CONDENSED_LIST, false);"> 294         mIsCondensedNoteList = PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_CONDENSED_LIST, false)ðŸ”µ</abbr>
 295         mTitleFontSize = PrefUtils.getFontSize(getActivity());
 296         mPreviewFontSize = mTitleFontSize - 2;
 297     }
 298 
 299     @Override
<abbr title=" 300     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {"> 300     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceSðŸ”µ</abbr>
 301         return inflater.inflate(R.layout.fragment_notes_list, container, false);
 302     }
 303 
 304     @Override
 305     public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
 306         super.onViewCreated(view, savedInstanceState);
 307 
 308         NotesActivity notesActivity = (NotesActivity) requireActivity();
 309 
 310         if (ACTION_NEW_NOTE.equals(notesActivity.getIntent().getAction()) &amp;&amp;
 311                 !notesActivity.userIsUnauthorized()){
 312             //if user tap on &quot;app shortcut&quot;, create a new note
 313             createNewNote(&quot;new_note_shortcut&quot;);
 314         }
 315 
 316         mPreferences = PreferenceManager.getDefaultSharedPreferences(requireContext());
 317         mRootView = view.findViewById(R.id.list_root);
 318 
 319         LinearLayout emptyView = view.findViewById(android.R.id.empty);
 320         emptyView.setVisibility(View.GONE);
 321         mEmptyViewImage = emptyView.findViewById(R.id.image);
 322         mEmptyViewText = emptyView.findViewById(R.id.text);
 323         setEmptyListImage(R.drawable.ic_notes_24dp);
 324         setEmptyListMessage(getString(R.string.empty_notes_all));
 325         mDividerLine = view.findViewById(R.id.divider_line);
 326 
 327         if (DisplayUtils.isLargeScreenLandscape(notesActivity)) {
 328             setActivateOnItemClick(true);
 329             mDividerLine.setVisibility(View.VISIBLE);
 330         }
 331 
 332         mFloatingActionButton = view.findViewById(R.id.fab_button);
 333         mFloatingActionButton.setOnClickListener(new View.OnClickListener() {
 334             @Override
 335             public void onClick(View v) {
 336                 createNewNote(&quot;action_bar_button&quot;);
 337             }
 338         });
 339         mFloatingActionButton.setOnLongClickListener(new View.OnLongClickListener() {
 340             @Override
 341             public boolean onLongClick(View v) {
 342                 if (v.isHapticFeedbackEnabled()) {
 343                     v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
 344                 }
 345 
<abbr title=" 346                 Toast.makeText(getContext(), requireContext().getString(R.string.new_note), Toast.LENGTH_SHORT).show();"> 346                 Toast.makeText(getContext(), requireContext().getString(R.string.new_note), Toast.LENGTH_ðŸ”µ</abbr>
 347                 return true;
 348             }
 349         });
 350 
 351         mSuggestionLayout = view.findViewById(R.id.suggestion_layout);
 352         mSuggestionList = view.findViewById(R.id.suggestion_list);
 353         mSuggestionAdapter = new SuggestionAdapter(new ArrayList&lt;Suggestion&gt;());
 354         mSuggestionList.setAdapter(mSuggestionAdapter);
 355         mSuggestionList.setLayoutManager(new LinearLayoutManager(requireContext()));
 356         @SuppressLint(&quot;InflateParams&quot;)
<abbr title=" 357         LinearLayout sortLayoutContainer = (LinearLayout) getLayoutInflater().inflate(R.layout.search_sort, null, false);"> 357         LinearLayout sortLayoutContainer = (LinearLayout) getLayoutInflater().inflate(R.layout.search_sorðŸ”µ</abbr>
 358         mSortLayoutContent = sortLayoutContainer.findViewById(R.id.sort_content);
 359         mSortLayoutContent.setVisibility(mIsSearching ? View.VISIBLE : View.GONE);
 360         mSortOrder = sortLayoutContainer.findViewById(R.id.sort_order);
 361         mSortLayoutContent.setOnClickListener(new View.OnClickListener() {
 362             @Override
 363             public void onClick(View v) {
 364                 PopupMenu popup = new PopupMenu(mSortOrder.getContext(), mSortOrder, Gravity.START);
 365                 MenuInflater inflater = popup.getMenuInflater();
 366                 inflater.inflate(R.menu.search_sort, popup.getMenu());
 367                 popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {
 368                     @Override
 369                     public boolean onMenuItemClick(MenuItem item) {
 370                         // Do nothing when same sort is selected.
 371                         if (mSortOrder.getText().equals(item.getTitle())) {
 372                             return false;
 373                         }
 374 
 375                         mSortOrder.setText(item.getTitle());
 376 
 377                         switch (item.getItemId()) {
 378                             case R.id.search_alphabetically:
 379                                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER,
 380                                     String.valueOf(ALPHABETICAL_ASCENDING)
 381                                 ).apply();
 382 
 383                                 // If arrow is down, rotate it up for ascending direction.
 384                                 if (mIsSortDown &amp;&amp; !mIsSortReverse) {
 385                                     mSortDirectionAnimation.start();
 386                                     mIsSortReverse = true;
 387                                 } else if (!mIsSortDown &amp;&amp; mIsSortReverse) {
 388                                     mSortDirectionAnimation.reverse();
 389                                     mIsSortReverse = false;
 390                                 }
 391 
 392                                 refreshListForSearch();
 393                                 return true;
 394                             case R.id.search_created:
 395                                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER,
 396                                     String.valueOf(DATE_CREATED_DESCENDING)
 397                                 ).apply();
 398 
 399                                 // If arrow is up, rotate it down for descending direction.
 400                                 if (mIsSortDown &amp;&amp; mIsSortReverse) {
 401                                     mSortDirectionAnimation.reverse();
 402                                     mIsSortReverse = false;
 403                                 } else if (!mIsSortDown &amp;&amp; !mIsSortReverse) {
 404                                     mSortDirectionAnimation.start();
 405                                     mIsSortReverse = true;
 406                                 }
 407 
 408                                 refreshListForSearch();
 409                                 return true;
 410                             case R.id.search_modified:
 411                                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER,
 412                                     String.valueOf(DATE_MODIFIED_DESCENDING)
 413                                 ).apply();
 414 
 415                                 // If arrow is up, rotate it down for descending direction.
 416                                 if (mIsSortDown &amp;&amp; mIsSortReverse) {
 417                                     mSortDirectionAnimation.reverse();
 418                                     mIsSortReverse = false;
 419                                 } else if (!mIsSortDown &amp;&amp; !mIsSortReverse) {
 420                                     mSortDirectionAnimation.start();
 421                                     mIsSortReverse = true;
 422                                 }
 423 
 424                                 refreshListForSearch();
 425                                 return true;
 426                             default:
 427                                 return false;
 428                         }
 429                     }
 430                 });
 431                 popup.show();
 432             }
 433         });
 434         mList = view.findViewById(android.R.id.list);
 435         mList.addHeaderView(sortLayoutContainer);
 436 
 437         mNotesAdapter = new NotesCursorAdapter(requireActivity().getBaseContext(), null, 0);
 438         setListAdapter(mNotesAdapter);
 439 
 440         getListView().setOnItemLongClickListener(this);
 441         getListView().setMultiChoiceModeListener(this);
 442 
 443         mSortDirection = sortLayoutContainer.findViewById(R.id.sort_direction);
 444         ImageView sortDirectionSwitch = sortLayoutContainer.findViewById(R.id.sort_direction_switch);
 445         sortDirectionSwitch.setImageResource(R.drawable.ic_sort_order_24dp);
 446         sortDirectionSwitch.setOnClickListener(new View.OnClickListener() {
 447             @Override
 448             public void onClick(View v) {
 449                 if (mIsSortReverse) {
 450                     mSortDirectionAnimation.reverse();
 451                 } else {
 452                     mSortDirectionAnimation.start();
 453                 }
 454 
 455                 mIsSortReverse = !mIsSortReverse;
 456                 switchSortDirection();
 457                 refreshListForSearch();
 458             }
 459         });
 460         sortDirectionSwitch.setOnLongClickListener(new View.OnLongClickListener() {
 461             @Override
 462             public boolean onLongClick(View v) {
 463                 if (v.isHapticFeedbackEnabled()) {
 464                     v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
 465                 }
 466 
<abbr title=" 467                 Toast.makeText(requireContext(), requireContext().getString(R.string.sort_search_reverse_order), Toast.LENGTH_SHORT).show();"> 467                 Toast.makeText(requireContext(), requireContext().getString(R.string.sort_search_reverse_ðŸ”µ</abbr>
 468                 return true;
 469             }
 470         });
 471     }
 472 
 473     public void showListPadding(boolean show) {
 474         mList.setPadding(
 475             mList.getPaddingLeft(),
 476             mList.getPaddingTop(),
 477             mList.getPaddingRight(),
 478             show ? (int) getResources().getDimension(R.dimen.note_list_item_padding_bottom_button) : 0
 479         );
 480     }
 481 
 482     private @StringRes int getSortOrderText() {
 483         switch (PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER)) {
 484             case ALPHABETICAL_ASCENDING:
 485             case ALPHABETICAL_DESCENDING:
 486                 return R.string.sort_search_alphabetically;
 487             case DATE_CREATED_ASCENDING:
 488             case DATE_CREATED_DESCENDING:
 489                 return R.string.sort_search_created;
 490             case DATE_MODIFIED_ASCENDING:
 491             case DATE_MODIFIED_DESCENDING:
 492             default:
 493                 return R.string.sort_search_modified;
 494         }
 495     }
 496 
 497     private void setSortDirection() {
 498         if (mIsSortReverse) {
 499             mSortDirectionAnimation.reverse();
 500             mIsSortReverse = false;
 501         }
 502 
 503         switch (PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER)) {
 504             case ALPHABETICAL_ASCENDING:
 505             case DATE_CREATED_ASCENDING:
 506             case DATE_MODIFIED_ASCENDING:
 507                 mSortDirection.setContentDescription(getString(R.string.description_up));
 508                 mSortDirection.setImageResource(R.drawable.ic_arrow_up_16dp);
 509                 mIsSortDown = false;
 510                 break;
 511             case ALPHABETICAL_DESCENDING:
 512             case DATE_CREATED_DESCENDING:
 513             case DATE_MODIFIED_DESCENDING:
 514             default:
 515                 mSortDirection.setContentDescription(getString(R.string.description_down));
 516                 mSortDirection.setImageResource(R.drawable.ic_arrow_down_16dp);
 517                 mIsSortDown = true;
 518                 break;
 519         }
 520 
 521         mSortDirectionAnimation = ObjectAnimator.ofFloat(
 522             mSortDirection,
 523             View.ROTATION,
 524             0f,
 525             mIsSortDown ? -180f : 180f
 526         ).setDuration(getResources().getInteger(android.R.integer.config_shortAnimTime));
 527     }
 528 
 529     private void switchSortDirection() {
 530         switch (PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER)) {
 531             case DATE_MODIFIED_DESCENDING:
<abbr title=" 532                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_MODIFIED_ASCENDING)).apply();"> 532                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_MODIFIED_ASCðŸ”µ</abbr>
 533                 break;
 534             case DATE_MODIFIED_ASCENDING:
<abbr title=" 535                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_MODIFIED_DESCENDING)).apply();"> 535                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_MODIFIED_DESðŸ”µ</abbr>
 536                 break;
 537             case DATE_CREATED_DESCENDING:
<abbr title=" 538                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_CREATED_ASCENDING)).apply();"> 538                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_CREATED_ASCEðŸ”µ</abbr>
 539                 break;
 540             case DATE_CREATED_ASCENDING:
<abbr title=" 541                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_CREATED_DESCENDING)).apply();"> 541                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_CREATED_DESCðŸ”µ</abbr>
 542                 break;
 543             case ALPHABETICAL_ASCENDING:
<abbr title=" 544                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(ALPHABETICAL_DESCENDING)).apply();"> 544                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(ALPHABETICAL_DESCðŸ”µ</abbr>
 545                 break;
 546             case ALPHABETICAL_DESCENDING:
<abbr title=" 547                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(ALPHABETICAL_ASCENDING)).apply();"> 547                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(ALPHABETICAL_ASCEðŸ”µ</abbr>
 548                 break;
 549         }
 550     }
 551 
 552     public void createNewNote(String label){
 553         if (!isAdded()) return;
 554 
 555         addNote();
 556         AnalyticsTracker.track(
 557                 AnalyticsTracker.Stat.LIST_NOTE_CREATED,
 558                 AnalyticsTracker.CATEGORY_NOTE,
 559                 label
 560         );
 561     }
 562 
 563     @Override
 564     public void onAttach(@NonNull Context activity) {
 565         super.onAttach(activity);
 566 
 567         // Activities containing this fragment must implement its callbacks.
 568         if (!(activity instanceof Callbacks)) {
 569             throw new IllegalStateException(&quot;Activity must implement fragment&#x27;s callbacks.&quot;);
 570         }
 571 
 572         mCallbacks = (Callbacks) activity;
 573     }
 574 
 575     @Override
 576     public void onResume() {
 577         super.onResume();
 578         getPrefs();
 579 
 580         if (mIsSearching) {
 581             refreshListForSearch();
 582         } else {
 583             refreshList();
 584         }
 585 
 586         mBucketPreferences.start();
 587         mBucketPreferences.addOnDeleteObjectListener(this);
 588         mBucketPreferences.addOnNetworkChangeListener(this);
 589         mBucketPreferences.addOnSaveObjectListener(this);
 590     }
 591 
 592     @Override
 593     public void onPause() {
 594         super.onPause();
 595         mBucketPreferences.removeOnDeleteObjectListener(this);
 596         mBucketPreferences.removeOnNetworkChangeListener(this);
 597         mBucketPreferences.removeOnSaveObjectListener(this);
 598         mBucketPreferences.stop();
 599         AppLog.add(Type.SCREEN, &quot;Paused (NoteListFragment)&quot;);
 600     }
 601 
 602     @Override
 603     public void onDetach() {
 604         super.onDetach();
 605         // Restore sort order from Settings.
<abbr title=" 606         mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(mPreferenceSortOrder)).apply();"> 606         mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(mPreferenceSortOrder)).apðŸ”µ</abbr>
 607         // Reset the active callbacks interface to the dummy implementation.
 608         mCallbacks = sCallbacks;
 609     }
 610 
 611     public void setEmptyListImage(@DrawableRes int image) {
 612         if (mEmptyViewImage != null) {
 613             if (image != -1) {
 614                 mEmptyViewImage.setVisibility(View.VISIBLE);
 615                 mEmptyViewImage.setImageResource(image);
 616             } else {
 617                 mEmptyViewImage.setVisibility(View.GONE);
 618             }
 619         }
 620     }
 621 
 622     public void setEmptyListMessage(String message) {
 623         if (mEmptyViewText != null &amp;&amp; message != null) {
 624             mEmptyViewText.setText(message);
 625         }
 626     }
 627 
 628     @Override
 629     public void onListItemClick(@NonNull ListView listView, @NonNull View view, int position, long id) {
 630         if (!isAdded()) return;
 631         super.onListItemClick(listView, view, position, id);
 632 
 633         NoteViewHolder holder = (NoteViewHolder) view.getTag();
 634         String noteID = holder.getNoteId();
 635 
 636         if (noteID != null) {
 637             Note note = mNotesAdapter.getItem(position);
<abbr title=" 638             mCallbacks.onNoteSelected(noteID, holder.mMatchOffsets, note.isMarkdownEnabled(), note.isPreviewEnabled());"> 638             mCallbacks.onNoteSelected(noteID, holder.mMatchOffsets, note.isMarkdownEnabled(), note.isPrevðŸ”µ</abbr>
 639         }
 640 
 641         mActivatedPosition = position;
 642     }
 643 
 644     /**
 645      * Selects first row in the list if available
 646      */
 647     public void selectFirstNote() {
 648         if (mNotesAdapter.getCount() &gt; 0) {
 649             Note selectedNote = mNotesAdapter.getItem(mList.getHeaderViewsCount());
<abbr title=" 650             mCallbacks.onNoteSelected(selectedNote.getSimperiumKey(), null, selectedNote.isMarkdownEnabled(), selectedNote.isPreviewEnabled());"> 650             mCallbacks.onNoteSelected(selectedNote.getSimperiumKey(), null, selectedNote.isMarkdownEnableðŸ”µ</abbr>
 651         }
 652     }
 653 
 654     @Override
 655     public void onSaveInstanceState(@NonNull Bundle outState) {
 656         super.onSaveInstanceState(outState);
 657         if (mActivatedPosition != ListView.INVALID_POSITION) {
 658             // Serialize and persist the activated item position.
 659             outState.putInt(STATE_ACTIVATED_POSITION, mActivatedPosition);
 660         }
 661     }
 662 
 663     public View getRootView() {
 664         return mRootView;
 665     }
 666 
 667     /**
 668      * Turns on activate-on-click mode. When this mode is on, list items will be
 669      * given the &#x27;activated&#x27; state when touched.
 670      */
 671     public void setActivateOnItemClick(boolean activateOnItemClick) {
 672         // When setting CHOICE_MODE_SINGLE, ListView will automatically
 673         // give items the &#x27;activated&#x27; state when touched.
<abbr title=" 674         getListView().setChoiceMode(activateOnItemClick ? ListView.CHOICE_MODE_SINGLE : ListView.CHOICE_MODE_NONE);"> 674         getListView().setChoiceMode(activateOnItemClick ? ListView.CHOICE_MODE_SINGLE : ListView.CHOICE_MðŸ”µ</abbr>
 675     }
 676 
 677     public void setActivatedPosition(int position) {
 678         if (getListView() != null) {
 679             if (position == ListView.INVALID_POSITION) {
 680                 getListView().setItemChecked(mActivatedPosition, false);
 681             } else {
 682                 getListView().setItemChecked(position, true);
 683             }
 684 
 685             mActivatedPosition = position;
 686         }
 687     }
 688 
 689     public void setDividerVisible(boolean visible) {
 690         mDividerLine.setVisibility(visible ? View.VISIBLE : View.GONE);
 691     }
 692 
 693     public void setFloatingActionButtonVisible(boolean visible) {
 694         if (mFloatingActionButton == null) return;
 695 
 696         if (visible) {
 697             mFloatingActionButton.show();
 698         } else {
 699             mFloatingActionButton.hide();
 700         }
 701     }
 702 
 703     public void refreshList() {
 704         mSortOrder.setText(getSortOrderText());
 705         setSortDirection();
 706         refreshList(false);
 707     }
 708 
 709     public void refreshList(boolean fromNav) {
 710         if (mRefreshListTask != null &amp;&amp; mRefreshListTask.getStatus() != AsyncTask.Status.FINISHED)
 711             mRefreshListTask.cancel(true);
 712 
 713         mRefreshListTask = new RefreshListTask(this);
 714         mRefreshListTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, fromNav);
 715 
 716         WidgetUtils.updateNoteWidgets(requireActivity().getApplicationContext());
 717     }
 718 
 719     private void refreshListForSearch() {
<abbr title=" 720         if (mRefreshListForSearchTask != null &amp;&amp; mRefreshListForSearchTask.getStatus() != AsyncTask.Status.FINISHED) {"> 720         if (mRefreshListForSearchTask != null &amp;&amp; mRefreshListForSearchTask.getStatus() != AsyncTask.StatuðŸ”µ</abbr>
 721             mRefreshListForSearchTask.cancel(true);
 722         }
 723 
 724         mRefreshListForSearchTask = new RefreshListForSearchTask(this);
 725         mRefreshListForSearchTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 726     }
 727 
 728     public void refreshListFromNavSelect() {
 729         refreshList(true);
 730     }
 731 
 732     public ObjectCursor&lt;Note&gt; queryNotes() {
 733         if (!isAdded()) return null;
 734 
 735         NotesActivity notesActivity = (NotesActivity) requireActivity();
 736         Query&lt;Note&gt; query = notesActivity.getSelectedTag().query();
 737 
 738         String searchString = mSearchString;
 739         if (hasSearchQuery()) {
 740             searchString = queryTags(query, mSearchString);
 741         }
 742         if (!TextUtils.isEmpty(searchString)) {
 743             query.where(new Query.FullTextMatch(new SearchTokenizer(searchString)));
 744             query.include(new Query.FullTextOffsets(&quot;match_offsets&quot;));
<abbr title=" 745             query.include(new Query.FullTextSnippet(Note.MATCHED_TITLE_INDEX_NAME, Note.TITLE_INDEX_NAME));"> 745             query.include(new Query.FullTextSnippet(Note.MATCHED_TITLE_INDEX_NAME, Note.TITLE_INDEX_NAME)ðŸ”µ</abbr>
<abbr title=" 746             query.include(new Query.FullTextSnippet(Note.MATCHED_CONTENT_INDEX_NAME, Note.CONTENT_PROPERTY));"> 746             query.include(new Query.FullTextSnippet(Note.MATCHED_CONTENT_INDEX_NAME, Note.CONTENT_PROPERTðŸ”µ</abbr>
 747             query.include(Note.TITLE_INDEX_NAME, Note.CONTENT_PREVIEW_INDEX_NAME);
 748         } else {
 749             query.include(Note.TITLE_INDEX_NAME, Note.CONTENT_PREVIEW_INDEX_NAME);
 750         }
 751 
 752         query.include(Note.PINNED_INDEX_NAME);
 753         PrefUtils.sortNoteQuery(query, requireContext(), true);
 754         return query.execute();
 755     }
 756 
 757     private ObjectCursor&lt;Note&gt; queryNotesForSearch() {
 758         if (!isAdded()) {
 759             return null;
 760         }
 761 
 762         Query&lt;Note&gt; query = Note.all(((Simplenote) requireActivity().getApplication()).getNotesBucket());
 763         String searchString = mSearchString;
 764 
 765         if (hasSearchQuery()) {
 766             searchString = queryTags(query, mSearchString);
 767         }
 768 
 769         if (!TextUtils.isEmpty(searchString)) {
 770             query.where(new Query.FullTextMatch(new SearchTokenizer(searchString)));
 771             query.include(new Query.FullTextOffsets(&quot;match_offsets&quot;));
<abbr title=" 772             query.include(new Query.FullTextSnippet(Note.MATCHED_TITLE_INDEX_NAME, Note.TITLE_INDEX_NAME));"> 772             query.include(new Query.FullTextSnippet(Note.MATCHED_TITLE_INDEX_NAME, Note.TITLE_INDEX_NAME)ðŸ”µ</abbr>
<abbr title=" 773             query.include(new Query.FullTextSnippet(Note.MATCHED_CONTENT_INDEX_NAME, Note.CONTENT_PROPERTY));"> 773             query.include(new Query.FullTextSnippet(Note.MATCHED_CONTENT_INDEX_NAME, Note.CONTENT_PROPERTðŸ”µ</abbr>
 774             query.include(Note.TITLE_INDEX_NAME, Note.CONTENT_PREVIEW_INDEX_NAME);
 775         } else {
 776             query.include(Note.TITLE_INDEX_NAME, Note.CONTENT_PREVIEW_INDEX_NAME);
 777         }
 778 
 779         PrefUtils.sortNoteQuery(query, requireContext(), false);
 780         return query.execute();
 781     }
 782 
 783     private String queryTags(Query&lt;Note&gt; query, String searchString) {
 784         Pattern pattern = Pattern.compile(TAG_PREFIX + &quot;(.*?)( |$)&quot;);
 785         Matcher matcher = pattern.matcher(searchString);
 786         while (matcher.find()) {
 787             query.where(TAGS_PROPERTY, Query.ComparisonType.LIKE, matcher.group(1));
 788         }
 789         return matcher.replaceAll(&quot;&quot;);
 790     }
 791 
 792     public void addNote() {
 793 
 794         // Prevents jarring &#x27;New note...&#x27; from showing in the list view when creating a new note
 795         NotesActivity notesActivity = (NotesActivity) requireActivity();
 796         if (!DisplayUtils.isLargeScreenLandscape(notesActivity))
 797             notesActivity.stopListeningToNotesBucket();
 798 
 799         // Create &amp; save new note
 800         Simplenote simplenote = (Simplenote) requireActivity().getApplication();
 801         Bucket&lt;Note&gt; notesBucket = simplenote.getNotesBucket();
 802         final Note note = notesBucket.newObject();
 803         note.setCreationDate(Calendar.getInstance());
 804         note.setModificationDate(note.getCreationDate());
<abbr title=" 805         note.setMarkdownEnabled(PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_MARKDOWN_ENABLED, false));"> 805         note.setMarkdownEnabled(PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_MARKDOWN_ENABLED, falðŸ”µ</abbr>
 806 
 807         if (notesActivity.getSelectedTag() != null &amp;&amp; notesActivity.getSelectedTag().name != null) {
 808             String tagName = notesActivity.getSelectedTag().name;
<abbr title=" 809             if (!tagName.equals(getString(R.string.all_notes)) &amp;&amp; !tagName.equals(getString(R.string.trash)) &amp;&amp; !tagName.equals(getString(R.string.untagged_notes)))"> 809             if (!tagName.equals(getString(R.string.all_notes)) &amp;&amp; !tagName.equals(getString(R.string.trasðŸ”µ</abbr>
 810                 note.setTagString(tagName);
 811         }
 812 
 813         note.save();
 814 
 815         if (DisplayUtils.isLargeScreenLandscape(getActivity())) {
 816             // Hack: Simperium saves async so we add a small delay to ensure the new note is truly
 817             // saved before proceeding.
 818             new Handler().postDelayed(new Runnable() {
 819                 @Override
 820                 public void run() {
<abbr title=" 821                     mCallbacks.onNoteSelected(note.getSimperiumKey(), null, note.isMarkdownEnabled(), note.isPreviewEnabled());"> 821                     mCallbacks.onNoteSelected(note.getSimperiumKey(), null, note.isMarkdownEnabled(), notðŸ”µ</abbr>
 822                 }
 823             }, 50);
 824         } else {
 825             Bundle arguments = new Bundle();
 826             arguments.putString(NoteEditorFragment.ARG_ITEM_ID, note.getSimperiumKey());
 827             arguments.putBoolean(NoteEditorFragment.ARG_NEW_NOTE, true);
 828             arguments.putBoolean(NoteEditorFragment.ARG_MARKDOWN_ENABLED, note.isMarkdownEnabled());
 829             arguments.putBoolean(NoteEditorFragment.ARG_PREVIEW_ENABLED, note.isPreviewEnabled());
 830             Intent editNoteIntent = new Intent(getActivity(), NoteEditorActivity.class);
 831             editNoteIntent.putExtras(arguments);
 832 
 833             requireActivity().startActivityForResult(editNoteIntent, Simplenote.INTENT_EDIT_NOTE);
 834         }
 835     }
 836 
 837     public void setNoteSelected(String selectedNoteID) {
 838         // Loop through notes and set note selected if found
 839         //noinspection unchecked
 840         ObjectCursor&lt;Note&gt; cursor = (ObjectCursor&lt;Note&gt;) mNotesAdapter.getCursor();
 841         if (cursor != null) {
 842             for (int i = 0; i &lt; cursor.getCount(); i++) {
 843                 cursor.moveToPosition(i);
 844                 String noteKey = cursor.getSimperiumKey();
 845                 if (noteKey != null &amp;&amp; noteKey.equals(selectedNoteID)) {
 846                     setActivatedPosition(i + mList.getHeaderViewsCount());
 847                     return;
 848                 }
 849             }
 850         }
 851 
 852         // Didn&#x27;t find the note, let&#x27;s try again after the cursor updates (see RefreshListTask)
 853         mSelectedNoteId = selectedNoteID;
 854     }
 855 
 856     public void searchNotes(String searchString, boolean isSubmit) {
 857         mIsSearching = true;
 858         mSortLayoutContent.setVisibility(View.VISIBLE);
 859         mSuggestionLayout.setVisibility(View.VISIBLE);
 860         mSortOrder.setText(getSortOrderText());
 861 
 862         if (!searchString.equals(mSearchString)) {
 863             mSearchString = searchString;
 864         }
 865 
 866         if (searchString.isEmpty()) {
 867             getSearchItems();
 868         } else {
 869             getTagSuggestions(searchString);
 870         }
 871 
 872         if (isSubmit) {
 873             mSuggestionLayout.setVisibility(View.GONE);
 874             refreshListForSearch();
 875         }
 876     }
 877 
 878     /**
 879      * Clear search and load all notes
 880      */
 881     public void clearSearch() {
 882         mIsSearching = false;
 883         mSortLayoutContent.setVisibility(View.GONE);
 884         mSuggestionLayout.setVisibility(View.GONE);
 885         // Restore sort order from Settings.
<abbr title=" 886         mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(mPreferenceSortOrder)).apply();"> 886         mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(mPreferenceSortOrder)).apðŸ”µ</abbr>
 887         refreshList();
 888 
 889         if (mSearchString != null &amp;&amp; !mSearchString.equals(&quot;&quot;)) {
 890             mSearchString = null;
 891             refreshList();
 892         }
 893     }
 894 
 895     public boolean hasSearchQuery() {
 896         return mSearchString != null &amp;&amp; !mSearchString.equals(&quot;&quot;);
 897     }
 898 
 899     public void addSearchItem(String item, int index) {
 900         Preferences preferences = getPreferences();
 901 
 902         if (preferences != null) {
 903             List&lt;String&gt; recents = preferences.getRecentSearches();
 904             recents.remove(item);
 905             recents.add(index, item);
<abbr title=" 906             // Trim recent searches to MAX_RECENT_SEARCHES (currently 5) if size is greater than MAX_RECENT_SEARCHES."> 906             // Trim recent searches to MAX_RECENT_SEARCHES (currently 5) if size is greater than MAX_RECEðŸ”µ</abbr>
<abbr title=" 907             preferences.setRecentSearches(recents.subList(0, recents.size() &gt; MAX_RECENT_SEARCHES ? MAX_RECENT_SEARCHES : recents.size()));"> 907             preferences.setRecentSearches(recents.subList(0, recents.size() &gt; MAX_RECENT_SEARCHES ? MAX_RðŸ”µ</abbr>
 908             preferences.save();
 909         } else {
 910             Log.e(&quot;addSearchItem&quot;, &quot;Could not get preferences entity&quot;);
 911         }
 912     }
 913 
 914     private void deleteSearchItem(String item) {
 915         Preferences preferences = getPreferences();
 916 
 917         if (preferences != null) {
 918             List&lt;String&gt; recents = preferences.getRecentSearches();
 919             mDeletedItemIndex = recents.indexOf(item);
 920             recents.remove(item);
 921             preferences.setRecentSearches(recents);
 922             preferences.save();
 923         } else {
 924             Log.e(&quot;deleteSearchItem&quot;, &quot;Could not get preferences entity&quot;);
 925         }
 926     }
 927 
 928     private Preferences getPreferences() {
 929         try {
 930             return mBucketPreferences.get(PREFERENCES_OBJECT_KEY);
 931         } catch (BucketObjectMissingException exception) {
 932             try {
 933                 Preferences preferences = mBucketPreferences.newObject(PREFERENCES_OBJECT_KEY);
 934                 preferences.save();
 935                 return preferences;
 936             } catch (BucketObjectNameInvalid invalid) {
 937                 Log.e(&quot;getPreferences&quot;, &quot;Could not create preferences entity&quot;, invalid);
 938                 return null;
 939             }
 940         }
 941     }
 942 
 943     private void getSearchItems() {
 944         Preferences preferences = getPreferences();
 945 
 946         if (preferences != null) {
 947             ArrayList&lt;Suggestion&gt; suggestions = new ArrayList&lt;&gt;();
 948 
 949             for (String recent : preferences.getRecentSearches()) {
 950                 suggestions.add(new Suggestion(recent, HISTORY));
 951             }
 952 
 953             mSuggestionAdapter.updateItems(suggestions);
 954         } else {
 955             Log.e(&quot;getSearchItems&quot;, &quot;Could not get preferences entity&quot;);
 956         }
 957     }
 958 
 959     private void getTagSuggestions(String query) {
 960         ArrayList&lt;Suggestion&gt; suggestions = new ArrayList&lt;&gt;();
 961         suggestions.add(new Suggestion(query, QUERY));
<abbr title=" 962         Query&lt;Tag&gt; tags = Tag.all(mBucketTag).reorder().order(Tag.NOTE_COUNT_INDEX_NAME, Query.SortType.DESCENDING);"> 962         Query&lt;Tag&gt; tags = Tag.all(mBucketTag).reorder().order(Tag.NOTE_COUNT_INDEX_NAME, Query.SortType.DðŸ”µ</abbr>
 963 
 964         if (!query.endsWith(TAG_PREFIX)) {
 965             tags.where(NAME_PROPERTY, Query.ComparisonType.LIKE, &quot;%&quot; + query + &quot;%&quot;);
 966         }
 967 
 968         try (ObjectCursor&lt;Tag&gt; cursor = tags.execute()) {
 969             while (cursor.moveToNext()) {
 970                 suggestions.add(new Suggestion(cursor.getObject().getName(), TAG));
 971             }
 972         }
 973 
 974         mSuggestionAdapter = new SuggestionAdapter(suggestions);
 975         mSuggestionList.setAdapter(mSuggestionAdapter);
 976     }
 977 
 978     /**
 979      * A callback interface that all activities containing this fragment must
 980      * implement. This mechanism allows activities to be notified of item
 981      * selections.
 982      */
 983     public interface Callbacks {
 984         /**
 985          * Callback for when action mode is created.
 986          */
 987         void onActionModeCreated();
 988         /**
 989          * Callback for when action mode is destroyed.
 990          */
 991         void onActionModeDestroyed();
 992         /**
 993          * Callback for when a note has been selected.
 994          */
<abbr title=" 995         void onNoteSelected(String noteID, String matchOffsets, boolean isMarkdownEnabled, boolean isPreviewEnabled);"> 995         void onNoteSelected(String noteID, String matchOffsets, boolean isMarkdownEnabled, boolean isPrevðŸ”µ</abbr>
 996     }
 997 
 998     // view holder for NotesCursorAdapter
 999     private static class NoteViewHolder {
1000         private ImageView mPinned;
1001         private ImageView mPublished;
1002         private TextView mContent;
1003         private TextView mDate;
1004         private TextView mTitle;
1005         private String mMatchOffsets;
1006         private String mNoteId;
1007         private View mStatus;
1008 
1009         public String getNoteId() {
1010             return mNoteId;
1011         }
1012 
1013         public void setNoteId(String noteId) {
1014             mNoteId = noteId;
1015         }
1016     }
1017 
1018     public class NotesCursorAdapter extends CursorAdapter {
1019         private ObjectCursor&lt;Note&gt; mCursor;
1020 
<abbr title="1021         private SearchSnippetFormatter.SpanFactory mSnippetHighlighter = new TextHighlighter(requireActivity(),">1021         private SearchSnippetFormatter.SpanFactory mSnippetHighlighter = new TextHighlighter(requireActivðŸ”µ</abbr>
1022                 R.attr.listSearchHighlightForegroundColor, R.attr.listSearchHighlightBackgroundColor);
1023 
1024         public NotesCursorAdapter(Context context, ObjectCursor&lt;Note&gt; c, int flags) {
1025             super(context, c, flags);
1026             mCursor = c;
1027         }
1028 
1029         public void changeCursor(ObjectCursor&lt;Note&gt; cursor) {
1030             mCursor = cursor;
1031             super.changeCursor(cursor);
1032         }
1033 
1034         @Override
1035         public Note getItem(int position) {
1036             mCursor.moveToPosition(position - mList.getHeaderViewsCount());
1037             return mCursor.getObject();
1038         }
1039 
1040         /*
1041          *  nbradbury - implemented &quot;holder pattern&quot; to boost performance with large note lists
1042          */
1043         @Override
1044         public View getView(final int position, View view, ViewGroup parent) {
1045             final NoteViewHolder holder;
1046 
1047             if (view == null) {
1048                 view = View.inflate(requireActivity().getBaseContext(), R.layout.note_list_row, null);
1049                 holder = new NoteViewHolder();
1050                 holder.mTitle = view.findViewById(R.id.note_title);
1051                 holder.mContent = view.findViewById(R.id.note_content);
1052                 holder.mDate = view.findViewById(R.id.note_date);
1053                 holder.mPinned = view.findViewById(R.id.note_pinned);
1054                 holder.mPublished = view.findViewById(R.id.note_published);
1055                 holder.mStatus = view.findViewById(R.id.note_status);
1056                 view.setTag(holder);
1057             } else {
1058                 holder = (NoteViewHolder) view.getTag();
1059             }
1060 
1061             if (holder.mTitle.getTextSize() != mTitleFontSize) {
1062                 holder.mTitle.setTextSize(TypedValue.COMPLEX_UNIT_SP, mTitleFontSize);
1063                 holder.mContent.setTextSize(TypedValue.COMPLEX_UNIT_SP, mPreviewFontSize);
1064                 holder.mDate.setTextSize(TypedValue.COMPLEX_UNIT_SP, mPreviewFontSize);
1065             }
1066 
1067             if (position == getListView().getCheckedItemPosition())
1068                 view.setActivated(true);
1069             else
1070                 view.setActivated(false);
1071 
1072             // for performance reasons we are going to get indexed values
1073             // from the cursor instead of instantiating the entire bucket object
1074             holder.mContent.setVisibility(mIsCondensedNoteList ? View.GONE : View.VISIBLE);
1075             mCursor.moveToPosition(position);
1076             holder.setNoteId(mCursor.getSimperiumKey());
1077             Calendar date = getDateByPreference(mCursor.getObject());
1078             holder.mDate.setText(date != null ? DateTimeUtils.getDateTextNumeric(date) : &quot;&quot;);
1079             holder.mDate.setVisibility(mIsSearching &amp;&amp; date != null ? View.VISIBLE : View.GONE);
1080             boolean isPinned = mCursor.getObject().isPinned();
1081             holder.mPinned.setVisibility(!isPinned || mIsSearching ? View.GONE : View.VISIBLE);
1082             boolean isPublished = !mCursor.getObject().getPublishedUrl().isEmpty();
1083             holder.mPublished.setVisibility(!isPublished || mIsSearching ? View.GONE : View.VISIBLE);
1084             boolean showIcons = isPinned || isPublished;
1085             boolean showDate = mIsSearching &amp;&amp; date != null;
1086             holder.mStatus.setVisibility(showIcons || showDate ? View.VISIBLE : View.GONE);
1087             String title = mCursor.getString(mCursor.getColumnIndex(Note.TITLE_INDEX_NAME));
1088 
1089             if (TextUtils.isEmpty(title)) {
1090                 SpannableString newNoteString = new SpannableString(getString(R.string.new_note_list));
<abbr title="1091                 newNoteString.setSpan(new TextAppearanceSpan(getActivity(),R.style.UntitledNoteAppearance),">1091                 newNoteString.setSpan(new TextAppearanceSpan(getActivity(),R.style.UntitledNoteAppearanceðŸ”µ</abbr>
1092                         0,
1093                         newNoteString.length(),
1094                         SpannableString.SPAN_EXCLUSIVE_EXCLUSIVE
1095                 );
1096                 newNoteString.setSpan(new AbsoluteSizeSpan(mTitleFontSize, true),
1097                         0,
1098                         newNoteString.length(),
1099                         SpannableString.SPAN_EXCLUSIVE_EXCLUSIVE
1100                 );
1101                 holder.mTitle.setText(newNoteString);
1102             } else {
1103                 SpannableStringBuilder titleChecklistString = new SpannableStringBuilder(title);
<abbr title="1104                 titleChecklistString = (SpannableStringBuilder) ChecklistUtils.addChecklistSpansForRegexAndColor(">1104                 titleChecklistString = (SpannableStringBuilder) ChecklistUtils.addChecklistSpansForRegexAðŸ”µ</abbr>
1105                         getContext(),
1106                         titleChecklistString,
1107                         ChecklistUtils.CHECKLIST_REGEX,
1108                         ThemeUtils.getThemeTextColorId(getContext()));
1109                 holder.mTitle.setText(titleChecklistString);
1110             }
1111 
1112             holder.mMatchOffsets = null;
1113             int matchOffsetsIndex = mCursor.getColumnIndex(&quot;match_offsets&quot;);
1114 
1115             if (hasSearchQuery() &amp;&amp; matchOffsetsIndex != -1) {
1116                 title = mCursor.getString(mCursor.getColumnIndex(Note.MATCHED_TITLE_INDEX_NAME));
<abbr title="1117                 String snippet = mCursor.getString(mCursor.getColumnIndex(Note.MATCHED_CONTENT_INDEX_NAME));">1117                 String snippet = mCursor.getString(mCursor.getColumnIndex(Note.MATCHED_CONTENT_INDEX_NAMEðŸ”µ</abbr>
1118                 holder.mMatchOffsets = mCursor.getString(matchOffsetsIndex);
1119 
1120                 try {
1121                     holder.mContent.setText(SearchSnippetFormatter.formatString(
1122                             getContext(),
1123                             snippet,
1124                             mSnippetHighlighter,
1125                             R.color.text_title_disabled));
1126                     holder.mTitle.setText(SearchSnippetFormatter.formatString(
1127                             getContext(),
1128                             title,
1129                             mSnippetHighlighter, ThemeUtils.getThemeTextColorId(getContext())));
1130                 } catch (NullPointerException e) {
<abbr title="1131                     title = StrUtils.notNullStr(mCursor.getString(mCursor.getColumnIndex(Note.TITLE_INDEX_NAME)));">1131                     title = StrUtils.notNullStr(mCursor.getString(mCursor.getColumnIndex(Note.TITLE_INDEXðŸ”µ</abbr>
1132                     holder.mTitle.setText(title);
<abbr title="1133                     String matchedContentPreview = StrUtils.notNullStr(mCursor.getString(mCursor.getColumnIndex(Note.CONTENT_PREVIEW_INDEX_NAME)));">1133                     String matchedContentPreview = StrUtils.notNullStr(mCursor.getString(mCursor.getColumðŸ”µ</abbr>
1134                     holder.mContent.setText(matchedContentPreview);
1135                 }
1136             } else if (!mIsCondensedNoteList) {
<abbr title="1137                 String contentPreview = mCursor.getString(mCursor.getColumnIndex(Note.CONTENT_PREVIEW_INDEX_NAME));">1137                 String contentPreview = mCursor.getString(mCursor.getColumnIndex(Note.CONTENT_PREVIEW_INDðŸ”µ</abbr>
1138 
<abbr title="1139                 if (title == null || title.equals(contentPreview) || title.equals(getString(R.string.new_note_list)))">1139                 if (title == null || title.equals(contentPreview) || title.equals(getString(R.string.new_ðŸ”µ</abbr>
1140                     holder.mContent.setVisibility(View.GONE);
1141                 else {
1142                     holder.mContent.setText(contentPreview);
1143                     SpannableStringBuilder checklistString = new SpannableStringBuilder(contentPreview);
<abbr title="1144                     checklistString = (SpannableStringBuilder) ChecklistUtils.addChecklistSpansForRegexAndColor(">1144                     checklistString = (SpannableStringBuilder) ChecklistUtils.addChecklistSpansForRegexAnðŸ”µ</abbr>
1145                             getContext(),
1146                             checklistString,
1147                             ChecklistUtils.CHECKLIST_REGEX,
1148                             R.color.text_title_disabled);
1149                     holder.mContent.setText(checklistString);
1150                 }
1151             }
1152 
1153             // Add mouse right click support for showing a popup menu
1154             view.setOnTouchListener(new View.OnTouchListener() {
1155                 @SuppressLint(&quot;ClickableViewAccessibility&quot;)
1156                 @Override
1157                 public boolean onTouch(View view, MotionEvent event) {
<abbr title="1158                     if (event.getButtonState() == MotionEvent.BUTTON_SECONDARY &amp;&amp; event.getAction() == MotionEvent.ACTION_DOWN) {">1158                     if (event.getButtonState() == MotionEvent.BUTTON_SECONDARY &amp;&amp; event.getAction() == MoðŸ”µ</abbr>
1159                         showPopupMenuAtPosition(view, position);
1160                         return true;
1161                     }
1162 
1163                     return false;
1164                 }
1165             });
1166 
1167             return view;
1168         }
1169 
1170         @Override
1171         public View newView(Context context, Cursor cursor, ViewGroup viewGroup) {
1172             return null;
1173         }
1174 
1175         @Override
1176         public void bindView(View view, Context context, Cursor cursor) {
1177         }
1178     }
1179 
1180     @Override
1181     public void onBeforeUpdateObject(Bucket&lt;Preferences&gt; bucket, Preferences object) {
1182     }
1183 
1184     @Override
1185     public void onDeleteObject(Bucket&lt;Preferences&gt; bucket, Preferences object) {
1186         if (isAdded()) {
1187             requireActivity().runOnUiThread(new Runnable() {
1188                 @Override
1189                 public void run() {
1190                     getSearchItems();
1191                 }
1192             });
1193         }
1194     }
1195 
1196     @Override
1197     public void onNetworkChange(Bucket&lt;Preferences&gt; bucket, Bucket.ChangeType type, String key) {
1198         if (isAdded()) {
1199             requireActivity().runOnUiThread(new Runnable() {
1200                 @Override
1201                 public void run() {
1202                     getSearchItems();
1203                 }
1204             });
1205         }
1206     }
1207 
1208     @Override
1209     public void onSaveObject(Bucket&lt;Preferences&gt; bucket, Preferences object) {
1210         if (isAdded()) {
1211             requireActivity().runOnUiThread(new Runnable() {
1212                 @Override
1213                 public void run() {
1214                     getSearchItems();
1215                 }
1216             });
1217         }
1218     }
1219 
1220     private class SuggestionAdapter extends RecyclerView.Adapter&lt;SuggestionAdapter.ViewHolder&gt; {
1221         private final List&lt;Suggestion&gt; mSuggestions;
1222 
1223         private SuggestionAdapter(List&lt;Suggestion&gt; suggestions) {
1224             mSuggestions = new ArrayList&lt;&gt;(suggestions);
1225         }
1226 
1227         @Override
1228         public int getItemCount() {
1229             return mSuggestions.size();
1230         }
1231 
1232         @Override
1233         public int getItemViewType(int position) {
1234             return mSuggestions.get(position).getType();
1235         }
1236 
1237         @SuppressLint(&quot;SetTextI18n&quot;)
1238         @Override
1239         public void onBindViewHolder(@NonNull final ViewHolder holder, final int position) {
1240             switch (holder.mViewType) {
1241                 case HISTORY:
1242                     holder.mSuggestionText.setText(mSuggestions.get(position).getName());
1243                     holder.mSuggestionIcon.setImageResource(R.drawable.ic_history_24dp);
1244                     holder.mButtonDelete.setVisibility(View.VISIBLE);
1245                     break;
1246                 case QUERY:
1247                     holder.mSuggestionText.setText(mSuggestions.get(position).getName());
1248                     holder.mSuggestionIcon.setImageResource(R.drawable.ic_search_24dp);
1249                     holder.mButtonDelete.setVisibility(View.GONE);
1250                     break;
1251                 case TAG:
1252                     holder.mSuggestionText.setText(TAG_PREFIX + mSuggestions.get(position).getName());
1253                     holder.mSuggestionIcon.setImageResource(R.drawable.ic_tag_24dp);
1254                     holder.mButtonDelete.setVisibility(View.GONE);
1255                     break;
1256             }
1257 
1258             holder.mButtonDelete.setOnClickListener(new View.OnClickListener() {
1259                 @Override
1260                 public void onClick(View view) {
1261                     if (!isAdded()) {
1262                         return;
1263                     }
1264 
1265                     final String item = holder.mSuggestionText.getText().toString();
1266                     deleteSearchItem(item);
1267                     Snackbar
<abbr title="1268                         .make(getRootView(), R.string.snackbar_deleted_recent_search, Snackbar.LENGTH_LONG)">1268                         .make(getRootView(), R.string.snackbar_deleted_recent_search, Snackbar.LENGTH_LONðŸ”µ</abbr>
1269                         .setAction(
1270                             getString(R.string.undo),
1271                             new View.OnClickListener() {
1272                                 @Override
1273                                 public void onClick(View view) {
1274                                     addSearchItem(item, mDeletedItemIndex);
1275                                 }
1276                             }
1277                         )
1278                         .show();
1279                 }
1280             });
1281             holder.mButtonDelete.setOnLongClickListener(new View.OnLongClickListener() {
1282                 @Override
1283                 public boolean onLongClick(View v) {
1284                     if (v.isHapticFeedbackEnabled()) {
1285                         v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
1286                     }
1287 
<abbr title="1288                     Toast.makeText(getContext(), requireContext().getString(R.string.description_delete_item), Toast.LENGTH_SHORT).show();">1288                     Toast.makeText(getContext(), requireContext().getString(R.string.description_delete_iðŸ”µ</abbr>
1289                     return true;
1290                 }
1291             });
1292 
1293             holder.mView.setOnClickListener(new View.OnClickListener() {
1294                 @Override
1295                 public void onClick(View view) {
<abbr title="1296                     ((NotesActivity) requireActivity()).submitSearch(holder.mSuggestionText.getText().toString());">1296                     ((NotesActivity) requireActivity()).submitSearch(holder.mSuggestionText.getText().toSðŸ”µ</abbr>
1297 
1298                     if (holder.mViewType == HISTORY) {
1299                         AnalyticsTracker.track(
1300                             RECENT_SEARCH_TAPPED,
1301                             CATEGORY_SEARCH,
1302                             &quot;recent_search_tapped&quot;
1303                         );
1304                     }
1305                 }
1306             });
1307         }
1308 
1309         @NonNull
1310         @Override
1311         public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
<abbr title="1312             return new ViewHolder(LayoutInflater.from(requireContext()).inflate(R.layout.search_suggestion, parent, false), viewType);">1312             return new ViewHolder(LayoutInflater.from(requireContext()).inflate(R.layout.search_suggestioðŸ”µ</abbr>
1313         }
1314 
1315         private class ViewHolder extends RecyclerView.ViewHolder {
1316             private ImageButton mButtonDelete;
1317             private ImageView mSuggestionIcon;
1318             private TextView mSuggestionText;
1319             private View mView;
1320             private int mViewType;
1321 
1322             private ViewHolder(View itemView, int viewType) {
1323                 super(itemView);
1324                 mView = itemView;
1325                 mViewType = viewType;
1326                 mSuggestionText = itemView.findViewById(R.id.suggestion_text);
1327                 mSuggestionIcon = itemView.findViewById(R.id.suggestion_icon);
1328                 mButtonDelete = itemView.findViewById(R.id.suggestion_delete);
1329             }
1330         }
1331 
1332         private void updateItems(List&lt;Suggestion&gt; suggestions) {
<abbr title="1333             DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new SuggestionDiffCallback(mSuggestions, suggestions));">1333             DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new SuggestionDiffCallback(mSuggestioðŸ”µ</abbr>
1334             mSuggestions.clear();
1335             mSuggestions.addAll(suggestions);
1336             diffResult.dispatchUpdatesTo(this);
1337         }
1338     }
1339 
1340     private class SuggestionDiffCallback extends DiffUtil.Callback {
1341         private List&lt;Suggestion&gt; mListNew;
1342         private List&lt;Suggestion&gt; mListOld;
1343 
1344         private SuggestionDiffCallback(List&lt;Suggestion&gt; oldList, List&lt;Suggestion&gt; newList) {
1345             mListOld = oldList;
1346             mListNew = newList;
1347         }
1348 
1349         @Override
1350         public boolean areContentsTheSame(int itemPositionOld, int itemPositionNew) {
1351             Suggestion itemOld = mListOld.get(itemPositionOld);
1352             Suggestion itemNew = mListNew.get(itemPositionNew);
1353             return itemOld.getName().equalsIgnoreCase(itemNew.getName());
1354         }
1355 
1356         @Override
1357         public boolean areItemsTheSame(int itemPositionOld, int itemPositionNew) {
1358             Suggestion itemOld = mListOld.get(itemPositionOld);
1359             Suggestion itemNew = mListNew.get(itemPositionNew);
1360             return itemOld.getName().equalsIgnoreCase(itemNew.getName());
1361         }
1362 
1363         @Override
1364         public int getNewListSize() {
1365             return mListNew.size();
1366         }
1367 
1368         @Override
1369         public int getOldListSize() {
1370             return mListOld.size();
1371         }
1372     }
1373 
1374     private Calendar getDateByPreference(Note note) {
1375         switch (PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER)) {
1376             case DATE_CREATED_ASCENDING:
1377             case DATE_CREATED_DESCENDING:
1378                 return note.getCreationDate();
1379             case DATE_MODIFIED_ASCENDING:
1380             case DATE_MODIFIED_DESCENDING:
1381                 return note.getModificationDate();
1382             case ALPHABETICAL_ASCENDING:
1383             case ALPHABETICAL_DESCENDING:
1384             default:
1385                 return null;
1386         }
1387     }
1388 
1389     private void showPopupMenuAtPosition(View view, int position) {
1390         if (view.getContext() == null) {
1391             return;
1392         }
1393 
1394         final Note note = mNotesAdapter.getItem(position + mList.getHeaderViewsCount());
1395         if (note == null) {
1396             return;
1397         }
1398 
1399         PopupMenu popup = new PopupMenu(view.getContext(), view, Gravity.END);
1400         MenuInflater inflater = popup.getMenuInflater();
1401         inflater.inflate(R.menu.bulk_edit, popup.getMenu());
1402 
1403         if (!getListView().isLongClickable()) {
1404             // If viewing the trash, remove pin menu item and change trash menu title to &#x27;Restore&#x27;
1405             popup.getMenu().removeItem(R.id.menu_pin);
1406             if (popup.getMenu().getItem(POPUP_MENU_FIRST_ITEM_POSITION) != null) {
1407                 popup.getMenu().getItem(POPUP_MENU_FIRST_ITEM_POSITION).setTitle(R.string.restore);
1408             }
1409         } else if (popup.getMenu().getItem(POPUP_MENU_FIRST_ITEM_POSITION) != null) {
1410             // If not viewing the trash, set pin menu title based on note pin state
1411             int pinTitle = note.isPinned() ? R.string.unpin_from_top : R.string.pin_to_top;
1412             popup.getMenu().getItem(POPUP_MENU_FIRST_ITEM_POSITION).setTitle(pinTitle);
1413         }
1414 
1415         popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {
1416             @Override
1417             public boolean onMenuItemClick(MenuItem item) {
1418                 switch (item.getItemId()) {
1419                     case R.id.menu_pin:
1420                         note.setPinned(!note.isPinned());
1421                         note.setModificationDate(Calendar.getInstance());
1422                         note.save();
1423                         refreshList();
1424                         return true;
1425                     case R.id.menu_trash:
1426                         note.setDeleted(!note.isDeleted());
1427                         note.setModificationDate(Calendar.getInstance());
1428                         note.save();
1429                         if (getActivity() != null) {
1430                             ((NotesActivity) getActivity()).updateViewsAfterTrashAction(note);
1431                         }
1432                         return true;
1433                     default:
1434                         return false;
1435                 }
1436             }
1437         });
1438 
1439         popup.show();
1440     }
1441 
1442     private static class RefreshListTask extends AsyncTask&lt;Boolean, Void, ObjectCursor&lt;Note&gt;&gt; {
1443         private SoftReference&lt;NoteListFragment&gt; mNoteListFragmentReference;
1444         private boolean mIsFromNavSelect;
1445 
1446         private RefreshListTask(NoteListFragment context) {
1447             mNoteListFragmentReference = new SoftReference&lt;&gt;(context);
1448         }
1449 
1450         @Override
1451         protected ObjectCursor&lt;Note&gt; doInBackground(Boolean... args) {
1452             NoteListFragment fragment = mNoteListFragmentReference.get();
1453             mIsFromNavSelect = args[0];
1454             return fragment.queryNotes();
1455         }
1456 
1457         @Override
1458         protected void onPostExecute(ObjectCursor&lt;Note&gt; cursor) {
1459             NoteListFragment fragment = mNoteListFragmentReference.get();
1460 
<abbr title="1461             if (cursor == null || fragment.getActivity() == null || fragment.getActivity().isFinishing()) {">1461             if (cursor == null || fragment.getActivity() == null || fragment.getActivity().isFinishing())ðŸ”µ</abbr>
1462                 return;
1463             }
1464 
<abbr title="1465             // While using a Query.FullTextMatch it&#x27;s easy to enter an invalid term so catch the error and clear the cursor">1465             // While using a Query.FullTextMatch it&#x27;s easy to enter an invalid term so catch the error anðŸ”µ</abbr>
1466             int count;
1467 
1468             try {
1469                 fragment.mNotesAdapter.changeCursor(cursor);
1470                 count = fragment.mNotesAdapter.getCount();
1471             } catch (SQLiteException e) {
1472                 count = 0;
1473                 Log.e(Simplenote.TAG, &quot;Invalid SQL statement&quot;, e);
1474                 fragment.mNotesAdapter.changeCursor(null);
1475             }
1476 
1477             NotesActivity notesActivity = (NotesActivity) fragment.getActivity();
1478 
1479             if (notesActivity != null) {
1480                 if (mIsFromNavSelect &amp;&amp; DisplayUtils.isLargeScreenLandscape(notesActivity)) {
1481                     if (count == 0) {
1482                         notesActivity.showDetailPlaceholder();
1483                     } else {
1484                         // Select the first note
1485                         fragment.selectFirstNote();
1486                     }
1487                 }
1488 
1489                 notesActivity.updateTrashMenuItem(true);
1490             }
1491 
1492             if (fragment.mSelectedNoteId != null) {
1493                 fragment.setNoteSelected(fragment.mSelectedNoteId);
1494                 fragment.mSelectedNoteId = null;
1495             }
1496         }
1497     }
1498 
1499     private static class RefreshListForSearchTask extends AsyncTask&lt;Void, Void, ObjectCursor&lt;Note&gt;&gt; {
1500         private SoftReference&lt;NoteListFragment&gt; mNoteListFragmentReference;
1501 
1502         private RefreshListForSearchTask(NoteListFragment context) {
1503             mNoteListFragmentReference = new SoftReference&lt;&gt;(context);
1504         }
1505 
1506         @Override
1507         protected ObjectCursor&lt;Note&gt; doInBackground(Void... args) {
1508             NoteListFragment fragment = mNoteListFragmentReference.get();
1509             return fragment.queryNotesForSearch();
1510         }
1511 
1512         @Override
1513         protected void onPostExecute(ObjectCursor&lt;Note&gt; cursor) {
1514             NoteListFragment fragment = mNoteListFragmentReference.get();
1515 
<abbr title="1516             if (cursor == null || fragment.getActivity() == null || fragment.getActivity().isFinishing()) {">1516             if (cursor == null || fragment.getActivity() == null || fragment.getActivity().isFinishing())ðŸ”µ</abbr>
1517                 return;
1518             }
1519 
<abbr title="1520             // While using Query.FullTextMatch, it&#x27;s easy to enter an invalid term so catch the error and clear the cursor.">1520             // While using Query.FullTextMatch, it&#x27;s easy to enter an invalid term so catch the error andðŸ”µ</abbr>
1521             try {
1522                 fragment.mNotesAdapter.changeCursor(cursor);
1523             } catch (SQLiteException e) {
1524                 Log.e(Simplenote.TAG, &quot;Invalid SQL statement&quot;, e);
1525                 fragment.mNotesAdapter.changeCursor(null);
1526             }
1527 
1528             NotesActivity notesActivity = (NotesActivity) fragment.requireActivity();
1529             notesActivity.updateTrashMenuItem(true);
1530 
1531             if (fragment.mSelectedNoteId != null) {
1532                 fragment.setNoteSelected(fragment.mSelectedNoteId);
1533                 fragment.mSelectedNoteId = null;
1534             }
1535         }
1536     }
1537 
1538     private static class PinNotesTask extends AsyncTask&lt;Void, Void, Void&gt; {
1539         private SoftReference&lt;NoteListFragment&gt; mNoteListFragmentReference;
1540         private SparseBooleanArray mSelectedRows = new SparseBooleanArray();
1541 
1542         private PinNotesTask(NoteListFragment context) {
1543             mNoteListFragmentReference = new SoftReference&lt;&gt;(context);
1544         }
1545 
1546         @Override
1547         protected void onPreExecute() {
1548             NoteListFragment fragment = mNoteListFragmentReference.get();
1549             mSelectedRows = fragment.getListView().getCheckedItemPositions();
1550         }
1551 
1552         @Override
1553         protected Void doInBackground(Void... args) {
1554             NoteListFragment fragment = mNoteListFragmentReference.get();
1555             // Get the checked notes and add them to the pinnedNotesList
1556             // We can&#x27;t modify the note in this loop because the adapter could change
1557             List&lt;Note&gt; pinnedNotesList = new ArrayList&lt;&gt;();
1558 
1559             for (int i = 0; i &lt; mSelectedRows.size(); i++) {
1560                 if (mSelectedRows.valueAt(i)) {
1561                     pinnedNotesList.add(fragment.mNotesAdapter.getItem(mSelectedRows.keyAt(i)));
1562                 }
1563             }
1564 
1565             // Now loop through the notes list and mark them as pinned
1566             for (Note pinnedNote : pinnedNotesList) {
1567                 pinnedNote.setPinned(!pinnedNote.isPinned());
1568                 pinnedNote.setModificationDate(Calendar.getInstance());
1569                 pinnedNote.save();
1570             }
1571 
1572             return null;
1573         }
1574 
1575         @Override
1576         protected void onPostExecute(Void aVoid) {
1577             NoteListFragment fragment = mNoteListFragmentReference.get();
1578             fragment.mActionMode.finish();
1579             fragment.refreshList();
1580         }
1581     }
1582 
1583     private static class TrashNotesTask extends AsyncTask&lt;Void, Void, Void&gt; {
1584         private List&lt;String&gt; mDeletedNoteIds = new ArrayList&lt;&gt;();
1585         private SoftReference&lt;NoteListFragment&gt; mNoteListFragmentReference;
1586         private SparseBooleanArray mSelectedRows = new SparseBooleanArray();
1587 
1588         private TrashNotesTask(NoteListFragment context) {
1589             mNoteListFragmentReference = new SoftReference&lt;&gt;(context);
1590         }
1591 
1592         @Override
1593         protected void onPreExecute() {
1594             NoteListFragment fragment = mNoteListFragmentReference.get();
1595             mSelectedRows = fragment.getListView().getCheckedItemPositions();
1596         }
1597 
1598         @Override
1599         protected Void doInBackground(Void... args) {
1600             NoteListFragment fragment = mNoteListFragmentReference.get();
1601             // Get the checked notes and add them to the deletedNotesList
1602             // We can&#x27;t modify the note in this loop because the adapter could change
1603             List&lt;Note&gt; deletedNotesList = new ArrayList&lt;&gt;();
1604 
1605             for (int i = 0; i &lt; mSelectedRows.size(); i++) {
1606                 if (mSelectedRows.valueAt(i)) {
1607                     deletedNotesList.add(fragment.mNotesAdapter.getItem(mSelectedRows.keyAt(i)));
1608                 }
1609             }
1610 
1611             // Now loop through the notes list and mark them as deleted
1612             for (Note deletedNote : deletedNotesList) {
1613                 mDeletedNoteIds.add(deletedNote.getSimperiumKey());
1614                 deletedNote.setDeleted(!deletedNote.isDeleted());
1615                 deletedNote.setModificationDate(Calendar.getInstance());
1616                 deletedNote.save();
1617             }
1618 
1619             return null;
1620         }
1621 
1622         @Override
1623         protected void onPostExecute(Void aVoid) {
1624             NoteListFragment fragment = mNoteListFragmentReference.get();
1625             NotesActivity notesActivity = ((NotesActivity) fragment.getActivity());
1626 
1627             if (notesActivity != null) {
1628                 notesActivity.showUndoBarWithNoteIds(mDeletedNoteIds);
1629             }
1630 
1631             fragment.refreshList();
1632         }
1633     }
1634 }
 
 
 
 
 </pre></td>
                            <td><pre>   1 package com.automattic.simplenote;
   2 
   3 import android.animation.ObjectAnimator;
   4 import android.annotation.SuppressLint;
   5 import android.content.Context;
   6 import android.content.Intent;
   7 import android.content.SharedPreferences;
   8 import android.database.Cursor;
   9 import android.database.sqlite.SQLiteException;
  10 import android.os.AsyncTask;
  11 import android.os.Bundle;
  12 import android.os.Handler;
  13 import android.text.SpannableString;
  14 import android.text.SpannableStringBuilder;
  15 import android.text.TextUtils;
  16 import android.text.style.AbsoluteSizeSpan;
  17 import android.text.style.TextAppearanceSpan;
  18 import android.util.Log;
  19 import android.util.SparseBooleanArray;
  20 import android.util.TypedValue;
  21 import android.view.ActionMode;
  22 import android.view.Gravity;
  23 import android.view.HapticFeedbackConstants;
  24 import android.view.LayoutInflater;
  25 import android.view.Menu;
  26 import android.view.MenuInflater;
  27 import android.view.MenuItem;
  28 import android.view.MotionEvent;
  29 import android.view.View;
  30 import android.view.ViewGroup;
  31 import android.widget.AbsListView;
  32 import android.widget.AdapterView;
  33 import android.widget.CursorAdapter;
  34 import android.widget.ImageButton;
  35 import android.widget.ImageView;
  36 import android.widget.LinearLayout;
  37 import android.widget.ListView;
  38 import android.widget.RelativeLayout;
  39 import android.widget.TextView;
  40 import android.widget.Toast;
  41 import androidx.annotation.DrawableRes;
  42 import androidx.annotation.NonNull;
  43 import androidx.annotation.StringRes;
  44 import androidx.appcompat.widget.PopupMenu;
  45 import androidx.fragment.app.ListFragment;
  46 import androidx.preference.PreferenceManager;
  47 import androidx.recyclerview.widget.DiffUtil;
  48 import androidx.recyclerview.widget.LinearLayoutManager;
  49 import androidx.recyclerview.widget.RecyclerView;
  50 import com.automattic.simplenote.analytics.AnalyticsTracker;
  51 import com.automattic.simplenote.models.Note;
  52 import com.automattic.simplenote.models.Preferences;
  53 import com.automattic.simplenote.models.Suggestion;
  54 import com.automattic.simplenote.models.Tag;
  55 import com.automattic.simplenote.utils.AppLog.Type;
  56 import com.automattic.simplenote.utils.AppLog;
  57 import com.automattic.simplenote.utils.BrowserUtils;
  58 import com.automattic.simplenote.utils.ChecklistUtils;
  59 import com.automattic.simplenote.utils.DateTimeUtils;
  60 import com.automattic.simplenote.utils.DisplayUtils;
  61 import com.automattic.simplenote.utils.DrawableUtils;
  62 import com.automattic.simplenote.utils.NetworkUtils;
  63 import com.automattic.simplenote.utils.PrefUtils;
  64 import com.automattic.simplenote.utils.SearchSnippetFormatter;
  65 import com.automattic.simplenote.utils.SearchTokenizer;
  66 import com.automattic.simplenote.utils.SimplenoteLinkify;
  67 import com.automattic.simplenote.utils.StrUtils;
  68 import com.automattic.simplenote.utils.TextHighlighter;
  69 import com.automattic.simplenote.utils.ThemeUtils;
  70 import com.automattic.simplenote.utils.WidgetUtils;
  71 import com.google.android.material.floatingactionbutton.FloatingActionButton;
  72 import com.google.android.material.snackbar.Snackbar;
  73 import com.simperium.client.Bucket.ObjectCursor;
  74 import com.simperium.client.Bucket;
  75 import com.simperium.client.BucketObjectMissingException;
  76 import com.simperium.client.BucketObjectNameInvalid;
  77 import com.simperium.client.Query;
  78 import java.lang.ref.SoftReference;
  79 import java.util.ArrayList;
  80 import java.util.Calendar;
  81 import java.util.List;
  82 import java.util.regex.Matcher;
  83 import java.util.regex.Pattern;
  84 import static com.automattic.simplenote.analytics.AnalyticsTracker.CATEGORY_SEARCH;
  85 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.RECENT_SEARCH_TAPPED;
  86 import static com.automattic.simplenote.models.Note.TAGS_PROPERTY;
  87 import static com.automattic.simplenote.models.Preferences.MAX_RECENT_SEARCHES;
  88 import static com.automattic.simplenote.models.Preferences.PREFERENCES_OBJECT_KEY;
  89 import static com.automattic.simplenote.models.Suggestion.Type.HISTORY;
  90 import static com.automattic.simplenote.models.Suggestion.Type.QUERY;
  91 import static com.automattic.simplenote.models.Suggestion.Type.TAG;
  92 import static com.automattic.simplenote.models.Tag.NAME_PROPERTY;
  93 import static com.automattic.simplenote.utils.PrefUtils.ALPHABETICAL_ASCENDING;
  94 import static com.automattic.simplenote.utils.PrefUtils.ALPHABETICAL_DESCENDING;
  95 import static com.automattic.simplenote.utils.PrefUtils.DATE_CREATED_ASCENDING;
  96 import static com.automattic.simplenote.utils.PrefUtils.DATE_CREATED_DESCENDING;
  97 import static com.automattic.simplenote.utils.PrefUtils.DATE_MODIFIED_ASCENDING;
  98 import static com.automattic.simplenote.utils.PrefUtils.DATE_MODIFIED_DESCENDING;
  99 
 100 
 101 /**
 102  * A list fragment representing a list of Notes. This fragment also supports
 103  * tablet devices by allowing list items to be given an &#x27;activated&#x27; state upon
 104  * selection. This helps indicate which item is currently being viewed in a
 105  * {@link NoteEditorFragment}.
 106  * &lt;p&gt;
 107  * Activities containing this fragment MUST implement the {@link Callbacks}
 108  * interface.
 109  */
<abbr title=" 110 public class NoteListFragment extends ListFragment implements AdapterView.OnItemLongClickListener , AbsListView.MultiChoiceModeListener , Bucket.Listener&lt;Preferences&gt; {"> 110 public class NoteListFragment extends ListFragment implements AdapterView.OnItemLongClickListener , AbsLiðŸ”µ</abbr>
 111     public static final String TAG_PREFIX = &quot;tag:&quot;;
 112 
 113     /**
 114      * The preferences key representing the activated item position. Only used on tablets.
 115      */
 116     private static final String STATE_ACTIVATED_POSITION = &quot;activated_position&quot;;
 117 
 118     private static final int POPUP_MENU_FIRST_ITEM_POSITION = 0;
 119 
 120     public static final String ACTION_NEW_NOTE = &quot;com.automattic.simplenote.NEW_NOTE&quot;;
 121 
 122     /**
 123      * A dummy implementation of the {@link Callbacks} interface that does
 124      * nothing. Used only when this fragment is not attached to an activity.
 125      */
 126     private static Callbacks sCallbacks = new Callbacks() {
 127         @Override
 128         public void onActionModeCreated() {
 129         }
 130 
 131         @Override
 132         public void onActionModeDestroyed() {
 133         }
 134 
 135         @Override
<abbr title=" 136         public void onNoteSelected(String noteID, String matchOffsets, boolean isMarkdownEnabled, boolean isPreviewEnabled) {"> 136         public void onNoteSelected(String noteID, String matchOffsets, boolean isMarkdownEnabled, booleanðŸ”µ</abbr>
 137         }
 138     };
 139 
 140     protected NotesCursorAdapter mNotesAdapter;
 141 
 142     protected String mSearchString;
 143 
 144     private Bucket&lt;Preferences&gt; mBucketPreferences;
 145 
 146     private Bucket&lt;Tag&gt; mBucketTag;
 147 
 148     private ActionMode mActionMode;
 149 
 150     private View mRootView;
 151 
 152     private ImageView mEmptyViewImage;
 153 
 154     private TextView mEmptyViewText;
 155 
 156     private View mDividerLine;
 157 
 158     private FloatingActionButton mFloatingActionButton;
 159 
 160     private boolean mIsCondensedNoteList;
 161 
 162     private boolean mIsSearching;
 163 
 164     private ImageView mSortDirection;
 165 
 166     private ListView mList;
 167 
 168     private ObjectAnimator mSortDirectionAnimation;
 169 
 170     private RecyclerView mSuggestionList;
 171 
 172     private RelativeLayout mSortLayoutContent;
 173 
 174     private RelativeLayout mSuggestionLayout;
 175 
 176     private SharedPreferences mPreferences;
 177 
 178     private String mSelectedNoteId;
 179 
 180     private SuggestionAdapter mSuggestionAdapter;
 181 
 182     private TextView mSortOrder;
 183 
 184     private RefreshListTask mRefreshListTask;
 185 
 186     private RefreshListForSearchTask mRefreshListForSearchTask;
 187 
 188     private int mDeletedItemIndex;
 189 
 190     private int mPreferenceSortOrder;
 191 
 192     private int mTitleFontSize;
 193 
 194     private int mPreviewFontSize;
 195 
 196     private boolean mIsSortDown;
 197 
 198     private boolean mIsSortReverse;
 199 
 200     /**
 201      * The fragment&#x27;s current callback object, which is notified of list item
 202      * clicks.
 203      */
 204     private Callbacks mCallbacks = sCallbacks;
 205 
 206     /**
 207      * The current activated item position. Only used on tablets.
 208      */
 209     private int mActivatedPosition = ListView.INVALID_POSITION;
 210 
 211     /**
 212      * Mandatory empty constructor for the fragment manager to instantiate the
 213      * fragment (e.g. upon screen orientation changes).
 214      */
 215     public NoteListFragment() {
 216     }
 217 
 218     @Override
 219     public boolean onItemLongClick(AdapterView&lt;?&gt; adapterView, View view, int position, long l) {
 220         getListView().setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);
 221         getListView().setItemChecked(position, true);
 222         if (mActionMode == null) {
 223             requireActivity().startActionMode(this);
 224         }
 225         return true;
 226     }
 227 
 228     @Override
 229     public boolean onCreateActionMode(ActionMode actionMode, Menu menu) {
 230         mCallbacks.onActionModeCreated();
 231         MenuInflater inflater = actionMode.getMenuInflater();
 232         inflater.inflate(R.menu.bulk_edit, menu);
 233         DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.actionModeTextColor);
 234         mActionMode = actionMode;
<abbr title=" 235         int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.background_dark;"> 235         int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.bðŸ”µ</abbr>
<abbr title=" 236         requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().getTheme()));"> 236         requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActiviðŸ”µ</abbr>
 237         return true;
 238     }
 239 
 240     @Override
 241     public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 242         return false;
 243     }
 244 
 245     @Override
 246     public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 247         if (getListView().getCheckedItemIds().length &gt; 0) {
 248             switch (item.getItemId()) {
 249                 case R.id.menu_link :
 250                     BrowserUtils.copyToClipboard(requireContext(), getSelectedNoteLinks());
 251                     mode.finish();
 252                     break;
 253                 case R.id.menu_trash :
 254                     new TrashNotesTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 255                     break;
 256                 case R.id.menu_pin :
 257                     new PinNotesTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 258                     break;
 259             }
 260         }
 261         return false;
 262     }
 263 
 264     private String getSelectedNoteLinks() {
 265         SparseBooleanArray checkedPositions = getListView().getCheckedItemPositions();
 266         StringBuilder links = new StringBuilder();
 267 
 268         for (int i = 0; i &lt; checkedPositions.size(); i++) {
 269             if (checkedPositions.valueAt(i)) {
 270                 Note note = mNotesAdapter.getItem(checkedPositions.keyAt(i));
<abbr title=" 271                 links.append(SimplenoteLinkify.getNoteLinkWithTitle(note.getTitle(), note.getSimperiumKey())).append(&quot;\n&quot;);"> 271                 links.append(SimplenoteLinkify.getNoteLinkWithTitle(note.getTitle(), note.getSimperiumKeyðŸ”µ</abbr>
 272             }
 273         }
 274 
 275         return links.toString();
 276     }
 277 
 278     @Override
 279     public void onDestroyActionMode(ActionMode mode) {
 280         mCallbacks.onActionModeDestroyed();
 281         mActionMode = null;
 282         new Handler().postDelayed(
 283             new Runnable() {
 284                 @Override
 285                 public void run() {
 286                     if (getActivity() != null) {
 287                         NotesActivity notesActivity = (NotesActivity) getActivity();
 288                         setActivateOnItemClick(DisplayUtils.isLargeScreenLandscape(notesActivity));
 289                         notesActivity.showDetailPlaceholder();
 290                     }
 291 
<abbr title=" 292                     requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 292                     requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.colðŸ”µ</abbr>
 293                 }
 294             },
 295             requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime)
 296         );
 297     }
 298 
 299     @Override
<abbr title=" 300     public void onItemCheckedStateChanged(ActionMode actionMode, int position, long id, boolean checked) {"> 300     public void onItemCheckedStateChanged(ActionMode actionMode, int position, long id, boolean checked) ðŸ”µ</abbr>
 301         int checkedCount = getListView().getCheckedItemCount();
 302         if (checkedCount == 0) {
 303             actionMode.setTitle(&quot;&quot;);
 304         } else {
<abbr title=" 305             actionMode.setTitle(getResources().getQuantityString(R.plurals.selected_notes, checkedCount, checkedCount));"> 305             actionMode.setTitle(getResources().getQuantityString(R.plurals.selected_notes, checkedCount, ðŸ”µ</abbr>
 306         }
 307         actionMode.invalidate();
 308     }
 309 
 310     @Override
 311     public void onCreate(Bundle savedInstanceState) {
 312         super.onCreate(savedInstanceState);
 313         AppLog.add(Type.NETWORK, NetworkUtils.getNetworkInfo(requireContext()));
 314         AppLog.add(Type.SCREEN, &quot;Created (NoteListFragment)&quot;);
 315         mBucketPreferences = ((Simplenote) (requireActivity().getApplication())).getPreferencesBucket();
 316         mBucketTag = ((Simplenote) (requireActivity().getApplication())).getTagsBucket();
 317     }
 318 
 319     protected void getPrefs() {
 320         mPreferenceSortOrder = PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER);
<abbr title=" 321         mIsCondensedNoteList = PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_CONDENSED_LIST, false);"> 321         mIsCondensedNoteList = PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_CONDENSED_LIST, false)ðŸ”µ</abbr>
 322         mTitleFontSize = PrefUtils.getFontSize(getActivity());
 323         mPreviewFontSize = mTitleFontSize - 2;
 324     }
 325 
 326     @Override
<abbr title=" 327     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {"> 327     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceSðŸ”µ</abbr>
 328         return inflater.inflate(R.layout.fragment_notes_list, container, false);
 329     }
 330 
 331     @Override
 332     public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
 333         super.onViewCreated(view, savedInstanceState);
 334 
 335         NotesActivity notesActivity = (NotesActivity) requireActivity();
 336 
 337         if (ACTION_NEW_NOTE.equals(notesActivity.getIntent().getAction()) &amp;&amp;
 338                 !notesActivity.userIsUnauthorized()){
 339             //if user tap on &quot;app shortcut&quot;, create a new note
 340             createNewNote(&quot;new_note_shortcut&quot;);
 341         }
 342 
 343         mPreferences = PreferenceManager.getDefaultSharedPreferences(requireContext());
 344         mRootView = view.findViewById(R.id.list_root);
 345 
 346         LinearLayout emptyView = view.findViewById(android.R.id.empty);
 347         emptyView.setVisibility(View.GONE);
 348         mEmptyViewImage = emptyView.findViewById(R.id.image);
 349         mEmptyViewText = emptyView.findViewById(R.id.text);
 350         setEmptyListImage(R.drawable.ic_notes_24dp);
 351         setEmptyListMessage(getString(R.string.empty_notes_all));
 352         mDividerLine = view.findViewById(R.id.divider_line);
 353 
 354         if (DisplayUtils.isLargeScreenLandscape(notesActivity)) {
 355             setActivateOnItemClick(true);
 356             mDividerLine.setVisibility(View.VISIBLE);
 357         }
 358 
 359         mFloatingActionButton = view.findViewById(R.id.fab_button);
 360         mFloatingActionButton.setOnClickListener(new View.OnClickListener() {
 361             @Override
 362             public void onClick(View v) {
 363                 createNewNote(&quot;action_bar_button&quot;);
 364             }
 365         });
 366         mFloatingActionButton.setOnLongClickListener(new View.OnLongClickListener() {
 367             @Override
 368             public boolean onLongClick(View v) {
 369                 if (v.isHapticFeedbackEnabled()) {
 370                     v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
 371                 }
 372 
<abbr title=" 373                 Toast.makeText(getContext(), requireContext().getString(R.string.new_note), Toast.LENGTH_SHORT).show();"> 373                 Toast.makeText(getContext(), requireContext().getString(R.string.new_note), Toast.LENGTH_ðŸ”µ</abbr>
 374                 return true;
 375             }
 376         });
 377 
 378         mSuggestionLayout = view.findViewById(R.id.suggestion_layout);
 379         mSuggestionList = view.findViewById(R.id.suggestion_list);
 380         mSuggestionAdapter = new SuggestionAdapter(new ArrayList&lt;Suggestion&gt;());
 381         mSuggestionList.setAdapter(mSuggestionAdapter);
 382         mSuggestionList.setLayoutManager(new LinearLayoutManager(requireContext()));
 383         @SuppressLint(&quot;InflateParams&quot;)
<abbr title=" 384         LinearLayout sortLayoutContainer = (LinearLayout) getLayoutInflater().inflate(R.layout.search_sort, null, false);"> 384         LinearLayout sortLayoutContainer = (LinearLayout) getLayoutInflater().inflate(R.layout.search_sorðŸ”µ</abbr>
 385         mSortLayoutContent = sortLayoutContainer.findViewById(R.id.sort_content);
 386         mSortLayoutContent.setVisibility(mIsSearching ? View.VISIBLE : View.GONE);
 387         mSortOrder = sortLayoutContainer.findViewById(R.id.sort_order);
 388         mSortLayoutContent.setOnClickListener(new View.OnClickListener() {
 389             @Override
 390             public void onClick(View v) {
 391                 PopupMenu popup = new PopupMenu(mSortOrder.getContext(), mSortOrder, Gravity.START);
 392                 MenuInflater inflater = popup.getMenuInflater();
 393                 inflater.inflate(R.menu.search_sort, popup.getMenu());
 394                 popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {
 395                     @Override
 396                     public boolean onMenuItemClick(MenuItem item) {
 397                         // Do nothing when same sort is selected.
 398                         if (mSortOrder.getText().equals(item.getTitle())) {
 399                             return false;
 400                         }
 401 
 402                         mSortOrder.setText(item.getTitle());
 403 
 404                         switch (item.getItemId()) {
 405                             case R.id.search_alphabetically:
 406                                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER,
 407                                     String.valueOf(ALPHABETICAL_ASCENDING)
 408                                 ).apply();
 409 
 410                                 // If arrow is down, rotate it up for ascending direction.
 411                                 if (mIsSortDown &amp;&amp; !mIsSortReverse) {
 412                                     mSortDirectionAnimation.start();
 413                                     mIsSortReverse = true;
 414                                 } else if (!mIsSortDown &amp;&amp; mIsSortReverse) {
 415                                     mSortDirectionAnimation.reverse();
 416                                     mIsSortReverse = false;
 417                                 }
 418 
 419                                 refreshListForSearch();
 420                                 return true;
 421                             case R.id.search_created:
 422                                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER,
 423                                     String.valueOf(DATE_CREATED_DESCENDING)
 424                                 ).apply();
 425 
 426                                 // If arrow is up, rotate it down for descending direction.
 427                                 if (mIsSortDown &amp;&amp; mIsSortReverse) {
 428                                     mSortDirectionAnimation.reverse();
 429                                     mIsSortReverse = false;
 430                                 } else if (!mIsSortDown &amp;&amp; !mIsSortReverse) {
 431                                     mSortDirectionAnimation.start();
 432                                     mIsSortReverse = true;
 433                                 }
 434 
 435                                 refreshListForSearch();
 436                                 return true;
 437                             case R.id.search_modified:
 438                                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER,
 439                                     String.valueOf(DATE_MODIFIED_DESCENDING)
 440                                 ).apply();
 441 
 442                                 // If arrow is up, rotate it down for descending direction.
 443                                 if (mIsSortDown &amp;&amp; mIsSortReverse) {
 444                                     mSortDirectionAnimation.reverse();
 445                                     mIsSortReverse = false;
 446                                 } else if (!mIsSortDown &amp;&amp; !mIsSortReverse) {
 447                                     mSortDirectionAnimation.start();
 448                                     mIsSortReverse = true;
 449                                 }
 450 
 451                                 refreshListForSearch();
 452                                 return true;
 453                             default:
 454                                 return false;
 455                         }
 456                     }
 457                 });
 458                 popup.show();
 459             }
 460         });
 461         mList = view.findViewById(android.R.id.list);
 462         mList.addHeaderView(sortLayoutContainer);
 463 
 464         mNotesAdapter = new NotesCursorAdapter(requireActivity().getBaseContext(), null, 0);
 465         setListAdapter(mNotesAdapter);
 466 
 467         getListView().setOnItemLongClickListener(this);
 468         getListView().setMultiChoiceModeListener(this);
 469 
 470         mSortDirection = sortLayoutContainer.findViewById(R.id.sort_direction);
 471         ImageView sortDirectionSwitch = sortLayoutContainer.findViewById(R.id.sort_direction_switch);
 472         sortDirectionSwitch.setImageResource(R.drawable.ic_sort_order_24dp);
 473         sortDirectionSwitch.setOnClickListener(new View.OnClickListener() {
 474             @Override
 475             public void onClick(View v) {
 476                 if (mIsSortReverse) {
 477                     mSortDirectionAnimation.reverse();
 478                 } else {
 479                     mSortDirectionAnimation.start();
 480                 }
 481 
 482                 mIsSortReverse = !mIsSortReverse;
 483                 switchSortDirection();
 484                 refreshListForSearch();
 485             }
 486         });
 487         sortDirectionSwitch.setOnLongClickListener(new View.OnLongClickListener() {
 488             @Override
 489             public boolean onLongClick(View v) {
 490                 if (v.isHapticFeedbackEnabled()) {
 491                     v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
 492                 }
 493 
<abbr title=" 494                 Toast.makeText(requireContext(), requireContext().getString(R.string.sort_search_reverse_order), Toast.LENGTH_SHORT).show();"> 494                 Toast.makeText(requireContext(), requireContext().getString(R.string.sort_search_reverse_ðŸ”µ</abbr>
 495                 return true;
 496             }
 497         });
 498     }
 499 
 500     public void showListPadding(boolean show) {
 501         mList.setPadding(
 502             mList.getPaddingLeft(),
 503             mList.getPaddingTop(),
 504             mList.getPaddingRight(),
 505             show ? (int) getResources().getDimension(R.dimen.note_list_item_padding_bottom_button) : 0
 506         );
 507     }
 508 
 509     private @StringRes int getSortOrderText() {
 510         switch (PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER)) {
 511             case ALPHABETICAL_ASCENDING:
 512             case ALPHABETICAL_DESCENDING:
 513                 return R.string.sort_search_alphabetically;
 514             case DATE_CREATED_ASCENDING:
 515             case DATE_CREATED_DESCENDING:
 516                 return R.string.sort_search_created;
 517             case DATE_MODIFIED_ASCENDING:
 518             case DATE_MODIFIED_DESCENDING:
 519             default:
 520                 return R.string.sort_search_modified;
 521         }
 522     }
 523 
 524     private void setSortDirection() {
 525         if (mIsSortReverse) {
 526             mSortDirectionAnimation.reverse();
 527             mIsSortReverse = false;
 528         }
 529 
 530         switch (PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER)) {
 531             case ALPHABETICAL_ASCENDING:
 532             case DATE_CREATED_ASCENDING:
 533             case DATE_MODIFIED_ASCENDING:
 534                 mSortDirection.setContentDescription(getString(R.string.description_up));
 535                 mSortDirection.setImageResource(R.drawable.ic_arrow_up_16dp);
 536                 mIsSortDown = false;
 537                 break;
 538             case ALPHABETICAL_DESCENDING:
 539             case DATE_CREATED_DESCENDING:
 540             case DATE_MODIFIED_DESCENDING:
 541             default:
 542                 mSortDirection.setContentDescription(getString(R.string.description_down));
 543                 mSortDirection.setImageResource(R.drawable.ic_arrow_down_16dp);
 544                 mIsSortDown = true;
 545                 break;
 546         }
 547 
 548         mSortDirectionAnimation = ObjectAnimator.ofFloat(
 549             mSortDirection,
 550             View.ROTATION,
 551             0f,
 552             mIsSortDown ? -180f : 180f
 553         ).setDuration(getResources().getInteger(android.R.integer.config_shortAnimTime));
 554     }
 555 
 556     private void switchSortDirection() {
 557         switch (PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER)) {
 558             case DATE_MODIFIED_DESCENDING:
<abbr title=" 559                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_MODIFIED_ASCENDING)).apply();"> 559                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_MODIFIED_ASCðŸ”µ</abbr>
 560                 break;
 561             case DATE_MODIFIED_ASCENDING:
<abbr title=" 562                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_MODIFIED_DESCENDING)).apply();"> 562                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_MODIFIED_DESðŸ”µ</abbr>
 563                 break;
 564             case DATE_CREATED_DESCENDING:
<abbr title=" 565                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_CREATED_ASCENDING)).apply();"> 565                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_CREATED_ASCEðŸ”µ</abbr>
 566                 break;
 567             case DATE_CREATED_ASCENDING:
<abbr title=" 568                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_CREATED_DESCENDING)).apply();"> 568                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_CREATED_DESCðŸ”µ</abbr>
 569                 break;
 570             case ALPHABETICAL_ASCENDING:
<abbr title=" 571                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(ALPHABETICAL_DESCENDING)).apply();"> 571                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(ALPHABETICAL_DESCðŸ”µ</abbr>
 572                 break;
 573             case ALPHABETICAL_DESCENDING:
<abbr title=" 574                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(ALPHABETICAL_ASCENDING)).apply();"> 574                 mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(ALPHABETICAL_ASCEðŸ”µ</abbr>
 575                 break;
 576         }
 577     }
 578 
 579     public void createNewNote(String label){
 580         if (!isAdded()) return;
 581 
 582         addNote();
 583         AnalyticsTracker.track(
 584                 AnalyticsTracker.Stat.LIST_NOTE_CREATED,
 585                 AnalyticsTracker.CATEGORY_NOTE,
 586                 label
 587         );
 588     }
 589 
 590     @Override
 591     public void onAttach(@NonNull Context activity) {
 592         super.onAttach(activity);
 593 
 594         // Activities containing this fragment must implement its callbacks.
 595         if (!(activity instanceof Callbacks)) {
 596             throw new IllegalStateException(&quot;Activity must implement fragment&#x27;s callbacks.&quot;);
 597         }
 598 
 599         mCallbacks = (Callbacks) activity;
 600     }
 601 
 602     @Override
 603     public void onResume() {
 604         super.onResume();
 605         getPrefs();
 606 
 607         if (mIsSearching) {
 608             refreshListForSearch();
 609         } else {
 610             refreshList();
 611         }
 612 
 613         mBucketPreferences.start();
 614         mBucketPreferences.addOnDeleteObjectListener(this);
 615         mBucketPreferences.addOnNetworkChangeListener(this);
 616         mBucketPreferences.addOnSaveObjectListener(this);
 617     }
 618 
 619     @Override
 620     public void onPause() {
 621         super.onPause();
 622         mBucketPreferences.removeOnDeleteObjectListener(this);
 623         mBucketPreferences.removeOnNetworkChangeListener(this);
 624         mBucketPreferences.removeOnSaveObjectListener(this);
 625         mBucketPreferences.stop();
 626         AppLog.add(Type.SCREEN, &quot;Paused (NoteListFragment)&quot;);
 627     }
 628 
 629     @Override
 630     public void onDetach() {
 631         super.onDetach();
 632         // Restore sort order from Settings.
<abbr title=" 633         mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(mPreferenceSortOrder)).apply();"> 633         mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(mPreferenceSortOrder)).apðŸ”µ</abbr>
 634         // Reset the active callbacks interface to the dummy implementation.
 635         mCallbacks = sCallbacks;
 636     }
 637 
 638     public void setEmptyListImage(@DrawableRes int image) {
 639         if (mEmptyViewImage != null) {
 640             if (image != -1) {
 641                 mEmptyViewImage.setVisibility(View.VISIBLE);
 642                 mEmptyViewImage.setImageResource(image);
 643             } else {
 644                 mEmptyViewImage.setVisibility(View.GONE);
 645             }
 646         }
 647     }
 648 
 649     public void setEmptyListMessage(String message) {
 650         if (mEmptyViewText != null &amp;&amp; message != null) {
 651             mEmptyViewText.setText(message);
 652         }
 653     }
 654 
 655     @Override
 656     public void onListItemClick(@NonNull ListView listView, @NonNull View view, int position, long id) {
 657         if (!isAdded()) return;
 658         super.onListItemClick(listView, view, position, id);
 659 
 660         NoteViewHolder holder = (NoteViewHolder) view.getTag();
 661         String noteID = holder.getNoteId();
 662 
 663         if (noteID != null) {
 664             Note note = mNotesAdapter.getItem(position);
<abbr title=" 665             mCallbacks.onNoteSelected(noteID, holder.mMatchOffsets, note.isMarkdownEnabled(), note.isPreviewEnabled());"> 665             mCallbacks.onNoteSelected(noteID, holder.mMatchOffsets, note.isMarkdownEnabled(), note.isPrevðŸ”µ</abbr>
 666         }
 667 
 668         mActivatedPosition = position;
 669     }
 670 
 671     /**
 672      * Selects first row in the list if available
 673      */
 674     public void selectFirstNote() {
 675         if (mNotesAdapter.getCount() &gt; 0) {
 676             Note selectedNote = mNotesAdapter.getItem(mList.getHeaderViewsCount());
<abbr title=" 677             mCallbacks.onNoteSelected(selectedNote.getSimperiumKey(), null, selectedNote.isMarkdownEnabled(), selectedNote.isPreviewEnabled());"> 677             mCallbacks.onNoteSelected(selectedNote.getSimperiumKey(), null, selectedNote.isMarkdownEnableðŸ”µ</abbr>
 678         }
 679     }
 680 
 681     @Override
 682     public void onSaveInstanceState(@NonNull Bundle outState) {
 683         super.onSaveInstanceState(outState);
 684         if (mActivatedPosition != ListView.INVALID_POSITION) {
 685             // Serialize and persist the activated item position.
 686             outState.putInt(STATE_ACTIVATED_POSITION, mActivatedPosition);
 687         }
 688     }
 689 
 690     public View getRootView() {
 691         return mRootView;
 692     }
 693 
 694     /**
 695      * Turns on activate-on-click mode. When this mode is on, list items will be
 696      * given the &#x27;activated&#x27; state when touched.
 697      */
 698     public void setActivateOnItemClick(boolean activateOnItemClick) {
 699         // When setting CHOICE_MODE_SINGLE, ListView will automatically
 700         // give items the &#x27;activated&#x27; state when touched.
<abbr title=" 701         getListView().setChoiceMode(activateOnItemClick ? ListView.CHOICE_MODE_SINGLE : ListView.CHOICE_MODE_NONE);"> 701         getListView().setChoiceMode(activateOnItemClick ? ListView.CHOICE_MODE_SINGLE : ListView.CHOICE_MðŸ”µ</abbr>
 702     }
 703 
 704     public void setActivatedPosition(int position) {
 705         if (getListView() != null) {
 706             if (position == ListView.INVALID_POSITION) {
 707                 getListView().setItemChecked(mActivatedPosition, false);
 708             } else {
 709                 getListView().setItemChecked(position, true);
 710             }
 711 
 712             mActivatedPosition = position;
 713         }
 714     }
 715 
 716     public void setDividerVisible(boolean visible) {
 717         mDividerLine.setVisibility(visible ? View.VISIBLE : View.GONE);
 718     }
 719 
 720     public void setFloatingActionButtonVisible(boolean visible) {
 721         if (mFloatingActionButton == null) return;
 722 
 723         if (visible) {
 724             mFloatingActionButton.show();
 725         } else {
 726             mFloatingActionButton.hide();
 727         }
 728     }
 729 
 730     public void refreshList() {
 731         mSortOrder.setText(getSortOrderText());
 732         setSortDirection();
 733         refreshList(false);
 734     }
 735 
 736     public void refreshList(boolean fromNav) {
 737         if (mRefreshListTask != null &amp;&amp; mRefreshListTask.getStatus() != AsyncTask.Status.FINISHED)
 738             mRefreshListTask.cancel(true);
 739 
 740         mRefreshListTask = new RefreshListTask(this);
 741         mRefreshListTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, fromNav);
 742 
 743         WidgetUtils.updateNoteWidgets(requireActivity().getApplicationContext());
 744     }
 745 
 746     private void refreshListForSearch() {
<abbr title=" 747         if (mRefreshListForSearchTask != null &amp;&amp; mRefreshListForSearchTask.getStatus() != AsyncTask.Status.FINISHED) {"> 747         if (mRefreshListForSearchTask != null &amp;&amp; mRefreshListForSearchTask.getStatus() != AsyncTask.StatuðŸ”µ</abbr>
 748             mRefreshListForSearchTask.cancel(true);
 749         }
 750 
 751         mRefreshListForSearchTask = new RefreshListForSearchTask(this);
 752         mRefreshListForSearchTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 753     }
 754 
 755     public void refreshListFromNavSelect() {
 756         refreshList(true);
 757     }
 758 
 759     public ObjectCursor&lt;Note&gt; queryNotes() {
 760         if (!isAdded()) return null;
 761 
 762         NotesActivity notesActivity = (NotesActivity) requireActivity();
 763         Query&lt;Note&gt; query = notesActivity.getSelectedTag().query();
 764 
 765         String searchString = mSearchString;
 766         if (hasSearchQuery()) {
 767             searchString = queryTags(query, mSearchString);
 768         }
 769         if (!TextUtils.isEmpty(searchString)) {
 770             query.where(new Query.FullTextMatch(new SearchTokenizer(searchString)));
 771             query.include(new Query.FullTextOffsets(&quot;match_offsets&quot;));
<abbr title=" 772             query.include(new Query.FullTextSnippet(Note.MATCHED_TITLE_INDEX_NAME, Note.TITLE_INDEX_NAME));"> 772             query.include(new Query.FullTextSnippet(Note.MATCHED_TITLE_INDEX_NAME, Note.TITLE_INDEX_NAME)ðŸ”µ</abbr>
<abbr title=" 773             query.include(new Query.FullTextSnippet(Note.MATCHED_CONTENT_INDEX_NAME, Note.CONTENT_PROPERTY));"> 773             query.include(new Query.FullTextSnippet(Note.MATCHED_CONTENT_INDEX_NAME, Note.CONTENT_PROPERTðŸ”µ</abbr>
 774             query.include(Note.TITLE_INDEX_NAME, Note.CONTENT_PREVIEW_INDEX_NAME);
 775         } else {
 776             query.include(Note.TITLE_INDEX_NAME, Note.CONTENT_PREVIEW_INDEX_NAME);
 777         }
 778 
 779         query.include(Note.PINNED_INDEX_NAME);
 780         PrefUtils.sortNoteQuery(query, requireContext(), true);
 781         return query.execute();
 782     }
 783 
 784     private ObjectCursor&lt;Note&gt; queryNotesForSearch() {
 785         if (!isAdded()) {
 786             return null;
 787         }
 788 
 789         Query&lt;Note&gt; query = Note.all(((Simplenote) requireActivity().getApplication()).getNotesBucket());
 790         String searchString = mSearchString;
 791 
 792         if (hasSearchQuery()) {
 793             searchString = queryTags(query, mSearchString);
 794         }
 795 
 796         if (!TextUtils.isEmpty(searchString)) {
 797             query.where(new Query.FullTextMatch(new SearchTokenizer(searchString)));
 798             query.include(new Query.FullTextOffsets(&quot;match_offsets&quot;));
<abbr title=" 799             query.include(new Query.FullTextSnippet(Note.MATCHED_TITLE_INDEX_NAME, Note.TITLE_INDEX_NAME));"> 799             query.include(new Query.FullTextSnippet(Note.MATCHED_TITLE_INDEX_NAME, Note.TITLE_INDEX_NAME)ðŸ”µ</abbr>
<abbr title=" 800             query.include(new Query.FullTextSnippet(Note.MATCHED_CONTENT_INDEX_NAME, Note.CONTENT_PROPERTY));"> 800             query.include(new Query.FullTextSnippet(Note.MATCHED_CONTENT_INDEX_NAME, Note.CONTENT_PROPERTðŸ”µ</abbr>
 801             query.include(Note.TITLE_INDEX_NAME, Note.CONTENT_PREVIEW_INDEX_NAME);
 802         } else {
 803             query.include(Note.TITLE_INDEX_NAME, Note.CONTENT_PREVIEW_INDEX_NAME);
 804         }
 805 
 806         PrefUtils.sortNoteQuery(query, requireContext(), false);
 807         return query.execute();
 808     }
 809 
 810     private String queryTags(Query&lt;Note&gt; query, String searchString) {
 811         Pattern pattern = Pattern.compile(TAG_PREFIX + &quot;(.*?)( |$)&quot;);
 812         Matcher matcher = pattern.matcher(searchString);
 813         while (matcher.find()) {
 814             query.where(TAGS_PROPERTY, Query.ComparisonType.LIKE, matcher.group(1));
 815         }
 816         return matcher.replaceAll(&quot;&quot;);
 817     }
 818 
 819     public void addNote() {
 820 
 821         // Prevents jarring &#x27;New note...&#x27; from showing in the list view when creating a new note
 822         NotesActivity notesActivity = (NotesActivity) requireActivity();
 823         if (!DisplayUtils.isLargeScreenLandscape(notesActivity))
 824             notesActivity.stopListeningToNotesBucket();
 825 
 826         // Create &amp; save new note
 827         Simplenote simplenote = (Simplenote) requireActivity().getApplication();
 828         Bucket&lt;Note&gt; notesBucket = simplenote.getNotesBucket();
 829         final Note note = notesBucket.newObject();
 830         note.setCreationDate(Calendar.getInstance());
 831         note.setModificationDate(note.getCreationDate());
<abbr title=" 832         note.setMarkdownEnabled(PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_MARKDOWN_ENABLED, false));"> 832         note.setMarkdownEnabled(PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_MARKDOWN_ENABLED, falðŸ”µ</abbr>
 833 
 834         if (notesActivity.getSelectedTag() != null &amp;&amp; notesActivity.getSelectedTag().name != null) {
 835             String tagName = notesActivity.getSelectedTag().name;
<abbr title=" 836             if (!tagName.equals(getString(R.string.all_notes)) &amp;&amp; !tagName.equals(getString(R.string.trash)) &amp;&amp; !tagName.equals(getString(R.string.untagged_notes)))"> 836             if (!tagName.equals(getString(R.string.all_notes)) &amp;&amp; !tagName.equals(getString(R.string.trasðŸ”µ</abbr>
 837                 note.setTagString(tagName);
 838         }
 839 
 840         note.save();
 841 
 842         if (DisplayUtils.isLargeScreenLandscape(getActivity())) {
 843             // Hack: Simperium saves async so we add a small delay to ensure the new note is truly
 844             // saved before proceeding.
 845             new Handler().postDelayed(new Runnable() {
 846                 @Override
 847                 public void run() {
<abbr title=" 848                     mCallbacks.onNoteSelected(note.getSimperiumKey(), null, note.isMarkdownEnabled(), note.isPreviewEnabled());"> 848                     mCallbacks.onNoteSelected(note.getSimperiumKey(), null, note.isMarkdownEnabled(), notðŸ”µ</abbr>
 849                 }
 850             }, 50);
 851         } else {
 852             Bundle arguments = new Bundle();
 853             arguments.putString(NoteEditorFragment.ARG_ITEM_ID, note.getSimperiumKey());
 854             arguments.putBoolean(NoteEditorFragment.ARG_NEW_NOTE, true);
 855             arguments.putBoolean(NoteEditorFragment.ARG_MARKDOWN_ENABLED, note.isMarkdownEnabled());
 856             arguments.putBoolean(NoteEditorFragment.ARG_PREVIEW_ENABLED, note.isPreviewEnabled());
 857             Intent editNoteIntent = new Intent(getActivity(), NoteEditorActivity.class);
 858             editNoteIntent.putExtras(arguments);
 859 
 860             requireActivity().startActivityForResult(editNoteIntent, Simplenote.INTENT_EDIT_NOTE);
 861         }
 862     }
 863 
 864     public void setNoteSelected(String selectedNoteID) {
 865         // Loop through notes and set note selected if found
 866         //noinspection unchecked
 867         ObjectCursor&lt;Note&gt; cursor = (ObjectCursor&lt;Note&gt;) mNotesAdapter.getCursor();
 868         if (cursor != null) {
 869             for (int i = 0; i &lt; cursor.getCount(); i++) {
 870                 cursor.moveToPosition(i);
 871                 String noteKey = cursor.getSimperiumKey();
 872                 if (noteKey != null &amp;&amp; noteKey.equals(selectedNoteID)) {
 873                     setActivatedPosition(i + mList.getHeaderViewsCount());
 874                     return;
 875                 }
 876             }
 877         }
 878 
 879         // Didn&#x27;t find the note, let&#x27;s try again after the cursor updates (see RefreshListTask)
 880         mSelectedNoteId = selectedNoteID;
 881     }
 882 
 883     public void searchNotes(String searchString, boolean isSubmit) {
 884         mIsSearching = true;
 885         mSortLayoutContent.setVisibility(View.VISIBLE);
 886         mSuggestionLayout.setVisibility(View.VISIBLE);
 887         mSortOrder.setText(getSortOrderText());
 888 
 889         if (!searchString.equals(mSearchString)) {
 890             mSearchString = searchString;
 891         }
 892 
 893         if (searchString.isEmpty()) {
 894             getSearchItems();
 895         } else {
 896             getTagSuggestions(searchString);
 897         }
 898 
 899         if (isSubmit) {
 900             mSuggestionLayout.setVisibility(View.GONE);
 901             refreshListForSearch();
 902         }
 903     }
 904 
 905     /**
 906      * Clear search and load all notes
 907      */
 908     public void clearSearch() {
 909         mIsSearching = false;
 910         mSortLayoutContent.setVisibility(View.GONE);
 911         mSuggestionLayout.setVisibility(View.GONE);
 912         // Restore sort order from Settings.
<abbr title=" 913         mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(mPreferenceSortOrder)).apply();"> 913         mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(mPreferenceSortOrder)).apðŸ”µ</abbr>
 914         refreshList();
 915 
 916         if (mSearchString != null &amp;&amp; !mSearchString.equals(&quot;&quot;)) {
 917             mSearchString = null;
 918             refreshList();
 919         }
 920     }
 921 
 922     public boolean hasSearchQuery() {
 923         return mSearchString != null &amp;&amp; !mSearchString.equals(&quot;&quot;);
 924     }
 925 
 926     public void addSearchItem(String item, int index) {
 927         Preferences preferences = getPreferences();
 928 
 929         if (preferences != null) {
 930             List&lt;String&gt; recents = preferences.getRecentSearches();
 931             recents.remove(item);
 932             recents.add(index, item);
<abbr title=" 933             // Trim recent searches to MAX_RECENT_SEARCHES (currently 5) if size is greater than MAX_RECENT_SEARCHES."> 933             // Trim recent searches to MAX_RECENT_SEARCHES (currently 5) if size is greater than MAX_RECEðŸ”µ</abbr>
<abbr title=" 934             preferences.setRecentSearches(recents.subList(0, recents.size() &gt; MAX_RECENT_SEARCHES ? MAX_RECENT_SEARCHES : recents.size()));"> 934             preferences.setRecentSearches(recents.subList(0, recents.size() &gt; MAX_RECENT_SEARCHES ? MAX_RðŸ”µ</abbr>
 935             preferences.save();
 936         } else {
 937             Log.e(&quot;addSearchItem&quot;, &quot;Could not get preferences entity&quot;);
 938         }
 939     }
 940 
 941     private void deleteSearchItem(String item) {
 942         Preferences preferences = getPreferences();
 943 
 944         if (preferences != null) {
 945             List&lt;String&gt; recents = preferences.getRecentSearches();
 946             mDeletedItemIndex = recents.indexOf(item);
 947             recents.remove(item);
 948             preferences.setRecentSearches(recents);
 949             preferences.save();
 950         } else {
 951             Log.e(&quot;deleteSearchItem&quot;, &quot;Could not get preferences entity&quot;);
 952         }
 953     }
 954 
 955     private Preferences getPreferences() {
 956         try {
 957             return mBucketPreferences.get(PREFERENCES_OBJECT_KEY);
 958         } catch (BucketObjectMissingException exception) {
 959             try {
 960                 Preferences preferences = mBucketPreferences.newObject(PREFERENCES_OBJECT_KEY);
 961                 preferences.save();
 962                 return preferences;
 963             } catch (BucketObjectNameInvalid invalid) {
 964                 Log.e(&quot;getPreferences&quot;, &quot;Could not create preferences entity&quot;, invalid);
 965                 return null;
 966             }
 967         }
 968     }
 969 
 970     private void getSearchItems() {
 971         Preferences preferences = getPreferences();
 972 
 973         if (preferences != null) {
 974             ArrayList&lt;Suggestion&gt; suggestions = new ArrayList&lt;&gt;();
 975 
 976             for (String recent : preferences.getRecentSearches()) {
 977                 suggestions.add(new Suggestion(recent, HISTORY));
 978             }
 979 
 980             mSuggestionAdapter.updateItems(suggestions);
 981         } else {
 982             Log.e(&quot;getSearchItems&quot;, &quot;Could not get preferences entity&quot;);
 983         }
 984     }
 985 
 986     private void getTagSuggestions(String query) {
 987         ArrayList&lt;Suggestion&gt; suggestions = new ArrayList&lt;&gt;();
 988         suggestions.add(new Suggestion(query, QUERY));
<abbr title=" 989         Query&lt;Tag&gt; tags = Tag.all(mBucketTag).reorder().order(Tag.NOTE_COUNT_INDEX_NAME, Query.SortType.DESCENDING);"> 989         Query&lt;Tag&gt; tags = Tag.all(mBucketTag).reorder().order(Tag.NOTE_COUNT_INDEX_NAME, Query.SortType.DðŸ”µ</abbr>
 990 
 991         if (!query.endsWith(TAG_PREFIX)) {
 992             tags.where(NAME_PROPERTY, Query.ComparisonType.LIKE, &quot;%&quot; + query + &quot;%&quot;);
 993         }
 994 
 995         try (ObjectCursor&lt;Tag&gt; cursor = tags.execute()) {
 996             while (cursor.moveToNext()) {
 997                 suggestions.add(new Suggestion(cursor.getObject().getName(), TAG));
 998             }
 999         }
1000 
1001         mSuggestionAdapter = new SuggestionAdapter(suggestions);
1002         mSuggestionList.setAdapter(mSuggestionAdapter);
1003     }
1004 
1005     /**
1006      * A callback interface that all activities containing this fragment must
1007      * implement. This mechanism allows activities to be notified of item
1008      * selections.
1009      */
1010     public interface Callbacks {
1011         /**
1012          * Callback for when action mode is created.
1013          */
1014         public abstract void onActionModeCreated();
1015 
1016         /**
1017          * Callback for when action mode is destroyed.
1018          */
1019         public abstract void onActionModeDestroyed();
1020 
1021         /**
1022          * Callback for when a note has been selected.
1023          */
<abbr title="1024         public abstract void onNoteSelected(String noteID, String matchOffsets, boolean isMarkdownEnabled, boolean isPreviewEnabled);">1024         public abstract void onNoteSelected(String noteID, String matchOffsets, boolean isMarkdownEnabledðŸ”µ</abbr>
1025     }
1026 
1027     // view holder for NotesCursorAdapter
1028     private static class NoteViewHolder {
1029         private ImageView mPinned;
1030 
1031         private ImageView mPublished;
1032 
1033         private TextView mContent;
1034 
1035         private TextView mDate;
1036 
1037         private TextView mTitle;
1038 
1039         private String mMatchOffsets;
1040 
1041         private String mNoteId;
1042 
1043         private View mStatus;
1044 
1045         public String getNoteId() {
1046             return mNoteId;
1047         }
1048 
1049         public void setNoteId(String noteId) {
1050             mNoteId = noteId;
1051         }
1052     }
1053 
1054     public class NotesCursorAdapter extends CursorAdapter {
1055         private ObjectCursor&lt;Note&gt; mCursor;
1056 
<abbr title="1057         private SearchSnippetFormatter.SpanFactory mSnippetHighlighter = new TextHighlighter(requireActivity(), R.attr.listSearchHighlightForegroundColor, R.attr.listSearchHighlightBackgroundColor);">1057         private SearchSnippetFormatter.SpanFactory mSnippetHighlighter = new TextHighlighter(requireActivðŸ”µ</abbr>
1058 
1059         public NotesCursorAdapter(Context context, ObjectCursor&lt;Note&gt; c, int flags) {
1060             super(context, c, flags);
1061             mCursor = c;
1062         }
1063 
1064         public void changeCursor(ObjectCursor&lt;Note&gt; cursor) {
1065             mCursor = cursor;
1066             super.changeCursor(cursor);
1067         }
1068 
1069         @Override
1070         public Note getItem(int position) {
1071             mCursor.moveToPosition(position - mList.getHeaderViewsCount());
1072             return mCursor.getObject();
1073         }
1074 
1075         /* nbradbury - implemented &quot;holder pattern&quot; to boost performance with large note lists */
1076         @Override
1077         public View getView(final int position, View view, ViewGroup parent) {
1078             final NoteViewHolder holder;
1079             if (view == null) {
1080                 view = View.inflate(requireActivity().getBaseContext(), R.layout.note_list_row, null);
1081                 holder = new NoteViewHolder();
1082                 holder.mTitle = view.findViewById(R.id.note_title);
1083                 holder.mContent = view.findViewById(R.id.note_content);
1084                 holder.mDate = view.findViewById(R.id.note_date);
1085                 holder.mPinned = view.findViewById(R.id.note_pinned);
1086                 holder.mPublished = view.findViewById(R.id.note_published);
1087                 holder.mStatus = view.findViewById(R.id.note_status);
1088                 view.setTag(holder);
1089             } else {
1090                 holder = ((NoteViewHolder) (view.getTag()));
1091             }
1092             if (holder.mTitle.getTextSize() != mTitleFontSize) {
1093                 holder.mTitle.setTextSize(TypedValue.COMPLEX_UNIT_SP, mTitleFontSize);
1094                 holder.mContent.setTextSize(TypedValue.COMPLEX_UNIT_SP, mPreviewFontSize);
1095                 holder.mDate.setTextSize(TypedValue.COMPLEX_UNIT_SP, mPreviewFontSize);
1096             }
1097             if (position == getListView().getCheckedItemPosition()) {
1098                 view.setActivated(true);
1099             } else {
1100                 view.setActivated(false);
1101             }
1102             // for performance reasons we are going to get indexed values
1103             // from the cursor instead of instantiating the entire bucket object
1104             holder.mContent.setVisibility(mIsCondensedNoteList ? View.GONE : View.VISIBLE);
1105             mCursor.moveToPosition(position);
1106             holder.setNoteId(mCursor.getSimperiumKey());
1107             Calendar date = getDateByPreference(mCursor.getObject());
1108             holder.mDate.setText(date != null ? DateTimeUtils.getDateTextNumeric(date) : &quot;&quot;);
1109             holder.mDate.setVisibility(mIsSearching &amp;&amp; (date != null) ? View.VISIBLE : View.GONE);
1110             boolean isPinned = mCursor.getObject().isPinned();
1111             holder.mPinned.setVisibility((!isPinned) || mIsSearching ? View.GONE : View.VISIBLE);
1112             boolean isPublished = !mCursor.getObject().getPublishedUrl().isEmpty();
1113             holder.mPublished.setVisibility((!isPublished) || mIsSearching ? View.GONE : View.VISIBLE);
1114             boolean showIcons = isPinned || isPublished;
1115             boolean showDate = mIsSearching &amp;&amp; (date != null);
1116             holder.mStatus.setVisibility(showIcons || showDate ? View.VISIBLE : View.GONE);
1117             String title = mCursor.getString(mCursor.getColumnIndex(Note.TITLE_INDEX_NAME));
1118             if (TextUtils.isEmpty(title)) {
1119                 SpannableString newNoteString = new SpannableString(getString(R.string.new_note_list));
<abbr title="1120                 newNoteString.setSpan(new TextAppearanceSpan(getActivity(), R.style.UntitledNoteAppearance), 0, newNoteString.length(), SpannableString.SPAN_EXCLUSIVE_EXCLUSIVE);">1120                 newNoteString.setSpan(new TextAppearanceSpan(getActivity(), R.style.UntitledNoteAppearancðŸ”µ</abbr>
<abbr title="1121                 newNoteString.setSpan(new AbsoluteSizeSpan(mTitleFontSize, true), 0, newNoteString.length(), SpannableString.SPAN_EXCLUSIVE_EXCLUSIVE);">1121                 newNoteString.setSpan(new AbsoluteSizeSpan(mTitleFontSize, true), 0, newNoteString.lengthðŸ”µ</abbr>
1122                 holder.mTitle.setText(newNoteString);
1123             } else {
1124                 SpannableStringBuilder titleChecklistString = new SpannableStringBuilder(title);
<abbr title="1125                 titleChecklistString = ((SpannableStringBuilder) (ChecklistUtils.addChecklistSpansForRegexAndColor(getContext(), titleChecklistString, ChecklistUtils.CHECKLIST_REGEX, ThemeUtils.getThemeTextColorId(getContext()))));">1125                 titleChecklistString = ((SpannableStringBuilder) (ChecklistUtils.addChecklistSpansForRegeðŸ”µ</abbr>
1126                 holder.mTitle.setText(titleChecklistString);
1127             }
1128             holder.mMatchOffsets = null;
1129             int matchOffsetsIndex = mCursor.getColumnIndex(&quot;match_offsets&quot;);
1130             if (hasSearchQuery() &amp;&amp; (matchOffsetsIndex != (-1))) {
1131                 title = mCursor.getString(mCursor.getColumnIndex(Note.MATCHED_TITLE_INDEX_NAME));
<abbr title="1132                 String snippet = mCursor.getString(mCursor.getColumnIndex(Note.MATCHED_CONTENT_INDEX_NAME));">1132                 String snippet = mCursor.getString(mCursor.getColumnIndex(Note.MATCHED_CONTENT_INDEX_NAMEðŸ”µ</abbr>
1133                 holder.mMatchOffsets = mCursor.getString(matchOffsetsIndex);
1134                 try {
<abbr title="1135                     holder.mContent.setText(SearchSnippetFormatter.formatString(getContext(), snippet, mSnippetHighlighter, R.color.text_title_disabled));">1135                     holder.mContent.setText(SearchSnippetFormatter.formatString(getContext(), snippet, mSðŸ”µ</abbr>
<abbr title="1136                     holder.mTitle.setText(SearchSnippetFormatter.formatString(getContext(), title, mSnippetHighlighter, ThemeUtils.getThemeTextColorId(getContext())));">1136                     holder.mTitle.setText(SearchSnippetFormatter.formatString(getContext(), title, mSnippðŸ”µ</abbr>
1137                 } catch (java.lang.NullPointerException e) {
<abbr title="1138                     title = StrUtils.notNullStr(mCursor.getString(mCursor.getColumnIndex(Note.TITLE_INDEX_NAME)));">1138                     title = StrUtils.notNullStr(mCursor.getString(mCursor.getColumnIndex(Note.TITLE_INDEXðŸ”µ</abbr>
1139                     holder.mTitle.setText(title);
<abbr title="1140                     String matchedContentPreview = StrUtils.notNullStr(mCursor.getString(mCursor.getColumnIndex(Note.CONTENT_PREVIEW_INDEX_NAME)));">1140                     String matchedContentPreview = StrUtils.notNullStr(mCursor.getString(mCursor.getColumðŸ”µ</abbr>
1141                     holder.mContent.setText(matchedContentPreview);
1142                 }
1143             } else if (!mIsCondensedNoteList) {
<abbr title="1144                 String contentPreview = mCursor.getString(mCursor.getColumnIndex(Note.CONTENT_PREVIEW_INDEX_NAME));">1144                 String contentPreview = mCursor.getString(mCursor.getColumnIndex(Note.CONTENT_PREVIEW_INDðŸ”µ</abbr>
<abbr title="1145                 if (((title == null) || title.equals(contentPreview)) || title.equals(getString(R.string.new_note_list))) {">1145                 if (((title == null) || title.equals(contentPreview)) || title.equals(getString(R.string.ðŸ”µ</abbr>
1146                     holder.mContent.setVisibility(View.GONE);
1147                 } else {
1148                     holder.mContent.setText(contentPreview);
1149                     SpannableStringBuilder checklistString = new SpannableStringBuilder(contentPreview);
<abbr title="1150                     checklistString = ((SpannableStringBuilder) (ChecklistUtils.addChecklistSpansForRegexAndColor(getContext(), checklistString, ChecklistUtils.CHECKLIST_REGEX, R.color.text_title_disabled)));">1150                     checklistString = ((SpannableStringBuilder) (ChecklistUtils.addChecklistSpansForRegexðŸ”µ</abbr>
1151                     holder.mContent.setText(checklistString);
1152                 }
1153             }
1154             // Add mouse right click support for showing a popup menu
1155             view.setOnTouchListener(new View.OnTouchListener() {
1156                 @SuppressLint(&quot;ClickableViewAccessibility&quot;)
1157                 @Override
1158                 public boolean onTouch(View view, MotionEvent event) {
<abbr title="1159                     if ((event.getButtonState() == MotionEvent.BUTTON_SECONDARY) &amp;&amp; (event.getAction() == MotionEvent.ACTION_DOWN)) {">1159                     if ((event.getButtonState() == MotionEvent.BUTTON_SECONDARY) &amp;&amp; (event.getAction() ==ðŸ”µ</abbr>
1160                         showPopupMenuAtPosition(view, position);
1161                         return true;
1162                     }
1163                     return false;
1164                 }
1165             });
1166             return view;
1167         }
1168 
1169         @Override
1170         public View newView(Context context, Cursor cursor, ViewGroup viewGroup) {
1171             return null;
1172         }
1173 
1174         @Override
1175         public void bindView(View view, Context context, Cursor cursor) {
1176         }
1177     }
1178 
1179     @Override
1180     public void onBeforeUpdateObject(Bucket&lt;Preferences&gt; bucket, Preferences object) {
1181     }
1182 
1183     @Override
1184     public void onDeleteObject(Bucket&lt;Preferences&gt; bucket, Preferences object) {
1185         if (isAdded()) {
1186             requireActivity().runOnUiThread(new Runnable() {
1187                 @Override
1188                 public void run() {
1189                     getSearchItems();
1190                 }
1191             });
1192         }
1193     }
1194 
1195     @Override
1196     public void onNetworkChange(Bucket&lt;Preferences&gt; bucket, Bucket.ChangeType type, String key) {
1197         if (isAdded()) {
1198             requireActivity().runOnUiThread(new Runnable() {
1199                 @Override
1200                 public void run() {
1201                     getSearchItems();
1202                 }
1203             });
1204         }
1205     }
1206 
1207     @Override
1208     public void onSaveObject(Bucket&lt;Preferences&gt; bucket, Preferences object) {
1209         if (isAdded()) {
1210             requireActivity().runOnUiThread(new Runnable() {
1211                 @Override
1212                 public void run() {
1213                     getSearchItems();
1214                 }
1215             });
1216         }
1217     }
1218 
1219     private class SuggestionAdapter extends RecyclerView.Adapter&lt;SuggestionAdapter.ViewHolder&gt; {
1220         private final List&lt;Suggestion&gt; mSuggestions;
1221 
1222         private SuggestionAdapter(List&lt;Suggestion&gt; suggestions) {
1223             mSuggestions = new ArrayList&lt;&gt;(suggestions);
1224         }
1225 
1226         @Override
1227         public int getItemCount() {
1228             return mSuggestions.size();
1229         }
1230 
1231         @Override
1232         public int getItemViewType(int position) {
1233             return mSuggestions.get(position).getType();
1234         }
1235 
1236         @SuppressLint(&quot;SetTextI18n&quot;)
1237         @Override
1238         public void onBindViewHolder(@NonNull
1239         final ViewHolder holder, final int position) {
1240             switch (holder.mViewType) {
1241                 case HISTORY :
1242                     holder.mSuggestionText.setText(mSuggestions.get(position).getName());
1243                     holder.mSuggestionIcon.setImageResource(R.drawable.ic_history_24dp);
1244                     holder.mButtonDelete.setVisibility(View.VISIBLE);
1245                     break;
1246                 case QUERY :
1247                     holder.mSuggestionText.setText(mSuggestions.get(position).getName());
1248                     holder.mSuggestionIcon.setImageResource(R.drawable.ic_search_24dp);
1249                     holder.mButtonDelete.setVisibility(View.GONE);
1250                     break;
1251                 case TAG :
1252                     holder.mSuggestionText.setText(TAG_PREFIX + mSuggestions.get(position).getName());
1253                     holder.mSuggestionIcon.setImageResource(R.drawable.ic_tag_24dp);
1254                     holder.mButtonDelete.setVisibility(View.GONE);
1255                     break;
1256             }
1257             holder.mButtonDelete.setOnClickListener(new View.OnClickListener() {
1258                 @Override
1259                 public void onClick(View view) {
1260                     if (!isAdded()) {
1261                         return;
1262                     }
1263                     final String item = holder.mSuggestionText.getText().toString();
1264                     deleteSearchItem(item);
<abbr title="1265                     Snackbar.make(getRootView(), R.string.snackbar_deleted_recent_search, Snackbar.LENGTH_LONG).setAction(getString(R.string.undo), new View.OnClickListener() {">1265                     Snackbar.make(getRootView(), R.string.snackbar_deleted_recent_search, Snackbar.LENGTHðŸ”µ</abbr>
1266                         @Override
1267                         public void onClick(View view) {
1268                             addSearchItem(item, mDeletedItemIndex);
1269                         }
1270                     }).show();
1271                 }
1272             });
1273             holder.mButtonDelete.setOnLongClickListener(new View.OnLongClickListener() {
1274                 @Override
1275                 public boolean onLongClick(View v) {
1276                     if (v.isHapticFeedbackEnabled()) {
1277                         v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
1278                     }
<abbr title="1279                     Toast.makeText(getContext(), requireContext().getString(R.string.description_delete_item), Toast.LENGTH_SHORT).show();">1279                     Toast.makeText(getContext(), requireContext().getString(R.string.description_delete_iðŸ”µ</abbr>
1280                     return true;
1281                 }
1282             });
1283             holder.mView.setOnClickListener(new View.OnClickListener() {
1284                 @Override
1285                 public void onClick(View view) {
<abbr title="1286                     ((NotesActivity) (requireActivity())).submitSearch(holder.mSuggestionText.getText().toString());">1286                     ((NotesActivity) (requireActivity())).submitSearch(holder.mSuggestionText.getText().tðŸ”µ</abbr>
1287                     if (holder.mViewType == HISTORY) {
<abbr title="1288                         AnalyticsTracker.track(RECENT_SEARCH_TAPPED, CATEGORY_SEARCH, &quot;recent_search_tapped&quot;);">1288                         AnalyticsTracker.track(RECENT_SEARCH_TAPPED, CATEGORY_SEARCH, &quot;recent_search_tappðŸ”µ</abbr>
1289                     }
1290                 }
1291             });
1292         }
1293 
1294         @NonNull
1295         @Override
1296         public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
<abbr title="1297             return new ViewHolder(LayoutInflater.from(requireContext()).inflate(R.layout.search_suggestion, parent, false), viewType);">1297             return new ViewHolder(LayoutInflater.from(requireContext()).inflate(R.layout.search_suggestioðŸ”µ</abbr>
1298         }
1299 
1300         private class ViewHolder extends RecyclerView.ViewHolder {
1301             private ImageButton mButtonDelete;
1302 
1303             private ImageView mSuggestionIcon;
1304 
1305             private TextView mSuggestionText;
1306 
1307             private View mView;
1308 
1309             private int mViewType;
1310 
1311             private ViewHolder(View itemView, int viewType) {
1312                 super(itemView);
1313                 mView = itemView;
1314                 mViewType = viewType;
1315                 mSuggestionText = itemView.findViewById(R.id.suggestion_text);
1316                 mSuggestionIcon = itemView.findViewById(R.id.suggestion_icon);
1317                 mButtonDelete = itemView.findViewById(R.id.suggestion_delete);
1318             }
1319         }
1320 
1321         private void updateItems(List&lt;Suggestion&gt; suggestions) {
<abbr title="1322             DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new SuggestionDiffCallback(mSuggestions, suggestions));">1322             DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new SuggestionDiffCallback(mSuggestioðŸ”µ</abbr>
1323             mSuggestions.clear();
1324             mSuggestions.addAll(suggestions);
1325             diffResult.dispatchUpdatesTo(this);
1326         }
1327     }
1328 
1329     private class SuggestionDiffCallback extends DiffUtil.Callback {
1330         private List&lt;Suggestion&gt; mListNew;
1331 
1332         private List&lt;Suggestion&gt; mListOld;
1333 
1334         private SuggestionDiffCallback(List&lt;Suggestion&gt; oldList, List&lt;Suggestion&gt; newList) {
1335             mListOld = oldList;
1336             mListNew = newList;
1337         }
1338 
1339         @Override
1340         public boolean areContentsTheSame(int itemPositionOld, int itemPositionNew) {
1341             Suggestion itemOld = mListOld.get(itemPositionOld);
1342             Suggestion itemNew = mListNew.get(itemPositionNew);
1343             return itemOld.getName().equalsIgnoreCase(itemNew.getName());
1344         }
1345 
1346         @Override
1347         public boolean areItemsTheSame(int itemPositionOld, int itemPositionNew) {
1348             Suggestion itemOld = mListOld.get(itemPositionOld);
1349             Suggestion itemNew = mListNew.get(itemPositionNew);
1350             return itemOld.getName().equalsIgnoreCase(itemNew.getName());
1351         }
1352 
1353         @Override
1354         public int getNewListSize() {
1355             return mListNew.size();
1356         }
1357 
1358         @Override
1359         public int getOldListSize() {
1360             return mListOld.size();
1361         }
1362     }
1363 
1364     private Calendar getDateByPreference(Note note) {
1365         switch (PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER)) {
1366             case DATE_CREATED_ASCENDING:
1367             case DATE_CREATED_DESCENDING:
1368                 return note.getCreationDate();
1369             case DATE_MODIFIED_ASCENDING:
1370             case DATE_MODIFIED_DESCENDING:
1371                 return note.getModificationDate();
1372             case ALPHABETICAL_ASCENDING:
1373             case ALPHABETICAL_DESCENDING:
1374             default:
1375                 return null;
1376         }
1377     }
1378 
1379     private void showPopupMenuAtPosition(View view, int position) {
1380         if (view.getContext() == null) {
1381             return;
1382         }
1383 
1384         final Note note = mNotesAdapter.getItem(position + mList.getHeaderViewsCount());
1385         if (note == null) {
1386             return;
1387         }
1388 
1389         PopupMenu popup = new PopupMenu(view.getContext(), view, Gravity.END);
1390         MenuInflater inflater = popup.getMenuInflater();
1391         inflater.inflate(R.menu.bulk_edit, popup.getMenu());
1392 
1393         if (!getListView().isLongClickable()) {
1394             // If viewing the trash, remove pin menu item and change trash menu title to &#x27;Restore&#x27;
1395             popup.getMenu().removeItem(R.id.menu_pin);
1396             if (popup.getMenu().getItem(POPUP_MENU_FIRST_ITEM_POSITION) != null) {
1397                 popup.getMenu().getItem(POPUP_MENU_FIRST_ITEM_POSITION).setTitle(R.string.restore);
1398             }
1399         } else if (popup.getMenu().getItem(POPUP_MENU_FIRST_ITEM_POSITION) != null) {
1400             // If not viewing the trash, set pin menu title based on note pin state
1401             int pinTitle = note.isPinned() ? R.string.unpin_from_top : R.string.pin_to_top;
1402             popup.getMenu().getItem(POPUP_MENU_FIRST_ITEM_POSITION).setTitle(pinTitle);
1403         }
1404 
1405         popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {
1406             @Override
1407             public boolean onMenuItemClick(MenuItem item) {
1408                 switch (item.getItemId()) {
1409                     case R.id.menu_pin:
1410                         note.setPinned(!note.isPinned());
1411                         note.setModificationDate(Calendar.getInstance());
1412                         note.save();
1413                         refreshList();
1414                         return true;
1415                     case R.id.menu_trash:
1416                         note.setDeleted(!note.isDeleted());
1417                         note.setModificationDate(Calendar.getInstance());
1418                         note.save();
1419                         if (getActivity() != null) {
1420                             ((NotesActivity) getActivity()).updateViewsAfterTrashAction(note);
1421                         }
1422                         return true;
1423                     default:
1424                         return false;
1425                 }
1426             }
1427         });
1428 
1429         popup.show();
1430     }
1431 
1432     private static class RefreshListTask extends AsyncTask&lt;Boolean, Void, ObjectCursor&lt;Note&gt;&gt; {
1433         private SoftReference&lt;NoteListFragment&gt; mNoteListFragmentReference;
1434 
1435         private boolean mIsFromNavSelect;
1436 
1437         private RefreshListTask(NoteListFragment context) {
1438             mNoteListFragmentReference = new SoftReference&lt;&gt;(context);
1439         }
1440 
1441         @Override
1442         protected ObjectCursor&lt;Note&gt; doInBackground(Boolean... args) {
1443             NoteListFragment fragment = mNoteListFragmentReference.get();
1444             mIsFromNavSelect = args[0];
1445             return fragment.queryNotes();
1446         }
1447 
1448         @Override
1449         protected void onPostExecute(ObjectCursor&lt;Note&gt; cursor) {
1450             NoteListFragment fragment = mNoteListFragmentReference.get();
<abbr title="1451             if (((cursor == null) || (fragment.getActivity() == null)) || fragment.getActivity().isFinishing()) {">1451             if (((cursor == null) || (fragment.getActivity() == null)) || fragment.getActivity().isFinishðŸ”µ</abbr>
1452                 return;
1453             }
<abbr title="1454             // While using a Query.FullTextMatch it&#x27;s easy to enter an invalid term so catch the error and clear the cursor">1454             // While using a Query.FullTextMatch it&#x27;s easy to enter an invalid term so catch the error anðŸ”µ</abbr>
1455             int count;
1456             try {
1457                 fragment.mNotesAdapter.changeCursor(cursor);
1458                 count = fragment.mNotesAdapter.getCount();
1459             } catch (SQLiteException e) {
1460                 count = 0;
1461                 Log.e(Simplenote.TAG, &quot;Invalid SQL statement&quot;, e);
1462                 fragment.mNotesAdapter.changeCursor(null);
1463             }
1464             NotesActivity notesActivity = ((NotesActivity) (fragment.getActivity()));
1465             if (notesActivity != null) {
1466                 if (mIsFromNavSelect &amp;&amp; DisplayUtils.isLargeScreenLandscape(notesActivity)) {
1467                     if (count == 0) {
1468                         notesActivity.showDetailPlaceholder();
1469                     } else {
1470                         // Select the first note
1471                         fragment.selectFirstNote();
1472                     }
1473                 }
1474                 notesActivity.updateTrashMenuItem(true);
1475             }
1476             if (fragment.mSelectedNoteId != null) {
1477                 fragment.setNoteSelected(fragment.mSelectedNoteId);
1478                 fragment.mSelectedNoteId = null;
1479             }
1480         }
1481     }
1482 
1483     private static class RefreshListForSearchTask extends AsyncTask&lt;Void, Void, ObjectCursor&lt;Note&gt;&gt; {
1484         private SoftReference&lt;NoteListFragment&gt; mNoteListFragmentReference;
1485 
1486         private RefreshListForSearchTask(NoteListFragment context) {
1487             mNoteListFragmentReference = new SoftReference&lt;&gt;(context);
1488         }
1489 
1490         @Override
1491         protected ObjectCursor&lt;Note&gt; doInBackground(Void... args) {
1492             NoteListFragment fragment = mNoteListFragmentReference.get();
1493             return fragment.queryNotesForSearch();
1494         }
1495 
1496         @Override
1497         protected void onPostExecute(ObjectCursor&lt;Note&gt; cursor) {
1498             NoteListFragment fragment = mNoteListFragmentReference.get();
<abbr title="1499             if (((cursor == null) || (fragment.getActivity() == null)) || fragment.getActivity().isFinishing()) {">1499             if (((cursor == null) || (fragment.getActivity() == null)) || fragment.getActivity().isFinishðŸ”µ</abbr>
1500                 return;
1501             }
<abbr title="1502             // While using Query.FullTextMatch, it&#x27;s easy to enter an invalid term so catch the error and clear the cursor.">1502             // While using Query.FullTextMatch, it&#x27;s easy to enter an invalid term so catch the error andðŸ”µ</abbr>
1503             try {
1504                 fragment.mNotesAdapter.changeCursor(cursor);
1505             } catch (SQLiteException e) {
1506                 Log.e(Simplenote.TAG, &quot;Invalid SQL statement&quot;, e);
1507                 fragment.mNotesAdapter.changeCursor(null);
1508             }
1509             NotesActivity notesActivity = ((NotesActivity) (fragment.requireActivity()));
1510             notesActivity.updateTrashMenuItem(true);
1511             if (fragment.mSelectedNoteId != null) {
1512                 fragment.setNoteSelected(fragment.mSelectedNoteId);
1513                 fragment.mSelectedNoteId = null;
1514             }
1515         }
1516     }
1517 
1518     private static class PinNotesTask extends AsyncTask&lt;Void, Void, Void&gt; {
1519         private SoftReference&lt;NoteListFragment&gt; mNoteListFragmentReference;
1520 
1521         private SparseBooleanArray mSelectedRows = new SparseBooleanArray();
1522 
1523         private PinNotesTask(NoteListFragment context) {
1524             mNoteListFragmentReference = new SoftReference&lt;&gt;(context);
1525         }
1526 
1527         @Override
1528         protected void onPreExecute() {
1529             NoteListFragment fragment = mNoteListFragmentReference.get();
1530             mSelectedRows = fragment.getListView().getCheckedItemPositions();
1531         }
1532 
1533         @Override
1534         protected Void doInBackground(Void... args) {
1535             NoteListFragment fragment = mNoteListFragmentReference.get();
1536             // Get the checked notes and add them to the pinnedNotesList
1537             // We can&#x27;t modify the note in this loop because the adapter could change
1538             List&lt;Note&gt; pinnedNotesList = new ArrayList&lt;&gt;();
1539             for (int i = 0; i &lt; mSelectedRows.size(); i++) {
1540                 if (mSelectedRows.valueAt(i)) {
1541                     pinnedNotesList.add(fragment.mNotesAdapter.getItem(mSelectedRows.keyAt(i)));
1542                 }
1543             }
1544             // Now loop through the notes list and mark them as pinned
1545             for (Note pinnedNote : pinnedNotesList) {
1546                 pinnedNote.setPinned(!pinnedNote.isPinned());
1547                 pinnedNote.setModificationDate(Calendar.getInstance());
1548                 pinnedNote.save();
1549             }
1550             return null;
1551         }
1552 
1553         @Override
1554         protected void onPostExecute(Void aVoid) {
1555             NoteListFragment fragment = mNoteListFragmentReference.get();
1556             fragment.mActionMode.finish();
1557             fragment.refreshList();
1558         }
1559     }
1560 
1561     private static class TrashNotesTask extends AsyncTask&lt;Void, Void, Void&gt; {
1562         private List&lt;String&gt; mDeletedNoteIds = new ArrayList&lt;&gt;();
1563 
1564         private SoftReference&lt;NoteListFragment&gt; mNoteListFragmentReference;
1565 
1566         private SparseBooleanArray mSelectedRows = new SparseBooleanArray();
1567 
1568         private TrashNotesTask(NoteListFragment context) {
1569             mNoteListFragmentReference = new SoftReference&lt;&gt;(context);
1570         }
1571 
1572         @Override
1573         protected void onPreExecute() {
1574             NoteListFragment fragment = mNoteListFragmentReference.get();
1575             mSelectedRows = fragment.getListView().getCheckedItemPositions();
1576         }
1577 
1578         @Override
1579         protected Void doInBackground(Void... args) {
1580             NoteListFragment fragment = mNoteListFragmentReference.get();
1581             // Get the checked notes and add them to the deletedNotesList
1582             // We can&#x27;t modify the note in this loop because the adapter could change
1583             List&lt;Note&gt; deletedNotesList = new ArrayList&lt;&gt;();
1584             for (int i = 0; i &lt; mSelectedRows.size(); i++) {
1585                 if (mSelectedRows.valueAt(i)) {
1586                     deletedNotesList.add(fragment.mNotesAdapter.getItem(mSelectedRows.keyAt(i)));
1587                 }
1588             }
1589             // Now loop through the notes list and mark them as deleted
1590             for (Note deletedNote : deletedNotesList) {
1591                 mDeletedNoteIds.add(deletedNote.getSimperiumKey());
1592                 deletedNote.setDeleted(!deletedNote.isDeleted());
1593                 deletedNote.setModificationDate(Calendar.getInstance());
1594                 deletedNote.save();
1595             }
1596             return null;
1597         }
1598 
1599         @Override
1600         protected void onPostExecute(Void aVoid) {
1601             NoteListFragment fragment = mNoteListFragmentReference.get();
1602             NotesActivity notesActivity = ((NotesActivity) (fragment.getActivity()));
1603             if (notesActivity != null) {
1604                 notesActivity.showUndoBarWithNoteIds(mDeletedNoteIds);
1605             }
1606             fragment.refreshList();
1607         }
1608     }
1609 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  package com.automattic.simplenote;
   2  
   3  import android.animation.ObjectAnimator;
   4  import android.annotation.SuppressLint;
   5  import android.content.Context;
   6  import android.content.Intent;
   7  import android.content.SharedPreferences;
   8  import android.database.Cursor;
   9  import android.database.sqlite.SQLiteException;
  10  import android.os.AsyncTask;
  11  import android.os.Bundle;
  12  import android.os.Handler;
  13  import android.text.SpannableString;
  14  import android.text.SpannableStringBuilder;
  15  import android.text.TextUtils;
  16  import android.text.style.AbsoluteSizeSpan;
  17  import android.text.style.TextAppearanceSpan;
  18  import android.util.Log;
  19  import android.util.SparseBooleanArray;
  20  import android.util.TypedValue;
  21  import android.view.ActionMode;
  22  import android.view.Gravity;
  23  import android.view.HapticFeedbackConstants;
  24  import android.view.LayoutInflater;
  25  import android.view.Menu;
  26  import android.view.MenuInflater;
  27  import android.view.MenuItem;
  28  import android.view.MotionEvent;
  29  import android.view.View;
  30  import android.view.ViewGroup;
  31  import android.widget.AbsListView;
  32  import android.widget.AdapterView;
  33  import android.widget.CursorAdapter;
  34  import android.widget.ImageButton;
  35  import android.widget.ImageView;
  36  import android.widget.LinearLayout;
  37  import android.widget.ListView;
  38  import android.widget.RelativeLayout;
  39  import android.widget.TextView;
  40  import android.widget.Toast;
  41  
  42  import androidx.annotation.DrawableRes;
  43  import androidx.annotation.NonNull;
  44  import androidx.annotation.StringRes;
  45  import androidx.appcompat.widget.PopupMenu;
  46  import androidx.fragment.app.ListFragment;
  47  import androidx.preference.PreferenceManager;
  48  import androidx.recyclerview.widget.DiffUtil;
  49  import androidx.recyclerview.widget.LinearLayoutManager;
  50  import androidx.recyclerview.widget.RecyclerView;
  51  
  52  import com.automattic.simplenote.analytics.AnalyticsTracker;
  53  import com.automattic.simplenote.models.Note;
  54  import com.automattic.simplenote.models.Preferences;
  55  import com.automattic.simplenote.models.Suggestion;
  56  import com.automattic.simplenote.models.Tag;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  57 +import com.automattic.simplenote.utils.BrowserUtils;</span>

  58  import com.automattic.simplenote.utils.ChecklistUtils;
  59  import com.automattic.simplenote.utils.DateTimeUtils;
  60  import com.automattic.simplenote.utils.DisplayUtils;
  61  import com.automattic.simplenote.utils.DrawableUtils;

  62  import com.automattic.simplenote.utils.PrefUtils;
  63  import com.automattic.simplenote.utils.SearchSnippetFormatter;
  64  import com.automattic.simplenote.utils.SearchTokenizer;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  65 +import com.automattic.simplenote.utils.SimplenoteLinkify;</span>
  66  import com.automattic.simplenote.utils.StrUtils;
  67  import com.automattic.simplenote.utils.TextHighlighter;
  68  import com.automattic.simplenote.utils.ThemeUtils;
  69  import com.automattic.simplenote.utils.WidgetUtils;
  70  import com.google.android.material.floatingactionbutton.FloatingActionButton;
  71  import com.google.android.material.snackbar.Snackbar;
  72  import com.simperium.client.Bucket;
  73  import com.simperium.client.Bucket.ObjectCursor;
  74  import com.simperium.client.BucketObjectMissingException;
  75  import com.simperium.client.BucketObjectNameInvalid;
  76  import com.simperium.client.Query;
  77  
  78  import java.lang.ref.SoftReference;
  79  import java.util.ArrayList;
  80  import java.util.Calendar;
  81  import java.util.List;
  82  import java.util.regex.Matcher;
  83  import java.util.regex.Pattern;
  84  


  85  import static com.automattic.simplenote.models.Note.TAGS_PROPERTY;
  86  import static com.automattic.simplenote.models.Preferences.MAX_RECENT_SEARCHES;
  87  import static com.automattic.simplenote.models.Preferences.PREFERENCES_OBJECT_KEY;
  88  import static com.automattic.simplenote.models.Suggestion.Type.HISTORY;
  89  import static com.automattic.simplenote.models.Suggestion.Type.QUERY;
  90  import static com.automattic.simplenote.models.Suggestion.Type.TAG;
  91  import static com.automattic.simplenote.models.Tag.NAME_PROPERTY;
  92  import static com.automattic.simplenote.utils.PrefUtils.ALPHABETICAL_ASCENDING;
  93  import static com.automattic.simplenote.utils.PrefUtils.ALPHABETICAL_DESCENDING;
  94  import static com.automattic.simplenote.utils.PrefUtils.DATE_CREATED_ASCENDING;
  95  import static com.automattic.simplenote.utils.PrefUtils.DATE_CREATED_DESCENDING;
  96  import static com.automattic.simplenote.utils.PrefUtils.DATE_MODIFIED_ASCENDING;
  97  import static com.automattic.simplenote.utils.PrefUtils.DATE_MODIFIED_DESCENDING;
  98  
  99  /**
 100   * A list fragment representing a list of Notes. This fragment also supports
 101   * tablet devices by allowing list items to be given an &#x27;activated&#x27; state upon
 102   * selection. This helps indicate which item is currently being viewed in a
 103   * {@link NoteEditorFragment}.
 104   * &lt;p&gt;
 105   * Activities containing this fragment MUST implement the {@link Callbacks}
 106   * interface.
 107   */
<abbr title=" 108  public class NoteListFragment extends ListFragment implements AdapterView.OnItemLongClickListener, AbsListView.MultiChoiceModeListener, Bucket.Listener&lt;Preferences&gt; {"> 108  public class NoteListFragment extends ListFragment implements AdapterView.OnItemLongClickListener, AbsListView.MulðŸ”µ</abbr>
 109      public static final String TAG_PREFIX = &quot;tag:&quot;;
 110  
 111      /**
 112       * The preferences key representing the activated item position. Only used on tablets.
 113       */
 114      private static final String STATE_ACTIVATED_POSITION = &quot;activated_position&quot;;
 115      private static final int POPUP_MENU_FIRST_ITEM_POSITION = 0;
 116      public static final String ACTION_NEW_NOTE = &quot;com.automattic.simplenote.NEW_NOTE&quot;;
 117      /**
 118       * A dummy implementation of the {@link Callbacks} interface that does
 119       * nothing. Used only when this fragment is not attached to an activity.
 120       */
 121      private static Callbacks sCallbacks = new Callbacks() {
 122          @Override
 123          public void onActionModeCreated() {
 124          }
 125  
 126          @Override
 127          public void onActionModeDestroyed() {
 128          }
 129  
 130          @Override
<abbr title=" 131          public void onNoteSelected(String noteID, String matchOffsets, boolean isMarkdownEnabled, boolean isPreviewEnabled) {"> 131          public void onNoteSelected(String noteID, String matchOffsets, boolean isMarkdownEnabled, boolean isPrevieðŸ”µ</abbr>
 132          }
 133      };
 134      protected NotesCursorAdapter mNotesAdapter;
 135      protected String mSearchString;
 136      private Bucket&lt;Preferences&gt; mBucketPreferences;
 137      private Bucket&lt;Tag&gt; mBucketTag;
 138      private ActionMode mActionMode;
 139      private View mRootView;
 140      private ImageView mEmptyViewImage;
 141      private TextView mEmptyViewText;
 142      private View mDividerLine;
 143      private FloatingActionButton mFloatingActionButton;
 144      private boolean mIsCondensedNoteList;
 145      private boolean mIsSearching;
 146      private ImageView mSortDirection;
 147      private ListView mList;
 148      private ObjectAnimator mSortDirectionAnimation;
 149      private RecyclerView mSuggestionList;
 150      private RelativeLayout mSortLayoutContent;
 151      private RelativeLayout mSuggestionLayout;
 152      private SharedPreferences mPreferences;
 153      private String mSelectedNoteId;
 154      private SuggestionAdapter mSuggestionAdapter;
 155      private TextView mSortOrder;
 156      private RefreshListTask mRefreshListTask;
 157      private RefreshListForSearchTask mRefreshListForSearchTask;
 158      private int mDeletedItemIndex;
 159      private int mPreferenceSortOrder;
 160      private int mTitleFontSize;
 161      private int mPreviewFontSize;
 162      private boolean mIsSortDown;
 163      private boolean mIsSortReverse;
 164      /**
 165       * The fragment&#x27;s current callback object, which is notified of list item
 166       * clicks.
 167       */
 168      private Callbacks mCallbacks = sCallbacks;
 169      /**
 170       * The current activated item position. Only used on tablets.
 171       */
 172      private int mActivatedPosition = ListView.INVALID_POSITION;
 173  
 174      /**
 175       * Mandatory empty constructor for the fragment manager to instantiate the
 176       * fragment (e.g. upon screen orientation changes).
 177       */
 178      public NoteListFragment() {
 179      }
 180  
 181      @Override
 182      public boolean onItemLongClick(AdapterView&lt;?&gt; adapterView, View view, int position, long l) {
 183          getListView().setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);
 184          getListView().setItemChecked(position, true);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 185 -        if (mActionMode == null)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 186 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 187 +        if (mActionMode == null) {</span>
 188              requireActivity().startActionMode(this);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 189 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 190 +</span>
 191          return true;
 192      }
 193  
 194      @Override
 195      public boolean onCreateActionMode(ActionMode actionMode, Menu menu) {
 196          mCallbacks.onActionModeCreated();
 197          MenuInflater inflater = actionMode.getMenuInflater();
 198          inflater.inflate(R.menu.bulk_edit, menu);
 199          DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.actionModeTextColor);
 200          mActionMode = actionMode;
<abbr title=" 201          int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.background_dark;"> 201          int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.backgroundðŸ”µ</abbr>
<abbr title=" 202          requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().getTheme()));"> 202          requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().getTðŸ”µ</abbr>
 203          return true;
 204      }
 205  
 206      @Override
 207      public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 208          return false;
 209      }
 210  
 211      @Override
 212      public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 213          if (getListView().getCheckedItemIds().length &gt; 0) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 214 -</span>
 215              switch (item.getItemId()) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 216 +                case R.id.menu_link:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 217 +                    BrowserUtils.copyToClipboard(requireContext(), getSelectedNoteLinks());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 218 +                    mode.finish();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 219 +                    break;</span>
 220                  case R.id.menu_trash:
 221                      new TrashNotesTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 222                      break;
 223                  case R.id.menu_pin:
 224                      new PinNotesTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 225                      break;
 226              }
 227          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 228 +</span>
 229          return false;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 230 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 231 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 232 +    private String getSelectedNoteLinks() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 233 +        SparseBooleanArray checkedPositions = getListView().getCheckedItemPositions();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 234 +        StringBuilder links = new StringBuilder();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 235 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 236 +        for (int i = 0; i &lt; checkedPositions.size(); i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 237 +            if (checkedPositions.valueAt(i)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 238 +                Note note = mNotesAdapter.getItem(checkedPositions.keyAt(i));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 239 +                links.append(SimplenoteLinkify.getNoteLinkWithTitle(note.getTitle(), note.getSimperiumKey())).append(&quot;\n&quot;);"> 239 +                links.append(SimplenoteLinkify.getNoteLinkWithTitle(note.getTitle(), note.getSimperiumKey())).appeðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 240 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 241 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 242 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 243 +        return links.toString();</span>
 244      }
 245  
 246      @Override
 247      public void onDestroyActionMode(ActionMode mode) {
 248          mCallbacks.onActionModeDestroyed();
 249          mActionMode = null;
 250          new Handler().postDelayed(
 251              new Runnable() {
 252                  @Override
 253                  public void run() {
 254                      if (getActivity() != null) {
 255                          NotesActivity notesActivity = (NotesActivity) getActivity();
 256                          setActivateOnItemClick(DisplayUtils.isLargeScreenLandscape(notesActivity));
 257                          notesActivity.showDetailPlaceholder();
 258                      }
 259  
<abbr title=" 260                      requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 260                      requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transpðŸ”µ</abbr>
 261                  }
 262              },
 263              requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime)
 264          );
 265      }
 266  
 267      @Override
 268      public void onItemCheckedStateChanged(ActionMode actionMode, int position, long id, boolean checked) {
 269          int checkedCount = getListView().getCheckedItemCount();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 270 -        if (checkedCount == 0)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 271 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 272 +        if (checkedCount == 0) {</span>
 273              actionMode.setTitle(&quot;&quot;);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 274 -        else</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 275 +        } else {</span>
<abbr title=" 276              actionMode.setTitle(getResources().getQuantityString(R.plurals.selected_notes, checkedCount, checkedCount));"> 276              actionMode.setTitle(getResources().getQuantityString(R.plurals.selected_notes, checkedCount, checkedCoðŸ”µ</abbr>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 277 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 278 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 279 +        actionMode.invalidate();</span>
 280      }
 281  
 282      @Override
 283      public void onCreate(Bundle savedInstanceState) {
 284          super.onCreate(savedInstanceState);


 285          mBucketPreferences = ((Simplenote) requireActivity().getApplication()).getPreferencesBucket();
 286          mBucketTag = ((Simplenote) requireActivity().getApplication()).getTagsBucket();
 287      }
 288  
 289      protected void getPrefs() {
 290          mPreferenceSortOrder = PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER);
 291          mIsCondensedNoteList = PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_CONDENSED_LIST, false);
 292          mTitleFontSize = PrefUtils.getFontSize(getActivity());
 293          mPreviewFontSize = mTitleFontSize - 2;
 294      }
 295  
 296      @Override
 297      public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
 298          return inflater.inflate(R.layout.fragment_notes_list, container, false);
 299      }
 300  
 301      @Override
 302      public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
 303          super.onViewCreated(view, savedInstanceState);
 304  
 305          NotesActivity notesActivity = (NotesActivity) requireActivity();
 306  
 307          if (ACTION_NEW_NOTE.equals(notesActivity.getIntent().getAction()) &amp;&amp;
 308                  !notesActivity.userIsUnauthorized()){
 309              //if user tap on &quot;app shortcut&quot;, create a new note
 310              createNewNote(&quot;new_note_shortcut&quot;);
 311          }
 312  
 313          mPreferences = PreferenceManager.getDefaultSharedPreferences(requireContext());
 314          mRootView = view.findViewById(R.id.list_root);
 315  
 316          LinearLayout emptyView = view.findViewById(android.R.id.empty);
 317          emptyView.setVisibility(View.GONE);
 318          mEmptyViewImage = emptyView.findViewById(R.id.image);
 319          mEmptyViewText = emptyView.findViewById(R.id.text);
 320          setEmptyListImage(R.drawable.ic_notes_24dp);
 321          setEmptyListMessage(getString(R.string.empty_notes_all));
 322          mDividerLine = view.findViewById(R.id.divider_line);
 323  
 324          if (DisplayUtils.isLargeScreenLandscape(notesActivity)) {
 325              setActivateOnItemClick(true);
 326              mDividerLine.setVisibility(View.VISIBLE);
 327          }
 328  
 329          mFloatingActionButton = view.findViewById(R.id.fab_button);
 330          mFloatingActionButton.setOnClickListener(new View.OnClickListener() {
 331              @Override
 332              public void onClick(View v) {
 333                  createNewNote(&quot;action_bar_button&quot;);
 334              }
 335          });
 336          mFloatingActionButton.setOnLongClickListener(new View.OnLongClickListener() {
 337              @Override
 338              public boolean onLongClick(View v) {
 339                  if (v.isHapticFeedbackEnabled()) {
 340                      v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
 341                  }
 342  
<abbr title=" 343                  Toast.makeText(getContext(), requireContext().getString(R.string.new_note), Toast.LENGTH_SHORT).show();"> 343                  Toast.makeText(getContext(), requireContext().getString(R.string.new_note), Toast.LENGTH_SHORT).shðŸ”µ</abbr>
 344                  return true;
 345              }
 346          });
 347  
 348          mSuggestionLayout = view.findViewById(R.id.suggestion_layout);
 349          mSuggestionList = view.findViewById(R.id.suggestion_list);
 350          mSuggestionAdapter = new SuggestionAdapter(new ArrayList&lt;Suggestion&gt;());
 351          mSuggestionList.setAdapter(mSuggestionAdapter);
 352          mSuggestionList.setLayoutManager(new LinearLayoutManager(requireContext()));
 353          @SuppressLint(&quot;InflateParams&quot;)
<abbr title=" 354          LinearLayout sortLayoutContainer = (LinearLayout) getLayoutInflater().inflate(R.layout.search_sort, null, false);"> 354          LinearLayout sortLayoutContainer = (LinearLayout) getLayoutInflater().inflate(R.layout.search_sort, null, ðŸ”µ</abbr>
 355          mSortLayoutContent = sortLayoutContainer.findViewById(R.id.sort_content);
 356          mSortLayoutContent.setVisibility(mIsSearching ? View.VISIBLE : View.GONE);
 357          mSortOrder = sortLayoutContainer.findViewById(R.id.sort_order);
 358          mSortLayoutContent.setOnClickListener(new View.OnClickListener() {
 359              @Override
 360              public void onClick(View v) {
 361                  PopupMenu popup = new PopupMenu(mSortOrder.getContext(), mSortOrder, Gravity.START);
 362                  MenuInflater inflater = popup.getMenuInflater();
 363                  inflater.inflate(R.menu.search_sort, popup.getMenu());
 364                  popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {
 365                      @Override
 366                      public boolean onMenuItemClick(MenuItem item) {
 367                          // Do nothing when same sort is selected.
 368                          if (mSortOrder.getText().equals(item.getTitle())) {
 369                              return false;
 370                          }
 371  
 372                          mSortOrder.setText(item.getTitle());
 373  
 374                          switch (item.getItemId()) {
 375                              case R.id.search_alphabetically:
 376                                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER,
 377                                      String.valueOf(ALPHABETICAL_ASCENDING)
 378                                  ).apply();
 379  
 380                                  // If arrow is down, rotate it up for ascending direction.
 381                                  if (mIsSortDown &amp;&amp; !mIsSortReverse) {
 382                                      mSortDirectionAnimation.start();
 383                                      mIsSortReverse = true;
 384                                  } else if (!mIsSortDown &amp;&amp; mIsSortReverse) {
 385                                      mSortDirectionAnimation.reverse();
 386                                      mIsSortReverse = false;
 387                                  }
 388  
 389                                  refreshListForSearch();
 390                                  return true;
 391                              case R.id.search_created:
 392                                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER,
 393                                      String.valueOf(DATE_CREATED_DESCENDING)
 394                                  ).apply();
 395  
 396                                  // If arrow is up, rotate it down for descending direction.
 397                                  if (mIsSortDown &amp;&amp; mIsSortReverse) {
 398                                      mSortDirectionAnimation.reverse();
 399                                      mIsSortReverse = false;
 400                                  } else if (!mIsSortDown &amp;&amp; !mIsSortReverse) {
 401                                      mSortDirectionAnimation.start();
 402                                      mIsSortReverse = true;
 403                                  }
 404  
 405                                  refreshListForSearch();
 406                                  return true;
 407                              case R.id.search_modified:
 408                                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER,
 409                                      String.valueOf(DATE_MODIFIED_DESCENDING)
 410                                  ).apply();
 411  
 412                                  // If arrow is up, rotate it down for descending direction.
 413                                  if (mIsSortDown &amp;&amp; mIsSortReverse) {
 414                                      mSortDirectionAnimation.reverse();
 415                                      mIsSortReverse = false;
 416                                  } else if (!mIsSortDown &amp;&amp; !mIsSortReverse) {
 417                                      mSortDirectionAnimation.start();
 418                                      mIsSortReverse = true;
 419                                  }
 420  
 421                                  refreshListForSearch();
 422                                  return true;
 423                              default:
 424                                  return false;
 425                          }
 426                      }
 427                  });
 428                  popup.show();
 429              }
 430          });
 431          mList = view.findViewById(android.R.id.list);
 432          mList.addHeaderView(sortLayoutContainer);
 433  
 434          mNotesAdapter = new NotesCursorAdapter(requireActivity().getBaseContext(), null, 0);
 435          setListAdapter(mNotesAdapter);
 436  
 437          getListView().setOnItemLongClickListener(this);
 438          getListView().setMultiChoiceModeListener(this);
 439  
 440          mSortDirection = sortLayoutContainer.findViewById(R.id.sort_direction);
 441          ImageView sortDirectionSwitch = sortLayoutContainer.findViewById(R.id.sort_direction_switch);
 442          sortDirectionSwitch.setImageResource(R.drawable.ic_sort_order_24dp);
 443          sortDirectionSwitch.setOnClickListener(new View.OnClickListener() {
 444              @Override
 445              public void onClick(View v) {
 446                  if (mIsSortReverse) {
 447                      mSortDirectionAnimation.reverse();
 448                  } else {
 449                      mSortDirectionAnimation.start();
 450                  }
 451  
 452                  mIsSortReverse = !mIsSortReverse;
 453                  switchSortDirection();
 454                  refreshListForSearch();
 455              }
 456          });
 457          sortDirectionSwitch.setOnLongClickListener(new View.OnLongClickListener() {
 458              @Override
 459              public boolean onLongClick(View v) {
 460                  if (v.isHapticFeedbackEnabled()) {
 461                      v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
 462                  }
 463  
<abbr title=" 464                  Toast.makeText(requireContext(), requireContext().getString(R.string.sort_search_reverse_order), Toast.LENGTH_SHORT).show();"> 464                  Toast.makeText(requireContext(), requireContext().getString(R.string.sort_search_reverse_order), TðŸ”µ</abbr>
 465                  return true;
 466              }
 467          });
 468      }
 469  
 470      public void showListPadding(boolean show) {
 471          mList.setPadding(
 472              mList.getPaddingLeft(),
 473              mList.getPaddingTop(),
 474              mList.getPaddingRight(),
 475              show ? (int) getResources().getDimension(R.dimen.note_list_item_padding_bottom_button) : 0
 476          );
 477      }
 478  
 479      private @StringRes int getSortOrderText() {
 480          switch (PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER)) {
 481              case ALPHABETICAL_ASCENDING:
 482              case ALPHABETICAL_DESCENDING:
 483                  return R.string.sort_search_alphabetically;
 484              case DATE_CREATED_ASCENDING:
 485              case DATE_CREATED_DESCENDING:
 486                  return R.string.sort_search_created;
 487              case DATE_MODIFIED_ASCENDING:
 488              case DATE_MODIFIED_DESCENDING:
 489              default:
 490                  return R.string.sort_search_modified;
 491          }
 492      }
 493  
 494      private void setSortDirection() {
 495          if (mIsSortReverse) {
 496              mSortDirectionAnimation.reverse();
 497              mIsSortReverse = false;
 498          }
 499  
 500          switch (PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER)) {
 501              case ALPHABETICAL_ASCENDING:
 502              case DATE_CREATED_ASCENDING:
 503              case DATE_MODIFIED_ASCENDING:
 504                  mSortDirection.setContentDescription(getString(R.string.description_up));
 505                  mSortDirection.setImageResource(R.drawable.ic_arrow_up_16dp);
 506                  mIsSortDown = false;
 507                  break;
 508              case ALPHABETICAL_DESCENDING:
 509              case DATE_CREATED_DESCENDING:
 510              case DATE_MODIFIED_DESCENDING:
 511              default:
 512                  mSortDirection.setContentDescription(getString(R.string.description_down));
 513                  mSortDirection.setImageResource(R.drawable.ic_arrow_down_16dp);
 514                  mIsSortDown = true;
 515                  break;
 516          }
 517  
 518          mSortDirectionAnimation = ObjectAnimator.ofFloat(
 519              mSortDirection,
 520              View.ROTATION,
 521              0f,
 522              mIsSortDown ? -180f : 180f
 523          ).setDuration(getResources().getInteger(android.R.integer.config_shortAnimTime));
 524      }
 525  
 526      private void switchSortDirection() {
 527          switch (PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER)) {
 528              case DATE_MODIFIED_DESCENDING:
<abbr title=" 529                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_MODIFIED_ASCENDING)).apply();"> 529                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_MODIFIED_ASCENDING)).ðŸ”µ</abbr>
 530                  break;
 531              case DATE_MODIFIED_ASCENDING:
<abbr title=" 532                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_MODIFIED_DESCENDING)).apply();"> 532                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_MODIFIED_DESCENDING))ðŸ”µ</abbr>
 533                  break;
 534              case DATE_CREATED_DESCENDING:
<abbr title=" 535                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_CREATED_ASCENDING)).apply();"> 535                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_CREATED_ASCENDING)).aðŸ”µ</abbr>
 536                  break;
 537              case DATE_CREATED_ASCENDING:
<abbr title=" 538                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_CREATED_DESCENDING)).apply();"> 538                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_CREATED_DESCENDING)).ðŸ”µ</abbr>
 539                  break;
 540              case ALPHABETICAL_ASCENDING:
<abbr title=" 541                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(ALPHABETICAL_DESCENDING)).apply();"> 541                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(ALPHABETICAL_DESCENDING)).ðŸ”µ</abbr>
 542                  break;
 543              case ALPHABETICAL_DESCENDING:
<abbr title=" 544                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(ALPHABETICAL_ASCENDING)).apply();"> 544                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(ALPHABETICAL_ASCENDING)).aðŸ”µ</abbr>
 545                  break;
 546          }
 547      }
 548  
 549      public void createNewNote(String label){
 550          if (!isAdded()) return;
 551  
 552          addNote();
 553          AnalyticsTracker.track(
 554                  AnalyticsTracker.Stat.LIST_NOTE_CREATED,
 555                  AnalyticsTracker.CATEGORY_NOTE,
 556                  label
 557          );
 558      }
 559  
 560      @Override
 561      public void onAttach(@NonNull Context activity) {
 562          super.onAttach(activity);
 563  
 564          // Activities containing this fragment must implement its callbacks.
 565          if (!(activity instanceof Callbacks)) {
 566              throw new IllegalStateException(&quot;Activity must implement fragment&#x27;s callbacks.&quot;);
 567          }
 568  
 569          mCallbacks = (Callbacks) activity;
 570      }
 571  
 572      @Override
 573      public void onResume() {
 574          super.onResume();
 575          getPrefs();
 576  
 577          if (mIsSearching) {
 578              refreshListForSearch();
 579          } else {
 580              refreshList();
 581          }
 582  
 583          mBucketPreferences.start();
 584          mBucketPreferences.addOnDeleteObjectListener(this);
 585          mBucketPreferences.addOnNetworkChangeListener(this);
 586          mBucketPreferences.addOnSaveObjectListener(this);
 587      }
 588  
 589      @Override
 590      public void onPause() {
 591          super.onPause();
 592          mBucketPreferences.removeOnDeleteObjectListener(this);
 593          mBucketPreferences.removeOnNetworkChangeListener(this);
 594          mBucketPreferences.removeOnSaveObjectListener(this);
 595          mBucketPreferences.stop();

 596      }
 597  
 598      @Override
 599      public void onDetach() {
 600          super.onDetach();
 601          // Restore sort order from Settings.
 602          mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(mPreferenceSortOrder)).apply();
 603          // Reset the active callbacks interface to the dummy implementation.
 604          mCallbacks = sCallbacks;
 605      }
 606  
 607      public void setEmptyListImage(@DrawableRes int image) {
 608          if (mEmptyViewImage != null) {
 609              if (image != -1) {
 610                  mEmptyViewImage.setVisibility(View.VISIBLE);
 611                  mEmptyViewImage.setImageResource(image);
 612              } else {
 613                  mEmptyViewImage.setVisibility(View.GONE);
 614              }
 615          }
 616      }
 617  
 618      public void setEmptyListMessage(String message) {
 619          if (mEmptyViewText != null &amp;&amp; message != null) {
 620              mEmptyViewText.setText(message);
 621          }
 622      }
 623  
 624      @Override
 625      public void onListItemClick(@NonNull ListView listView, @NonNull View view, int position, long id) {
 626          if (!isAdded()) return;
 627          super.onListItemClick(listView, view, position, id);
 628  
 629          NoteViewHolder holder = (NoteViewHolder) view.getTag();
 630          String noteID = holder.getNoteId();
 631  
 632          if (noteID != null) {
 633              Note note = mNotesAdapter.getItem(position);
<abbr title=" 634              mCallbacks.onNoteSelected(noteID, holder.mMatchOffsets, note.isMarkdownEnabled(), note.isPreviewEnabled());"> 634              mCallbacks.onNoteSelected(noteID, holder.mMatchOffsets, note.isMarkdownEnabled(), note.isPreviewEnableðŸ”µ</abbr>
 635          }
 636  
 637          mActivatedPosition = position;
 638      }
 639  
 640      /**
 641       * Selects first row in the list if available
 642       */
 643      public void selectFirstNote() {
 644          if (mNotesAdapter.getCount() &gt; 0) {
 645              Note selectedNote = mNotesAdapter.getItem(mList.getHeaderViewsCount());
<abbr title=" 646              mCallbacks.onNoteSelected(selectedNote.getSimperiumKey(), null, selectedNote.isMarkdownEnabled(), selectedNote.isPreviewEnabled());"> 646              mCallbacks.onNoteSelected(selectedNote.getSimperiumKey(), null, selectedNote.isMarkdownEnabled(), seleðŸ”µ</abbr>
 647          }
 648      }
 649  
 650      @Override
 651      public void onSaveInstanceState(@NonNull Bundle outState) {
 652          super.onSaveInstanceState(outState);
 653          if (mActivatedPosition != ListView.INVALID_POSITION) {
 654              // Serialize and persist the activated item position.
 655              outState.putInt(STATE_ACTIVATED_POSITION, mActivatedPosition);
 656          }
 657      }
 658  
 659      public View getRootView() {
 660          return mRootView;
 661      }
 662  
 663      /**
 664       * Turns on activate-on-click mode. When this mode is on, list items will be
 665       * given the &#x27;activated&#x27; state when touched.
 666       */
 667      public void setActivateOnItemClick(boolean activateOnItemClick) {
 668          // When setting CHOICE_MODE_SINGLE, ListView will automatically
 669          // give items the &#x27;activated&#x27; state when touched.
<abbr title=" 670          getListView().setChoiceMode(activateOnItemClick ? ListView.CHOICE_MODE_SINGLE : ListView.CHOICE_MODE_NONE);"> 670          getListView().setChoiceMode(activateOnItemClick ? ListView.CHOICE_MODE_SINGLE : ListView.CHOICE_MODE_NONE)ðŸ”µ</abbr>
 671      }
 672  
 673      public void setActivatedPosition(int position) {
 674          if (getListView() != null) {
 675              if (position == ListView.INVALID_POSITION) {
 676                  getListView().setItemChecked(mActivatedPosition, false);
 677              } else {
 678                  getListView().setItemChecked(position, true);
 679              }
 680  
 681              mActivatedPosition = position;
 682          }
 683      }
 684  
 685      public void setDividerVisible(boolean visible) {
 686          mDividerLine.setVisibility(visible ? View.VISIBLE : View.GONE);
 687      }
 688  
 689      public void setFloatingActionButtonVisible(boolean visible) {
 690          if (mFloatingActionButton == null) return;
 691  
 692          if (visible) {
 693              mFloatingActionButton.show();
 694          } else {
 695              mFloatingActionButton.hide();
 696          }
 697      }
 698  
 699      public void refreshList() {
 700          mSortOrder.setText(getSortOrderText());
 701          setSortDirection();
 702          refreshList(false);
 703      }
 704  
 705      public void refreshList(boolean fromNav) {
 706          if (mRefreshListTask != null &amp;&amp; mRefreshListTask.getStatus() != AsyncTask.Status.FINISHED)
 707              mRefreshListTask.cancel(true);
 708  
 709          mRefreshListTask = new RefreshListTask(this);
 710          mRefreshListTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, fromNav);
 711  
 712          WidgetUtils.updateNoteWidgets(requireActivity().getApplicationContext());
 713      }
 714  
 715      private void refreshListForSearch() {
<abbr title=" 716          if (mRefreshListForSearchTask != null &amp;&amp; mRefreshListForSearchTask.getStatus() != AsyncTask.Status.FINISHED) {"> 716          if (mRefreshListForSearchTask != null &amp;&amp; mRefreshListForSearchTask.getStatus() != AsyncTask.Status.FINISHEðŸ”µ</abbr>
 717              mRefreshListForSearchTask.cancel(true);
 718          }
 719  
 720          mRefreshListForSearchTask = new RefreshListForSearchTask(this);
 721          mRefreshListForSearchTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 722      }
 723  
 724      public void refreshListFromNavSelect() {
 725          refreshList(true);
 726      }
 727  
 728      public ObjectCursor&lt;Note&gt; queryNotes() {
 729          if (!isAdded()) return null;
 730  
 731          NotesActivity notesActivity = (NotesActivity) requireActivity();
 732          Query&lt;Note&gt; query = notesActivity.getSelectedTag().query();
 733  
 734          String searchString = mSearchString;
 735          if (hasSearchQuery()) {
 736              searchString = queryTags(query, mSearchString);
 737          }
 738          if (!TextUtils.isEmpty(searchString)) {
 739              query.where(new Query.FullTextMatch(new SearchTokenizer(searchString)));
 740              query.include(new Query.FullTextOffsets(&quot;match_offsets&quot;));
 741              query.include(new Query.FullTextSnippet(Note.MATCHED_TITLE_INDEX_NAME, Note.TITLE_INDEX_NAME));
 742              query.include(new Query.FullTextSnippet(Note.MATCHED_CONTENT_INDEX_NAME, Note.CONTENT_PROPERTY));
 743              query.include(Note.TITLE_INDEX_NAME, Note.CONTENT_PREVIEW_INDEX_NAME);
 744          } else {
 745              query.include(Note.TITLE_INDEX_NAME, Note.CONTENT_PREVIEW_INDEX_NAME);
 746          }
 747  
 748          query.include(Note.PINNED_INDEX_NAME);
 749          PrefUtils.sortNoteQuery(query, requireContext(), true);
 750          return query.execute();
 751      }
 752  
 753      private ObjectCursor&lt;Note&gt; queryNotesForSearch() {
 754          if (!isAdded()) {
 755              return null;
 756          }
 757  
 758          Query&lt;Note&gt; query = Note.all(((Simplenote) requireActivity().getApplication()).getNotesBucket());
 759          String searchString = mSearchString;
 760  
 761          if (hasSearchQuery()) {
 762              searchString = queryTags(query, mSearchString);
 763          }
 764  
 765          if (!TextUtils.isEmpty(searchString)) {
 766              query.where(new Query.FullTextMatch(new SearchTokenizer(searchString)));
 767              query.include(new Query.FullTextOffsets(&quot;match_offsets&quot;));
 768              query.include(new Query.FullTextSnippet(Note.MATCHED_TITLE_INDEX_NAME, Note.TITLE_INDEX_NAME));
 769              query.include(new Query.FullTextSnippet(Note.MATCHED_CONTENT_INDEX_NAME, Note.CONTENT_PROPERTY));
 770              query.include(Note.TITLE_INDEX_NAME, Note.CONTENT_PREVIEW_INDEX_NAME);
 771          } else {
 772              query.include(Note.TITLE_INDEX_NAME, Note.CONTENT_PREVIEW_INDEX_NAME);
 773          }
 774  
 775          PrefUtils.sortNoteQuery(query, requireContext(), false);
 776          return query.execute();
 777      }
 778  
 779      private String queryTags(Query&lt;Note&gt; query, String searchString) {
 780          Pattern pattern = Pattern.compile(TAG_PREFIX + &quot;(.*?)( |$)&quot;);
 781          Matcher matcher = pattern.matcher(searchString);
 782          while (matcher.find()) {
 783              query.where(TAGS_PROPERTY, Query.ComparisonType.LIKE, matcher.group(1));
 784          }
 785          return matcher.replaceAll(&quot;&quot;);
 786      }
 787  
 788      public void addNote() {
 789  
 790          // Prevents jarring &#x27;New note...&#x27; from showing in the list view when creating a new note
 791          NotesActivity notesActivity = (NotesActivity) requireActivity();
 792          if (!DisplayUtils.isLargeScreenLandscape(notesActivity))
 793              notesActivity.stopListeningToNotesBucket();
 794  
 795          // Create &amp; save new note
 796          Simplenote simplenote = (Simplenote) requireActivity().getApplication();
 797          Bucket&lt;Note&gt; notesBucket = simplenote.getNotesBucket();
 798          final Note note = notesBucket.newObject();
 799          note.setCreationDate(Calendar.getInstance());
 800          note.setModificationDate(note.getCreationDate());
 801          note.setMarkdownEnabled(PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_MARKDOWN_ENABLED, false));
 802  
 803          if (notesActivity.getSelectedTag() != null &amp;&amp; notesActivity.getSelectedTag().name != null) {
 804              String tagName = notesActivity.getSelectedTag().name;
<abbr title=" 805              if (!tagName.equals(getString(R.string.all_notes)) &amp;&amp; !tagName.equals(getString(R.string.trash)) &amp;&amp; !tagName.equals(getString(R.string.untagged_notes)))"> 805              if (!tagName.equals(getString(R.string.all_notes)) &amp;&amp; !tagName.equals(getString(R.string.trash)) &amp;&amp; !tðŸ”µ</abbr>
 806                  note.setTagString(tagName);
 807          }
 808  
 809          note.save();
 810  
 811          if (DisplayUtils.isLargeScreenLandscape(getActivity())) {
 812              // Hack: Simperium saves async so we add a small delay to ensure the new note is truly
 813              // saved before proceeding.
 814              new Handler().postDelayed(new Runnable() {
 815                  @Override
 816                  public void run() {
<abbr title=" 817                      mCallbacks.onNoteSelected(note.getSimperiumKey(), null, note.isMarkdownEnabled(), note.isPreviewEnabled());"> 817                      mCallbacks.onNoteSelected(note.getSimperiumKey(), null, note.isMarkdownEnabled(), note.isPreviðŸ”µ</abbr>
 818                  }
 819              }, 50);
 820          } else {
 821              Bundle arguments = new Bundle();
 822              arguments.putString(NoteEditorFragment.ARG_ITEM_ID, note.getSimperiumKey());
 823              arguments.putBoolean(NoteEditorFragment.ARG_NEW_NOTE, true);
 824              arguments.putBoolean(NoteEditorFragment.ARG_MARKDOWN_ENABLED, note.isMarkdownEnabled());
 825              arguments.putBoolean(NoteEditorFragment.ARG_PREVIEW_ENABLED, note.isPreviewEnabled());
 826              Intent editNoteIntent = new Intent(getActivity(), NoteEditorActivity.class);
 827              editNoteIntent.putExtras(arguments);
 828  
 829              requireActivity().startActivityForResult(editNoteIntent, Simplenote.INTENT_EDIT_NOTE);
 830          }
 831      }
 832  
 833      public void setNoteSelected(String selectedNoteID) {
 834          // Loop through notes and set note selected if found
 835          //noinspection unchecked
 836          ObjectCursor&lt;Note&gt; cursor = (ObjectCursor&lt;Note&gt;) mNotesAdapter.getCursor();
 837          if (cursor != null) {
 838              for (int i = 0; i &lt; cursor.getCount(); i++) {
 839                  cursor.moveToPosition(i);
 840                  String noteKey = cursor.getSimperiumKey();
 841                  if (noteKey != null &amp;&amp; noteKey.equals(selectedNoteID)) {
 842                      setActivatedPosition(i + mList.getHeaderViewsCount());
 843                      return;
 844                  }
 845              }
 846          }
 847  
 848          // Didn&#x27;t find the note, let&#x27;s try again after the cursor updates (see RefreshListTask)
 849          mSelectedNoteId = selectedNoteID;
 850      }
 851  
 852      public void searchNotes(String searchString, boolean isSubmit) {
 853          mIsSearching = true;
 854          mSortLayoutContent.setVisibility(View.VISIBLE);
 855          mSuggestionLayout.setVisibility(View.VISIBLE);
 856          mSortOrder.setText(getSortOrderText());
 857  
 858          if (!searchString.equals(mSearchString)) {
 859              mSearchString = searchString;
 860          }
 861  
 862          if (searchString.isEmpty()) {
 863              getSearchItems();
 864          } else {
 865              getTagSuggestions(searchString);
 866          }
 867  
 868          if (isSubmit) {
 869              mSuggestionLayout.setVisibility(View.GONE);
 870              refreshListForSearch();
 871          }
 872      }
 873  
 874      /**
 875       * Clear search and load all notes
 876       */
 877      public void clearSearch() {
 878          mIsSearching = false;
 879          mSortLayoutContent.setVisibility(View.GONE);
 880          mSuggestionLayout.setVisibility(View.GONE);
 881          // Restore sort order from Settings.
 882          mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(mPreferenceSortOrder)).apply();
 883          refreshList();
 884  
 885          if (mSearchString != null &amp;&amp; !mSearchString.equals(&quot;&quot;)) {
 886              mSearchString = null;
 887              refreshList();
 888          }
 889      }
 890  
 891      public boolean hasSearchQuery() {
 892          return mSearchString != null &amp;&amp; !mSearchString.equals(&quot;&quot;);
 893      }
 894  
 895      public void addSearchItem(String item, int index) {
 896          Preferences preferences = getPreferences();
 897  
 898          if (preferences != null) {
 899              List&lt;String&gt; recents = preferences.getRecentSearches();
 900              recents.remove(item);
 901              recents.add(index, item);
<abbr title=" 902              // Trim recent searches to MAX_RECENT_SEARCHES (currently 5) if size is greater than MAX_RECENT_SEARCHES."> 902              // Trim recent searches to MAX_RECENT_SEARCHES (currently 5) if size is greater than MAX_RECENT_SEARCHðŸ”µ</abbr>
<abbr title=" 903              preferences.setRecentSearches(recents.subList(0, recents.size() &gt; MAX_RECENT_SEARCHES ? MAX_RECENT_SEARCHES : recents.size()));"> 903              preferences.setRecentSearches(recents.subList(0, recents.size() &gt; MAX_RECENT_SEARCHES ? MAX_RECENT_SEAðŸ”µ</abbr>
 904              preferences.save();
 905          } else {
 906              Log.e(&quot;addSearchItem&quot;, &quot;Could not get preferences entity&quot;);
 907          }
 908      }
 909  
 910      private void deleteSearchItem(String item) {
 911          Preferences preferences = getPreferences();
 912  
 913          if (preferences != null) {
 914              List&lt;String&gt; recents = preferences.getRecentSearches();
 915              mDeletedItemIndex = recents.indexOf(item);
 916              recents.remove(item);
 917              preferences.setRecentSearches(recents);
 918              preferences.save();
 919          } else {
 920              Log.e(&quot;deleteSearchItem&quot;, &quot;Could not get preferences entity&quot;);
 921          }
 922      }
 923  
 924      private Preferences getPreferences() {
 925          try {
 926              return mBucketPreferences.get(PREFERENCES_OBJECT_KEY);
 927          } catch (BucketObjectMissingException exception) {
 928              try {
 929                  Preferences preferences = mBucketPreferences.newObject(PREFERENCES_OBJECT_KEY);
 930                  preferences.save();
 931                  return preferences;
 932              } catch (BucketObjectNameInvalid invalid) {
 933                  Log.e(&quot;getPreferences&quot;, &quot;Could not create preferences entity&quot;, invalid);
 934                  return null;
 935              }
 936          }
 937      }
 938  
 939      private void getSearchItems() {
 940          Preferences preferences = getPreferences();
 941  
 942          if (preferences != null) {
 943              ArrayList&lt;Suggestion&gt; suggestions = new ArrayList&lt;&gt;();
 944  
 945              for (String recent : preferences.getRecentSearches()) {
 946                  suggestions.add(new Suggestion(recent, HISTORY));
 947              }
 948  
 949              mSuggestionAdapter.updateItems(suggestions);
 950          } else {
 951              Log.e(&quot;getSearchItems&quot;, &quot;Could not get preferences entity&quot;);
 952          }
 953      }
 954  
 955      private void getTagSuggestions(String query) {
 956          ArrayList&lt;Suggestion&gt; suggestions = new ArrayList&lt;&gt;();
 957          suggestions.add(new Suggestion(query, QUERY));
<abbr title=" 958          Query&lt;Tag&gt; tags = Tag.all(mBucketTag).reorder().order(Tag.NOTE_COUNT_INDEX_NAME, Query.SortType.DESCENDING);"> 958          Query&lt;Tag&gt; tags = Tag.all(mBucketTag).reorder().order(Tag.NOTE_COUNT_INDEX_NAME, Query.SortType.DESCENDINGðŸ”µ</abbr>
 959  
 960          if (!query.endsWith(TAG_PREFIX)) {
 961              tags.where(NAME_PROPERTY, Query.ComparisonType.LIKE, &quot;%&quot; + query + &quot;%&quot;);
 962          }
 963  
 964          try (ObjectCursor&lt;Tag&gt; cursor = tags.execute()) {
 965              while (cursor.moveToNext()) {
 966                  suggestions.add(new Suggestion(cursor.getObject().getName(), TAG));
 967              }
 968          }
 969  
 970          mSuggestionAdapter = new SuggestionAdapter(suggestions);
 971          mSuggestionList.setAdapter(mSuggestionAdapter);
 972      }
 973  
 974      /**
 975       * A callback interface that all activities containing this fragment must
 976       * implement. This mechanism allows activities to be notified of item
 977       * selections.
 978       */
 979      public interface Callbacks {
 980          /**
 981           * Callback for when action mode is created.
 982           */
 983          void onActionModeCreated();
 984          /**
 985           * Callback for when action mode is destroyed.
 986           */
 987          void onActionModeDestroyed();
 988          /**
 989           * Callback for when a note has been selected.
 990           */
<abbr title=" 991          void onNoteSelected(String noteID, String matchOffsets, boolean isMarkdownEnabled, boolean isPreviewEnabled);"> 991          void onNoteSelected(String noteID, String matchOffsets, boolean isMarkdownEnabled, boolean isPreviewEnableðŸ”µ</abbr>
 992      }
 993  
 994      // view holder for NotesCursorAdapter
 995      private static class NoteViewHolder {
 996          private ImageView mPinned;
 997          private ImageView mPublished;
 998          private TextView mContent;
 999          private TextView mDate;
1000          private TextView mTitle;
1001          private String mMatchOffsets;
1002          private String mNoteId;
1003          private View mStatus;
1004  
1005          public String getNoteId() {
1006              return mNoteId;
1007          }
1008  
1009          public void setNoteId(String noteId) {
1010              mNoteId = noteId;
1011          }
1012      }
1013  
1014      public class NotesCursorAdapter extends CursorAdapter {
1015          private ObjectCursor&lt;Note&gt; mCursor;
1016  
1017          private SearchSnippetFormatter.SpanFactory mSnippetHighlighter = new TextHighlighter(requireActivity(),
1018                  R.attr.listSearchHighlightForegroundColor, R.attr.listSearchHighlightBackgroundColor);
1019  
1020          public NotesCursorAdapter(Context context, ObjectCursor&lt;Note&gt; c, int flags) {
1021              super(context, c, flags);
1022              mCursor = c;
1023          }
1024  
1025          public void changeCursor(ObjectCursor&lt;Note&gt; cursor) {
1026              mCursor = cursor;
1027              super.changeCursor(cursor);
1028          }
1029  
1030          @Override
1031          public Note getItem(int position) {
1032              mCursor.moveToPosition(position - mList.getHeaderViewsCount());
1033              return mCursor.getObject();
1034          }
1035  
1036          /*
1037           *  nbradbury - implemented &quot;holder pattern&quot; to boost performance with large note lists
1038           */
1039          @Override
1040          public View getView(final int position, View view, ViewGroup parent) {
1041              final NoteViewHolder holder;
1042  
1043              if (view == null) {
1044                  view = View.inflate(requireActivity().getBaseContext(), R.layout.note_list_row, null);
1045                  holder = new NoteViewHolder();
1046                  holder.mTitle = view.findViewById(R.id.note_title);
1047                  holder.mContent = view.findViewById(R.id.note_content);
1048                  holder.mDate = view.findViewById(R.id.note_date);
1049                  holder.mPinned = view.findViewById(R.id.note_pinned);
1050                  holder.mPublished = view.findViewById(R.id.note_published);
1051                  holder.mStatus = view.findViewById(R.id.note_status);
1052                  view.setTag(holder);
1053              } else {
1054                  holder = (NoteViewHolder) view.getTag();
1055              }
1056  
1057              if (holder.mTitle.getTextSize() != mTitleFontSize) {
1058                  holder.mTitle.setTextSize(TypedValue.COMPLEX_UNIT_SP, mTitleFontSize);
1059                  holder.mContent.setTextSize(TypedValue.COMPLEX_UNIT_SP, mPreviewFontSize);
1060                  holder.mDate.setTextSize(TypedValue.COMPLEX_UNIT_SP, mPreviewFontSize);
1061              }
1062  
1063              if (position == getListView().getCheckedItemPosition())
1064                  view.setActivated(true);
1065              else
1066                  view.setActivated(false);
1067  
1068              // for performance reasons we are going to get indexed values
1069              // from the cursor instead of instantiating the entire bucket object
1070              holder.mContent.setVisibility(mIsCondensedNoteList ? View.GONE : View.VISIBLE);
1071              mCursor.moveToPosition(position);
1072              holder.setNoteId(mCursor.getSimperiumKey());
1073              Calendar date = getDateByPreference(mCursor.getObject());
1074              holder.mDate.setText(date != null ? DateTimeUtils.getDateTextNumeric(date) : &quot;&quot;);
1075              holder.mDate.setVisibility(mIsSearching &amp;&amp; date != null ? View.VISIBLE : View.GONE);
1076              boolean isPinned = mCursor.getObject().isPinned();
1077              holder.mPinned.setVisibility(!isPinned || mIsSearching ? View.GONE : View.VISIBLE);
1078              boolean isPublished = !mCursor.getObject().getPublishedUrl().isEmpty();
1079              holder.mPublished.setVisibility(!isPublished || mIsSearching ? View.GONE : View.VISIBLE);
1080              boolean showIcons = isPinned || isPublished;
1081              boolean showDate = mIsSearching &amp;&amp; date != null;
1082              holder.mStatus.setVisibility(showIcons || showDate ? View.VISIBLE : View.GONE);
1083              String title = mCursor.getString(mCursor.getColumnIndex(Note.TITLE_INDEX_NAME));
1084  
1085              if (TextUtils.isEmpty(title)) {
1086                  SpannableString newNoteString = new SpannableString(getString(R.string.new_note_list));
1087                  newNoteString.setSpan(new TextAppearanceSpan(getActivity(),R.style.UntitledNoteAppearance),
1088                          0,
1089                          newNoteString.length(),
1090                          SpannableString.SPAN_EXCLUSIVE_EXCLUSIVE
1091                  );
1092                  newNoteString.setSpan(new AbsoluteSizeSpan(mTitleFontSize, true),
1093                          0,
1094                          newNoteString.length(),
1095                          SpannableString.SPAN_EXCLUSIVE_EXCLUSIVE
1096                  );
1097                  holder.mTitle.setText(newNoteString);
1098              } else {
1099                  SpannableStringBuilder titleChecklistString = new SpannableStringBuilder(title);
1100                  titleChecklistString = (SpannableStringBuilder) ChecklistUtils.addChecklistSpansForRegexAndColor(
1101                          getContext(),
1102                          titleChecklistString,
1103                          ChecklistUtils.CHECKLIST_REGEX,
1104                          ThemeUtils.getThemeTextColorId(getContext()));
1105                  holder.mTitle.setText(titleChecklistString);
1106              }
1107  
1108              holder.mMatchOffsets = null;
1109              int matchOffsetsIndex = mCursor.getColumnIndex(&quot;match_offsets&quot;);
1110  
1111              if (hasSearchQuery() &amp;&amp; matchOffsetsIndex != -1) {
1112                  title = mCursor.getString(mCursor.getColumnIndex(Note.MATCHED_TITLE_INDEX_NAME));
1113                  String snippet = mCursor.getString(mCursor.getColumnIndex(Note.MATCHED_CONTENT_INDEX_NAME));
1114                  holder.mMatchOffsets = mCursor.getString(matchOffsetsIndex);
1115  
1116                  try {
1117                      holder.mContent.setText(SearchSnippetFormatter.formatString(
1118                              getContext(),
1119                              snippet,
1120                              mSnippetHighlighter,
1121                              R.color.text_title_disabled));
1122                      holder.mTitle.setText(SearchSnippetFormatter.formatString(
1123                              getContext(),
1124                              title,
1125                              mSnippetHighlighter, ThemeUtils.getThemeTextColorId(getContext())));
1126                  } catch (NullPointerException e) {
1127                      title = StrUtils.notNullStr(mCursor.getString(mCursor.getColumnIndex(Note.TITLE_INDEX_NAME)));
1128                      holder.mTitle.setText(title);
<abbr title="1129                      String matchedContentPreview = StrUtils.notNullStr(mCursor.getString(mCursor.getColumnIndex(Note.CONTENT_PREVIEW_INDEX_NAME)));">1129                      String matchedContentPreview = StrUtils.notNullStr(mCursor.getString(mCursor.getColumnIndex(NoðŸ”µ</abbr>
1130                      holder.mContent.setText(matchedContentPreview);
1131                  }
1132              } else if (!mIsCondensedNoteList) {
<abbr title="1133                  String contentPreview = mCursor.getString(mCursor.getColumnIndex(Note.CONTENT_PREVIEW_INDEX_NAME));">1133                  String contentPreview = mCursor.getString(mCursor.getColumnIndex(Note.CONTENT_PREVIEW_INDEX_NAME))ðŸ”µ</abbr>
1134  
<abbr title="1135                  if (title == null || title.equals(contentPreview) || title.equals(getString(R.string.new_note_list)))">1135                  if (title == null || title.equals(contentPreview) || title.equals(getString(R.string.new_note_listðŸ”µ</abbr>
1136                      holder.mContent.setVisibility(View.GONE);
1137                  else {
1138                      holder.mContent.setText(contentPreview);
1139                      SpannableStringBuilder checklistString = new SpannableStringBuilder(contentPreview);
1140                      checklistString = (SpannableStringBuilder) ChecklistUtils.addChecklistSpansForRegexAndColor(
1141                              getContext(),
1142                              checklistString,
1143                              ChecklistUtils.CHECKLIST_REGEX,
1144                              R.color.text_title_disabled);
1145                      holder.mContent.setText(checklistString);
1146                  }
1147              }
1148  
1149              // Add mouse right click support for showing a popup menu
1150              view.setOnTouchListener(new View.OnTouchListener() {
1151                  @SuppressLint(&quot;ClickableViewAccessibility&quot;)
1152                  @Override
1153                  public boolean onTouch(View view, MotionEvent event) {
<abbr title="1154                      if (event.getButtonState() == MotionEvent.BUTTON_SECONDARY &amp;&amp; event.getAction() == MotionEvent.ACTION_DOWN) {">1154                      if (event.getButtonState() == MotionEvent.BUTTON_SECONDARY &amp;&amp; event.getAction() == MotionEventðŸ”µ</abbr>
1155                          showPopupMenuAtPosition(view, position);
1156                          return true;
1157                      }
1158  
1159                      return false;
1160                  }
1161              });
1162  
1163              return view;
1164          }
1165  
1166          @Override
1167          public View newView(Context context, Cursor cursor, ViewGroup viewGroup) {
1168              return null;
1169          }
1170  
1171          @Override
1172          public void bindView(View view, Context context, Cursor cursor) {
1173          }
1174      }
1175  
1176      @Override
1177      public void onBeforeUpdateObject(Bucket&lt;Preferences&gt; bucket, Preferences object) {
1178      }
1179  
1180      @Override
1181      public void onDeleteObject(Bucket&lt;Preferences&gt; bucket, Preferences object) {
1182          if (isAdded()) {
1183              requireActivity().runOnUiThread(new Runnable() {
1184                  @Override
1185                  public void run() {
1186                      getSearchItems();
1187                  }
1188              });
1189          }
1190      }
1191  
1192      @Override
1193      public void onNetworkChange(Bucket&lt;Preferences&gt; bucket, Bucket.ChangeType type, String key) {
1194          if (isAdded()) {
1195              requireActivity().runOnUiThread(new Runnable() {
1196                  @Override
1197                  public void run() {
1198                      getSearchItems();
1199                  }
1200              });
1201          }
1202      }
1203  
1204      @Override
1205      public void onSaveObject(Bucket&lt;Preferences&gt; bucket, Preferences object) {
1206          if (isAdded()) {
1207              requireActivity().runOnUiThread(new Runnable() {
1208                  @Override
1209                  public void run() {
1210                      getSearchItems();
1211                  }
1212              });
1213          }
1214      }
1215  
1216      private class SuggestionAdapter extends RecyclerView.Adapter&lt;SuggestionAdapter.ViewHolder&gt; {
1217          private final List&lt;Suggestion&gt; mSuggestions;
1218  
1219          private SuggestionAdapter(List&lt;Suggestion&gt; suggestions) {
1220              mSuggestions = new ArrayList&lt;&gt;(suggestions);
1221          }
1222  
1223          @Override
1224          public int getItemCount() {
1225              return mSuggestions.size();
1226          }
1227  
1228          @Override
1229          public int getItemViewType(int position) {
1230              return mSuggestions.get(position).getType();
1231          }
1232  
1233          @SuppressLint(&quot;SetTextI18n&quot;)
1234          @Override
1235          public void onBindViewHolder(@NonNull final ViewHolder holder, final int position) {
1236              switch (holder.mViewType) {
1237                  case HISTORY:
1238                      holder.mSuggestionText.setText(mSuggestions.get(position).getName());
1239                      holder.mSuggestionIcon.setImageResource(R.drawable.ic_history_24dp);
1240                      holder.mButtonDelete.setVisibility(View.VISIBLE);
1241                      break;
1242                  case QUERY:
1243                      holder.mSuggestionText.setText(mSuggestions.get(position).getName());
1244                      holder.mSuggestionIcon.setImageResource(R.drawable.ic_search_24dp);
1245                      holder.mButtonDelete.setVisibility(View.GONE);
1246                      break;
1247                  case TAG:
1248                      holder.mSuggestionText.setText(TAG_PREFIX + mSuggestions.get(position).getName());
1249                      holder.mSuggestionIcon.setImageResource(R.drawable.ic_tag_24dp);
1250                      holder.mButtonDelete.setVisibility(View.GONE);
1251                      break;
1252              }
1253  
1254              holder.mButtonDelete.setOnClickListener(new View.OnClickListener() {
1255                  @Override
1256                  public void onClick(View view) {
1257                      if (!isAdded()) {
1258                          return;
1259                      }
1260  
1261                      final String item = holder.mSuggestionText.getText().toString();
1262                      deleteSearchItem(item);
1263                      Snackbar
1264                          .make(getRootView(), R.string.snackbar_deleted_recent_search, Snackbar.LENGTH_LONG)
1265                          .setAction(
1266                              getString(R.string.undo),
1267                              new View.OnClickListener() {
1268                                  @Override
1269                                  public void onClick(View view) {
1270                                      addSearchItem(item, mDeletedItemIndex);
1271                                  }
1272                              }
1273                          )
1274                          .show();
1275                  }
1276              });
1277              holder.mButtonDelete.setOnLongClickListener(new View.OnLongClickListener() {
1278                  @Override
1279                  public boolean onLongClick(View v) {
1280                      if (v.isHapticFeedbackEnabled()) {
1281                          v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
1282                      }
1283  
<abbr title="1284                      Toast.makeText(getContext(), requireContext().getString(R.string.description_delete_item), Toast.LENGTH_SHORT).show();">1284                      Toast.makeText(getContext(), requireContext().getString(R.string.description_delete_item), ToaðŸ”µ</abbr>
1285                      return true;
1286                  }
1287              });
1288  
1289              holder.mView.setOnClickListener(new View.OnClickListener() {
1290                  @Override
1291                  public void onClick(View view) {
1292                      ((NotesActivity) requireActivity()).submitSearch(holder.mSuggestionText.getText().toString());








1293                  }
1294              });
1295          }
1296  
1297          @NonNull
1298          @Override
1299          public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
<abbr title="1300              return new ViewHolder(LayoutInflater.from(requireContext()).inflate(R.layout.search_suggestion, parent, false), viewType);">1300              return new ViewHolder(LayoutInflater.from(requireContext()).inflate(R.layout.search_suggestion, parentðŸ”µ</abbr>
1301          }
1302  
1303          private class ViewHolder extends RecyclerView.ViewHolder {
1304              private ImageButton mButtonDelete;
1305              private ImageView mSuggestionIcon;
1306              private TextView mSuggestionText;
1307              private View mView;
1308              private int mViewType;
1309  
1310              private ViewHolder(View itemView, int viewType) {
1311                  super(itemView);
1312                  mView = itemView;
1313                  mViewType = viewType;
1314                  mSuggestionText = itemView.findViewById(R.id.suggestion_text);
1315                  mSuggestionIcon = itemView.findViewById(R.id.suggestion_icon);
1316                  mButtonDelete = itemView.findViewById(R.id.suggestion_delete);
1317              }
1318          }
1319  
1320          private void updateItems(List&lt;Suggestion&gt; suggestions) {
<abbr title="1321              DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new SuggestionDiffCallback(mSuggestions, suggestions));">1321              DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new SuggestionDiffCallback(mSuggestions, suggeðŸ”µ</abbr>
1322              mSuggestions.clear();
1323              mSuggestions.addAll(suggestions);
1324              diffResult.dispatchUpdatesTo(this);
1325          }
1326      }
1327  
1328      private class SuggestionDiffCallback extends DiffUtil.Callback {
1329          private List&lt;Suggestion&gt; mListNew;
1330          private List&lt;Suggestion&gt; mListOld;
1331  
1332          private SuggestionDiffCallback(List&lt;Suggestion&gt; oldList, List&lt;Suggestion&gt; newList) {
1333              mListOld = oldList;
1334              mListNew = newList;
1335          }
1336  
1337          @Override
1338          public boolean areContentsTheSame(int itemPositionOld, int itemPositionNew) {
1339              Suggestion itemOld = mListOld.get(itemPositionOld);
1340              Suggestion itemNew = mListNew.get(itemPositionNew);
1341              return itemOld.getName().equalsIgnoreCase(itemNew.getName());
1342          }
1343  
1344          @Override
1345          public boolean areItemsTheSame(int itemPositionOld, int itemPositionNew) {
1346              Suggestion itemOld = mListOld.get(itemPositionOld);
1347              Suggestion itemNew = mListNew.get(itemPositionNew);
1348              return itemOld.getName().equalsIgnoreCase(itemNew.getName());
1349          }
1350  
1351          @Override
1352          public int getNewListSize() {
1353              return mListNew.size();
1354          }
1355  
1356          @Override
1357          public int getOldListSize() {
1358              return mListOld.size();
1359          }
1360      }
1361  
1362      private Calendar getDateByPreference(Note note) {
1363          switch (PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER)) {
1364              case DATE_CREATED_ASCENDING:
1365              case DATE_CREATED_DESCENDING:
1366                  return note.getCreationDate();
1367              case DATE_MODIFIED_ASCENDING:
1368              case DATE_MODIFIED_DESCENDING:
1369                  return note.getModificationDate();
1370              case ALPHABETICAL_ASCENDING:
1371              case ALPHABETICAL_DESCENDING:
1372              default:
1373                  return null;
1374          }
1375      }
1376  
1377      private void showPopupMenuAtPosition(View view, int position) {
1378          if (view.getContext() == null) {
1379              return;
1380          }
1381  
1382          final Note note = mNotesAdapter.getItem(position + mList.getHeaderViewsCount());
1383          if (note == null) {
1384              return;
1385          }
1386  
1387          PopupMenu popup = new PopupMenu(view.getContext(), view, Gravity.END);
1388          MenuInflater inflater = popup.getMenuInflater();
1389          inflater.inflate(R.menu.bulk_edit, popup.getMenu());
1390  
1391          if (!getListView().isLongClickable()) {
1392              // If viewing the trash, remove pin menu item and change trash menu title to &#x27;Restore&#x27;
1393              popup.getMenu().removeItem(R.id.menu_pin);
1394              if (popup.getMenu().getItem(POPUP_MENU_FIRST_ITEM_POSITION) != null) {
1395                  popup.getMenu().getItem(POPUP_MENU_FIRST_ITEM_POSITION).setTitle(R.string.restore);
1396              }
1397          } else if (popup.getMenu().getItem(POPUP_MENU_FIRST_ITEM_POSITION) != null) {
1398              // If not viewing the trash, set pin menu title based on note pin state
1399              int pinTitle = note.isPinned() ? R.string.unpin_from_top : R.string.pin_to_top;
1400              popup.getMenu().getItem(POPUP_MENU_FIRST_ITEM_POSITION).setTitle(pinTitle);
1401          }
1402  
1403          popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {
1404              @Override
1405              public boolean onMenuItemClick(MenuItem item) {
1406                  switch (item.getItemId()) {
1407                      case R.id.menu_pin:
1408                          note.setPinned(!note.isPinned());
1409                          note.setModificationDate(Calendar.getInstance());
1410                          note.save();
1411                          refreshList();
1412                          return true;
1413                      case R.id.menu_trash:
1414                          note.setDeleted(!note.isDeleted());
1415                          note.setModificationDate(Calendar.getInstance());
1416                          note.save();
1417                          if (getActivity() != null) {
1418                              ((NotesActivity) getActivity()).updateViewsAfterTrashAction(note);
1419                          }
1420                          return true;
1421                      default:
1422                          return false;
1423                  }
1424              }
1425          });
1426  
1427          popup.show();
1428      }
1429  
1430      private static class RefreshListTask extends AsyncTask&lt;Boolean, Void, ObjectCursor&lt;Note&gt;&gt; {
1431          private SoftReference&lt;NoteListFragment&gt; mNoteListFragmentReference;
1432          private boolean mIsFromNavSelect;
1433  
1434          private RefreshListTask(NoteListFragment context) {
1435              mNoteListFragmentReference = new SoftReference&lt;&gt;(context);
1436          }
1437  
1438          @Override
1439          protected ObjectCursor&lt;Note&gt; doInBackground(Boolean... args) {
1440              NoteListFragment fragment = mNoteListFragmentReference.get();
1441              mIsFromNavSelect = args[0];
1442              return fragment.queryNotes();
1443          }
1444  
1445          @Override
1446          protected void onPostExecute(ObjectCursor&lt;Note&gt; cursor) {
1447              NoteListFragment fragment = mNoteListFragmentReference.get();
1448  
1449              if (cursor == null || fragment.getActivity() == null || fragment.getActivity().isFinishing()) {
1450                  return;
1451              }
1452  
<abbr title="1453              // While using a Query.FullTextMatch it&#x27;s easy to enter an invalid term so catch the error and clear the cursor">1453              // While using a Query.FullTextMatch it&#x27;s easy to enter an invalid term so catch the error and clear tðŸ”µ</abbr>
1454              int count;
1455  
1456              try {
1457                  fragment.mNotesAdapter.changeCursor(cursor);
1458                  count = fragment.mNotesAdapter.getCount();
1459              } catch (SQLiteException e) {
1460                  count = 0;
1461                  Log.e(Simplenote.TAG, &quot;Invalid SQL statement&quot;, e);
1462                  fragment.mNotesAdapter.changeCursor(null);
1463              }
1464  
1465              NotesActivity notesActivity = (NotesActivity) fragment.getActivity();
1466  
1467              if (notesActivity != null) {
1468                  if (mIsFromNavSelect &amp;&amp; DisplayUtils.isLargeScreenLandscape(notesActivity)) {
1469                      if (count == 0) {
1470                          notesActivity.showDetailPlaceholder();
1471                      } else {
1472                          // Select the first note
1473                          fragment.selectFirstNote();
1474                      }
1475                  }
1476  
1477                  notesActivity.updateTrashMenuItem(true);
1478              }
1479  
1480              if (fragment.mSelectedNoteId != null) {
1481                  fragment.setNoteSelected(fragment.mSelectedNoteId);
1482                  fragment.mSelectedNoteId = null;
1483              }
1484          }
1485      }
1486  
1487      private static class RefreshListForSearchTask extends AsyncTask&lt;Void, Void, ObjectCursor&lt;Note&gt;&gt; {
1488          private SoftReference&lt;NoteListFragment&gt; mNoteListFragmentReference;
1489  
1490          private RefreshListForSearchTask(NoteListFragment context) {
1491              mNoteListFragmentReference = new SoftReference&lt;&gt;(context);
1492          }
1493  
1494          @Override
1495          protected ObjectCursor&lt;Note&gt; doInBackground(Void... args) {
1496              NoteListFragment fragment = mNoteListFragmentReference.get();
1497              return fragment.queryNotesForSearch();
1498          }
1499  
1500          @Override
1501          protected void onPostExecute(ObjectCursor&lt;Note&gt; cursor) {
1502              NoteListFragment fragment = mNoteListFragmentReference.get();
1503  
1504              if (cursor == null || fragment.getActivity() == null || fragment.getActivity().isFinishing()) {
1505                  return;
1506              }
1507  
<abbr title="1508              // While using Query.FullTextMatch, it&#x27;s easy to enter an invalid term so catch the error and clear the cursor.">1508              // While using Query.FullTextMatch, it&#x27;s easy to enter an invalid term so catch the error and clear thðŸ”µ</abbr>
1509              try {
1510                  fragment.mNotesAdapter.changeCursor(cursor);
1511              } catch (SQLiteException e) {
1512                  Log.e(Simplenote.TAG, &quot;Invalid SQL statement&quot;, e);
1513                  fragment.mNotesAdapter.changeCursor(null);
1514              }
1515  
1516              NotesActivity notesActivity = (NotesActivity) fragment.requireActivity();
1517              notesActivity.updateTrashMenuItem(true);
1518  
1519              if (fragment.mSelectedNoteId != null) {
1520                  fragment.setNoteSelected(fragment.mSelectedNoteId);
1521                  fragment.mSelectedNoteId = null;
1522              }
1523          }
1524      }
1525  
1526      private static class PinNotesTask extends AsyncTask&lt;Void, Void, Void&gt; {
1527          private SoftReference&lt;NoteListFragment&gt; mNoteListFragmentReference;
1528          private SparseBooleanArray mSelectedRows = new SparseBooleanArray();
1529  
1530          private PinNotesTask(NoteListFragment context) {
1531              mNoteListFragmentReference = new SoftReference&lt;&gt;(context);
1532          }
1533  
1534          @Override
1535          protected void onPreExecute() {
1536              NoteListFragment fragment = mNoteListFragmentReference.get();
1537              mSelectedRows = fragment.getListView().getCheckedItemPositions();
1538          }
1539  
1540          @Override
1541          protected Void doInBackground(Void... args) {
1542              NoteListFragment fragment = mNoteListFragmentReference.get();
1543              // Get the checked notes and add them to the pinnedNotesList
1544              // We can&#x27;t modify the note in this loop because the adapter could change
1545              List&lt;Note&gt; pinnedNotesList = new ArrayList&lt;&gt;();
1546  
1547              for (int i = 0; i &lt; mSelectedRows.size(); i++) {
1548                  if (mSelectedRows.valueAt(i)) {
1549                      pinnedNotesList.add(fragment.mNotesAdapter.getItem(mSelectedRows.keyAt(i)));
1550                  }
1551              }
1552  
1553              // Now loop through the notes list and mark them as pinned
1554              for (Note pinnedNote : pinnedNotesList) {
1555                  pinnedNote.setPinned(!pinnedNote.isPinned());
1556                  pinnedNote.setModificationDate(Calendar.getInstance());
1557                  pinnedNote.save();
1558              }
1559  
1560              return null;
1561          }
1562  
1563          @Override
1564          protected void onPostExecute(Void aVoid) {
1565              NoteListFragment fragment = mNoteListFragmentReference.get();
1566              fragment.mActionMode.finish();
1567              fragment.refreshList();
1568          }
1569      }
1570  
1571      private static class TrashNotesTask extends AsyncTask&lt;Void, Void, Void&gt; {
1572          private List&lt;String&gt; mDeletedNoteIds = new ArrayList&lt;&gt;();
1573          private SoftReference&lt;NoteListFragment&gt; mNoteListFragmentReference;
1574          private SparseBooleanArray mSelectedRows = new SparseBooleanArray();
1575  
1576          private TrashNotesTask(NoteListFragment context) {
1577              mNoteListFragmentReference = new SoftReference&lt;&gt;(context);
1578          }
1579  
1580          @Override
1581          protected void onPreExecute() {
1582              NoteListFragment fragment = mNoteListFragmentReference.get();
1583              mSelectedRows = fragment.getListView().getCheckedItemPositions();
1584          }
1585  
1586          @Override
1587          protected Void doInBackground(Void... args) {
1588              NoteListFragment fragment = mNoteListFragmentReference.get();
1589              // Get the checked notes and add them to the deletedNotesList
1590              // We can&#x27;t modify the note in this loop because the adapter could change
1591              List&lt;Note&gt; deletedNotesList = new ArrayList&lt;&gt;();
1592  
1593              for (int i = 0; i &lt; mSelectedRows.size(); i++) {
1594                  if (mSelectedRows.valueAt(i)) {
1595                      deletedNotesList.add(fragment.mNotesAdapter.getItem(mSelectedRows.keyAt(i)));
1596                  }
1597              }
1598  
1599              // Now loop through the notes list and mark them as deleted
1600              for (Note deletedNote : deletedNotesList) {
1601                  mDeletedNoteIds.add(deletedNote.getSimperiumKey());
1602                  deletedNote.setDeleted(!deletedNote.isDeleted());
1603                  deletedNote.setModificationDate(Calendar.getInstance());
1604                  deletedNote.save();
1605              }
1606  
1607              return null;
1608          }
1609  
1610          @Override
1611          protected void onPostExecute(Void aVoid) {
1612              NoteListFragment fragment = mNoteListFragmentReference.get();
1613              NotesActivity notesActivity = ((NotesActivity) fragment.getActivity());
1614  
1615              if (notesActivity != null) {
1616                  notesActivity.showUndoBarWithNoteIds(mDeletedNoteIds);
1617              }
1618  
1619              fragment.refreshList();
1620          }
1621      }
1622  }</pre></td>
                            <td><pre>   1  package com.automattic.simplenote;
   2  
   3  import android.animation.ObjectAnimator;
   4  import android.annotation.SuppressLint;
   5  import android.content.Context;
   6  import android.content.Intent;
   7  import android.content.SharedPreferences;
   8  import android.database.Cursor;
   9  import android.database.sqlite.SQLiteException;
  10  import android.os.AsyncTask;
  11  import android.os.Bundle;
  12  import android.os.Handler;
  13  import android.text.SpannableString;
  14  import android.text.SpannableStringBuilder;
  15  import android.text.TextUtils;
  16  import android.text.style.AbsoluteSizeSpan;
  17  import android.text.style.TextAppearanceSpan;
  18  import android.util.Log;
  19  import android.util.SparseBooleanArray;
  20  import android.util.TypedValue;
  21  import android.view.ActionMode;
  22  import android.view.Gravity;
  23  import android.view.HapticFeedbackConstants;
  24  import android.view.LayoutInflater;
  25  import android.view.Menu;
  26  import android.view.MenuInflater;
  27  import android.view.MenuItem;
  28  import android.view.MotionEvent;
  29  import android.view.View;
  30  import android.view.ViewGroup;
  31  import android.widget.AbsListView;
  32  import android.widget.AdapterView;
  33  import android.widget.CursorAdapter;
  34  import android.widget.ImageButton;
  35  import android.widget.ImageView;
  36  import android.widget.LinearLayout;
  37  import android.widget.ListView;
  38  import android.widget.RelativeLayout;
  39  import android.widget.TextView;
  40  import android.widget.Toast;
  41  
  42  import androidx.annotation.DrawableRes;
  43  import androidx.annotation.NonNull;
  44  import androidx.annotation.StringRes;
  45  import androidx.appcompat.widget.PopupMenu;
  46  import androidx.fragment.app.ListFragment;
  47  import androidx.preference.PreferenceManager;
  48  import androidx.recyclerview.widget.DiffUtil;
  49  import androidx.recyclerview.widget.LinearLayoutManager;
  50  import androidx.recyclerview.widget.RecyclerView;
  51  
  52  import com.automattic.simplenote.analytics.AnalyticsTracker;
  53  import com.automattic.simplenote.models.Note;
  54  import com.automattic.simplenote.models.Preferences;
  55  import com.automattic.simplenote.models.Suggestion;
  56  import com.automattic.simplenote.models.Tag;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  57 +import com.automattic.simplenote.utils.AppLog;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  58 +import com.automattic.simplenote.utils.AppLog.Type;</span>
  59  import com.automattic.simplenote.utils.ChecklistUtils;
  60  import com.automattic.simplenote.utils.DateTimeUtils;
  61  import com.automattic.simplenote.utils.DisplayUtils;
  62  import com.automattic.simplenote.utils.DrawableUtils;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  63 +import com.automattic.simplenote.utils.NetworkUtils;</span>
  64  import com.automattic.simplenote.utils.PrefUtils;
  65  import com.automattic.simplenote.utils.SearchSnippetFormatter;
  66  import com.automattic.simplenote.utils.SearchTokenizer;

  67  import com.automattic.simplenote.utils.StrUtils;
  68  import com.automattic.simplenote.utils.TextHighlighter;
  69  import com.automattic.simplenote.utils.ThemeUtils;
  70  import com.automattic.simplenote.utils.WidgetUtils;
  71  import com.google.android.material.floatingactionbutton.FloatingActionButton;
  72  import com.google.android.material.snackbar.Snackbar;
  73  import com.simperium.client.Bucket;
  74  import com.simperium.client.Bucket.ObjectCursor;
  75  import com.simperium.client.BucketObjectMissingException;
  76  import com.simperium.client.BucketObjectNameInvalid;
  77  import com.simperium.client.Query;
  78  
  79  import java.lang.ref.SoftReference;
  80  import java.util.ArrayList;
  81  import java.util.Calendar;
  82  import java.util.List;
  83  import java.util.regex.Matcher;
  84  import java.util.regex.Pattern;
  85  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  86 +import static com.automattic.simplenote.analytics.AnalyticsTracker.CATEGORY_SEARCH;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  87 +import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.RECENT_SEARCH_TAPPED;</span>
  88  import static com.automattic.simplenote.models.Note.TAGS_PROPERTY;
  89  import static com.automattic.simplenote.models.Preferences.MAX_RECENT_SEARCHES;
  90  import static com.automattic.simplenote.models.Preferences.PREFERENCES_OBJECT_KEY;
  91  import static com.automattic.simplenote.models.Suggestion.Type.HISTORY;
  92  import static com.automattic.simplenote.models.Suggestion.Type.QUERY;
  93  import static com.automattic.simplenote.models.Suggestion.Type.TAG;
  94  import static com.automattic.simplenote.models.Tag.NAME_PROPERTY;
  95  import static com.automattic.simplenote.utils.PrefUtils.ALPHABETICAL_ASCENDING;
  96  import static com.automattic.simplenote.utils.PrefUtils.ALPHABETICAL_DESCENDING;
  97  import static com.automattic.simplenote.utils.PrefUtils.DATE_CREATED_ASCENDING;
  98  import static com.automattic.simplenote.utils.PrefUtils.DATE_CREATED_DESCENDING;
  99  import static com.automattic.simplenote.utils.PrefUtils.DATE_MODIFIED_ASCENDING;
 100  import static com.automattic.simplenote.utils.PrefUtils.DATE_MODIFIED_DESCENDING;
 101  
 102  /**
 103   * A list fragment representing a list of Notes. This fragment also supports
 104   * tablet devices by allowing list items to be given an &#x27;activated&#x27; state upon
 105   * selection. This helps indicate which item is currently being viewed in a
 106   * {@link NoteEditorFragment}.
 107   * &lt;p&gt;
 108   * Activities containing this fragment MUST implement the {@link Callbacks}
 109   * interface.
 110   */
<abbr title=" 111  public class NoteListFragment extends ListFragment implements AdapterView.OnItemLongClickListener, AbsListView.MultiChoiceModeListener, Bucket.Listener&lt;Preferences&gt; {"> 111  public class NoteListFragment extends ListFragment implements AdapterView.OnItemLongClickListener, AbsListView.MulðŸ”µ</abbr>
 112      public static final String TAG_PREFIX = &quot;tag:&quot;;
 113  
 114      /**
 115       * The preferences key representing the activated item position. Only used on tablets.
 116       */
 117      private static final String STATE_ACTIVATED_POSITION = &quot;activated_position&quot;;
 118      private static final int POPUP_MENU_FIRST_ITEM_POSITION = 0;
 119      public static final String ACTION_NEW_NOTE = &quot;com.automattic.simplenote.NEW_NOTE&quot;;
 120      /**
 121       * A dummy implementation of the {@link Callbacks} interface that does
 122       * nothing. Used only when this fragment is not attached to an activity.
 123       */
 124      private static Callbacks sCallbacks = new Callbacks() {
 125          @Override
 126          public void onActionModeCreated() {
 127          }
 128  
 129          @Override
 130          public void onActionModeDestroyed() {
 131          }
 132  
 133          @Override
<abbr title=" 134          public void onNoteSelected(String noteID, String matchOffsets, boolean isMarkdownEnabled, boolean isPreviewEnabled) {"> 134          public void onNoteSelected(String noteID, String matchOffsets, boolean isMarkdownEnabled, boolean isPrevieðŸ”µ</abbr>
 135          }
 136      };
 137      protected NotesCursorAdapter mNotesAdapter;
 138      protected String mSearchString;
 139      private Bucket&lt;Preferences&gt; mBucketPreferences;
 140      private Bucket&lt;Tag&gt; mBucketTag;
 141      private ActionMode mActionMode;
 142      private View mRootView;
 143      private ImageView mEmptyViewImage;
 144      private TextView mEmptyViewText;
 145      private View mDividerLine;
 146      private FloatingActionButton mFloatingActionButton;
 147      private boolean mIsCondensedNoteList;
 148      private boolean mIsSearching;
 149      private ImageView mSortDirection;
 150      private ListView mList;
 151      private ObjectAnimator mSortDirectionAnimation;
 152      private RecyclerView mSuggestionList;
 153      private RelativeLayout mSortLayoutContent;
 154      private RelativeLayout mSuggestionLayout;
 155      private SharedPreferences mPreferences;
 156      private String mSelectedNoteId;
 157      private SuggestionAdapter mSuggestionAdapter;
 158      private TextView mSortOrder;
 159      private RefreshListTask mRefreshListTask;
 160      private RefreshListForSearchTask mRefreshListForSearchTask;
 161      private int mDeletedItemIndex;
 162      private int mPreferenceSortOrder;
 163      private int mTitleFontSize;
 164      private int mPreviewFontSize;
 165      private boolean mIsSortDown;
 166      private boolean mIsSortReverse;
 167      /**
 168       * The fragment&#x27;s current callback object, which is notified of list item
 169       * clicks.
 170       */
 171      private Callbacks mCallbacks = sCallbacks;
 172      /**
 173       * The current activated item position. Only used on tablets.
 174       */
 175      private int mActivatedPosition = ListView.INVALID_POSITION;
 176  
 177      /**
 178       * Mandatory empty constructor for the fragment manager to instantiate the
 179       * fragment (e.g. upon screen orientation changes).
 180       */
 181      public NoteListFragment() {
 182      }
 183  
 184      @Override
 185      public boolean onItemLongClick(AdapterView&lt;?&gt; adapterView, View view, int position, long l) {
 186          getListView().setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);
 187          getListView().setItemChecked(position, true);
 188          if (mActionMode == null)


 189              requireActivity().startActionMode(this);


 190          return true;
 191      }
 192  
 193      @Override
 194      public boolean onCreateActionMode(ActionMode actionMode, Menu menu) {
 195          mCallbacks.onActionModeCreated();
 196          MenuInflater inflater = actionMode.getMenuInflater();
 197          inflater.inflate(R.menu.bulk_edit, menu);
 198          DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.actionModeTextColor);
 199          mActionMode = actionMode;
<abbr title=" 200          int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.background_dark;"> 200          int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.backgroundðŸ”µ</abbr>
<abbr title=" 201          requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().getTheme()));"> 201          requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().getTðŸ”µ</abbr>
 202          return true;
 203      }
 204  
 205      @Override
 206      public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 207          return false;
 208      }
 209  
 210      @Override
 211      public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 212          if (getListView().getCheckedItemIds().length &gt; 0) {
 213  
 214              switch (item.getItemId()) {




 215                  case R.id.menu_trash:
 216                      new TrashNotesTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 217                      break;
 218                  case R.id.menu_pin:
 219                      new PinNotesTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 220                      break;
 221              }
 222          }

 223          return false;














 224      }
 225  
 226      @Override
 227      public void onDestroyActionMode(ActionMode mode) {
 228          mCallbacks.onActionModeDestroyed();
 229          mActionMode = null;
 230          new Handler().postDelayed(
 231              new Runnable() {
 232                  @Override
 233                  public void run() {
 234                      if (getActivity() != null) {
 235                          NotesActivity notesActivity = (NotesActivity) getActivity();
 236                          setActivateOnItemClick(DisplayUtils.isLargeScreenLandscape(notesActivity));
 237                          notesActivity.showDetailPlaceholder();
 238                      }
 239  
<abbr title=" 240                      requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 240                      requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transpðŸ”µ</abbr>
 241                  }
 242              },
 243              requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime)
 244          );
 245      }
 246  
 247      @Override
 248      public void onItemCheckedStateChanged(ActionMode actionMode, int position, long id, boolean checked) {
 249          int checkedCount = getListView().getCheckedItemCount();
 250          if (checkedCount == 0)


 251              actionMode.setTitle(&quot;&quot;);
 252          else

<abbr title=" 253              actionMode.setTitle(getResources().getQuantityString(R.plurals.selected_notes, checkedCount, checkedCount));"> 253              actionMode.setTitle(getResources().getQuantityString(R.plurals.selected_notes, checkedCount, checkedCoðŸ”µ</abbr>



 254      }
 255  
 256      @Override
 257      public void onCreate(Bundle savedInstanceState) {
 258          super.onCreate(savedInstanceState);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 259 +        AppLog.add(Type.NETWORK, NetworkUtils.getNetworkInfo(requireContext()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 260 +        AppLog.add(Type.SCREEN, &quot;Created (NoteListFragment)&quot;);</span>
 261          mBucketPreferences = ((Simplenote) requireActivity().getApplication()).getPreferencesBucket();
 262          mBucketTag = ((Simplenote) requireActivity().getApplication()).getTagsBucket();
 263      }
 264  
 265      protected void getPrefs() {
 266          mPreferenceSortOrder = PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER);
 267          mIsCondensedNoteList = PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_CONDENSED_LIST, false);
 268          mTitleFontSize = PrefUtils.getFontSize(getActivity());
 269          mPreviewFontSize = mTitleFontSize - 2;
 270      }
 271  
 272      @Override
 273      public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
 274          return inflater.inflate(R.layout.fragment_notes_list, container, false);
 275      }
 276  
 277      @Override
 278      public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
 279          super.onViewCreated(view, savedInstanceState);
 280  
 281          NotesActivity notesActivity = (NotesActivity) requireActivity();
 282  
 283          if (ACTION_NEW_NOTE.equals(notesActivity.getIntent().getAction()) &amp;&amp;
 284                  !notesActivity.userIsUnauthorized()){
 285              //if user tap on &quot;app shortcut&quot;, create a new note
 286              createNewNote(&quot;new_note_shortcut&quot;);
 287          }
 288  
 289          mPreferences = PreferenceManager.getDefaultSharedPreferences(requireContext());
 290          mRootView = view.findViewById(R.id.list_root);
 291  
 292          LinearLayout emptyView = view.findViewById(android.R.id.empty);
 293          emptyView.setVisibility(View.GONE);
 294          mEmptyViewImage = emptyView.findViewById(R.id.image);
 295          mEmptyViewText = emptyView.findViewById(R.id.text);
 296          setEmptyListImage(R.drawable.ic_notes_24dp);
 297          setEmptyListMessage(getString(R.string.empty_notes_all));
 298          mDividerLine = view.findViewById(R.id.divider_line);
 299  
 300          if (DisplayUtils.isLargeScreenLandscape(notesActivity)) {
 301              setActivateOnItemClick(true);
 302              mDividerLine.setVisibility(View.VISIBLE);
 303          }
 304  
 305          mFloatingActionButton = view.findViewById(R.id.fab_button);
 306          mFloatingActionButton.setOnClickListener(new View.OnClickListener() {
 307              @Override
 308              public void onClick(View v) {
 309                  createNewNote(&quot;action_bar_button&quot;);
 310              }
 311          });
 312          mFloatingActionButton.setOnLongClickListener(new View.OnLongClickListener() {
 313              @Override
 314              public boolean onLongClick(View v) {
 315                  if (v.isHapticFeedbackEnabled()) {
 316                      v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
 317                  }
 318  
<abbr title=" 319                  Toast.makeText(getContext(), requireContext().getString(R.string.new_note), Toast.LENGTH_SHORT).show();"> 319                  Toast.makeText(getContext(), requireContext().getString(R.string.new_note), Toast.LENGTH_SHORT).shðŸ”µ</abbr>
 320                  return true;
 321              }
 322          });
 323  
 324          mSuggestionLayout = view.findViewById(R.id.suggestion_layout);
 325          mSuggestionList = view.findViewById(R.id.suggestion_list);
 326          mSuggestionAdapter = new SuggestionAdapter(new ArrayList&lt;Suggestion&gt;());
 327          mSuggestionList.setAdapter(mSuggestionAdapter);
 328          mSuggestionList.setLayoutManager(new LinearLayoutManager(requireContext()));
 329          @SuppressLint(&quot;InflateParams&quot;)
<abbr title=" 330          LinearLayout sortLayoutContainer = (LinearLayout) getLayoutInflater().inflate(R.layout.search_sort, null, false);"> 330          LinearLayout sortLayoutContainer = (LinearLayout) getLayoutInflater().inflate(R.layout.search_sort, null, ðŸ”µ</abbr>
 331          mSortLayoutContent = sortLayoutContainer.findViewById(R.id.sort_content);
 332          mSortLayoutContent.setVisibility(mIsSearching ? View.VISIBLE : View.GONE);
 333          mSortOrder = sortLayoutContainer.findViewById(R.id.sort_order);
 334          mSortLayoutContent.setOnClickListener(new View.OnClickListener() {
 335              @Override
 336              public void onClick(View v) {
 337                  PopupMenu popup = new PopupMenu(mSortOrder.getContext(), mSortOrder, Gravity.START);
 338                  MenuInflater inflater = popup.getMenuInflater();
 339                  inflater.inflate(R.menu.search_sort, popup.getMenu());
 340                  popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {
 341                      @Override
 342                      public boolean onMenuItemClick(MenuItem item) {
 343                          // Do nothing when same sort is selected.
 344                          if (mSortOrder.getText().equals(item.getTitle())) {
 345                              return false;
 346                          }
 347  
 348                          mSortOrder.setText(item.getTitle());
 349  
 350                          switch (item.getItemId()) {
 351                              case R.id.search_alphabetically:
 352                                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER,
 353                                      String.valueOf(ALPHABETICAL_ASCENDING)
 354                                  ).apply();
 355  
 356                                  // If arrow is down, rotate it up for ascending direction.
 357                                  if (mIsSortDown &amp;&amp; !mIsSortReverse) {
 358                                      mSortDirectionAnimation.start();
 359                                      mIsSortReverse = true;
 360                                  } else if (!mIsSortDown &amp;&amp; mIsSortReverse) {
 361                                      mSortDirectionAnimation.reverse();
 362                                      mIsSortReverse = false;
 363                                  }
 364  
 365                                  refreshListForSearch();
 366                                  return true;
 367                              case R.id.search_created:
 368                                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER,
 369                                      String.valueOf(DATE_CREATED_DESCENDING)
 370                                  ).apply();
 371  
 372                                  // If arrow is up, rotate it down for descending direction.
 373                                  if (mIsSortDown &amp;&amp; mIsSortReverse) {
 374                                      mSortDirectionAnimation.reverse();
 375                                      mIsSortReverse = false;
 376                                  } else if (!mIsSortDown &amp;&amp; !mIsSortReverse) {
 377                                      mSortDirectionAnimation.start();
 378                                      mIsSortReverse = true;
 379                                  }
 380  
 381                                  refreshListForSearch();
 382                                  return true;
 383                              case R.id.search_modified:
 384                                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER,
 385                                      String.valueOf(DATE_MODIFIED_DESCENDING)
 386                                  ).apply();
 387  
 388                                  // If arrow is up, rotate it down for descending direction.
 389                                  if (mIsSortDown &amp;&amp; mIsSortReverse) {
 390                                      mSortDirectionAnimation.reverse();
 391                                      mIsSortReverse = false;
 392                                  } else if (!mIsSortDown &amp;&amp; !mIsSortReverse) {
 393                                      mSortDirectionAnimation.start();
 394                                      mIsSortReverse = true;
 395                                  }
 396  
 397                                  refreshListForSearch();
 398                                  return true;
 399                              default:
 400                                  return false;
 401                          }
 402                      }
 403                  });
 404                  popup.show();
 405              }
 406          });
 407          mList = view.findViewById(android.R.id.list);
 408          mList.addHeaderView(sortLayoutContainer);
 409  
 410          mNotesAdapter = new NotesCursorAdapter(requireActivity().getBaseContext(), null, 0);
 411          setListAdapter(mNotesAdapter);
 412  
 413          getListView().setOnItemLongClickListener(this);
 414          getListView().setMultiChoiceModeListener(this);
 415  
 416          mSortDirection = sortLayoutContainer.findViewById(R.id.sort_direction);
 417          ImageView sortDirectionSwitch = sortLayoutContainer.findViewById(R.id.sort_direction_switch);
 418          sortDirectionSwitch.setImageResource(R.drawable.ic_sort_order_24dp);
 419          sortDirectionSwitch.setOnClickListener(new View.OnClickListener() {
 420              @Override
 421              public void onClick(View v) {
 422                  if (mIsSortReverse) {
 423                      mSortDirectionAnimation.reverse();
 424                  } else {
 425                      mSortDirectionAnimation.start();
 426                  }
 427  
 428                  mIsSortReverse = !mIsSortReverse;
 429                  switchSortDirection();
 430                  refreshListForSearch();
 431              }
 432          });
 433          sortDirectionSwitch.setOnLongClickListener(new View.OnLongClickListener() {
 434              @Override
 435              public boolean onLongClick(View v) {
 436                  if (v.isHapticFeedbackEnabled()) {
 437                      v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
 438                  }
 439  
<abbr title=" 440                  Toast.makeText(requireContext(), requireContext().getString(R.string.sort_search_reverse_order), Toast.LENGTH_SHORT).show();"> 440                  Toast.makeText(requireContext(), requireContext().getString(R.string.sort_search_reverse_order), TðŸ”µ</abbr>
 441                  return true;
 442              }
 443          });
 444      }
 445  
 446      public void showListPadding(boolean show) {
 447          mList.setPadding(
 448              mList.getPaddingLeft(),
 449              mList.getPaddingTop(),
 450              mList.getPaddingRight(),
 451              show ? (int) getResources().getDimension(R.dimen.note_list_item_padding_bottom_button) : 0
 452          );
 453      }
 454  
 455      private @StringRes int getSortOrderText() {
 456          switch (PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER)) {
 457              case ALPHABETICAL_ASCENDING:
 458              case ALPHABETICAL_DESCENDING:
 459                  return R.string.sort_search_alphabetically;
 460              case DATE_CREATED_ASCENDING:
 461              case DATE_CREATED_DESCENDING:
 462                  return R.string.sort_search_created;
 463              case DATE_MODIFIED_ASCENDING:
 464              case DATE_MODIFIED_DESCENDING:
 465              default:
 466                  return R.string.sort_search_modified;
 467          }
 468      }
 469  
 470      private void setSortDirection() {
 471          if (mIsSortReverse) {
 472              mSortDirectionAnimation.reverse();
 473              mIsSortReverse = false;
 474          }
 475  
 476          switch (PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER)) {
 477              case ALPHABETICAL_ASCENDING:
 478              case DATE_CREATED_ASCENDING:
 479              case DATE_MODIFIED_ASCENDING:
 480                  mSortDirection.setContentDescription(getString(R.string.description_up));
 481                  mSortDirection.setImageResource(R.drawable.ic_arrow_up_16dp);
 482                  mIsSortDown = false;
 483                  break;
 484              case ALPHABETICAL_DESCENDING:
 485              case DATE_CREATED_DESCENDING:
 486              case DATE_MODIFIED_DESCENDING:
 487              default:
 488                  mSortDirection.setContentDescription(getString(R.string.description_down));
 489                  mSortDirection.setImageResource(R.drawable.ic_arrow_down_16dp);
 490                  mIsSortDown = true;
 491                  break;
 492          }
 493  
 494          mSortDirectionAnimation = ObjectAnimator.ofFloat(
 495              mSortDirection,
 496              View.ROTATION,
 497              0f,
 498              mIsSortDown ? -180f : 180f
 499          ).setDuration(getResources().getInteger(android.R.integer.config_shortAnimTime));
 500      }
 501  
 502      private void switchSortDirection() {
 503          switch (PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER)) {
 504              case DATE_MODIFIED_DESCENDING:
<abbr title=" 505                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_MODIFIED_ASCENDING)).apply();"> 505                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_MODIFIED_ASCENDING)).ðŸ”µ</abbr>
 506                  break;
 507              case DATE_MODIFIED_ASCENDING:
<abbr title=" 508                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_MODIFIED_DESCENDING)).apply();"> 508                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_MODIFIED_DESCENDING))ðŸ”µ</abbr>
 509                  break;
 510              case DATE_CREATED_DESCENDING:
<abbr title=" 511                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_CREATED_ASCENDING)).apply();"> 511                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_CREATED_ASCENDING)).aðŸ”µ</abbr>
 512                  break;
 513              case DATE_CREATED_ASCENDING:
<abbr title=" 514                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_CREATED_DESCENDING)).apply();"> 514                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(DATE_CREATED_DESCENDING)).ðŸ”µ</abbr>
 515                  break;
 516              case ALPHABETICAL_ASCENDING:
<abbr title=" 517                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(ALPHABETICAL_DESCENDING)).apply();"> 517                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(ALPHABETICAL_DESCENDING)).ðŸ”µ</abbr>
 518                  break;
 519              case ALPHABETICAL_DESCENDING:
<abbr title=" 520                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(ALPHABETICAL_ASCENDING)).apply();"> 520                  mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(ALPHABETICAL_ASCENDING)).aðŸ”µ</abbr>
 521                  break;
 522          }
 523      }
 524  
 525      public void createNewNote(String label){
 526          if (!isAdded()) return;
 527  
 528          addNote();
 529          AnalyticsTracker.track(
 530                  AnalyticsTracker.Stat.LIST_NOTE_CREATED,
 531                  AnalyticsTracker.CATEGORY_NOTE,
 532                  label
 533          );
 534      }
 535  
 536      @Override
 537      public void onAttach(@NonNull Context activity) {
 538          super.onAttach(activity);
 539  
 540          // Activities containing this fragment must implement its callbacks.
 541          if (!(activity instanceof Callbacks)) {
 542              throw new IllegalStateException(&quot;Activity must implement fragment&#x27;s callbacks.&quot;);
 543          }
 544  
 545          mCallbacks = (Callbacks) activity;
 546      }
 547  
 548      @Override
 549      public void onResume() {
 550          super.onResume();
 551          getPrefs();
 552  
 553          if (mIsSearching) {
 554              refreshListForSearch();
 555          } else {
 556              refreshList();
 557          }
 558  
 559          mBucketPreferences.start();
 560          mBucketPreferences.addOnDeleteObjectListener(this);
 561          mBucketPreferences.addOnNetworkChangeListener(this);
 562          mBucketPreferences.addOnSaveObjectListener(this);
 563      }
 564  
 565      @Override
 566      public void onPause() {
 567          super.onPause();
 568          mBucketPreferences.removeOnDeleteObjectListener(this);
 569          mBucketPreferences.removeOnNetworkChangeListener(this);
 570          mBucketPreferences.removeOnSaveObjectListener(this);
 571          mBucketPreferences.stop();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 572 +        AppLog.add(Type.SCREEN, &quot;Paused (NoteListFragment)&quot;);</span>
 573      }
 574  
 575      @Override
 576      public void onDetach() {
 577          super.onDetach();
 578          // Restore sort order from Settings.
 579          mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(mPreferenceSortOrder)).apply();
 580          // Reset the active callbacks interface to the dummy implementation.
 581          mCallbacks = sCallbacks;
 582      }
 583  
 584      public void setEmptyListImage(@DrawableRes int image) {
 585          if (mEmptyViewImage != null) {
 586              if (image != -1) {
 587                  mEmptyViewImage.setVisibility(View.VISIBLE);
 588                  mEmptyViewImage.setImageResource(image);
 589              } else {
 590                  mEmptyViewImage.setVisibility(View.GONE);
 591              }
 592          }
 593      }
 594  
 595      public void setEmptyListMessage(String message) {
 596          if (mEmptyViewText != null &amp;&amp; message != null) {
 597              mEmptyViewText.setText(message);
 598          }
 599      }
 600  
 601      @Override
 602      public void onListItemClick(@NonNull ListView listView, @NonNull View view, int position, long id) {
 603          if (!isAdded()) return;
 604          super.onListItemClick(listView, view, position, id);
 605  
 606          NoteViewHolder holder = (NoteViewHolder) view.getTag();
 607          String noteID = holder.getNoteId();
 608  
 609          if (noteID != null) {
 610              Note note = mNotesAdapter.getItem(position);
<abbr title=" 611              mCallbacks.onNoteSelected(noteID, holder.mMatchOffsets, note.isMarkdownEnabled(), note.isPreviewEnabled());"> 611              mCallbacks.onNoteSelected(noteID, holder.mMatchOffsets, note.isMarkdownEnabled(), note.isPreviewEnableðŸ”µ</abbr>
 612          }
 613  
 614          mActivatedPosition = position;
 615      }
 616  
 617      /**
 618       * Selects first row in the list if available
 619       */
 620      public void selectFirstNote() {
 621          if (mNotesAdapter.getCount() &gt; 0) {
 622              Note selectedNote = mNotesAdapter.getItem(mList.getHeaderViewsCount());
<abbr title=" 623              mCallbacks.onNoteSelected(selectedNote.getSimperiumKey(), null, selectedNote.isMarkdownEnabled(), selectedNote.isPreviewEnabled());"> 623              mCallbacks.onNoteSelected(selectedNote.getSimperiumKey(), null, selectedNote.isMarkdownEnabled(), seleðŸ”µ</abbr>
 624          }
 625      }
 626  
 627      @Override
 628      public void onSaveInstanceState(@NonNull Bundle outState) {
 629          super.onSaveInstanceState(outState);
 630          if (mActivatedPosition != ListView.INVALID_POSITION) {
 631              // Serialize and persist the activated item position.
 632              outState.putInt(STATE_ACTIVATED_POSITION, mActivatedPosition);
 633          }
 634      }
 635  
 636      public View getRootView() {
 637          return mRootView;
 638      }
 639  
 640      /**
 641       * Turns on activate-on-click mode. When this mode is on, list items will be
 642       * given the &#x27;activated&#x27; state when touched.
 643       */
 644      public void setActivateOnItemClick(boolean activateOnItemClick) {
 645          // When setting CHOICE_MODE_SINGLE, ListView will automatically
 646          // give items the &#x27;activated&#x27; state when touched.
<abbr title=" 647          getListView().setChoiceMode(activateOnItemClick ? ListView.CHOICE_MODE_SINGLE : ListView.CHOICE_MODE_NONE);"> 647          getListView().setChoiceMode(activateOnItemClick ? ListView.CHOICE_MODE_SINGLE : ListView.CHOICE_MODE_NONE)ðŸ”µ</abbr>
 648      }
 649  
 650      public void setActivatedPosition(int position) {
 651          if (getListView() != null) {
 652              if (position == ListView.INVALID_POSITION) {
 653                  getListView().setItemChecked(mActivatedPosition, false);
 654              } else {
 655                  getListView().setItemChecked(position, true);
 656              }
 657  
 658              mActivatedPosition = position;
 659          }
 660      }
 661  
 662      public void setDividerVisible(boolean visible) {
 663          mDividerLine.setVisibility(visible ? View.VISIBLE : View.GONE);
 664      }
 665  
 666      public void setFloatingActionButtonVisible(boolean visible) {
 667          if (mFloatingActionButton == null) return;
 668  
 669          if (visible) {
 670              mFloatingActionButton.show();
 671          } else {
 672              mFloatingActionButton.hide();
 673          }
 674      }
 675  
 676      public void refreshList() {
 677          mSortOrder.setText(getSortOrderText());
 678          setSortDirection();
 679          refreshList(false);
 680      }
 681  
 682      public void refreshList(boolean fromNav) {
 683          if (mRefreshListTask != null &amp;&amp; mRefreshListTask.getStatus() != AsyncTask.Status.FINISHED)
 684              mRefreshListTask.cancel(true);
 685  
 686          mRefreshListTask = new RefreshListTask(this);
 687          mRefreshListTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, fromNav);
 688  
 689          WidgetUtils.updateNoteWidgets(requireActivity().getApplicationContext());
 690      }
 691  
 692      private void refreshListForSearch() {
<abbr title=" 693          if (mRefreshListForSearchTask != null &amp;&amp; mRefreshListForSearchTask.getStatus() != AsyncTask.Status.FINISHED) {"> 693          if (mRefreshListForSearchTask != null &amp;&amp; mRefreshListForSearchTask.getStatus() != AsyncTask.Status.FINISHEðŸ”µ</abbr>
 694              mRefreshListForSearchTask.cancel(true);
 695          }
 696  
 697          mRefreshListForSearchTask = new RefreshListForSearchTask(this);
 698          mRefreshListForSearchTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 699      }
 700  
 701      public void refreshListFromNavSelect() {
 702          refreshList(true);
 703      }
 704  
 705      public ObjectCursor&lt;Note&gt; queryNotes() {
 706          if (!isAdded()) return null;
 707  
 708          NotesActivity notesActivity = (NotesActivity) requireActivity();
 709          Query&lt;Note&gt; query = notesActivity.getSelectedTag().query();
 710  
 711          String searchString = mSearchString;
 712          if (hasSearchQuery()) {
 713              searchString = queryTags(query, mSearchString);
 714          }
 715          if (!TextUtils.isEmpty(searchString)) {
 716              query.where(new Query.FullTextMatch(new SearchTokenizer(searchString)));
 717              query.include(new Query.FullTextOffsets(&quot;match_offsets&quot;));
 718              query.include(new Query.FullTextSnippet(Note.MATCHED_TITLE_INDEX_NAME, Note.TITLE_INDEX_NAME));
 719              query.include(new Query.FullTextSnippet(Note.MATCHED_CONTENT_INDEX_NAME, Note.CONTENT_PROPERTY));
 720              query.include(Note.TITLE_INDEX_NAME, Note.CONTENT_PREVIEW_INDEX_NAME);
 721          } else {
 722              query.include(Note.TITLE_INDEX_NAME, Note.CONTENT_PREVIEW_INDEX_NAME);
 723          }
 724  
 725          query.include(Note.PINNED_INDEX_NAME);
 726          PrefUtils.sortNoteQuery(query, requireContext(), true);
 727          return query.execute();
 728      }
 729  
 730      private ObjectCursor&lt;Note&gt; queryNotesForSearch() {
 731          if (!isAdded()) {
 732              return null;
 733          }
 734  
 735          Query&lt;Note&gt; query = Note.all(((Simplenote) requireActivity().getApplication()).getNotesBucket());
 736          String searchString = mSearchString;
 737  
 738          if (hasSearchQuery()) {
 739              searchString = queryTags(query, mSearchString);
 740          }
 741  
 742          if (!TextUtils.isEmpty(searchString)) {
 743              query.where(new Query.FullTextMatch(new SearchTokenizer(searchString)));
 744              query.include(new Query.FullTextOffsets(&quot;match_offsets&quot;));
 745              query.include(new Query.FullTextSnippet(Note.MATCHED_TITLE_INDEX_NAME, Note.TITLE_INDEX_NAME));
 746              query.include(new Query.FullTextSnippet(Note.MATCHED_CONTENT_INDEX_NAME, Note.CONTENT_PROPERTY));
 747              query.include(Note.TITLE_INDEX_NAME, Note.CONTENT_PREVIEW_INDEX_NAME);
 748          } else {
 749              query.include(Note.TITLE_INDEX_NAME, Note.CONTENT_PREVIEW_INDEX_NAME);
 750          }
 751  
 752          PrefUtils.sortNoteQuery(query, requireContext(), false);
 753          return query.execute();
 754      }
 755  
 756      private String queryTags(Query&lt;Note&gt; query, String searchString) {
 757          Pattern pattern = Pattern.compile(TAG_PREFIX + &quot;(.*?)( |$)&quot;);
 758          Matcher matcher = pattern.matcher(searchString);
 759          while (matcher.find()) {
 760              query.where(TAGS_PROPERTY, Query.ComparisonType.LIKE, matcher.group(1));
 761          }
 762          return matcher.replaceAll(&quot;&quot;);
 763      }
 764  
 765      public void addNote() {
 766  
 767          // Prevents jarring &#x27;New note...&#x27; from showing in the list view when creating a new note
 768          NotesActivity notesActivity = (NotesActivity) requireActivity();
 769          if (!DisplayUtils.isLargeScreenLandscape(notesActivity))
 770              notesActivity.stopListeningToNotesBucket();
 771  
 772          // Create &amp; save new note
 773          Simplenote simplenote = (Simplenote) requireActivity().getApplication();
 774          Bucket&lt;Note&gt; notesBucket = simplenote.getNotesBucket();
 775          final Note note = notesBucket.newObject();
 776          note.setCreationDate(Calendar.getInstance());
 777          note.setModificationDate(note.getCreationDate());
 778          note.setMarkdownEnabled(PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_MARKDOWN_ENABLED, false));
 779  
 780          if (notesActivity.getSelectedTag() != null &amp;&amp; notesActivity.getSelectedTag().name != null) {
 781              String tagName = notesActivity.getSelectedTag().name;
<abbr title=" 782              if (!tagName.equals(getString(R.string.all_notes)) &amp;&amp; !tagName.equals(getString(R.string.trash)) &amp;&amp; !tagName.equals(getString(R.string.untagged_notes)))"> 782              if (!tagName.equals(getString(R.string.all_notes)) &amp;&amp; !tagName.equals(getString(R.string.trash)) &amp;&amp; !tðŸ”µ</abbr>
 783                  note.setTagString(tagName);
 784          }
 785  
 786          note.save();
 787  
 788          if (DisplayUtils.isLargeScreenLandscape(getActivity())) {
 789              // Hack: Simperium saves async so we add a small delay to ensure the new note is truly
 790              // saved before proceeding.
 791              new Handler().postDelayed(new Runnable() {
 792                  @Override
 793                  public void run() {
<abbr title=" 794                      mCallbacks.onNoteSelected(note.getSimperiumKey(), null, note.isMarkdownEnabled(), note.isPreviewEnabled());"> 794                      mCallbacks.onNoteSelected(note.getSimperiumKey(), null, note.isMarkdownEnabled(), note.isPreviðŸ”µ</abbr>
 795                  }
 796              }, 50);
 797          } else {
 798              Bundle arguments = new Bundle();
 799              arguments.putString(NoteEditorFragment.ARG_ITEM_ID, note.getSimperiumKey());
 800              arguments.putBoolean(NoteEditorFragment.ARG_NEW_NOTE, true);
 801              arguments.putBoolean(NoteEditorFragment.ARG_MARKDOWN_ENABLED, note.isMarkdownEnabled());
 802              arguments.putBoolean(NoteEditorFragment.ARG_PREVIEW_ENABLED, note.isPreviewEnabled());
 803              Intent editNoteIntent = new Intent(getActivity(), NoteEditorActivity.class);
 804              editNoteIntent.putExtras(arguments);
 805  
 806              requireActivity().startActivityForResult(editNoteIntent, Simplenote.INTENT_EDIT_NOTE);
 807          }
 808      }
 809  
 810      public void setNoteSelected(String selectedNoteID) {
 811          // Loop through notes and set note selected if found
 812          //noinspection unchecked
 813          ObjectCursor&lt;Note&gt; cursor = (ObjectCursor&lt;Note&gt;) mNotesAdapter.getCursor();
 814          if (cursor != null) {
 815              for (int i = 0; i &lt; cursor.getCount(); i++) {
 816                  cursor.moveToPosition(i);
 817                  String noteKey = cursor.getSimperiumKey();
 818                  if (noteKey != null &amp;&amp; noteKey.equals(selectedNoteID)) {
 819                      setActivatedPosition(i + mList.getHeaderViewsCount());
 820                      return;
 821                  }
 822              }
 823          }
 824  
 825          // Didn&#x27;t find the note, let&#x27;s try again after the cursor updates (see RefreshListTask)
 826          mSelectedNoteId = selectedNoteID;
 827      }
 828  
 829      public void searchNotes(String searchString, boolean isSubmit) {
 830          mIsSearching = true;
 831          mSortLayoutContent.setVisibility(View.VISIBLE);
 832          mSuggestionLayout.setVisibility(View.VISIBLE);
 833          mSortOrder.setText(getSortOrderText());
 834  
 835          if (!searchString.equals(mSearchString)) {
 836              mSearchString = searchString;
 837          }
 838  
 839          if (searchString.isEmpty()) {
 840              getSearchItems();
 841          } else {
 842              getTagSuggestions(searchString);
 843          }
 844  
 845          if (isSubmit) {
 846              mSuggestionLayout.setVisibility(View.GONE);
 847              refreshListForSearch();
 848          }
 849      }
 850  
 851      /**
 852       * Clear search and load all notes
 853       */
 854      public void clearSearch() {
 855          mIsSearching = false;
 856          mSortLayoutContent.setVisibility(View.GONE);
 857          mSuggestionLayout.setVisibility(View.GONE);
 858          // Restore sort order from Settings.
 859          mPreferences.edit().putString(PrefUtils.PREF_SORT_ORDER, String.valueOf(mPreferenceSortOrder)).apply();
 860          refreshList();
 861  
 862          if (mSearchString != null &amp;&amp; !mSearchString.equals(&quot;&quot;)) {
 863              mSearchString = null;
 864              refreshList();
 865          }
 866      }
 867  
 868      public boolean hasSearchQuery() {
 869          return mSearchString != null &amp;&amp; !mSearchString.equals(&quot;&quot;);
 870      }
 871  
 872      public void addSearchItem(String item, int index) {
 873          Preferences preferences = getPreferences();
 874  
 875          if (preferences != null) {
 876              List&lt;String&gt; recents = preferences.getRecentSearches();
 877              recents.remove(item);
 878              recents.add(index, item);
<abbr title=" 879              // Trim recent searches to MAX_RECENT_SEARCHES (currently 5) if size is greater than MAX_RECENT_SEARCHES."> 879              // Trim recent searches to MAX_RECENT_SEARCHES (currently 5) if size is greater than MAX_RECENT_SEARCHðŸ”µ</abbr>
<abbr title=" 880              preferences.setRecentSearches(recents.subList(0, recents.size() &gt; MAX_RECENT_SEARCHES ? MAX_RECENT_SEARCHES : recents.size()));"> 880              preferences.setRecentSearches(recents.subList(0, recents.size() &gt; MAX_RECENT_SEARCHES ? MAX_RECENT_SEAðŸ”µ</abbr>
 881              preferences.save();
 882          } else {
 883              Log.e(&quot;addSearchItem&quot;, &quot;Could not get preferences entity&quot;);
 884          }
 885      }
 886  
 887      private void deleteSearchItem(String item) {
 888          Preferences preferences = getPreferences();
 889  
 890          if (preferences != null) {
 891              List&lt;String&gt; recents = preferences.getRecentSearches();
 892              mDeletedItemIndex = recents.indexOf(item);
 893              recents.remove(item);
 894              preferences.setRecentSearches(recents);
 895              preferences.save();
 896          } else {
 897              Log.e(&quot;deleteSearchItem&quot;, &quot;Could not get preferences entity&quot;);
 898          }
 899      }
 900  
 901      private Preferences getPreferences() {
 902          try {
 903              return mBucketPreferences.get(PREFERENCES_OBJECT_KEY);
 904          } catch (BucketObjectMissingException exception) {
 905              try {
 906                  Preferences preferences = mBucketPreferences.newObject(PREFERENCES_OBJECT_KEY);
 907                  preferences.save();
 908                  return preferences;
 909              } catch (BucketObjectNameInvalid invalid) {
 910                  Log.e(&quot;getPreferences&quot;, &quot;Could not create preferences entity&quot;, invalid);
 911                  return null;
 912              }
 913          }
 914      }
 915  
 916      private void getSearchItems() {
 917          Preferences preferences = getPreferences();
 918  
 919          if (preferences != null) {
 920              ArrayList&lt;Suggestion&gt; suggestions = new ArrayList&lt;&gt;();
 921  
 922              for (String recent : preferences.getRecentSearches()) {
 923                  suggestions.add(new Suggestion(recent, HISTORY));
 924              }
 925  
 926              mSuggestionAdapter.updateItems(suggestions);
 927          } else {
 928              Log.e(&quot;getSearchItems&quot;, &quot;Could not get preferences entity&quot;);
 929          }
 930      }
 931  
 932      private void getTagSuggestions(String query) {
 933          ArrayList&lt;Suggestion&gt; suggestions = new ArrayList&lt;&gt;();
 934          suggestions.add(new Suggestion(query, QUERY));
<abbr title=" 935          Query&lt;Tag&gt; tags = Tag.all(mBucketTag).reorder().order(Tag.NOTE_COUNT_INDEX_NAME, Query.SortType.DESCENDING);"> 935          Query&lt;Tag&gt; tags = Tag.all(mBucketTag).reorder().order(Tag.NOTE_COUNT_INDEX_NAME, Query.SortType.DESCENDINGðŸ”µ</abbr>
 936  
 937          if (!query.endsWith(TAG_PREFIX)) {
 938              tags.where(NAME_PROPERTY, Query.ComparisonType.LIKE, &quot;%&quot; + query + &quot;%&quot;);
 939          }
 940  
 941          try (ObjectCursor&lt;Tag&gt; cursor = tags.execute()) {
 942              while (cursor.moveToNext()) {
 943                  suggestions.add(new Suggestion(cursor.getObject().getName(), TAG));
 944              }
 945          }
 946  
 947          mSuggestionAdapter = new SuggestionAdapter(suggestions);
 948          mSuggestionList.setAdapter(mSuggestionAdapter);
 949      }
 950  
 951      /**
 952       * A callback interface that all activities containing this fragment must
 953       * implement. This mechanism allows activities to be notified of item
 954       * selections.
 955       */
 956      public interface Callbacks {
 957          /**
 958           * Callback for when action mode is created.
 959           */
 960          void onActionModeCreated();
 961          /**
 962           * Callback for when action mode is destroyed.
 963           */
 964          void onActionModeDestroyed();
 965          /**
 966           * Callback for when a note has been selected.
 967           */
<abbr title=" 968          void onNoteSelected(String noteID, String matchOffsets, boolean isMarkdownEnabled, boolean isPreviewEnabled);"> 968          void onNoteSelected(String noteID, String matchOffsets, boolean isMarkdownEnabled, boolean isPreviewEnableðŸ”µ</abbr>
 969      }
 970  
 971      // view holder for NotesCursorAdapter
 972      private static class NoteViewHolder {
 973          private ImageView mPinned;
 974          private ImageView mPublished;
 975          private TextView mContent;
 976          private TextView mDate;
 977          private TextView mTitle;
 978          private String mMatchOffsets;
 979          private String mNoteId;
 980          private View mStatus;
 981  
 982          public String getNoteId() {
 983              return mNoteId;
 984          }
 985  
 986          public void setNoteId(String noteId) {
 987              mNoteId = noteId;
 988          }
 989      }
 990  
 991      public class NotesCursorAdapter extends CursorAdapter {
 992          private ObjectCursor&lt;Note&gt; mCursor;
 993  
 994          private SearchSnippetFormatter.SpanFactory mSnippetHighlighter = new TextHighlighter(requireActivity(),
 995                  R.attr.listSearchHighlightForegroundColor, R.attr.listSearchHighlightBackgroundColor);
 996  
 997          public NotesCursorAdapter(Context context, ObjectCursor&lt;Note&gt; c, int flags) {
 998              super(context, c, flags);
 999              mCursor = c;
1000          }
1001  
1002          public void changeCursor(ObjectCursor&lt;Note&gt; cursor) {
1003              mCursor = cursor;
1004              super.changeCursor(cursor);
1005          }
1006  
1007          @Override
1008          public Note getItem(int position) {
1009              mCursor.moveToPosition(position - mList.getHeaderViewsCount());
1010              return mCursor.getObject();
1011          }
1012  
1013          /*
1014           *  nbradbury - implemented &quot;holder pattern&quot; to boost performance with large note lists
1015           */
1016          @Override
1017          public View getView(final int position, View view, ViewGroup parent) {
1018              final NoteViewHolder holder;
1019  
1020              if (view == null) {
1021                  view = View.inflate(requireActivity().getBaseContext(), R.layout.note_list_row, null);
1022                  holder = new NoteViewHolder();
1023                  holder.mTitle = view.findViewById(R.id.note_title);
1024                  holder.mContent = view.findViewById(R.id.note_content);
1025                  holder.mDate = view.findViewById(R.id.note_date);
1026                  holder.mPinned = view.findViewById(R.id.note_pinned);
1027                  holder.mPublished = view.findViewById(R.id.note_published);
1028                  holder.mStatus = view.findViewById(R.id.note_status);
1029                  view.setTag(holder);
1030              } else {
1031                  holder = (NoteViewHolder) view.getTag();
1032              }
1033  
1034              if (holder.mTitle.getTextSize() != mTitleFontSize) {
1035                  holder.mTitle.setTextSize(TypedValue.COMPLEX_UNIT_SP, mTitleFontSize);
1036                  holder.mContent.setTextSize(TypedValue.COMPLEX_UNIT_SP, mPreviewFontSize);
1037                  holder.mDate.setTextSize(TypedValue.COMPLEX_UNIT_SP, mPreviewFontSize);
1038              }
1039  
1040              if (position == getListView().getCheckedItemPosition())
1041                  view.setActivated(true);
1042              else
1043                  view.setActivated(false);
1044  
1045              // for performance reasons we are going to get indexed values
1046              // from the cursor instead of instantiating the entire bucket object
1047              holder.mContent.setVisibility(mIsCondensedNoteList ? View.GONE : View.VISIBLE);
1048              mCursor.moveToPosition(position);
1049              holder.setNoteId(mCursor.getSimperiumKey());
1050              Calendar date = getDateByPreference(mCursor.getObject());
1051              holder.mDate.setText(date != null ? DateTimeUtils.getDateTextNumeric(date) : &quot;&quot;);
1052              holder.mDate.setVisibility(mIsSearching &amp;&amp; date != null ? View.VISIBLE : View.GONE);
1053              boolean isPinned = mCursor.getObject().isPinned();
1054              holder.mPinned.setVisibility(!isPinned || mIsSearching ? View.GONE : View.VISIBLE);
1055              boolean isPublished = !mCursor.getObject().getPublishedUrl().isEmpty();
1056              holder.mPublished.setVisibility(!isPublished || mIsSearching ? View.GONE : View.VISIBLE);
1057              boolean showIcons = isPinned || isPublished;
1058              boolean showDate = mIsSearching &amp;&amp; date != null;
1059              holder.mStatus.setVisibility(showIcons || showDate ? View.VISIBLE : View.GONE);
1060              String title = mCursor.getString(mCursor.getColumnIndex(Note.TITLE_INDEX_NAME));
1061  
1062              if (TextUtils.isEmpty(title)) {
1063                  SpannableString newNoteString = new SpannableString(getString(R.string.new_note_list));
1064                  newNoteString.setSpan(new TextAppearanceSpan(getActivity(),R.style.UntitledNoteAppearance),
1065                          0,
1066                          newNoteString.length(),
1067                          SpannableString.SPAN_EXCLUSIVE_EXCLUSIVE
1068                  );
1069                  newNoteString.setSpan(new AbsoluteSizeSpan(mTitleFontSize, true),
1070                          0,
1071                          newNoteString.length(),
1072                          SpannableString.SPAN_EXCLUSIVE_EXCLUSIVE
1073                  );
1074                  holder.mTitle.setText(newNoteString);
1075              } else {
1076                  SpannableStringBuilder titleChecklistString = new SpannableStringBuilder(title);
1077                  titleChecklistString = (SpannableStringBuilder) ChecklistUtils.addChecklistSpansForRegexAndColor(
1078                          getContext(),
1079                          titleChecklistString,
1080                          ChecklistUtils.CHECKLIST_REGEX,
1081                          ThemeUtils.getThemeTextColorId(getContext()));
1082                  holder.mTitle.setText(titleChecklistString);
1083              }
1084  
1085              holder.mMatchOffsets = null;
1086              int matchOffsetsIndex = mCursor.getColumnIndex(&quot;match_offsets&quot;);
1087  
1088              if (hasSearchQuery() &amp;&amp; matchOffsetsIndex != -1) {
1089                  title = mCursor.getString(mCursor.getColumnIndex(Note.MATCHED_TITLE_INDEX_NAME));
1090                  String snippet = mCursor.getString(mCursor.getColumnIndex(Note.MATCHED_CONTENT_INDEX_NAME));
1091                  holder.mMatchOffsets = mCursor.getString(matchOffsetsIndex);
1092  
1093                  try {
1094                      holder.mContent.setText(SearchSnippetFormatter.formatString(
1095                              getContext(),
1096                              snippet,
1097                              mSnippetHighlighter,
1098                              R.color.text_title_disabled));
1099                      holder.mTitle.setText(SearchSnippetFormatter.formatString(
1100                              getContext(),
1101                              title,
1102                              mSnippetHighlighter, ThemeUtils.getThemeTextColorId(getContext())));
1103                  } catch (NullPointerException e) {
1104                      title = StrUtils.notNullStr(mCursor.getString(mCursor.getColumnIndex(Note.TITLE_INDEX_NAME)));
1105                      holder.mTitle.setText(title);
<abbr title="1106                      String matchedContentPreview = StrUtils.notNullStr(mCursor.getString(mCursor.getColumnIndex(Note.CONTENT_PREVIEW_INDEX_NAME)));">1106                      String matchedContentPreview = StrUtils.notNullStr(mCursor.getString(mCursor.getColumnIndex(NoðŸ”µ</abbr>
1107                      holder.mContent.setText(matchedContentPreview);
1108                  }
1109              } else if (!mIsCondensedNoteList) {
<abbr title="1110                  String contentPreview = mCursor.getString(mCursor.getColumnIndex(Note.CONTENT_PREVIEW_INDEX_NAME));">1110                  String contentPreview = mCursor.getString(mCursor.getColumnIndex(Note.CONTENT_PREVIEW_INDEX_NAME))ðŸ”µ</abbr>
1111  
<abbr title="1112                  if (title == null || title.equals(contentPreview) || title.equals(getString(R.string.new_note_list)))">1112                  if (title == null || title.equals(contentPreview) || title.equals(getString(R.string.new_note_listðŸ”µ</abbr>
1113                      holder.mContent.setVisibility(View.GONE);
1114                  else {
1115                      holder.mContent.setText(contentPreview);
1116                      SpannableStringBuilder checklistString = new SpannableStringBuilder(contentPreview);
1117                      checklistString = (SpannableStringBuilder) ChecklistUtils.addChecklistSpansForRegexAndColor(
1118                              getContext(),
1119                              checklistString,
1120                              ChecklistUtils.CHECKLIST_REGEX,
1121                              R.color.text_title_disabled);
1122                      holder.mContent.setText(checklistString);
1123                  }
1124              }
1125  
1126              // Add mouse right click support for showing a popup menu
1127              view.setOnTouchListener(new View.OnTouchListener() {
1128                  @SuppressLint(&quot;ClickableViewAccessibility&quot;)
1129                  @Override
1130                  public boolean onTouch(View view, MotionEvent event) {
<abbr title="1131                      if (event.getButtonState() == MotionEvent.BUTTON_SECONDARY &amp;&amp; event.getAction() == MotionEvent.ACTION_DOWN) {">1131                      if (event.getButtonState() == MotionEvent.BUTTON_SECONDARY &amp;&amp; event.getAction() == MotionEventðŸ”µ</abbr>
1132                          showPopupMenuAtPosition(view, position);
1133                          return true;
1134                      }
1135  
1136                      return false;
1137                  }
1138              });
1139  
1140              return view;
1141          }
1142  
1143          @Override
1144          public View newView(Context context, Cursor cursor, ViewGroup viewGroup) {
1145              return null;
1146          }
1147  
1148          @Override
1149          public void bindView(View view, Context context, Cursor cursor) {
1150          }
1151      }
1152  
1153      @Override
1154      public void onBeforeUpdateObject(Bucket&lt;Preferences&gt; bucket, Preferences object) {
1155      }
1156  
1157      @Override
1158      public void onDeleteObject(Bucket&lt;Preferences&gt; bucket, Preferences object) {
1159          if (isAdded()) {
1160              requireActivity().runOnUiThread(new Runnable() {
1161                  @Override
1162                  public void run() {
1163                      getSearchItems();
1164                  }
1165              });
1166          }
1167      }
1168  
1169      @Override
1170      public void onNetworkChange(Bucket&lt;Preferences&gt; bucket, Bucket.ChangeType type, String key) {
1171          if (isAdded()) {
1172              requireActivity().runOnUiThread(new Runnable() {
1173                  @Override
1174                  public void run() {
1175                      getSearchItems();
1176                  }
1177              });
1178          }
1179      }
1180  
1181      @Override
1182      public void onSaveObject(Bucket&lt;Preferences&gt; bucket, Preferences object) {
1183          if (isAdded()) {
1184              requireActivity().runOnUiThread(new Runnable() {
1185                  @Override
1186                  public void run() {
1187                      getSearchItems();
1188                  }
1189              });
1190          }
1191      }
1192  
1193      private class SuggestionAdapter extends RecyclerView.Adapter&lt;SuggestionAdapter.ViewHolder&gt; {
1194          private final List&lt;Suggestion&gt; mSuggestions;
1195  
1196          private SuggestionAdapter(List&lt;Suggestion&gt; suggestions) {
1197              mSuggestions = new ArrayList&lt;&gt;(suggestions);
1198          }
1199  
1200          @Override
1201          public int getItemCount() {
1202              return mSuggestions.size();
1203          }
1204  
1205          @Override
1206          public int getItemViewType(int position) {
1207              return mSuggestions.get(position).getType();
1208          }
1209  
1210          @SuppressLint(&quot;SetTextI18n&quot;)
1211          @Override
1212          public void onBindViewHolder(@NonNull final ViewHolder holder, final int position) {
1213              switch (holder.mViewType) {
1214                  case HISTORY:
1215                      holder.mSuggestionText.setText(mSuggestions.get(position).getName());
1216                      holder.mSuggestionIcon.setImageResource(R.drawable.ic_history_24dp);
1217                      holder.mButtonDelete.setVisibility(View.VISIBLE);
1218                      break;
1219                  case QUERY:
1220                      holder.mSuggestionText.setText(mSuggestions.get(position).getName());
1221                      holder.mSuggestionIcon.setImageResource(R.drawable.ic_search_24dp);
1222                      holder.mButtonDelete.setVisibility(View.GONE);
1223                      break;
1224                  case TAG:
1225                      holder.mSuggestionText.setText(TAG_PREFIX + mSuggestions.get(position).getName());
1226                      holder.mSuggestionIcon.setImageResource(R.drawable.ic_tag_24dp);
1227                      holder.mButtonDelete.setVisibility(View.GONE);
1228                      break;
1229              }
1230  
1231              holder.mButtonDelete.setOnClickListener(new View.OnClickListener() {
1232                  @Override
1233                  public void onClick(View view) {
1234                      if (!isAdded()) {
1235                          return;
1236                      }
1237  
1238                      final String item = holder.mSuggestionText.getText().toString();
1239                      deleteSearchItem(item);
1240                      Snackbar
1241                          .make(getRootView(), R.string.snackbar_deleted_recent_search, Snackbar.LENGTH_LONG)
1242                          .setAction(
1243                              getString(R.string.undo),
1244                              new View.OnClickListener() {
1245                                  @Override
1246                                  public void onClick(View view) {
1247                                      addSearchItem(item, mDeletedItemIndex);
1248                                  }
1249                              }
1250                          )
1251                          .show();
1252                  }
1253              });
1254              holder.mButtonDelete.setOnLongClickListener(new View.OnLongClickListener() {
1255                  @Override
1256                  public boolean onLongClick(View v) {
1257                      if (v.isHapticFeedbackEnabled()) {
1258                          v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
1259                      }
1260  
<abbr title="1261                      Toast.makeText(getContext(), requireContext().getString(R.string.description_delete_item), Toast.LENGTH_SHORT).show();">1261                      Toast.makeText(getContext(), requireContext().getString(R.string.description_delete_item), ToaðŸ”µ</abbr>
1262                      return true;
1263                  }
1264              });
1265  
1266              holder.mView.setOnClickListener(new View.OnClickListener() {
1267                  @Override
1268                  public void onClick(View view) {
1269                      ((NotesActivity) requireActivity()).submitSearch(holder.mSuggestionText.getText().toString());
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1270 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1271 +                    if (holder.mViewType == HISTORY) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1272 +                        AnalyticsTracker.track(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1273 +                            RECENT_SEARCH_TAPPED,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1274 +                            CATEGORY_SEARCH,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1275 +                            &quot;recent_search_tapped&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1276 +                        );</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1277 +                    }</span>
1278                  }
1279              });
1280          }
1281  
1282          @NonNull
1283          @Override
1284          public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
<abbr title="1285              return new ViewHolder(LayoutInflater.from(requireContext()).inflate(R.layout.search_suggestion, parent, false), viewType);">1285              return new ViewHolder(LayoutInflater.from(requireContext()).inflate(R.layout.search_suggestion, parentðŸ”µ</abbr>
1286          }
1287  
1288          private class ViewHolder extends RecyclerView.ViewHolder {
1289              private ImageButton mButtonDelete;
1290              private ImageView mSuggestionIcon;
1291              private TextView mSuggestionText;
1292              private View mView;
1293              private int mViewType;
1294  
1295              private ViewHolder(View itemView, int viewType) {
1296                  super(itemView);
1297                  mView = itemView;
1298                  mViewType = viewType;
1299                  mSuggestionText = itemView.findViewById(R.id.suggestion_text);
1300                  mSuggestionIcon = itemView.findViewById(R.id.suggestion_icon);
1301                  mButtonDelete = itemView.findViewById(R.id.suggestion_delete);
1302              }
1303          }
1304  
1305          private void updateItems(List&lt;Suggestion&gt; suggestions) {
<abbr title="1306              DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new SuggestionDiffCallback(mSuggestions, suggestions));">1306              DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new SuggestionDiffCallback(mSuggestions, suggeðŸ”µ</abbr>
1307              mSuggestions.clear();
1308              mSuggestions.addAll(suggestions);
1309              diffResult.dispatchUpdatesTo(this);
1310          }
1311      }
1312  
1313      private class SuggestionDiffCallback extends DiffUtil.Callback {
1314          private List&lt;Suggestion&gt; mListNew;
1315          private List&lt;Suggestion&gt; mListOld;
1316  
1317          private SuggestionDiffCallback(List&lt;Suggestion&gt; oldList, List&lt;Suggestion&gt; newList) {
1318              mListOld = oldList;
1319              mListNew = newList;
1320          }
1321  
1322          @Override
1323          public boolean areContentsTheSame(int itemPositionOld, int itemPositionNew) {
1324              Suggestion itemOld = mListOld.get(itemPositionOld);
1325              Suggestion itemNew = mListNew.get(itemPositionNew);
1326              return itemOld.getName().equalsIgnoreCase(itemNew.getName());
1327          }
1328  
1329          @Override
1330          public boolean areItemsTheSame(int itemPositionOld, int itemPositionNew) {
1331              Suggestion itemOld = mListOld.get(itemPositionOld);
1332              Suggestion itemNew = mListNew.get(itemPositionNew);
1333              return itemOld.getName().equalsIgnoreCase(itemNew.getName());
1334          }
1335  
1336          @Override
1337          public int getNewListSize() {
1338              return mListNew.size();
1339          }
1340  
1341          @Override
1342          public int getOldListSize() {
1343              return mListOld.size();
1344          }
1345      }
1346  
1347      private Calendar getDateByPreference(Note note) {
1348          switch (PrefUtils.getIntPref(requireContext(), PrefUtils.PREF_SORT_ORDER)) {
1349              case DATE_CREATED_ASCENDING:
1350              case DATE_CREATED_DESCENDING:
1351                  return note.getCreationDate();
1352              case DATE_MODIFIED_ASCENDING:
1353              case DATE_MODIFIED_DESCENDING:
1354                  return note.getModificationDate();
1355              case ALPHABETICAL_ASCENDING:
1356              case ALPHABETICAL_DESCENDING:
1357              default:
1358                  return null;
1359          }
1360      }
1361  
1362      private void showPopupMenuAtPosition(View view, int position) {
1363          if (view.getContext() == null) {
1364              return;
1365          }
1366  
1367          final Note note = mNotesAdapter.getItem(position + mList.getHeaderViewsCount());
1368          if (note == null) {
1369              return;
1370          }
1371  
1372          PopupMenu popup = new PopupMenu(view.getContext(), view, Gravity.END);
1373          MenuInflater inflater = popup.getMenuInflater();
1374          inflater.inflate(R.menu.bulk_edit, popup.getMenu());
1375  
1376          if (!getListView().isLongClickable()) {
1377              // If viewing the trash, remove pin menu item and change trash menu title to &#x27;Restore&#x27;
1378              popup.getMenu().removeItem(R.id.menu_pin);
1379              if (popup.getMenu().getItem(POPUP_MENU_FIRST_ITEM_POSITION) != null) {
1380                  popup.getMenu().getItem(POPUP_MENU_FIRST_ITEM_POSITION).setTitle(R.string.restore);
1381              }
1382          } else if (popup.getMenu().getItem(POPUP_MENU_FIRST_ITEM_POSITION) != null) {
1383              // If not viewing the trash, set pin menu title based on note pin state
1384              int pinTitle = note.isPinned() ? R.string.unpin_from_top : R.string.pin_to_top;
1385              popup.getMenu().getItem(POPUP_MENU_FIRST_ITEM_POSITION).setTitle(pinTitle);
1386          }
1387  
1388          popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {
1389              @Override
1390              public boolean onMenuItemClick(MenuItem item) {
1391                  switch (item.getItemId()) {
1392                      case R.id.menu_pin:
1393                          note.setPinned(!note.isPinned());
1394                          note.setModificationDate(Calendar.getInstance());
1395                          note.save();
1396                          refreshList();
1397                          return true;
1398                      case R.id.menu_trash:
1399                          note.setDeleted(!note.isDeleted());
1400                          note.setModificationDate(Calendar.getInstance());
1401                          note.save();
1402                          if (getActivity() != null) {
1403                              ((NotesActivity) getActivity()).updateViewsAfterTrashAction(note);
1404                          }
1405                          return true;
1406                      default:
1407                          return false;
1408                  }
1409              }
1410          });
1411  
1412          popup.show();
1413      }
1414  
1415      private static class RefreshListTask extends AsyncTask&lt;Boolean, Void, ObjectCursor&lt;Note&gt;&gt; {
1416          private SoftReference&lt;NoteListFragment&gt; mNoteListFragmentReference;
1417          private boolean mIsFromNavSelect;
1418  
1419          private RefreshListTask(NoteListFragment context) {
1420              mNoteListFragmentReference = new SoftReference&lt;&gt;(context);
1421          }
1422  
1423          @Override
1424          protected ObjectCursor&lt;Note&gt; doInBackground(Boolean... args) {
1425              NoteListFragment fragment = mNoteListFragmentReference.get();
1426              mIsFromNavSelect = args[0];
1427              return fragment.queryNotes();
1428          }
1429  
1430          @Override
1431          protected void onPostExecute(ObjectCursor&lt;Note&gt; cursor) {
1432              NoteListFragment fragment = mNoteListFragmentReference.get();
1433  
1434              if (cursor == null || fragment.getActivity() == null || fragment.getActivity().isFinishing()) {
1435                  return;
1436              }
1437  
<abbr title="1438              // While using a Query.FullTextMatch it&#x27;s easy to enter an invalid term so catch the error and clear the cursor">1438              // While using a Query.FullTextMatch it&#x27;s easy to enter an invalid term so catch the error and clear tðŸ”µ</abbr>
1439              int count;
1440  
1441              try {
1442                  fragment.mNotesAdapter.changeCursor(cursor);
1443                  count = fragment.mNotesAdapter.getCount();
1444              } catch (SQLiteException e) {
1445                  count = 0;
1446                  Log.e(Simplenote.TAG, &quot;Invalid SQL statement&quot;, e);
1447                  fragment.mNotesAdapter.changeCursor(null);
1448              }
1449  
1450              NotesActivity notesActivity = (NotesActivity) fragment.getActivity();
1451  
1452              if (notesActivity != null) {
1453                  if (mIsFromNavSelect &amp;&amp; DisplayUtils.isLargeScreenLandscape(notesActivity)) {
1454                      if (count == 0) {
1455                          notesActivity.showDetailPlaceholder();
1456                      } else {
1457                          // Select the first note
1458                          fragment.selectFirstNote();
1459                      }
1460                  }
1461  
1462                  notesActivity.updateTrashMenuItem(true);
1463              }
1464  
1465              if (fragment.mSelectedNoteId != null) {
1466                  fragment.setNoteSelected(fragment.mSelectedNoteId);
1467                  fragment.mSelectedNoteId = null;
1468              }
1469          }
1470      }
1471  
1472      private static class RefreshListForSearchTask extends AsyncTask&lt;Void, Void, ObjectCursor&lt;Note&gt;&gt; {
1473          private SoftReference&lt;NoteListFragment&gt; mNoteListFragmentReference;
1474  
1475          private RefreshListForSearchTask(NoteListFragment context) {
1476              mNoteListFragmentReference = new SoftReference&lt;&gt;(context);
1477          }
1478  
1479          @Override
1480          protected ObjectCursor&lt;Note&gt; doInBackground(Void... args) {
1481              NoteListFragment fragment = mNoteListFragmentReference.get();
1482              return fragment.queryNotesForSearch();
1483          }
1484  
1485          @Override
1486          protected void onPostExecute(ObjectCursor&lt;Note&gt; cursor) {
1487              NoteListFragment fragment = mNoteListFragmentReference.get();
1488  
1489              if (cursor == null || fragment.getActivity() == null || fragment.getActivity().isFinishing()) {
1490                  return;
1491              }
1492  
<abbr title="1493              // While using Query.FullTextMatch, it&#x27;s easy to enter an invalid term so catch the error and clear the cursor.">1493              // While using Query.FullTextMatch, it&#x27;s easy to enter an invalid term so catch the error and clear thðŸ”µ</abbr>
1494              try {
1495                  fragment.mNotesAdapter.changeCursor(cursor);
1496              } catch (SQLiteException e) {
1497                  Log.e(Simplenote.TAG, &quot;Invalid SQL statement&quot;, e);
1498                  fragment.mNotesAdapter.changeCursor(null);
1499              }
1500  
1501              NotesActivity notesActivity = (NotesActivity) fragment.requireActivity();
1502              notesActivity.updateTrashMenuItem(true);
1503  
1504              if (fragment.mSelectedNoteId != null) {
1505                  fragment.setNoteSelected(fragment.mSelectedNoteId);
1506                  fragment.mSelectedNoteId = null;
1507              }
1508          }
1509      }
1510  
1511      private static class PinNotesTask extends AsyncTask&lt;Void, Void, Void&gt; {
1512          private SoftReference&lt;NoteListFragment&gt; mNoteListFragmentReference;
1513          private SparseBooleanArray mSelectedRows = new SparseBooleanArray();
1514  
1515          private PinNotesTask(NoteListFragment context) {
1516              mNoteListFragmentReference = new SoftReference&lt;&gt;(context);
1517          }
1518  
1519          @Override
1520          protected void onPreExecute() {
1521              NoteListFragment fragment = mNoteListFragmentReference.get();
1522              mSelectedRows = fragment.getListView().getCheckedItemPositions();
1523          }
1524  
1525          @Override
1526          protected Void doInBackground(Void... args) {
1527              NoteListFragment fragment = mNoteListFragmentReference.get();
1528              // Get the checked notes and add them to the pinnedNotesList
1529              // We can&#x27;t modify the note in this loop because the adapter could change
1530              List&lt;Note&gt; pinnedNotesList = new ArrayList&lt;&gt;();
1531  
1532              for (int i = 0; i &lt; mSelectedRows.size(); i++) {
1533                  if (mSelectedRows.valueAt(i)) {
1534                      pinnedNotesList.add(fragment.mNotesAdapter.getItem(mSelectedRows.keyAt(i)));
1535                  }
1536              }
1537  
1538              // Now loop through the notes list and mark them as pinned
1539              for (Note pinnedNote : pinnedNotesList) {
1540                  pinnedNote.setPinned(!pinnedNote.isPinned());
1541                  pinnedNote.setModificationDate(Calendar.getInstance());
1542                  pinnedNote.save();
1543              }
1544  
1545              return null;
1546          }
1547  
1548          @Override
1549          protected void onPostExecute(Void aVoid) {
1550              NoteListFragment fragment = mNoteListFragmentReference.get();
1551              fragment.mActionMode.finish();
1552              fragment.refreshList();
1553          }
1554      }
1555  
1556      private static class TrashNotesTask extends AsyncTask&lt;Void, Void, Void&gt; {
1557          private List&lt;String&gt; mDeletedNoteIds = new ArrayList&lt;&gt;();
1558          private SoftReference&lt;NoteListFragment&gt; mNoteListFragmentReference;
1559          private SparseBooleanArray mSelectedRows = new SparseBooleanArray();
1560  
1561          private TrashNotesTask(NoteListFragment context) {
1562              mNoteListFragmentReference = new SoftReference&lt;&gt;(context);
1563          }
1564  
1565          @Override
1566          protected void onPreExecute() {
1567              NoteListFragment fragment = mNoteListFragmentReference.get();
1568              mSelectedRows = fragment.getListView().getCheckedItemPositions();
1569          }
1570  
1571          @Override
1572          protected Void doInBackground(Void... args) {
1573              NoteListFragment fragment = mNoteListFragmentReference.get();
1574              // Get the checked notes and add them to the deletedNotesList
1575              // We can&#x27;t modify the note in this loop because the adapter could change
1576              List&lt;Note&gt; deletedNotesList = new ArrayList&lt;&gt;();
1577  
1578              for (int i = 0; i &lt; mSelectedRows.size(); i++) {
1579                  if (mSelectedRows.valueAt(i)) {
1580                      deletedNotesList.add(fragment.mNotesAdapter.getItem(mSelectedRows.keyAt(i)));
1581                  }
1582              }
1583  
1584              // Now loop through the notes list and mark them as deleted
1585              for (Note deletedNote : deletedNotesList) {
1586                  mDeletedNoteIds.add(deletedNote.getSimperiumKey());
1587                  deletedNote.setDeleted(!deletedNote.isDeleted());
1588                  deletedNote.setModificationDate(Calendar.getInstance());
1589                  deletedNote.save();
1590              }
1591  
1592              return null;
1593          }
1594  
1595          @Override
1596          protected void onPostExecute(Void aVoid) {
1597              NoteListFragment fragment = mNoteListFragmentReference.get();
1598              NotesActivity notesActivity = ((NotesActivity) fragment.getActivity());
1599  
1600              if (notesActivity != null) {
1601                  notesActivity.showUndoBarWithNoteIds(mDeletedNoteIds);
1602              }
1603  
1604              fragment.refreshList();
1605          }
1606      }
1607  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            