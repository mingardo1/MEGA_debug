<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>6 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*\n&#x27;
                           &#x27; * Copyright (C) 2016 &#x27;
                           &#x27;AriaLyy(https://github.com/AriaLyy/Aria)\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                           &#x27;(the &quot;License&quot;);\n&#x27;
                           &#x27; * you may not use this file except in compliance &#x27;
                           &#x27;with the License.\n&#x27;
                           &#x27; * You may obtain a copy of the License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *      &#x27;
                           &#x27;http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;package com.arialyy.aria.http;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import android.net.TrafficStats;\n&#x27;
                           &#x27;import android.net.Uri;\n&#x27;
                           &#x27;import android.os.Process;\n&#x27;
                           &#x27;import android.text.TextUtils;\n&#x27;
                           &#x27;import com.arialyy.aria.core.AriaConfig;\n&#x27;
                           &#x27;import com.arialyy.aria.core.common.CompleteInfo;\n&#x27;
                           &#x27;import com.arialyy.aria.core.common.RequestEnum;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.DTaskWrapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.DownloadEntity;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.inf.OnFileInfoCallback;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.processor.IHttpFileLenAdapter;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.exception.AriaIOException;\n&#x27;
                           &#x27;import com.arialyy.aria.exception.BaseException;\n&#x27;
                           &#x27;import com.arialyy.aria.exception.TaskException;\n&#x27;
                           &#x27;import com.arialyy.aria.util.ALog;\n&#x27;
                           &#x27;import com.arialyy.aria.util.CheckUtil;\n&#x27;
                           &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                           &#x27;import com.arialyy.aria.util.FileUtil;\n&#x27;
                           &#x27;import com.arialyy.aria.util.RecordUtil;\n&#x27;
                           &#x27;import java.io.BufferedReader;\n&#x27;
                           &#x27;import java.io.File;\n&#x27;
                           &#x27;import java.io.IOException;\n&#x27;
                           &#x27;import java.io.InputStreamReader;\n&#x27;
                           &#x27;import java.io.OutputStreamWriter;\n&#x27;
                           &#x27;import java.io.UnsupportedEncodingException;\n&#x27;
                           &#x27;import java.net.CookieManager;\n&#x27;
                           &#x27;import java.net.HttpCookie;\n&#x27;
                           &#x27;import java.net.HttpURLConnection;\n&#x27;
                           &#x27;import java.net.URL;\n&#x27;
                           &#x27;import java.net.URLDecoder;\n&#x27;
                           &#x27;import java.net.URLEncoder;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;import java.util.Set;\n&#x27;
                           &#x27;import java.util.UUID;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * 下载文件信息获取\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class HttpFileInfoThread implements &#x27;
                           &#x27;Runnable {\n&#x27;
                           &#x27;  private static final String TAG = &#x27;
                           &#x27;&quot;HttpFileInfoThread&quot;;\n&#x27;
                           &#x27;  private DownloadEntity mEntity;\n&#x27;
                           &#x27;  private DTaskWrapper mTaskWrapper;\n&#x27;
                           &#x27;  private int mConnectTimeOut;\n&#x27;
                           &#x27;  private OnFileInfoCallback onFileInfoCallback;\n&#x27;
                           &#x27;  private HttpTaskOption taskOption;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  public HttpFileInfoThread(DTaskWrapper &#x27;
                           &#x27;taskWrapper, OnFileInfoCallback callback) {\n&#x27;
                           &#x27;    this.mTaskWrapper = taskWrapper;\n&#x27;
                           &#x27;    mEntity = taskWrapper.getEntity();\n&#x27;
                           &#x27;    mConnectTimeOut = &#x27;
                           &#x27;AriaConfig.getInstance().getDConfig().getConnectTimeOut();\n&#x27;
                           &#x27;    onFileInfoCallback = callback;\n&#x27;
                           &#x27;    taskOption = (HttpTaskOption) &#x27;
                           &#x27;taskWrapper.getTaskOption();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public void run() {\n&#x27;
                           &#x27;    &#x27;
                           &#x27;Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n&#x27;
                           &#x27;    &#x27;
                           &#x27;TrafficStats.setThreadStatsTag(UUID.randomUUID().toString().hashCode());\n&#x27;
                           &#x27;    HttpURLConnection conn = null;\n&#x27;
                           &#x27;    try {\n&#x27;
                           &#x27;      URL url = &#x27;
                           &#x27;ConnectionHelp.handleUrl(mEntity.getUrl(), &#x27;
                           &#x27;taskOption);\n&#x27;
                           &#x27;      conn = ConnectionHelp.handleConnection(url, &#x27;
                           &#x27;taskOption);\n&#x27;
                           &#x27;      ConnectionHelp.setConnectParam(taskOption, &#x27;
                           &#x27;conn);\n&#x27;
                           &#x27;      conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + &#x27;
                           &#x27;0 + &quot;-&quot;);\n&#x27;
                           &#x27;      conn.setConnectTimeout(mConnectTimeOut);\n&#x27;
                           &#x27;      conn.connect();\n&#x27;
                           &#x27;      handleConnect(conn);\n&#x27;
                           &#x27;    } catch (IOException e) {\n&#x27;
                           &#x27;      e.printStackTrace();\n&#x27;
                           &#x27;      failDownload(new AriaIOException(TAG,\n&#x27;
                           &#x27;              String.format(&quot;下载失败，filePath: %s, &#x27;
                           &#x27;url: %s&quot;, mEntity.getDownloadPath(), &#x27;
                           &#x27;mEntity.getUrl())),\n&#x27;
                           &#x27;          true);\n&#x27;
                           &#x27;    } finally {\n&#x27;
                           &#x27;      if (conn != null) {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;          conn.getInputStream().close();\n&#x27;
                           &#x27;        } catch (IOException e) {\n&#x27;
                           &#x27;          e.printStackTrace();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        conn.disconnect();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private void handleConnect(HttpURLConnection &#x27;
                           &#x27;conn) throws IOException {\n&#x27;
                           &#x27;    if (taskOption.getRequestEnum() == &#x27;
                           &#x27;RequestEnum.POST) {\n&#x27;
                           &#x27;      Map&lt;String, String&gt; params = &#x27;
                           &#x27;taskOption.getParams();\n&#x27;
                           &#x27;      if (params != null) {\n&#x27;
                           &#x27;        OutputStreamWriter dos = new &#x27;
                           &#x27;OutputStreamWriter(conn.getOutputStream());\n&#x27;
                           &#x27;        Set&lt;String&gt; keys = params.keySet();\n&#x27;
                           &#x27;        StringBuilder sb = new StringBuilder();\n&#x27;
                           &#x27;        for (String key : keys) {\n&#x27;
                           &#x27;          &#x27;
                           &#x27;sb.append(key).append(&quot;=&quot;).append(URLEncoder.encode(params.get(key))).append(&quot;&amp;&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        String url = sb.toString();\n&#x27;
                           &#x27;        url = url.substring(0, url.length() - 1);\n&#x27;
                           &#x27;        dos.write(url);\n&#x27;
                           &#x27;        dos.flush();\n&#x27;
                           &#x27;        dos.close();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    IHttpFileLenAdapter lenAdapter = &#x27;
                           &#x27;taskOption.getFileLenAdapter();\n&#x27;
                           &#x27;    if (lenAdapter == null) {\n&#x27;
                           &#x27;      lenAdapter = new FileLenAdapter();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      ALog.d(TAG, &quot;使用自定义adapter&quot;);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    long len = &#x27;
                           &#x27;lenAdapter.handleFileLen(conn.getHeaderFields());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    if &#x27;
                           &#x27;(!FileUtil.checkMemorySpace(mEntity.getFilePath(), &#x27;
                           &#x27;len)) {\n&#x27;
                           &#x27;      failDownload(new TaskException(TAG,\n&#x27;
                           &#x27;          String.format(&quot;下载失败，内存空间不足；filePath: %s, &#x27;
                           &#x27;url: %s&quot;, mEntity.getDownloadPath(),\n&#x27;
                           &#x27;              mEntity.getUrl())), false);\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    int code = conn.getResponseCode();\n&#x27;
                           &#x27;    boolean end = false;\n&#x27;
                           &#x27;    if (TextUtils.isEmpty(mEntity.getMd5Code())) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      String md5Code = &#x27;
                           &#x27;conn.getHeaderField(&quot;Content-MD5&quot;);\n&#x27;
                           &#x27;      mEntity.setMd5Code(md5Code);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    boolean isChunked = false;\n&#x27;
                           &#x27;    final String str = &#x27;
                           &#x27;conn.getHeaderField(&quot;Transfer-Encoding&quot;);\n&#x27;
                           &#x27;    if (!TextUtils.isEmpty(str) &amp;&amp; &#x27;
                           &#x27;str.equals(&quot;chunked&quot;)) {\n&#x27;
                           &#x27;      isChunked = true;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    Map&lt;String, List&lt;String&gt;&gt; headers = &#x27;
                           &#x27;conn.getHeaderFields();\n&#x27;
                           &#x27;    String disposition = &#x27;
                           &#x27;conn.getHeaderField(&quot;Content-Disposition&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    if (taskOption.isUseServerFileName()) {\n&#x27;
                           &#x27;      if (!TextUtils.isEmpty(disposition)) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mEntity.setDisposition(CommonUtil.encryptBASE64(disposition));\n&#x27;
                           &#x27;        handleContentDisposition(disposition);\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        ALog.w(TAG, &#x27;
                           &#x27;&quot;Content-Disposition对于端字段为空，使用服务器端文件名失败&quot;);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    CookieManager msCookieManager = new &#x27;
                           &#x27;CookieManager();\n&#x27;
                           &#x27;    List&lt;String&gt; cookiesHeader = &#x27;
                           &#x27;headers.get(&quot;Set-Cookie&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    if (cookiesHeader != null) {\n&#x27;
                           &#x27;      for (String cookie : cookiesHeader) {\n&#x27;
                           &#x27;        msCookieManager.getCookieStore().add(null, &#x27;
                           &#x27;HttpCookie.parse(cookie).get(0));\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      &#x27;
                           &#x27;taskOption.setCookieManager(msCookieManager);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    mTaskWrapper.setCode(code);\n&#x27;
                           &#x27;    if (code == HttpURLConnection.HTTP_PARTIAL) {\n&#x27;
                           &#x27;      if (!checkLen(len) &amp;&amp; !isChunked) {\n&#x27;
                           &#x27;        if (len &lt; 0) {\n&#x27;
                           &#x27;          failDownload(\n&#x27;
                           &#x27;              new AriaIOException(TAG, &#x27;
                           &#x27;String.format(&quot;任务下载失败，文件长度小于0， url: %s&quot;, &#x27;
                           &#x27;mEntity.getUrl())),\n&#x27;
                           &#x27;              false);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mEntity.setFileSize(len);\n&#x27;
                           &#x27;      mTaskWrapper.setSupportBP(true);\n&#x27;
                           &#x27;      end = true;\n&#x27;
                           &#x27;    } else if (code == HttpURLConnection.HTTP_OK) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      String contentType = &#x27;
                           &#x27;conn.getHeaderField(&quot;Content-Type&quot;);\n&#x27;
                           &#x27;      if (TextUtils.isEmpty(contentType)) {\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      if (contentType.equals(&quot;text/html&quot;)) {\n&#x27;
                           &#x27;        BufferedReader reader =\n&#x27;
                           &#x27;            new BufferedReader(new &#x27;
                           &#x27;InputStreamReader(ConnectionHelp.convertInputStream(conn)));\n&#x27;
                           &#x27;        StringBuilder sb = new StringBuilder();\n&#x27;
                           &#x27;        String line;\n&#x27;
                           &#x27;        while ((line = reader.readLine()) != null) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;          sb.append(line);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        reader.close();\n&#x27;
                           &#x27;        handleUrlReTurn(conn, &#x27;
                           &#x27;CommonUtil.getWindowReplaceUrl(sb.toString()));\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      } else if (!checkLen(len) &amp;&amp; !isChunked) {\n&#x27;
                           &#x27;        if (len &lt; 0) {\n&#x27;
                           &#x27;          failDownload(\n&#x27;
                           &#x27;              new AriaIOException(TAG, &#x27;
                           &#x27;String.format(&quot;任务下载失败，文件长度小于0， url: %s&quot;, &#x27;
                           &#x27;mEntity.getUrl())),\n&#x27;
                           &#x27;              false);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        ALog.d(TAG, &quot;len &lt; 0&quot;);\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mEntity.setFileSize(len);\n&#x27;
                           &#x27;      mTaskWrapper.setNewTask(true);\n&#x27;
                           &#x27;      mTaskWrapper.setSupportBP(false);\n&#x27;
                           &#x27;      end = true;\n&#x27;
                           &#x27;    } else if (code == &#x27;
                           &#x27;HttpURLConnection.HTTP_NOT_FOUND) {\n&#x27;
                           &#x27;      failDownload(new AriaIOException(TAG,\n&#x27;
                           &#x27;          String.format(&quot;任务下载失败，errorCode：404, &#x27;
                           &#x27;url: %s&quot;, mEntity.getUrl())), true);\n&#x27;
                           &#x27;    } else if (code == &#x27;
                           &#x27;HttpURLConnection.HTTP_MOVED_TEMP\n&#x27;
                           &#x27;        || code == &#x27;
                           &#x27;HttpURLConnection.HTTP_MOVED_PERM\n&#x27;
                           &#x27;        || code == &#x27;
                           &#x27;HttpURLConnection.HTTP_SEE_OTHER\n&#x27;
                           &#x27;        || code == HttpURLConnection.HTTP_CREATED &#x27;
                           &#x27;// 201 跳转\n&#x27;
                           &#x27;        || code == 307) {\n&#x27;
                           &#x27;      handleUrlReTurn(conn, &#x27;
                           &#x27;conn.getHeaderField(&quot;Location&quot;));\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      failDownload(new AriaIOException(TAG,\n&#x27;
                           &#x27;          String.format(&quot;任务下载失败，errorCode：%s, &#x27;
                           &#x27;errorMsg: %s, url: %s&quot;, code,\n&#x27;
                           &#x27;              conn.getResponseMessage(), &#x27;
                           &#x27;mEntity.getUrl())), &#x27;
                           &#x27;!CheckUtil.httpIsBadRequest(code));\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    if (end) {\n&#x27;
                           &#x27;      taskOption.setChunked(isChunked);\n&#x27;
                           &#x27;      if (onFileInfoCallback != null) {\n&#x27;
                           &#x27;        CompleteInfo info = new CompleteInfo(code, &#x27;
                           &#x27;mTaskWrapper);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;onFileInfoCallback.onComplete(mEntity.getUrl(), &#x27;
                           &#x27;info);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mEntity.update();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理&quot;Content-Disposition&quot;参数\n&#x27;
                           &#x27;   * &lt;a &#x27;
                           &#x27;href=https://cloud.tencent.com/developer/section/1189916&gt;Content-Disposition&lt;/a&gt;&lt;/&gt;\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @throws UnsupportedEncodingException\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleContentDisposition(String &#x27;
                           &#x27;disposition) throws UnsupportedEncodingException &#x27;
                           &#x27;{\n&#x27;
                           &#x27;    if (disposition.contains(&quot;;&quot;)) {\n&#x27;
                           &#x27;      String[] infos = disposition.split(&quot;;&quot;);\n&#x27;
                           &#x27;      if (infos[0].equals(&quot;attachment&quot;)) {\n&#x27;
                           &#x27;        for (String info : infos) {\n&#x27;
                           &#x27;          if (info.startsWith(&quot;filename&quot;) &amp;&amp; &#x27;
                           &#x27;info.contains(&quot;=&quot;)) {\n&#x27;
                           &#x27;            String[] temp = info.split(&quot;=&quot;);\n&#x27;
                           &#x27;            if (temp.length &gt; 1) {\n&#x27;
                           &#x27;              String newName = &#x27;
                           &#x27;URLDecoder.decode(temp[1], &#x27;
                           &#x27;&quot;utf-8&quot;).replaceAll(&quot;\\&quot;&quot;, &quot;&quot;);\n&#x27;
                           &#x27;              mEntity.setServerFileName(newName);\n&#x27;
                           &#x27;              renameFile(newName);\n&#x27;
                           &#x27;              break;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      } else if (infos[0].equals(&quot;form-data&quot;) &amp;&amp; &#x27;
                           &#x27;infos.length &gt; 2) {\n&#x27;
                           &#x27;        String[] temp = infos[2].split(&quot;=&quot;);\n&#x27;
                           &#x27;        if (temp.length &gt; 1) {\n&#x27;
                           &#x27;          String newName = &#x27;
                           &#x27;URLDecoder.decode(temp[1], &#x27;
                           &#x27;&quot;utf-8&quot;).replaceAll(&quot;\\&quot;&quot;, &quot;&quot;);\n&#x27;
                           &#x27;          mEntity.setServerFileName(newName);\n&#x27;
                           &#x27;          renameFile(newName);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        ALog.w(TAG, &quot;不识别的Content-Disposition参数&quot;);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 重命名文件\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void renameFile(String newName) {\n&#x27;
                           &#x27;    if (TextUtils.isEmpty(newName)) {\n&#x27;
                           &#x27;      ALog.w(TAG, &quot;重命名失败【服务器返回的文件名为空】&quot;);\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    ALog.d(TAG, String.format(&quot;文件重命名为：%s&quot;, &#x27;
                           &#x27;newName));\n&#x27;
                           &#x27;    File oldFile = new &#x27;
                           &#x27;File(mEntity.getFilePath());\n&#x27;
                           &#x27;    String newPath = oldFile.getParent() + &quot;/&quot; + &#x27;
                           &#x27;newName;\n&#x27;
                           &#x27;    if (oldFile.exists()) {\n&#x27;
                           &#x27;      boolean b = oldFile.renameTo(new &#x27;
                           &#x27;File(newPath));\n&#x27;
                           &#x27;      ALog.d(TAG, String.format(&quot;文件重命名%s&quot;, b ? &#x27;
                           &#x27;&quot;成功&quot; : &quot;失败&quot;));\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    mEntity.setFileName(newName);\n&#x27;
                           &#x27;    mEntity.setFilePath(newPath);\n&#x27;
                           &#x27;    RecordUtil.modifyTaskRecord(oldFile.getPath(), &#x27;
                           &#x27;newPath, mEntity.getTaskType());\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理30x跳转\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleUrlReTurn(HttpURLConnection &#x27;
                           &#x27;conn, String newUrl) throws IOException {\n&#x27;
                           &#x27;    ALog.d(TAG, &quot;30x跳转，新url为【&quot; + newUrl + &quot;】&quot;);\n&#x27;
                           &#x27;    if (TextUtils.isEmpty(newUrl) || &#x27;
                           &#x27;newUrl.equalsIgnoreCase(&quot;null&quot;)) {\n&#x27;
                           &#x27;      if (onFileInfoCallback != null) {\n&#x27;
                           &#x27;        onFileInfoCallback.onFail(mEntity, new &#x27;
                           &#x27;TaskException(TAG, &quot;获取重定向链接失败&quot;), false);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    if (newUrl.startsWith(&quot;/&quot;)) {\n&#x27;
                           &#x27;      Uri uri = Uri.parse(mEntity.getUrl());\n&#x27;
                           &#x27;      newUrl = uri.getHost() + newUrl;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    if (!CheckUtil.checkUrl(newUrl)) {\n&#x27;
                           &#x27;      failDownload(new TaskException(TAG, &#x27;
                           &#x27;&quot;下载失败，重定向url错误&quot;), false);\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    taskOption.setRedirectUrl(newUrl);\n&#x27;
                           &#x27;    mEntity.setRedirect(true);\n&#x27;
                           &#x27;    mEntity.setRedirectUrl(newUrl);\n&#x27;
                           &#x27;    String cookies = &#x27;
                           &#x27;conn.getHeaderField(&quot;Set-Cookie&quot;);\n&#x27;
                           &#x27;    conn.disconnect();\n&#x27;
                           &#x27;    URL url = ConnectionHelp.handleUrl(newUrl, &#x27;
                           &#x27;taskOption);\n&#x27;
                           &#x27;    conn = ConnectionHelp.handleConnection(url, &#x27;
                           &#x27;taskOption);\n&#x27;
                           &#x27;    ConnectionHelp.setConnectParam(taskOption, &#x27;
                           &#x27;conn);\n&#x27;
                           &#x27;    conn.setRequestProperty(&quot;Cookie&quot;, cookies);\n&#x27;
                           &#x27;    conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + 0 &#x27;
                           &#x27;+ &quot;-&quot;);\n&#x27;
                           &#x27;    conn.setConnectTimeout(mConnectTimeOut);\n&#x27;
                           &#x27;    conn.connect();\n&#x27;
                           &#x27;    handleConnect(conn);\n&#x27;
                           &#x27;    conn.disconnect();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * &#x27;
                           &#x27;检查长度是否合法，并且检查新获取的文件长度是否和数据库的文件长度一直，如果不一致，则表示该任务为新任务\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param len 从服务器获取的文件长度\n&#x27;
                           &#x27;   * @return {@code true}合法\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private boolean checkLen(long len) {\n&#x27;
                           &#x27;    if (len != mEntity.getFileSize()) {\n&#x27;
                           &#x27;      ALog.d(TAG, &quot;长度不一致，任务为新任务&quot;);\n&#x27;
                           &#x27;      mTaskWrapper.setNewTask(true);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    return true;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private void failDownload(BaseException e, &#x27;
                           &#x27;boolean needRetry) {\n&#x27;
                           &#x27;    if (onFileInfoCallback != null) {\n&#x27;
                           &#x27;      onFileInfoCallback.onFail(mEntity, e, &#x27;
                           &#x27;needRetry);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private static class FileLenAdapter implements &#x27;
                           &#x27;IHttpFileLenAdapter {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override public long &#x27;
                           &#x27;handleFileLen(Map&lt;String, List&lt;String&gt;&gt; headers) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      if (headers == null || headers.isEmpty()) {\n&#x27;
                           &#x27;        ALog.e(TAG, &quot;header为空，获取文件长度失败&quot;);\n&#x27;
                           &#x27;        return -1;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      List&lt;String&gt; sLength = &#x27;
                           &#x27;headers.get(&quot;Content-Length&quot;);\n&#x27;
                           &#x27;      if (sLength == null || sLength.isEmpty()) {\n&#x27;
                           &#x27;        return -1;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      String temp = sLength.get(0);\n&#x27;
                           &#x27;      long len = TextUtils.isEmpty(temp) ? -1 : &#x27;
                           &#x27;Long.parseLong(temp);\n&#x27;
                           &#x27;      // &#x27;
                           &#x27;某些服务，如果设置了conn.setRequestProperty(&quot;Range&quot;, &#x27;
                           &#x27;&quot;bytes=&quot; + 0 + &quot;-&quot;);\n&#x27;
                           &#x27;      // 会返回 Content-Range: bytes &#x27;
                           &#x27;0-225427911/225427913\n&#x27;
                           &#x27;      if (len &lt; 0) {\n&#x27;
                           &#x27;        List&lt;String&gt; sRange = &#x27;
                           &#x27;headers.get(&quot;Content-Range&quot;);\n&#x27;
                           &#x27;        if (sRange == null || sRange.isEmpty()) {\n&#x27;
                           &#x27;          len = -1;\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          int start = temp.indexOf(&quot;/&quot;);\n&#x27;
                           &#x27;          len = &#x27;
                           &#x27;Long.parseLong(temp.substring(start + 1));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      return len;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*\n&#x27;
                           &#x27; * Copyright (C) 2016 &#x27;
                           &#x27;AriaLyy(https://github.com/AriaLyy/Aria)\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                           &#x27;(the &quot;License&quot;);\n&#x27;
                           &#x27; * you may not use this file except in compliance &#x27;
                           &#x27;with the License.\n&#x27;
                           &#x27; * You may obtain a copy of the License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *      &#x27;
                           &#x27;http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;package com.arialyy.aria.http;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import android.net.TrafficStats;\n&#x27;
                           &#x27;import android.net.Uri;\n&#x27;
                           &#x27;import android.os.Process;\n&#x27;
                           &#x27;import android.text.TextUtils;\n&#x27;
                           &#x27;import com.arialyy.aria.core.AriaConfig;\n&#x27;
                           &#x27;import com.arialyy.aria.core.common.CompleteInfo;\n&#x27;
                           &#x27;import com.arialyy.aria.core.common.RequestEnum;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.DTaskWrapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.DownloadEntity;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.inf.OnFileInfoCallback;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.processor.IHttpFileLenAdapter;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.exception.AriaIOException;\n&#x27;
                           &#x27;import com.arialyy.aria.exception.BaseException;\n&#x27;
                           &#x27;import com.arialyy.aria.exception.TaskException;\n&#x27;
                           &#x27;import com.arialyy.aria.util.ALog;\n&#x27;
                           &#x27;import com.arialyy.aria.util.CheckUtil;\n&#x27;
                           &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                           &#x27;import com.arialyy.aria.util.FileUtil;\n&#x27;
                           &#x27;import com.arialyy.aria.util.RecordUtil;\n&#x27;
                           &#x27;import java.io.BufferedReader;\n&#x27;
                           &#x27;import java.io.File;\n&#x27;
                           &#x27;import java.io.IOException;\n&#x27;
                           &#x27;import java.io.InputStreamReader;\n&#x27;
                           &#x27;import java.io.OutputStreamWriter;\n&#x27;
                           &#x27;import java.io.UnsupportedEncodingException;\n&#x27;
                           &#x27;import java.net.CookieManager;\n&#x27;
                           &#x27;import java.net.HttpCookie;\n&#x27;
                           &#x27;import java.net.HttpURLConnection;\n&#x27;
                           &#x27;import java.net.URL;\n&#x27;
                           &#x27;import java.net.URLDecoder;\n&#x27;
                           &#x27;import java.net.URLEncoder;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;import java.util.Set;\n&#x27;
                           &#x27;import java.util.UUID;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * 下载文件信息获取\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class HttpFileInfoThread implements &#x27;
                           &#x27;Runnable {\n&#x27;
                           &#x27;  private static final String TAG = &#x27;
                           &#x27;&quot;HttpFileInfoThread&quot;;\n&#x27;
                           &#x27;  private DownloadEntity mEntity;\n&#x27;
                           &#x27;  private DTaskWrapper mTaskWrapper;\n&#x27;
                           &#x27;  private int mConnectTimeOut;\n&#x27;
                           &#x27;  private OnFileInfoCallback onFileInfoCallback;\n&#x27;
                           &#x27;  private HttpTaskOption taskOption;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  public HttpFileInfoThread(DTaskWrapper &#x27;
                           &#x27;taskWrapper, OnFileInfoCallback callback) {\n&#x27;
                           &#x27;    this.mTaskWrapper = taskWrapper;\n&#x27;
                           &#x27;    mEntity = taskWrapper.getEntity();\n&#x27;
                           &#x27;    mConnectTimeOut = &#x27;
                           &#x27;AriaConfig.getInstance().getDConfig().getConnectTimeOut();\n&#x27;
                           &#x27;    onFileInfoCallback = callback;\n&#x27;
                           &#x27;    taskOption = (HttpTaskOption) &#x27;
                           &#x27;taskWrapper.getTaskOption();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public void run() {\n&#x27;
                           &#x27;    &#x27;
                           &#x27;Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n&#x27;
                           &#x27;    &#x27;
                           &#x27;TrafficStats.setThreadStatsTag(UUID.randomUUID().toString().hashCode());\n&#x27;
                           &#x27;    HttpURLConnection conn = null;\n&#x27;
                           &#x27;    try {\n&#x27;
                           &#x27;      URL url = &#x27;
                           &#x27;ConnectionHelp.handleUrl(mEntity.getUrl(), &#x27;
                           &#x27;taskOption);\n&#x27;
                           &#x27;      conn = ConnectionHelp.handleConnection(url, &#x27;
                           &#x27;taskOption);\n&#x27;
                           &#x27;      ConnectionHelp.setConnectParam(taskOption, &#x27;
                           &#x27;conn);\n&#x27;
                           &#x27;      conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + &#x27;
                           &#x27;0 + &quot;-&quot;);\n&#x27;
                           &#x27;      conn.setConnectTimeout(mConnectTimeOut);\n&#x27;
                           &#x27;      conn.connect();\n&#x27;
                           &#x27;      handleConnect(conn);\n&#x27;
                           &#x27;    } catch (IOException e) {\n&#x27;
                           &#x27;      e.printStackTrace();\n&#x27;
                           &#x27;      failDownload(new AriaIOException(TAG,\n&#x27;
                           &#x27;              String.format(&quot;下载失败，filePath: %s, &#x27;
                           &#x27;url: %s&quot;, mEntity.getDownloadPath(), &#x27;
                           &#x27;mEntity.getUrl())),\n&#x27;
                           &#x27;          true);\n&#x27;
                           &#x27;    } finally {\n&#x27;
                           &#x27;      if (conn != null) {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;          conn.getInputStream().close();\n&#x27;
                           &#x27;        } catch (IOException e) {\n&#x27;
                           &#x27;          e.printStackTrace();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        conn.disconnect();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private void handleConnect(HttpURLConnection &#x27;
                           &#x27;conn) throws IOException {\n&#x27;
                           &#x27;    if (taskOption.getRequestEnum() == &#x27;
                           &#x27;RequestEnum.POST) {\n&#x27;
                           &#x27;      Map&lt;String, String&gt; params = &#x27;
                           &#x27;taskOption.getParams();\n&#x27;
                           &#x27;      if (params != null) {\n&#x27;
                           &#x27;        OutputStreamWriter dos = new &#x27;
                           &#x27;OutputStreamWriter(conn.getOutputStream());\n&#x27;
                           &#x27;        Set&lt;String&gt; keys = params.keySet();\n&#x27;
                           &#x27;        StringBuilder sb = new StringBuilder();\n&#x27;
                           &#x27;        for (String key : keys) {\n&#x27;
                           &#x27;          &#x27;
                           &#x27;sb.append(key).append(&quot;=&quot;).append(URLEncoder.encode(params.get(key))).append(&quot;&amp;&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        String url = sb.toString();\n&#x27;
                           &#x27;        url = url.substring(0, url.length() - 1);\n&#x27;
                           &#x27;        dos.write(url);\n&#x27;
                           &#x27;        dos.flush();\n&#x27;
                           &#x27;        dos.close();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    IHttpFileLenAdapter lenAdapter = &#x27;
                           &#x27;taskOption.getFileLenAdapter();\n&#x27;
                           &#x27;    if (lenAdapter == null) {\n&#x27;
                           &#x27;      lenAdapter = new FileLenAdapter();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      ALog.d(TAG, &quot;使用自定义adapter&quot;);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    long len = &#x27;
                           &#x27;lenAdapter.handleFileLen(conn.getHeaderFields());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    if &#x27;
                           &#x27;(!FileUtil.checkMemorySpace(mEntity.getFilePath(), &#x27;
                           &#x27;len)) {\n&#x27;
                           &#x27;      failDownload(new TaskException(TAG,\n&#x27;
                           &#x27;          String.format(&quot;下载失败，内存空间不足；filePath: %s, &#x27;
                           &#x27;url: %s&quot;, mEntity.getDownloadPath(),\n&#x27;
                           &#x27;              mEntity.getUrl())), false);\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    int code = conn.getResponseCode();\n&#x27;
                           &#x27;    boolean end = false;\n&#x27;
                           &#x27;    if (TextUtils.isEmpty(mEntity.getMd5Code())) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      String md5Code = &#x27;
                           &#x27;conn.getHeaderField(&quot;Content-MD5&quot;);\n&#x27;
                           &#x27;      mEntity.setMd5Code(md5Code);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    boolean isChunked = false;\n&#x27;
                           &#x27;    final String str = &#x27;
                           &#x27;conn.getHeaderField(&quot;Transfer-Encoding&quot;);\n&#x27;
                           &#x27;    if (!TextUtils.isEmpty(str) &amp;&amp; &#x27;
                           &#x27;str.equals(&quot;chunked&quot;)) {\n&#x27;
                           &#x27;      isChunked = true;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    Map&lt;String, List&lt;String&gt;&gt; headers = &#x27;
                           &#x27;conn.getHeaderFields();\n&#x27;
                           &#x27;    String disposition = &#x27;
                           &#x27;conn.getHeaderField(&quot;Content-Disposition&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    if (taskOption.isUseServerFileName()) {\n&#x27;
                           &#x27;      if (!TextUtils.isEmpty(disposition)) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mEntity.setDisposition(CommonUtil.encryptBASE64(disposition));\n&#x27;
                           &#x27;        handleContentDisposition(disposition);\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        ALog.w(TAG, &#x27;
                           &#x27;&quot;Content-Disposition对于端字段为空，使用服务器端文件名失败&quot;);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    CookieManager msCookieManager = new &#x27;
                           &#x27;CookieManager();\n&#x27;
                           &#x27;    List&lt;String&gt; cookiesHeader = &#x27;
                           &#x27;headers.get(&quot;Set-Cookie&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    if (cookiesHeader != null) {\n&#x27;
                           &#x27;      for (String cookie : cookiesHeader) {\n&#x27;
                           &#x27;        msCookieManager.getCookieStore().add(null, &#x27;
                           &#x27;HttpCookie.parse(cookie).get(0));\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      &#x27;
                           &#x27;taskOption.setCookieManager(msCookieManager);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    mTaskWrapper.setCode(code);\n&#x27;
                           &#x27;    if (code == HttpURLConnection.HTTP_PARTIAL) {\n&#x27;
                           &#x27;      if (!checkLen(len) &amp;&amp; !isChunked) {\n&#x27;
                           &#x27;        if (len &lt; 0) {\n&#x27;
                           &#x27;          failDownload(\n&#x27;
                           &#x27;              new AriaIOException(TAG, &#x27;
                           &#x27;String.format(&quot;任务下载失败，文件长度小于0， url: %s&quot;, &#x27;
                           &#x27;mEntity.getUrl())),\n&#x27;
                           &#x27;              false);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mEntity.setFileSize(len);\n&#x27;
                           &#x27;      mTaskWrapper.setSupportBP(true);\n&#x27;
                           &#x27;      end = true;\n&#x27;
                           &#x27;    } else if (code == HttpURLConnection.HTTP_OK) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      String contentType = &#x27;
                           &#x27;conn.getHeaderField(&quot;Content-Type&quot;);\n&#x27;
                           &#x27;      if (TextUtils.isEmpty(contentType)) {\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      if (contentType.equals(&quot;text/html&quot;)) {\n&#x27;
                           &#x27;        BufferedReader reader =\n&#x27;
                           &#x27;            new BufferedReader(new &#x27;
                           &#x27;InputStreamReader(ConnectionHelp.convertInputStream(conn)));\n&#x27;
                           &#x27;        StringBuilder sb = new StringBuilder();\n&#x27;
                           &#x27;        String line;\n&#x27;
                           &#x27;        while ((line = reader.readLine()) != null) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;          sb.append(line);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        reader.close();\n&#x27;
                           &#x27;        handleUrlReTurn(conn, &#x27;
                           &#x27;CommonUtil.getWindowReplaceUrl(sb.toString()));\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      } else if (!checkLen(len) &amp;&amp; !isChunked) {\n&#x27;
                           &#x27;        if (len &lt; 0) {\n&#x27;
                           &#x27;          failDownload(\n&#x27;
                           &#x27;              new AriaIOException(TAG, &#x27;
                           &#x27;String.format(&quot;任务下载失败，文件长度小于0， url: %s&quot;, &#x27;
                           &#x27;mEntity.getUrl())),\n&#x27;
                           &#x27;              false);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        ALog.d(TAG, &quot;len &lt; 0&quot;);\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mEntity.setFileSize(len);\n&#x27;
                           &#x27;      mTaskWrapper.setNewTask(true);\n&#x27;
                           &#x27;      mTaskWrapper.setSupportBP(false);\n&#x27;
                           &#x27;      end = true;\n&#x27;
                           &#x27;    } else if (code == &#x27;
                           &#x27;HttpURLConnection.HTTP_NOT_FOUND) {\n&#x27;
                           &#x27;      failDownload(new AriaIOException(TAG,\n&#x27;
                           &#x27;          String.format(&quot;任务下载失败，errorCode：404, &#x27;
                           &#x27;url: %s&quot;, mEntity.getUrl())), true);\n&#x27;
                           &#x27;    } else if (code == &#x27;
                           &#x27;HttpURLConnection.HTTP_MOVED_TEMP\n&#x27;
                           &#x27;        || code == &#x27;
                           &#x27;HttpURLConnection.HTTP_MOVED_PERM\n&#x27;
                           &#x27;        || code == &#x27;
                           &#x27;HttpURLConnection.HTTP_SEE_OTHER\n&#x27;
                           &#x27;        || code == HttpURLConnection.HTTP_CREATED &#x27;
                           &#x27;// 201 跳转\n&#x27;
                           &#x27;        || code == 307) {\n&#x27;
                           &#x27;      handleUrlReTurn(conn, &#x27;
                           &#x27;conn.getHeaderField(&quot;Location&quot;));\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      failDownload(new AriaIOException(TAG,\n&#x27;
                           &#x27;          String.format(&quot;任务下载失败，errorCode：%s, &#x27;
                           &#x27;errorMsg: %s, url: %s&quot;, code,\n&#x27;
                           &#x27;              conn.getResponseMessage(), &#x27;
                           &#x27;mEntity.getUrl())), &#x27;
                           &#x27;!CheckUtil.httpIsBadRequest(code));\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    if (end) {\n&#x27;
                           &#x27;      taskOption.setChunked(isChunked);\n&#x27;
                           &#x27;      if (onFileInfoCallback != null) {\n&#x27;
                           &#x27;        CompleteInfo info = new CompleteInfo(code, &#x27;
                           &#x27;mTaskWrapper);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;onFileInfoCallback.onComplete(mEntity.getUrl(), &#x27;
                           &#x27;info);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mEntity.update();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理&quot;Content-Disposition&quot;参数\n&#x27;
                           &#x27;   * &lt;a &#x27;
                           &#x27;href=https://cloud.tencent.com/developer/section/1189916&gt;Content-Disposition&lt;/a&gt;&lt;/&gt;\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @throws UnsupportedEncodingException\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleContentDisposition(String &#x27;
                           &#x27;disposition) throws UnsupportedEncodingException &#x27;
                           &#x27;{\n&#x27;
                           &#x27;    if (disposition.contains(&quot;;&quot;)) {\n&#x27;
                           &#x27;      String[] infos = disposition.split(&quot;;&quot;);\n&#x27;
                           &#x27;      if (infos[0].equals(&quot;attachment&quot;)) {\n&#x27;
                           &#x27;        for (String info : infos) {\n&#x27;
                           &#x27;          if (info.startsWith(&quot;filename&quot;) &amp;&amp; &#x27;
                           &#x27;info.contains(&quot;=&quot;)) {\n&#x27;
                           &#x27;            String[] temp = info.split(&quot;=&quot;);\n&#x27;
                           &#x27;            if (temp.length &gt; 1) {\n&#x27;
                           &#x27;              String newName = &#x27;
                           &#x27;URLDecoder.decode(temp[1], &#x27;
                           &#x27;&quot;utf-8&quot;).replaceAll(&quot;\\&quot;&quot;, &quot;&quot;);\n&#x27;
                           &#x27;              mEntity.setServerFileName(newName);\n&#x27;
                           &#x27;              renameFile(newName);\n&#x27;
                           &#x27;              break;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      } else if (infos[0].equals(&quot;form-data&quot;) &amp;&amp; &#x27;
                           &#x27;infos.length &gt; 2) {\n&#x27;
                           &#x27;        String[] temp = infos[2].split(&quot;=&quot;);\n&#x27;
                           &#x27;        if (temp.length &gt; 1) {\n&#x27;
                           &#x27;          String newName = &#x27;
                           &#x27;URLDecoder.decode(temp[1], &#x27;
                           &#x27;&quot;utf-8&quot;).replaceAll(&quot;\\&quot;&quot;, &quot;&quot;);\n&#x27;
                           &#x27;          mEntity.setServerFileName(newName);\n&#x27;
                           &#x27;          renameFile(newName);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        ALog.w(TAG, &quot;不识别的Content-Disposition参数&quot;);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 重命名文件\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void renameFile(String newName) {\n&#x27;
                           &#x27;    if (TextUtils.isEmpty(newName)) {\n&#x27;
                           &#x27;      ALog.w(TAG, &quot;重命名失败【服务器返回的文件名为空】&quot;);\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    ALog.d(TAG, String.format(&quot;文件重命名为：%s&quot;, &#x27;
                           &#x27;newName));\n&#x27;
                           &#x27;    File oldFile = new &#x27;
                           &#x27;File(mEntity.getFilePath());\n&#x27;
                           &#x27;    String newPath = oldFile.getParent() + &quot;/&quot; + &#x27;
                           &#x27;newName;\n&#x27;
                           &#x27;    if (oldFile.exists()) {\n&#x27;
                           &#x27;      boolean b = oldFile.renameTo(new &#x27;
                           &#x27;File(newPath));\n&#x27;
                           &#x27;      ALog.d(TAG, String.format(&quot;文件重命名%s&quot;, b ? &#x27;
                           &#x27;&quot;成功&quot; : &quot;失败&quot;));\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    mEntity.setFileName(newName);\n&#x27;
                           &#x27;    mEntity.setFilePath(newPath);\n&#x27;
                           &#x27;    RecordUtil.modifyTaskRecord(oldFile.getPath(), &#x27;
                           &#x27;newPath, mEntity.getTaskType());\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理30x跳转\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleUrlReTurn(HttpURLConnection &#x27;
                           &#x27;conn, String newUrl) throws IOException {\n&#x27;
                           &#x27;    ALog.d(TAG, &quot;30x跳转，新url为【&quot; + newUrl + &quot;】&quot;);\n&#x27;
                           &#x27;    if (TextUtils.isEmpty(newUrl) || &#x27;
                           &#x27;newUrl.equalsIgnoreCase(&quot;null&quot;)) {\n&#x27;
                           &#x27;      if (onFileInfoCallback != null) {\n&#x27;
                           &#x27;        onFileInfoCallback.onFail(mEntity, new &#x27;
                           &#x27;TaskException(TAG, &quot;获取重定向链接失败&quot;), false);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    if (newUrl.startsWith(&quot;/&quot;)) {\n&#x27;
                           &#x27;      Uri uri = Uri.parse(mEntity.getUrl());\n&#x27;
                           &#x27;      newUrl = uri.getHost() + newUrl;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    if (!CheckUtil.checkUrl(newUrl)) {\n&#x27;
                           &#x27;      failDownload(new TaskException(TAG, &#x27;
                           &#x27;&quot;下载失败，重定向url错误&quot;), false);\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    taskOption.setRedirectUrl(newUrl);\n&#x27;
                           &#x27;    mEntity.setRedirect(true);\n&#x27;
                           &#x27;    mEntity.setRedirectUrl(newUrl);\n&#x27;
                           &#x27;    String cookies = &#x27;
                           &#x27;conn.getHeaderField(&quot;Set-Cookie&quot;);\n&#x27;
                           &#x27;    conn.disconnect();\n&#x27;
                           &#x27;    URL url = ConnectionHelp.handleUrl(newUrl, &#x27;
                           &#x27;taskOption);\n&#x27;
                           &#x27;    conn = ConnectionHelp.handleConnection(url, &#x27;
                           &#x27;taskOption);\n&#x27;
                           &#x27;    ConnectionHelp.setConnectParam(taskOption, &#x27;
                           &#x27;conn);\n&#x27;
                           &#x27;    conn.setRequestProperty(&quot;Cookie&quot;, cookies);\n&#x27;
                           &#x27;    conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + 0 &#x27;
                           &#x27;+ &quot;-&quot;);\n&#x27;
                           &#x27;    conn.setConnectTimeout(mConnectTimeOut);\n&#x27;
                           &#x27;    conn.connect();\n&#x27;
                           &#x27;    handleConnect(conn);\n&#x27;
                           &#x27;    conn.disconnect();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * &#x27;
                           &#x27;检查长度是否合法，并且检查新获取的文件长度是否和数据库的文件长度一直，如果不一致，则表示该任务为新任务\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param len 从服务器获取的文件长度\n&#x27;
                           &#x27;   * @return {@code true}合法\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private boolean checkLen(long len) {\n&#x27;
                           &#x27;    if (len != mEntity.getFileSize()) {\n&#x27;
                           &#x27;      ALog.d(TAG, &quot;长度不一致，任务为新任务&quot;);\n&#x27;
                           &#x27;      mTaskWrapper.setNewTask(true);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    return true;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private void failDownload(BaseException e, &#x27;
                           &#x27;boolean needRetry) {\n&#x27;
                           &#x27;    if (onFileInfoCallback != null) {\n&#x27;
                           &#x27;      onFileInfoCallback.onFail(mEntity, e, &#x27;
                           &#x27;needRetry);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private static class FileLenAdapter implements &#x27;
                           &#x27;IHttpFileLenAdapter {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override public long &#x27;
                           &#x27;handleFileLen(Map&lt;String, List&lt;String&gt;&gt; headers) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      if (headers == null || headers.isEmpty()) {\n&#x27;
                           &#x27;        ALog.e(TAG, &quot;header为空，获取文件长度失败&quot;);\n&#x27;
                           &#x27;        return -1;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      List&lt;String&gt; sLength = &#x27;
                           &#x27;headers.get(&quot;Content-Length&quot;);\n&#x27;
                           &#x27;      if (sLength == null || sLength.isEmpty()) {\n&#x27;
                           &#x27;        return -1;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      String temp = sLength.get(0);\n&#x27;
                           &#x27;      long len = TextUtils.isEmpty(temp) ? -1 : &#x27;
                           &#x27;Long.parseLong(temp);\n&#x27;
                           &#x27;      // &#x27;
                           &#x27;某些服务，如果设置了conn.setRequestProperty(&quot;Range&quot;, &#x27;
                           &#x27;&quot;bytes=&quot; + 0 + &quot;-&quot;);\n&#x27;
                           &#x27;      // 会返回 Content-Range: bytes &#x27;
                           &#x27;0-225427911/225427913\n&#x27;
                           &#x27;      if (len &lt; 0) {\n&#x27;
                           &#x27;        List&lt;String&gt; sRange = &#x27;
                           &#x27;headers.get(&quot;Content-Range&quot;);\n&#x27;
                           &#x27;        if (sRange == null || sRange.isEmpty()) {\n&#x27;
                           &#x27;          len = -1;\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          int start = temp.indexOf(&quot;/&quot;);\n&#x27;
                           &#x27;          len = &#x27;
                           &#x27;Long.parseLong(temp.substring(start + 1));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      return len;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;/*\n&#x27;
                           &#x27; * Copyright (C) 2016 &#x27;
                           &#x27;AriaLyy(https://github.com/AriaLyy/Aria)\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                           &#x27;(the &quot;License&quot;);\n&#x27;
                           &#x27; * you may not use this file except in compliance &#x27;
                           &#x27;with the License.\n&#x27;
                           &#x27; * You may obtain a copy of the License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *      &#x27;
                           &#x27;http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;package com.arialyy.aria.http;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import android.net.TrafficStats;\n&#x27;
                           &#x27;import android.net.Uri;\n&#x27;
                           &#x27;import android.os.Process;\n&#x27;
                           &#x27;import android.text.TextUtils;\n&#x27;
                           &#x27;import com.arialyy.aria.core.AriaConfig;\n&#x27;
                           &#x27;import com.arialyy.aria.core.common.CompleteInfo;\n&#x27;
                           &#x27;import com.arialyy.aria.core.common.RequestEnum;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.DTaskWrapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.DownloadEntity;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.inf.OnFileInfoCallback;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.processor.IHttpFileLenAdapter;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.exception.AriaIOException;\n&#x27;
                           &#x27;import com.arialyy.aria.exception.BaseException;\n&#x27;
                           &#x27;import com.arialyy.aria.exception.TaskException;\n&#x27;
                           &#x27;import com.arialyy.aria.util.ALog;\n&#x27;
                           &#x27;import com.arialyy.aria.util.CheckUtil;\n&#x27;
                           &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                           &#x27;import com.arialyy.aria.util.FileUtil;\n&#x27;
                           &#x27;import com.arialyy.aria.util.RecordUtil;\n&#x27;
                           &#x27;import java.io.BufferedReader;\n&#x27;
                           &#x27;import java.io.File;\n&#x27;
                           &#x27;import java.io.IOException;\n&#x27;
                           &#x27;import java.io.InputStreamReader;\n&#x27;
                           &#x27;import java.io.OutputStreamWriter;\n&#x27;
                           &#x27;import java.io.UnsupportedEncodingException;\n&#x27;
                           &#x27;import java.net.CookieManager;\n&#x27;
                           &#x27;import java.net.HttpCookie;\n&#x27;
                           &#x27;import java.net.HttpURLConnection;\n&#x27;
                           &#x27;import java.net.URL;\n&#x27;
                           &#x27;import java.net.URLDecoder;\n&#x27;
                           &#x27;import java.net.URLEncoder;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;import java.util.Set;\n&#x27;
                           &#x27;import java.util.UUID;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * 下载文件信息获取\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class HttpFileInfoThread implements &#x27;
                           &#x27;Runnable {\n&#x27;
                           &#x27;  private static final String TAG = &#x27;
                           &#x27;&quot;HttpFileInfoThread&quot;;\n&#x27;
                           &#x27;  private DownloadEntity mEntity;\n&#x27;
                           &#x27;  private DTaskWrapper mTaskWrapper;\n&#x27;
                           &#x27;  private int mConnectTimeOut;\n&#x27;
                           &#x27;  private OnFileInfoCallback onFileInfoCallback;\n&#x27;
                           &#x27;  private HttpTaskOption taskOption;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  public HttpFileInfoThread(DTaskWrapper &#x27;
                           &#x27;taskWrapper, OnFileInfoCallback callback) {\n&#x27;
                           &#x27;    this.mTaskWrapper = taskWrapper;\n&#x27;
                           &#x27;    mEntity = taskWrapper.getEntity();\n&#x27;
                           &#x27;    mConnectTimeOut = &#x27;
                           &#x27;AriaConfig.getInstance().getDConfig().getConnectTimeOut();\n&#x27;
                           &#x27;    onFileInfoCallback = callback;\n&#x27;
                           &#x27;    taskOption = (HttpTaskOption) &#x27;
                           &#x27;taskWrapper.getTaskOption();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public void run() {\n&#x27;
                           &#x27;    &#x27;
                           &#x27;Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n&#x27;
                           &#x27;    &#x27;
                           &#x27;TrafficStats.setThreadStatsTag(UUID.randomUUID().toString().hashCode());\n&#x27;
                           &#x27;    HttpURLConnection conn = null;\n&#x27;
                           &#x27;    try {\n&#x27;
                           &#x27;      URL url = &#x27;
                           &#x27;ConnectionHelp.handleUrl(mEntity.getUrl(), &#x27;
                           &#x27;taskOption);\n&#x27;
                           &#x27;      conn = ConnectionHelp.handleConnection(url, &#x27;
                           &#x27;taskOption);\n&#x27;
                           &#x27;      ConnectionHelp.setConnectParam(taskOption, &#x27;
                           &#x27;conn);\n&#x27;
                           &#x27;      conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + &#x27;
                           &#x27;0 + &quot;-&quot;);\n&#x27;
                           &#x27;      conn.setConnectTimeout(mConnectTimeOut);\n&#x27;
                           &#x27;      conn.connect();\n&#x27;
                           &#x27;      handleConnect(conn);\n&#x27;
                           &#x27;    } catch (IOException e) {\n&#x27;
                           &#x27;      e.printStackTrace();\n&#x27;
                           &#x27;      failDownload(new AriaIOException(TAG,\n&#x27;
                           &#x27;              String.format(&quot;下载失败，filePath: %s, &#x27;
                           &#x27;url: %s&quot;, mEntity.getDownloadPath(), &#x27;
                           &#x27;mEntity.getUrl())),\n&#x27;
                           &#x27;          true);\n&#x27;
                           &#x27;    } finally {\n&#x27;
                           &#x27;      if (conn != null) {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;          conn.getInputStream().close();\n&#x27;
                           &#x27;        } catch (IOException e) {\n&#x27;
                           &#x27;          e.printStackTrace();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        conn.disconnect();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private void handleConnect(HttpURLConnection &#x27;
                           &#x27;conn) throws IOException {\n&#x27;
                           &#x27;    if (taskOption.getRequestEnum() == &#x27;
                           &#x27;RequestEnum.POST) {\n&#x27;
                           &#x27;      Map&lt;String, String&gt; params = &#x27;
                           &#x27;taskOption.getParams();\n&#x27;
                           &#x27;      if (params != null) {\n&#x27;
                           &#x27;        OutputStreamWriter dos = new &#x27;
                           &#x27;OutputStreamWriter(conn.getOutputStream());\n&#x27;
                           &#x27;        Set&lt;String&gt; keys = params.keySet();\n&#x27;
                           &#x27;        StringBuilder sb = new StringBuilder();\n&#x27;
                           &#x27;        for (String key : keys) {\n&#x27;
                           &#x27;          &#x27;
                           &#x27;sb.append(key).append(&quot;=&quot;).append(URLEncoder.encode(params.get(key))).append(&quot;&amp;&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        String url = sb.toString();\n&#x27;
                           &#x27;        url = url.substring(0, url.length() - 1);\n&#x27;
                           &#x27;        dos.write(url);\n&#x27;
                           &#x27;        dos.flush();\n&#x27;
                           &#x27;        dos.close();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    IHttpFileLenAdapter lenAdapter = &#x27;
                           &#x27;taskOption.getFileLenAdapter();\n&#x27;
                           &#x27;    if (lenAdapter == null) {\n&#x27;
                           &#x27;      lenAdapter = new FileLenAdapter();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      ALog.d(TAG, &quot;使用自定义adapter&quot;);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    long len = &#x27;
                           &#x27;lenAdapter.handleFileLen(conn.getHeaderFields());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    if &#x27;
                           &#x27;(!FileUtil.checkMemorySpace(mEntity.getFilePath(), &#x27;
                           &#x27;len)) {\n&#x27;
                           &#x27;      failDownload(new TaskException(TAG,\n&#x27;
                           &#x27;          String.format(&quot;下载失败，内存空间不足；filePath: %s, &#x27;
                           &#x27;url: %s&quot;, mEntity.getDownloadPath(),\n&#x27;
                           &#x27;              mEntity.getUrl())), false);\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    int code = conn.getResponseCode();\n&#x27;
                           &#x27;    boolean end = false;\n&#x27;
                           &#x27;    if (TextUtils.isEmpty(mEntity.getMd5Code())) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      String md5Code = &#x27;
                           &#x27;conn.getHeaderField(&quot;Content-MD5&quot;);\n&#x27;
                           &#x27;      mEntity.setMd5Code(md5Code);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    boolean isChunked = false;\n&#x27;
                           &#x27;    final String str = &#x27;
                           &#x27;conn.getHeaderField(&quot;Transfer-Encoding&quot;);\n&#x27;
                           &#x27;    if (!TextUtils.isEmpty(str) &amp;&amp; &#x27;
                           &#x27;str.equals(&quot;chunked&quot;)) {\n&#x27;
                           &#x27;      isChunked = true;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    Map&lt;String, List&lt;String&gt;&gt; headers = &#x27;
                           &#x27;conn.getHeaderFields();\n&#x27;
                           &#x27;    String disposition = &#x27;
                           &#x27;conn.getHeaderField(&quot;Content-Disposition&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    if (taskOption.isUseServerFileName()) {\n&#x27;
                           &#x27;      if (!TextUtils.isEmpty(disposition)) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mEntity.setDisposition(CommonUtil.encryptBASE64(disposition));\n&#x27;
                           &#x27;        handleContentDisposition(disposition);\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        ALog.w(TAG, &#x27;
                           &#x27;&quot;Content-Disposition对于端字段为空，使用服务器端文件名失败&quot;);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    CookieManager msCookieManager = new &#x27;
                           &#x27;CookieManager();\n&#x27;
                           &#x27;    List&lt;String&gt; cookiesHeader = &#x27;
                           &#x27;headers.get(&quot;Set-Cookie&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    if (cookiesHeader != null) {\n&#x27;
                           &#x27;      for (String cookie : cookiesHeader) {\n&#x27;
                           &#x27;        msCookieManager.getCookieStore().add(null, &#x27;
                           &#x27;HttpCookie.parse(cookie).get(0));\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      &#x27;
                           &#x27;taskOption.setCookieManager(msCookieManager);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    mTaskWrapper.setCode(code);\n&#x27;
                           &#x27;    if (code == HttpURLConnection.HTTP_PARTIAL) {\n&#x27;
                           &#x27;      if (!checkLen(len) &amp;&amp; !isChunked) {\n&#x27;
                           &#x27;        if (len &lt; 0) {\n&#x27;
                           &#x27;          failDownload(\n&#x27;
                           &#x27;              new AriaIOException(TAG, &#x27;
                           &#x27;String.format(&quot;任务下载失败，文件长度小于0， url: %s&quot;, &#x27;
                           &#x27;mEntity.getUrl())),\n&#x27;
                           &#x27;              false);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mEntity.setFileSize(len);\n&#x27;
                           &#x27;      mTaskWrapper.setSupportBP(true);\n&#x27;
                           &#x27;      end = true;\n&#x27;
                           &#x27;    } else if (code == HttpURLConnection.HTTP_OK) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      String contentType = &#x27;
                           &#x27;conn.getHeaderField(&quot;Content-Type&quot;);\n&#x27;
                           &#x27;      if (TextUtils.isEmpty(contentType)) {\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      if (contentType.equals(&quot;text/html&quot;)) {\n&#x27;
                           &#x27;        BufferedReader reader =\n&#x27;
                           &#x27;            new BufferedReader(new &#x27;
                           &#x27;InputStreamReader(ConnectionHelp.convertInputStream(conn)));\n&#x27;
                           &#x27;        StringBuilder sb = new StringBuilder();\n&#x27;
                           &#x27;        String line;\n&#x27;
                           &#x27;        while ((line = reader.readLine()) != null) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;          sb.append(line);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        reader.close();\n&#x27;
                           &#x27;        handleUrlReTurn(conn, &#x27;
                           &#x27;CommonUtil.getWindowReplaceUrl(sb.toString()));\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      } else if (!checkLen(len) &amp;&amp; !isChunked) {\n&#x27;
                           &#x27;        if (len &lt; 0) {\n&#x27;
                           &#x27;          failDownload(\n&#x27;
                           &#x27;              new AriaIOException(TAG, &#x27;
                           &#x27;String.format(&quot;任务下载失败，文件长度小于0， url: %s&quot;, &#x27;
                           &#x27;mEntity.getUrl())),\n&#x27;
                           &#x27;              false);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        ALog.d(TAG, &quot;len &lt; 0&quot;);\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mEntity.setFileSize(len);\n&#x27;
                           &#x27;      mTaskWrapper.setNewTask(true);\n&#x27;
                           &#x27;      mTaskWrapper.setSupportBP(false);\n&#x27;
                           &#x27;      end = true;\n&#x27;
                           &#x27;    } else if (code == &#x27;
                           &#x27;HttpURLConnection.HTTP_NOT_FOUND) {\n&#x27;
                           &#x27;      failDownload(new AriaIOException(TAG,\n&#x27;
                           &#x27;          String.format(&quot;任务下载失败，errorCode：404, &#x27;
                           &#x27;url: %s&quot;, mEntity.getUrl())), true);\n&#x27;
                           &#x27;    } else if (code == &#x27;
                           &#x27;HttpURLConnection.HTTP_MOVED_TEMP\n&#x27;
                           &#x27;        || code == &#x27;
                           &#x27;HttpURLConnection.HTTP_MOVED_PERM\n&#x27;
                           &#x27;        || code == &#x27;
                           &#x27;HttpURLConnection.HTTP_SEE_OTHER\n&#x27;
                           &#x27;        || code == HttpURLConnection.HTTP_CREATED &#x27;
                           &#x27;// 201 跳转\n&#x27;
                           &#x27;        || code == 307) {\n&#x27;
                           &#x27;      handleUrlReTurn(conn, &#x27;
                           &#x27;conn.getHeaderField(&quot;Location&quot;));\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      failDownload(new AriaIOException(TAG,\n&#x27;
                           &#x27;          String.format(&quot;任务下载失败，errorCode：%s, &#x27;
                           &#x27;errorMsg: %s, url: %s&quot;, code,\n&#x27;
                           &#x27;              conn.getResponseMessage(), &#x27;
                           &#x27;mEntity.getUrl())), &#x27;
                           &#x27;!CheckUtil.httpIsBadRequest(code));\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    if (end) {\n&#x27;
                           &#x27;      taskOption.setChunked(isChunked);\n&#x27;
                           &#x27;      if (onFileInfoCallback != null) {\n&#x27;
                           &#x27;        CompleteInfo info = new CompleteInfo(code, &#x27;
                           &#x27;mTaskWrapper);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;onFileInfoCallback.onComplete(mEntity.getUrl(), &#x27;
                           &#x27;info);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mEntity.update();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理&quot;Content-Disposition&quot;参数\n&#x27;
                           &#x27;   * &lt;a &#x27;
                           &#x27;href=https://cloud.tencent.com/developer/section/1189916&gt;Content-Disposition&lt;/a&gt;&lt;/&gt;\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @throws UnsupportedEncodingException\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleContentDisposition(String &#x27;
                           &#x27;disposition) throws UnsupportedEncodingException &#x27;
                           &#x27;{\n&#x27;
                           &#x27;    if (disposition.contains(&quot;;&quot;)) {\n&#x27;
                           &#x27;      String[] infos = disposition.split(&quot;;&quot;);\n&#x27;
                           &#x27;      if (infos[0].equals(&quot;attachment&quot;)) {\n&#x27;
                           &#x27;        for (String info : infos) {\n&#x27;
                           &#x27;          if (info.startsWith(&quot;filename&quot;) &amp;&amp; &#x27;
                           &#x27;info.contains(&quot;=&quot;)) {\n&#x27;
                           &#x27;            String[] temp = info.split(&quot;=&quot;);\n&#x27;
                           &#x27;            if (temp.length &gt; 1) {\n&#x27;
                           &#x27;              String newName = &#x27;
                           &#x27;URLDecoder.decode(temp[1], &#x27;
                           &#x27;&quot;utf-8&quot;).replaceAll(&quot;\\&quot;&quot;, &quot;&quot;);\n&#x27;
                           &#x27;              mEntity.setServerFileName(newName);\n&#x27;
                           &#x27;              renameFile(newName);\n&#x27;
                           &#x27;              break;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      } else if (infos[0].equals(&quot;form-data&quot;) &amp;&amp; &#x27;
                           &#x27;infos.length &gt; 2) {\n&#x27;
                           &#x27;        String[] temp = infos[2].split(&quot;=&quot;);\n&#x27;
                           &#x27;        if (temp.length &gt; 1) {\n&#x27;
                           &#x27;          String newName = &#x27;
                           &#x27;URLDecoder.decode(temp[1], &#x27;
                           &#x27;&quot;utf-8&quot;).replaceAll(&quot;\\&quot;&quot;, &quot;&quot;);\n&#x27;
                           &#x27;          mEntity.setServerFileName(newName);\n&#x27;
                           &#x27;          renameFile(newName);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        ALog.w(TAG, &quot;不识别的Content-Disposition参数&quot;);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 重命名文件\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void renameFile(String newName) {\n&#x27;
                           &#x27;    if (TextUtils.isEmpty(newName)) {\n&#x27;
                           &#x27;      ALog.w(TAG, &quot;重命名失败【服务器返回的文件名为空】&quot;);\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    ALog.d(TAG, String.format(&quot;文件重命名为：%s&quot;, &#x27;
                           &#x27;newName));\n&#x27;
                           &#x27;    File oldFile = new &#x27;
                           &#x27;File(mEntity.getFilePath());\n&#x27;
                           &#x27;    String newPath = oldFile.getParent() + &quot;/&quot; + &#x27;
                           &#x27;newName;\n&#x27;
                           &#x27;    if (oldFile.exists()) {\n&#x27;
                           &#x27;      boolean b = oldFile.renameTo(new &#x27;
                           &#x27;File(newPath));\n&#x27;
                           &#x27;      ALog.d(TAG, String.format(&quot;文件重命名%s&quot;, b ? &#x27;
                           &#x27;&quot;成功&quot; : &quot;失败&quot;));\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    mEntity.setFileName(newName);\n&#x27;
                           &#x27;    mEntity.setFilePath(newPath);\n&#x27;
                           &#x27;    RecordUtil.modifyTaskRecord(oldFile.getPath(), &#x27;
                           &#x27;newPath, mEntity.getTaskType());\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理30x跳转\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleUrlReTurn(HttpURLConnection &#x27;
                           &#x27;conn, String newUrl) throws IOException {\n&#x27;
                           &#x27;    ALog.d(TAG, &quot;30x跳转，新url为【&quot; + newUrl + &quot;】&quot;);\n&#x27;
                           &#x27;    if (TextUtils.isEmpty(newUrl) || &#x27;
                           &#x27;newUrl.equalsIgnoreCase(&quot;null&quot;)) {\n&#x27;
                           &#x27;      if (onFileInfoCallback != null) {\n&#x27;
                           &#x27;        onFileInfoCallback.onFail(mEntity, new &#x27;
                           &#x27;TaskException(TAG, &quot;获取重定向链接失败&quot;), false);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    if (newUrl.startsWith(&quot;/&quot;)) {\n&#x27;
                           &#x27;      Uri uri = Uri.parse(mEntity.getUrl());\n&#x27;
                           &#x27;      newUrl = uri.getHost() + newUrl;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    if (!CheckUtil.checkUrl(newUrl)) {\n&#x27;
                           &#x27;      failDownload(new TaskException(TAG, &#x27;
                           &#x27;&quot;下载失败，重定向url错误&quot;), false);\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    taskOption.setRedirectUrl(newUrl);\n&#x27;
                           &#x27;    mEntity.setRedirect(true);\n&#x27;
                           &#x27;    mEntity.setRedirectUrl(newUrl);\n&#x27;
                           &#x27;    String cookies = &#x27;
                           &#x27;conn.getHeaderField(&quot;Set-Cookie&quot;);\n&#x27;
                           &#x27;    conn.disconnect();\n&#x27;
                           &#x27;    URL url = ConnectionHelp.handleUrl(newUrl, &#x27;
                           &#x27;taskOption);\n&#x27;
                           &#x27;    conn = ConnectionHelp.handleConnection(url, &#x27;
                           &#x27;taskOption);\n&#x27;
                           &#x27;    ConnectionHelp.setConnectParam(taskOption, &#x27;
                           &#x27;conn);\n&#x27;
                           &#x27;    conn.setRequestProperty(&quot;Cookie&quot;, cookies);\n&#x27;
                           &#x27;    conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + 0 &#x27;
                           &#x27;+ &quot;-&quot;);\n&#x27;
                           &#x27;    conn.setConnectTimeout(mConnectTimeOut);\n&#x27;
                           &#x27;    conn.connect();\n&#x27;
                           &#x27;    handleConnect(conn);\n&#x27;
                           &#x27;    conn.disconnect();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * &#x27;
                           &#x27;检查长度是否合法，并且检查新获取的文件长度是否和数据库的文件长度一直，如果不一致，则表示该任务为新任务\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param len 从服务器获取的文件长度\n&#x27;
                           &#x27;   * @return {@code true}合法\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private boolean checkLen(long len) {\n&#x27;
                           &#x27;    if (len != mEntity.getFileSize()) {\n&#x27;
                           &#x27;      ALog.d(TAG, &quot;长度不一致，任务为新任务&quot;);\n&#x27;
                           &#x27;      mTaskWrapper.setNewTask(true);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    return true;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private void failDownload(BaseException e, &#x27;
                           &#x27;boolean needRetry) {\n&#x27;
                           &#x27;    if (onFileInfoCallback != null) {\n&#x27;
                           &#x27;      onFileInfoCallback.onFail(mEntity, e, &#x27;
                           &#x27;needRetry);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private static class FileLenAdapter implements &#x27;
                           &#x27;IHttpFileLenAdapter {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override public long &#x27;
                           &#x27;handleFileLen(Map&lt;String, List&lt;String&gt;&gt; headers) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      if (headers == null || headers.isEmpty()) {\n&#x27;
                           &#x27;        ALog.e(TAG, &quot;header为空，获取文件长度失败&quot;);\n&#x27;
                           &#x27;        return -1;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      List&lt;String&gt; sLength = &#x27;
                           &#x27;headers.get(&quot;Content-Length&quot;);\n&#x27;
                           &#x27;      if (sLength == null || sLength.isEmpty()) {\n&#x27;
                           &#x27;        return -1;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      String temp = sLength.get(0);\n&#x27;
                           &#x27;      long len = TextUtils.isEmpty(temp) ? -1 : &#x27;
                           &#x27;Long.parseLong(temp);\n&#x27;
                           &#x27;      // &#x27;
                           &#x27;某些服务，如果设置了conn.setRequestProperty(&quot;Range&quot;, &#x27;
                           &#x27;&quot;bytes=&quot; + 0 + &quot;-&quot;);\n&#x27;
                           &#x27;      // 会返回 Content-Range: bytes &#x27;
                           &#x27;0-225427911/225427913\n&#x27;
                           &#x27;      if (len &lt; 0) {\n&#x27;
                           &#x27;        List&lt;String&gt; sRange = &#x27;
                           &#x27;headers.get(&quot;Content-Range&quot;);\n&#x27;
                           &#x27;        if (sRange == null || sRange.isEmpty()) {\n&#x27;
                           &#x27;          len = -1;\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          int start = temp.indexOf(&quot;/&quot;);\n&#x27;
                           &#x27;          len = &#x27;
                           &#x27;Long.parseLong(temp.substring(start + 1));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      return len;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;}\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*\n&#x27;
                           &#x27; * Copyright (C) 2016 &#x27;
                           &#x27;AriaLyy(https://github.com/AriaLyy/Aria)\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                           &#x27;(the &quot;License&quot;);\n&#x27;
                           &#x27; * you may not use this file except in compliance &#x27;
                           &#x27;with the License.\n&#x27;
                           &#x27; * You may obtain a copy of the License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *      &#x27;
                           &#x27;http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;package com.arialyy.aria.http;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import android.net.TrafficStats;\n&#x27;
                           &#x27;import android.net.Uri;\n&#x27;
                           &#x27;import android.os.Process;\n&#x27;
                           &#x27;import android.text.TextUtils;\n&#x27;
                           &#x27;import com.arialyy.aria.core.AriaConfig;\n&#x27;
                           &#x27;import com.arialyy.aria.core.common.CompleteInfo;\n&#x27;
                           &#x27;import com.arialyy.aria.core.common.RequestEnum;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.DTaskWrapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.DownloadEntity;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.inf.OnFileInfoCallback;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.processor.IHttpFileLenAdapter;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.exception.AriaIOException;\n&#x27;
                           &#x27;import com.arialyy.aria.exception.BaseException;\n&#x27;
                           &#x27;import com.arialyy.aria.exception.TaskException;\n&#x27;
                           &#x27;import com.arialyy.aria.util.ALog;\n&#x27;
                           &#x27;import com.arialyy.aria.util.CheckUtil;\n&#x27;
                           &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                           &#x27;import com.arialyy.aria.util.FileUtil;\n&#x27;
                           &#x27;import com.arialyy.aria.util.RecordUtil;\n&#x27;
                           &#x27;import java.io.BufferedReader;\n&#x27;
                           &#x27;import java.io.File;\n&#x27;
                           &#x27;import java.io.IOException;\n&#x27;
                           &#x27;import java.io.InputStreamReader;\n&#x27;
                           &#x27;import java.io.OutputStreamWriter;\n&#x27;
                           &#x27;import java.io.UnsupportedEncodingException;\n&#x27;
                           &#x27;import java.net.CookieManager;\n&#x27;
                           &#x27;import java.net.HttpCookie;\n&#x27;
                           &#x27;import java.net.HttpURLConnection;\n&#x27;
                           &#x27;import java.net.URL;\n&#x27;
                           &#x27;import java.net.URLDecoder;\n&#x27;
                           &#x27;import java.net.URLEncoder;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;import java.util.Set;\n&#x27;
                           &#x27;import java.util.UUID;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * 下载文件信息获取\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class HttpFileInfoThread implements &#x27;
                           &#x27;Runnable {\n&#x27;
                           &#x27;  private static final String TAG = &#x27;
                           &#x27;&quot;HttpFileInfoThread&quot;;\n&#x27;
                           &#x27;  private DownloadEntity mEntity;\n&#x27;
                           &#x27;  private DTaskWrapper mTaskWrapper;\n&#x27;
                           &#x27;  private int mConnectTimeOut;\n&#x27;
                           &#x27;  private OnFileInfoCallback onFileInfoCallback;\n&#x27;
                           &#x27;  private HttpTaskOption taskOption;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  public HttpFileInfoThread(DTaskWrapper &#x27;
                           &#x27;taskWrapper, OnFileInfoCallback callback) {\n&#x27;
                           &#x27;    this.mTaskWrapper = taskWrapper;\n&#x27;
                           &#x27;    mEntity = taskWrapper.getEntity();\n&#x27;
                           &#x27;    mConnectTimeOut = &#x27;
                           &#x27;AriaConfig.getInstance().getDConfig().getConnectTimeOut();\n&#x27;
                           &#x27;    onFileInfoCallback = callback;\n&#x27;
                           &#x27;    taskOption = (HttpTaskOption) &#x27;
                           &#x27;taskWrapper.getTaskOption();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public void run() {\n&#x27;
                           &#x27;    &#x27;
                           &#x27;Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n&#x27;
                           &#x27;    &#x27;
                           &#x27;TrafficStats.setThreadStatsTag(UUID.randomUUID().toString().hashCode());\n&#x27;
                           &#x27;    HttpURLConnection conn = null;\n&#x27;
                           &#x27;    try {\n&#x27;
                           &#x27;      URL url = &#x27;
                           &#x27;ConnectionHelp.handleUrl(mEntity.getUrl(), &#x27;
                           &#x27;taskOption);\n&#x27;
                           &#x27;      conn = ConnectionHelp.handleConnection(url, &#x27;
                           &#x27;taskOption);\n&#x27;
                           &#x27;      ConnectionHelp.setConnectParam(taskOption, &#x27;
                           &#x27;conn);\n&#x27;
                           &#x27;      conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + &#x27;
                           &#x27;0 + &quot;-&quot;);\n&#x27;
                           &#x27;      conn.setConnectTimeout(mConnectTimeOut);\n&#x27;
                           &#x27;      conn.connect();\n&#x27;
                           &#x27;      handleConnect(conn);\n&#x27;
                           &#x27;    } catch (IOException e) {\n&#x27;
                           &#x27;      e.printStackTrace();\n&#x27;
                           &#x27;      failDownload(new AriaIOException(TAG,\n&#x27;
                           &#x27;              String.format(&quot;下载失败，filePath: %s, &#x27;
                           &#x27;url: %s&quot;, mEntity.getDownloadPath(), &#x27;
                           &#x27;mEntity.getUrl())),\n&#x27;
                           &#x27;          true);\n&#x27;
                           &#x27;    } finally {\n&#x27;
                           &#x27;      if (conn != null) {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;          conn.getInputStream().close();\n&#x27;
                           &#x27;        } catch (IOException e) {\n&#x27;
                           &#x27;          e.printStackTrace();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        conn.disconnect();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private void handleConnect(HttpURLConnection &#x27;
                           &#x27;conn) throws IOException {\n&#x27;
                           &#x27;    if (taskOption.getRequestEnum() == &#x27;
                           &#x27;RequestEnum.POST) {\n&#x27;
                           &#x27;      Map&lt;String, String&gt; params = &#x27;
                           &#x27;taskOption.getParams();\n&#x27;
                           &#x27;      if (params != null) {\n&#x27;
                           &#x27;        OutputStreamWriter dos = new &#x27;
                           &#x27;OutputStreamWriter(conn.getOutputStream());\n&#x27;
                           &#x27;        Set&lt;String&gt; keys = params.keySet();\n&#x27;
                           &#x27;        StringBuilder sb = new StringBuilder();\n&#x27;
                           &#x27;        for (String key : keys) {\n&#x27;
                           &#x27;          &#x27;
                           &#x27;sb.append(key).append(&quot;=&quot;).append(URLEncoder.encode(params.get(key))).append(&quot;&amp;&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        String url = sb.toString();\n&#x27;
                           &#x27;        url = url.substring(0, url.length() - 1);\n&#x27;
                           &#x27;        dos.write(url);\n&#x27;
                           &#x27;        dos.flush();\n&#x27;
                           &#x27;        dos.close();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    IHttpFileLenAdapter lenAdapter = &#x27;
                           &#x27;taskOption.getFileLenAdapter();\n&#x27;
                           &#x27;    if (lenAdapter == null) {\n&#x27;
                           &#x27;      lenAdapter = new FileLenAdapter();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      ALog.d(TAG, &quot;使用自定义adapter&quot;);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    long len = &#x27;
                           &#x27;lenAdapter.handleFileLen(conn.getHeaderFields());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    if &#x27;
                           &#x27;(!FileUtil.checkMemorySpace(mEntity.getFilePath(), &#x27;
                           &#x27;len)) {\n&#x27;
                           &#x27;      failDownload(new TaskException(TAG,\n&#x27;
                           &#x27;          String.format(&quot;下载失败，内存空间不足；filePath: %s, &#x27;
                           &#x27;url: %s&quot;, mEntity.getDownloadPath(),\n&#x27;
                           &#x27;              mEntity.getUrl())), false);\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    int code = conn.getResponseCode();\n&#x27;
                           &#x27;    boolean end = false;\n&#x27;
                           &#x27;    if (TextUtils.isEmpty(mEntity.getMd5Code())) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      String md5Code = &#x27;
                           &#x27;conn.getHeaderField(&quot;Content-MD5&quot;);\n&#x27;
                           &#x27;      mEntity.setMd5Code(md5Code);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    boolean isChunked = false;\n&#x27;
                           &#x27;    final String str = &#x27;
                           &#x27;conn.getHeaderField(&quot;Transfer-Encoding&quot;);\n&#x27;
                           &#x27;    if (!TextUtils.isEmpty(str) &amp;&amp; &#x27;
                           &#x27;str.equals(&quot;chunked&quot;)) {\n&#x27;
                           &#x27;      isChunked = true;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    Map&lt;String, List&lt;String&gt;&gt; headers = &#x27;
                           &#x27;conn.getHeaderFields();\n&#x27;
                           &#x27;    String disposition = &#x27;
                           &#x27;conn.getHeaderField(&quot;Content-Disposition&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    if (taskOption.isUseServerFileName()) {\n&#x27;
                           &#x27;      if (!TextUtils.isEmpty(disposition)) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mEntity.setDisposition(CommonUtil.encryptBASE64(disposition));\n&#x27;
                           &#x27;        handleContentDisposition(disposition);\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        ALog.w(TAG, &#x27;
                           &#x27;&quot;Content-Disposition对于端字段为空，使用服务器端文件名失败&quot;);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    CookieManager msCookieManager = new &#x27;
                           &#x27;CookieManager();\n&#x27;
                           &#x27;    List&lt;String&gt; cookiesHeader = &#x27;
                           &#x27;headers.get(&quot;Set-Cookie&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    if (cookiesHeader != null) {\n&#x27;
                           &#x27;      for (String cookie : cookiesHeader) {\n&#x27;
                           &#x27;        msCookieManager.getCookieStore().add(null, &#x27;
                           &#x27;HttpCookie.parse(cookie).get(0));\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      &#x27;
                           &#x27;taskOption.setCookieManager(msCookieManager);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    mTaskWrapper.setCode(code);\n&#x27;
                           &#x27;    if (code == HttpURLConnection.HTTP_PARTIAL) {\n&#x27;
                           &#x27;      if (!checkLen(len) &amp;&amp; !isChunked) {\n&#x27;
                           &#x27;        if (len &lt; 0) {\n&#x27;
                           &#x27;          failDownload(\n&#x27;
                           &#x27;              new AriaIOException(TAG, &#x27;
                           &#x27;String.format(&quot;任务下载失败，文件长度小于0， url: %s&quot;, &#x27;
                           &#x27;mEntity.getUrl())),\n&#x27;
                           &#x27;              false);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mEntity.setFileSize(len);\n&#x27;
                           &#x27;      mTaskWrapper.setSupportBP(true);\n&#x27;
                           &#x27;      end = true;\n&#x27;
                           &#x27;    } else if (code == HttpURLConnection.HTTP_OK) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      String contentType = &#x27;
                           &#x27;conn.getHeaderField(&quot;Content-Type&quot;);\n&#x27;
                           &#x27;      if (TextUtils.isEmpty(contentType)) {\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      if (contentType.equals(&quot;text/html&quot;)) {\n&#x27;
                           &#x27;        BufferedReader reader =\n&#x27;
                           &#x27;            new BufferedReader(new &#x27;
                           &#x27;InputStreamReader(ConnectionHelp.convertInputStream(conn)));\n&#x27;
                           &#x27;        StringBuilder sb = new StringBuilder();\n&#x27;
                           &#x27;        String line;\n&#x27;
                           &#x27;        while ((line = reader.readLine()) != null) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;          sb.append(line);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        reader.close();\n&#x27;
                           &#x27;        handleUrlReTurn(conn, &#x27;
                           &#x27;CommonUtil.getWindowReplaceUrl(sb.toString()));\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      } else if (!checkLen(len) &amp;&amp; !isChunked) {\n&#x27;
                           &#x27;        if (len &lt; 0) {\n&#x27;
                           &#x27;          failDownload(\n&#x27;
                           &#x27;              new AriaIOException(TAG, &#x27;
                           &#x27;String.format(&quot;任务下载失败，文件长度小于0， url: %s&quot;, &#x27;
                           &#x27;mEntity.getUrl())),\n&#x27;
                           &#x27;              false);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        ALog.d(TAG, &quot;len &lt; 0&quot;);\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mEntity.setFileSize(len);\n&#x27;
                           &#x27;      mTaskWrapper.setNewTask(true);\n&#x27;
                           &#x27;      mTaskWrapper.setSupportBP(false);\n&#x27;
                           &#x27;      end = true;\n&#x27;
                           &#x27;    } else if (code == &#x27;
                           &#x27;HttpURLConnection.HTTP_NOT_FOUND) {\n&#x27;
                           &#x27;      failDownload(new AriaIOException(TAG,\n&#x27;
                           &#x27;          String.format(&quot;任务下载失败，errorCode：404, &#x27;
                           &#x27;url: %s&quot;, mEntity.getUrl())), true);\n&#x27;
                           &#x27;    } else if (code == &#x27;
                           &#x27;HttpURLConnection.HTTP_MOVED_TEMP\n&#x27;
                           &#x27;        || code == &#x27;
                           &#x27;HttpURLConnection.HTTP_MOVED_PERM\n&#x27;
                           &#x27;        || code == &#x27;
                           &#x27;HttpURLConnection.HTTP_SEE_OTHER\n&#x27;
                           &#x27;        || code == HttpURLConnection.HTTP_CREATED &#x27;
                           &#x27;// 201 跳转\n&#x27;
                           &#x27;        || code == 307) {\n&#x27;
                           &#x27;      handleUrlReTurn(conn, &#x27;
                           &#x27;conn.getHeaderField(&quot;Location&quot;));\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      failDownload(new AriaIOException(TAG,\n&#x27;
                           &#x27;          String.format(&quot;任务下载失败，errorCode：%s, &#x27;
                           &#x27;errorMsg: %s, url: %s&quot;, code,\n&#x27;
                           &#x27;              conn.getResponseMessage(), &#x27;
                           &#x27;mEntity.getUrl())), &#x27;
                           &#x27;!CheckUtil.httpIsBadRequest(code));\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    if (end) {\n&#x27;
                           &#x27;      taskOption.setChunked(isChunked);\n&#x27;
                           &#x27;      if (onFileInfoCallback != null) {\n&#x27;
                           &#x27;        CompleteInfo info = new CompleteInfo(code, &#x27;
                           &#x27;mTaskWrapper);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;onFileInfoCallback.onComplete(mEntity.getUrl(), &#x27;
                           &#x27;info);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mEntity.update();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理&quot;Content-Disposition&quot;参数\n&#x27;
                           &#x27;   * &lt;a &#x27;
                           &#x27;href=https://cloud.tencent.com/developer/section/1189916&gt;Content-Disposition&lt;/a&gt;&lt;/&gt;\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @throws UnsupportedEncodingException\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleContentDisposition(String &#x27;
                           &#x27;disposition) throws UnsupportedEncodingException &#x27;
                           &#x27;{\n&#x27;
                           &#x27;    if (disposition.contains(&quot;;&quot;)) {\n&#x27;
                           &#x27;      String[] infos = disposition.split(&quot;;&quot;);\n&#x27;
                           &#x27;      if (infos[0].equals(&quot;attachment&quot;)) {\n&#x27;
                           &#x27;        for (String info : infos) {\n&#x27;
                           &#x27;          if (info.startsWith(&quot;filename&quot;) &amp;&amp; &#x27;
                           &#x27;info.contains(&quot;=&quot;)) {\n&#x27;
                           &#x27;            String[] temp = info.split(&quot;=&quot;);\n&#x27;
                           &#x27;            if (temp.length &gt; 1) {\n&#x27;
                           &#x27;              String newName = &#x27;
                           &#x27;URLDecoder.decode(temp[1], &#x27;
                           &#x27;&quot;utf-8&quot;).replaceAll(&quot;\\&quot;&quot;, &quot;&quot;);\n&#x27;
                           &#x27;              mEntity.setServerFileName(newName);\n&#x27;
                           &#x27;              renameFile(newName);\n&#x27;
                           &#x27;              break;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      } else if (infos[0].equals(&quot;form-data&quot;) &amp;&amp; &#x27;
                           &#x27;infos.length &gt; 2) {\n&#x27;
                           &#x27;        String[] temp = infos[2].split(&quot;=&quot;);\n&#x27;
                           &#x27;        if (temp.length &gt; 1) {\n&#x27;
                           &#x27;          String newName = &#x27;
                           &#x27;URLDecoder.decode(temp[1], &#x27;
                           &#x27;&quot;utf-8&quot;).replaceAll(&quot;\\&quot;&quot;, &quot;&quot;);\n&#x27;
                           &#x27;          mEntity.setServerFileName(newName);\n&#x27;
                           &#x27;          renameFile(newName);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        ALog.w(TAG, &quot;不识别的Content-Disposition参数&quot;);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 重命名文件\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void renameFile(String newName) {\n&#x27;
                           &#x27;    if (TextUtils.isEmpty(newName)) {\n&#x27;
                           &#x27;      ALog.w(TAG, &quot;重命名失败【服务器返回的文件名为空】&quot;);\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    ALog.d(TAG, String.format(&quot;文件重命名为：%s&quot;, &#x27;
                           &#x27;newName));\n&#x27;
                           &#x27;    File oldFile = new &#x27;
                           &#x27;File(mEntity.getFilePath());\n&#x27;
                           &#x27;    String newPath = oldFile.getParent() + &quot;/&quot; + &#x27;
                           &#x27;newName;\n&#x27;
                           &#x27;    if (oldFile.exists()) {\n&#x27;
                           &#x27;      boolean b = oldFile.renameTo(new &#x27;
                           &#x27;File(newPath));\n&#x27;
                           &#x27;      ALog.d(TAG, String.format(&quot;文件重命名%s&quot;, b ? &#x27;
                           &#x27;&quot;成功&quot; : &quot;失败&quot;));\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    mEntity.setFileName(newName);\n&#x27;
                           &#x27;    mEntity.setFilePath(newPath);\n&#x27;
                           &#x27;    RecordUtil.modifyTaskRecord(oldFile.getPath(), &#x27;
                           &#x27;newPath, mEntity.getTaskType());\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理30x跳转\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleUrlReTurn(HttpURLConnection &#x27;
                           &#x27;conn, String newUrl) throws IOException {\n&#x27;
                           &#x27;    ALog.d(TAG, &quot;30x跳转，新url为【&quot; + newUrl + &quot;】&quot;);\n&#x27;
                           &#x27;    if (TextUtils.isEmpty(newUrl) || &#x27;
                           &#x27;newUrl.equalsIgnoreCase(&quot;null&quot;)) {\n&#x27;
                           &#x27;      if (onFileInfoCallback != null) {\n&#x27;
                           &#x27;        onFileInfoCallback.onFail(mEntity, new &#x27;
                           &#x27;TaskException(TAG, &quot;获取重定向链接失败&quot;), false);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    if (newUrl.startsWith(&quot;/&quot;)) {\n&#x27;
                           &#x27;      Uri uri = Uri.parse(mEntity.getUrl());\n&#x27;
                           &#x27;      newUrl = uri.getHost() + newUrl;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    if (!CheckUtil.checkUrl(newUrl)) {\n&#x27;
                           &#x27;      failDownload(new TaskException(TAG, &#x27;
                           &#x27;&quot;下载失败，重定向url错误&quot;), false);\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    taskOption.setRedirectUrl(newUrl);\n&#x27;
                           &#x27;    mEntity.setRedirect(true);\n&#x27;
                           &#x27;    mEntity.setRedirectUrl(newUrl);\n&#x27;
                           &#x27;    String cookies = &#x27;
                           &#x27;conn.getHeaderField(&quot;Set-Cookie&quot;);\n&#x27;
                           &#x27;    conn.disconnect();\n&#x27;
                           &#x27;    URL url = ConnectionHelp.handleUrl(newUrl, &#x27;
                           &#x27;taskOption);\n&#x27;
                           &#x27;    conn = ConnectionHelp.handleConnection(url, &#x27;
                           &#x27;taskOption);\n&#x27;
                           &#x27;    ConnectionHelp.setConnectParam(taskOption, &#x27;
                           &#x27;conn);\n&#x27;
                           &#x27;    conn.setRequestProperty(&quot;Cookie&quot;, cookies);\n&#x27;
                           &#x27;    conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + 0 &#x27;
                           &#x27;+ &quot;-&quot;);\n&#x27;
                           &#x27;    conn.setConnectTimeout(mConnectTimeOut);\n&#x27;
                           &#x27;    conn.connect();\n&#x27;
                           &#x27;    handleConnect(conn);\n&#x27;
                           &#x27;    conn.disconnect();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * &#x27;
                           &#x27;检查长度是否合法，并且检查新获取的文件长度是否和数据库的文件长度一直，如果不一致，则表示该任务为新任务\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param len 从服务器获取的文件长度\n&#x27;
                           &#x27;   * @return {@code true}合法\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private boolean checkLen(long len) {\n&#x27;
                           &#x27;    if (len != mEntity.getFileSize()) {\n&#x27;
                           &#x27;      ALog.d(TAG, &quot;长度不一致，任务为新任务&quot;);\n&#x27;
                           &#x27;      mTaskWrapper.setNewTask(true);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    return true;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private void failDownload(BaseException e, &#x27;
                           &#x27;boolean needRetry) {\n&#x27;
                           &#x27;    if (onFileInfoCallback != null) {\n&#x27;
                           &#x27;      onFileInfoCallback.onFail(mEntity, e, &#x27;
                           &#x27;needRetry);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private static class FileLenAdapter implements &#x27;
                           &#x27;IHttpFileLenAdapter {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override public long &#x27;
                           &#x27;handleFileLen(Map&lt;String, List&lt;String&gt;&gt; headers) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      if (headers == null || headers.isEmpty()) {\n&#x27;
                           &#x27;        ALog.e(TAG, &quot;header为空，获取文件长度失败&quot;);\n&#x27;
                           &#x27;        return -1;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      List&lt;String&gt; sLength = &#x27;
                           &#x27;headers.get(&quot;Content-Length&quot;);\n&#x27;
                           &#x27;      if (sLength == null || sLength.isEmpty()) {\n&#x27;
                           &#x27;        return -1;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      String temp = sLength.get(0);\n&#x27;
                           &#x27;      long len = TextUtils.isEmpty(temp) ? -1 : &#x27;
                           &#x27;Long.parseLong(temp);\n&#x27;
                           &#x27;      // &#x27;
                           &#x27;某些服务，如果设置了conn.setRequestProperty(&quot;Range&quot;, &#x27;
                           &#x27;&quot;bytes=&quot; + 0 + &quot;-&quot;);\n&#x27;
                           &#x27;      // 会返回 Content-Range: bytes &#x27;
                           &#x27;0-225427911/225427913\n&#x27;
                           &#x27;      if (len &lt; 0) {\n&#x27;
                           &#x27;        List&lt;String&gt; sRange = &#x27;
                           &#x27;headers.get(&quot;Content-Range&quot;);\n&#x27;
                           &#x27;        if (sRange == null || sRange.isEmpty()) {\n&#x27;
                           &#x27;          len = -1;\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          int start = temp.indexOf(&quot;/&quot;);\n&#x27;
                           &#x27;          len = &#x27;
                           &#x27;Long.parseLong(temp.substring(start + 1));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      return len;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*\n&#x27;
                           &#x27; * Copyright (C) 2016 &#x27;
                           &#x27;AriaLyy(https://github.com/AriaLyy/Aria)\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                           &#x27;(the &quot;License&quot;);\n&#x27;
                           &#x27; * you may not use this file except in compliance &#x27;
                           &#x27;with the License.\n&#x27;
                           &#x27; * You may obtain a copy of the License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *      &#x27;
                           &#x27;http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;package com.arialyy.aria.http;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import android.net.TrafficStats;\n&#x27;
                           &#x27;import android.net.Uri;\n&#x27;
                           &#x27;import android.os.Process;\n&#x27;
                           &#x27;import android.text.TextUtils;\n&#x27;
                           &#x27;import com.arialyy.aria.core.AriaConfig;\n&#x27;
                           &#x27;import com.arialyy.aria.core.common.CompleteInfo;\n&#x27;
                           &#x27;import com.arialyy.aria.core.common.RequestEnum;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.DTaskWrapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.DownloadEntity;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.inf.OnFileInfoCallback;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.processor.IHttpFileLenAdapter;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.exception.AriaIOException;\n&#x27;
                           &#x27;import com.arialyy.aria.exception.BaseException;\n&#x27;
                           &#x27;import com.arialyy.aria.exception.TaskException;\n&#x27;
                           &#x27;import com.arialyy.aria.util.ALog;\n&#x27;
                           &#x27;import com.arialyy.aria.util.CheckUtil;\n&#x27;
                           &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                           &#x27;import com.arialyy.aria.util.FileUtil;\n&#x27;
                           &#x27;import com.arialyy.aria.util.RecordUtil;\n&#x27;
                           &#x27;import java.io.BufferedReader;\n&#x27;
                           &#x27;import java.io.File;\n&#x27;
                           &#x27;import java.io.IOException;\n&#x27;
                           &#x27;import java.io.InputStreamReader;\n&#x27;
                           &#x27;import java.io.OutputStreamWriter;\n&#x27;
                           &#x27;import java.io.UnsupportedEncodingException;\n&#x27;
                           &#x27;import java.net.CookieManager;\n&#x27;
                           &#x27;import java.net.HttpCookie;\n&#x27;
                           &#x27;import java.net.HttpURLConnection;\n&#x27;
                           &#x27;import java.net.URL;\n&#x27;
                           &#x27;import java.net.URLDecoder;\n&#x27;
                           &#x27;import java.net.URLEncoder;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;import java.util.Set;\n&#x27;
                           &#x27;import java.util.UUID;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * 下载文件信息获取\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class HttpFileInfoThread implements &#x27;
                           &#x27;Runnable {\n&#x27;
                           &#x27;  private static final String TAG = &#x27;
                           &#x27;&quot;HttpFileInfoThread&quot;;\n&#x27;
                           &#x27;  private DownloadEntity mEntity;\n&#x27;
                           &#x27;  private DTaskWrapper mTaskWrapper;\n&#x27;
                           &#x27;  private int mConnectTimeOut;\n&#x27;
                           &#x27;  private OnFileInfoCallback onFileInfoCallback;\n&#x27;
                           &#x27;  private HttpTaskOption taskOption;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  public HttpFileInfoThread(DTaskWrapper &#x27;
                           &#x27;taskWrapper, OnFileInfoCallback callback) {\n&#x27;
                           &#x27;    this.mTaskWrapper = taskWrapper;\n&#x27;
                           &#x27;    mEntity = taskWrapper.getEntity();\n&#x27;
                           &#x27;    mConnectTimeOut = &#x27;
                           &#x27;AriaConfig.getInstance().getDConfig().getConnectTimeOut();\n&#x27;
                           &#x27;    onFileInfoCallback = callback;\n&#x27;
                           &#x27;    taskOption = (HttpTaskOption) &#x27;
                           &#x27;taskWrapper.getTaskOption();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public void run() {\n&#x27;
                           &#x27;    &#x27;
                           &#x27;Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n&#x27;
                           &#x27;    &#x27;
                           &#x27;TrafficStats.setThreadStatsTag(UUID.randomUUID().toString().hashCode());\n&#x27;
                           &#x27;    HttpURLConnection conn = null;\n&#x27;
                           &#x27;    try {\n&#x27;
                           &#x27;      URL url = &#x27;
                           &#x27;ConnectionHelp.handleUrl(mEntity.getUrl(), &#x27;
                           &#x27;taskOption);\n&#x27;
                           &#x27;      conn = ConnectionHelp.handleConnection(url, &#x27;
                           &#x27;taskOption);\n&#x27;
                           &#x27;      ConnectionHelp.setConnectParam(taskOption, &#x27;
                           &#x27;conn);\n&#x27;
                           &#x27;      conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + &#x27;
                           &#x27;0 + &quot;-&quot;);\n&#x27;
                           &#x27;      conn.setConnectTimeout(mConnectTimeOut);\n&#x27;
                           &#x27;      conn.connect();\n&#x27;
                           &#x27;      handleConnect(conn);\n&#x27;
                           &#x27;    } catch (IOException e) {\n&#x27;
                           &#x27;      e.printStackTrace();\n&#x27;
                           &#x27;      failDownload(new AriaIOException(TAG,\n&#x27;
                           &#x27;              String.format(&quot;下载失败，filePath: %s, &#x27;
                           &#x27;url: %s&quot;, mEntity.getDownloadPath(), &#x27;
                           &#x27;mEntity.getUrl())),\n&#x27;
                           &#x27;          true);\n&#x27;
                           &#x27;    } finally {\n&#x27;
                           &#x27;      if (conn != null) {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;          conn.getInputStream().close();\n&#x27;
                           &#x27;        } catch (IOException e) {\n&#x27;
                           &#x27;          e.printStackTrace();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        conn.disconnect();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private void handleConnect(HttpURLConnection &#x27;
                           &#x27;conn) throws IOException {\n&#x27;
                           &#x27;    if (taskOption.getRequestEnum() == &#x27;
                           &#x27;RequestEnum.POST) {\n&#x27;
                           &#x27;      Map&lt;String, String&gt; params = &#x27;
                           &#x27;taskOption.getParams();\n&#x27;
                           &#x27;      if (params != null) {\n&#x27;
                           &#x27;        OutputStreamWriter dos = new &#x27;
                           &#x27;OutputStreamWriter(conn.getOutputStream());\n&#x27;
                           &#x27;        Set&lt;String&gt; keys = params.keySet();\n&#x27;
                           &#x27;        StringBuilder sb = new StringBuilder();\n&#x27;
                           &#x27;        for (String key : keys) {\n&#x27;
                           &#x27;          &#x27;
                           &#x27;sb.append(key).append(&quot;=&quot;).append(URLEncoder.encode(params.get(key))).append(&quot;&amp;&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        String url = sb.toString();\n&#x27;
                           &#x27;        url = url.substring(0, url.length() - 1);\n&#x27;
                           &#x27;        dos.write(url);\n&#x27;
                           &#x27;        dos.flush();\n&#x27;
                           &#x27;        dos.close();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    IHttpFileLenAdapter lenAdapter = &#x27;
                           &#x27;taskOption.getFileLenAdapter();\n&#x27;
                           &#x27;    if (lenAdapter == null) {\n&#x27;
                           &#x27;      lenAdapter = new FileLenAdapter();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      ALog.d(TAG, &quot;使用自定义adapter&quot;);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    long len = &#x27;
                           &#x27;lenAdapter.handleFileLen(conn.getHeaderFields());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    if &#x27;
                           &#x27;(!FileUtil.checkMemorySpace(mEntity.getFilePath(), &#x27;
                           &#x27;len)) {\n&#x27;
                           &#x27;      failDownload(new TaskException(TAG,\n&#x27;
                           &#x27;          String.format(&quot;下载失败，内存空间不足；filePath: %s, &#x27;
                           &#x27;url: %s&quot;, mEntity.getDownloadPath(),\n&#x27;
                           &#x27;              mEntity.getUrl())), false);\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    int code = conn.getResponseCode();\n&#x27;
                           &#x27;    boolean end = false;\n&#x27;
                           &#x27;    if (TextUtils.isEmpty(mEntity.getMd5Code())) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      String md5Code = &#x27;
                           &#x27;conn.getHeaderField(&quot;Content-MD5&quot;);\n&#x27;
                           &#x27;      mEntity.setMd5Code(md5Code);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    boolean isChunked = false;\n&#x27;
                           &#x27;    final String str = &#x27;
                           &#x27;conn.getHeaderField(&quot;Transfer-Encoding&quot;);\n&#x27;
                           &#x27;    if (!TextUtils.isEmpty(str) &amp;&amp; &#x27;
                           &#x27;str.equals(&quot;chunked&quot;)) {\n&#x27;
                           &#x27;      isChunked = true;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    Map&lt;String, List&lt;String&gt;&gt; headers = &#x27;
                           &#x27;conn.getHeaderFields();\n&#x27;
                           &#x27;    String disposition = &#x27;
                           &#x27;conn.getHeaderField(&quot;Content-Disposition&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    if (taskOption.isUseServerFileName()) {\n&#x27;
                           &#x27;      if (!TextUtils.isEmpty(disposition)) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mEntity.setDisposition(CommonUtil.encryptBASE64(disposition));\n&#x27;
                           &#x27;        handleContentDisposition(disposition);\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        ALog.w(TAG, &#x27;
                           &#x27;&quot;Content-Disposition对于端字段为空，使用服务器端文件名失败&quot;);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    CookieManager msCookieManager = new &#x27;
                           &#x27;CookieManager();\n&#x27;
                           &#x27;    List&lt;String&gt; cookiesHeader = &#x27;
                           &#x27;headers.get(&quot;Set-Cookie&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    if (cookiesHeader != null) {\n&#x27;
                           &#x27;      for (String cookie : cookiesHeader) {\n&#x27;
                           &#x27;        msCookieManager.getCookieStore().add(null, &#x27;
                           &#x27;HttpCookie.parse(cookie).get(0));\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      &#x27;
                           &#x27;taskOption.setCookieManager(msCookieManager);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    mTaskWrapper.setCode(code);\n&#x27;
                           &#x27;    if (code == HttpURLConnection.HTTP_PARTIAL) {\n&#x27;
                           &#x27;      if (!checkLen(len) &amp;&amp; !isChunked) {\n&#x27;
                           &#x27;        if (len &lt; 0) {\n&#x27;
                           &#x27;          failDownload(\n&#x27;
                           &#x27;              new AriaIOException(TAG, &#x27;
                           &#x27;String.format(&quot;任务下载失败，文件长度小于0， url: %s&quot;, &#x27;
                           &#x27;mEntity.getUrl())),\n&#x27;
                           &#x27;              false);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mEntity.setFileSize(len);\n&#x27;
                           &#x27;      mTaskWrapper.setSupportBP(true);\n&#x27;
                           &#x27;      end = true;\n&#x27;
                           &#x27;    } else if (code == HttpURLConnection.HTTP_OK) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      String contentType = &#x27;
                           &#x27;conn.getHeaderField(&quot;Content-Type&quot;);\n&#x27;
                           &#x27;      if (TextUtils.isEmpty(contentType)) {\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      if (contentType.equals(&quot;text/html&quot;)) {\n&#x27;
                           &#x27;        BufferedReader reader =\n&#x27;
                           &#x27;            new BufferedReader(new &#x27;
                           &#x27;InputStreamReader(ConnectionHelp.convertInputStream(conn)));\n&#x27;
                           &#x27;        StringBuilder sb = new StringBuilder();\n&#x27;
                           &#x27;        String line;\n&#x27;
                           &#x27;        while ((line = reader.readLine()) != null) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;          sb.append(line);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        reader.close();\n&#x27;
                           &#x27;        handleUrlReTurn(conn, &#x27;
                           &#x27;CommonUtil.getWindowReplaceUrl(sb.toString()));\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      } else if (!checkLen(len) &amp;&amp; !isChunked) {\n&#x27;
                           &#x27;        if (len &lt; 0) {\n&#x27;
                           &#x27;          failDownload(\n&#x27;
                           &#x27;              new AriaIOException(TAG, &#x27;
                           &#x27;String.format(&quot;任务下载失败，文件长度小于0， url: %s&quot;, &#x27;
                           &#x27;mEntity.getUrl())),\n&#x27;
                           &#x27;              false);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        ALog.d(TAG, &quot;len &lt; 0&quot;);\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mEntity.setFileSize(len);\n&#x27;
                           &#x27;      mTaskWrapper.setNewTask(true);\n&#x27;
                           &#x27;      mTaskWrapper.setSupportBP(false);\n&#x27;
                           &#x27;      end = true;\n&#x27;
                           &#x27;    } else if (code == &#x27;
                           &#x27;HttpURLConnection.HTTP_NOT_FOUND) {\n&#x27;
                           &#x27;      failDownload(new AriaIOException(TAG,\n&#x27;
                           &#x27;          String.format(&quot;任务下载失败，errorCode：404, &#x27;
                           &#x27;url: %s&quot;, mEntity.getUrl())), true);\n&#x27;
                           &#x27;    } else if (code == &#x27;
                           &#x27;HttpURLConnection.HTTP_MOVED_TEMP\n&#x27;
                           &#x27;        || code == &#x27;
                           &#x27;HttpURLConnection.HTTP_MOVED_PERM\n&#x27;
                           &#x27;        || code == &#x27;
                           &#x27;HttpURLConnection.HTTP_SEE_OTHER\n&#x27;
                           &#x27;        || code == HttpURLConnection.HTTP_CREATED &#x27;
                           &#x27;// 201 跳转\n&#x27;
                           &#x27;        || code == 307) {\n&#x27;
                           &#x27;      handleUrlReTurn(conn, &#x27;
                           &#x27;conn.getHeaderField(&quot;Location&quot;));\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      failDownload(new AriaIOException(TAG,\n&#x27;
                           &#x27;          String.format(&quot;任务下载失败，errorCode：%s, &#x27;
                           &#x27;errorMsg: %s, url: %s&quot;, code,\n&#x27;
                           &#x27;              conn.getResponseMessage(), &#x27;
                           &#x27;mEntity.getUrl())), &#x27;
                           &#x27;!CheckUtil.httpIsBadRequest(code));\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    if (end) {\n&#x27;
                           &#x27;      taskOption.setChunked(isChunked);\n&#x27;
                           &#x27;      if (onFileInfoCallback != null) {\n&#x27;
                           &#x27;        CompleteInfo info = new CompleteInfo(code, &#x27;
                           &#x27;mTaskWrapper);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;onFileInfoCallback.onComplete(mEntity.getUrl(), &#x27;
                           &#x27;info);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mEntity.update();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理&quot;Content-Disposition&quot;参数\n&#x27;
                           &#x27;   * &lt;a &#x27;
                           &#x27;href=https://cloud.tencent.com/developer/section/1189916&gt;Content-Disposition&lt;/a&gt;&lt;/&gt;\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @throws UnsupportedEncodingException\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleContentDisposition(String &#x27;
                           &#x27;disposition) throws UnsupportedEncodingException &#x27;
                           &#x27;{\n&#x27;
                           &#x27;    if (disposition.contains(&quot;;&quot;)) {\n&#x27;
                           &#x27;      String[] infos = disposition.split(&quot;;&quot;);\n&#x27;
                           &#x27;      if (infos[0].equals(&quot;attachment&quot;)) {\n&#x27;
                           &#x27;        for (String info : infos) {\n&#x27;
                           &#x27;          if (info.startsWith(&quot;filename&quot;) &amp;&amp; &#x27;
                           &#x27;info.contains(&quot;=&quot;)) {\n&#x27;
                           &#x27;            String[] temp = info.split(&quot;=&quot;);\n&#x27;
                           &#x27;            if (temp.length &gt; 1) {\n&#x27;
                           &#x27;              String newName = &#x27;
                           &#x27;URLDecoder.decode(temp[1], &#x27;
                           &#x27;&quot;utf-8&quot;).replaceAll(&quot;\\&quot;&quot;, &quot;&quot;);\n&#x27;
                           &#x27;              mEntity.setServerFileName(newName);\n&#x27;
                           &#x27;              renameFile(newName);\n&#x27;
                           &#x27;              break;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      } else if (infos[0].equals(&quot;form-data&quot;) &amp;&amp; &#x27;
                           &#x27;infos.length &gt; 2) {\n&#x27;
                           &#x27;        String[] temp = infos[2].split(&quot;=&quot;);\n&#x27;
                           &#x27;        if (temp.length &gt; 1) {\n&#x27;
                           &#x27;          String newName = &#x27;
                           &#x27;URLDecoder.decode(temp[1], &#x27;
                           &#x27;&quot;utf-8&quot;).replaceAll(&quot;\\&quot;&quot;, &quot;&quot;);\n&#x27;
                           &#x27;          mEntity.setServerFileName(newName);\n&#x27;
                           &#x27;          renameFile(newName);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        ALog.w(TAG, &quot;不识别的Content-Disposition参数&quot;);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 重命名文件\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void renameFile(String newName) {\n&#x27;
                           &#x27;    if (TextUtils.isEmpty(newName)) {\n&#x27;
                           &#x27;      ALog.w(TAG, &quot;重命名失败【服务器返回的文件名为空】&quot;);\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    ALog.d(TAG, String.format(&quot;文件重命名为：%s&quot;, &#x27;
                           &#x27;newName));\n&#x27;
                           &#x27;    File oldFile = new &#x27;
                           &#x27;File(mEntity.getFilePath());\n&#x27;
                           &#x27;    String newPath = oldFile.getParent() + &quot;/&quot; + &#x27;
                           &#x27;newName;\n&#x27;
                           &#x27;    if (oldFile.exists()) {\n&#x27;
                           &#x27;      boolean b = oldFile.renameTo(new &#x27;
                           &#x27;File(newPath));\n&#x27;
                           &#x27;      ALog.d(TAG, String.format(&quot;文件重命名%s&quot;, b ? &#x27;
                           &#x27;&quot;成功&quot; : &quot;失败&quot;));\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    mEntity.setFileName(newName);\n&#x27;
                           &#x27;    mEntity.setFilePath(newPath);\n&#x27;
                           &#x27;    RecordUtil.modifyTaskRecord(oldFile.getPath(), &#x27;
                           &#x27;newPath, mEntity.getTaskType());\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理30x跳转\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleUrlReTurn(HttpURLConnection &#x27;
                           &#x27;conn, String newUrl) throws IOException {\n&#x27;
                           &#x27;    ALog.d(TAG, &quot;30x跳转，新url为【&quot; + newUrl + &quot;】&quot;);\n&#x27;
                           &#x27;    if (TextUtils.isEmpty(newUrl) || &#x27;
                           &#x27;newUrl.equalsIgnoreCase(&quot;null&quot;)) {\n&#x27;
                           &#x27;      if (onFileInfoCallback != null) {\n&#x27;
                           &#x27;        onFileInfoCallback.onFail(mEntity, new &#x27;
                           &#x27;TaskException(TAG, &quot;获取重定向链接失败&quot;), false);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    if (newUrl.startsWith(&quot;/&quot;)) {\n&#x27;
                           &#x27;      Uri uri = Uri.parse(mEntity.getUrl());\n&#x27;
                           &#x27;      newUrl = uri.getHost() + newUrl;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    if (!CheckUtil.checkUrl(newUrl)) {\n&#x27;
                           &#x27;      failDownload(new TaskException(TAG, &#x27;
                           &#x27;&quot;下载失败，重定向url错误&quot;), false);\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    taskOption.setRedirectUrl(newUrl);\n&#x27;
                           &#x27;    mEntity.setRedirect(true);\n&#x27;
                           &#x27;    mEntity.setRedirectUrl(newUrl);\n&#x27;
                           &#x27;    String cookies = &#x27;
                           &#x27;conn.getHeaderField(&quot;Set-Cookie&quot;);\n&#x27;
                           &#x27;    conn.disconnect();\n&#x27;
                           &#x27;    URL url = ConnectionHelp.handleUrl(newUrl, &#x27;
                           &#x27;taskOption);\n&#x27;
                           &#x27;    conn = ConnectionHelp.handleConnection(url, &#x27;
                           &#x27;taskOption);\n&#x27;
                           &#x27;    ConnectionHelp.setConnectParam(taskOption, &#x27;
                           &#x27;conn);\n&#x27;
                           &#x27;    conn.setRequestProperty(&quot;Cookie&quot;, cookies);\n&#x27;
                           &#x27;    conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + 0 &#x27;
                           &#x27;+ &quot;-&quot;);\n&#x27;
                           &#x27;    conn.setConnectTimeout(mConnectTimeOut);\n&#x27;
                           &#x27;    conn.connect();\n&#x27;
                           &#x27;    handleConnect(conn);\n&#x27;
                           &#x27;    conn.disconnect();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * &#x27;
                           &#x27;检查长度是否合法，并且检查新获取的文件长度是否和数据库的文件长度一直，如果不一致，则表示该任务为新任务\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param len 从服务器获取的文件长度\n&#x27;
                           &#x27;   * @return {@code true}合法\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private boolean checkLen(long len) {\n&#x27;
                           &#x27;    if (len != mEntity.getFileSize()) {\n&#x27;
                           &#x27;      ALog.d(TAG, &quot;长度不一致，任务为新任务&quot;);\n&#x27;
                           &#x27;      mTaskWrapper.setNewTask(true);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    return true;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private void failDownload(BaseException e, &#x27;
                           &#x27;boolean needRetry) {\n&#x27;
                           &#x27;    if (onFileInfoCallback != null) {\n&#x27;
                           &#x27;      onFileInfoCallback.onFail(mEntity, e, &#x27;
                           &#x27;needRetry);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private static class FileLenAdapter implements &#x27;
                           &#x27;IHttpFileLenAdapter {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override public long &#x27;
                           &#x27;handleFileLen(Map&lt;String, List&lt;String&gt;&gt; headers) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      if (headers == null || headers.isEmpty()) {\n&#x27;
                           &#x27;        ALog.e(TAG, &quot;header为空，获取文件长度失败&quot;);\n&#x27;
                           &#x27;        return -1;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      List&lt;String&gt; sLength = &#x27;
                           &#x27;headers.get(&quot;Content-Length&quot;);\n&#x27;
                           &#x27;      if (sLength == null || sLength.isEmpty()) {\n&#x27;
                           &#x27;        return -1;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      String temp = sLength.get(0);\n&#x27;
                           &#x27;      long len = TextUtils.isEmpty(temp) ? -1 : &#x27;
                           &#x27;Long.parseLong(temp);\n&#x27;
                           &#x27;      // &#x27;
                           &#x27;某些服务，如果设置了conn.setRequestProperty(&quot;Range&quot;, &#x27;
                           &#x27;&quot;bytes=&quot; + 0 + &quot;-&quot;);\n&#x27;
                           &#x27;      // 会返回 Content-Range: bytes &#x27;
                           &#x27;0-225427911/225427913\n&#x27;
                           &#x27;      if (len &lt; 0) {\n&#x27;
                           &#x27;        List&lt;String&gt; sRange = &#x27;
                           &#x27;headers.get(&quot;Content-Range&quot;);\n&#x27;
                           &#x27;        if (sRange == null || sRange.isEmpty()) {\n&#x27;
                           &#x27;          len = -1;\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          int start = temp.indexOf(&quot;/&quot;);\n&#x27;
                           &#x27;          len = &#x27;
                           &#x27;Long.parseLong(temp.substring(start + 1));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      return len;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;/*\n&#x27;
                           &#x27; * Copyright (C) 2016 &#x27;
                           &#x27;AriaLyy(https://github.com/AriaLyy/Aria)\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                           &#x27;(the &quot;License&quot;);\n&#x27;
                           &#x27; * you may not use this file except in compliance &#x27;
                           &#x27;with the License.\n&#x27;
                           &#x27; * You may obtain a copy of the License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *      &#x27;
                           &#x27;http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;package com.arialyy.aria.http;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import android.net.TrafficStats;\n&#x27;
                           &#x27;import android.net.Uri;\n&#x27;
                           &#x27;import android.os.Process;\n&#x27;
                           &#x27;import android.text.TextUtils;\n&#x27;
                           &#x27;import com.arialyy.aria.core.AriaConfig;\n&#x27;
                           &#x27;import com.arialyy.aria.core.common.CompleteInfo;\n&#x27;
                           &#x27;import com.arialyy.aria.core.common.RequestEnum;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.DTaskWrapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.DownloadEntity;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.inf.OnFileInfoCallback;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.processor.IHttpFileLenAdapter;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.exception.AriaIOException;\n&#x27;
                           &#x27;import com.arialyy.aria.exception.BaseException;\n&#x27;
                           &#x27;import com.arialyy.aria.exception.TaskException;\n&#x27;
                           &#x27;import com.arialyy.aria.util.ALog;\n&#x27;
                           &#x27;import com.arialyy.aria.util.CheckUtil;\n&#x27;
                           &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                           &#x27;import com.arialyy.aria.util.FileUtil;\n&#x27;
                           &#x27;import com.arialyy.aria.util.RecordUtil;\n&#x27;
                           &#x27;import java.io.BufferedReader;\n&#x27;
                           &#x27;import java.io.File;\n&#x27;
                           &#x27;import java.io.IOException;\n&#x27;
                           &#x27;import java.io.InputStreamReader;\n&#x27;
                           &#x27;import java.io.OutputStreamWriter;\n&#x27;
                           &#x27;import java.io.UnsupportedEncodingException;\n&#x27;
                           &#x27;import java.net.CookieManager;\n&#x27;
                           &#x27;import java.net.HttpCookie;\n&#x27;
                           &#x27;import java.net.HttpURLConnection;\n&#x27;
                           &#x27;import java.net.URL;\n&#x27;
                           &#x27;import java.net.URLDecoder;\n&#x27;
                           &#x27;import java.net.URLEncoder;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;import java.util.Set;\n&#x27;
                           &#x27;import java.util.UUID;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * 下载文件信息获取\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class HttpFileInfoThread implements &#x27;
                           &#x27;Runnable {\n&#x27;
                           &#x27;  private static final String TAG = &#x27;
                           &#x27;&quot;HttpFileInfoThread&quot;;\n&#x27;
                           &#x27;  private DownloadEntity mEntity;\n&#x27;
                           &#x27;  private DTaskWrapper mTaskWrapper;\n&#x27;
                           &#x27;  private int mConnectTimeOut;\n&#x27;
                           &#x27;  private OnFileInfoCallback onFileInfoCallback;\n&#x27;
                           &#x27;  private HttpTaskOption taskOption;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  public HttpFileInfoThread(DTaskWrapper &#x27;
                           &#x27;taskWrapper, OnFileInfoCallback callback) {\n&#x27;
                           &#x27;    this.mTaskWrapper = taskWrapper;\n&#x27;
                           &#x27;    mEntity = taskWrapper.getEntity();\n&#x27;
                           &#x27;    mConnectTimeOut = &#x27;
                           &#x27;AriaConfig.getInstance().getDConfig().getConnectTimeOut();\n&#x27;
                           &#x27;    onFileInfoCallback = callback;\n&#x27;
                           &#x27;    taskOption = (HttpTaskOption) &#x27;
                           &#x27;taskWrapper.getTaskOption();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public void run() {\n&#x27;
                           &#x27;    &#x27;
                           &#x27;Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n&#x27;
                           &#x27;    &#x27;
                           &#x27;TrafficStats.setThreadStatsTag(UUID.randomUUID().toString().hashCode());\n&#x27;
                           &#x27;    HttpURLConnection conn = null;\n&#x27;
                           &#x27;    try {\n&#x27;
                           &#x27;      URL url = &#x27;
                           &#x27;ConnectionHelp.handleUrl(mEntity.getUrl(), &#x27;
                           &#x27;taskOption);\n&#x27;
                           &#x27;      conn = ConnectionHelp.handleConnection(url, &#x27;
                           &#x27;taskOption);\n&#x27;
                           &#x27;      ConnectionHelp.setConnectParam(taskOption, &#x27;
                           &#x27;conn);\n&#x27;
                           &#x27;      conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + &#x27;
                           &#x27;0 + &quot;-&quot;);\n&#x27;
                           &#x27;      conn.setConnectTimeout(mConnectTimeOut);\n&#x27;
                           &#x27;      conn.connect();\n&#x27;
                           &#x27;      handleConnect(conn);\n&#x27;
                           &#x27;    } catch (IOException e) {\n&#x27;
                           &#x27;      e.printStackTrace();\n&#x27;
                           &#x27;      failDownload(new AriaIOException(TAG,\n&#x27;
                           &#x27;              String.format(&quot;下载失败，filePath: %s, &#x27;
                           &#x27;url: %s&quot;, mEntity.getDownloadPath(), &#x27;
                           &#x27;mEntity.getUrl())),\n&#x27;
                           &#x27;          true);\n&#x27;
                           &#x27;    } finally {\n&#x27;
                           &#x27;      if (conn != null) {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;          conn.getInputStream().close();\n&#x27;
                           &#x27;        } catch (IOException e) {\n&#x27;
                           &#x27;          e.printStackTrace();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        conn.disconnect();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private void handleConnect(HttpURLConnection &#x27;
                           &#x27;conn) throws IOException {\n&#x27;
                           &#x27;    if (taskOption.getRequestEnum() == &#x27;
                           &#x27;RequestEnum.POST) {\n&#x27;
                           &#x27;      Map&lt;String, String&gt; params = &#x27;
                           &#x27;taskOption.getParams();\n&#x27;
                           &#x27;      if (params != null) {\n&#x27;
                           &#x27;        OutputStreamWriter dos = new &#x27;
                           &#x27;OutputStreamWriter(conn.getOutputStream());\n&#x27;
                           &#x27;        Set&lt;String&gt; keys = params.keySet();\n&#x27;
                           &#x27;        StringBuilder sb = new StringBuilder();\n&#x27;
                           &#x27;        for (String key : keys) {\n&#x27;
                           &#x27;          &#x27;
                           &#x27;sb.append(key).append(&quot;=&quot;).append(URLEncoder.encode(params.get(key))).append(&quot;&amp;&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        String url = sb.toString();\n&#x27;
                           &#x27;        url = url.substring(0, url.length() - 1);\n&#x27;
                           &#x27;        dos.write(url);\n&#x27;
                           &#x27;        dos.flush();\n&#x27;
                           &#x27;        dos.close();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    IHttpFileLenAdapter lenAdapter = &#x27;
                           &#x27;taskOption.getFileLenAdapter();\n&#x27;
                           &#x27;    if (lenAdapter == null) {\n&#x27;
                           &#x27;      lenAdapter = new FileLenAdapter();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      ALog.d(TAG, &quot;使用自定义adapter&quot;);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    long len = &#x27;
                           &#x27;lenAdapter.handleFileLen(conn.getHeaderFields());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    if &#x27;
                           &#x27;(!FileUtil.checkMemorySpace(mEntity.getFilePath(), &#x27;
                           &#x27;len)) {\n&#x27;
                           &#x27;      failDownload(new TaskException(TAG,\n&#x27;
                           &#x27;          String.format(&quot;下载失败，内存空间不足；filePath: %s, &#x27;
                           &#x27;url: %s&quot;, mEntity.getDownloadPath(),\n&#x27;
                           &#x27;              mEntity.getUrl())), false);\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    int code = conn.getResponseCode();\n&#x27;
                           &#x27;    boolean end = false;\n&#x27;
                           &#x27;    if (TextUtils.isEmpty(mEntity.getMd5Code())) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      String md5Code = &#x27;
                           &#x27;conn.getHeaderField(&quot;Content-MD5&quot;);\n&#x27;
                           &#x27;      mEntity.setMd5Code(md5Code);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    boolean isChunked = false;\n&#x27;
                           &#x27;    final String str = &#x27;
                           &#x27;conn.getHeaderField(&quot;Transfer-Encoding&quot;);\n&#x27;
                           &#x27;    if (!TextUtils.isEmpty(str) &amp;&amp; &#x27;
                           &#x27;str.equals(&quot;chunked&quot;)) {\n&#x27;
                           &#x27;      isChunked = true;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    Map&lt;String, List&lt;String&gt;&gt; headers = &#x27;
                           &#x27;conn.getHeaderFields();\n&#x27;
                           &#x27;    String disposition = &#x27;
                           &#x27;conn.getHeaderField(&quot;Content-Disposition&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    if (taskOption.isUseServerFileName()) {\n&#x27;
                           &#x27;      if (!TextUtils.isEmpty(disposition)) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mEntity.setDisposition(CommonUtil.encryptBASE64(disposition));\n&#x27;
                           &#x27;        handleContentDisposition(disposition);\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        ALog.w(TAG, &#x27;
                           &#x27;&quot;Content-Disposition对于端字段为空，使用服务器端文件名失败&quot;);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    CookieManager msCookieManager = new &#x27;
                           &#x27;CookieManager();\n&#x27;
                           &#x27;    List&lt;String&gt; cookiesHeader = &#x27;
                           &#x27;headers.get(&quot;Set-Cookie&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    if (cookiesHeader != null) {\n&#x27;
                           &#x27;      for (String cookie : cookiesHeader) {\n&#x27;
                           &#x27;        msCookieManager.getCookieStore().add(null, &#x27;
                           &#x27;HttpCookie.parse(cookie).get(0));\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      &#x27;
                           &#x27;taskOption.setCookieManager(msCookieManager);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    mTaskWrapper.setCode(code);\n&#x27;
                           &#x27;    if (code == HttpURLConnection.HTTP_PARTIAL) {\n&#x27;
                           &#x27;      if (!checkLen(len) &amp;&amp; !isChunked) {\n&#x27;
                           &#x27;        if (len &lt; 0) {\n&#x27;
                           &#x27;          failDownload(\n&#x27;
                           &#x27;              new AriaIOException(TAG, &#x27;
                           &#x27;String.format(&quot;任务下载失败，文件长度小于0， url: %s&quot;, &#x27;
                           &#x27;mEntity.getUrl())),\n&#x27;
                           &#x27;              false);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mEntity.setFileSize(len);\n&#x27;
                           &#x27;      mTaskWrapper.setSupportBP(true);\n&#x27;
                           &#x27;      end = true;\n&#x27;
                           &#x27;    } else if (code == HttpURLConnection.HTTP_OK) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      String contentType = &#x27;
                           &#x27;conn.getHeaderField(&quot;Content-Type&quot;);\n&#x27;
                           &#x27;      if (TextUtils.isEmpty(contentType)) {\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      if (contentType.equals(&quot;text/html&quot;)) {\n&#x27;
                           &#x27;        BufferedReader reader =\n&#x27;
                           &#x27;            new BufferedReader(new &#x27;
                           &#x27;InputStreamReader(ConnectionHelp.convertInputStream(conn)));\n&#x27;
                           &#x27;        StringBuilder sb = new StringBuilder();\n&#x27;
                           &#x27;        String line;\n&#x27;
                           &#x27;        while ((line = reader.readLine()) != null) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;          sb.append(line);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        reader.close();\n&#x27;
                           &#x27;        handleUrlReTurn(conn, &#x27;
                           &#x27;CommonUtil.getWindowReplaceUrl(sb.toString()));\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      } else if (!checkLen(len) &amp;&amp; !isChunked) {\n&#x27;
                           &#x27;        if (len &lt; 0) {\n&#x27;
                           &#x27;          failDownload(\n&#x27;
                           &#x27;              new AriaIOException(TAG, &#x27;
                           &#x27;String.format(&quot;任务下载失败，文件长度小于0， url: %s&quot;, &#x27;
                           &#x27;mEntity.getUrl())),\n&#x27;
                           &#x27;              false);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        ALog.d(TAG, &quot;len &lt; 0&quot;);\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mEntity.setFileSize(len);\n&#x27;
                           &#x27;      mTaskWrapper.setNewTask(true);\n&#x27;
                           &#x27;      mTaskWrapper.setSupportBP(false);\n&#x27;
                           &#x27;      end = true;\n&#x27;
                           &#x27;    } else if (code == &#x27;
                           &#x27;HttpURLConnection.HTTP_NOT_FOUND) {\n&#x27;
                           &#x27;      failDownload(new AriaIOException(TAG,\n&#x27;
                           &#x27;          String.format(&quot;任务下载失败，errorCode：404, &#x27;
                           &#x27;url: %s&quot;, mEntity.getUrl())), true);\n&#x27;
                           &#x27;    } else if (code == &#x27;
                           &#x27;HttpURLConnection.HTTP_MOVED_TEMP\n&#x27;
                           &#x27;        || code == &#x27;
                           &#x27;HttpURLConnection.HTTP_MOVED_PERM\n&#x27;
                           &#x27;        || code == &#x27;
                           &#x27;HttpURLConnection.HTTP_SEE_OTHER\n&#x27;
                           &#x27;        || code == HttpURLConnection.HTTP_CREATED &#x27;
                           &#x27;// 201 跳转\n&#x27;
                           &#x27;        || code == 307) {\n&#x27;
                           &#x27;      handleUrlReTurn(conn, &#x27;
                           &#x27;conn.getHeaderField(&quot;Location&quot;));\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      failDownload(new AriaIOException(TAG,\n&#x27;
                           &#x27;          String.format(&quot;任务下载失败，errorCode：%s, &#x27;
                           &#x27;errorMsg: %s, url: %s&quot;, code,\n&#x27;
                           &#x27;              conn.getResponseMessage(), &#x27;
                           &#x27;mEntity.getUrl())), &#x27;
                           &#x27;!CheckUtil.httpIsBadRequest(code));\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    if (end) {\n&#x27;
                           &#x27;      taskOption.setChunked(isChunked);\n&#x27;
                           &#x27;      if (onFileInfoCallback != null) {\n&#x27;
                           &#x27;        CompleteInfo info = new CompleteInfo(code, &#x27;
                           &#x27;mTaskWrapper);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;onFileInfoCallback.onComplete(mEntity.getUrl(), &#x27;
                           &#x27;info);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mEntity.update();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理&quot;Content-Disposition&quot;参数\n&#x27;
                           &#x27;   * &lt;a &#x27;
                           &#x27;href=https://cloud.tencent.com/developer/section/1189916&gt;Content-Disposition&lt;/a&gt;&lt;/&gt;\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @throws UnsupportedEncodingException\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleContentDisposition(String &#x27;
                           &#x27;disposition) throws UnsupportedEncodingException &#x27;
                           &#x27;{\n&#x27;
                           &#x27;    if (disposition.contains(&quot;;&quot;)) {\n&#x27;
                           &#x27;      String[] infos = disposition.split(&quot;;&quot;);\n&#x27;
                           &#x27;      if (infos[0].equals(&quot;attachment&quot;)) {\n&#x27;
                           &#x27;        for (String info : infos) {\n&#x27;
                           &#x27;          if (info.startsWith(&quot;filename&quot;) &amp;&amp; &#x27;
                           &#x27;info.contains(&quot;=&quot;)) {\n&#x27;
                           &#x27;            String[] temp = info.split(&quot;=&quot;);\n&#x27;
                           &#x27;            if (temp.length &gt; 1) {\n&#x27;
                           &#x27;              String newName = &#x27;
                           &#x27;URLDecoder.decode(temp[1], &#x27;
                           &#x27;&quot;utf-8&quot;).replaceAll(&quot;\\&quot;&quot;, &quot;&quot;);\n&#x27;
                           &#x27;              mEntity.setServerFileName(newName);\n&#x27;
                           &#x27;              renameFile(newName);\n&#x27;
                           &#x27;              break;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      } else if (infos[0].equals(&quot;form-data&quot;) &amp;&amp; &#x27;
                           &#x27;infos.length &gt; 2) {\n&#x27;
                           &#x27;        String[] temp = infos[2].split(&quot;=&quot;);\n&#x27;
                           &#x27;        if (temp.length &gt; 1) {\n&#x27;
                           &#x27;          String newName = &#x27;
                           &#x27;URLDecoder.decode(temp[1], &#x27;
                           &#x27;&quot;utf-8&quot;).replaceAll(&quot;\\&quot;&quot;, &quot;&quot;);\n&#x27;
                           &#x27;          mEntity.setServerFileName(newName);\n&#x27;
                           &#x27;          renameFile(newName);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        ALog.w(TAG, &quot;不识别的Content-Disposition参数&quot;);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 重命名文件\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void renameFile(String newName) {\n&#x27;
                           &#x27;    if (TextUtils.isEmpty(newName)) {\n&#x27;
                           &#x27;      ALog.w(TAG, &quot;重命名失败【服务器返回的文件名为空】&quot;);\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    ALog.d(TAG, String.format(&quot;文件重命名为：%s&quot;, &#x27;
                           &#x27;newName));\n&#x27;
                           &#x27;    File oldFile = new &#x27;
                           &#x27;File(mEntity.getFilePath());\n&#x27;
                           &#x27;    String newPath = oldFile.getParent() + &quot;/&quot; + &#x27;
                           &#x27;newName;\n&#x27;
                           &#x27;    if (oldFile.exists()) {\n&#x27;
                           &#x27;      boolean b = oldFile.renameTo(new &#x27;
                           &#x27;File(newPath));\n&#x27;
                           &#x27;      ALog.d(TAG, String.format(&quot;文件重命名%s&quot;, b ? &#x27;
                           &#x27;&quot;成功&quot; : &quot;失败&quot;));\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    mEntity.setFileName(newName);\n&#x27;
                           &#x27;    mEntity.setFilePath(newPath);\n&#x27;
                           &#x27;    RecordUtil.modifyTaskRecord(oldFile.getPath(), &#x27;
                           &#x27;newPath, mEntity.getTaskType());\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理30x跳转\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleUrlReTurn(HttpURLConnection &#x27;
                           &#x27;conn, String newUrl) throws IOException {\n&#x27;
                           &#x27;    ALog.d(TAG, &quot;30x跳转，新url为【&quot; + newUrl + &quot;】&quot;);\n&#x27;
                           &#x27;    if (TextUtils.isEmpty(newUrl) || &#x27;
                           &#x27;newUrl.equalsIgnoreCase(&quot;null&quot;)) {\n&#x27;
                           &#x27;      if (onFileInfoCallback != null) {\n&#x27;
                           &#x27;        onFileInfoCallback.onFail(mEntity, new &#x27;
                           &#x27;TaskException(TAG, &quot;获取重定向链接失败&quot;), false);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    if (newUrl.startsWith(&quot;/&quot;)) {\n&#x27;
                           &#x27;      Uri uri = Uri.parse(mEntity.getUrl());\n&#x27;
                           &#x27;      newUrl = uri.getHost() + newUrl;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    if (!CheckUtil.checkUrl(newUrl)) {\n&#x27;
                           &#x27;      failDownload(new TaskException(TAG, &#x27;
                           &#x27;&quot;下载失败，重定向url错误&quot;), false);\n&#x27;
                           &#x27;      return;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    taskOption.setRedirectUrl(newUrl);\n&#x27;
                           &#x27;    mEntity.setRedirect(true);\n&#x27;
                           &#x27;    mEntity.setRedirectUrl(newUrl);\n&#x27;
                           &#x27;    String cookies = &#x27;
                           &#x27;conn.getHeaderField(&quot;Set-Cookie&quot;);\n&#x27;
                           &#x27;    conn.disconnect();\n&#x27;
                           &#x27;    URL url = ConnectionHelp.handleUrl(newUrl, &#x27;
                           &#x27;taskOption);\n&#x27;
                           &#x27;    conn = ConnectionHelp.handleConnection(url, &#x27;
                           &#x27;taskOption);\n&#x27;
                           &#x27;    ConnectionHelp.setConnectParam(taskOption, &#x27;
                           &#x27;conn);\n&#x27;
                           &#x27;    conn.setRequestProperty(&quot;Cookie&quot;, cookies);\n&#x27;
                           &#x27;    conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + 0 &#x27;
                           &#x27;+ &quot;-&quot;);\n&#x27;
                           &#x27;    conn.setConnectTimeout(mConnectTimeOut);\n&#x27;
                           &#x27;    conn.connect();\n&#x27;
                           &#x27;    handleConnect(conn);\n&#x27;
                           &#x27;    conn.disconnect();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * &#x27;
                           &#x27;检查长度是否合法，并且检查新获取的文件长度是否和数据库的文件长度一直，如果不一致，则表示该任务为新任务\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param len 从服务器获取的文件长度\n&#x27;
                           &#x27;   * @return {@code true}合法\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private boolean checkLen(long len) {\n&#x27;
                           &#x27;    if (len != mEntity.getFileSize()) {\n&#x27;
                           &#x27;      ALog.d(TAG, &quot;长度不一致，任务为新任务&quot;);\n&#x27;
                           &#x27;      mTaskWrapper.setNewTask(true);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    return true;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private void failDownload(BaseException e, &#x27;
                           &#x27;boolean needRetry) {\n&#x27;
                           &#x27;    if (onFileInfoCallback != null) {\n&#x27;
                           &#x27;      onFileInfoCallback.onFail(mEntity, e, &#x27;
                           &#x27;needRetry);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private static class FileLenAdapter implements &#x27;
                           &#x27;IHttpFileLenAdapter {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override public long &#x27;
                           &#x27;handleFileLen(Map&lt;String, List&lt;String&gt;&gt; headers) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      if (headers == null || headers.isEmpty()) {\n&#x27;
                           &#x27;        ALog.e(TAG, &quot;header为空，获取文件长度失败&quot;);\n&#x27;
                           &#x27;        return -1;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      List&lt;String&gt; sLength = &#x27;
                           &#x27;headers.get(&quot;Content-Length&quot;);\n&#x27;
                           &#x27;      if (sLength == null || sLength.isEmpty()) {\n&#x27;
                           &#x27;        return -1;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      String temp = sLength.get(0);\n&#x27;
                           &#x27;      long len = TextUtils.isEmpty(temp) ? -1 : &#x27;
                           &#x27;Long.parseLong(temp);\n&#x27;
                           &#x27;      // &#x27;
                           &#x27;某些服务，如果设置了conn.setRequestProperty(&quot;Range&quot;, &#x27;
                           &#x27;&quot;bytes=&quot; + 0 + &quot;-&quot;);\n&#x27;
                           &#x27;      // 会返回 Content-Range: bytes &#x27;
                           &#x27;0-225427911/225427913\n&#x27;
                           &#x27;      if (len &lt; 0) {\n&#x27;
                           &#x27;        List&lt;String&gt; sRange = &#x27;
                           &#x27;headers.get(&quot;Content-Range&quot;);\n&#x27;
                           &#x27;        if (sRange == null || sRange.isEmpty()) {\n&#x27;
                           &#x27;          len = -1;\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          int start = temp.indexOf(&quot;/&quot;);\n&#x27;
                           &#x27;          len = &#x27;
                           &#x27;Long.parseLong(temp.substring(start + 1));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      return len;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;}\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        