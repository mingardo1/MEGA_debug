<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>364</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    364
                    <a href="363.html">prev</a>
                    <a href="365.html">next</a>
                    <a href="364_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_999109be2fedd4c8ecb84850737b6444c04b35f6_core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;999109be2fedd4c8ecb84850737b6444c04b35f6:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;999109be2fedd4c8ecb84850737b6444c04b35f6^1:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;999109be2fedd4c8ecb84850737b6444c04b35f6^2:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;622b4b8bf10b2c46c725d2ea85bf82c704d459c0:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b], [b], [b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 package com.dtstack.flink.sql.side;
  21 
  22 import com.dtstack.flink.sql.enums.ECacheType;
  23 import com.dtstack.flink.sql.exec.FlinkSQLExec;
  24 import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  25 import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  26 import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  27 import com.dtstack.flink.sql.util.ClassUtil;
  28 import com.dtstack.flink.sql.util.ParseUtils;
  29 import com.dtstack.flink.sql.util.TableUtils;
  30 import com.google.common.base.Preconditions;
  31 import com.google.common.collect.HashBasedTable;
  32 import com.google.common.collect.Lists;
  33 import com.google.common.collect.Maps;
  34 import com.google.common.collect.Sets;
  35 import org.apache.calcite.sql.*;
  36 import org.apache.calcite.sql.parser.SqlParseException;
  37 import org.apache.commons.collections.CollectionUtils;
  38 import org.apache.commons.lang3.StringUtils;
  39 import org.apache.flink.api.common.typeinfo.TypeInformation;
  40 import org.apache.flink.api.common.typeinfo.Types;
  41 import org.apache.flink.api.java.tuple.Tuple2;
  42 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  43 import org.apache.flink.api.java.typeutils.TupleTypeInfo;
  44 import org.apache.flink.streaming.api.datastream.DataStream;
  45 import org.apache.flink.table.api.EnvironmentSettings;
  46 import org.apache.flink.table.api.Table;
  47 import org.apache.flink.table.api.TableSchema;
  48 import org.apache.flink.table.api.java.StreamTableEnvironment;
  49 import org.apache.flink.table.runtime.typeutils.BaseRowTypeInfo;
  50 import org.apache.flink.table.types.logical.LogicalType;
  51 import org.apache.flink.table.catalog.ObjectIdentifier;
  52 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  53 import org.apache.flink.types.Row;
  54 import org.slf4j.Logger;
  55 import org.slf4j.LoggerFactory;
  56 
  57 import java.time.LocalDateTime;
  58 import java.util.*;
  59 
  60 import static org.apache.calcite.sql.SqlKind.*;
  61 
  62 /**
  63  * Reason:
  64  * Date: 2018/7/24
  65  * Company: www.dtstack.com
  66  *
  67  * @author xuchao
  68  */
  69 
  70 public class SideSqlExec {
  71 
  72     private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  73 
  74     private String localSqlPluginPath = null;
  75 
  76     private String tmpFields = null;
  77 
  78     private String pluginLoadMode = null;
  79 
  80     private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  81 
  82     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  83 
  84     public void exec(String sql,
  85                      Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
  86                      StreamTableEnvironment tableEnv,
  87                      Map&lt;String, Table&gt; tableCache,
  88                      CreateTmpTableParser.SqlParserResult createView,
  89                      String scope) throws Exception {
  90 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
  91 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  92     private String tmpFields = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  93 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  94     private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  95 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  96     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  97 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  98     public void exec(String sql,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  99                      Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 100                      StreamTableEnvironment tableEnv,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 101                      Map&lt;String, Table&gt; tableCache,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 102                      CreateTmpTableParser.SqlParserResult createView,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 103                      String scope) throws Exception {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 104         if(localSqlPluginPath == null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 105             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);</span>
 106 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 107         if (localSqlPluginPath == null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 108             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 109         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 110 </span>
 111 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 112         localTableCache.putAll(tableCache);
 113         try {
 114             sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 115         } catch (Exception e) {
 116             LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 117         }
 118 
 119         if (createView != null) {
 120             LOG.warn(&quot;create view info\n&quot;);
 121             LOG.warn(createView.getExecSql());
 122             LOG.warn(&quot;-----------------&quot;);
 123         }
 124 
 125         SideSQLParser sideSQLParser = new SideSQLParser();
 126         sideSQLParser.setLocalTableCache(localTableCache);
 127         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet(), scope);
 128         Object pollObj = null;
 129 
 130         while ((pollObj = exeQueue.poll()) != null) {
 131 
 132             if (pollObj instanceof SqlNode) {
 133                 SqlNode pollSqlNode = (SqlNode) pollObj;
 134 
 135 
 136                 if (pollSqlNode.getKind() == INSERT) {
 137                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString());
 138                     if (LOG.isInfoEnabled()) {
 139                         LOG.info(&quot;----------real exec sql-----------\n{}&quot;, pollSqlNode.toString());
 140                     }
 141 
 142                 } else if (pollSqlNode.getKind() == AS) {
 143                     dealAsSourceTable(tableEnv, pollSqlNode, tableCache);
 144 
 145                 } else if (pollSqlNode.getKind() == WITH_ITEM) {
 146                     SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 147                     String TableAlias = sqlWithItem.name.toString();
 148                     Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 149                     tableEnv.registerTable(TableAlias, table);
 150 
 151                 } else if (pollSqlNode.getKind() == SELECT) {
<abbr title=" 152                     Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);"> 152                     Preconditions.checkState(createView != null, &quot;select sql must included by create view🔵</abbr>
 153                     Table table = tableEnv.sqlQuery(pollObj.toString());
 154 
 155                     if (createView.getFieldsInfoStr() == null) {
 156                         tableEnv.registerTable(createView.getTableName(), table);
 157                     } else {
 158                         if (checkFieldsInfo(createView, table)) {
 159                             table = table.as(tmpFields);
 160                             tableEnv.registerTable(createView.getTableName(), table);
 161                         } else {
 162                             throw new RuntimeException(&quot;Fields mismatch&quot;);
 163                         }
 164                     }
 165 
 166                     localTableCache.put(createView.getTableName(), table);
 167                 }
 168 
 169             } else if (pollObj instanceof JoinInfo) {
 170                 LOG.info(&quot;----------exec join info----------\n{}&quot;, pollObj.toString());
 171                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv);
 172             }
 173         }
 174 
 175     }
 176 
 177 
 178     /**
 179      * 解析出as查询的表和字段的关系
 180      *
 181      * @param asSqlNode
 182      * @param tableCache
 183      * @return
 184      */
 185     private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache) {
 186         SqlNode info = asSqlNode.getOperands()[0];
 187         SqlNode alias = asSqlNode.getOperands()[1];
 188 
 189         SqlKind infoKind = info.getKind();
 190         if (infoKind != SELECT) {
 191             return null;
 192         }
 193 
 194         List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 195 
 196         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 197         for (FieldInfo fieldInfo : extractFieldList) {
 198             String tableName = fieldInfo.getTable();
 199             String fieldName = fieldInfo.getFieldName();
 200             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 201             mappingTable.put(tableName, fieldName, mappingFieldName);
 202         }
 203 
 204         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 205         replaceInfo.setMappingTable(mappingTable);
 206         replaceInfo.setTargetTableName(alias.toString());
 207         replaceInfo.setTargetTableAlias(alias.toString());
 208         return replaceInfo;
 209     }
 210 
 211 
 212     public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {
 213         SqlKind sqlKind = sqlNode.getKind();
 214         if (sqlKind != AS) {
 215             throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 216         }
 217 
 218         SqlNode info = ((SqlBasicCall) sqlNode).getOperands()[0];
 219         SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 220 
 221         AliasInfo aliasInfo = new AliasInfo();
 222         aliasInfo.setName(info.toString());
 223         aliasInfo.setAlias(alias.toString());
 224 
 225         return aliasInfo;
 226     }
 227 
 228     public BaseRowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo,
 229                                                HashBasedTable&lt;String, String, String&gt; mappingTable) {
 230         // TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 231         LogicalType[] sideOutTypes = new LogicalType[sideJoinFieldInfo.size()];
 232         String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 233         for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 234             FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 235             String tableName = fieldInfo.getTable();
 236             String fieldName = fieldInfo.getFieldName();
 237 
 238             String mappingFieldName = mappingTable.get(tableName, fieldName);
<abbr title=" 239             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;);"> 239             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be f🔵</abbr>
 240 
 241             sideOutTypes[i] = fieldInfo.getLogicalType();
 242             sideOutNames[i] = mappingFieldName;
 243         }
 244         return new BaseRowTypeInfo(sideOutTypes, sideOutNames);
 245     }
 246 
 247 
 248     /**
 249      * 对时间类型进行类型转换
 250      *
 251      * @param leftTypeInfo
 252      * @return
 253      */
 254     private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 255         TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 256         TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 257         for (int i = 0; i &lt; sideOutTypes.length; i++) {
 258             sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 259         }
 260         RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 261         return rowTypeInfo;
 262     }
 263 
 264     private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 265         if (typeInformation instanceof TimeIndicatorTypeInfo) {
 266             return TypeInformation.of(LocalDateTime.class);
 267         }
 268         return typeInformation;
 269     }
 270 
 271 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
 272 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 273         return rowTypeInfo;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 274     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 275 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 276     private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 277         if (typeInformation instanceof TimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 278             return TypeInformation.of(LocalDateTime.class);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 279         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 280         return typeInformation;</span>
 281 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 282 </span>
 283 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 284     public void setLocalSqlPluginPath(String localSqlPluginPath) {
 285         this.localSqlPluginPath = localSqlPluginPath;
 286     }
 287 
 288 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 289     public void setPluginLoadMode(String pluginLoadMode) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 290         this.pluginLoadMode = pluginLoadMode;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 291     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 292 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 293     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){"> 293     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableNa🔵</abbr></span>
 294 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 295             return TypeInformation.of(LocalDateTime.class);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 296         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 297         return typeInformation;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 298     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 299 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 300 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 301 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 302 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 303 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 304 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 305     public void setLocalSqlPluginPath(String localSqlPluginPath) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 306         this.localSqlPluginPath = localSqlPluginPath;</span>
 307 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 308     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName) {"> 308     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableNa🔵</abbr></span>
 309 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 310         Table table = localTableCache.get(tableAlias);
 311         if (table == null) {
 312             table = localTableCache.get(tableName);
 313         }
 314 
 315         if (table == null) {
 316             throw new RuntimeException(&quot;not register table &quot; + tableAlias);
 317         }
 318 
 319         return table;
 320     }
 321 
 322 
 323     /**
<abbr title=" 324      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 324      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., d🔵</abbr>
 325      *
 326      * @return
 327      */
<abbr title=" 328     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 328     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInf🔵</abbr>
 329         List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 330         if (CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))) {
 331             return true;
 332         }
 333         return false;
 334     }
 335 
 336     private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 337         List&lt;String&gt; res = Lists.newArrayList();
 338         sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 339             res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 340         });
 341         return res;
 342     }
 343 
<abbr title=" 344     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo) {"> 344     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTa🔵</abbr>
 345         List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 346         ParseUtils.parseAnd(conditionNode, sqlNodeList);
 347         List&lt;String&gt; conditionFields = Lists.newArrayList();
 348         for (SqlNode sqlNode : sqlNodeList) {
 349             if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 350                 throw new RuntimeException(&quot;not compare operator.&quot;);
 351             }
 352 
 353             SqlIdentifier left = (SqlIdentifier) ((SqlBasicCall) sqlNode).getOperands()[0];
 354             SqlIdentifier right = (SqlIdentifier) ((SqlBasicCall) sqlNode).getOperands()[1];
 355 
 356             String leftTableName = left.getComponent(0).getSimple();
 357             String rightTableName = right.getComponent(0).getSimple();
 358 
 359             String tableCol = &quot;&quot;;
 360             if (leftTableName.equalsIgnoreCase(specifyTableName)) {
 361                 tableCol = left.getComponent(1).getSimple();
 362             } else if (rightTableName.equalsIgnoreCase(specifyTableName)) {
 363                 tableCol = right.getComponent(1).getSimple();
 364             } else {
<abbr title=" 365                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 365                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specify🔵</abbr>
 366             }
 367             tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 368             conditionFields.add(tableCol);
 369         }
 370 
 371         return conditionFields;
 372     }
 373 
 374     protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 375                                      SqlNode pollSqlNode,
 376                                      Map&lt;String, Table&gt; tableCache) throws SqlParseException {
 377 
 378         AliasInfo aliasInfo = parseASNode(pollSqlNode);
 379         if (localTableCache.containsKey(aliasInfo.getName())) {
 380             return;
 381         }
 382 
 383         Table table = tableEnv.sqlQuery(aliasInfo.getName());
 384         tableEnv.registerTable(aliasInfo.getAlias(), table);
 385         localTableCache.put(aliasInfo.getAlias(), table);
 386 
 387         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 388 
 389         FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 390         if (fieldReplaceInfo == null) {
 391             return;
 392         }
 393 
 394         //as 的源表
 395         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 396         SqlNode fromNode = ((SqlBasicCall) pollSqlNode).getOperands()[0];
 397         TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 398 
 399     }
 400 
 401     private void joinFun(Object pollObj,
 402                          Map&lt;String, Table&gt; localTableCache,
 403                          Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
 404                          StreamTableEnvironment tableEnv) throws Exception {
 405         JoinInfo joinInfo = (JoinInfo) pollObj;
 406 
 407         JoinScope joinScope = new JoinScope();
 408         JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 409         leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 410         leftScopeChild.setTableName(joinInfo.getLeftTableName());
 411 
<abbr title=" 412         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 412         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLe🔵</abbr>
 413 
<abbr title=" 414         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSchema().getFieldNames());"> 414         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSc🔵</abbr>
 415 
 416         int length = leftTable.getSchema().getFieldDataTypes().length;
 417         LogicalType[] logicalTypes = new LogicalType[length];
 418         for(int i=0; i&lt;length; i++){
 419             logicalTypes[i] = leftTable.getSchema().getFieldDataTypes()[i].getLogicalType();
 420         }
 421 
<abbr title=" 422         BaseRowTypeInfo leftBaseTypeInfo = new BaseRowTypeInfo(logicalTypes, leftTable.getSchema().getFieldNames());"> 422         BaseRowTypeInfo leftBaseTypeInfo = new BaseRowTypeInfo(logicalTypes, leftTable.getSchema().getFie🔵</abbr>
 423 
 424         leftScopeChild.setRowTypeInfo(leftTypeInfo);
 425         leftScopeChild.setBaseRowTypeInfo(leftBaseTypeInfo);
 426 
 427         JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 428         rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 429         rightScopeChild.setTableName(joinInfo.getRightTableName());
 430         AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 431         if (sideTableInfo == null) {
 432             sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 433         }
 434 
 435         if (sideTableInfo == null) {
 436             throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 437         }
 438 
 439         rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 440         rightScopeChild.setBaseRowTypeInfo(sideTableInfo.getBaseRowTypeInfo());
 441 
 442         joinScope.addScope(leftScopeChild);
 443         joinScope.addScope(rightScopeChild);
 444 
 445         HashBasedTable&lt;String, String, String&gt; mappingTable = ((JoinInfo) pollObj).getTableFieldRef();
 446 
 447         //获取两个表的所有字段
<abbr title=" 448         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 448         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), join🔵</abbr>
 449         //通过join的查询字段信息过滤出需要的字段信息
<abbr title=" 450         sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getFieldName()) == null);"> 450         sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo🔵</abbr>
 451 
 452         String leftTableAlias = joinInfo.getLeftTableAlias();
 453         Table targetTable = localTableCache.get(leftTableAlias);
 454         if (targetTable == null) {
 455             targetTable = localTableCache.get(joinInfo.getLeftTableName());
 456         }
 457 
<abbr title=" 458         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSchema().getFieldNames());"> 458         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSc🔵</abbr>
 459 
 460         DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; adaptStream = tableEnv.toRetractStream(targetTable, Row.class);
 461 
 462         //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 463         if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 464             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 464             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTa🔵</abbr>
 465             List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 466             int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 467             adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 467             adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, ta🔵</abbr>
 468         }
 469 
 470         DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; dsOut = null;
 471 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 472         if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 473             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo, pluginLoadMode);"> 473             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), 🔵</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 474         }else{</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 475             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo, pluginLoadMode);"> 475             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSq🔵</abbr></span>
 476 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 477         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 478 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 479         DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; dsOut = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 480         if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){</span>
 481 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 482         if (ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 483             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 483             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), 🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 484         } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 485             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 485             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSq🔵</abbr></span>
 486 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 487         }
 488 
 489         BaseRowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 490 
 491         TupleTypeInfo tupleTypeInfo = new TupleTypeInfo(Types.BOOLEAN, sideOutTypeInfo);
 492         dsOut.getTransformation().setOutputType(tupleTypeInfo);
 493 
 494         String targetTableName = joinInfo.getNewTableName();
 495         String targetTableAlias = joinInfo.getNewTableAlias();
 496 
 497         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 498         replaceInfo.setMappingTable(mappingTable);
 499         replaceInfo.setTargetTableName(targetTableName);
 500         replaceInfo.setTargetTableAlias(targetTableAlias);
 501 
 502         ObjectIdentifier objectIdentifier = ObjectIdentifier.of(
 503                 EnvironmentSettings.DEFAULT_BUILTIN_CATALOG,
 504                 EnvironmentSettings.DEFAULT_BUILTIN_DATABASE,
 505                 targetTableName);
<abbr title=" 506         boolean tableExists = tableEnv.getCatalog(EnvironmentSettings.DEFAULT_BUILTIN_CATALOG).get().tableExists(objectIdentifier.toObjectPath());"> 506         boolean tableExists = tableEnv.getCatalog(EnvironmentSettings.DEFAULT_BUILTIN_CATALOG).get().tabl🔵</abbr>
 507 
 508         if (!tableExists) {
 509             Table joinTable = tableEnv.fromDataStream(dsOut);
 510             tableEnv.createTemporaryView(targetTableName, joinTable);
 511             localTableCache.put(joinInfo.getNewTableName(), joinTable);
 512         }
 513     }
 514 
 515     private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 516         String[] fieldNames = schema.getFieldNames();
 517         TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 518 
<abbr title=" 519         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);"> 519         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::ne🔵</abbr>
<abbr title=" 520         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 520         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(Typ🔵</abbr>
 521         return new RowTypeInfo(projectedTypes, projectedNames);
 522     }
 523 
 524 
 525     private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 526         List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 527         String fieldsInfo = result.getFieldsInfoStr();
 528         String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 529         for (int i = 0; i &lt; fields.length; i++) {
 530             String[] filed = fields[i].split(&quot;\\s&quot;);
 531             if (filed.length &lt; 2 || fields.length != table.getSchema().getFieldCount()) {
 532                 return false;
 533             } else {
 534                 String[] filedNameArr = new String[filed.length - 1];
 535                 System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 536                 String fieldName = String.join(&quot; &quot;, filedNameArr);
 537                 fieldNames.add(fieldName);
 538                 String fieldType = filed[filed.length - 1].trim();
 539                 Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 540                 Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 541                 if (fieldClass == tableField) {
 542                     continue;
 543                 } else {
 544                     return false;
 545                 }
 546             }
 547         }
 548         tmpFields = String.join(&quot;,&quot;, fieldNames);
 549         return true;
 550     }
 551 
 552 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.side;
  22 
  23 import com.dtstack.flink.sql.enums.ECacheType;
  24 import com.dtstack.flink.sql.exec.FlinkSQLExec;
  25 import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  26 import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  27 import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  28 import com.dtstack.flink.sql.util.ClassUtil;
  29 import com.dtstack.flink.sql.util.ParseUtils;
  30 import com.dtstack.flink.sql.util.TableUtils;
  31 import com.google.common.base.Preconditions;
  32 import com.google.common.collect.HashBasedTable;
  33 import com.google.common.collect.Lists;
  34 import com.google.common.collect.Maps;
  35 import com.google.common.collect.Sets;
  36 import org.apache.calcite.sql.*;
  37 import org.apache.calcite.sql.parser.SqlParseException;
  38 import org.apache.commons.collections.CollectionUtils;
  39 import org.apache.commons.lang3.StringUtils;
  40 import org.apache.flink.api.common.typeinfo.TypeInformation;
  41 import org.apache.flink.api.common.typeinfo.Types;
  42 import org.apache.flink.api.java.tuple.Tuple2;
  43 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  44 import org.apache.flink.api.java.typeutils.TupleTypeInfo;
  45 import org.apache.flink.streaming.api.datastream.DataStream;
  46 import org.apache.flink.table.api.EnvironmentSettings;
  47 import org.apache.flink.table.api.Table;
  48 import org.apache.flink.table.api.TableSchema;
  49 import org.apache.flink.table.api.java.StreamTableEnvironment;
  50 import org.apache.flink.table.runtime.typeutils.BaseRowTypeInfo;
  51 import org.apache.flink.table.types.logical.LogicalType;
  52 import org.apache.flink.table.catalog.ObjectIdentifier;
  53 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  54 import org.apache.flink.types.Row;
  55 import org.slf4j.Logger;
  56 import org.slf4j.LoggerFactory;
  57 
  58 import java.time.LocalDateTime;
  59 import java.util.*;
  60 
  61 import static org.apache.calcite.sql.SqlKind.*;
  62 
  63 /**
  64  * Reason:
  65  * Date: 2018/7/24
  66  * Company: www.dtstack.com
  67  *
  68  * @author xuchao
  69  */
  70 
  71 public class SideSqlExec {
  72 
  73     private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  74 
  75     private String localSqlPluginPath = null;
  76 
  77     private String tmpFields = null;
  78 
  79     private String pluginLoadMode = null;
  80 
  81     private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  82 
  83     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  84 
  85     public void exec(String sql,
  86                      Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
  87                      StreamTableEnvironment tableEnv,
  88                      Map&lt;String, Table&gt; tableCache,
  89                      CreateTmpTableParser.SqlParserResult createView,
  90                      String scope) throws Exception {
  91         localTableCache.putAll(tableCache);
  92         try {
  93             sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
  94         } catch (Exception e) {
  95             LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
  96         }
  97 
  98         if(createView != null){
  99             LOG.warn(&quot;create view info\n&quot;);
 100             LOG.warn(createView.getExecSql());
 101             LOG.warn(&quot;-----------------&quot;);
 102         }
 103 
 104         SideSQLParser sideSQLParser = new SideSQLParser();
 105         sideSQLParser.setLocalTableCache(localTableCache);
 106         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet(), scope);
 107         Object pollObj = null;
 108 
 109         while((pollObj = exeQueue.poll()) != null){
 110 
 111             if(pollObj instanceof SqlNode){
 112                 SqlNode pollSqlNode = (SqlNode) pollObj;
 113 
 114 
 115                 if(pollSqlNode.getKind() == INSERT){
 116                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString());
 117                     if(LOG.isInfoEnabled()){
 118                         LOG.info(&quot;----------real exec sql-----------\n{}&quot;, pollSqlNode.toString());
 119                     }
 120 
 121                 }else if(pollSqlNode.getKind() == AS){
 122                     dealAsSourceTable(tableEnv, pollSqlNode, tableCache);
 123 
 124                 } else if (pollSqlNode.getKind() == WITH_ITEM) {
 125                     SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 126                     String TableAlias = sqlWithItem.name.toString();
 127                     Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 128                     tableEnv.registerTable(TableAlias, table);
 129 
 130                 } else if (pollSqlNode.getKind() == SELECT){
<abbr title=" 131                     Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);"> 131                     Preconditions.checkState(createView != null, &quot;select sql must included by create view🔵</abbr>
 132                     Table table = tableEnv.sqlQuery(pollObj.toString());
 133 
 134                     if (createView.getFieldsInfoStr() == null){
 135                         tableEnv.registerTable(createView.getTableName(), table);
 136                     } else {
 137                         if (checkFieldsInfo(createView, table)){
 138                             table = table.as(tmpFields);
 139                             tableEnv.registerTable(createView.getTableName(), table);
 140                         } else {
 141                             throw new RuntimeException(&quot;Fields mismatch&quot;);
 142                         }
 143                     }
 144 
 145                     localTableCache.put(createView.getTableName(), table);
 146                 }
 147 
 148             }else if (pollObj instanceof JoinInfo){
 149                 LOG.info(&quot;----------exec join info----------\n{}&quot;, pollObj.toString());
 150                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv);
 151             }
 152         }
 153 
 154     }
 155 
 156 
 157     /**
 158      * 解析出as查询的表和字段的关系
 159      *
 160      * @param asSqlNode
 161      * @param tableCache
 162      * @return
 163      */
 164     private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 165         SqlNode info = asSqlNode.getOperands()[0];
 166         SqlNode alias = asSqlNode.getOperands()[1];
 167 
 168         SqlKind infoKind = info.getKind();
 169         if(infoKind != SELECT){
 170             return null;
 171         }
 172 
 173         List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 174 
 175         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 176         for (FieldInfo fieldInfo : extractFieldList) {
 177             String tableName = fieldInfo.getTable();
 178             String fieldName = fieldInfo.getFieldName();
 179             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 180             mappingTable.put(tableName, fieldName, mappingFieldName);
 181         }
 182 
 183         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 184         replaceInfo.setMappingTable(mappingTable);
 185         replaceInfo.setTargetTableName(alias.toString());
 186         replaceInfo.setTargetTableAlias(alias.toString());
 187         return replaceInfo;
 188     }
 189 
 190 
 191     public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {
 192         SqlKind sqlKind = sqlNode.getKind();
 193         if(sqlKind != AS){
 194             throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 195         }
 196 
 197         SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 198         SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 199 
 200         AliasInfo aliasInfo = new AliasInfo();
 201         aliasInfo.setName(info.toString());
 202         aliasInfo.setAlias(alias.toString());
 203 
 204         return aliasInfo;
 205     }
 206 
 207     public BaseRowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo,
 208                                            HashBasedTable&lt;String, String, String&gt; mappingTable) {
 209         // TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 210         LogicalType[] sideOutTypes = new LogicalType[sideJoinFieldInfo.size()];
 211         String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 212         for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 213             FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 214             String tableName = fieldInfo.getTable();
 215             String fieldName = fieldInfo.getFieldName();
 216 
 217             String mappingFieldName = mappingTable.get(tableName, fieldName);
<abbr title=" 218             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;);"> 218             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be f🔵</abbr>
 219 
 220             sideOutTypes[i] = fieldInfo.getLogicalType();
 221             sideOutNames[i] = mappingFieldName;
 222         }
 223         return new BaseRowTypeInfo(sideOutTypes, sideOutNames);
 224     }
 225 
 226 
 227     /**
 228      * 对时间类型进行类型转换
 229      *
 230      * @param leftTypeInfo
 231      * @return
 232      */
 233     private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 234         TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 235         TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 236         for (int i = 0; i &lt; sideOutTypes.length; i++) {
 237             sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 238         }
 239         RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 240         return rowTypeInfo;
 241     }
 242 
 243     private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 244         if (typeInformation instanceof TimeIndicatorTypeInfo) {
 245             return TypeInformation.of(LocalDateTime.class);
 246         }
 247         return typeInformation;
 248     }
 249 
 250     public void setLocalSqlPluginPath(String localSqlPluginPath) {
 251         this.localSqlPluginPath = localSqlPluginPath;
 252     }
 253 
 254     public void setPluginLoadMode(String pluginLoadMode) {
 255         this.pluginLoadMode = pluginLoadMode;
 256     }
 257 
<abbr title=" 258     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){"> 258     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableNa🔵</abbr>
 259         Table table = localTableCache.get(tableAlias);
 260         if(table == null){
 261             table = localTableCache.get(tableName);
 262         }
 263 
 264         if(table == null){
 265             throw new RuntimeException(&quot;not register table &quot; + tableAlias);
 266         }
 267 
 268         return table;
 269     }
 270 
 271 
 272     /**
<abbr title=" 273      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 273      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., d🔵</abbr>
 274      *
 275      * @return
 276      */
<abbr title=" 277     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 277     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInf🔵</abbr>
 278         List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 279         if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 280             return true;
 281         }
 282         return false;
 283     }
 284 
 285     private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 286         List&lt;String&gt; res = Lists.newArrayList();
 287         sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 288             res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 289         });
 290         return res;
 291     }
 292 
<abbr title=" 293     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 293     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTa🔵</abbr>
 294         List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 295         ParseUtils.parseAnd(conditionNode, sqlNodeList);
 296         List&lt;String&gt; conditionFields = Lists.newArrayList();
 297         for(SqlNode sqlNode : sqlNodeList){
 298             if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 299                 throw new RuntimeException(&quot;not compare operator.&quot;);
 300             }
 301 
 302             SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 303             SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 304 
 305             String leftTableName = left.getComponent(0).getSimple();
 306             String rightTableName = right.getComponent(0).getSimple();
 307 
 308             String tableCol = &quot;&quot;;
 309             if(leftTableName.equalsIgnoreCase(specifyTableName)){
 310                 tableCol = left.getComponent(1).getSimple();
 311             }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 312                 tableCol = right.getComponent(1).getSimple();
 313             }else{
<abbr title=" 314                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 314                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specify🔵</abbr>
 315             }
 316             tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 317             conditionFields.add(tableCol);
 318         }
 319 
 320         return conditionFields;
 321     }
 322 
 323     protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 324                                      SqlNode pollSqlNode,
 325                                      Map&lt;String, Table&gt; tableCache) throws SqlParseException {
 326 
 327         AliasInfo aliasInfo = parseASNode(pollSqlNode);
 328         if (localTableCache.containsKey(aliasInfo.getName())) {
 329             return;
 330         }
 331 
 332         Table table = tableEnv.sqlQuery(aliasInfo.getName());
 333         tableEnv.registerTable(aliasInfo.getAlias(), table);
 334         localTableCache.put(aliasInfo.getAlias(), table);
 335 
 336         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 337 
 338         FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 339         if(fieldReplaceInfo == null){
 340            return;
 341         }
 342 
 343         //as 的源表
 344         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 345         SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];
 346         TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 347 
 348     }
 349 
 350     private void joinFun(Object pollObj,
 351                          Map&lt;String, Table&gt; localTableCache,
 352                          Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
 353                          StreamTableEnvironment tableEnv) throws Exception{
 354         JoinInfo joinInfo = (JoinInfo) pollObj;
 355 
 356         JoinScope joinScope = new JoinScope();
 357         JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 358         leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 359         leftScopeChild.setTableName(joinInfo.getLeftTableName());
 360 
<abbr title=" 361         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 361         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLe🔵</abbr>
 362 
<abbr title=" 363         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSchema().getFieldNames());"> 363         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSc🔵</abbr>
 364 
 365         int length = leftTable.getSchema().getFieldDataTypes().length;
 366         LogicalType[] logicalTypes = new LogicalType[length];
 367         for(int i=0; i&lt;length; i++){
 368             logicalTypes[i] = leftTable.getSchema().getFieldDataTypes()[i].getLogicalType();
 369         }
 370 
<abbr title=" 371         BaseRowTypeInfo leftBaseTypeInfo = new BaseRowTypeInfo(logicalTypes, leftTable.getSchema().getFieldNames());"> 371         BaseRowTypeInfo leftBaseTypeInfo = new BaseRowTypeInfo(logicalTypes, leftTable.getSchema().getFie🔵</abbr>
 372 
 373         leftScopeChild.setRowTypeInfo(leftTypeInfo);
 374         leftScopeChild.setBaseRowTypeInfo(leftBaseTypeInfo);
 375 
 376         JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 377         rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 378         rightScopeChild.setTableName(joinInfo.getRightTableName());
 379         AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 380         if(sideTableInfo == null){
 381             sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 382         }
 383 
 384         if(sideTableInfo == null){
 385             throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 386         }
 387 
 388         rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 389         rightScopeChild.setBaseRowTypeInfo(sideTableInfo.getBaseRowTypeInfo());
 390 
 391         joinScope.addScope(leftScopeChild);
 392         joinScope.addScope(rightScopeChild);
 393 
 394         HashBasedTable&lt;String, String, String&gt; mappingTable = ((JoinInfo) pollObj).getTableFieldRef();
 395 
 396         //获取两个表的所有字段
<abbr title=" 397         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 397         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), join🔵</abbr>
 398         //通过join的查询字段信息过滤出需要的字段信息
<abbr title=" 399         sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getFieldName()) == null);"> 399         sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo🔵</abbr>
 400 
 401         String leftTableAlias = joinInfo.getLeftTableAlias();
 402         Table targetTable = localTableCache.get(leftTableAlias);
 403         if(targetTable == null){
 404             targetTable = localTableCache.get(joinInfo.getLeftTableName());
 405         }
 406 
<abbr title=" 407         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSchema().getFieldNames());"> 407         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSc🔵</abbr>
 408 
 409         DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; adaptStream = tableEnv.toRetractStream(targetTable, Row.class);
 410 
 411         //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 412         if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 413             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 413             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTa🔵</abbr>
 414             List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 415             int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 416             adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 416             adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, ta🔵</abbr>
 417         }
 418 
 419         DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; dsOut = null;
 420         if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title=" 421             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo, pluginLoadMode);"> 421             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), 🔵</abbr>
 422         }else{
<abbr title=" 423             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo, pluginLoadMode);"> 423             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSq🔵</abbr>
 424         }
 425 
 426         BaseRowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 427 
 428         TupleTypeInfo tupleTypeInfo = new TupleTypeInfo(Types.BOOLEAN, sideOutTypeInfo);
 429         dsOut.getTransformation().setOutputType(tupleTypeInfo);
 430 
 431         String targetTableName = joinInfo.getNewTableName();
 432         String targetTableAlias = joinInfo.getNewTableAlias();
 433 
 434         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 435         replaceInfo.setMappingTable(mappingTable);
 436         replaceInfo.setTargetTableName(targetTableName);
 437         replaceInfo.setTargetTableAlias(targetTableAlias);
 438 
 439         ObjectIdentifier objectIdentifier = ObjectIdentifier.of(
 440                 EnvironmentSettings.DEFAULT_BUILTIN_CATALOG,
 441                 EnvironmentSettings.DEFAULT_BUILTIN_DATABASE,
 442                 targetTableName);
<abbr title=" 443         boolean tableExists = tableEnv.getCatalog(EnvironmentSettings.DEFAULT_BUILTIN_CATALOG).get().tableExists(objectIdentifier.toObjectPath());"> 443         boolean tableExists = tableEnv.getCatalog(EnvironmentSettings.DEFAULT_BUILTIN_CATALOG).get().tabl🔵</abbr>
 444 
 445         if (!tableExists){
 446             Table joinTable = tableEnv.fromDataStream(dsOut);
 447             tableEnv.createTemporaryView(targetTableName, joinTable);
 448             localTableCache.put(joinInfo.getNewTableName(), joinTable);
 449         }
 450     }
 451 
 452     private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 453         String[] fieldNames = schema.getFieldNames();
 454         TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 455 
<abbr title=" 456         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);"> 456         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::ne🔵</abbr>
<abbr title=" 457         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 457         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(Typ🔵</abbr>
 458         return new RowTypeInfo(projectedTypes, projectedNames);
 459     }
 460 
 461 
 462     private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 463         List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 464         String fieldsInfo = result.getFieldsInfoStr();
 465         String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 466         for (int i = 0; i &lt; fields.length; i++) {
 467             String[] filed = fields[i].split(&quot;\\s&quot;);
 468             if (filed.length &lt; 2 || fields.length != table.getSchema().getFieldCount()){
 469                 return false;
 470             } else {
 471                 String[] filedNameArr = new String[filed.length - 1];
 472                 System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 473                 String fieldName = String.join(&quot; &quot;, filedNameArr);
 474                 fieldNames.add(fieldName);
 475                 String fieldType = filed[filed.length - 1 ].trim();
 476                 Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 477                 Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 478                 if (fieldClass == tableField){
 479                     continue;
 480                 } else {
 481                     return false;
 482                 }
 483             }
 484         }
 485         tmpFields = String.join(&quot;,&quot;, fieldNames);
 486         return true;
 487     }
 488 
 489 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side;
  19 
  20 import com.dtstack.flink.sql.enums.ECacheType;
  21 import com.dtstack.flink.sql.exec.FlinkSQLExec;
  22 import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  23 import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  24 import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  25 import com.dtstack.flink.sql.util.ClassUtil;
  26 import com.dtstack.flink.sql.util.ParseUtils;
  27 import com.dtstack.flink.sql.util.TableUtils;
  28 import com.google.common.base.Preconditions;
  29 import com.google.common.collect.HashBasedTable;
  30 import com.google.common.collect.Lists;
  31 import com.google.common.collect.Maps;
  32 import com.google.common.collect.Sets;
  33 import java.time.LocalDateTime;
  34 import java.util.*;
  35 import org.apache.calcite.sql.*;
  36 import org.apache.calcite.sql.parser.SqlParseException;
  37 import org.apache.commons.collections.CollectionUtils;
  38 import org.apache.commons.lang3.StringUtils;
  39 import org.apache.flink.api.common.typeinfo.TypeInformation;
  40 import org.apache.flink.api.common.typeinfo.Types;
  41 import org.apache.flink.api.java.tuple.Tuple2;
  42 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  43 import org.apache.flink.api.java.typeutils.TupleTypeInfo;
  44 import org.apache.flink.streaming.api.datastream.DataStream;
  45 import org.apache.flink.table.api.EnvironmentSettings;
  46 import org.apache.flink.table.api.Table;
  47 import org.apache.flink.table.api.TableSchema;
  48 import org.apache.flink.table.api.java.StreamTableEnvironment;
  49 import org.apache.flink.table.catalog.ObjectIdentifier;
  50 import org.apache.flink.table.runtime.typeutils.BaseRowTypeInfo;
  51 import org.apache.flink.table.types.logical.LogicalType;
  52 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  53 import org.apache.flink.types.Row;
  54 import org.slf4j.Logger;
  55 import org.slf4j.LoggerFactory;
  56 import static org.apache.calcite.sql.SqlKind.*;
  57 
  58 
  59 /**
  60  * Reason:
  61  * Date: 2018/7/24
  62  * Company: www.dtstack.com
  63  * @author xuchao
  64  */
  65 public class SideSqlExec {
  66     private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  67 
  68     private String localSqlPluginPath = null;
  69 
  70     private String tmpFields = null;
  71 
  72     private String pluginLoadMode = null;
  73 
  74     private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  75 
  76     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  77 
<abbr title="  78     public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv, Map&lt;String, Table&gt; tableCache, CreateTmpTableParser.SqlParserResult createView, String scope) throws Exception {">  78     public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment 🔵</abbr>
  79         localTableCache.putAll(tableCache);
  80         try {
  81             sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
  82         } catch (java.lang.Exception e) {
  83             LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
  84         }
  85         if (createView != null) {
  86             LOG.warn(&quot;create view info\n&quot;);
  87             LOG.warn(createView.getExecSql());
  88             LOG.warn(&quot;-----------------&quot;);
  89         }
  90         SideSQLParser sideSQLParser = new SideSQLParser();
  91         sideSQLParser.setLocalTableCache(localTableCache);
  92         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet(), scope);
  93         Object pollObj = null;
  94         while ((pollObj = exeQueue.poll()) != null) {
  95             if (pollObj instanceof SqlNode) {
  96                 SqlNode pollSqlNode = ((SqlNode) (pollObj));
  97                 if (pollSqlNode.getKind() == INSERT) {
  98                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString());
  99                     if (LOG.isInfoEnabled()) {
 100                         LOG.info(&quot;----------real exec sql-----------\n{}&quot;, pollSqlNode.toString());
 101                     }
 102                 } else if (pollSqlNode.getKind() == AS) {
 103                     dealAsSourceTable(tableEnv, pollSqlNode, tableCache);
 104                 } else if (pollSqlNode.getKind() == WITH_ITEM) {
 105                     SqlWithItem sqlWithItem = ((SqlWithItem) (pollSqlNode));
 106                     String TableAlias = sqlWithItem.name.toString();
 107                     Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 108                     tableEnv.registerTable(TableAlias, table);
 109                 } else if (pollSqlNode.getKind() == SELECT) {
<abbr title=" 110                     Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);"> 110                     Preconditions.checkState(createView != null, &quot;select sql must included by create view🔵</abbr>
 111                     Table table = tableEnv.sqlQuery(pollObj.toString());
 112                     if (createView.getFieldsInfoStr() == null) {
 113                         tableEnv.registerTable(createView.getTableName(), table);
 114                     } else if (checkFieldsInfo(createView, table)) {
 115                         table = table.as(tmpFields);
 116                         tableEnv.registerTable(createView.getTableName(), table);
 117                     } else {
 118                         throw new RuntimeException(&quot;Fields mismatch&quot;);
 119                     }
 120                     localTableCache.put(createView.getTableName(), table);
 121                 }
 122             } else if (pollObj instanceof JoinInfo) {
 123                 LOG.info(&quot;----------exec join info----------\n{}&quot;, pollObj.toString());
 124                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv);
 125             }
 126         }
 127     }
 128 
 129     /**
 130      * 解析出as查询的表和字段的关系
 131      * @param asSqlNode
 132      * @param tableCache
 133      * @return
 134      */
 135     private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache) {
 136         SqlNode info = asSqlNode.getOperands()[0];
 137         SqlNode alias = asSqlNode.getOperands()[1];
 138         SqlKind infoKind = info.getKind();
 139         if (infoKind != SELECT) {
 140             return null;
 141         }
<abbr title=" 142         List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField(((SqlSelect) (info)), tableCache);"> 142         List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField(((SqlSelect) (info)), tableCache)🔵</abbr>
 143         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 144         for (FieldInfo fieldInfo : extractFieldList) {
 145             String tableName = fieldInfo.getTable();
 146             String fieldName = fieldInfo.getFieldName();
 147             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 148             mappingTable.put(tableName, fieldName, mappingFieldName);
 149         }
 150         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 151         replaceInfo.setMappingTable(mappingTable);
 152         replaceInfo.setTargetTableName(alias.toString());
 153         replaceInfo.setTargetTableAlias(alias.toString());
 154         return replaceInfo;
 155     }
 156 
 157     public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {
 158         SqlKind sqlKind = sqlNode.getKind();
 159         if (sqlKind != AS) {
 160             throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 161         }
 162         SqlNode info = ((SqlBasicCall) (sqlNode)).getOperands()[0];
 163         SqlNode alias = ((SqlBasicCall) (sqlNode)).getOperands()[1];
 164         AliasInfo aliasInfo = new AliasInfo();
 165         aliasInfo.setName(info.toString());
 166         aliasInfo.setAlias(alias.toString());
 167         return aliasInfo;
 168     }
 169 
<abbr title=" 170     public BaseRowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 170     public BaseRowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, 🔵</abbr>
 171         // TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 172         LogicalType[] sideOutTypes = new LogicalType[sideJoinFieldInfo.size()];
 173         String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 174         for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 175             FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 176             String tableName = fieldInfo.getTable();
 177             String fieldName = fieldInfo.getFieldName();
 178             String mappingFieldName = mappingTable.get(tableName, fieldName);
<abbr title=" 179             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;);"> 179             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be f🔵</abbr>
 180             sideOutTypes[i] = fieldInfo.getLogicalType();
 181             sideOutNames[i] = mappingFieldName;
 182         }
 183         return new BaseRowTypeInfo(sideOutTypes, sideOutNames);
 184     }
 185 
 186     /**
 187      *  对时间类型进行类型转换
 188      * @param leftTypeInfo
 189      * @return
 190      */
 191     private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 192         TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 193         TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 194         for (int i = 0; i &lt; sideOutTypes.length; i++) {
 195             sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 196         }
 197         RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 198         return rowTypeInfo;
 199     }
 200 
 201     private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 202         if (typeInformation instanceof TimeIndicatorTypeInfo) {
 203             return TypeInformation.of(LocalDateTime.class);
 204         }
 205         return typeInformation;
 206     }
 207 
 208     public void setLocalSqlPluginPath(String localSqlPluginPath) {
 209         this.localSqlPluginPath = localSqlPluginPath;
 210     }
 211 
 212     public void setPluginLoadMode(String pluginLoadMode) {
 213         this.pluginLoadMode = pluginLoadMode;
 214     }
 215 
<abbr title=" 216     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){"> 216     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableNa🔵</abbr>
 217         Table table = localTableCache.get(tableAlias);
 218         if(table == null){
 219             table = localTableCache.get(tableName);
 220         }
 221 
 222         if(table == null){
 223             throw new RuntimeException(&quot;not register table &quot; + tableAlias);
 224         }
 225 
 226         return table;
 227     }
 228 
 229     /**
<abbr title=" 230      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 230      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., d🔵</abbr>
 231      *
 232      * @return
 233      */
<abbr title=" 234     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 234     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInf🔵</abbr>
 235         List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 236         if (CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))) {
 237             return true;
 238         }
 239         return false;
 240     }
 241 
 242     private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 243         List&lt;String&gt; res = Lists.newArrayList();
 244         sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 245             res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 246         });
 247         return res;
 248     }
 249 
<abbr title=" 250     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo) {"> 250     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTa🔵</abbr>
 251         List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 252         ParseUtils.parseAnd(conditionNode, sqlNodeList);
 253         List&lt;String&gt; conditionFields = Lists.newArrayList();
 254         for (SqlNode sqlNode : sqlNodeList) {
 255             if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 256                 throw new RuntimeException(&quot;not compare operator.&quot;);
 257             }
 258             SqlIdentifier left = ((SqlIdentifier) (((SqlBasicCall) (sqlNode)).getOperands()[0]));
 259             SqlIdentifier right = ((SqlIdentifier) (((SqlBasicCall) (sqlNode)).getOperands()[1]));
 260             String leftTableName = left.getComponent(0).getSimple();
 261             String rightTableName = right.getComponent(0).getSimple();
 262             String tableCol = &quot;&quot;;
 263             if (leftTableName.equalsIgnoreCase(specifyTableName)) {
 264                 tableCol = left.getComponent(1).getSimple();
 265             } else if (rightTableName.equalsIgnoreCase(specifyTableName)) {
 266                 tableCol = right.getComponent(1).getSimple();
 267             } else {
<abbr title=" 268                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 268                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specify🔵</abbr>
 269             }
 270             tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 271             conditionFields.add(tableCol);
 272         }
 273         return conditionFields;
 274     }
 275 
<abbr title=" 276     protected void dealAsSourceTable(StreamTableEnvironment tableEnv, SqlNode pollSqlNode, Map&lt;String, Table&gt; tableCache) throws SqlParseException {"> 276     protected void dealAsSourceTable(StreamTableEnvironment tableEnv, SqlNode pollSqlNode, Map&lt;String, Ta🔵</abbr>
 277         AliasInfo aliasInfo = parseASNode(pollSqlNode);
 278         if (localTableCache.containsKey(aliasInfo.getName())) {
 279             return;
 280         }
 281         Table table = tableEnv.sqlQuery(aliasInfo.getName());
 282         tableEnv.registerTable(aliasInfo.getAlias(), table);
 283         localTableCache.put(aliasInfo.getAlias(), table);
 284         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 285         FieldReplaceInfo fieldReplaceInfo = parseAsQuery(((SqlBasicCall) (pollSqlNode)), tableCache);
 286         if (fieldReplaceInfo == null) {
 287             return;
 288         }
 289         // as 的源表
 290         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 291         SqlNode fromNode = ((SqlBasicCall) (pollSqlNode)).getOperands()[0];
 292         TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 293     }
 294 
<abbr title=" 295     private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv) throws Exception {"> 295     private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache, Map&lt;String, AbstractSideTabl🔵</abbr>
 296         JoinInfo joinInfo = ((JoinInfo) (pollObj));
 297         JoinScope joinScope = new JoinScope();
 298         JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 299         leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 300         leftScopeChild.setTableName(joinInfo.getLeftTableName());
<abbr title=" 301         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 301         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLe🔵</abbr>
<abbr title=" 302         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSchema().getFieldNames());"> 302         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSc🔵</abbr>
 303         int length = leftTable.getSchema().getFieldDataTypes().length;
 304         LogicalType[] logicalTypes = new LogicalType[length];
 305         for (int i = 0; i &lt; length; i++) {
 306             logicalTypes[i] = leftTable.getSchema().getFieldDataTypes()[i].getLogicalType();
 307         }
<abbr title=" 308         BaseRowTypeInfo leftBaseTypeInfo = new BaseRowTypeInfo(logicalTypes, leftTable.getSchema().getFieldNames());"> 308         BaseRowTypeInfo leftBaseTypeInfo = new BaseRowTypeInfo(logicalTypes, leftTable.getSchema().getFie🔵</abbr>
 309         leftScopeChild.setRowTypeInfo(leftTypeInfo);
 310         leftScopeChild.setBaseRowTypeInfo(leftBaseTypeInfo);
 311         JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 312         rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 313         rightScopeChild.setTableName(joinInfo.getRightTableName());
 314         AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 315         if (sideTableInfo == null) {
 316             sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 317         }
 318         if (sideTableInfo == null) {
 319             throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 320         }
 321         rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 322         rightScopeChild.setBaseRowTypeInfo(sideTableInfo.getBaseRowTypeInfo());
 323         joinScope.addScope(leftScopeChild);
 324         joinScope.addScope(rightScopeChild);
 325         HashBasedTable&lt;String, String, String&gt; mappingTable = ((JoinInfo) (pollObj)).getTableFieldRef();
 326         // 获取两个表的所有字段
<abbr title=" 327         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 327         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), join🔵</abbr>
 328         // 通过join的查询字段信息过滤出需要的字段信息
<abbr title=" 329         sideJoinFieldInfo.removeIf(( tmpFieldInfo) -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getFieldName()) == null);"> 329         sideJoinFieldInfo.removeIf(( tmpFieldInfo) -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldI🔵</abbr>
 330         String leftTableAlias = joinInfo.getLeftTableAlias();
 331         Table targetTable = localTableCache.get(leftTableAlias);
 332         if (targetTable == null) {
 333             targetTable = localTableCache.get(joinInfo.getLeftTableName());
 334         }
<abbr title=" 335         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSchema().getFieldNames());"> 335         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSc🔵</abbr>
 336         DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; adaptStream = tableEnv.toRetractStream(targetTable, Row.class);
 337         //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 338         if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 339             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 339             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTa🔵</abbr>
 340             List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 341             int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 342             adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 342             adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, ta🔵</abbr>
 343         }
 344         DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; dsOut = null;
 345         if (ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())) {
<abbr title=" 346             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo, pluginLoadMode);"> 346             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), 🔵</abbr>
 347         } else {
<abbr title=" 348             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo, pluginLoadMode);"> 348             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSq🔵</abbr>
 349         }
 350         BaseRowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 351         TupleTypeInfo tupleTypeInfo = new TupleTypeInfo(Types.BOOLEAN, sideOutTypeInfo);
 352         dsOut.getTransformation().setOutputType(tupleTypeInfo);
 353         String targetTableName = joinInfo.getNewTableName();
 354         String targetTableAlias = joinInfo.getNewTableAlias();
 355         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 356         replaceInfo.setMappingTable(mappingTable);
 357         replaceInfo.setTargetTableName(targetTableName);
 358         replaceInfo.setTargetTableAlias(targetTableAlias);
<abbr title=" 359         ObjectIdentifier objectIdentifier = ObjectIdentifier.of(EnvironmentSettings.DEFAULT_BUILTIN_CATALOG, EnvironmentSettings.DEFAULT_BUILTIN_DATABASE, targetTableName);"> 359         ObjectIdentifier objectIdentifier = ObjectIdentifier.of(EnvironmentSettings.DEFAULT_BUILTIN_CATAL🔵</abbr>
<abbr title=" 360         boolean tableExists = tableEnv.getCatalog(EnvironmentSettings.DEFAULT_BUILTIN_CATALOG).get().tableExists(objectIdentifier.toObjectPath());"> 360         boolean tableExists = tableEnv.getCatalog(EnvironmentSettings.DEFAULT_BUILTIN_CATALOG).get().tabl🔵</abbr>
 361         if (!tableExists) {
 362             Table joinTable = tableEnv.fromDataStream(dsOut);
 363             tableEnv.createTemporaryView(targetTableName, joinTable);
 364             localTableCache.put(joinInfo.getNewTableName(), joinTable);
 365         }
 366     }
 367 
 368     private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 369         String[] fieldNames = schema.getFieldNames();
 370         TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 371 
<abbr title=" 372         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);"> 372         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::ne🔵</abbr>
<abbr title=" 373         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 373         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(Typ🔵</abbr>
 374         return new RowTypeInfo(projectedTypes, projectedNames);
 375     }
 376 
 377     private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 378         List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 379         String fieldsInfo = result.getFieldsInfoStr();
 380         String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 381         for (int i = 0; i &lt; fields.length; i++) {
 382             String[] filed = fields[i].split(&quot;\\s&quot;);
 383             if (filed.length &lt; 2 || fields.length != table.getSchema().getFieldCount()){
 384                 return false;
 385             } else {
 386                 String[] filedNameArr = new String[filed.length - 1];
 387                 System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 388                 String fieldName = String.join(&quot; &quot;, filedNameArr);
 389                 fieldNames.add(fieldName);
 390                 String fieldType = filed[filed.length - 1 ].trim();
 391                 Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 392                 Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 393                 if (fieldClass == tableField){
 394                     continue;
 395                 } else {
 396                     return false;
 397                 }
 398             }
 399         }
 400         tmpFields = String.join(&quot;,&quot;, fieldNames);
 401         return true;
 402     }
 403 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.side;
  22  
  23  import org.apache.flink.api.common.typeinfo.TypeInformation;
  24  import org.apache.flink.api.common.typeinfo.Types;
  25  import org.apache.flink.api.java.tuple.Tuple2;
  26  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  27  import org.apache.flink.api.java.typeutils.TupleTypeInfo;
  28  import org.apache.flink.streaming.api.datastream.DataStream;
  29  import org.apache.flink.table.api.EnvironmentSettings;
  30  import org.apache.flink.table.api.Table;
  31  import org.apache.flink.table.api.TableSchema;
  32  import org.apache.flink.table.api.java.StreamTableEnvironment;
  33  import org.apache.flink.table.api.java.internal.StreamTableEnvironmentImpl;
  34  import org.apache.flink.table.catalog.CatalogManager;
  35  import org.apache.flink.table.catalog.ObjectIdentifier;
  36  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  37  import org.apache.flink.types.Row;
  38  
  39  import com.dtstack.flink.sql.enums.ECacheType;
  40  import com.dtstack.flink.sql.exec.FlinkSQLExec;
  41  import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  42  import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  43  import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  44  import com.dtstack.flink.sql.util.ClassUtil;
  45  import com.dtstack.flink.sql.util.ParseUtils;
  46  import com.dtstack.flink.sql.util.TableUtils;
  47  import com.google.common.base.Preconditions;
  48  import com.google.common.collect.HashBasedTable;
  49  import com.google.common.collect.Lists;
  50  import com.google.common.collect.Maps;
  51  import com.google.common.collect.Sets;
  52  import org.apache.calcite.sql.SqlBasicCall;
  53  import org.apache.calcite.sql.SqlIdentifier;
  54  import org.apache.calcite.sql.SqlKind;
  55  import org.apache.calcite.sql.SqlNode;
  56  import org.apache.calcite.sql.SqlSelect;
  57  import org.apache.calcite.sql.SqlWithItem;

  58  import org.apache.calcite.sql.parser.SqlParseException;
  59  import org.apache.commons.collections.CollectionUtils;
  60  import org.apache.commons.lang3.StringUtils;















  61  import org.slf4j.Logger;
  62  import org.slf4j.LoggerFactory;
  63  
  64  import java.sql.Timestamp;
  65  import java.time.LocalDateTime;
  66  import java.util.Arrays;
  67  import java.util.LinkedList;
  68  import java.util.List;
  69  import java.util.Map;
  70  import java.util.Queue;
  71  import java.util.Set;

  72  
  73  import static org.apache.calcite.sql.SqlKind.*;
  74  
  75  /**
  76   * Reason:
  77   * Date: 2018/7/24
  78   * Company: www.dtstack.com

  79   * @author xuchao
  80   */
  81  
  82  public class SideSqlExec {
  83  
  84      private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  85  
  86      private String localSqlPluginPath = null;
  87  
  88      private String tmpFields = null;
  89  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  90 +    private String pluginLoadMode = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  91 +</span>
  92      private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  93  
  94      private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  95  
  96      public void exec(String sql,
  97                       Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
  98                       StreamTableEnvironment tableEnv,
  99                       Map&lt;String, Table&gt; tableCache,
 100                       CreateTmpTableParser.SqlParserResult createView,
 101                       String scope) throws Exception {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 102 -        if(localSqlPluginPath == null){</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 103 -            throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 104 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 105 -</span>
 106          localTableCache.putAll(tableCache);
 107          try {
 108              sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 109          } catch (Exception e) {
 110              LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 111          }
 112  
 113          if(createView != null){

 114              LOG.warn(&quot;create view info\n&quot;);
 115              LOG.warn(createView.getExecSql());
 116              LOG.warn(&quot;-----------------&quot;);
 117          }
 118  
 119          SideSQLParser sideSQLParser = new SideSQLParser();
 120          sideSQLParser.setLocalTableCache(localTableCache);
 121          Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet(), scope);
 122          Object pollObj = null;
 123  
 124          while((pollObj = exeQueue.poll()) != null){
 125  
 126              if(pollObj instanceof SqlNode){



 127                  SqlNode pollSqlNode = (SqlNode) pollObj;
 128  
 129  
 130                  if(pollSqlNode.getKind() == INSERT){

 131                      FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString());
 132                      if(LOG.isInfoEnabled()){

 133                          LOG.info(&quot;----------real exec sql-----------\n{}&quot;, pollSqlNode.toString());
 134                      }
 135  
 136                  }else if(pollSqlNode.getKind() == AS){

 137                      dealAsSourceTable(tableEnv, pollSqlNode, tableCache);
 138  
 139                  } else if (pollSqlNode.getKind() == WITH_ITEM) {
 140                      SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 141                      String TableAlias = sqlWithItem.name.toString();
 142                      Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 143                      tableEnv.registerTable(TableAlias, table);
 144  
 145                  } else if (pollSqlNode.getKind() == SELECT){

 146                      Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);
 147                      Table table = tableEnv.sqlQuery(pollObj.toString());
 148  
 149                      if (createView.getFieldsInfoStr() == null){

 150                          tableEnv.registerTable(createView.getTableName(), table);
 151                      } else {
 152                          if (checkFieldsInfo(createView, table)){

 153                              table = table.as(tmpFields);
 154                              tableEnv.registerTable(createView.getTableName(), table);
 155                          } else {
 156                              throw new RuntimeException(&quot;Fields mismatch&quot;);
 157                          }
 158                      }
 159  
 160                      localTableCache.put(createView.getTableName(), table);
 161                  }
 162  
 163              }else if (pollObj instanceof JoinInfo){

 164                  LOG.info(&quot;----------exec join info----------\n{}&quot;, pollObj.toString());
 165                  joinFun(pollObj, localTableCache, sideTableMap, tableEnv);
 166              }
 167          }
 168  
 169      }
 170  
 171  
 172      /**
 173       * 解析出as查询的表和字段的关系

 174       * @param asSqlNode
 175       * @param tableCache
 176       * @return
 177       */
 178      private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){

 179          SqlNode info = asSqlNode.getOperands()[0];
 180          SqlNode alias = asSqlNode.getOperands()[1];
 181  
 182          SqlKind infoKind = info.getKind();
 183          if(infoKind != SELECT){

 184              return null;
 185          }
 186  
 187          List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 188  
 189          HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 190          for (FieldInfo fieldInfo : extractFieldList) {
 191              String tableName = fieldInfo.getTable();
 192              String fieldName = fieldInfo.getFieldName();
 193              String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 194              mappingTable.put(tableName, fieldName, mappingFieldName);
 195          }
 196  
 197          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 198          replaceInfo.setMappingTable(mappingTable);
 199          replaceInfo.setTargetTableName(alias.toString());
 200          replaceInfo.setTargetTableAlias(alias.toString());
 201          return replaceInfo;
 202      }
 203  
 204  
 205      public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {
 206          SqlKind sqlKind = sqlNode.getKind();
 207          if(sqlKind != AS){

 208              throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 209          }
 210  
 211          SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];

 212          SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 213  
 214          AliasInfo aliasInfo = new AliasInfo();
 215          aliasInfo.setName(info.toString());
 216          aliasInfo.setAlias(alias.toString());
 217  
 218          return aliasInfo;
 219      }
 220  
 221      public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo,
 222                                             HashBasedTable&lt;String, String, String&gt; mappingTable) {
 223          TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];




 224          String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 225          for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 226              FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 227              String tableName = fieldInfo.getTable();
 228              String fieldName = fieldInfo.getFieldName();
 229  
 230              String mappingFieldName = mappingTable.get(tableName, fieldName);
<abbr title=" 231              Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;);"> 231              Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;🔵</abbr>
 232  
 233              sideOutTypes[i] = fieldInfo.getTypeInformation();

 234              sideOutNames[i] = mappingFieldName;
 235          }
 236          return new RowTypeInfo(sideOutTypes, sideOutNames);
 237      }
 238  


 239  
 240  
 241      /**
 242       *  对时间类型进行类型转换


 243       * @param leftTypeInfo
 244       * @return
 245       */
 246      private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 247          TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 248          TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 249          for (int i = 0; i &lt; sideOutTypes.length; i++) {
 250              sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 251          }
 252          RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 253          return rowTypeInfo;
 254      }
 255  
 256      private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 257          if (typeInformation instanceof TimeIndicatorTypeInfo) {
 258              return TypeInformation.of(LocalDateTime.class);
 259          }
 260          return typeInformation;
 261      }
 262  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 263 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 264 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 265 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 266 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 267 -</span>
 268      public void setLocalSqlPluginPath(String localSqlPluginPath) {
 269          this.localSqlPluginPath = localSqlPluginPath;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 270 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 271 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 272 +    public void setPluginLoadMode(String pluginLoadMode) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 273 +        this.pluginLoadMode = pluginLoadMode;</span>
 274      }
 275  
 276      private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){

 277          Table table = localTableCache.get(tableAlias);
 278          if(table == null){

 279              table = localTableCache.get(tableName);
 280          }
 281  
 282          if(table == null){

 283              throw new RuntimeException(&quot;not register table &quot; + tableAlias);
 284          }
 285  
 286          return table;
 287      }
 288  
 289  
 290      /**
<abbr title=" 291       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 291       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension 🔵</abbr>
 292       *
 293       * @return
 294       */
<abbr title=" 295      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 295      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTab🔵</abbr>
 296          List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 297          if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){

 298              return true;
 299          }
 300          return false;
 301      }
 302  
 303      private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 304          List&lt;String&gt; res = Lists.newArrayList();
 305          sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 306              res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 307          });
 308          return res;
 309      }
 310  
<abbr title=" 311      public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 311      public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo s🔵</abbr>

 312          List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 313          ParseUtils.parseAnd(conditionNode, sqlNodeList);
 314          List&lt;String&gt; conditionFields = Lists.newArrayList();
 315          for(SqlNode sqlNode : sqlNodeList){

 316              if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 317                  throw new RuntimeException(&quot;not compare operator.&quot;);
 318              }
 319  
 320              SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 321              SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];


 322  
 323              String leftTableName = left.getComponent(0).getSimple();
 324              String rightTableName = right.getComponent(0).getSimple();
 325  
 326              String tableCol = &quot;&quot;;
 327              if(leftTableName.equalsIgnoreCase(specifyTableName)){

 328                  tableCol = left.getComponent(1).getSimple();
 329              }else if(rightTableName.equalsIgnoreCase(specifyTableName)){

 330                  tableCol = right.getComponent(1).getSimple();
 331              }else{

<abbr title=" 332                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 332                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName🔵</abbr>
 333              }
 334              tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 335              conditionFields.add(tableCol);
 336          }
 337  
 338          return conditionFields;
 339      }
 340  
 341      protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 342                                       SqlNode pollSqlNode,
 343                                       Map&lt;String, Table&gt; tableCache) throws SqlParseException {
 344  
 345          AliasInfo aliasInfo = parseASNode(pollSqlNode);
 346          if (localTableCache.containsKey(aliasInfo.getName())) {
 347              return;
 348          }
 349  
 350          Table table = tableEnv.sqlQuery(aliasInfo.getName());
 351          tableEnv.registerTable(aliasInfo.getAlias(), table);
 352          localTableCache.put(aliasInfo.getAlias(), table);
 353  
 354          LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 355  
 356          FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 357          if(fieldReplaceInfo == null){
 358             return;


 359          }
 360  
 361          //as 的源表
 362          Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 363          SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];

 364          TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 365  
 366      }
 367  
 368      private void joinFun(Object pollObj,
 369                           Map&lt;String, Table&gt; localTableCache,
 370                           Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
 371                           StreamTableEnvironment tableEnv) throws Exception{

 372          JoinInfo joinInfo = (JoinInfo) pollObj;
 373  
 374          JoinScope joinScope = new JoinScope();
 375          JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 376          leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 377          leftScopeChild.setTableName(joinInfo.getLeftTableName());
 378  
<abbr title=" 379          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 379          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableNa🔵</abbr>
 380  
<abbr title=" 381          RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSchema().getFieldNames());"> 381          RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSchema().ge🔵</abbr>









 382          leftScopeChild.setRowTypeInfo(leftTypeInfo);

 383  
 384          JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 385          rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 386          rightScopeChild.setTableName(joinInfo.getRightTableName());
 387          AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 388          if(sideTableInfo == null){

 389              sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 390          }
 391  
 392          if(sideTableInfo == null){

 393              throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 394          }
 395  
 396          rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());

 397  
 398          joinScope.addScope(leftScopeChild);
 399          joinScope.addScope(rightScopeChild);
 400  
 401          HashBasedTable&lt;String, String, String&gt; mappingTable = ((JoinInfo) pollObj).getTableFieldRef();
 402  
 403          //获取两个表的所有字段
<abbr title=" 404          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 404          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, tr🔵</abbr>
 405          //通过join的查询字段信息过滤出需要的字段信息
<abbr title=" 406          sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getFieldName()) == null);"> 406          sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getField🔵</abbr>
 407  
 408          String leftTableAlias = joinInfo.getLeftTableAlias();
 409          Table targetTable = localTableCache.get(leftTableAlias);
 410          if(targetTable == null){

 411              targetTable = localTableCache.get(joinInfo.getLeftTableName());
 412          }
 413  
<abbr title=" 414          RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSchema().getFieldNames());"> 414          RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSchema().ge🔵</abbr>
 415  
 416          DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; adaptStream = tableEnv.toRetractStream(targetTable, Row.class);
 417  
 418          //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 419          if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 420              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 420              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(🔵</abbr>
 421              List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 422              int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 423              adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 423              adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable🔵</abbr>
 424          }
 425  
 426          DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; dsOut = null;
 427          if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 428 -            dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 428 -            dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlP🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 429 +            dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo, pluginLoadMode);"> 429 +            dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlP🔵</abbr></span>
 430          }else{

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 431 -            dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 431 -            dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPa🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 432 +            dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo, pluginLoadMode);"> 432 +            dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPa🔵</abbr></span>
 433          }
 434  
 435          RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);

 436  
 437          TupleTypeInfo tupleTypeInfo = new TupleTypeInfo(Types.BOOLEAN, sideOutTypeInfo);
 438          dsOut.getTransformation().setOutputType(tupleTypeInfo);
 439  
 440          String targetTableName = joinInfo.getNewTableName();
 441          String targetTableAlias = joinInfo.getNewTableAlias();
 442  
 443          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 444          replaceInfo.setMappingTable(mappingTable);
 445          replaceInfo.setTargetTableName(targetTableName);
 446          replaceInfo.setTargetTableAlias(targetTableAlias);
 447  
 448          ObjectIdentifier objectIdentifier = ObjectIdentifier.of(
 449                  EnvironmentSettings.DEFAULT_BUILTIN_CATALOG,
 450                  EnvironmentSettings.DEFAULT_BUILTIN_DATABASE,
 451                  targetTableName);
<abbr title=" 452          boolean tableExists = tableEnv.getCatalog(EnvironmentSettings.DEFAULT_BUILTIN_CATALOG).get().tableExists(objectIdentifier.toObjectPath());"> 452          boolean tableExists = tableEnv.getCatalog(EnvironmentSettings.DEFAULT_BUILTIN_CATALOG).get().tableExists(o🔵</abbr>
 453  
 454          if (!tableExists){

 455              Table joinTable = tableEnv.fromDataStream(dsOut);
 456              tableEnv.createTemporaryView(targetTableName, joinTable);
 457              localTableCache.put(joinInfo.getNewTableName(), joinTable);
 458          }
 459      }
 460  
 461      private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 462          String[] fieldNames = schema.getFieldNames();
 463          TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 464  
 465          String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);
<abbr title=" 466          TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 466          TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformat🔵</abbr>
 467          return new RowTypeInfo(projectedTypes, projectedNames);
 468      }
 469  
 470  
 471      private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 472          List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 473          String fieldsInfo = result.getFieldsInfoStr();
 474          String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 475          for (int i = 0; i &lt; fields.length; i++) {
 476              String[] filed = fields[i].split(&quot;\\s&quot;);
 477              if (filed.length &lt; 2 || fields.length != table.getSchema().getFieldCount()){

 478                  return false;
 479              } else {
 480                  String[] filedNameArr = new String[filed.length - 1];
 481                  System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 482                  String fieldName = String.join(&quot; &quot;, filedNameArr);
 483                  fieldNames.add(fieldName);
 484                  String fieldType = filed[filed.length - 1 ].trim();

 485                  Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 486                  Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 487                  if (fieldClass == tableField){

 488                      continue;
 489                  } else {
 490                      return false;
 491                  }
 492              }
 493          }
 494          tmpFields = String.join(&quot;,&quot;, fieldNames);
 495          return true;
 496      }
 497  
 498  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  20 -</span>
  21  package com.dtstack.flink.sql.side;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  22 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  23 -import org.apache.flink.api.common.typeinfo.TypeInformation;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  24 -import org.apache.flink.api.common.typeinfo.Types;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  25 -import org.apache.flink.api.java.tuple.Tuple2;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  26 -import org.apache.flink.api.java.typeutils.RowTypeInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  27 -import org.apache.flink.api.java.typeutils.TupleTypeInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  28 -import org.apache.flink.streaming.api.datastream.DataStream;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  29 -import org.apache.flink.table.api.EnvironmentSettings;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  30 -import org.apache.flink.table.api.Table;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  31 -import org.apache.flink.table.api.TableSchema;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  32 -import org.apache.flink.table.api.java.StreamTableEnvironment;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  33 -import org.apache.flink.table.api.java.internal.StreamTableEnvironmentImpl;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  34 -import org.apache.flink.table.catalog.CatalogManager;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  35 -import org.apache.flink.table.catalog.ObjectIdentifier;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  36 -import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  37 -import org.apache.flink.types.Row;</span>
  38  
  39  import com.dtstack.flink.sql.enums.ECacheType;
  40  import com.dtstack.flink.sql.exec.FlinkSQLExec;
  41  import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  42  import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  43  import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  44  import com.dtstack.flink.sql.util.ClassUtil;
  45  import com.dtstack.flink.sql.util.ParseUtils;
  46  import com.dtstack.flink.sql.util.TableUtils;
  47  import com.google.common.base.Preconditions;
  48  import com.google.common.collect.HashBasedTable;
  49  import com.google.common.collect.Lists;
  50  import com.google.common.collect.Maps;
  51  import com.google.common.collect.Sets;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  52 -import org.apache.calcite.sql.SqlBasicCall;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  53 -import org.apache.calcite.sql.SqlIdentifier;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  54 -import org.apache.calcite.sql.SqlKind;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  55 -import org.apache.calcite.sql.SqlNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  56 -import org.apache.calcite.sql.SqlSelect;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  57 -import org.apache.calcite.sql.SqlWithItem;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  58 +import org.apache.calcite.sql.*;</span>
  59  import org.apache.calcite.sql.parser.SqlParseException;
  60  import org.apache.commons.collections.CollectionUtils;
  61  import org.apache.commons.lang3.StringUtils;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  62 +import org.apache.flink.api.common.typeinfo.TypeInformation;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  63 +import org.apache.flink.api.common.typeinfo.Types;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  64 +import org.apache.flink.api.java.tuple.Tuple2;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  65 +import org.apache.flink.api.java.typeutils.RowTypeInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  66 +import org.apache.flink.api.java.typeutils.TupleTypeInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  67 +import org.apache.flink.streaming.api.datastream.DataStream;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  68 +import org.apache.flink.table.api.EnvironmentSettings;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  69 +import org.apache.flink.table.api.Table;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  70 +import org.apache.flink.table.api.TableSchema;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  71 +import org.apache.flink.table.api.java.StreamTableEnvironment;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  72 +import org.apache.flink.table.runtime.typeutils.BaseRowTypeInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  73 +import org.apache.flink.table.types.logical.LogicalType;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  74 +import org.apache.flink.table.catalog.ObjectIdentifier;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  75 +import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  76 +import org.apache.flink.types.Row;</span>
  77  import org.slf4j.Logger;
  78  import org.slf4j.LoggerFactory;
  79  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  80 -import java.sql.Timestamp;</span>
  81  import java.time.LocalDateTime;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  82 -import java.util.Arrays;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  83 -import java.util.LinkedList;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  84 -import java.util.List;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  85 -import java.util.Map;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  86 -import java.util.Queue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  87 -import java.util.Set;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  88 +import java.util.*;</span>
  89  
  90  import static org.apache.calcite.sql.SqlKind.*;
  91  
  92  /**
  93   * Reason:
  94   * Date: 2018/7/24
  95   * Company: www.dtstack.com
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  96 + *</span>
  97   * @author xuchao
  98   */
  99  
 100  public class SideSqlExec {
 101  
 102      private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
 103  
 104      private String localSqlPluginPath = null;
 105  
 106      private String tmpFields = null;
 107  


 108      private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
 109  
 110      private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
 111  
 112      public void exec(String sql,
 113                       Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
 114                       StreamTableEnvironment tableEnv,
 115                       Map&lt;String, Table&gt; tableCache,
 116                       CreateTmpTableParser.SqlParserResult createView,
 117                       String scope) throws Exception {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 118 -        if(localSqlPluginPath == null){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 119 +        if (localSqlPluginPath == null) {</span>
 120              throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
 121          }
 122  
 123          localTableCache.putAll(tableCache);
 124          try {
 125              sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 126          } catch (Exception e) {
 127              LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 128          }
 129  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 130 -        if(createView != null){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 131 +        if (createView != null) {</span>
 132              LOG.warn(&quot;create view info\n&quot;);
 133              LOG.warn(createView.getExecSql());
 134              LOG.warn(&quot;-----------------&quot;);
 135          }
 136  
 137          SideSQLParser sideSQLParser = new SideSQLParser();
 138          sideSQLParser.setLocalTableCache(localTableCache);
 139          Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet(), scope);
 140          Object pollObj = null;
 141  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 142 -        while((pollObj = exeQueue.poll()) != null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 143 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 144 -            if(pollObj instanceof SqlNode){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 145 +        while ((pollObj = exeQueue.poll()) != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 146 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 147 +            if (pollObj instanceof SqlNode) {</span>
 148                  SqlNode pollSqlNode = (SqlNode) pollObj;
 149  
 150  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 151 -                if(pollSqlNode.getKind() == INSERT){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 152 +                if (pollSqlNode.getKind() == INSERT) {</span>
 153                      FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 154 -                    if(LOG.isInfoEnabled()){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 155 +                    if (LOG.isInfoEnabled()) {</span>
 156                          LOG.info(&quot;----------real exec sql-----------\n{}&quot;, pollSqlNode.toString());
 157                      }
 158  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 159 -                }else if(pollSqlNode.getKind() == AS){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 160 +                } else if (pollSqlNode.getKind() == AS) {</span>
 161                      dealAsSourceTable(tableEnv, pollSqlNode, tableCache);
 162  
 163                  } else if (pollSqlNode.getKind() == WITH_ITEM) {
 164                      SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 165                      String TableAlias = sqlWithItem.name.toString();
 166                      Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 167                      tableEnv.registerTable(TableAlias, table);
 168  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 169 -                } else if (pollSqlNode.getKind() == SELECT){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 170 +                } else if (pollSqlNode.getKind() == SELECT) {</span>
 171                      Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);
 172                      Table table = tableEnv.sqlQuery(pollObj.toString());
 173  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 174 -                    if (createView.getFieldsInfoStr() == null){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 175 +                    if (createView.getFieldsInfoStr() == null) {</span>
 176                          tableEnv.registerTable(createView.getTableName(), table);
 177                      } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 178 -                        if (checkFieldsInfo(createView, table)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 179 +                        if (checkFieldsInfo(createView, table)) {</span>
 180                              table = table.as(tmpFields);
 181                              tableEnv.registerTable(createView.getTableName(), table);
 182                          } else {
 183                              throw new RuntimeException(&quot;Fields mismatch&quot;);
 184                          }
 185                      }
 186  
 187                      localTableCache.put(createView.getTableName(), table);
 188                  }
 189  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 190 -            }else if (pollObj instanceof JoinInfo){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 191 +            } else if (pollObj instanceof JoinInfo) {</span>
 192                  LOG.info(&quot;----------exec join info----------\n{}&quot;, pollObj.toString());
 193                  joinFun(pollObj, localTableCache, sideTableMap, tableEnv);
 194              }
 195          }
 196  
 197      }
 198  
 199  
 200      /**
 201       * 解析出as查询的表和字段的关系
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 202 +     *</span>
 203       * @param asSqlNode
 204       * @param tableCache
 205       * @return
 206       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 207 -    private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 208 +    private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache) {</span>
 209          SqlNode info = asSqlNode.getOperands()[0];
 210          SqlNode alias = asSqlNode.getOperands()[1];
 211  
 212          SqlKind infoKind = info.getKind();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 213 -        if(infoKind != SELECT){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 214 +        if (infoKind != SELECT) {</span>
 215              return null;
 216          }
 217  
 218          List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 219  
 220          HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 221          for (FieldInfo fieldInfo : extractFieldList) {
 222              String tableName = fieldInfo.getTable();
 223              String fieldName = fieldInfo.getFieldName();
 224              String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 225              mappingTable.put(tableName, fieldName, mappingFieldName);
 226          }
 227  
 228          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 229          replaceInfo.setMappingTable(mappingTable);
 230          replaceInfo.setTargetTableName(alias.toString());
 231          replaceInfo.setTargetTableAlias(alias.toString());
 232          return replaceInfo;
 233      }
 234  
 235  
 236      public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {
 237          SqlKind sqlKind = sqlNode.getKind();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 238 -        if(sqlKind != AS){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 239 +        if (sqlKind != AS) {</span>
 240              throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 241          }
 242  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 243 -        SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 244 +        SqlNode info = ((SqlBasicCall) sqlNode).getOperands()[0];</span>
 245          SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 246  
 247          AliasInfo aliasInfo = new AliasInfo();
 248          aliasInfo.setName(info.toString());
 249          aliasInfo.setAlias(alias.toString());
 250  
 251          return aliasInfo;
 252      }
 253  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 254 -    public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 255 -                                           HashBasedTable&lt;String, String, String&gt; mappingTable) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 256 -        TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 257 +    public BaseRowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 258 +                                               HashBasedTable&lt;String, String, String&gt; mappingTable) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 259 +        // TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 260 +        LogicalType[] sideOutTypes = new LogicalType[sideJoinFieldInfo.size()];</span>
 261          String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 262          for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 263              FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 264              String tableName = fieldInfo.getTable();
 265              String fieldName = fieldInfo.getFieldName();
 266  
 267              String mappingFieldName = mappingTable.get(tableName, fieldName);
<abbr title=" 268              Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;);"> 268              Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;🔵</abbr>
 269  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 270 -            sideOutTypes[i] = fieldInfo.getTypeInformation();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 271 +            sideOutTypes[i] = fieldInfo.getLogicalType();</span>
 272              sideOutNames[i] = mappingFieldName;
 273          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 274 -        return new RowTypeInfo(sideOutTypes, sideOutNames);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 275 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 276 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 277 +        return new BaseRowTypeInfo(sideOutTypes, sideOutNames);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 278 +    }</span>
 279  
 280  
 281      /**
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 282 -     *  对时间类型进行类型转换</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 283 +     * 对时间类型进行类型转换</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 284 +     *</span>
 285       * @param leftTypeInfo
 286       * @return
 287       */
 288      private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 289          TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 290          TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 291          for (int i = 0; i &lt; sideOutTypes.length; i++) {
 292              sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 293          }
 294          RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 295          return rowTypeInfo;
 296      }
 297  
 298      private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 299          if (typeInformation instanceof TimeIndicatorTypeInfo) {
 300              return TypeInformation.of(LocalDateTime.class);
 301          }
 302          return typeInformation;
 303      }
 304  
 305  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 306 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 307 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 308 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 309 -</span>
 310      public void setLocalSqlPluginPath(String localSqlPluginPath) {
 311          this.localSqlPluginPath = localSqlPluginPath;




 312      }
 313  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 314 -    private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 315 +    private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName) {</span>
 316          Table table = localTableCache.get(tableAlias);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 317 -        if(table == null){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 318 +        if (table == null) {</span>
 319              table = localTableCache.get(tableName);
 320          }
 321  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 322 -        if(table == null){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 323 +        if (table == null) {</span>
 324              throw new RuntimeException(&quot;not register table &quot; + tableAlias);
 325          }
 326  
 327          return table;
 328      }
 329  
 330  
 331      /**
<abbr title=" 332       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 332       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension 🔵</abbr>
 333       *
 334       * @return
 335       */
<abbr title=" 336      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 336      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTab🔵</abbr>
 337          List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 338 -        if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 339 +        if (CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))) {</span>
 340              return true;
 341          }
 342          return false;
 343      }
 344  
 345      private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 346          List&lt;String&gt; res = Lists.newArrayList();
 347          sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 348              res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 349          });
 350          return res;
 351      }
 352  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 353 -    public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 353 -    public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo s🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 354 +    public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo) {"> 354 +    public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo s🔵</abbr></span>
 355          List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 356          ParseUtils.parseAnd(conditionNode, sqlNodeList);
 357          List&lt;String&gt; conditionFields = Lists.newArrayList();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 358 -        for(SqlNode sqlNode : sqlNodeList){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 359 +        for (SqlNode sqlNode : sqlNodeList) {</span>
 360              if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 361                  throw new RuntimeException(&quot;not compare operator.&quot;);
 362              }
 363  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 364 -            SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 365 -            SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 366 +            SqlIdentifier left = (SqlIdentifier) ((SqlBasicCall) sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 367 +            SqlIdentifier right = (SqlIdentifier) ((SqlBasicCall) sqlNode).getOperands()[1];</span>
 368  
 369              String leftTableName = left.getComponent(0).getSimple();
 370              String rightTableName = right.getComponent(0).getSimple();
 371  
 372              String tableCol = &quot;&quot;;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 373 -            if(leftTableName.equalsIgnoreCase(specifyTableName)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 374 +            if (leftTableName.equalsIgnoreCase(specifyTableName)) {</span>
 375                  tableCol = left.getComponent(1).getSimple();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 376 -            }else if(rightTableName.equalsIgnoreCase(specifyTableName)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 377 +            } else if (rightTableName.equalsIgnoreCase(specifyTableName)) {</span>
 378                  tableCol = right.getComponent(1).getSimple();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 379 -            }else{</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 380 +            } else {</span>
<abbr title=" 381                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 381                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName🔵</abbr>
 382              }
 383              tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 384              conditionFields.add(tableCol);
 385          }
 386  
 387          return conditionFields;
 388      }
 389  
 390      protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 391                                       SqlNode pollSqlNode,
 392                                       Map&lt;String, Table&gt; tableCache) throws SqlParseException {
 393  
 394          AliasInfo aliasInfo = parseASNode(pollSqlNode);
 395          if (localTableCache.containsKey(aliasInfo.getName())) {
 396              return;
 397          }
 398  
 399          Table table = tableEnv.sqlQuery(aliasInfo.getName());
 400          tableEnv.registerTable(aliasInfo.getAlias(), table);
 401          localTableCache.put(aliasInfo.getAlias(), table);
 402  
 403          LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 404  
 405          FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 406 -        if(fieldReplaceInfo == null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 407 -           return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 408 +        if (fieldReplaceInfo == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 409 +            return;</span>
 410          }
 411  
 412          //as 的源表
 413          Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 414 -        SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 415 +        SqlNode fromNode = ((SqlBasicCall) pollSqlNode).getOperands()[0];</span>
 416          TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 417  
 418      }
 419  
 420      private void joinFun(Object pollObj,
 421                           Map&lt;String, Table&gt; localTableCache,
 422                           Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 423 -                         StreamTableEnvironment tableEnv) throws Exception{</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 424 +                         StreamTableEnvironment tableEnv) throws Exception {</span>
 425          JoinInfo joinInfo = (JoinInfo) pollObj;
 426  
 427          JoinScope joinScope = new JoinScope();
 428          JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 429          leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 430          leftScopeChild.setTableName(joinInfo.getLeftTableName());
 431  
<abbr title=" 432          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 432          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableNa🔵</abbr>
 433  
<abbr title=" 434          RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSchema().getFieldNames());"> 434          RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSchema().ge🔵</abbr>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 435 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 436 +        int length = leftTable.getSchema().getFieldDataTypes().length;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 437 +        LogicalType[] logicalTypes = new LogicalType[length];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 438 +        for(int i=0; i&lt;length; i++){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 439 +            logicalTypes[i] = leftTable.getSchema().getFieldDataTypes()[i].getLogicalType();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 440 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 441 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 442 +        BaseRowTypeInfo leftBaseTypeInfo = new BaseRowTypeInfo(logicalTypes, leftTable.getSchema().getFieldNames());"> 442 +        BaseRowTypeInfo leftBaseTypeInfo = new BaseRowTypeInfo(logicalTypes, leftTable.getSchema().getFieldNames()🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 443 +</span>
 444          leftScopeChild.setRowTypeInfo(leftTypeInfo);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 445 +        leftScopeChild.setBaseRowTypeInfo(leftBaseTypeInfo);</span>
 446  
 447          JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 448          rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 449          rightScopeChild.setTableName(joinInfo.getRightTableName());
 450          AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 451 -        if(sideTableInfo == null){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 452 +        if (sideTableInfo == null) {</span>
 453              sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 454          }
 455  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 456 -        if(sideTableInfo == null){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 457 +        if (sideTableInfo == null) {</span>
 458              throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 459          }
 460  
 461          rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 462 +        rightScopeChild.setBaseRowTypeInfo(sideTableInfo.getBaseRowTypeInfo());</span>
 463  
 464          joinScope.addScope(leftScopeChild);
 465          joinScope.addScope(rightScopeChild);
 466  
 467          HashBasedTable&lt;String, String, String&gt; mappingTable = ((JoinInfo) pollObj).getTableFieldRef();
 468  
 469          //获取两个表的所有字段
<abbr title=" 470          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 470          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, tr🔵</abbr>
 471          //通过join的查询字段信息过滤出需要的字段信息
<abbr title=" 472          sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getFieldName()) == null);"> 472          sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getField🔵</abbr>
 473  
 474          String leftTableAlias = joinInfo.getLeftTableAlias();
 475          Table targetTable = localTableCache.get(leftTableAlias);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 476 -        if(targetTable == null){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 477 +        if (targetTable == null) {</span>
 478              targetTable = localTableCache.get(joinInfo.getLeftTableName());
 479          }
 480  
<abbr title=" 481          RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSchema().getFieldNames());"> 481          RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSchema().ge🔵</abbr>
 482  
 483          DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; adaptStream = tableEnv.toRetractStream(targetTable, Row.class);
 484  
 485          //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 486          if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 487              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 487              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(🔵</abbr>
 488              List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 489              int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 490              adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 490              adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable🔵</abbr>
 491          }
 492  
 493          DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; dsOut = null;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 494 -        if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 495 +        if (ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())) {</span>
<abbr title=" 496              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 496              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlP🔵</abbr>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 497 -        }else{</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 498 +        } else {</span>
<abbr title=" 499              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 499              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPa🔵</abbr>

 500          }
 501  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 502 -        RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 503 +        BaseRowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);</span>
 504  
 505          TupleTypeInfo tupleTypeInfo = new TupleTypeInfo(Types.BOOLEAN, sideOutTypeInfo);
 506          dsOut.getTransformation().setOutputType(tupleTypeInfo);
 507  
 508          String targetTableName = joinInfo.getNewTableName();
 509          String targetTableAlias = joinInfo.getNewTableAlias();
 510  
 511          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 512          replaceInfo.setMappingTable(mappingTable);
 513          replaceInfo.setTargetTableName(targetTableName);
 514          replaceInfo.setTargetTableAlias(targetTableAlias);
 515  
 516          ObjectIdentifier objectIdentifier = ObjectIdentifier.of(
 517                  EnvironmentSettings.DEFAULT_BUILTIN_CATALOG,
 518                  EnvironmentSettings.DEFAULT_BUILTIN_DATABASE,
 519                  targetTableName);
<abbr title=" 520          boolean tableExists = tableEnv.getCatalog(EnvironmentSettings.DEFAULT_BUILTIN_CATALOG).get().tableExists(objectIdentifier.toObjectPath());"> 520          boolean tableExists = tableEnv.getCatalog(EnvironmentSettings.DEFAULT_BUILTIN_CATALOG).get().tableExists(o🔵</abbr>
 521  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 522 -        if (!tableExists){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 523 +        if (!tableExists) {</span>
 524              Table joinTable = tableEnv.fromDataStream(dsOut);
 525              tableEnv.createTemporaryView(targetTableName, joinTable);
 526              localTableCache.put(joinInfo.getNewTableName(), joinTable);
 527          }
 528      }
 529  
 530      private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 531          String[] fieldNames = schema.getFieldNames();
 532          TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 533  
 534          String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);
<abbr title=" 535          TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 535          TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformat🔵</abbr>
 536          return new RowTypeInfo(projectedTypes, projectedNames);
 537      }
 538  
 539  
 540      private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 541          List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 542          String fieldsInfo = result.getFieldsInfoStr();
 543          String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 544          for (int i = 0; i &lt; fields.length; i++) {
 545              String[] filed = fields[i].split(&quot;\\s&quot;);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 546 -            if (filed.length &lt; 2 || fields.length != table.getSchema().getFieldCount()){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 547 +            if (filed.length &lt; 2 || fields.length != table.getSchema().getFieldCount()) {</span>
 548                  return false;
 549              } else {
 550                  String[] filedNameArr = new String[filed.length - 1];
 551                  System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 552                  String fieldName = String.join(&quot; &quot;, filedNameArr);
 553                  fieldNames.add(fieldName);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 554 -                String fieldType = filed[filed.length - 1 ].trim();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 555 +                String fieldType = filed[filed.length - 1].trim();</span>
 556                  Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 557                  Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 558 -                if (fieldClass == tableField){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 559 +                if (fieldClass == tableField) {</span>
 560                      continue;
 561                  } else {
 562                      return false;
 563                  }
 564              }
 565          }
 566          tmpFields = String.join(&quot;,&quot;, fieldNames);
 567          return true;
 568      }
 569  
 570  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            