<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>84</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    84
                    <a href="83.html">prev</a>
                    <a href="85.html">next</a>
                    <a href="84_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    Automattic/simplenote-android_847cc65342fcbd44235ea5a83f1a08b103b6ddab_Simplenote/src/main/java/com/automattic/simplenote/NoteEditorFragment.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;847cc65342fcbd44235ea5a83f1a08b103b6ddab:Simplenote/src/main/java/com/automattic/simplenote/NoteEditorFragment.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;847cc65342fcbd44235ea5a83f1a08b103b6ddab^1:Simplenote/src/main/java/com/automattic/simplenote/NoteEditorFragment.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;847cc65342fcbd44235ea5a83f1a08b103b6ddab^2:Simplenote/src/main/java/com/automattic/simplenote/NoteEditorFragment.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;ce7aec49945699c066e58c1e519ba95d78c8bce4:Simplenote/src/main/java/com/automattic/simplenote/NoteEditorFragment.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bj]], subset: [[bj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 package com.automattic.simplenote;
   2 
   3 import android.app.Activity;
   4 import android.content.Context;
   5 import android.content.SharedPreferences;
   6 import android.content.res.ColorStateList;
   7 import android.database.Cursor;
   8 import android.graphics.Typeface;
   9 import android.graphics.drawable.Drawable;
  10 import android.os.AsyncTask;
  11 import android.os.Bundle;
  12 import android.os.Handler;
  13 import android.text.Editable;
  14 import android.text.Layout;
  15 import android.text.Spanned;
  16 import android.text.TextUtils.SimpleStringSplitter;
  17 import android.text.TextWatcher;
  18 import android.text.style.MetricAffectingSpan;
  19 import android.text.style.RelativeSizeSpan;
  20 import android.text.style.StyleSpan;
  21 import android.text.style.URLSpan;
  22 import android.text.util.Linkify;
  23 import android.util.TypedValue;
  24 import android.view.LayoutInflater;
  25 import android.view.Menu;
  26 import android.view.MenuInflater;
  27 import android.view.MenuItem;
  28 import android.view.View;
  29 import android.view.ViewGroup;
  30 import android.view.ViewTreeObserver;
  31 import android.view.inputmethod.InputMethodManager;
  32 import android.webkit.WebResourceRequest;
  33 import android.webkit.WebView;
  34 import android.webkit.WebViewClient;
  35 import android.widget.CompoundButton;
  36 import android.widget.CursorAdapter;
  37 import android.widget.LinearLayout;
  38 import android.widget.TextView;
  39 import android.widget.Toast;
  40 
  41 import androidx.annotation.NonNull;
  42 import androidx.annotation.StringRes;
  43 import androidx.appcompat.app.AppCompatActivity;
  44 import androidx.appcompat.view.ActionMode;
  45 import androidx.core.app.ShareCompat;
  46 import androidx.core.view.MenuCompat;
  47 import androidx.core.widget.NestedScrollView;
  48 import androidx.fragment.app.Fragment;
  49 import androidx.fragment.app.FragmentTransaction;
  50 import androidx.preference.PreferenceManager;
  51 
  52 import com.automattic.simplenote.analytics.AnalyticsTracker;
  53 import com.automattic.simplenote.models.Note;
  54 import com.automattic.simplenote.models.Tag;
  55 import com.automattic.simplenote.utils.AppLog;
  56 import com.automattic.simplenote.utils.AppLog.Type;
  57 import com.automattic.simplenote.utils.AutoBullet;
  58 import com.automattic.simplenote.utils.BrowserUtils;
  59 import com.automattic.simplenote.utils.ContextUtils;
  60 import com.automattic.simplenote.utils.DisplayUtils;
  61 import com.automattic.simplenote.utils.DrawableUtils;
  62 import com.automattic.simplenote.utils.MatchOffsetHighlighter;
  63 import com.automattic.simplenote.utils.NetworkUtils;
  64 import com.automattic.simplenote.utils.NoteUtils;
  65 import com.automattic.simplenote.utils.PrefUtils;
  66 import com.automattic.simplenote.utils.SimplenoteLinkify;
  67 import com.automattic.simplenote.utils.SimplenoteMovementMethod;
  68 import com.automattic.simplenote.utils.SpaceTokenizer;
  69 import com.automattic.simplenote.utils.TagUtils;
  70 import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;
  71 import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;
  72 import com.automattic.simplenote.utils.TextHighlighter;
  73 import com.automattic.simplenote.utils.ThemeUtils;
  74 import com.automattic.simplenote.utils.WidgetUtils;
  75 import com.automattic.simplenote.widgets.SimplenoteEditText;
  76 import com.google.android.material.chip.Chip;
  77 import com.google.android.material.chip.ChipGroup;
  78 import com.google.android.material.snackbar.Snackbar;
  79 import com.simperium.client.Bucket;
  80 import com.simperium.client.BucketObjectMissingException;
  81 import com.simperium.client.Query;
  82 
  83 import java.lang.ref.WeakReference;
  84 import java.util.Calendar;
  85 
  86 import static com.automattic.simplenote.analytics.AnalyticsTracker.CATEGORY_NOTE;
  87 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_CHECKLIST_INSERTED;
  88 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_CONTENT_SHARED;
  89 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_EDITED;
  90 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_PUBLISHED;
  91 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_UNPUBLISHED;
  92 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_ADDED;
  93 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_REMOVED;
  94 import static com.automattic.simplenote.utils.SearchTokenizer.SPACE;
  95 import static com.automattic.simplenote.utils.SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX;
  96 
  97 public class NoteEditorFragment extends Fragment implements Bucket.Listener&lt;Note&gt;,
  98         TextWatcher, OnTagAddedListener, View.OnFocusChangeListener,
  99         SimplenoteEditText.OnSelectionChangedListener,
 100         ShareBottomSheetDialog.ShareSheetListener,
 101         HistoryBottomSheetDialog.HistorySheetListener,
 102         SimplenoteEditText.OnCheckboxToggledListener {
 103 
 104     public static final String ARG_IS_FROM_WIDGET = &quot;is_from_widget&quot;;
 105     public static final String ARG_ITEM_ID = &quot;item_id&quot;;
 106     public static final String ARG_NEW_NOTE = &quot;new_note&quot;;
 107     public static final String ARG_MATCH_OFFSETS = &quot;match_offsets&quot;;
 108     public static final String ARG_MARKDOWN_ENABLED = &quot;markdown_enabled&quot;;
 109     public static final String ARG_PREVIEW_ENABLED = &quot;preview_enabled&quot;;
 110     private static final String STATE_NOTE_ID = &quot;state_note_id&quot;;
 111     private static final int AUTOSAVE_DELAY_MILLIS = 2000;
 112     private static final int MAX_REVISIONS = 30;
 113     private static final int PUBLISH_TIMEOUT = 20000;
 114     private static final int HISTORY_TIMEOUT = 10000;
 115     private Note mNote;
 116     private final Runnable mAutoSaveRunnable = new Runnable() {
 117         @Override
 118         public void run() {
 119             saveAndSyncNote();
 120         }
 121     };
 122     private Bucket&lt;Note&gt; mNotesBucket;
 123     private View mRootView;
 124     private View mTagPadding;
 125     private SimplenoteEditText mContentEditText;
 126     private ChipGroup mTagChips;
 127     private TagsMultiAutoCompleteTextView mTagInput;
 128     private Handler mAutoSaveHandler;
 129     private Handler mPublishTimeoutHandler;
 130     private Handler mHistoryTimeoutHandler;
 131     private LinearLayout mPlaceholderView;
 132     private CursorAdapter mAutocompleteAdapter;
 133     private boolean mIsLoadingNote;
 134     private boolean mIsMarkdownEnabled;
 135     private boolean mIsPreviewEnabled;
 136     private boolean mShouldScrollToSearchMatch;
 137     private ActionMode mActionMode;
 138     private MenuItem mChecklistMenuItem;
 139     private MenuItem mCopyMenuItem;
 140     private MenuItem mInformationMenuItem;
 141     private MenuItem mShareMenuItem;
 142     private MenuItem mViewLinkMenuItem;
 143     private String mLinkUrl;
 144     private String mLinkText;
 145     private MatchOffsetHighlighter mHighlighter;
 146     private Drawable mBrowserIcon;
 147     private Drawable mCallIcon;
 148     private Drawable mCopyIcon;
 149     private Drawable mEmailIcon;
 150     private Drawable mLinkIcon;
 151     private Drawable mMapIcon;
 152     private Drawable mShareIcon;
 153     private MatchOffsetHighlighter.SpanFactory mMatchHighlighter;
 154     private String mMatchOffsets;
 155     private int mCurrentCursorPosition;
 156     private HistoryBottomSheetDialog mHistoryBottomSheet;
 157     private boolean mIsPaused;
 158     private boolean mIsFromWidget;
 159 
 160     // Hides the history bottom sheet if no revisions are loaded
 161     private final Runnable mHistoryTimeoutRunnable = new Runnable() {
 162         @Override
 163         public void run() {
 164             if (!isAdded()) {
 165                 return;
 166             }
 167 
 168             requireActivity().runOnUiThread(new Runnable() {
 169                 @Override
 170                 public void run() {
<abbr title=" 171                     if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; !mHistoryBottomSheet.isHistoryLoaded()) {"> 171                     if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowðŸ”µ</abbr>
 172                         mHistoryBottomSheet.dismiss();
 173                         Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 174                     }
 175                 }
 176             });
 177         }
 178     };
 179     private InfoBottomSheetDialog mInfoBottomSheet;
 180     private ShareBottomSheetDialog mShareBottomSheet;
 181     // Contextual action bar for dealing with links
 182     private final ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
 183         // Called when the action mode is created; startActionMode() was called
 184         @Override
 185         public boolean onCreateActionMode(ActionMode mode, Menu menu) {
 186             // Inflate a menu resource providing context menu items
 187             MenuInflater inflater = mode.getMenuInflater();
 188 
 189             if (inflater != null) {
 190                 inflater.inflate(R.menu.view_link, menu);
 191                 mCopyMenuItem = menu.findItem(R.id.menu_copy);
 192                 mShareMenuItem = menu.findItem(R.id.menu_share);
 193                 mViewLinkMenuItem = menu.findItem(R.id.menu_view_link);
 194                 mode.setTitle(getString(R.string.link));
 195                 mode.setTitleOptionalHint(false);
 196 
 197                 DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 198             }
 199 
<abbr title=" 200             requireActivity().getWindow().setStatusBarColor(ThemeUtils.getColorFromAttribute(requireContext(), R.attr.mainBackgroundColor));"> 200             requireActivity().getWindow().setStatusBarColor(ThemeUtils.getColorFromAttribute(requireConteðŸ”µ</abbr>
 201             return true;
 202         }
 203 
 204         // Called each time the action mode is shown. Always called after onCreateActionMode, but
 205         // may be called multiple times if the mode is invalidated.
 206         @Override
 207         public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 208             return false; // Return false if nothing is done
 209         }
 210 
 211         // Called when the user selects a contextual menu item
 212         @Override
 213         public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 214             switch (item.getItemId()) {
 215                 case R.id.menu_view_link:
 216                     if (mLinkText != null) {
 217                         if (mLinkText.startsWith(SIMPLENOTE_LINK_PREFIX)) {
<abbr title=" 218                             SimplenoteLinkify.openNote(requireActivity(), mLinkText.replace(SIMPLENOTE_LINK_PREFIX, &quot;&quot;));"> 218                             SimplenoteLinkify.openNote(requireActivity(), mLinkText.replace(SIMPLENOTE_LIðŸ”µ</abbr>
 219                         } else {
 220                             try {
 221                                 BrowserUtils.launchBrowserOrShowError(requireContext(), mLinkText);
 222                             } catch (Exception e) {
 223                                 e.printStackTrace();
 224                             }
 225                         }
 226 
 227                         mode.finish(); // Action picked, so close the CAB
 228                     }
 229 
 230                     return true;
 231                 case R.id.menu_copy:
 232                     if (mLinkText != null &amp;&amp; getActivity() != null) {
 233                         if (BrowserUtils.copyToClipboard(requireContext(), mLinkText)) {
 234                             Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 235                         } else {
<abbr title=" 236                             Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();"> 236                             Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT)ðŸ”µ</abbr>
 237                         }
 238 
 239                         mode.finish();
 240                     }
 241 
 242                     return true;
 243                 case R.id.menu_share:
 244                     if (mLinkText != null) {
 245                         showShare(mLinkText);
 246                         mode.finish();
 247                     }
 248 
 249                     return true;
 250                 default:
 251                     return false;
 252             }
 253         }
 254 
 255         // Called when the user exits the action mode
 256         @Override
 257         public void onDestroyActionMode(ActionMode mode) {
 258             if (mActionMode != null) {
 259                 mActionMode.setSubtitle(&quot;&quot;);
 260                 mActionMode = null;
 261             }
 262 
 263             new Handler().postDelayed(
 264                 new Runnable() {
 265                     @Override
 266                     public void run() {
<abbr title=" 267                         requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 267                         requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.RðŸ”µ</abbr>
 268                     }
 269                 },
 270                 requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime)
 271             );
 272         }
 273     };
 274     private Snackbar mPublishingSnackbar;
 275     private boolean mHideActionOnSuccess;
 276     // Resets note publish status if Simperium never returned the new publish status
 277     private final Runnable mPublishTimeoutRunnable = new Runnable() {
 278         @Override
 279         public void run() {
 280             if (!isAdded()) return;
 281 
 282             requireActivity().runOnUiThread(new Runnable() {
 283                 @Override
 284                 public void run() {
 285 
 286                     mNote.setPublished(!mNote.isPublished());
 287                     mNote.save();
 288 
 289                     updatePublishedState(false);
 290                 }
 291             });
 292         }
 293     };
 294     private NoteMarkdownFragment mNoteMarkdownFragment;
 295     private String mCss;
 296     private WebView mMarkdown;
 297 
 298     /**
 299      * Mandatory empty constructor for the fragment manager to instantiate the
 300      * fragment (e.g. upon screen orientation changes).
 301      */
 302     public NoteEditorFragment() {
 303     }
 304 
 305     @Override
 306     public void onCreate(Bundle savedInstanceState) {
 307         super.onCreate(savedInstanceState);
 308         AppLog.add(Type.NETWORK, NetworkUtils.getNetworkInfo(requireContext()));
 309         AppLog.add(Type.SCREEN, &quot;Created (NoteEditorFragment)&quot;);
 310         mInfoBottomSheet = new InfoBottomSheetDialog(this);
 311         mShareBottomSheet = new ShareBottomSheetDialog(this, this);
 312         mHistoryBottomSheet = new HistoryBottomSheetDialog(this, this);
 313 
 314         Simplenote currentApp = (Simplenote) requireActivity().getApplication();
 315         mNotesBucket = currentApp.getNotesBucket();
 316 
<abbr title=" 317         mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.actionModeTextColor);"> 317         mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp,ðŸ”µ</abbr>
<abbr title=" 318         mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.attr.actionModeTextColor);"> 318         mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.aðŸ”µ</abbr>
<abbr title=" 319         mLinkIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_note_24dp, R.attr.actionModeTextColor);"> 319         mLinkIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_note_24dp, R.attðŸ”µ</abbr>
<abbr title=" 320         mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.actionModeTextColor);"> 320         mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.ðŸ”µ</abbr>
<abbr title=" 321         mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp, R.attr.actionModeTextColor);"> 321         mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp,ðŸ”µ</abbr>
<abbr title=" 322         mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attr.actionModeTextColor);"> 322         mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attðŸ”µ</abbr>
<abbr title=" 323         mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.attr.actionModeTextColor);"> 323         mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.aðŸ”µ</abbr>
 324 
 325         mAutoSaveHandler = new Handler();
 326         mPublishTimeoutHandler = new Handler();
 327         mHistoryTimeoutHandler = new Handler();
 328 
 329         mMatchHighlighter = new TextHighlighter(requireActivity(),
<abbr title=" 330                 R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor);"> 330                 R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor)ðŸ”µ</abbr>
 331         mAutocompleteAdapter = new CursorAdapter(getActivity(), null, 0x0) {
 332             @Override
 333             public View newView(Context context, Cursor cursor, ViewGroup parent) {
 334                 Activity activity = (Activity) context;
 335                 if (activity == null) return null;
 336                 return activity.getLayoutInflater().inflate(R.layout.tag_autocomplete_list_item, null);
 337             }
 338 
 339             @Override
 340             public void bindView(View view, Context context, Cursor cursor) {
 341                 TextView textView = (TextView) view;
 342                 textView.setText(convertToString(cursor));
 343             }
 344 
 345             @Override
 346             public CharSequence convertToString(Cursor cursor) {
 347                 return cursor.getString(cursor.getColumnIndex(Tag.NAME_PROPERTY));
 348             }
 349 
 350             @Override
 351             public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 352                 Activity activity = getActivity();
 353                 if (activity == null) return null;
 354                 Simplenote application = (Simplenote) activity.getApplication();
 355                 Query&lt;Tag&gt; query = application.getTagsBucket().query();
 356                 // make the tag name available to the cursor
 357                 query.include(Tag.NAME_PROPERTY);
 358                 // sort the tags by their names
 359                 query.order(Tag.NAME_PROPERTY);
 360                 // if there&#x27;s a filter string find only matching tag names
 361                 if (filter != null)
<abbr title=" 362                     query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filter));"> 362                     query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filteðŸ”µ</abbr>
 363                 return query.execute();
 364             }
 365         };
 366 
 367         WidgetUtils.updateNoteWidgets(requireActivity().getApplicationContext());
 368     }
 369 
 370     @Override
<abbr title=" 371     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {"> 371     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceSðŸ”µ</abbr>
 372         mRootView = inflater.inflate(R.layout.fragment_note_editor, container, false);
 373         mContentEditText = mRootView.findViewById(R.id.note_content);
 374         mContentEditText.addOnSelectionChangedListener(this);
 375         mContentEditText.setOnCheckboxToggledListener(this);
 376         mContentEditText.setMovementMethod(SimplenoteMovementMethod.getInstance());
 377         mContentEditText.setOnFocusChangeListener(this);
<abbr title=" 378         mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()));"> 378         mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()))ðŸ”µ</abbr>
 379         mTagInput = mRootView.findViewById(R.id.tag_input);
 380         mTagInput.setDropDownBackgroundResource(R.drawable.bg_list_popup);
 381         mTagInput.setTokenizer(new SpaceTokenizer());
 382         mTagInput.setOnFocusChangeListener(this);
 383         mTagChips = mRootView.findViewById(R.id.tag_chips);
 384         mTagPadding = mRootView.findViewById(R.id.tag_padding);
 385         mHighlighter = new MatchOffsetHighlighter(mMatchHighlighter, mContentEditText);
 386         mPlaceholderView = mRootView.findViewById(R.id.placeholder);
 387 
 388         if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote == null) {
 389             mPlaceholderView.setVisibility(View.VISIBLE);
 390             requireActivity().invalidateOptionsMenu();
 391             mMarkdown = mRootView.findViewById(R.id.markdown);
 392 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 393             mCss = ContextUtils.readCssFile(requireContext(), ThemeUtils.getCssFromStyle(requireContext()));"> 393             mCss = ContextUtils.readCssFile(requireContext(), ThemeUtils.getCssFromStyle(requireContext()ðŸ”µ</abbr></span>
 394 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 395             mMarkdown = mRootView.findViewById(R.id.markdown);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 396             mCss = ThemeUtils.isLightTheme(requireContext())</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 397                     ? ContextUtils.readCssFile(requireContext(), &quot;light.css&quot;)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 398                     : ContextUtils.readCssFile(requireContext(), &quot;dark.css&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 399         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 400 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 401         mTagInput.setAdapter(mAutocompleteAdapter);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 402         Bundle arguments = getArguments();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 403 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 404         if (arguments != null &amp;&amp; arguments.containsKey(ARG_ITEM_ID)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 405             // Load note if we were passed a note Id</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 406             String key = arguments.getString(ARG_ITEM_ID);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 407 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 408             if (arguments.containsKey(ARG_MATCH_OFFSETS)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 409                 mMatchOffsets = arguments.getString(ARG_MATCH_OFFSETS);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 410             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 411 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 412             mIsFromWidget = arguments.getBoolean(ARG_IS_FROM_WIDGET);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 413 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 414             if (mIsFromWidget) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 415                 AppLog.add(Type.ACTION, &quot;Opened from widget (NoteEditorFragment)&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 416             } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 417                 AppLog.add(Type.ACTION, &quot;Opened from list (NoteEditorFragment)&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 418             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 419 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 420             new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, key);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 421         } else if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; savedInstanceState != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 422             // Restore selected note when in dual pane mode</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 423             String noteId = savedInstanceState.getString(STATE_NOTE_ID);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 424 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 425             if (noteId != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 426                 setNote(noteId);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 427             }</span>
 428 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 429             mMarkdown.setWebViewClient(</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 430                 new WebViewClient() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 431                     @Override</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 432                     public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request){</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 433                         String url = request.getUrl().toString();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 434 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 435                         if (url.startsWith(SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX)){</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 436                             SimplenoteLinkify.openNote(requireActivity(), url.replace(SIMPLENOTE_LINK_PREFIX, &quot;&quot;));"> 436                             SimplenoteLinkify.openNote(requireActivity(), url.replace(SIMPLENOTE_LINK_PREðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 437                         } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 438                             BrowserUtils.launchBrowserOrShowError(requireContext(), url);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 439                         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 440 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 441                         return true;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 442                     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 443                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 444             );</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 445             mCss = ThemeUtils.isLightTheme(requireContext())</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 446                 ? ContextUtils.readCssFile(requireContext(), &quot;light.css&quot;)</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 447                 : ContextUtils.readCssFile(requireContext(), &quot;dark.css&quot;);</span>
 448 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 449         }
 450 
 451         mTagInput.setAdapter(mAutocompleteAdapter);
 452         Bundle arguments = getArguments();
 453 
 454         if (arguments != null &amp;&amp; arguments.containsKey(ARG_ITEM_ID)) {
 455             // Load note if we were passed a note Id
 456             String key = arguments.getString(ARG_ITEM_ID);
 457 
 458             if (arguments.containsKey(ARG_MATCH_OFFSETS)) {
 459                 mMatchOffsets = arguments.getString(ARG_MATCH_OFFSETS);
 460             }
 461 
 462             mIsFromWidget = arguments.getBoolean(ARG_IS_FROM_WIDGET);
 463 
 464             if (mIsFromWidget) {
 465                 AppLog.add(Type.ACTION, &quot;Opened from widget (NoteEditorFragment)&quot;);
 466             } else {
 467                 AppLog.add(Type.ACTION, &quot;Opened from list (NoteEditorFragment)&quot;);
 468             }
 469 
 470             new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, key);
 471         } else if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; savedInstanceState != null) {
 472             // Restore selected note when in dual pane mode
 473             String noteId = savedInstanceState.getString(STATE_NOTE_ID);
 474 
 475             if (noteId != null) {
 476                 setNote(noteId);
 477             }
 478         }
 479 
 480         ViewTreeObserver viewTreeObserver = mContentEditText.getViewTreeObserver();
 481         viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
 482             @Override
 483             public void onGlobalLayout() {
 484                 // If a note was loaded with search matches, scroll to the first match in the editor
 485                 if (mShouldScrollToSearchMatch &amp;&amp; mMatchOffsets != null) {
 486                     if (!isAdded()) {
 487                         return;
 488                     }
 489 
 490                     // Get the character location of the first search match
 491                     int matchLocation = MatchOffsetHighlighter.getFirstMatchLocation(
 492                             mContentEditText.getText(),
 493                             mMatchOffsets
 494                     );
 495                     if (matchLocation == 0) {
 496                         return;
 497                     }
 498 
 499                     // Calculate how far to scroll to bring the match into view
 500                     Layout layout = mContentEditText.getLayout();
 501                     int lineTop = layout.getLineTop(layout.getLineForOffset(matchLocation));
 502                     ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 503                     mShouldScrollToSearchMatch = false;
 504                 }
 505             }
 506         });
 507         setHasOptionsMenu(true);
 508         return mRootView;
 509     }
 510 
 511     public void scrollToMatch(int location) {
 512         if (isAdded()) {
 513             // Calculate how far to scroll to bring the match into view
 514             Layout layout = mContentEditText.getLayout();
 515             int lineTop = layout.getLineTop(layout.getLineForOffset(location));
 516             ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 517         }
 518     }
 519 
 520     @Override
 521     public void onResume() {
 522         super.onResume();
 523         mNotesBucket.start();
 524         AppLog.add(Type.SYNC, &quot;Started note bucket (NoteEditorFragment)&quot;);
 525         mNotesBucket.addListener(this);
 526         mTagInput.setOnTagAddedListener(this);
 527 
 528         if (mContentEditText != null) {
<abbr title=" 529             mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()));"> 529             mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContextðŸ”µ</abbr>
 530 
 531             if (mContentEditText.hasFocus()) {
 532                 showSoftKeyboard();
 533             }
 534         }
 535     }
 536 
 537     private void showSoftKeyboard() {
 538         new Handler().postDelayed(new Runnable() {
 539             @Override
 540             public void run() {
 541                 if (getActivity() == null) {
 542                     return;
 543                 }
 544 
<abbr title=" 545                 InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);"> 545                 InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemServiðŸ”µ</abbr>
 546                 if (inputMethodManager != null) {
 547                     inputMethodManager.showSoftInput(mContentEditText, 0);
 548                 }
 549             }
 550         }, 100);
 551     }
 552 
 553     @Override
 554     public void onPause() {
 555         super.onPause();  // Always call the superclass method first
 556         mIsPaused = true;
 557 
 558         // Hide soft keyboard if it is showing...
 559         DisplayUtils.hideKeyboard(mContentEditText);
 560 
 561         mTagInput.setOnTagAddedListener(null);
 562 
 563         if (mAutoSaveHandler != null) {
 564             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 565             mAutoSaveHandler.post(mAutoSaveRunnable);
 566         }
 567 
 568         if (mPublishTimeoutHandler != null) {
 569             mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
 570         }
 571 
 572         if (mHistoryTimeoutHandler != null) {
 573             mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 574         }
 575 
 576         mHighlighter.stop();
 577         saveNote();
 578         AppLog.add(Type.SCREEN, &quot;Paused (NoteEditorFragment)&quot;);
 579     }
 580 
 581     @Override
 582     public void onDestroy() {
 583         super.onDestroy();
 584         mNotesBucket.removeListener(this);
 585         mNotesBucket.stop();
 586         AppLog.add(Type.SYNC, &quot;Stopped note bucket (NoteEditorFragment)&quot;);
 587         AppLog.add(Type.SCREEN, &quot;Destroyed (NoteEditorFragment)&quot;);
 588     }
 589 
 590     @Override
 591     public void onSaveInstanceState(@NonNull Bundle outState) {
 592         super.onSaveInstanceState(outState);
 593 
 594         if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote != null) {
 595             outState.putString(STATE_NOTE_ID, mNote.getSimperiumKey());
 596         }
 597     }
 598 
 599     @Override
 600     public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
 601         super.onCreateOptionsMenu(menu, inflater);
 602 
<abbr title=" 603         if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFragment == null)) {"> 603         if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMðŸ”µ</abbr>
 604             return;
 605         }
 606 
 607         inflater.inflate(R.menu.note_editor, menu);
 608         MenuCompat.setGroupDividerEnabled(menu, true);
 609     }
 610 
 611     @Override
 612     public boolean onOptionsItemSelected(@NonNull MenuItem item) {
 613         switch (item.getItemId()) {
 614             case R.id.menu_checklist:
 615                 insertChecklist();
 616                 return true;
 617             case R.id.menu_copy:
 618                 if (BrowserUtils.copyToClipboard(requireContext(), mNote.getPublishedUrl())) {
 619                     Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 620                 } else {
 621                     Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();
 622                 }
 623 
 624                 return true;
 625             case R.id.menu_copy_internal:
<abbr title=" 626                 if (BrowserUtils.copyToClipboard(requireContext(), SimplenoteLinkify.getNoteLinkWithTitle(mNote.getTitle(), mNote.getSimperiumKey()))) {"> 626                 if (BrowserUtils.copyToClipboard(requireContext(), SimplenoteLinkify.getNoteLinkWithTitleðŸ”µ</abbr>
 627                     Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 628                 } else {
 629                     Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();
 630                 }
 631 
 632                 return true;
 633             case R.id.menu_history:
 634                 showHistory();
 635                 return true;
 636             case R.id.menu_info:
 637                 showInfo();
 638                 return true;
 639             case R.id.menu_markdown:
 640                 setMarkdown(!item.isChecked());
 641                 return true;
 642             case R.id.menu_pin:
 643                 NoteUtils.setNotePin(mNote, !item.isChecked());
 644                 requireActivity().invalidateOptionsMenu();
 645                 return true;
 646             case R.id.menu_publish:
 647                 if (item.isChecked()) {
 648                     unpublishNote();
 649                 } else {
 650                     publishNote();
 651                 }
 652 
 653                 return true;
 654             case R.id.menu_share:
 655                 shareNote();
 656                 return true;
 657             case R.id.menu_trash:
 658                 if (!isAdded()) {
 659                     return false;
 660                 }
 661 
 662                 deleteNote();
 663                 return true;
 664             case android.R.id.home:
 665                 AppLog.add(Type.ACTION, &quot;Tapped back arrow in app bar (NoteEditorFragment)&quot;);
 666                 if (!isAdded()) {
 667                     return false;
 668                 }
 669 
 670                 requireActivity().finish();
 671                 return true;
 672             default:
 673                 return super.onOptionsItemSelected(item);
 674         }
 675     }
 676 
 677     @Override
 678     public void onPrepareOptionsMenu(@NonNull Menu menu) {
 679         if (mNote != null) {
 680             MenuItem pinItem = menu.findItem(R.id.menu_pin);
 681             MenuItem shareItem = menu.findItem(R.id.menu_share);
 682             MenuItem historyItem = menu.findItem(R.id.menu_history);
 683             MenuItem publishItem = menu.findItem(R.id.menu_publish);
 684             MenuItem copyLinkItem = menu.findItem(R.id.menu_copy);
 685             MenuItem markdownItem = menu.findItem(R.id.menu_markdown);
 686             MenuItem trashItem = menu.findItem(R.id.menu_trash);
 687             mChecklistMenuItem = menu.findItem(R.id.menu_checklist);
 688             mInformationMenuItem = menu.findItem(R.id.menu_info).setVisible(true);
 689 
 690             pinItem.setChecked(mNote.isPinned());
 691             publishItem.setChecked(mNote.isPublished());
 692             markdownItem.setChecked(mNote.isMarkdownEnabled());
 693 
 694             // Disable actions when note is in Trash or markdown view is shown on large device.
 695             if (mNote.isDeleted() || (mMarkdown != null &amp;&amp; mMarkdown.getVisibility() == View.VISIBLE)) {
 696                 pinItem.setEnabled(false);
 697                 shareItem.setEnabled(false);
 698                 historyItem.setEnabled(false);
 699                 publishItem.setEnabled(false);
 700                 copyLinkItem.setEnabled(false);
 701                 markdownItem.setEnabled(false);
 702                 mChecklistMenuItem.setEnabled(false);
 703                 DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 0.3);  // 0.3 is 30% opacity.
 704             } else {
 705                 pinItem.setEnabled(true);
 706                 shareItem.setEnabled(true);
 707                 historyItem.setEnabled(true);
 708                 publishItem.setEnabled(true);
 709                 copyLinkItem.setEnabled(mNote.isPublished());
 710                 markdownItem.setEnabled(true);
 711                 mChecklistMenuItem.setEnabled(true);
 712                 DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 1.0);  // 1.0 is 100% opacity.
 713             }
 714 
 715             if (mNote.isDeleted()) {
 716                 trashItem.setTitle(R.string.restore);
 717             } else {
 718                 trashItem.setTitle(R.string.trash);
 719             }
 720         }
 721 
 722         DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 723         super.onPrepareOptionsMenu(menu);
 724     }
 725 
 726     public void insertChecklist() {
 727         DrawableUtils.startAnimatedVectorDrawable(mChecklistMenuItem.getIcon());
 728 
 729         try {
 730             mContentEditText.insertChecklist();
 731         } catch (Exception e) {
 732             e.printStackTrace();
 733             return;
 734         }
 735 
 736         AnalyticsTracker.track(
 737             EDITOR_CHECKLIST_INSERTED,
 738             CATEGORY_NOTE,
 739             &quot;toolbar_button&quot;
 740         );
 741     }
 742 
 743     @Override
 744     public void onCheckboxToggled() {
 745         // Save note (using delay) after toggling a checkbox
 746         if (mAutoSaveHandler != null) {
 747             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 748             mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 749         }
 750     }
 751 
 752     private void deleteNote() {
 753         NoteUtils.deleteNote(mNote, getActivity());
 754         requireActivity().finish();
 755     }
 756 
 757     protected void clearMarkdown() {
 758         mMarkdown.loadDataWithBaseURL(&quot;file:///android_asset/&quot;, mCss + &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 759     }
 760 
 761     protected void hideMarkdown() {
 762         mMarkdown.setVisibility(View.INVISIBLE);
 763     }
 764 
 765     protected void showMarkdown() {
 766         loadMarkdownData();
 767         mMarkdown.setVisibility(View.VISIBLE);
 768 
 769         new Handler().postDelayed(
 770             new Runnable() {
 771                 @Override
 772                 public void run() {
 773                     requireActivity().invalidateOptionsMenu();
 774                 }
 775             },
 776             getResources().getInteger(R.integer.time_animation)
 777         );
 778     }
 779 
 780     public void shareNote() {
 781         if (mNote != null) {
 782             mContentEditText.clearFocus();
 783             showShareSheet();
 784             AnalyticsTracker.track(
 785                 EDITOR_NOTE_CONTENT_SHARED,
 786                 CATEGORY_NOTE,
 787                 &quot;action_bar_share_button&quot;
 788             );
 789         }
 790     }
 791 
 792     public void showHistory() {
 793         if (mNote != null &amp;&amp; mNote.getVersion() &gt; 1) {
 794             mContentEditText.clearFocus();
 795             mHistoryTimeoutHandler.postDelayed(mHistoryTimeoutRunnable, HISTORY_TIMEOUT);
 796             showHistorySheet();
 797         } else {
 798             Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 799         }
 800     }
 801 
 802     public void showInfo() {
 803         DrawableUtils.startAnimatedVectorDrawable(mInformationMenuItem.getIcon());
 804 
 805         if (mNote != null) {
 806             mContentEditText.clearFocus();
 807             saveNote();
 808             showInfoSheet();
 809         }
 810     }
 811 
 812     private void setMarkdown(boolean isChecked) {
 813         mIsMarkdownEnabled = isChecked;
 814         showMarkdownActionOrTabs();
 815         saveNote();
 816 
 817         // Set preference so that next new note will have markdown enabled.
 818         SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(requireContext());
 819         SharedPreferences.Editor editor = prefs.edit();
 820         editor.putBoolean(PrefUtils.PREF_MARKDOWN_ENABLED, isChecked);
 821         editor.apply();
 822     }
 823 
 824     private void setMarkdownEnabled(boolean enabled) {
 825         mIsMarkdownEnabled = enabled;
 826 
 827         if (mIsMarkdownEnabled) {
 828             loadMarkdownData();
 829         }
 830     }
 831 
 832     private void showMarkdownActionOrTabs() {
 833         Activity activity = getActivity();
 834 
 835         if (activity instanceof NoteEditorActivity) {
 836             NoteEditorActivity editorActivity = (NoteEditorActivity) activity;
 837 
 838             if (mIsMarkdownEnabled) {
 839                 editorActivity.showTabs();
 840 
 841                 if (mNoteMarkdownFragment == null) {
 842                     // Get markdown fragment and update content
 843                     mNoteMarkdownFragment = editorActivity.getNoteMarkdownFragment();
 844                     mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPreviewTextContent());
 845                 }
 846             } else {
 847                 editorActivity.hideTabs();
 848             }
 849         } else if (activity instanceof NotesActivity) {
 850             setMarkdownEnabled(mIsMarkdownEnabled);
 851             ((NotesActivity) getActivity()).setMarkdownShowing(false);
 852         }
 853     }
 854 
 855     private void loadMarkdownData() {
 856         String formattedContent = NoteMarkdownFragment.getMarkdownFormattedContent(
 857                 mCss,
 858                 mContentEditText.getPreviewTextContent()
 859         );
 860 
 861         mMarkdown.loadDataWithBaseURL(null, formattedContent, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 862     }
 863 
 864     public void setNote(String noteID, String matchOffsets) {
 865         if (mAutoSaveHandler != null)
 866             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 867 
 868         mPlaceholderView.setVisibility(View.GONE);
 869 
 870         if (matchOffsets != null) {
 871             mMatchOffsets = matchOffsets;
 872         } else {
 873             mMatchOffsets = null;
 874         }
 875 
 876 
 877         saveNote();
 878 
 879         new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteID);
 880     }
 881 
 882     private void updateNote(Note updatedNote) {
 883         // update note if network change arrived
 884         mNote = updatedNote;
 885         refreshContent(true);
 886     }
 887 
 888     private void refreshContent(boolean isNoteUpdate) {
 889         if (mNote != null) {
 890             // Restore the cursor position if possible.
<abbr title=" 891             int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.getSelectionEnd());"> 891             int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEdðŸ”µ</abbr>
 892             mContentEditText.setText(mNote.getContent());
 893 
 894             if (isNoteUpdate) {
 895                 // Update markdown and preview flags from updated note.
 896                 mIsMarkdownEnabled = mNote.isMarkdownEnabled();
 897                 mIsPreviewEnabled = mNote.isPreviewEnabled();
 898 
 899                 // Show/Hide action/tabs based on markdown flag.
 900                 showMarkdownActionOrTabs();
 901 
 902                 // Save note so any local changes get synced.
 903                 mNote.save();
 904 
 905                 // Update current note object on large screen devices in landscape orientation.
 906                 if (DisplayUtils.isLargeScreenLandscape(requireContext())) {
 907                     ((NotesActivity) requireActivity()).setCurrentNote(mNote);
 908                 }
 909 
 910                 // Update overflow popup menu.
 911                 requireActivity().invalidateOptionsMenu();
 912 
 913                 if (mContentEditText.hasFocus()
 914                         &amp;&amp; cursorPosition != mContentEditText.getSelectionEnd()
 915                         &amp;&amp; cursorPosition &lt; mContentEditText.getText().length()) {
 916                     mContentEditText.setSelection(cursorPosition);
 917                 }
 918             }
 919 
 920             afterTextChanged(mContentEditText.getText());
 921             mContentEditText.processChecklists();
 922             updateTagList();
 923         }
 924     }
 925 
 926     private void updateTagList() {
 927         setChips(mNote.getTagString());
 928         mTagInput.setText(&quot;&quot;);
 929     }
 930 
 931     private int newCursorLocation(String newText, String oldText, int cursorLocation) {
 932         // Ported from the iOS app :)
 933         // Cases:
 934         // 0. All text after cursor (and possibly more) was removed ==&gt; put cursor at end
 935         // 1. Text was added after the cursor ==&gt; no change
 936         // 2. Text was added before the cursor ==&gt; location advances
 937         // 3. Text was removed after the cursor ==&gt; no change
 938         // 4. Text was removed before the cursor ==&gt; location retreats
 939         // 5. Text was added/removed on both sides of the cursor ==&gt; not handled
 940 
 941         cursorLocation = Math.max(cursorLocation, 0);
 942 
 943         int newCursorLocation = cursorLocation;
 944 
 945         int deltaLength = newText.length() - oldText.length();
 946 
 947         // Case 0
 948         if (newText.length() &lt; cursorLocation)
 949             return newText.length();
 950 
 951         boolean beforeCursorMatches = false;
 952         boolean afterCursorMatches = false;
 953 
 954         try {
<abbr title=" 955             beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation));"> 955             beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorðŸ”µ</abbr>
<abbr title=" 956             afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaLength));"> 956             afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocatioðŸ”µ</abbr>
 957         } catch (Exception e) {
 958             e.printStackTrace();
 959         }
 960 
 961         // Cases 2 and 4
 962         if (!beforeCursorMatches &amp;&amp; afterCursorMatches)
 963             newCursorLocation += deltaLength;
 964 
 965         // Cases 1, 3 and 5 have no change
 966         return newCursorLocation;
 967     }
 968 
 969     @Override
 970     public void onTagAdded(String tag) {
 971         if (mNote == null || !isAdded()) {
 972             return;
 973         }
 974 
 975         if (mNote.getTagString() != null &amp;&amp; tag.length() &gt; mNote.getTagString().length()) {
 976             AnalyticsTracker.track(
 977                 EDITOR_TAG_ADDED,
 978                 CATEGORY_NOTE,
 979                 &quot;tag_added_to_note&quot;
 980             );
 981         }
 982 
 983         mNote.setTagString(mNote.getTagString() + String.valueOf(SPACE) + tag);
 984         mNote.setModificationDate(Calendar.getInstance());
 985         updateTagList();
 986         mNote.save();
 987     }
 988 
 989     @Override
 990     public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
 991         // Unused
 992     }
 993 
 994     @Override
 995     public void afterTextChanged(Editable editable) {
 996         attemptAutoList(editable);
 997         setTitleSpan(editable);
 998         mContentEditText.fixLineSpacing();
 999     }
1000 
1001     @Override
1002     public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
1003         // When text changes, start timer that will fire after AUTOSAVE_DELAY_MILLIS passes
1004         if (mAutoSaveHandler != null) {
1005             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
1006             mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
1007         }
1008 
1009         // Remove search highlight spans when note content changes
1010         if (mMatchOffsets != null) {
1011             mMatchOffsets = null;
1012             mHighlighter.removeMatches();
1013         }
1014 
1015         if (!DisplayUtils.isLargeScreenLandscape(requireContext())) {
1016             ((NoteEditorActivity) requireActivity()).setSearchMatchBarVisible(false);
1017         }
1018 
1019         // Temporarily remove the text watcher as we process checklists to prevent callback looping
1020         mContentEditText.removeTextChangedListener(this);
1021         mContentEditText.processChecklists();
1022         mContentEditText.addTextChangedListener(this);
1023     }
1024 
1025     /**
1026      * Set the note title to be a larger size and bold style.
1027      *
1028      * Remove all existing spans before applying spans or performance issues will occur.  Since both
1029      * {@link RelativeSizeSpan} and {@link StyleSpan} inherit from {@link MetricAffectingSpan}, all
1030      * spans are removed when {@link MetricAffectingSpan} is removed.
1031      */
1032     private void setTitleSpan(Editable editable) {
<abbr title="1033         for (MetricAffectingSpan span : editable.getSpans(0, editable.length(), MetricAffectingSpan.class)) {">1033         for (MetricAffectingSpan span : editable.getSpans(0, editable.length(), MetricAffectingSpan.classðŸ”µ</abbr>
1034             if (span instanceof RelativeSizeSpan || span instanceof StyleSpan) {
1035                 editable.removeSpan(span);
1036             }
1037         }
1038 
1039         int newLinePosition = getNoteContentString().indexOf(&quot;\n&quot;);
1040 
1041         if (newLinePosition == 0) {
1042             return;
1043         }
1044 
1045         int titleEndPosition = (newLinePosition &gt; 0) ? newLinePosition : editable.length();
<abbr title="1046         editable.setSpan(new RelativeSizeSpan(1.3f), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);">1046         editable.setSpan(new RelativeSizeSpan(1.3f), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVðŸ”µ</abbr>
<abbr title="1047         editable.setSpan(new StyleSpan(Typeface.BOLD), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);">1047         editable.setSpan(new StyleSpan(Typeface.BOLD), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSðŸ”µ</abbr>
1048     }
1049 
1050     private void attemptAutoList(Editable editable) {
1051         int oldCursorPosition = mCurrentCursorPosition;
1052         mCurrentCursorPosition = mContentEditText.getSelectionStart();
1053         AutoBullet.apply(editable, oldCursorPosition, mCurrentCursorPosition);
1054         mCurrentCursorPosition = mContentEditText.getSelectionStart();
1055     }
1056 
1057     private void saveAndSyncNote() {
1058         if (mNote == null) {
1059             return;
1060         }
1061 
1062         AppLog.add(
1063             Type.ACTION,
1064             &quot;Edited note (ID: &quot; + mNote.getSimperiumKey() +
1065                 &quot; / Title: &quot; + mNote.getTitle() +
1066                 &quot; / Characters: &quot; + NoteUtils.getCharactersCount(mNote.getContent()) +
1067                 &quot; / Words: &quot; + NoteUtils.getWordCount(mNote.getContent()) + &quot;)&quot;
1068         );
1069         new SaveNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
1070     }
1071 
1072     public boolean isPlaceholderVisible() {
1073         if (mPlaceholderView != null) {
1074             return mPlaceholderView.getVisibility() == View.VISIBLE;
1075         } else {
1076             return false;
1077         }
1078     }
1079 
1080     public void setPlaceholderVisible(boolean isVisible) {
1081         if (isVisible) {
1082             mNote = null;
1083             mContentEditText.setText(&quot;&quot;);
1084         }
1085 
1086         if (mPlaceholderView != null) {
1087             mPlaceholderView.setVisibility(isVisible ? View.VISIBLE : View.GONE);
1088         }
1089     }
1090 
1091     @Override
1092     public void onFocusChange(View v, boolean hasFocus) {
1093         if (!hasFocus) {
1094             String tags = getNoteTagsString().trim();
1095 
1096             if (mTagInput.getText().toString().trim().length() &gt; 0
1097                 &amp;&amp; TagUtils.hashTagValid(mTagInput.getText().toString().trim())) {
1098                 onTagAdded(mTagInput.getText().toString());
1099             } else if (tags.length() &gt; 0) {
1100                 setChips(tags);
1101             }
1102         }
1103     }
1104 
1105     private Note getNote() {
1106         return mNote;
1107     }
1108 
1109     public void setNote(String noteID) {
1110         setNote(noteID, null);
1111     }
1112 
1113     private String getNoteContentString() {
1114         if (mContentEditText == null || mContentEditText.getText() == null) {
1115             return &quot;&quot;;
1116         } else {
1117             return mContentEditText.getText().toString();
1118         }
1119     }
1120 
1121     private String getNoteTagsString() {
1122         StringBuilder tags = new StringBuilder();
1123 
1124         for (int i= 0; i &lt; mTagChips.getChildCount(); i++) {
1125             tags.append(((Chip) mTagChips.getChildAt(i)).getText()).append(&quot; &quot;);
1126         }
1127 
1128         return tags.toString();
1129     }
1130 
1131     /**
1132      * Share bottom sheet callbacks
1133      */
1134 
1135     @Override
1136     public void onSharePublishClicked() {
1137         publishNote();
1138         if (mShareBottomSheet != null) {
1139             mShareBottomSheet.dismiss();
1140         }
1141     }
1142 
1143     @Override
1144     public void onShareUnpublishClicked() {
1145         unpublishNote();
1146         if (mShareBottomSheet != null) {
1147             mShareBottomSheet.dismiss();
1148         }
1149     }
1150 
1151     @Override
1152     public void onWordPressPostClicked() {
1153         if (mShareBottomSheet != null) {
1154             mShareBottomSheet.dismiss();
1155         }
1156 
1157         if (getFragmentManager() == null) {
1158             return;
1159         }
1160 
1161         FragmentTransaction ft = getFragmentManager().beginTransaction();
1162         Fragment prev = getFragmentManager().findFragmentByTag(WordPressDialogFragment.DIALOG_TAG);
1163         if (prev != null) {
1164             ft.remove(prev);
1165         }
1166         ft.addToBackStack(null);
1167 
1168         // Create and show the dialog.
1169         WordPressDialogFragment wpDialogFragment = new WordPressDialogFragment();
1170         wpDialogFragment.setNote(mNote);
1171         wpDialogFragment.show(ft, WordPressDialogFragment.DIALOG_TAG);
1172     }
1173 
1174     @Override
1175     public void onShareCollaborateClicked() {
1176         Toast.makeText(getActivity(), R.string.collaborate_message, Toast.LENGTH_LONG).show();
1177     }
1178 
1179     @Override
1180     public void onShareDismissed() {
1181 
1182     }
1183 
1184     /**
1185      * History bottom sheet listeners
1186      */
1187 
1188     @Override
1189     public void onHistoryCancelClicked() {
1190         mContentEditText.setText(mNote.getContent());
1191         if (mHistoryBottomSheet != null) {
1192             mHistoryBottomSheet.dismiss();
1193         }
1194     }
1195 
1196     @Override
1197     public void onHistoryRestoreClicked() {
1198         if (mHistoryBottomSheet != null) {
1199             mHistoryBottomSheet.dismiss();
1200         }
1201         saveAndSyncNote();
1202     }
1203 
1204     @Override
1205     public void onHistoryDismissed() {
1206         if (!mHistoryBottomSheet.didTapOnButton()) {
1207             mContentEditText.setText(mNote.getContent());
1208         }
1209 
1210         if (mHistoryTimeoutHandler != null) {
1211             mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
1212         }
1213     }
1214 
1215     @Override
1216     public void onHistoryUpdateNote(String content) {
1217         mContentEditText.setText(content);
1218     }
1219 
1220     private void saveNote() {
1221         try {
1222             if (mNote == null || mNotesBucket == null || mContentEditText == null || mIsLoadingNote ||
<abbr title="1223                 (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing())) {">1223                 (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomðŸ”µ</abbr>
1224                 return;
1225             } else {
1226                 mNote = mNotesBucket.get(mNote.getSimperiumKey());
1227                 mIsPreviewEnabled = mNote.isPreviewEnabled();
1228             }
1229 
1230             String content = mContentEditText.getPlainTextContent();
1231             String tagString = getNoteTagsString();
1232 
<abbr title="1233             if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnabled)) {">1233             if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPrevðŸ”µ</abbr>
1234                 mNote.setContent(content);
1235                 mNote.setTagString(tagString);
1236                 mNote.setModificationDate(Calendar.getInstance());
1237                 mNote.setMarkdownEnabled(mIsMarkdownEnabled);
1238                 mNote.setPreviewEnabled(mIsPreviewEnabled);
1239                 mNote.save();
1240 
1241                 AnalyticsTracker.track(
1242                     EDITOR_NOTE_EDITED,
1243                     CATEGORY_NOTE,
1244                     &quot;editor_save&quot;
1245                 );
1246 
1247                 AppLog.add(
1248                     Type.SYNC,
1249                     &quot;Saved note locally in NoteEditorFragment (ID: &quot; + mNote.getSimperiumKey() +
1250                         &quot; / Title: &quot; + mNote.getTitle() +
1251                         &quot; / Characters: &quot; + NoteUtils.getCharactersCount(content) +
1252                         &quot; / Words: &quot; + NoteUtils.getWordCount(content) + &quot;)&quot;
1253                 );
1254             }
1255         } catch (BucketObjectMissingException exception) {
1256             exception.printStackTrace();
1257         }
1258     }
1259 
1260     // Checks if cursor is at a URL when the selection changes
1261     // If it is a URL, show the contextual action bar
1262     @Override
1263     public void onSelectionChanged(int selStart, int selEnd) {
1264         mCurrentCursorPosition = selEnd;
1265 
1266         if (selStart == selEnd) {
1267             Editable noteContent = mContentEditText.getText();
1268 
1269             if (noteContent == null) {
1270                 return;
1271             }
1272 
1273             URLSpan[] urlSpans = noteContent.getSpans(selStart, selStart, URLSpan.class);
1274 
1275             if (urlSpans.length &gt; 0) {
1276                 URLSpan urlSpan = urlSpans[0];
1277                 mLinkUrl = urlSpan.getURL();
<abbr title="1278                 mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSpan)).toString();">1278                 mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpaðŸ”µ</abbr>
1279 
1280                 if (mActionMode != null) {
1281                     mActionMode.setSubtitle(mLinkText);
1282                     updateMenuItems();
1283                     return;
1284                 }
1285 
1286                 // Show the Contextual Action Bar
1287                 if (getActivity() != null) {
<abbr title="1288                     mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCallback);">1288                     mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCðŸ”µ</abbr>
1289 
1290                     if (mActionMode != null) {
1291                         mActionMode.setSubtitle(mLinkText);
1292                     }
1293 
1294                     updateMenuItems();
1295                 }
1296             } else if (mActionMode != null) {
1297                 mActionMode.finish();
1298                 mActionMode = null;
1299             }
1300         } else if (mActionMode != null) {
1301             mActionMode.finish();
1302             mActionMode = null;
1303         }
1304     }
1305 
1306     private void updateMenuItems() {
1307         mCopyMenuItem.setIcon(mCopyIcon);
1308         mShareMenuItem.setIcon(mShareIcon);
1309 
1310         if (mViewLinkMenuItem != null &amp;&amp; mLinkUrl != null) {
1311             if (mLinkUrl.startsWith(&quot;tel:&quot;)) {
1312                 mViewLinkMenuItem.setIcon(mCallIcon);
1313                 mViewLinkMenuItem.setTitle(getString(R.string.call));
1314             } else if (mLinkUrl.startsWith(&quot;mailto:&quot;)) {
1315                 mViewLinkMenuItem.setIcon(mEmailIcon);
1316                 mViewLinkMenuItem.setTitle(getString(R.string.email));
1317             } else if (mLinkUrl.startsWith(&quot;geo:&quot;)) {
1318                 mViewLinkMenuItem.setIcon(mMapIcon);
1319                 mViewLinkMenuItem.setTitle(getString(R.string.view_map));
1320             } else if (mLinkUrl.startsWith(SIMPLENOTE_LINK_PREFIX)) {
1321                 mViewLinkMenuItem.setIcon(mLinkIcon);
1322                 mViewLinkMenuItem.setTitle(getString(R.string.open_note));
1323             } else {
1324                 mViewLinkMenuItem.setIcon(mBrowserIcon);
1325                 mViewLinkMenuItem.setTitle(getString(R.string.view_in_browser));
1326             }
1327         }
1328     }
1329 
1330     private void setPublishedNote(boolean isPublished) {
1331         if (mNote != null) {
1332             mNote.setPublished(isPublished);
1333             mNote.save();
1334 
1335             // reset publish status in 20 seconds if we don&#x27;t hear back from Simperium
1336             mPublishTimeoutHandler.postDelayed(mPublishTimeoutRunnable, PUBLISH_TIMEOUT);
1337 
1338             AnalyticsTracker.track(
1339                 isPublished ? EDITOR_NOTE_PUBLISHED : EDITOR_NOTE_UNPUBLISHED,
1340                 CATEGORY_NOTE,
1341                 &quot;publish_note_button&quot;
1342             );
1343         }
1344     }
1345 
1346     private void updatePublishedState(boolean isSuccess) {
1347         if (mPublishingSnackbar == null) {
1348             return;
1349         }
1350 
1351         mPublishingSnackbar.dismiss();
1352         mPublishingSnackbar = null;
1353 
1354         if (isSuccess &amp;&amp; isAdded()) {
1355             if (mNote.isPublished()) {
1356                 @StringRes int text;
1357 
1358                 if (BrowserUtils.copyToClipboard(requireContext(), mNote.getPublishedUrl())) {
1359                     text = R.string.publish_successful_link;
1360                 } else {
1361                     text = R.string.publish_successful;
1362                 }
1363 
1364                 if (mHideActionOnSuccess) {
1365                     Snackbar.make(mRootView, text, Snackbar.LENGTH_LONG).show();
1366                 } else {
1367                     Snackbar.make(mRootView, text, Snackbar.LENGTH_LONG)
1368                         .setAction(
1369                             R.string.undo,
1370                             new View.OnClickListener() {
1371                                 @Override
1372                                 public void onClick(View v) {
1373                                     mHideActionOnSuccess = true;
1374                                     unpublishNote();
1375                                 }
1376                             }
1377                         )
1378                         .show();
1379                 }
1380             } else {
1381                 if (mHideActionOnSuccess) {
1382                     Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG)
1383                             .show();
1384                 } else {
1385                     Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG)
1386                             .setAction(
1387                                 R.string.undo,
1388                                 new View.OnClickListener() {
1389                                     @Override
1390                                     public void onClick(View v) {
1391                                         mHideActionOnSuccess = true;
1392                                         publishNote();
1393                                     }
1394                                 }
1395                             )
1396                             .show();
1397                 }
1398             }
1399         } else {
1400             if (mNote.isPublished()) {
1401                 Snackbar.make(mRootView, R.string.unpublish_error, Snackbar.LENGTH_LONG)
1402                         .setAction(
1403                             R.string.retry,
1404                             new View.OnClickListener() {
1405                                 @Override
1406                                 public void onClick(View v) {
1407                                     mHideActionOnSuccess = true;
1408                                     unpublishNote();
1409                                 }
1410                             }
1411                         ).show();
1412             } else {
1413                 Snackbar.make(mRootView, R.string.publish_error, Snackbar.LENGTH_LONG)
1414                         .setAction(
1415                             R.string.retry,
1416                             new View.OnClickListener() {
1417                                 @Override
1418                                 public void onClick(View v) {
1419                                     mHideActionOnSuccess = true;
1420                                     publishNote();
1421                                 }
1422                             }
1423                         ).show();
1424             }
1425         }
1426 
1427         mHideActionOnSuccess = false;
1428         requireActivity().invalidateOptionsMenu();
1429     }
1430 
1431     private void publishNote() {
1432         if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1433             Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1434             return;
1435         }
1436 
1437         if (isAdded()) {
<abbr title="1438             mPublishingSnackbar = Snackbar.make(mRootView, R.string.publishing, Snackbar.LENGTH_INDEFINITE);">1438             mPublishingSnackbar = Snackbar.make(mRootView, R.string.publishing, Snackbar.LENGTH_INDEFINITðŸ”µ</abbr>
1439             mPublishingSnackbar.show();
1440         }
1441 
1442         setPublishedNote(true);
1443     }
1444 
1445     private void unpublishNote() {
1446         if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1447             Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1448             return;
1449         }
1450 
1451         if (isAdded()) {
<abbr title="1452             mPublishingSnackbar = Snackbar.make(mRootView, R.string.unpublishing, Snackbar.LENGTH_INDEFINITE);">1452             mPublishingSnackbar = Snackbar.make(mRootView, R.string.unpublishing, Snackbar.LENGTH_INDEFINðŸ”µ</abbr>
1453             mPublishingSnackbar.show();
1454         }
1455 
1456         setPublishedNote(false);
1457     }
1458 
1459     private void showShare(String text) {
1460         startActivity(
1461             ShareCompat.IntentBuilder.from(requireActivity())
1462                 .setText(text)
1463                 .setType(&quot;text/plain&quot;)
1464                 .createChooserIntent()
1465         );
1466     }
1467     private void showShareSheet() {
1468         if (isAdded() &amp;&amp; mShareBottomSheet != null &amp;&amp; !mShareBottomSheet.isAdded()) {
1469             mShareBottomSheet.show(requireFragmentManager(), mNote);
1470         }
1471     }
1472 
1473     private void showInfoSheet() {
1474         if (isAdded() &amp;&amp; mInfoBottomSheet != null &amp;&amp; !mInfoBottomSheet.isAdded()) {
1475             mInfoBottomSheet.show(requireFragmentManager(), mNote);
1476         }
1477     }
1478 
1479     private void showHistorySheet() {
1480         if (isAdded() &amp;&amp; mHistoryBottomSheet != null &amp;&amp; !mHistoryBottomSheet.isAdded()) {
1481             // Request revisions for the current note
<abbr title="1482             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbacks());">1482             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbaðŸ”µ</abbr>
1483             saveNote();
1484 
1485             mHistoryBottomSheet.show(requireFragmentManager(), mNote);
1486         }
1487     }
1488 
1489     @Override
1490     public void onDeleteObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1491     }
1492 
1493     @Override
<abbr title="1494     public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) {">1494     public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) ðŸ”µ</abbr>
1495         if (changeType == Bucket.ChangeType.MODIFY) {
1496             if (getNote() != null &amp;&amp; getNote().getSimperiumKey().equals(key)) {
1497                 try {
1498                     mNotesBucket = noteBucket;
1499                     final Note updatedNote = mNotesBucket.get(key);
1500                     if (getActivity() != null) {
1501                         getActivity().runOnUiThread(new Runnable() {
1502                             @Override
1503                             public void run() {
1504                                 if (mPublishTimeoutHandler != null) {
1505                                     mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
1506                                 }
1507 
1508                                 updateNote(updatedNote);
1509                                 updatePublishedState(true);
1510                             }
1511                         });
1512                     }
1513                 } catch (BucketObjectMissingException e) {
1514                     e.printStackTrace();
1515                 }
1516             }
1517         }
1518     }
1519 
1520     @Override
1521     public void onSaveObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1522         if (mIsPaused) {
1523             mNotesBucket.removeListener(this);
1524             mNotesBucket.stop();
1525             AppLog.add(Type.SYNC, &quot;Stopped note bucket (NoteEditorFragment)&quot;);
1526         }
1527 
1528         AppLog.add(
1529             Type.SYNC,
1530             &quot;Saved note callback in NoteEditorFragment (ID: &quot; + note.getSimperiumKey() +
1531                 &quot; / Title: &quot; + note.getTitle() +
1532                 &quot; / Characters: &quot; + NoteUtils.getCharactersCount(note.getContent()) +
1533                 &quot; / Words: &quot; + NoteUtils.getWordCount(note.getContent()) + &quot;)&quot;
1534         );
1535     }
1536 
1537     @Override
1538     public void onBeforeUpdateObject(Bucket&lt;Note&gt; bucket, Note note) {
1539         // Don&#x27;t apply updates if we haven&#x27;t loaded the note yet
1540         if (mIsLoadingNote)
1541             return;
1542 
1543         Note openNote = getNote();
1544         if (openNote == null || !openNote.getSimperiumKey().equals(note.getSimperiumKey()))
1545             return;
1546 
1547         note.setContent(mContentEditText.getPlainTextContent());
1548     }
1549 
1550     private static class LoadNoteTask extends AsyncTask&lt;String, Void, Void&gt; {
1551         WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1552 
1553         LoadNoteTask(NoteEditorFragment fragment) {
1554             mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1555         }
1556 
1557         @Override
1558         protected void onPreExecute() {
1559             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1560 
1561             if (fragment != null) {
1562                 fragment.mContentEditText.removeTextChangedListener(fragment);
1563                 fragment.mIsLoadingNote = true;
1564             }
1565         }
1566 
1567         @Override
1568         protected Void doInBackground(String... args) {
1569             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1570 
1571             if (fragment == null || fragment.getActivity() == null) {
1572                 return null;
1573             }
1574 
1575             String noteID = args[0];
1576             Simplenote application = (Simplenote) fragment.getActivity().getApplication();
1577             Bucket&lt;Note&gt; notesBucket = application.getNotesBucket();
1578 
1579             try {
1580                 fragment.mNote = notesBucket.get(noteID);
1581 
1582                 // Set the current note in NotesActivity when on a tablet
1583                 if (fragment.getActivity() instanceof NotesActivity) {
1584                     ((NotesActivity) fragment.getActivity()).setCurrentNote(fragment.mNote);
1585                 }
1586 
1587                 // Set markdown and preview flags for current note
1588                 if (fragment.mNote != null) {
1589                     fragment.mIsMarkdownEnabled = fragment.mNote.isMarkdownEnabled();
1590                     fragment.mIsPreviewEnabled = fragment.mNote.isPreviewEnabled();
1591                     AppLog.add(
1592                         Type.SYNC,
1593                         &quot;Loaded note (ID: &quot; + fragment.mNote.getSimperiumKey() +
1594                             &quot; / Title: &quot; + fragment.mNote.getTitle() +
<abbr title="1595                             &quot; / Characters: &quot; + NoteUtils.getCharactersCount(fragment.mNote.getContent()) +">1595                             &quot; / Characters: &quot; + NoteUtils.getCharactersCount(fragment.mNote.getContent())ðŸ”µ</abbr>
1596                             &quot; / Words: &quot; + NoteUtils.getWordCount(fragment.mNote.getContent()) + &quot;)&quot;
1597                     );
1598                 }
1599             } catch (BucketObjectMissingException e) {
1600                 // See if the note is in the object store
1601                 Bucket.ObjectCursor&lt;Note&gt; notesCursor = notesBucket.allObjects();
1602 
1603                 while (notesCursor.moveToNext()) {
1604                     Note currentNote = notesCursor.getObject();
1605 
1606                     if (currentNote != null &amp;&amp; currentNote.getSimperiumKey().equals(noteID)) {
1607                         fragment.mNote = currentNote;
1608                         return null;
1609                     }
1610                 }
1611             }
1612 
1613             return null;
1614         }
1615 
1616         @Override
1617         protected void onPostExecute(Void nada) {
1618             final NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
<abbr title="1619             if (fragment == null || fragment.getActivity() == null || fragment.getActivity().isFinishing()) {">1619             if (fragment == null || fragment.getActivity() == null || fragment.getActivity().isFinishing(ðŸ”µ</abbr>
1620                 return;
1621             }
1622 
1623             fragment.refreshContent(false);
1624 
1625             if (fragment.mMatchOffsets != null) {
<abbr title="1626                 int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.CONTENT_PROPERTY);">1626                 int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndeðŸ”µ</abbr>
1627                 fragment.mHighlighter.highlightMatches(fragment.mMatchOffsets, columnIndex);
1628                 fragment.mShouldScrollToSearchMatch = true;
1629             }
1630 
1631             fragment.mContentEditText.addTextChangedListener(fragment);
1632 
1633             if (fragment.mNote != null &amp;&amp; fragment.mNote.getContent().isEmpty()) {
1634                 // Show soft keyboard
1635                 fragment.mContentEditText.requestFocus();
1636 
1637                 new Handler().postDelayed(new Runnable() {
1638                     @Override
1639                     public void run() {
1640                         if (fragment.getActivity() == null) {
1641                             return;
1642                         }
1643 
<abbr title="1644                         InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);">1644                         InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivityðŸ”µ</abbr>
1645 
1646                         if (inputMethodManager != null) {
1647                             inputMethodManager.showSoftInput(fragment.mContentEditText, 0);
1648                         }
1649                     }
1650                 }, 100);
1651             } else if (fragment.mNote != null) {
1652                 // If we have a valid note, hide the placeholder
1653                 fragment.setPlaceholderVisible(false);
1654             }
1655 
1656             fragment.updateMarkdownView();
1657             fragment.requireActivity().invalidateOptionsMenu();
1658             fragment.linkifyEditorContent();
1659             fragment.mIsLoadingNote = false;
1660         }
1661     }
1662 
1663     private static class SaveNoteTask extends AsyncTask&lt;Void, Void, Void&gt; {
1664         WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1665 
1666         SaveNoteTask(NoteEditorFragment fragment) {
1667             mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1668         }
1669 
1670         @Override
1671         protected Void doInBackground(Void... args) {
1672             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1673 
1674             if (fragment != null) {
1675                 fragment.saveNote();
1676             }
1677 
1678             return null;
1679         }
1680 
1681         @Override
1682         protected void onPostExecute(Void nada) {
1683             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1684 
<abbr title="1685             if (fragment != null &amp;&amp; fragment.getActivity() != null &amp;&amp; !fragment.getActivity().isFinishing()) {">1685             if (fragment != null &amp;&amp; fragment.getActivity() != null &amp;&amp; !fragment.getActivity().isFinishingðŸ”µ</abbr>
1686                 // Update links
1687                 fragment.linkifyEditorContent();
1688                 fragment.updateMarkdownView();
1689             }
1690         }
1691     }
1692 
1693     private void linkifyEditorContent() {
1694         if (getActivity() == null || getActivity().isFinishing()) {
1695             return;
1696         }
1697 
1698         if (PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_DETECT_LINKS)) {
1699             SimplenoteLinkify.addLinks(mContentEditText, Linkify.ALL);
1700         }
1701     }
1702 
1703     // Show tabs if markdown is enabled globally, for current note, and not tablet landscape
1704     private void updateMarkdownView() {
1705         if (!mIsMarkdownEnabled) {
1706             return;
1707         }
1708 
1709         Activity activity = getActivity();
1710         if (activity instanceof NotesActivity) {
1711             // This fragment lives in NotesActivity, so load markdown in this fragment&#x27;s WebView.
1712             loadMarkdownData();
1713         } else {
1714             // This fragment lives in the NoteEditorActivity&#x27;s ViewPager.
1715             if (mNoteMarkdownFragment == null) {
1716                 mNoteMarkdownFragment = ((NoteEditorActivity) requireActivity())
1717                         .getNoteMarkdownFragment();
1718                 ((NoteEditorActivity) requireActivity()).showTabs();
1719             }
1720             // Load markdown in the sibling NoteMarkdownFragment&#x27;s WebView.
1721             mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPreviewTextContent());
1722         }
1723     }
1724 
1725     private ColorStateList getChipBackgroundColor() {
1726         int[][] states = new int[][] {
1727             new int[] { android.R.attr.state_checked}, // checked
1728             new int[] {-android.R.attr.state_checked}  // unchecked
1729         };
1730 
1731         int[] colors = new int[] {
1732             ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOnBackgroundColor),
1733             ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOffBackgroundColor)
1734         };
1735 
1736         return new ColorStateList(states, colors);
1737     }
1738 
1739     private void setChips(CharSequence text) {
1740         mTagPadding.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1741         mTagChips.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1742         mTagChips.setSingleSelection(true);
1743         mTagChips.removeAllViews();
1744         SimpleStringSplitter tags = new SimpleStringSplitter(SPACE);
1745         tags.setString(text.toString());
1746 
1747         for (String tag : tags) {
1748             final Chip chip = new Chip(requireContext());
1749             chip.setText(tag);
1750             chip.setCheckable(true);
1751             chip.setCheckedIcon(null);
1752             chip.setChipBackgroundColor(getChipBackgroundColor());
1753             chip.setTextColor(ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipTextColor));
1754             chip.setStateListAnimator(null);
1755             chip.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
1756                 @Override
1757                 public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
1758                     chip.setCloseIconVisible(isChecked);
1759                 }
1760             });
1761             chip.setOnCloseIconClickListener(new View.OnClickListener() {
1762                 @Override
1763                 public void onClick(View view) {
1764                     mTagChips.removeView(view);
1765                     updateTags();
1766                     AnalyticsTracker.track(
1767                         EDITOR_TAG_REMOVED,
1768                         CATEGORY_NOTE,
1769                         &quot;tag_removed_from_note&quot;
1770                     );
1771                 }
1772             });
1773             mTagChips.addView(chip);
1774         }
1775     }
1776 
1777     private void updateTags() {
1778         if (mNote == null) {
1779             return;
1780         }
1781 
1782         mNote.setTagString(getNoteTagsString());
1783         mNote.setModificationDate(Calendar.getInstance());
1784         updateTagList();
1785         mNote.save();
1786     }
1787 }</pre></td>
                            <td><pre>   1 package com.automattic.simplenote;
   2 
   3 import android.app.Activity;
   4 import android.content.Context;
   5 import android.content.SharedPreferences;
   6 import android.content.res.ColorStateList;
   7 import android.database.Cursor;
   8 import android.graphics.Typeface;
   9 import android.graphics.drawable.Drawable;
  10 import android.os.AsyncTask;
  11 import android.os.Bundle;
  12 import android.os.Handler;
  13 import android.text.Editable;
  14 import android.text.Layout;
  15 import android.text.Spanned;
  16 import android.text.TextUtils.SimpleStringSplitter;
  17 import android.text.TextWatcher;
  18 import android.text.style.MetricAffectingSpan;
  19 import android.text.style.RelativeSizeSpan;
  20 import android.text.style.StyleSpan;
  21 import android.text.style.URLSpan;
  22 import android.text.util.Linkify;
  23 import android.util.TypedValue;
  24 import android.view.LayoutInflater;
  25 import android.view.Menu;
  26 import android.view.MenuInflater;
  27 import android.view.MenuItem;
  28 import android.view.View;
  29 import android.view.ViewGroup;
  30 import android.view.ViewTreeObserver;
  31 import android.view.inputmethod.InputMethodManager;
  32 import android.webkit.WebResourceRequest;
  33 import android.webkit.WebView;
  34 import android.webkit.WebViewClient;
  35 import android.widget.CompoundButton;
  36 import android.widget.CursorAdapter;
  37 import android.widget.LinearLayout;
  38 import android.widget.TextView;
  39 import android.widget.Toast;
  40 
  41 import androidx.annotation.NonNull;
  42 import androidx.annotation.StringRes;
  43 import androidx.appcompat.app.AppCompatActivity;
  44 import androidx.appcompat.view.ActionMode;
  45 import androidx.core.app.ShareCompat;
  46 import androidx.core.view.MenuCompat;
  47 import androidx.core.widget.NestedScrollView;
  48 import androidx.fragment.app.Fragment;
  49 import androidx.fragment.app.FragmentTransaction;
  50 import androidx.preference.PreferenceManager;
  51 
  52 import com.automattic.simplenote.analytics.AnalyticsTracker;
  53 import com.automattic.simplenote.models.Note;
  54 import com.automattic.simplenote.models.Tag;
  55 import com.automattic.simplenote.utils.AppLog;
  56 import com.automattic.simplenote.utils.AppLog.Type;
  57 import com.automattic.simplenote.utils.AutoBullet;
  58 import com.automattic.simplenote.utils.BrowserUtils;
  59 import com.automattic.simplenote.utils.ContextUtils;
  60 import com.automattic.simplenote.utils.DisplayUtils;
  61 import com.automattic.simplenote.utils.DrawableUtils;
  62 import com.automattic.simplenote.utils.MatchOffsetHighlighter;
  63 import com.automattic.simplenote.utils.NetworkUtils;
  64 import com.automattic.simplenote.utils.NoteUtils;
  65 import com.automattic.simplenote.utils.PrefUtils;
  66 import com.automattic.simplenote.utils.SimplenoteLinkify;
  67 import com.automattic.simplenote.utils.SimplenoteMovementMethod;
  68 import com.automattic.simplenote.utils.SpaceTokenizer;
  69 import com.automattic.simplenote.utils.TagUtils;
  70 import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;
  71 import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;
  72 import com.automattic.simplenote.utils.TextHighlighter;
  73 import com.automattic.simplenote.utils.ThemeUtils;
  74 import com.automattic.simplenote.utils.WidgetUtils;
  75 import com.automattic.simplenote.widgets.SimplenoteEditText;
  76 import com.google.android.material.chip.Chip;
  77 import com.google.android.material.chip.ChipGroup;
  78 import com.google.android.material.snackbar.Snackbar;
  79 import com.simperium.client.Bucket;
  80 import com.simperium.client.BucketObjectMissingException;
  81 import com.simperium.client.Query;
  82 
  83 import java.lang.ref.WeakReference;
  84 import java.util.Calendar;
  85 
  86 import static com.automattic.simplenote.analytics.AnalyticsTracker.CATEGORY_NOTE;
  87 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_CHECKLIST_INSERTED;
  88 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_CONTENT_SHARED;
  89 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_EDITED;
  90 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_PUBLISHED;
  91 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_UNPUBLISHED;
  92 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_ADDED;
  93 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_REMOVED;
  94 import static com.automattic.simplenote.utils.SearchTokenizer.SPACE;
  95 import static com.automattic.simplenote.utils.SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX;
  96 
  97 public class NoteEditorFragment extends Fragment implements Bucket.Listener&lt;Note&gt;,
  98         TextWatcher, OnTagAddedListener, View.OnFocusChangeListener,
  99         SimplenoteEditText.OnSelectionChangedListener,
 100         ShareBottomSheetDialog.ShareSheetListener,
 101         HistoryBottomSheetDialog.HistorySheetListener,
 102         SimplenoteEditText.OnCheckboxToggledListener {
 103 
 104     public static final String ARG_IS_FROM_WIDGET = &quot;is_from_widget&quot;;
 105     public static final String ARG_ITEM_ID = &quot;item_id&quot;;
 106     public static final String ARG_NEW_NOTE = &quot;new_note&quot;;
 107     public static final String ARG_MATCH_OFFSETS = &quot;match_offsets&quot;;
 108     public static final String ARG_MARKDOWN_ENABLED = &quot;markdown_enabled&quot;;
 109     public static final String ARG_PREVIEW_ENABLED = &quot;preview_enabled&quot;;
 110     private static final String STATE_NOTE_ID = &quot;state_note_id&quot;;
 111     private static final int AUTOSAVE_DELAY_MILLIS = 2000;
 112     private static final int MAX_REVISIONS = 30;
 113     private static final int PUBLISH_TIMEOUT = 20000;
 114     private static final int HISTORY_TIMEOUT = 10000;
 115     private Note mNote;
 116     private final Runnable mAutoSaveRunnable = new Runnable() {
 117         @Override
 118         public void run() {
 119             saveAndSyncNote();
 120         }
 121     };
 122     private Bucket&lt;Note&gt; mNotesBucket;
 123     private View mRootView;
 124     private View mTagPadding;
 125     private SimplenoteEditText mContentEditText;
 126     private ChipGroup mTagChips;
 127     private TagsMultiAutoCompleteTextView mTagInput;
 128     private Handler mAutoSaveHandler;
 129     private Handler mPublishTimeoutHandler;
 130     private Handler mHistoryTimeoutHandler;
 131     private LinearLayout mPlaceholderView;
 132     private CursorAdapter mAutocompleteAdapter;
 133     private boolean mIsLoadingNote;
 134     private boolean mIsMarkdownEnabled;
 135     private boolean mIsPreviewEnabled;
 136     private boolean mShouldScrollToSearchMatch;
 137     private ActionMode mActionMode;
 138     private MenuItem mChecklistMenuItem;
 139     private MenuItem mCopyMenuItem;
 140     private MenuItem mInformationMenuItem;
 141     private MenuItem mShareMenuItem;
 142     private MenuItem mViewLinkMenuItem;
 143     private String mLinkUrl;
 144     private String mLinkText;
 145     private MatchOffsetHighlighter mHighlighter;
 146     private Drawable mBrowserIcon;
 147     private Drawable mCallIcon;
 148     private Drawable mCopyIcon;
 149     private Drawable mEmailIcon;
 150     private Drawable mLinkIcon;
 151     private Drawable mMapIcon;
 152     private Drawable mShareIcon;
 153     private MatchOffsetHighlighter.SpanFactory mMatchHighlighter;
 154     private String mMatchOffsets;
 155     private int mCurrentCursorPosition;
 156     private HistoryBottomSheetDialog mHistoryBottomSheet;
 157     private boolean mIsPaused;
 158     private boolean mIsFromWidget;
 159 
 160     // Hides the history bottom sheet if no revisions are loaded
 161     private final Runnable mHistoryTimeoutRunnable = new Runnable() {
 162         @Override
 163         public void run() {
 164             if (!isAdded()) {
 165                 return;
 166             }
 167 
 168             requireActivity().runOnUiThread(new Runnable() {
 169                 @Override
 170                 public void run() {
<abbr title=" 171                     if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; !mHistoryBottomSheet.isHistoryLoaded()) {"> 171                     if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowðŸ”µ</abbr>
 172                         mHistoryBottomSheet.dismiss();
 173                         Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 174                     }
 175                 }
 176             });
 177         }
 178     };
 179     private InfoBottomSheetDialog mInfoBottomSheet;
 180     private ShareBottomSheetDialog mShareBottomSheet;
 181     // Contextual action bar for dealing with links
 182     private final ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
 183         // Called when the action mode is created; startActionMode() was called
 184         @Override
 185         public boolean onCreateActionMode(ActionMode mode, Menu menu) {
 186             // Inflate a menu resource providing context menu items
 187             MenuInflater inflater = mode.getMenuInflater();
 188 
 189             if (inflater != null) {
 190                 inflater.inflate(R.menu.view_link, menu);
 191                 mCopyMenuItem = menu.findItem(R.id.menu_copy);
 192                 mShareMenuItem = menu.findItem(R.id.menu_share);
 193                 mViewLinkMenuItem = menu.findItem(R.id.menu_view_link);
 194                 mode.setTitle(getString(R.string.link));
 195                 mode.setTitleOptionalHint(false);
 196 
 197                 DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 198             }
 199 
<abbr title=" 200             requireActivity().getWindow().setStatusBarColor(ThemeUtils.getColorFromAttribute(requireContext(), R.attr.mainBackgroundColor));"> 200             requireActivity().getWindow().setStatusBarColor(ThemeUtils.getColorFromAttribute(requireConteðŸ”µ</abbr>
 201             return true;
 202         }
 203 
 204         // Called each time the action mode is shown. Always called after onCreateActionMode, but
 205         // may be called multiple times if the mode is invalidated.
 206         @Override
 207         public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 208             return false; // Return false if nothing is done
 209         }
 210 
 211         // Called when the user selects a contextual menu item
 212         @Override
 213         public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 214             switch (item.getItemId()) {
 215                 case R.id.menu_view_link:
 216                     if (mLinkText != null) {
 217                         if (mLinkText.startsWith(SIMPLENOTE_LINK_PREFIX)) {
<abbr title=" 218                             SimplenoteLinkify.openNote(requireActivity(), mLinkText.replace(SIMPLENOTE_LINK_PREFIX, &quot;&quot;));"> 218                             SimplenoteLinkify.openNote(requireActivity(), mLinkText.replace(SIMPLENOTE_LIðŸ”µ</abbr>
 219                         } else {
 220                         try {
 221                                 BrowserUtils.launchBrowserOrShowError(requireContext(), mLinkText);
 222                         } catch (Exception e) {
 223                             e.printStackTrace();
 224                         }
 225                         }
 226 
 227                         mode.finish(); // Action picked, so close the CAB
 228                     }
 229 
 230                     return true;
 231                 case R.id.menu_copy:
 232                     if (mLinkText != null &amp;&amp; getActivity() != null) {
 233                         if (BrowserUtils.copyToClipboard(requireContext(), mLinkText)) {
 234                             Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 235                         } else {
<abbr title=" 236                             Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();"> 236                             Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT)ðŸ”µ</abbr>
 237                         }
 238 
 239                         mode.finish();
 240                     }
 241 
 242                     return true;
 243                 case R.id.menu_share:
 244                     if (mLinkText != null) {
 245                         showShare(mLinkText);
 246                         mode.finish();
 247                     }
 248 
 249                     return true;
 250                 default:
 251                     return false;
 252             }
 253         }
 254 
 255         // Called when the user exits the action mode
 256         @Override
 257         public void onDestroyActionMode(ActionMode mode) {
 258             if (mActionMode != null) {
 259                 mActionMode.setSubtitle(&quot;&quot;);
 260             mActionMode = null;
 261             }
 262 
 263             new Handler().postDelayed(
 264                 new Runnable() {
 265                     @Override
 266                     public void run() {
<abbr title=" 267                         requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 267                         requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.RðŸ”µ</abbr>
 268                     }
 269                 },
 270                 requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime)
 271             );
 272         }
 273     };
 274     private Snackbar mPublishingSnackbar;
 275     private boolean mHideActionOnSuccess;
 276     // Resets note publish status if Simperium never returned the new publish status
 277     private final Runnable mPublishTimeoutRunnable = new Runnable() {
 278         @Override
 279         public void run() {
 280             if (!isAdded()) return;
 281 
 282             requireActivity().runOnUiThread(new Runnable() {
 283                 @Override
 284                 public void run() {
 285 
 286                     mNote.setPublished(!mNote.isPublished());
 287                     mNote.save();
 288 
 289                     updatePublishedState(false);
 290                 }
 291             });
 292         }
 293     };
 294     private NoteMarkdownFragment mNoteMarkdownFragment;
 295     private String mCss;
 296     private WebView mMarkdown;
 297 
 298     /**
 299      * Mandatory empty constructor for the fragment manager to instantiate the
 300      * fragment (e.g. upon screen orientation changes).
 301      */
 302     public NoteEditorFragment() {
 303     }
 304 
 305     @Override
 306     public void onCreate(Bundle savedInstanceState) {
 307         super.onCreate(savedInstanceState);
 308         AppLog.add(Type.NETWORK, NetworkUtils.getNetworkInfo(requireContext()));
 309         AppLog.add(Type.SCREEN, &quot;Created (NoteEditorFragment)&quot;);
 310         mInfoBottomSheet = new InfoBottomSheetDialog(this);
 311         mShareBottomSheet = new ShareBottomSheetDialog(this, this);
 312         mHistoryBottomSheet = new HistoryBottomSheetDialog(this, this);
 313 
 314         Simplenote currentApp = (Simplenote) requireActivity().getApplication();
 315         mNotesBucket = currentApp.getNotesBucket();
 316 
<abbr title=" 317         mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.actionModeTextColor);"> 317         mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp,ðŸ”µ</abbr>
<abbr title=" 318         mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.attr.actionModeTextColor);"> 318         mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.aðŸ”µ</abbr>
<abbr title=" 319         mLinkIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_note_24dp, R.attr.actionModeTextColor);"> 319         mLinkIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_note_24dp, R.attðŸ”µ</abbr>
<abbr title=" 320         mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.actionModeTextColor);"> 320         mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.ðŸ”µ</abbr>
<abbr title=" 321         mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp, R.attr.actionModeTextColor);"> 321         mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp,ðŸ”µ</abbr>
<abbr title=" 322         mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attr.actionModeTextColor);"> 322         mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attðŸ”µ</abbr>
<abbr title=" 323         mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.attr.actionModeTextColor);"> 323         mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.aðŸ”µ</abbr>
 324 
 325         mAutoSaveHandler = new Handler();
 326         mPublishTimeoutHandler = new Handler();
 327         mHistoryTimeoutHandler = new Handler();
 328 
 329         mMatchHighlighter = new TextHighlighter(requireActivity(),
<abbr title=" 330                 R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor);"> 330                 R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor)ðŸ”µ</abbr>
 331         mAutocompleteAdapter = new CursorAdapter(getActivity(), null, 0x0) {
 332             @Override
 333             public View newView(Context context, Cursor cursor, ViewGroup parent) {
 334                 Activity activity = (Activity) context;
 335                 if (activity == null) return null;
 336                 return activity.getLayoutInflater().inflate(R.layout.tag_autocomplete_list_item, null);
 337             }
 338 
 339             @Override
 340             public void bindView(View view, Context context, Cursor cursor) {
 341                 TextView textView = (TextView) view;
 342                 textView.setText(convertToString(cursor));
 343             }
 344 
 345             @Override
 346             public CharSequence convertToString(Cursor cursor) {
 347                 return cursor.getString(cursor.getColumnIndex(Tag.NAME_PROPERTY));
 348             }
 349 
 350             @Override
 351             public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 352                 Activity activity = getActivity();
 353                 if (activity == null) return null;
 354                 Simplenote application = (Simplenote) activity.getApplication();
 355                 Query&lt;Tag&gt; query = application.getTagsBucket().query();
 356                 // make the tag name available to the cursor
 357                 query.include(Tag.NAME_PROPERTY);
 358                 // sort the tags by their names
 359                 query.order(Tag.NAME_PROPERTY);
 360                 // if there&#x27;s a filter string find only matching tag names
 361                 if (filter != null)
<abbr title=" 362                     query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filter));"> 362                     query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filteðŸ”µ</abbr>
 363                 return query.execute();
 364             }
 365         };
 366 
 367         WidgetUtils.updateNoteWidgets(requireActivity().getApplicationContext());
 368     }
 369 
 370     @Override
<abbr title=" 371     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {"> 371     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceSðŸ”µ</abbr>
 372         mRootView = inflater.inflate(R.layout.fragment_note_editor, container, false);
 373         mContentEditText = mRootView.findViewById(R.id.note_content);
 374         mContentEditText.addOnSelectionChangedListener(this);
 375         mContentEditText.setOnCheckboxToggledListener(this);
 376         mContentEditText.setMovementMethod(SimplenoteMovementMethod.getInstance());
 377         mContentEditText.setOnFocusChangeListener(this);
<abbr title=" 378         mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()));"> 378         mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()))ðŸ”µ</abbr>
 379         mTagInput = mRootView.findViewById(R.id.tag_input);
 380         mTagInput.setDropDownBackgroundResource(R.drawable.bg_list_popup);
 381         mTagInput.setTokenizer(new SpaceTokenizer());
 382         mTagInput.setOnFocusChangeListener(this);
 383         mTagChips = mRootView.findViewById(R.id.tag_chips);
 384         mTagPadding = mRootView.findViewById(R.id.tag_padding);
 385         mHighlighter = new MatchOffsetHighlighter(mMatchHighlighter, mContentEditText);
 386         mPlaceholderView = mRootView.findViewById(R.id.placeholder);
 387 
 388         if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote == null) {
 389             mPlaceholderView.setVisibility(View.VISIBLE);
 390             requireActivity().invalidateOptionsMenu();
 391             mMarkdown = mRootView.findViewById(R.id.markdown);
 392 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 393             mCss = ContextUtils.readCssFile(requireContext(), ThemeUtils.getCssFromStyle(requireContext()));"> 393             mCss = ContextUtils.readCssFile(requireContext(), ThemeUtils.getCssFromStyle(requireContext()ðŸ”µ</abbr></span>
 394 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 395             mCss = ThemeUtils.isLightTheme(requireContext())</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 396                     ? ContextUtils.readCssFile(requireContext(), &quot;light.css&quot;)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 397                     : ContextUtils.readCssFile(requireContext(), &quot;dark.css&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 398         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 399 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 400         mTagInput.setAdapter(mAutocompleteAdapter);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 401         Bundle arguments = getArguments();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 402 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 403         if (arguments != null &amp;&amp; arguments.containsKey(ARG_ITEM_ID)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 404             // Load note if we were passed a note Id</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 405             String key = arguments.getString(ARG_ITEM_ID);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 406 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 407             if (arguments.containsKey(ARG_MATCH_OFFSETS)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 408                 mMatchOffsets = arguments.getString(ARG_MATCH_OFFSETS);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 409             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 410 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 411             mIsFromWidget = arguments.getBoolean(ARG_IS_FROM_WIDGET);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 412 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 413             if (mIsFromWidget) {</span>
 414 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 415             mMarkdown.setWebViewClient(</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 416                 new WebViewClient() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 417                     @Override</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 418                     public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request){</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 419                         String url = request.getUrl().toString();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 420 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 421                         if (url.startsWith(SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX)){</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 422                             SimplenoteLinkify.openNote(requireActivity(), url.replace(SIMPLENOTE_LINK_PREFIX, &quot;&quot;));"> 422                             SimplenoteLinkify.openNote(requireActivity(), url.replace(SIMPLENOTE_LINK_PREðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 423                         } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 424                             BrowserUtils.launchBrowserOrShowError(requireContext(), url);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 425                         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 426 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 427                         return true;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 428                     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 429                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 430             );</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 431             mCss = ThemeUtils.isLightTheme(requireContext())</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 432                 ? ContextUtils.readCssFile(requireContext(), &quot;light.css&quot;)</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 433                 : ContextUtils.readCssFile(requireContext(), &quot;dark.css&quot;);</span>
 434 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 435         }
 436 
 437         mTagInput.setAdapter(mAutocompleteAdapter);
 438         Bundle arguments = getArguments();
 439 
 440         if (arguments != null &amp;&amp; arguments.containsKey(ARG_ITEM_ID)) {
 441             // Load note if we were passed a note Id
 442             String key = arguments.getString(ARG_ITEM_ID);
 443 
 444             if (arguments.containsKey(ARG_MATCH_OFFSETS)) {
 445                 mMatchOffsets = arguments.getString(ARG_MATCH_OFFSETS);
 446             }
 447 
 448             mIsFromWidget = arguments.getBoolean(ARG_IS_FROM_WIDGET);
 449 
 450             if (mIsFromWidget) {
 451                 AppLog.add(Type.ACTION, &quot;Opened from widget (NoteEditorFragment)&quot;);
 452             } else {
 453                 AppLog.add(Type.ACTION, &quot;Opened from list (NoteEditorFragment)&quot;);
 454             }
 455 
 456             new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, key);
 457         } else if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; savedInstanceState != null) {
 458             // Restore selected note when in dual pane mode
 459             String noteId = savedInstanceState.getString(STATE_NOTE_ID);
 460 
 461             if (noteId != null) {
 462                 setNote(noteId);
 463             }
 464         }
 465 
 466         ViewTreeObserver viewTreeObserver = mContentEditText.getViewTreeObserver();
 467         viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
 468             @Override
 469             public void onGlobalLayout() {
 470                 // If a note was loaded with search matches, scroll to the first match in the editor
 471                 if (mShouldScrollToSearchMatch &amp;&amp; mMatchOffsets != null) {
 472                     if (!isAdded()) {
 473                         return;
 474                     }
 475 
 476                     // Get the character location of the first search match
 477                     int matchLocation = MatchOffsetHighlighter.getFirstMatchLocation(
 478                             mContentEditText.getText(),
 479                             mMatchOffsets
 480                     );
 481                     if (matchLocation == 0) {
 482                         return;
 483                     }
 484 
 485                     // Calculate how far to scroll to bring the match into view
 486                     Layout layout = mContentEditText.getLayout();
 487                     int lineTop = layout.getLineTop(layout.getLineForOffset(matchLocation));
 488                     ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 489                     mShouldScrollToSearchMatch = false;
 490                 }
 491             }
 492         });
 493         setHasOptionsMenu(true);
 494         return mRootView;
 495     }
 496 
 497     public void scrollToMatch(int location) {
 498         if (isAdded()) {
 499             // Calculate how far to scroll to bring the match into view
 500             Layout layout = mContentEditText.getLayout();
 501             int lineTop = layout.getLineTop(layout.getLineForOffset(location));
 502             ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 503         }
 504     }
 505 
 506     @Override
 507     public void onResume() {
 508         super.onResume();
 509         mNotesBucket.start();
 510         AppLog.add(Type.SYNC, &quot;Started note bucket (NoteEditorFragment)&quot;);
 511         mNotesBucket.addListener(this);
 512         mTagInput.setOnTagAddedListener(this);
 513 
 514         if (mContentEditText != null) {
<abbr title=" 515             mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()));"> 515             mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContextðŸ”µ</abbr>
 516 
 517             if (mContentEditText.hasFocus()) {
 518                 showSoftKeyboard();
 519             }
 520         }
 521     }
 522 
 523     private void showSoftKeyboard() {
 524         new Handler().postDelayed(new Runnable() {
 525             @Override
 526             public void run() {
 527                 if (getActivity() == null) {
 528                     return;
 529                 }
 530 
<abbr title=" 531                 InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);"> 531                 InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemServiðŸ”µ</abbr>
 532                 if (inputMethodManager != null) {
 533                     inputMethodManager.showSoftInput(mContentEditText, 0);
 534                 }
 535             }
 536         }, 100);
 537     }
 538 
 539     @Override
 540     public void onPause() {
 541         super.onPause();  // Always call the superclass method first
 542         mIsPaused = true;
 543 
 544         // Hide soft keyboard if it is showing...
 545         DisplayUtils.hideKeyboard(mContentEditText);
 546 
 547         mTagInput.setOnTagAddedListener(null);
 548 
 549         if (mAutoSaveHandler != null) {
 550             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 551             mAutoSaveHandler.post(mAutoSaveRunnable);
 552         }
 553 
 554         if (mPublishTimeoutHandler != null) {
 555             mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
 556         }
 557 
 558         if (mHistoryTimeoutHandler != null) {
 559             mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 560         }
 561 
 562         mHighlighter.stop();
 563         saveNote();
 564         AppLog.add(Type.SCREEN, &quot;Paused (NoteEditorFragment)&quot;);
 565     }
 566 
 567     @Override
 568     public void onDestroy() {
 569         super.onDestroy();
 570         mNotesBucket.removeListener(this);
 571         mNotesBucket.stop();
 572         AppLog.add(Type.SYNC, &quot;Stopped note bucket (NoteEditorFragment)&quot;);
 573         AppLog.add(Type.SCREEN, &quot;Destroyed (NoteEditorFragment)&quot;);
 574     }
 575 
 576     @Override
 577     public void onSaveInstanceState(@NonNull Bundle outState) {
 578         super.onSaveInstanceState(outState);
 579 
 580         if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote != null) {
 581             outState.putString(STATE_NOTE_ID, mNote.getSimperiumKey());
 582         }
 583     }
 584 
 585     @Override
 586     public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
 587         super.onCreateOptionsMenu(menu, inflater);
 588 
<abbr title=" 589         if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFragment == null)) {"> 589         if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMðŸ”µ</abbr>
 590             return;
 591         }
 592 
 593         inflater.inflate(R.menu.note_editor, menu);
 594         MenuCompat.setGroupDividerEnabled(menu, true);
 595     }
 596 
 597     @Override
 598     public boolean onOptionsItemSelected(@NonNull MenuItem item) {
 599         switch (item.getItemId()) {
 600             case R.id.menu_checklist:
 601                 insertChecklist();
 602                 return true;
 603             case R.id.menu_copy:
 604                 if (BrowserUtils.copyToClipboard(requireContext(), mNote.getPublishedUrl())) {
 605                     Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 606                 } else {
 607                     Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();
 608                 }
 609 
 610                 return true;
 611             case R.id.menu_copy_internal:
<abbr title=" 612                 if (BrowserUtils.copyToClipboard(requireContext(), SimplenoteLinkify.getNoteLinkWithTitle(mNote.getTitle(), mNote.getSimperiumKey()))) {"> 612                 if (BrowserUtils.copyToClipboard(requireContext(), SimplenoteLinkify.getNoteLinkWithTitleðŸ”µ</abbr>
 613                     Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 614                 } else {
 615                     Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();
 616                 }
 617 
 618                 return true;
 619             case R.id.menu_history:
 620                 showHistory();
 621                 return true;
 622             case R.id.menu_info:
 623                 showInfo();
 624                 return true;
 625             case R.id.menu_markdown:
 626                 setMarkdown(!item.isChecked());
 627                 return true;
 628             case R.id.menu_pin:
 629                 NoteUtils.setNotePin(mNote, !item.isChecked());
 630                 requireActivity().invalidateOptionsMenu();
 631                 return true;
 632             case R.id.menu_publish:
 633                 if (item.isChecked()) {
 634                     unpublishNote();
 635                 } else {
 636                     publishNote();
 637                 }
 638 
 639                 return true;
 640             case R.id.menu_share:
 641                 shareNote();
 642                 return true;
 643             case R.id.menu_trash:
 644                 if (!isAdded()) {
 645                     return false;
 646                 }
 647 
 648                 deleteNote();
 649                 return true;
 650             case android.R.id.home:
 651                 AppLog.add(Type.ACTION, &quot;Tapped back arrow in app bar (NoteEditorFragment)&quot;);
 652                 if (!isAdded()) {
 653                     return false;
 654                 }
 655 
 656                 requireActivity().finish();
 657                 return true;
 658             default:
 659                 return super.onOptionsItemSelected(item);
 660         }
 661     }
 662 
 663     @Override
 664     public void onPrepareOptionsMenu(@NonNull Menu menu) {
 665         if (mNote != null) {
 666             MenuItem pinItem = menu.findItem(R.id.menu_pin);
 667             MenuItem shareItem = menu.findItem(R.id.menu_share);
 668             MenuItem historyItem = menu.findItem(R.id.menu_history);
 669             MenuItem publishItem = menu.findItem(R.id.menu_publish);
 670             MenuItem copyLinkItem = menu.findItem(R.id.menu_copy);
 671             MenuItem markdownItem = menu.findItem(R.id.menu_markdown);
 672             MenuItem trashItem = menu.findItem(R.id.menu_trash);
 673             mChecklistMenuItem = menu.findItem(R.id.menu_checklist);
 674             mInformationMenuItem = menu.findItem(R.id.menu_info).setVisible(true);
 675 
 676             pinItem.setChecked(mNote.isPinned());
 677             publishItem.setChecked(mNote.isPublished());
 678             markdownItem.setChecked(mNote.isMarkdownEnabled());
 679 
 680             // Disable actions when note is in Trash or markdown view is shown on large device.
 681             if (mNote.isDeleted() || (mMarkdown != null &amp;&amp; mMarkdown.getVisibility() == View.VISIBLE)) {
 682                 pinItem.setEnabled(false);
 683                 shareItem.setEnabled(false);
 684                 historyItem.setEnabled(false);
 685                 publishItem.setEnabled(false);
 686                 copyLinkItem.setEnabled(false);
 687                 markdownItem.setEnabled(false);
 688                 mChecklistMenuItem.setEnabled(false);
 689                 DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 0.3);  // 0.3 is 30% opacity.
 690             } else {
 691                 pinItem.setEnabled(true);
 692                 shareItem.setEnabled(true);
 693                 historyItem.setEnabled(true);
 694                 publishItem.setEnabled(true);
 695                 copyLinkItem.setEnabled(mNote.isPublished());
 696                 markdownItem.setEnabled(true);
 697                 mChecklistMenuItem.setEnabled(true);
 698                 DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 1.0);  // 1.0 is 100% opacity.
 699             }
 700 
 701             if (mNote.isDeleted()) {
 702                 trashItem.setTitle(R.string.restore);
 703             } else {
 704                 trashItem.setTitle(R.string.trash);
 705             }
 706         }
 707 
 708         DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 709         super.onPrepareOptionsMenu(menu);
 710     }
 711 
 712     public void insertChecklist() {
 713         DrawableUtils.startAnimatedVectorDrawable(mChecklistMenuItem.getIcon());
 714 
 715         try {
 716             mContentEditText.insertChecklist();
 717         } catch (Exception e) {
 718             e.printStackTrace();
 719             return;
 720         }
 721 
 722         AnalyticsTracker.track(
 723             EDITOR_CHECKLIST_INSERTED,
 724             CATEGORY_NOTE,
 725             &quot;toolbar_button&quot;
 726         );
 727     }
 728 
 729     @Override
 730     public void onCheckboxToggled() {
 731         // Save note (using delay) after toggling a checkbox
 732         if (mAutoSaveHandler != null) {
 733             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 734             mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 735         }
 736     }
 737 
 738     private void deleteNote() {
 739         NoteUtils.deleteNote(mNote, getActivity());
 740         requireActivity().finish();
 741     }
 742 
 743     protected void clearMarkdown() {
 744         mMarkdown.loadDataWithBaseURL(&quot;file:///android_asset/&quot;, mCss + &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 745     }
 746 
 747     protected void hideMarkdown() {
 748         mMarkdown.setVisibility(View.INVISIBLE);
 749     }
 750 
 751     protected void showMarkdown() {
 752         loadMarkdownData();
 753         mMarkdown.setVisibility(View.VISIBLE);
 754 
 755         new Handler().postDelayed(
 756             new Runnable() {
 757                 @Override
 758                 public void run() {
 759                     requireActivity().invalidateOptionsMenu();
 760                 }
 761             },
 762             getResources().getInteger(R.integer.time_animation)
 763         );
 764     }
 765 
 766     public void shareNote() {
 767         if (mNote != null) {
 768             mContentEditText.clearFocus();
 769             showShareSheet();
 770             AnalyticsTracker.track(
 771                 EDITOR_NOTE_CONTENT_SHARED,
 772                 CATEGORY_NOTE,
 773                 &quot;action_bar_share_button&quot;
 774             );
 775         }
 776     }
 777 
 778     public void showHistory() {
 779         if (mNote != null &amp;&amp; mNote.getVersion() &gt; 1) {
 780             mContentEditText.clearFocus();
 781             mHistoryTimeoutHandler.postDelayed(mHistoryTimeoutRunnable, HISTORY_TIMEOUT);
 782             showHistorySheet();
 783         } else {
 784             Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 785         }
 786     }
 787 
 788     public void showInfo() {
 789         DrawableUtils.startAnimatedVectorDrawable(mInformationMenuItem.getIcon());
 790 
 791         if (mNote != null) {
 792             mContentEditText.clearFocus();
 793             saveNote();
 794             showInfoSheet();
 795         }
 796     }
 797 
 798     private void setMarkdown(boolean isChecked) {
 799         mIsMarkdownEnabled = isChecked;
 800         showMarkdownActionOrTabs();
 801         saveNote();
 802 
 803         // Set preference so that next new note will have markdown enabled.
 804         SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(requireContext());
 805         SharedPreferences.Editor editor = prefs.edit();
 806         editor.putBoolean(PrefUtils.PREF_MARKDOWN_ENABLED, isChecked);
 807         editor.apply();
 808     }
 809 
 810     private void setMarkdownEnabled(boolean enabled) {
 811         mIsMarkdownEnabled = enabled;
 812 
 813         if (mIsMarkdownEnabled) {
 814             loadMarkdownData();
 815         }
 816     }
 817 
 818     private void showMarkdownActionOrTabs() {
 819         Activity activity = getActivity();
 820 
 821         if (activity instanceof NoteEditorActivity) {
 822             NoteEditorActivity editorActivity = (NoteEditorActivity) activity;
 823 
 824             if (mIsMarkdownEnabled) {
 825                 editorActivity.showTabs();
 826 
 827                 if (mNoteMarkdownFragment == null) {
 828                     // Get markdown fragment and update content
 829                     mNoteMarkdownFragment = editorActivity.getNoteMarkdownFragment();
 830                     mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPreviewTextContent());
 831                 }
 832             } else {
 833                 editorActivity.hideTabs();
 834             }
 835         } else if (activity instanceof NotesActivity) {
 836             setMarkdownEnabled(mIsMarkdownEnabled);
 837             ((NotesActivity) getActivity()).setMarkdownShowing(false);
 838         }
 839     }
 840 
 841     private void loadMarkdownData() {
 842         String formattedContent = NoteMarkdownFragment.getMarkdownFormattedContent(
 843                 mCss,
 844                 mContentEditText.getPreviewTextContent()
 845         );
 846 
 847         mMarkdown.loadDataWithBaseURL(null, formattedContent, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 848     }
 849 
 850     public void setNote(String noteID, String matchOffsets) {
 851         if (mAutoSaveHandler != null)
 852             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 853 
 854         mPlaceholderView.setVisibility(View.GONE);
 855 
 856         if (matchOffsets != null) {
 857             mMatchOffsets = matchOffsets;
 858         } else {
 859             mMatchOffsets = null;
 860         }
 861 
 862 
 863         saveNote();
 864 
 865         new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteID);
 866     }
 867 
 868     private void updateNote(Note updatedNote) {
 869         // update note if network change arrived
 870         mNote = updatedNote;
 871         refreshContent(true);
 872     }
 873 
 874     private void refreshContent(boolean isNoteUpdate) {
 875         if (mNote != null) {
 876             // Restore the cursor position if possible.
<abbr title=" 877             int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.getSelectionEnd());"> 877             int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEdðŸ”µ</abbr>
 878             mContentEditText.setText(mNote.getContent());
 879 
 880             if (isNoteUpdate) {
 881                 // Update markdown and preview flags from updated note.
 882                 mIsMarkdownEnabled = mNote.isMarkdownEnabled();
 883                 mIsPreviewEnabled = mNote.isPreviewEnabled();
 884 
 885                 // Show/Hide action/tabs based on markdown flag.
 886                 showMarkdownActionOrTabs();
 887 
 888                 // Save note so any local changes get synced.
 889                 mNote.save();
 890 
 891                 // Update current note object on large screen devices in landscape orientation.
 892                 if (DisplayUtils.isLargeScreenLandscape(requireContext())) {
 893                     ((NotesActivity) requireActivity()).setCurrentNote(mNote);
 894                 }
 895 
 896                 // Update overflow popup menu.
 897                 requireActivity().invalidateOptionsMenu();
 898 
 899                 if (mContentEditText.hasFocus()
 900                         &amp;&amp; cursorPosition != mContentEditText.getSelectionEnd()
 901                         &amp;&amp; cursorPosition &lt; mContentEditText.getText().length()) {
 902                     mContentEditText.setSelection(cursorPosition);
 903                 }
 904             }
 905 
 906             afterTextChanged(mContentEditText.getText());
 907             mContentEditText.processChecklists();
 908             updateTagList();
 909         }
 910     }
 911 
 912     private void updateTagList() {
 913         setChips(mNote.getTagString());
 914         mTagInput.setText(&quot;&quot;);
 915     }
 916 
 917     private int newCursorLocation(String newText, String oldText, int cursorLocation) {
 918         // Ported from the iOS app :)
 919         // Cases:
 920         // 0. All text after cursor (and possibly more) was removed ==&gt; put cursor at end
 921         // 1. Text was added after the cursor ==&gt; no change
 922         // 2. Text was added before the cursor ==&gt; location advances
 923         // 3. Text was removed after the cursor ==&gt; no change
 924         // 4. Text was removed before the cursor ==&gt; location retreats
 925         // 5. Text was added/removed on both sides of the cursor ==&gt; not handled
 926 
 927         cursorLocation = Math.max(cursorLocation, 0);
 928 
 929         int newCursorLocation = cursorLocation;
 930 
 931         int deltaLength = newText.length() - oldText.length();
 932 
 933         // Case 0
 934         if (newText.length() &lt; cursorLocation)
 935             return newText.length();
 936 
 937         boolean beforeCursorMatches = false;
 938         boolean afterCursorMatches = false;
 939 
 940         try {
<abbr title=" 941             beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation));"> 941             beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorðŸ”µ</abbr>
<abbr title=" 942             afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaLength));"> 942             afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocatioðŸ”µ</abbr>
 943         } catch (Exception e) {
 944             e.printStackTrace();
 945         }
 946 
 947         // Cases 2 and 4
 948         if (!beforeCursorMatches &amp;&amp; afterCursorMatches)
 949             newCursorLocation += deltaLength;
 950 
 951         // Cases 1, 3 and 5 have no change
 952         return newCursorLocation;
 953     }
 954 
 955     @Override
 956     public void onTagAdded(String tag) {
 957         if (mNote == null || !isAdded()) {
 958             return;
 959         }
 960 
 961         if (mNote.getTagString() != null &amp;&amp; tag.length() &gt; mNote.getTagString().length()) {
 962             AnalyticsTracker.track(
 963                 EDITOR_TAG_ADDED,
 964                 CATEGORY_NOTE,
 965                 &quot;tag_added_to_note&quot;
 966             );
 967         }
 968 
 969         mNote.setTagString(mNote.getTagString() + String.valueOf(SPACE) + tag);
 970         mNote.setModificationDate(Calendar.getInstance());
 971         updateTagList();
 972         mNote.save();
 973     }
 974 
 975     @Override
 976     public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
 977         // Unused
 978     }
 979 
 980     @Override
 981     public void afterTextChanged(Editable editable) {
 982         attemptAutoList(editable);
 983         setTitleSpan(editable);
 984         mContentEditText.fixLineSpacing();
 985     }
 986 
 987     @Override
 988     public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
 989         // When text changes, start timer that will fire after AUTOSAVE_DELAY_MILLIS passes
 990         if (mAutoSaveHandler != null) {
 991             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 992             mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 993         }
 994 
 995         // Remove search highlight spans when note content changes
 996         if (mMatchOffsets != null) {
 997             mMatchOffsets = null;
 998             mHighlighter.removeMatches();
 999         }
1000 
1001         if (!DisplayUtils.isLargeScreenLandscape(requireContext())) {
1002             ((NoteEditorActivity) requireActivity()).setSearchMatchBarVisible(false);
1003         }
1004 
1005         // Temporarily remove the text watcher as we process checklists to prevent callback looping
1006         mContentEditText.removeTextChangedListener(this);
1007         mContentEditText.processChecklists();
1008         mContentEditText.addTextChangedListener(this);
1009     }
1010 
1011     /**
1012      * Set the note title to be a larger size and bold style.
1013      *
1014      * Remove all existing spans before applying spans or performance issues will occur.  Since both
1015      * {@link RelativeSizeSpan} and {@link StyleSpan} inherit from {@link MetricAffectingSpan}, all
1016      * spans are removed when {@link MetricAffectingSpan} is removed.
1017      */
1018     private void setTitleSpan(Editable editable) {
<abbr title="1019         for (MetricAffectingSpan span : editable.getSpans(0, editable.length(), MetricAffectingSpan.class)) {">1019         for (MetricAffectingSpan span : editable.getSpans(0, editable.length(), MetricAffectingSpan.classðŸ”µ</abbr>
1020             if (span instanceof RelativeSizeSpan || span instanceof StyleSpan) {
1021                 editable.removeSpan(span);
1022             }
1023         }
1024 
1025         int newLinePosition = getNoteContentString().indexOf(&quot;\n&quot;);
1026 
1027         if (newLinePosition == 0) {
1028             return;
1029         }
1030 
1031         int titleEndPosition = (newLinePosition &gt; 0) ? newLinePosition : editable.length();
<abbr title="1032         editable.setSpan(new RelativeSizeSpan(1.3f), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);">1032         editable.setSpan(new RelativeSizeSpan(1.3f), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVðŸ”µ</abbr>
<abbr title="1033         editable.setSpan(new StyleSpan(Typeface.BOLD), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);">1033         editable.setSpan(new StyleSpan(Typeface.BOLD), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSðŸ”µ</abbr>
1034     }
1035 
1036     private void attemptAutoList(Editable editable) {
1037         int oldCursorPosition = mCurrentCursorPosition;
1038         mCurrentCursorPosition = mContentEditText.getSelectionStart();
1039         AutoBullet.apply(editable, oldCursorPosition, mCurrentCursorPosition);
1040         mCurrentCursorPosition = mContentEditText.getSelectionStart();
1041     }
1042 
1043     private void saveAndSyncNote() {
1044         if (mNote == null) {
1045             return;
1046         }
1047 
1048         AppLog.add(
1049             Type.ACTION,
1050             &quot;Edited note (ID: &quot; + mNote.getSimperiumKey() +
1051                 &quot; / Title: &quot; + mNote.getTitle() +
1052                 &quot; / Characters: &quot; + NoteUtils.getCharactersCount(mNote.getContent()) +
1053                 &quot; / Words: &quot; + NoteUtils.getWordCount(mNote.getContent()) + &quot;)&quot;
1054         );
1055         new SaveNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
1056     }
1057 
1058     public boolean isPlaceholderVisible() {
1059         if (mPlaceholderView != null) {
1060             return mPlaceholderView.getVisibility() == View.VISIBLE;
1061         } else {
1062             return false;
1063         }
1064     }
1065 
1066     public void setPlaceholderVisible(boolean isVisible) {
1067         if (isVisible) {
1068             mNote = null;
1069             mContentEditText.setText(&quot;&quot;);
1070         }
1071 
1072         if (mPlaceholderView != null) {
1073             mPlaceholderView.setVisibility(isVisible ? View.VISIBLE : View.GONE);
1074         }
1075     }
1076 
1077     @Override
1078     public void onFocusChange(View v, boolean hasFocus) {
1079         if (!hasFocus) {
1080             String tags = getNoteTagsString().trim();
1081 
1082             if (mTagInput.getText().toString().trim().length() &gt; 0
1083                 &amp;&amp; TagUtils.hashTagValid(mTagInput.getText().toString().trim())) {
1084                 onTagAdded(mTagInput.getText().toString());
1085             } else if (tags.length() &gt; 0) {
1086                 setChips(tags);
1087             }
1088         }
1089     }
1090 
1091     private Note getNote() {
1092         return mNote;
1093     }
1094 
1095     public void setNote(String noteID) {
1096         setNote(noteID, null);
1097     }
1098 
1099     private String getNoteContentString() {
1100         if (mContentEditText == null || mContentEditText.getText() == null) {
1101             return &quot;&quot;;
1102         } else {
1103             return mContentEditText.getText().toString();
1104         }
1105     }
1106 
1107     private String getNoteTagsString() {
1108         StringBuilder tags = new StringBuilder();
1109 
1110         for (int i= 0; i &lt; mTagChips.getChildCount(); i++) {
1111             tags.append(((Chip) mTagChips.getChildAt(i)).getText()).append(&quot; &quot;);
1112         }
1113 
1114         return tags.toString();
1115     }
1116 
1117     /**
1118      * Share bottom sheet callbacks
1119      */
1120 
1121     @Override
1122     public void onSharePublishClicked() {
1123         publishNote();
1124         if (mShareBottomSheet != null) {
1125             mShareBottomSheet.dismiss();
1126         }
1127     }
1128 
1129     @Override
1130     public void onShareUnpublishClicked() {
1131         unpublishNote();
1132         if (mShareBottomSheet != null) {
1133             mShareBottomSheet.dismiss();
1134         }
1135     }
1136 
1137     @Override
1138     public void onWordPressPostClicked() {
1139         if (mShareBottomSheet != null) {
1140             mShareBottomSheet.dismiss();
1141         }
1142 
1143         if (getFragmentManager() == null) {
1144             return;
1145         }
1146 
1147         FragmentTransaction ft = getFragmentManager().beginTransaction();
1148         Fragment prev = getFragmentManager().findFragmentByTag(WordPressDialogFragment.DIALOG_TAG);
1149         if (prev != null) {
1150             ft.remove(prev);
1151         }
1152         ft.addToBackStack(null);
1153 
1154         // Create and show the dialog.
1155         WordPressDialogFragment wpDialogFragment = new WordPressDialogFragment();
1156         wpDialogFragment.setNote(mNote);
1157         wpDialogFragment.show(ft, WordPressDialogFragment.DIALOG_TAG);
1158     }
1159 
1160     @Override
1161     public void onShareCollaborateClicked() {
1162         Toast.makeText(getActivity(), R.string.collaborate_message, Toast.LENGTH_LONG).show();
1163     }
1164 
1165     @Override
1166     public void onShareDismissed() {
1167 
1168     }
1169 
1170     /**
1171      * History bottom sheet listeners
1172      */
1173 
1174     @Override
1175     public void onHistoryCancelClicked() {
1176         mContentEditText.setText(mNote.getContent());
1177         if (mHistoryBottomSheet != null) {
1178             mHistoryBottomSheet.dismiss();
1179         }
1180     }
1181 
1182     @Override
1183     public void onHistoryRestoreClicked() {
1184         if (mHistoryBottomSheet != null) {
1185             mHistoryBottomSheet.dismiss();
1186         }
1187         saveAndSyncNote();
1188     }
1189 
1190     @Override
1191     public void onHistoryDismissed() {
1192         if (!mHistoryBottomSheet.didTapOnButton()) {
1193             mContentEditText.setText(mNote.getContent());
1194         }
1195 
1196         if (mHistoryTimeoutHandler != null) {
1197             mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
1198         }
1199     }
1200 
1201     @Override
1202     public void onHistoryUpdateNote(String content) {
1203         mContentEditText.setText(content);
1204     }
1205 
1206     private void saveNote() {
1207         try {
1208             if (mNote == null || mNotesBucket == null || mContentEditText == null || mIsLoadingNote ||
<abbr title="1209                 (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing())) {">1209                 (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomðŸ”µ</abbr>
1210                 return;
1211             } else {
1212                 mNote = mNotesBucket.get(mNote.getSimperiumKey());
1213                 mIsPreviewEnabled = mNote.isPreviewEnabled();
1214             }
1215 
1216             String content = mContentEditText.getPlainTextContent();
1217             String tagString = getNoteTagsString();
1218 
<abbr title="1219             if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnabled)) {">1219             if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPrevðŸ”µ</abbr>
1220                 mNote.setContent(content);
1221                 mNote.setTagString(tagString);
1222                 mNote.setModificationDate(Calendar.getInstance());
1223                 mNote.setMarkdownEnabled(mIsMarkdownEnabled);
1224                 mNote.setPreviewEnabled(mIsPreviewEnabled);
1225                 mNote.save();
1226 
1227                 AnalyticsTracker.track(
1228                     EDITOR_NOTE_EDITED,
1229                     CATEGORY_NOTE,
1230                     &quot;editor_save&quot;
1231                 );
1232 
1233                 AppLog.add(
1234                     Type.SYNC,
1235                     &quot;Saved note locally in NoteEditorFragment (ID: &quot; + mNote.getSimperiumKey() +
1236                         &quot; / Title: &quot; + mNote.getTitle() +
1237                         &quot; / Characters: &quot; + NoteUtils.getCharactersCount(content) +
1238                         &quot; / Words: &quot; + NoteUtils.getWordCount(content) + &quot;)&quot;
1239                 );
1240             }
1241         } catch (BucketObjectMissingException exception) {
1242             exception.printStackTrace();
1243         }
1244     }
1245 
1246     // Checks if cursor is at a URL when the selection changes
1247     // If it is a URL, show the contextual action bar
1248     @Override
1249     public void onSelectionChanged(int selStart, int selEnd) {
1250         mCurrentCursorPosition = selEnd;
1251 
1252         if (selStart == selEnd) {
1253             Editable noteContent = mContentEditText.getText();
1254 
1255             if (noteContent == null) {
1256                 return;
1257             }
1258 
1259             URLSpan[] urlSpans = noteContent.getSpans(selStart, selStart, URLSpan.class);
1260 
1261             if (urlSpans.length &gt; 0) {
1262                 URLSpan urlSpan = urlSpans[0];
1263                 mLinkUrl = urlSpan.getURL();
<abbr title="1264                 mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSpan)).toString();">1264                 mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpaðŸ”µ</abbr>
1265 
1266                 if (mActionMode != null) {
1267                     mActionMode.setSubtitle(mLinkText);
1268                     updateMenuItems();
1269                     return;
1270                 }
1271 
1272                 // Show the Contextual Action Bar
1273                 if (getActivity() != null) {
<abbr title="1274                     mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCallback);">1274                     mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCðŸ”µ</abbr>
1275 
1276                     if (mActionMode != null) {
1277                         mActionMode.setSubtitle(mLinkText);
1278                     }
1279 
1280                     updateMenuItems();
1281                 }
1282             } else if (mActionMode != null) {
1283                 mActionMode.finish();
1284                 mActionMode = null;
1285             }
1286         } else if (mActionMode != null) {
1287             mActionMode.finish();
1288             mActionMode = null;
1289         }
1290     }
1291 
1292     private void updateMenuItems() {
1293         mCopyMenuItem.setIcon(mCopyIcon);
1294         mShareMenuItem.setIcon(mShareIcon);
1295 
1296         if (mViewLinkMenuItem != null &amp;&amp; mLinkUrl != null) {
1297             if (mLinkUrl.startsWith(&quot;tel:&quot;)) {
1298                 mViewLinkMenuItem.setIcon(mCallIcon);
1299                 mViewLinkMenuItem.setTitle(getString(R.string.call));
1300             } else if (mLinkUrl.startsWith(&quot;mailto:&quot;)) {
1301                 mViewLinkMenuItem.setIcon(mEmailIcon);
1302                 mViewLinkMenuItem.setTitle(getString(R.string.email));
1303             } else if (mLinkUrl.startsWith(&quot;geo:&quot;)) {
1304                 mViewLinkMenuItem.setIcon(mMapIcon);
1305                 mViewLinkMenuItem.setTitle(getString(R.string.view_map));
1306             } else if (mLinkUrl.startsWith(SIMPLENOTE_LINK_PREFIX)) {
1307                 mViewLinkMenuItem.setIcon(mLinkIcon);
1308                 mViewLinkMenuItem.setTitle(getString(R.string.open_note));
1309             } else {
1310                 mViewLinkMenuItem.setIcon(mBrowserIcon);
1311                 mViewLinkMenuItem.setTitle(getString(R.string.view_in_browser));
1312             }
1313         }
1314     }
1315 
1316     private void setPublishedNote(boolean isPublished) {
1317         if (mNote != null) {
1318             mNote.setPublished(isPublished);
1319             mNote.save();
1320 
1321             // reset publish status in 20 seconds if we don&#x27;t hear back from Simperium
1322             mPublishTimeoutHandler.postDelayed(mPublishTimeoutRunnable, PUBLISH_TIMEOUT);
1323 
1324             AnalyticsTracker.track(
1325                 isPublished ? EDITOR_NOTE_PUBLISHED : EDITOR_NOTE_UNPUBLISHED,
1326                 CATEGORY_NOTE,
1327                 &quot;publish_note_button&quot;
1328             );
1329         }
1330     }
1331 
1332     private void updatePublishedState(boolean isSuccess) {
1333         if (mPublishingSnackbar == null) {
1334             return;
1335         }
1336 
1337         mPublishingSnackbar.dismiss();
1338         mPublishingSnackbar = null;
1339 
1340         if (isSuccess &amp;&amp; isAdded()) {
1341             if (mNote.isPublished()) {
1342                 @StringRes int text;
1343 
1344                 if (BrowserUtils.copyToClipboard(requireContext(), mNote.getPublishedUrl())) {
1345                     text = R.string.publish_successful_link;
1346                 } else {
1347                     text = R.string.publish_successful;
1348                 }
1349 
1350                 if (mHideActionOnSuccess) {
1351                     Snackbar.make(mRootView, text, Snackbar.LENGTH_LONG).show();
1352                 } else {
1353                     Snackbar.make(mRootView, text, Snackbar.LENGTH_LONG)
1354                         .setAction(
1355                             R.string.undo,
1356                             new View.OnClickListener() {
1357                                 @Override
1358                                 public void onClick(View v) {
1359                                     mHideActionOnSuccess = true;
1360                                     unpublishNote();
1361                                 }
1362                             }
1363                         )
1364                         .show();
1365                 }
1366             } else {
1367                 if (mHideActionOnSuccess) {
1368                     Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG)
1369                             .show();
1370                 } else {
1371                     Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG)
1372                             .setAction(
1373                                 R.string.undo,
1374                                 new View.OnClickListener() {
1375                                     @Override
1376                                     public void onClick(View v) {
1377                                         mHideActionOnSuccess = true;
1378                                         publishNote();
1379                                     }
1380                                 }
1381                             )
1382                             .show();
1383                 }
1384             }
1385         } else {
1386             if (mNote.isPublished()) {
1387                 Snackbar.make(mRootView, R.string.unpublish_error, Snackbar.LENGTH_LONG)
1388                         .setAction(
1389                             R.string.retry,
1390                             new View.OnClickListener() {
1391                                 @Override
1392                                 public void onClick(View v) {
1393                                     mHideActionOnSuccess = true;
1394                                     unpublishNote();
1395                                 }
1396                             }
1397                         ).show();
1398             } else {
1399                 Snackbar.make(mRootView, R.string.publish_error, Snackbar.LENGTH_LONG)
1400                         .setAction(
1401                             R.string.retry,
1402                             new View.OnClickListener() {
1403                                 @Override
1404                                 public void onClick(View v) {
1405                                     mHideActionOnSuccess = true;
1406                                     publishNote();
1407                                 }
1408                             }
1409                         ).show();
1410             }
1411         }
1412 
1413         mHideActionOnSuccess = false;
1414         requireActivity().invalidateOptionsMenu();
1415     }
1416 
1417     private void publishNote() {
1418         if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1419             Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1420             return;
1421         }
1422 
1423         if (isAdded()) {
<abbr title="1424             mPublishingSnackbar = Snackbar.make(mRootView, R.string.publishing, Snackbar.LENGTH_INDEFINITE);">1424             mPublishingSnackbar = Snackbar.make(mRootView, R.string.publishing, Snackbar.LENGTH_INDEFINITðŸ”µ</abbr>
1425             mPublishingSnackbar.show();
1426         }
1427 
1428         setPublishedNote(true);
1429     }
1430 
1431     private void unpublishNote() {
1432         if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1433             Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1434             return;
1435         }
1436 
1437         if (isAdded()) {
<abbr title="1438             mPublishingSnackbar = Snackbar.make(mRootView, R.string.unpublishing, Snackbar.LENGTH_INDEFINITE);">1438             mPublishingSnackbar = Snackbar.make(mRootView, R.string.unpublishing, Snackbar.LENGTH_INDEFINðŸ”µ</abbr>
1439             mPublishingSnackbar.show();
1440         }
1441 
1442         setPublishedNote(false);
1443     }
1444 
1445     private void showShare(String text) {
1446         startActivity(
1447             ShareCompat.IntentBuilder.from(requireActivity())
1448                 .setText(text)
1449                 .setType(&quot;text/plain&quot;)
1450                 .createChooserIntent()
1451         );
1452     }
1453     private void showShareSheet() {
1454         if (isAdded() &amp;&amp; mShareBottomSheet != null &amp;&amp; !mShareBottomSheet.isAdded()) {
1455             mShareBottomSheet.show(requireFragmentManager(), mNote);
1456         }
1457     }
1458 
1459     private void showInfoSheet() {
1460         if (isAdded() &amp;&amp; mInfoBottomSheet != null &amp;&amp; !mInfoBottomSheet.isAdded()) {
1461             mInfoBottomSheet.show(requireFragmentManager(), mNote);
1462         }
1463     }
1464 
1465     private void showHistorySheet() {
1466         if (isAdded() &amp;&amp; mHistoryBottomSheet != null &amp;&amp; !mHistoryBottomSheet.isAdded()) {
1467             // Request revisions for the current note
<abbr title="1468             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbacks());">1468             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbaðŸ”µ</abbr>
1469             saveNote();
1470 
1471             mHistoryBottomSheet.show(requireFragmentManager(), mNote);
1472         }
1473     }
1474 
1475     @Override
1476     public void onDeleteObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1477     }
1478 
1479     @Override
<abbr title="1480     public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) {">1480     public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) ðŸ”µ</abbr>
1481         if (changeType == Bucket.ChangeType.MODIFY) {
1482             if (getNote() != null &amp;&amp; getNote().getSimperiumKey().equals(key)) {
1483                 try {
1484                     mNotesBucket = noteBucket;
1485                     final Note updatedNote = mNotesBucket.get(key);
1486                     if (getActivity() != null) {
1487                         getActivity().runOnUiThread(new Runnable() {
1488                             @Override
1489                             public void run() {
1490                                 if (mPublishTimeoutHandler != null) {
1491                                     mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
1492                                 }
1493 
1494                                 updateNote(updatedNote);
1495                                 updatePublishedState(true);
1496                             }
1497                         });
1498                     }
1499                 } catch (BucketObjectMissingException e) {
1500                     e.printStackTrace();
1501                 }
1502             }
1503         }
1504     }
1505 
1506     @Override
1507     public void onSaveObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1508         if (mIsPaused) {
1509             mNotesBucket.removeListener(this);
1510             mNotesBucket.stop();
1511             AppLog.add(Type.SYNC, &quot;Stopped note bucket (NoteEditorFragment)&quot;);
1512         }
1513 
1514         AppLog.add(
1515             Type.SYNC,
1516             &quot;Saved note callback in NoteEditorFragment (ID: &quot; + note.getSimperiumKey() +
1517                 &quot; / Title: &quot; + note.getTitle() +
1518                 &quot; / Characters: &quot; + NoteUtils.getCharactersCount(note.getContent()) +
1519                 &quot; / Words: &quot; + NoteUtils.getWordCount(note.getContent()) + &quot;)&quot;
1520         );
1521     }
1522 
1523     @Override
1524     public void onBeforeUpdateObject(Bucket&lt;Note&gt; bucket, Note note) {
1525         // Don&#x27;t apply updates if we haven&#x27;t loaded the note yet
1526         if (mIsLoadingNote)
1527             return;
1528 
1529         Note openNote = getNote();
1530         if (openNote == null || !openNote.getSimperiumKey().equals(note.getSimperiumKey()))
1531             return;
1532 
1533         note.setContent(mContentEditText.getPlainTextContent());
1534     }
1535 
1536     private static class LoadNoteTask extends AsyncTask&lt;String, Void, Void&gt; {
1537         WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1538 
1539         LoadNoteTask(NoteEditorFragment fragment) {
1540             mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1541         }
1542 
1543         @Override
1544         protected void onPreExecute() {
1545             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1546 
1547             if (fragment != null) {
1548                 fragment.mContentEditText.removeTextChangedListener(fragment);
1549                 fragment.mIsLoadingNote = true;
1550             }
1551         }
1552 
1553         @Override
1554         protected Void doInBackground(String... args) {
1555             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1556 
1557             if (fragment == null || fragment.getActivity() == null) {
1558                 return null;
1559             }
1560 
1561             String noteID = args[0];
1562             Simplenote application = (Simplenote) fragment.getActivity().getApplication();
1563             Bucket&lt;Note&gt; notesBucket = application.getNotesBucket();
1564 
1565             try {
1566                 fragment.mNote = notesBucket.get(noteID);
1567 
1568                 // Set the current note in NotesActivity when on a tablet
1569                 if (fragment.getActivity() instanceof NotesActivity) {
1570                     ((NotesActivity) fragment.getActivity()).setCurrentNote(fragment.mNote);
1571                 }
1572 
1573                 // Set markdown and preview flags for current note
1574                 if (fragment.mNote != null) {
1575                     fragment.mIsMarkdownEnabled = fragment.mNote.isMarkdownEnabled();
1576                     fragment.mIsPreviewEnabled = fragment.mNote.isPreviewEnabled();
1577                     AppLog.add(
1578                         Type.SYNC,
1579                         &quot;Loaded note (ID: &quot; + fragment.mNote.getSimperiumKey() +
1580                             &quot; / Title: &quot; + fragment.mNote.getTitle() +
<abbr title="1581                             &quot; / Characters: &quot; + NoteUtils.getCharactersCount(fragment.mNote.getContent()) +">1581                             &quot; / Characters: &quot; + NoteUtils.getCharactersCount(fragment.mNote.getContent())ðŸ”µ</abbr>
1582                             &quot; / Words: &quot; + NoteUtils.getWordCount(fragment.mNote.getContent()) + &quot;)&quot;
1583                     );
1584                 }
1585             } catch (BucketObjectMissingException e) {
1586                 // See if the note is in the object store
1587                 Bucket.ObjectCursor&lt;Note&gt; notesCursor = notesBucket.allObjects();
1588 
1589                 while (notesCursor.moveToNext()) {
1590                     Note currentNote = notesCursor.getObject();
1591 
1592                     if (currentNote != null &amp;&amp; currentNote.getSimperiumKey().equals(noteID)) {
1593                         fragment.mNote = currentNote;
1594                         return null;
1595                     }
1596                 }
1597             }
1598 
1599             return null;
1600         }
1601 
1602         @Override
1603         protected void onPostExecute(Void nada) {
1604             final NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
<abbr title="1605             if (fragment == null || fragment.getActivity() == null || fragment.getActivity().isFinishing()) {">1605             if (fragment == null || fragment.getActivity() == null || fragment.getActivity().isFinishing(ðŸ”µ</abbr>
1606                 return;
1607             }
1608 
1609             fragment.refreshContent(false);
1610 
1611             if (fragment.mMatchOffsets != null) {
<abbr title="1612                 int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.CONTENT_PROPERTY);">1612                 int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndeðŸ”µ</abbr>
1613                 fragment.mHighlighter.highlightMatches(fragment.mMatchOffsets, columnIndex);
1614                 fragment.mShouldScrollToSearchMatch = true;
1615             }
1616 
1617             fragment.mContentEditText.addTextChangedListener(fragment);
1618 
1619             if (fragment.mNote != null &amp;&amp; fragment.mNote.getContent().isEmpty()) {
1620                 // Show soft keyboard
1621                 fragment.mContentEditText.requestFocus();
1622 
1623                 new Handler().postDelayed(new Runnable() {
1624                     @Override
1625                     public void run() {
1626                         if (fragment.getActivity() == null) {
1627                             return;
1628                         }
1629 
<abbr title="1630                         InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);">1630                         InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivityðŸ”µ</abbr>
1631 
1632                         if (inputMethodManager != null) {
1633                             inputMethodManager.showSoftInput(fragment.mContentEditText, 0);
1634                         }
1635                     }
1636                 }, 100);
1637             } else if (fragment.mNote != null) {
1638                 // If we have a valid note, hide the placeholder
1639                 fragment.setPlaceholderVisible(false);
1640             }
1641 
1642             fragment.updateMarkdownView();
1643             fragment.requireActivity().invalidateOptionsMenu();
1644             fragment.linkifyEditorContent();
1645             fragment.mIsLoadingNote = false;
1646         }
1647     }
1648 
1649     private static class SaveNoteTask extends AsyncTask&lt;Void, Void, Void&gt; {
1650         WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1651 
1652         SaveNoteTask(NoteEditorFragment fragment) {
1653             mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1654         }
1655 
1656         @Override
1657         protected Void doInBackground(Void... args) {
1658             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1659 
1660             if (fragment != null) {
1661                 fragment.saveNote();
1662             }
1663 
1664             return null;
1665         }
1666 
1667         @Override
1668         protected void onPostExecute(Void nada) {
1669             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1670 
<abbr title="1671             if (fragment != null &amp;&amp; fragment.getActivity() != null &amp;&amp; !fragment.getActivity().isFinishing()) {">1671             if (fragment != null &amp;&amp; fragment.getActivity() != null &amp;&amp; !fragment.getActivity().isFinishingðŸ”µ</abbr>
1672                 // Update links
1673                 fragment.linkifyEditorContent();
1674                 fragment.updateMarkdownView();
1675             }
1676         }
1677     }
1678 
1679     private void linkifyEditorContent() {
1680         if (getActivity() == null || getActivity().isFinishing()) {
1681             return;
1682         }
1683 
1684         if (PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_DETECT_LINKS)) {
1685             SimplenoteLinkify.addLinks(mContentEditText, Linkify.ALL);
1686         }
1687     }
1688 
1689     // Show tabs if markdown is enabled globally, for current note, and not tablet landscape
1690     private void updateMarkdownView() {
1691         if (!mIsMarkdownEnabled) {
1692             return;
1693         }
1694 
1695         Activity activity = getActivity();
1696         if (activity instanceof NotesActivity) {
1697             // This fragment lives in NotesActivity, so load markdown in this fragment&#x27;s WebView.
1698             loadMarkdownData();
1699         } else {
1700             // This fragment lives in the NoteEditorActivity&#x27;s ViewPager.
1701             if (mNoteMarkdownFragment == null) {
1702                 mNoteMarkdownFragment = ((NoteEditorActivity) requireActivity())
1703                         .getNoteMarkdownFragment();
1704                 ((NoteEditorActivity) requireActivity()).showTabs();
1705             }
1706             // Load markdown in the sibling NoteMarkdownFragment&#x27;s WebView.
1707             mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPreviewTextContent());
1708         }
1709     }
1710 
1711     private ColorStateList getChipBackgroundColor() {
1712         int[][] states = new int[][] {
1713             new int[] { android.R.attr.state_checked}, // checked
1714             new int[] {-android.R.attr.state_checked}  // unchecked
1715         };
1716 
1717         int[] colors = new int[] {
1718             ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOnBackgroundColor),
1719             ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOffBackgroundColor)
1720         };
1721 
1722         return new ColorStateList(states, colors);
1723     }
1724 
1725     private void setChips(CharSequence text) {
1726         mTagPadding.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1727         mTagChips.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1728         mTagChips.setSingleSelection(true);
1729         mTagChips.removeAllViews();
1730         SimpleStringSplitter tags = new SimpleStringSplitter(SPACE);
1731         tags.setString(text.toString());
1732 
1733         for (String tag : tags) {
1734             final Chip chip = new Chip(requireContext());
1735             chip.setText(tag);
1736             chip.setCheckable(true);
1737             chip.setCheckedIcon(null);
1738             chip.setChipBackgroundColor(getChipBackgroundColor());
1739             chip.setTextColor(ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipTextColor));
1740             chip.setStateListAnimator(null);
1741             chip.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
1742                 @Override
1743                 public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
1744                     chip.setCloseIconVisible(isChecked);
1745                 }
1746             });
1747             chip.setOnCloseIconClickListener(new View.OnClickListener() {
1748                 @Override
1749                 public void onClick(View view) {
1750                     mTagChips.removeView(view);
1751                     updateTags();
1752                     AnalyticsTracker.track(
1753                         EDITOR_TAG_REMOVED,
1754                         CATEGORY_NOTE,
1755                         &quot;tag_removed_from_note&quot;
1756                     );
1757                 }
1758             });
1759             mTagChips.addView(chip);
1760         }
1761     }
1762 
1763     private void updateTags() {
1764         if (mNote == null) {
1765             return;
1766         }
1767 
1768         mNote.setTagString(getNoteTagsString());
1769         mNote.setModificationDate(Calendar.getInstance());
1770         updateTagList();
1771         mNote.save();
1772     }
1773 }
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 package com.automattic.simplenote;
   2 
   3 import android.app.Activity;
   4 import android.content.Context;
   5 import android.content.SharedPreferences;
   6 import android.content.res.ColorStateList;
   7 import android.database.Cursor;
   8 import android.graphics.Typeface;
   9 import android.graphics.drawable.Drawable;
  10 import android.os.AsyncTask;
  11 import android.os.Bundle;
  12 import android.os.Handler;
  13 import android.text.Editable;
  14 import android.text.Layout;
  15 import android.text.Spanned;
  16 import android.text.TextUtils.SimpleStringSplitter;
  17 import android.text.TextWatcher;
  18 import android.text.style.MetricAffectingSpan;
  19 import android.text.style.RelativeSizeSpan;
  20 import android.text.style.StyleSpan;
  21 import android.text.style.URLSpan;
  22 import android.text.util.Linkify;
  23 import android.util.TypedValue;
  24 import android.view.LayoutInflater;
  25 import android.view.Menu;
  26 import android.view.MenuInflater;
  27 import android.view.MenuItem;
  28 import android.view.View;
  29 import android.view.ViewGroup;
  30 import android.view.ViewTreeObserver;
  31 import android.view.inputmethod.InputMethodManager;
  32 import android.webkit.WebResourceRequest;
  33 import android.webkit.WebView;
  34 import android.webkit.WebViewClient;
  35 import android.widget.CompoundButton;
  36 import android.widget.CursorAdapter;
  37 import android.widget.LinearLayout;
  38 import android.widget.TextView;
  39 import android.widget.Toast;
  40 import androidx.annotation.NonNull;
  41 import androidx.annotation.StringRes;
  42 import androidx.appcompat.app.AppCompatActivity;
  43 import androidx.appcompat.view.ActionMode;
  44 import androidx.core.app.ShareCompat;
  45 import androidx.core.view.MenuCompat;
  46 import androidx.core.widget.NestedScrollView;
  47 import androidx.fragment.app.Fragment;
  48 import androidx.fragment.app.FragmentTransaction;
  49 import androidx.preference.PreferenceManager;
  50 import com.automattic.simplenote.analytics.AnalyticsTracker;
  51 import com.automattic.simplenote.models.Note;
  52 import com.automattic.simplenote.models.Tag;
  53 import com.automattic.simplenote.utils.AppLog.Type;
  54 import com.automattic.simplenote.utils.AppLog;
  55 import com.automattic.simplenote.utils.AutoBullet;
  56 import com.automattic.simplenote.utils.BrowserUtils;
  57 import com.automattic.simplenote.utils.ContextUtils;
  58 import com.automattic.simplenote.utils.DisplayUtils;
  59 import com.automattic.simplenote.utils.DrawableUtils;
  60 import com.automattic.simplenote.utils.MatchOffsetHighlighter;
  61 import com.automattic.simplenote.utils.NetworkUtils;
  62 import com.automattic.simplenote.utils.NoteUtils;
  63 import com.automattic.simplenote.utils.PrefUtils;
  64 import com.automattic.simplenote.utils.SimplenoteLinkify;
  65 import com.automattic.simplenote.utils.SimplenoteMovementMethod;
  66 import com.automattic.simplenote.utils.SpaceTokenizer;
  67 import com.automattic.simplenote.utils.TagUtils;
  68 import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;
  69 import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;
  70 import com.automattic.simplenote.utils.TextHighlighter;
  71 import com.automattic.simplenote.utils.ThemeUtils;
  72 import com.automattic.simplenote.utils.WidgetUtils;
  73 import com.automattic.simplenote.widgets.SimplenoteEditText;
  74 import com.google.android.material.chip.Chip;
  75 import com.google.android.material.chip.ChipGroup;
  76 import com.google.android.material.snackbar.Snackbar;
  77 import com.simperium.client.Bucket;
  78 import com.simperium.client.BucketObjectMissingException;
  79 import com.simperium.client.Query;
  80 import java.lang.ref.WeakReference;
  81 import java.util.Calendar;
  82 import static com.automattic.simplenote.analytics.AnalyticsTracker.CATEGORY_NOTE;
  83 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_CHECKLIST_INSERTED;
  84 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_CONTENT_SHARED;
  85 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_EDITED;
  86 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_PUBLISHED;
  87 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_UNPUBLISHED;
  88 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_ADDED;
  89 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_REMOVED;
  90 import static com.automattic.simplenote.utils.SearchTokenizer.SPACE;
  91 import static com.automattic.simplenote.utils.SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX;
  92 
  93 
<abbr title="  94 public class NoteEditorFragment extends Fragment implements Bucket.Listener&lt;Note&gt; , TextWatcher , OnTagAddedListener , View.OnFocusChangeListener , SimplenoteEditText.OnSelectionChangedListener , ShareBottomSheetDialog.ShareSheetListener , HistoryBottomSheetDialog.HistorySheetListener , SimplenoteEditText.OnCheckboxToggledListener {">  94 public class NoteEditorFragment extends Fragment implements Bucket.Listener&lt;Note&gt; , TextWatcher , OnTagAdðŸ”µ</abbr>
  95     public static final String ARG_IS_FROM_WIDGET = &quot;is_from_widget&quot;;
  96 
  97     public static final String ARG_ITEM_ID = &quot;item_id&quot;;
  98 
  99     public static final String ARG_NEW_NOTE = &quot;new_note&quot;;
 100 
 101     public static final String ARG_MATCH_OFFSETS = &quot;match_offsets&quot;;
 102 
 103     public static final String ARG_MARKDOWN_ENABLED = &quot;markdown_enabled&quot;;
 104 
 105     public static final String ARG_PREVIEW_ENABLED = &quot;preview_enabled&quot;;
 106 
 107     private static final String STATE_NOTE_ID = &quot;state_note_id&quot;;
 108 
 109     private static final int AUTOSAVE_DELAY_MILLIS = 2000;
 110 
 111     private static final int MAX_REVISIONS = 30;
 112 
 113     private static final int PUBLISH_TIMEOUT = 20000;
 114 
 115     private static final int HISTORY_TIMEOUT = 10000;
 116 
 117     private Note mNote;
 118 
 119     private final Runnable mAutoSaveRunnable = new Runnable() {
 120         @Override
 121         public void run() {
 122             saveAndSyncNote();
 123         }
 124     };
 125 
 126     private Bucket&lt;Note&gt; mNotesBucket;
 127 
 128     private View mRootView;
 129 
 130     private View mTagPadding;
 131 
 132     private SimplenoteEditText mContentEditText;
 133 
 134     private ChipGroup mTagChips;
 135 
 136     private TagsMultiAutoCompleteTextView mTagInput;
 137 
 138     private Handler mAutoSaveHandler;
 139 
 140     private Handler mPublishTimeoutHandler;
 141 
 142     private Handler mHistoryTimeoutHandler;
 143 
 144     private LinearLayout mPlaceholderView;
 145 
 146     private CursorAdapter mAutocompleteAdapter;
 147 
 148     private boolean mIsLoadingNote;
 149 
 150     private boolean mIsMarkdownEnabled;
 151 
 152     private boolean mIsPreviewEnabled;
 153 
 154     private boolean mShouldScrollToSearchMatch;
 155 
 156     private ActionMode mActionMode;
 157 
 158     private MenuItem mChecklistMenuItem;
 159 
 160     private MenuItem mCopyMenuItem;
 161 
 162     private MenuItem mInformationMenuItem;
 163 
 164     private MenuItem mShareMenuItem;
 165 
 166     private MenuItem mViewLinkMenuItem;
 167 
 168     private String mLinkUrl;
 169 
 170     private String mLinkText;
 171 
 172     private MatchOffsetHighlighter mHighlighter;
 173 
 174     private Drawable mBrowserIcon;
 175 
 176     private Drawable mCallIcon;
 177 
 178     private Drawable mCopyIcon;
 179 
 180     private Drawable mEmailIcon;
 181 
 182     private Drawable mLinkIcon;
 183 
 184     private Drawable mMapIcon;
 185 
 186     private Drawable mShareIcon;
 187 
 188     private MatchOffsetHighlighter.SpanFactory mMatchHighlighter;
 189 
 190     private String mMatchOffsets;
 191 
 192     private int mCurrentCursorPosition;
 193 
 194     private HistoryBottomSheetDialog mHistoryBottomSheet;
 195 
 196     private boolean mIsPaused;
 197 
 198     private boolean mIsFromWidget;
 199 
 200     // Hides the history bottom sheet if no revisions are loaded
 201     // Hides the history bottom sheet if no revisions are loaded
 202     private final Runnable mHistoryTimeoutRunnable = new Runnable() {
 203         @Override
 204         public void run() {
 205             if (!isAdded()) {
 206                 return;
 207             }
 208 
 209             requireActivity().runOnUiThread(new Runnable() {
 210                 @Override
 211                 public void run() {
<abbr title=" 212                     if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; !mHistoryBottomSheet.isHistoryLoaded()) {"> 212                     if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowðŸ”µ</abbr>
 213                         mHistoryBottomSheet.dismiss();
 214                         Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 215                     }
 216                 }
 217             });
 218         }
 219     };
 220 
 221     private InfoBottomSheetDialog mInfoBottomSheet;
 222 
 223     private ShareBottomSheetDialog mShareBottomSheet;
 224 
 225     // Contextual action bar for dealing with links
 226     private final ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
 227         // Called when the action mode is created; startActionMode() was called
 228         @Override
 229         public boolean onCreateActionMode(ActionMode mode, Menu menu) {
 230             // Inflate a menu resource providing context menu items
 231             MenuInflater inflater = mode.getMenuInflater();
 232             if (inflater != null) {
 233                 inflater.inflate(R.menu.view_link, menu);
 234                 mCopyMenuItem = menu.findItem(R.id.menu_copy);
 235                 mShareMenuItem = menu.findItem(R.id.menu_share);
 236                 mViewLinkMenuItem = menu.findItem(R.id.menu_view_link);
 237                 mode.setTitle(getString(R.string.link));
 238                 mode.setTitleOptionalHint(false);
 239                 DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 240             }
<abbr title=" 241             requireActivity().getWindow().setStatusBarColor(ThemeUtils.getColorFromAttribute(requireContext(), R.attr.mainBackgroundColor));"> 241             requireActivity().getWindow().setStatusBarColor(ThemeUtils.getColorFromAttribute(requireConteðŸ”µ</abbr>
 242             return true;
 243         }
 244 
 245         // Called each time the action mode is shown. Always called after onCreateActionMode, but
 246         // may be called multiple times if the mode is invalidated.
 247         @Override
 248         public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 249             return false; // Return false if nothing is done
 250         }
 251 
 252         // Called when the user selects a contextual menu item
 253         @Override
 254         public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 255             switch (item.getItemId()) {
 256                 case R.id.menu_view_link :
 257                     if (mLinkText != null) {
 258                         if (mLinkText.startsWith(SIMPLENOTE_LINK_PREFIX)) {
<abbr title=" 259                             SimplenoteLinkify.openNote(requireActivity(), mLinkText.replace(SIMPLENOTE_LINK_PREFIX, &quot;&quot;));"> 259                             SimplenoteLinkify.openNote(requireActivity(), mLinkText.replace(SIMPLENOTE_LIðŸ”µ</abbr>
 260                         } else {
 261                             try {
 262                                 BrowserUtils.launchBrowserOrShowError(requireContext(), mLinkText);
 263                             } catch (java.lang.Exception e) {
 264                                 e.printStackTrace();
 265                             }
 266                         }
 267                         mode.finish();// Action picked, so close the CAB
 268 
 269                     }
 270                     return true;
 271                 case R.id.menu_copy :
 272                     if ((mLinkText != null) &amp;&amp; (getActivity() != null)) {
 273                         if (BrowserUtils.copyToClipboard(requireContext(), mLinkText)) {
 274                             Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 275                         } else {
<abbr title=" 276                             Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();"> 276                             Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT)ðŸ”µ</abbr>
 277                         }
 278                         mode.finish();
 279                     }
 280                     return true;
 281                 case R.id.menu_share :
 282                     if (mLinkText != null) {
 283                         showShare(mLinkText);
 284                         mode.finish();
 285                     }
 286                     return true;
 287                 default :
 288                     return false;
 289             }
 290         }
 291 
 292         // Called when the user exits the action mode
 293         @Override
 294         public void onDestroyActionMode(ActionMode mode) {
 295             if (mActionMode != null) {
 296                 mActionMode.setSubtitle(&quot;&quot;);
 297                 mActionMode = null;
 298             }
 299             new Handler().postDelayed(new Runnable() {
 300                 @Override
 301                 public void run() {
<abbr title=" 302                     requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 302                     requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.colðŸ”µ</abbr>
 303                 }
 304             }, requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime));
 305         }
 306     };
 307 
 308     private Snackbar mPublishingSnackbar;
 309 
 310     private boolean mHideActionOnSuccess;
 311 
 312     // Resets note publish status if Simperium never returned the new publish status
 313     // Resets note publish status if Simperium never returned the new publish status
 314     private final Runnable mPublishTimeoutRunnable = new Runnable() {
 315         @Override
 316         public void run() {
 317             if (!isAdded()) return;
 318 
 319             requireActivity().runOnUiThread(new Runnable() {
 320                 @Override
 321                 public void run() {
 322 
 323                     mNote.setPublished(!mNote.isPublished());
 324                     mNote.save();
 325 
 326                     updatePublishedState(false);
 327                 }
 328             });
 329         }
 330     };
 331 
 332     private NoteMarkdownFragment mNoteMarkdownFragment;
 333 
 334     private String mCss;
 335 
 336     private WebView mMarkdown;
 337 
 338     /**
 339      * Mandatory empty constructor for the fragment manager to instantiate the
 340      * fragment (e.g. upon screen orientation changes).
 341      */
 342     public NoteEditorFragment() {
 343     }
 344 
 345     @Override
 346     public void onCreate(Bundle savedInstanceState) {
 347         super.onCreate(savedInstanceState);
 348         AppLog.add(Type.NETWORK, NetworkUtils.getNetworkInfo(requireContext()));
 349         AppLog.add(Type.SCREEN, &quot;Created (NoteEditorFragment)&quot;);
 350         mInfoBottomSheet = new InfoBottomSheetDialog(this);
 351         mShareBottomSheet = new ShareBottomSheetDialog(this, this);
 352         mHistoryBottomSheet = new HistoryBottomSheetDialog(this, this);
 353         Simplenote currentApp = ((Simplenote) (requireActivity().getApplication()));
 354         mNotesBucket = currentApp.getNotesBucket();
<abbr title=" 355         mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.actionModeTextColor);"> 355         mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp,ðŸ”µ</abbr>
<abbr title=" 356         mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.attr.actionModeTextColor);"> 356         mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.aðŸ”µ</abbr>
<abbr title=" 357         mLinkIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_note_24dp, R.attr.actionModeTextColor);"> 357         mLinkIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_note_24dp, R.attðŸ”µ</abbr>
<abbr title=" 358         mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.actionModeTextColor);"> 358         mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.ðŸ”µ</abbr>
<abbr title=" 359         mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp, R.attr.actionModeTextColor);"> 359         mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp,ðŸ”µ</abbr>
<abbr title=" 360         mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attr.actionModeTextColor);"> 360         mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attðŸ”µ</abbr>
<abbr title=" 361         mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.attr.actionModeTextColor);"> 361         mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.aðŸ”µ</abbr>
 362         mAutoSaveHandler = new Handler();
 363         mPublishTimeoutHandler = new Handler();
 364         mHistoryTimeoutHandler = new Handler();
<abbr title=" 365         mMatchHighlighter = new TextHighlighter(requireActivity(), R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor);"> 365         mMatchHighlighter = new TextHighlighter(requireActivity(), R.attr.editorSearchHighlightForegroundðŸ”µ</abbr>
 366         mAutocompleteAdapter = new CursorAdapter(getActivity(), null, 0x0) {
 367             @Override
 368             public View newView(Context context, Cursor cursor, ViewGroup parent) {
 369                 Activity activity = ((Activity) (context));
 370                 if (activity == null) {
 371                     return null;
 372                 }
 373                 return activity.getLayoutInflater().inflate(R.layout.tag_autocomplete_list_item, null);
 374             }
 375 
 376             @Override
 377             public void bindView(View view, Context context, Cursor cursor) {
 378                 TextView textView = ((TextView) (view));
 379                 textView.setText(convertToString(cursor));
 380             }
 381 
 382             @Override
 383             public CharSequence convertToString(Cursor cursor) {
 384                 return cursor.getString(cursor.getColumnIndex(Tag.NAME_PROPERTY));
 385             }
 386 
 387             @Override
 388             public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 389                 Activity activity = getActivity();
 390                 if (activity == null) {
 391                     return null;
 392                 }
 393                 Simplenote application = ((Simplenote) (activity.getApplication()));
 394                 Query&lt;Tag&gt; query = application.getTagsBucket().query();
 395                 // make the tag name available to the cursor
 396                 query.include(Tag.NAME_PROPERTY);
 397                 // sort the tags by their names
 398                 query.order(Tag.NAME_PROPERTY);
 399                 // if there&#x27;s a filter string find only matching tag names
 400                 if (filter != null) {
<abbr title=" 401                     query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filter));"> 401                     query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filteðŸ”µ</abbr>
 402                 }
 403                 return query.execute();
 404             }
 405         };
 406         WidgetUtils.updateNoteWidgets(requireActivity().getApplicationContext());
 407     }
 408 
 409     @Override
 410     public View onCreateView(@NonNull
 411     LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
 412         mRootView = inflater.inflate(R.layout.fragment_note_editor, container, false);
 413         mContentEditText = mRootView.findViewById(R.id.note_content);
 414         mContentEditText.addOnSelectionChangedListener(this);
 415         mContentEditText.setOnCheckboxToggledListener(this);
 416         mContentEditText.setMovementMethod(SimplenoteMovementMethod.getInstance());
 417         mContentEditText.setOnFocusChangeListener(this);
<abbr title=" 418         mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()));"> 418         mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()))ðŸ”µ</abbr>
 419         mTagInput = mRootView.findViewById(R.id.tag_input);
 420         mTagInput.setDropDownBackgroundResource(R.drawable.bg_list_popup);
 421         mTagInput.setTokenizer(new SpaceTokenizer());
 422         mTagInput.setOnFocusChangeListener(this);
 423         mTagChips = mRootView.findViewById(R.id.tag_chips);
 424         mTagPadding = mRootView.findViewById(R.id.tag_padding);
 425         mHighlighter = new MatchOffsetHighlighter(mMatchHighlighter, mContentEditText);
 426         mPlaceholderView = mRootView.findViewById(R.id.placeholder);
 427         if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; (mNote == null)) {
 428             mPlaceholderView.setVisibility(View.VISIBLE);
 429             requireActivity().invalidateOptionsMenu();
 430             mMarkdown = mRootView.findViewById(R.id.markdown);
 431             mMarkdown.setWebViewClient(new WebViewClient() {
 432                 @Override
 433                 public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
 434                     String url = request.getUrl().toString();
 435                     if (url.startsWith(SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX)) {
<abbr title=" 436                         SimplenoteLinkify.openNote(requireActivity(), url.replace(SIMPLENOTE_LINK_PREFIX, &quot;&quot;));"> 436                         SimplenoteLinkify.openNote(requireActivity(), url.replace(SIMPLENOTE_LINK_PREFIX,ðŸ”µ</abbr>
 437                     } else {
 438                         BrowserUtils.launchBrowserOrShowError(requireContext(), url);
 439                     }
 440                     return true;
 441                 }
 442             });
<abbr title=" 443             mCss = ContextUtils.readCssFile(requireContext(), ThemeUtils.getCssFromStyle(requireContext()));"> 443             mCss = ContextUtils.readCssFile(requireContext(), ThemeUtils.getCssFromStyle(requireContext()ðŸ”µ</abbr>
 444         }
 445         mTagInput.setAdapter(mAutocompleteAdapter);
 446         Bundle arguments = getArguments();
 447         if ((arguments != null) &amp;&amp; arguments.containsKey(ARG_ITEM_ID)) {
 448             // Load note if we were passed a note Id
 449             String key = arguments.getString(ARG_ITEM_ID);
 450             if (arguments.containsKey(ARG_MATCH_OFFSETS)) {
 451                 mMatchOffsets = arguments.getString(ARG_MATCH_OFFSETS);
 452             }
 453             mIsFromWidget = arguments.getBoolean(ARG_IS_FROM_WIDGET);
 454             if (mIsFromWidget) {
 455                 AppLog.add(Type.ACTION, &quot;Opened from widget (NoteEditorFragment)&quot;);
 456             } else {
 457                 AppLog.add(Type.ACTION, &quot;Opened from list (NoteEditorFragment)&quot;);
 458             }
 459             new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, key);
 460         } else if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; (savedInstanceState != null)) {
 461             // Restore selected note when in dual pane mode
 462             String noteId = savedInstanceState.getString(STATE_NOTE_ID);
 463             if (noteId != null) {
 464                 setNote(noteId);
 465             }
 466         }
 467         ViewTreeObserver viewTreeObserver = mContentEditText.getViewTreeObserver();
 468         viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
 469             @Override
 470             public void onGlobalLayout() {
 471                 // If a note was loaded with search matches, scroll to the first match in the editor
 472                 if (mShouldScrollToSearchMatch &amp;&amp; (mMatchOffsets != null)) {
 473                     if (!isAdded()) {
 474                         return;
 475                     }
 476                     // Get the character location of the first search match
<abbr title=" 477                     int matchLocation = MatchOffsetHighlighter.getFirstMatchLocation(mContentEditText.getText(), mMatchOffsets);"> 477                     int matchLocation = MatchOffsetHighlighter.getFirstMatchLocation(mContentEditText.getðŸ”µ</abbr>
 478                     if (matchLocation == 0) {
 479                         return;
 480                     }
 481                     // Calculate how far to scroll to bring the match into view
 482                     Layout layout = mContentEditText.getLayout();
 483                     int lineTop = layout.getLineTop(layout.getLineForOffset(matchLocation));
 484                     ((NestedScrollView) (mRootView)).smoothScrollTo(0, lineTop);
 485                     mShouldScrollToSearchMatch = false;
 486                 }
 487             }
 488         });
 489         setHasOptionsMenu(true);
 490         return mRootView;
 491     }
 492 
 493     public void scrollToMatch(int location) {
 494         if (isAdded()) {
 495             // Calculate how far to scroll to bring the match into view
 496             Layout layout = mContentEditText.getLayout();
 497             int lineTop = layout.getLineTop(layout.getLineForOffset(location));
 498             ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 499         }
 500     }
 501 
 502     @Override
 503     public void onResume() {
 504         super.onResume();
 505         mNotesBucket.start();
 506         AppLog.add(Type.SYNC, &quot;Started note bucket (NoteEditorFragment)&quot;);
 507         mNotesBucket.addListener(this);
 508         mTagInput.setOnTagAddedListener(this);
 509 
 510         if (mContentEditText != null) {
<abbr title=" 511             mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()));"> 511             mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContextðŸ”µ</abbr>
 512 
 513             if (mContentEditText.hasFocus()) {
 514                 showSoftKeyboard();
 515             }
 516         }
 517     }
 518 
 519     private void showSoftKeyboard() {
 520         new Handler().postDelayed(new Runnable() {
 521             @Override
 522             public void run() {
 523                 if (getActivity() == null) {
 524                     return;
 525                 }
<abbr title=" 526                 InputMethodManager inputMethodManager = ((InputMethodManager) (getActivity().getSystemService(Context.INPUT_METHOD_SERVICE)));"> 526                 InputMethodManager inputMethodManager = ((InputMethodManager) (getActivity().getSystemSerðŸ”µ</abbr>
 527                 if (inputMethodManager != null) {
 528                     inputMethodManager.showSoftInput(mContentEditText, 0);
 529                 }
 530             }
 531         }, 100);
 532     }
 533 
 534     @Override
 535     public void onPause() {
 536         super.onPause();  // Always call the superclass method first
 537         mIsPaused = true;
 538 
 539         // Hide soft keyboard if it is showing...
 540         DisplayUtils.hideKeyboard(mContentEditText);
 541 
 542         mTagInput.setOnTagAddedListener(null);
 543 
 544         if (mAutoSaveHandler != null) {
 545             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 546             mAutoSaveHandler.post(mAutoSaveRunnable);
 547         }
 548 
 549         if (mPublishTimeoutHandler != null) {
 550             mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
 551         }
 552 
 553         if (mHistoryTimeoutHandler != null) {
 554             mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 555         }
 556 
 557         mHighlighter.stop();
 558         saveNote();
 559         AppLog.add(Type.SCREEN, &quot;Paused (NoteEditorFragment)&quot;);
 560     }
 561 
 562     @Override
 563     public void onDestroy() {
 564         super.onDestroy();
 565         mNotesBucket.removeListener(this);
 566         mNotesBucket.stop();
 567         AppLog.add(Type.SYNC, &quot;Stopped note bucket (NoteEditorFragment)&quot;);
 568         AppLog.add(Type.SCREEN, &quot;Destroyed (NoteEditorFragment)&quot;);
 569     }
 570 
 571     @Override
 572     public void onSaveInstanceState(@NonNull Bundle outState) {
 573         super.onSaveInstanceState(outState);
 574 
 575         if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote != null) {
 576             outState.putString(STATE_NOTE_ID, mNote.getSimperiumKey());
 577         }
 578     }
 579 
 580     @Override
 581     public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
 582         super.onCreateOptionsMenu(menu, inflater);
 583 
<abbr title=" 584         if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFragment == null)) {"> 584         if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMðŸ”µ</abbr>
 585             return;
 586         }
 587 
 588         inflater.inflate(R.menu.note_editor, menu);
 589         MenuCompat.setGroupDividerEnabled(menu, true);
 590     }
 591 
 592     @Override
 593     public boolean onOptionsItemSelected(@NonNull
 594     MenuItem item) {
 595         switch (item.getItemId()) {
 596             case R.id.menu_checklist :
 597                 insertChecklist();
 598                 return true;
 599             case R.id.menu_copy :
 600                 if (BrowserUtils.copyToClipboard(requireContext(), mNote.getPublishedUrl())) {
 601                     Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 602                 } else {
 603                     Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();
 604                 }
 605                 return true;
 606             case R.id.menu_copy_internal :
<abbr title=" 607                 if (BrowserUtils.copyToClipboard(requireContext(), SimplenoteLinkify.getNoteLinkWithTitle(mNote.getTitle(), mNote.getSimperiumKey()))) {"> 607                 if (BrowserUtils.copyToClipboard(requireContext(), SimplenoteLinkify.getNoteLinkWithTitleðŸ”µ</abbr>
 608                     Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 609                 } else {
 610                     Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();
 611                 }
 612                 return true;
 613             case R.id.menu_history :
 614                 showHistory();
 615                 return true;
 616             case R.id.menu_info :
 617                 showInfo();
 618                 return true;
 619             case R.id.menu_markdown :
 620                 setMarkdown(!item.isChecked());
 621                 return true;
 622             case R.id.menu_pin :
 623                 NoteUtils.setNotePin(mNote, !item.isChecked());
 624                 requireActivity().invalidateOptionsMenu();
 625                 return true;
 626             case R.id.menu_publish :
 627                 if (item.isChecked()) {
 628                     unpublishNote();
 629                 } else {
 630                     publishNote();
 631                 }
 632                 return true;
 633             case R.id.menu_share :
 634                 shareNote();
 635                 return true;
 636             case R.id.menu_trash :
 637                 if (!isAdded()) {
 638                     return false;
 639                 }
 640                 deleteNote();
 641                 return true;
 642             case android.R.id.home :
 643                 AppLog.add(Type.ACTION, &quot;Tapped back arrow in app bar (NoteEditorFragment)&quot;);
 644                 if (!isAdded()) {
 645                     return false;
 646                 }
 647                 requireActivity().finish();
 648                 return true;
 649             default :
 650                 return super.onOptionsItemSelected(item);
 651         }
 652     }
 653 
 654     @Override
 655     public void onPrepareOptionsMenu(@NonNull Menu menu) {
 656         if (mNote != null) {
 657             MenuItem pinItem = menu.findItem(R.id.menu_pin);
 658             MenuItem shareItem = menu.findItem(R.id.menu_share);
 659             MenuItem historyItem = menu.findItem(R.id.menu_history);
 660             MenuItem publishItem = menu.findItem(R.id.menu_publish);
 661             MenuItem copyLinkItem = menu.findItem(R.id.menu_copy);
 662             MenuItem markdownItem = menu.findItem(R.id.menu_markdown);
 663             MenuItem trashItem = menu.findItem(R.id.menu_trash);
 664             mChecklistMenuItem = menu.findItem(R.id.menu_checklist);
 665             mInformationMenuItem = menu.findItem(R.id.menu_info).setVisible(true);
 666 
 667             pinItem.setChecked(mNote.isPinned());
 668             publishItem.setChecked(mNote.isPublished());
 669             markdownItem.setChecked(mNote.isMarkdownEnabled());
 670 
 671             // Disable actions when note is in Trash or markdown view is shown on large device.
 672             if (mNote.isDeleted() || (mMarkdown != null &amp;&amp; mMarkdown.getVisibility() == View.VISIBLE)) {
 673                 pinItem.setEnabled(false);
 674                 shareItem.setEnabled(false);
 675                 historyItem.setEnabled(false);
 676                 publishItem.setEnabled(false);
 677                 copyLinkItem.setEnabled(false);
 678                 markdownItem.setEnabled(false);
 679                 mChecklistMenuItem.setEnabled(false);
 680                 DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 0.3);  // 0.3 is 30% opacity.
 681             } else {
 682                 pinItem.setEnabled(true);
 683                 shareItem.setEnabled(true);
 684                 historyItem.setEnabled(true);
 685                 publishItem.setEnabled(true);
 686                 copyLinkItem.setEnabled(mNote.isPublished());
 687                 markdownItem.setEnabled(true);
 688                 mChecklistMenuItem.setEnabled(true);
 689                 DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 1.0);  // 1.0 is 100% opacity.
 690             }
 691 
 692             if (mNote.isDeleted()) {
 693                 trashItem.setTitle(R.string.restore);
 694             } else {
 695                 trashItem.setTitle(R.string.trash);
 696             }
 697         }
 698 
 699         DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 700         super.onPrepareOptionsMenu(menu);
 701     }
 702 
 703     public void insertChecklist() {
 704         DrawableUtils.startAnimatedVectorDrawable(mChecklistMenuItem.getIcon());
 705 
 706         try {
 707             mContentEditText.insertChecklist();
 708         } catch (Exception e) {
 709             e.printStackTrace();
 710             return;
 711         }
 712 
 713         AnalyticsTracker.track(
 714             EDITOR_CHECKLIST_INSERTED,
 715             CATEGORY_NOTE,
 716             &quot;toolbar_button&quot;
 717         );
 718     }
 719 
 720     @Override
 721     public void onCheckboxToggled() {
 722         // Save note (using delay) after toggling a checkbox
 723         if (mAutoSaveHandler != null) {
 724             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 725             mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 726         }
 727     }
 728 
 729     private void deleteNote() {
 730         NoteUtils.deleteNote(mNote, getActivity());
 731         requireActivity().finish();
 732     }
 733 
 734     protected void clearMarkdown() {
 735         mMarkdown.loadDataWithBaseURL(&quot;file:///android_asset/&quot;, mCss + &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 736     }
 737 
 738     protected void hideMarkdown() {
 739         mMarkdown.setVisibility(View.INVISIBLE);
 740     }
 741 
 742     protected void showMarkdown() {
 743         loadMarkdownData();
 744         mMarkdown.setVisibility(View.VISIBLE);
 745 
 746         new Handler().postDelayed(
 747             new Runnable() {
 748                 @Override
 749                 public void run() {
 750                     requireActivity().invalidateOptionsMenu();
 751                 }
 752             },
 753             getResources().getInteger(R.integer.time_animation)
 754         );
 755     }
 756 
 757     public void shareNote() {
 758         if (mNote != null) {
 759             mContentEditText.clearFocus();
 760             showShareSheet();
 761             AnalyticsTracker.track(
 762                 EDITOR_NOTE_CONTENT_SHARED,
 763                 CATEGORY_NOTE,
 764                 &quot;action_bar_share_button&quot;
 765             );
 766         }
 767     }
 768 
 769     public void showHistory() {
 770         if (mNote != null &amp;&amp; mNote.getVersion() &gt; 1) {
 771             mContentEditText.clearFocus();
 772             mHistoryTimeoutHandler.postDelayed(mHistoryTimeoutRunnable, HISTORY_TIMEOUT);
 773             showHistorySheet();
 774         } else {
 775             Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 776         }
 777     }
 778 
 779     public void showInfo() {
 780         DrawableUtils.startAnimatedVectorDrawable(mInformationMenuItem.getIcon());
 781 
 782         if (mNote != null) {
 783             mContentEditText.clearFocus();
 784             saveNote();
 785             showInfoSheet();
 786         }
 787     }
 788 
 789     private void setMarkdown(boolean isChecked) {
 790         mIsMarkdownEnabled = isChecked;
 791         showMarkdownActionOrTabs();
 792         saveNote();
 793 
 794         // Set preference so that next new note will have markdown enabled.
 795         SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(requireContext());
 796         SharedPreferences.Editor editor = prefs.edit();
 797         editor.putBoolean(PrefUtils.PREF_MARKDOWN_ENABLED, isChecked);
 798         editor.apply();
 799     }
 800 
 801     private void setMarkdownEnabled(boolean enabled) {
 802         mIsMarkdownEnabled = enabled;
 803 
 804         if (mIsMarkdownEnabled) {
 805             loadMarkdownData();
 806         }
 807     }
 808 
 809     private void showMarkdownActionOrTabs() {
 810         Activity activity = getActivity();
 811 
 812         if (activity instanceof NoteEditorActivity) {
 813             NoteEditorActivity editorActivity = (NoteEditorActivity) activity;
 814 
 815             if (mIsMarkdownEnabled) {
 816                 editorActivity.showTabs();
 817 
 818                 if (mNoteMarkdownFragment == null) {
 819                     // Get markdown fragment and update content
 820                     mNoteMarkdownFragment = editorActivity.getNoteMarkdownFragment();
 821                     mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPreviewTextContent());
 822                 }
 823             } else {
 824                 editorActivity.hideTabs();
 825             }
 826         } else if (activity instanceof NotesActivity) {
 827             setMarkdownEnabled(mIsMarkdownEnabled);
 828             ((NotesActivity) getActivity()).setMarkdownShowing(false);
 829         }
 830     }
 831 
 832     private void loadMarkdownData() {
 833         String formattedContent = NoteMarkdownFragment.getMarkdownFormattedContent(
 834                 mCss,
 835                 mContentEditText.getPreviewTextContent()
 836         );
 837 
 838         mMarkdown.loadDataWithBaseURL(null, formattedContent, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 839     }
 840 
 841     public void setNote(String noteID, String matchOffsets) {
 842         if (mAutoSaveHandler != null)
 843             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 844 
 845         mPlaceholderView.setVisibility(View.GONE);
 846 
 847         if (matchOffsets != null) {
 848             mMatchOffsets = matchOffsets;
 849         } else {
 850             mMatchOffsets = null;
 851         }
 852 
 853 
 854         saveNote();
 855 
 856         new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteID);
 857     }
 858 
 859     private void updateNote(Note updatedNote) {
 860         // update note if network change arrived
 861         mNote = updatedNote;
 862         refreshContent(true);
 863     }
 864 
 865     private void refreshContent(boolean isNoteUpdate) {
 866         if (mNote != null) {
 867             // Restore the cursor position if possible.
<abbr title=" 868             int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.getSelectionEnd());"> 868             int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEdðŸ”µ</abbr>
 869             mContentEditText.setText(mNote.getContent());
 870 
 871             if (isNoteUpdate) {
 872                 // Update markdown and preview flags from updated note.
 873                 mIsMarkdownEnabled = mNote.isMarkdownEnabled();
 874                 mIsPreviewEnabled = mNote.isPreviewEnabled();
 875 
 876                 // Show/Hide action/tabs based on markdown flag.
 877                 showMarkdownActionOrTabs();
 878 
 879                 // Save note so any local changes get synced.
 880                 mNote.save();
 881 
 882                 // Update current note object on large screen devices in landscape orientation.
 883                 if (DisplayUtils.isLargeScreenLandscape(requireContext())) {
 884                     ((NotesActivity) requireActivity()).setCurrentNote(mNote);
 885                 }
 886 
 887                 // Update overflow popup menu.
 888                 requireActivity().invalidateOptionsMenu();
 889 
 890                 if (mContentEditText.hasFocus()
 891                         &amp;&amp; cursorPosition != mContentEditText.getSelectionEnd()
 892                         &amp;&amp; cursorPosition &lt; mContentEditText.getText().length()) {
 893                     mContentEditText.setSelection(cursorPosition);
 894                 }
 895             }
 896 
 897             afterTextChanged(mContentEditText.getText());
 898             mContentEditText.processChecklists();
 899             updateTagList();
 900         }
 901     }
 902 
 903     private void updateTagList() {
 904         setChips(mNote.getTagString());
 905         mTagInput.setText(&quot;&quot;);
 906     }
 907 
 908     private int newCursorLocation(String newText, String oldText, int cursorLocation) {
 909         // Ported from the iOS app :)
 910         // Cases:
 911         // 0. All text after cursor (and possibly more) was removed ==&gt; put cursor at end
 912         // 1. Text was added after the cursor ==&gt; no change
 913         // 2. Text was added before the cursor ==&gt; location advances
 914         // 3. Text was removed after the cursor ==&gt; no change
 915         // 4. Text was removed before the cursor ==&gt; location retreats
 916         // 5. Text was added/removed on both sides of the cursor ==&gt; not handled
 917 
 918         cursorLocation = Math.max(cursorLocation, 0);
 919 
 920         int newCursorLocation = cursorLocation;
 921 
 922         int deltaLength = newText.length() - oldText.length();
 923 
 924         // Case 0
 925         if (newText.length() &lt; cursorLocation)
 926             return newText.length();
 927 
 928         boolean beforeCursorMatches = false;
 929         boolean afterCursorMatches = false;
 930 
 931         try {
<abbr title=" 932             beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation));"> 932             beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorðŸ”µ</abbr>
<abbr title=" 933             afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaLength));"> 933             afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocatioðŸ”µ</abbr>
 934         } catch (Exception e) {
 935             e.printStackTrace();
 936         }
 937 
 938         // Cases 2 and 4
 939         if (!beforeCursorMatches &amp;&amp; afterCursorMatches)
 940             newCursorLocation += deltaLength;
 941 
 942         // Cases 1, 3 and 5 have no change
 943         return newCursorLocation;
 944     }
 945 
 946     @Override
 947     public void onTagAdded(String tag) {
 948         if (mNote == null || !isAdded()) {
 949             return;
 950         }
 951 
 952         if (mNote.getTagString() != null &amp;&amp; tag.length() &gt; mNote.getTagString().length()) {
 953             AnalyticsTracker.track(
 954                 EDITOR_TAG_ADDED,
 955                 CATEGORY_NOTE,
 956                 &quot;tag_added_to_note&quot;
 957             );
 958         }
 959 
 960         mNote.setTagString(mNote.getTagString() + String.valueOf(SPACE) + tag);
 961         mNote.setModificationDate(Calendar.getInstance());
 962         updateTagList();
 963         mNote.save();
 964     }
 965 
 966     @Override
 967     public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
 968         // Unused
 969     }
 970 
 971     @Override
 972     public void afterTextChanged(Editable editable) {
 973         attemptAutoList(editable);
 974         setTitleSpan(editable);
 975         mContentEditText.fixLineSpacing();
 976     }
 977 
 978     @Override
 979     public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
 980         // When text changes, start timer that will fire after AUTOSAVE_DELAY_MILLIS passes
 981         if (mAutoSaveHandler != null) {
 982             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 983             mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 984         }
 985 
 986         // Remove search highlight spans when note content changes
 987         if (mMatchOffsets != null) {
 988             mMatchOffsets = null;
 989             mHighlighter.removeMatches();
 990         }
 991 
 992         if (!DisplayUtils.isLargeScreenLandscape(requireContext())) {
 993             ((NoteEditorActivity) requireActivity()).setSearchMatchBarVisible(false);
 994         }
 995 
 996         // Temporarily remove the text watcher as we process checklists to prevent callback looping
 997         mContentEditText.removeTextChangedListener(this);
 998         mContentEditText.processChecklists();
 999         mContentEditText.addTextChangedListener(this);
1000     }
1001 
1002     /**
1003      * Set the note title to be a larger size and bold style.
1004      *
1005      * Remove all existing spans before applying spans or performance issues will occur.  Since both
1006      * {@link RelativeSizeSpan} and {@link StyleSpan} inherit from {@link MetricAffectingSpan}, all
1007      * spans are removed when {@link MetricAffectingSpan} is removed.
1008      */
1009     private void setTitleSpan(Editable editable) {
<abbr title="1010         for (MetricAffectingSpan span : editable.getSpans(0, editable.length(), MetricAffectingSpan.class)) {">1010         for (MetricAffectingSpan span : editable.getSpans(0, editable.length(), MetricAffectingSpan.classðŸ”µ</abbr>
1011             if (span instanceof RelativeSizeSpan || span instanceof StyleSpan) {
1012                 editable.removeSpan(span);
1013             }
1014         }
1015 
1016         int newLinePosition = getNoteContentString().indexOf(&quot;\n&quot;);
1017 
1018         if (newLinePosition == 0) {
1019             return;
1020         }
1021 
1022         int titleEndPosition = (newLinePosition &gt; 0) ? newLinePosition : editable.length();
<abbr title="1023         editable.setSpan(new RelativeSizeSpan(1.3f), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);">1023         editable.setSpan(new RelativeSizeSpan(1.3f), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVðŸ”µ</abbr>
<abbr title="1024         editable.setSpan(new StyleSpan(Typeface.BOLD), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);">1024         editable.setSpan(new StyleSpan(Typeface.BOLD), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSðŸ”µ</abbr>
1025     }
1026 
1027     private void attemptAutoList(Editable editable) {
1028         int oldCursorPosition = mCurrentCursorPosition;
1029         mCurrentCursorPosition = mContentEditText.getSelectionStart();
1030         AutoBullet.apply(editable, oldCursorPosition, mCurrentCursorPosition);
1031         mCurrentCursorPosition = mContentEditText.getSelectionStart();
1032     }
1033 
1034     private void saveAndSyncNote() {
1035         if (mNote == null) {
1036             return;
1037         }
1038 
1039         AppLog.add(
1040             Type.ACTION,
1041             &quot;Edited note (ID: &quot; + mNote.getSimperiumKey() +
1042                 &quot; / Title: &quot; + mNote.getTitle() +
1043                 &quot; / Characters: &quot; + NoteUtils.getCharactersCount(mNote.getContent()) +
1044                 &quot; / Words: &quot; + NoteUtils.getWordCount(mNote.getContent()) + &quot;)&quot;
1045         );
1046         new SaveNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
1047     }
1048 
1049     public boolean isPlaceholderVisible() {
1050         if (mPlaceholderView != null) {
1051             return mPlaceholderView.getVisibility() == View.VISIBLE;
1052         } else {
1053             return false;
1054         }
1055     }
1056 
1057     public void setPlaceholderVisible(boolean isVisible) {
1058         if (isVisible) {
1059             mNote = null;
1060             mContentEditText.setText(&quot;&quot;);
1061         }
1062 
1063         if (mPlaceholderView != null) {
1064             mPlaceholderView.setVisibility(isVisible ? View.VISIBLE : View.GONE);
1065         }
1066     }
1067 
1068     @Override
1069     public void onFocusChange(View v, boolean hasFocus) {
1070         if (!hasFocus) {
1071             String tags = getNoteTagsString().trim();
1072 
1073             if (mTagInput.getText().toString().trim().length() &gt; 0
1074                 &amp;&amp; TagUtils.hashTagValid(mTagInput.getText().toString().trim())) {
1075                 onTagAdded(mTagInput.getText().toString());
1076             } else if (tags.length() &gt; 0) {
1077                 setChips(tags);
1078             }
1079         }
1080     }
1081 
1082     private Note getNote() {
1083         return mNote;
1084     }
1085 
1086     public void setNote(String noteID) {
1087         setNote(noteID, null);
1088     }
1089 
1090     private String getNoteContentString() {
1091         if (mContentEditText == null || mContentEditText.getText() == null) {
1092             return &quot;&quot;;
1093         } else {
1094             return mContentEditText.getText().toString();
1095         }
1096     }
1097 
1098     private String getNoteTagsString() {
1099         StringBuilder tags = new StringBuilder();
1100 
1101         for (int i= 0; i &lt; mTagChips.getChildCount(); i++) {
1102             tags.append(((Chip) mTagChips.getChildAt(i)).getText()).append(&quot; &quot;);
1103         }
1104 
1105         return tags.toString();
1106     }
1107 
1108     /**
1109      * Share bottom sheet callbacks
1110      */
1111 
1112     @Override
1113     public void onSharePublishClicked() {
1114         publishNote();
1115         if (mShareBottomSheet != null) {
1116             mShareBottomSheet.dismiss();
1117         }
1118     }
1119 
1120     @Override
1121     public void onShareUnpublishClicked() {
1122         unpublishNote();
1123         if (mShareBottomSheet != null) {
1124             mShareBottomSheet.dismiss();
1125         }
1126     }
1127 
1128     @Override
1129     public void onWordPressPostClicked() {
1130         if (mShareBottomSheet != null) {
1131             mShareBottomSheet.dismiss();
1132         }
1133 
1134         if (getFragmentManager() == null) {
1135             return;
1136         }
1137 
1138         FragmentTransaction ft = getFragmentManager().beginTransaction();
1139         Fragment prev = getFragmentManager().findFragmentByTag(WordPressDialogFragment.DIALOG_TAG);
1140         if (prev != null) {
1141             ft.remove(prev);
1142         }
1143         ft.addToBackStack(null);
1144 
1145         // Create and show the dialog.
1146         WordPressDialogFragment wpDialogFragment = new WordPressDialogFragment();
1147         wpDialogFragment.setNote(mNote);
1148         wpDialogFragment.show(ft, WordPressDialogFragment.DIALOG_TAG);
1149     }
1150 
1151     @Override
1152     public void onShareCollaborateClicked() {
1153         Toast.makeText(getActivity(), R.string.collaborate_message, Toast.LENGTH_LONG).show();
1154     }
1155 
1156     @Override
1157     public void onShareDismissed() {
1158 
1159     }
1160 
1161     /**
1162      * History bottom sheet listeners
1163      */
1164 
1165     @Override
1166     public void onHistoryCancelClicked() {
1167         mContentEditText.setText(mNote.getContent());
1168         if (mHistoryBottomSheet != null) {
1169             mHistoryBottomSheet.dismiss();
1170         }
1171     }
1172 
1173     @Override
1174     public void onHistoryRestoreClicked() {
1175         if (mHistoryBottomSheet != null) {
1176             mHistoryBottomSheet.dismiss();
1177         }
1178         saveAndSyncNote();
1179     }
1180 
1181     @Override
1182     public void onHistoryDismissed() {
1183         if (!mHistoryBottomSheet.didTapOnButton()) {
1184             mContentEditText.setText(mNote.getContent());
1185         }
1186 
1187         if (mHistoryTimeoutHandler != null) {
1188             mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
1189         }
1190     }
1191 
1192     @Override
1193     public void onHistoryUpdateNote(String content) {
1194         mContentEditText.setText(content);
1195     }
1196 
1197     private void saveNote() {
1198         try {
1199             if (mNote == null || mNotesBucket == null || mContentEditText == null || mIsLoadingNote ||
<abbr title="1200                 (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing())) {">1200                 (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomðŸ”µ</abbr>
1201                 return;
1202             } else {
1203                 mNote = mNotesBucket.get(mNote.getSimperiumKey());
1204                 mIsPreviewEnabled = mNote.isPreviewEnabled();
1205             }
1206 
1207             String content = mContentEditText.getPlainTextContent();
1208             String tagString = getNoteTagsString();
1209 
<abbr title="1210             if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnabled)) {">1210             if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPrevðŸ”µ</abbr>
1211                 mNote.setContent(content);
1212                 mNote.setTagString(tagString);
1213                 mNote.setModificationDate(Calendar.getInstance());
1214                 mNote.setMarkdownEnabled(mIsMarkdownEnabled);
1215                 mNote.setPreviewEnabled(mIsPreviewEnabled);
1216                 mNote.save();
1217 
1218                 AnalyticsTracker.track(
1219                     EDITOR_NOTE_EDITED,
1220                     CATEGORY_NOTE,
1221                     &quot;editor_save&quot;
1222                 );
1223 
1224                 AppLog.add(
1225                     Type.SYNC,
1226                     &quot;Saved note locally in NoteEditorFragment (ID: &quot; + mNote.getSimperiumKey() +
1227                         &quot; / Title: &quot; + mNote.getTitle() +
1228                         &quot; / Characters: &quot; + NoteUtils.getCharactersCount(content) +
1229                         &quot; / Words: &quot; + NoteUtils.getWordCount(content) + &quot;)&quot;
1230                 );
1231             }
1232         } catch (BucketObjectMissingException exception) {
1233             exception.printStackTrace();
1234         }
1235     }
1236 
1237     // Checks if cursor is at a URL when the selection changes
1238     // If it is a URL, show the contextual action bar
1239     @Override
1240     public void onSelectionChanged(int selStart, int selEnd) {
1241         mCurrentCursorPosition = selEnd;
1242         if (selStart == selEnd) {
1243             Editable noteContent = mContentEditText.getText();
1244             if (noteContent == null) {
1245                 return;
1246             }
1247             URLSpan[] urlSpans = noteContent.getSpans(selStart, selStart, URLSpan.class);
1248             if (urlSpans.length &gt; 0) {
1249                 URLSpan urlSpan = urlSpans[0];
1250                 mLinkUrl = urlSpan.getURL();
<abbr title="1251                 mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSpan)).toString();">1251                 mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpaðŸ”µ</abbr>
1252                 if (mActionMode != null) {
1253                     mActionMode.setSubtitle(mLinkText);
1254                     updateMenuItems();
1255                     return;
1256                 }
1257                 // Show the Contextual Action Bar
1258                 if (getActivity() != null) {
<abbr title="1259                     mActionMode = ((AppCompatActivity) (getActivity())).startSupportActionMode(mActionModeCallback);">1259                     mActionMode = ((AppCompatActivity) (getActivity())).startSupportActionMode(mActionModðŸ”µ</abbr>
1260                     if (mActionMode != null) {
1261                         mActionMode.setSubtitle(mLinkText);
1262                     }
1263                     updateMenuItems();
1264                 }
1265             } else if (mActionMode != null) {
1266                 mActionMode.finish();
1267                 mActionMode = null;
1268             }
1269         } else if (mActionMode != null) {
1270             mActionMode.finish();
1271             mActionMode = null;
1272         }
1273     }
1274 
1275     private void updateMenuItems() {
1276         mCopyMenuItem.setIcon(mCopyIcon);
1277         mShareMenuItem.setIcon(mShareIcon);
1278         if ((mViewLinkMenuItem != null) &amp;&amp; (mLinkUrl != null)) {
1279             if (mLinkUrl.startsWith(&quot;tel:&quot;)) {
1280                 mViewLinkMenuItem.setIcon(mCallIcon);
1281                 mViewLinkMenuItem.setTitle(getString(R.string.call));
1282             } else if (mLinkUrl.startsWith(&quot;mailto:&quot;)) {
1283                 mViewLinkMenuItem.setIcon(mEmailIcon);
1284                 mViewLinkMenuItem.setTitle(getString(R.string.email));
1285             } else if (mLinkUrl.startsWith(&quot;geo:&quot;)) {
1286                 mViewLinkMenuItem.setIcon(mMapIcon);
1287                 mViewLinkMenuItem.setTitle(getString(R.string.view_map));
1288             } else if (mLinkUrl.startsWith(SIMPLENOTE_LINK_PREFIX)) {
1289                 mViewLinkMenuItem.setIcon(mLinkIcon);
1290                 mViewLinkMenuItem.setTitle(getString(R.string.open_note));
1291             } else {
1292                 mViewLinkMenuItem.setIcon(mBrowserIcon);
1293                 mViewLinkMenuItem.setTitle(getString(R.string.view_in_browser));
1294             }
1295         }
1296     }
1297 
1298     private void setPublishedNote(boolean isPublished) {
1299         if (mNote != null) {
1300             mNote.setPublished(isPublished);
1301             mNote.save();
1302 
1303             // reset publish status in 20 seconds if we don&#x27;t hear back from Simperium
1304             mPublishTimeoutHandler.postDelayed(mPublishTimeoutRunnable, PUBLISH_TIMEOUT);
1305 
1306             AnalyticsTracker.track(
1307                 isPublished ? EDITOR_NOTE_PUBLISHED : EDITOR_NOTE_UNPUBLISHED,
1308                 CATEGORY_NOTE,
1309                 &quot;publish_note_button&quot;
1310             );
1311         }
1312     }
1313 
1314     private void updatePublishedState(boolean isSuccess) {
1315         if (mPublishingSnackbar == null) {
1316             return;
1317         }
1318         mPublishingSnackbar.dismiss();
1319         mPublishingSnackbar = null;
1320         if (isSuccess &amp;&amp; isAdded()) {
1321             if (mNote.isPublished()) {
1322                 @StringRes
1323                 int text;
1324                 if (BrowserUtils.copyToClipboard(requireContext(), mNote.getPublishedUrl())) {
1325                     text = R.string.publish_successful_link;
1326                 } else {
1327                     text = R.string.publish_successful;
1328                 }
1329                 if (mHideActionOnSuccess) {
1330                     Snackbar.make(mRootView, text, Snackbar.LENGTH_LONG).show();
1331                 } else {
<abbr title="1332                     Snackbar.make(mRootView, text, Snackbar.LENGTH_LONG).setAction(R.string.undo, new View.OnClickListener() {">1332                     Snackbar.make(mRootView, text, Snackbar.LENGTH_LONG).setAction(R.string.undo, new VieðŸ”µ</abbr>
1333                         @Override
1334                         public void onClick(View v) {
1335                             mHideActionOnSuccess = true;
1336                             unpublishNote();
1337                         }
1338                     }).show();
1339                 }
1340             } else if (mHideActionOnSuccess) {
1341                 Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG).show();
1342             } else {
<abbr title="1343                 Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG).setAction(R.string.undo, new View.OnClickListener() {">1343                 Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG).setAction(RðŸ”µ</abbr>
1344                     @Override
1345                     public void onClick(View v) {
1346                         mHideActionOnSuccess = true;
1347                         publishNote();
1348                     }
1349                 }).show();
1350             }
1351         } else if (mNote.isPublished()) {
<abbr title="1352             Snackbar.make(mRootView, R.string.unpublish_error, Snackbar.LENGTH_LONG).setAction(R.string.retry, new View.OnClickListener() {">1352             Snackbar.make(mRootView, R.string.unpublish_error, Snackbar.LENGTH_LONG).setAction(R.string.rðŸ”µ</abbr>
1353                 @Override
1354                 public void onClick(View v) {
1355                     mHideActionOnSuccess = true;
1356                     unpublishNote();
1357                 }
1358             }).show();
1359         } else {
<abbr title="1360             Snackbar.make(mRootView, R.string.publish_error, Snackbar.LENGTH_LONG).setAction(R.string.retry, new View.OnClickListener() {">1360             Snackbar.make(mRootView, R.string.publish_error, Snackbar.LENGTH_LONG).setAction(R.string.retðŸ”µ</abbr>
1361                 @Override
1362                 public void onClick(View v) {
1363                     mHideActionOnSuccess = true;
1364                     publishNote();
1365                 }
1366             }).show();
1367         }
1368         mHideActionOnSuccess = false;
1369         requireActivity().invalidateOptionsMenu();
1370     }
1371 
1372     private void publishNote() {
1373         if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1374             Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1375             return;
1376         }
1377 
1378         if (isAdded()) {
<abbr title="1379             mPublishingSnackbar = Snackbar.make(mRootView, R.string.publishing, Snackbar.LENGTH_INDEFINITE);">1379             mPublishingSnackbar = Snackbar.make(mRootView, R.string.publishing, Snackbar.LENGTH_INDEFINITðŸ”µ</abbr>
1380             mPublishingSnackbar.show();
1381         }
1382 
1383         setPublishedNote(true);
1384     }
1385 
1386     private void unpublishNote() {
1387         if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1388             Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1389             return;
1390         }
1391 
1392         if (isAdded()) {
<abbr title="1393             mPublishingSnackbar = Snackbar.make(mRootView, R.string.unpublishing, Snackbar.LENGTH_INDEFINITE);">1393             mPublishingSnackbar = Snackbar.make(mRootView, R.string.unpublishing, Snackbar.LENGTH_INDEFINðŸ”µ</abbr>
1394             mPublishingSnackbar.show();
1395         }
1396 
1397         setPublishedNote(false);
1398     }
1399 
1400     private void showShare(String text) {
1401         startActivity(
1402             ShareCompat.IntentBuilder.from(requireActivity())
1403                 .setText(text)
1404                 .setType(&quot;text/plain&quot;)
1405                 .createChooserIntent()
1406         );
1407     }
1408 
1409     private void showShareSheet() {
1410         if (isAdded() &amp;&amp; mShareBottomSheet != null &amp;&amp; !mShareBottomSheet.isAdded()) {
1411             mShareBottomSheet.show(requireFragmentManager(), mNote);
1412         }
1413     }
1414 
1415     private void showInfoSheet() {
1416         if (isAdded() &amp;&amp; mInfoBottomSheet != null &amp;&amp; !mInfoBottomSheet.isAdded()) {
1417             mInfoBottomSheet.show(requireFragmentManager(), mNote);
1418         }
1419     }
1420 
1421     private void showHistorySheet() {
1422         if (isAdded() &amp;&amp; mHistoryBottomSheet != null &amp;&amp; !mHistoryBottomSheet.isAdded()) {
1423             // Request revisions for the current note
<abbr title="1424             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbacks());">1424             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbaðŸ”µ</abbr>
1425             saveNote();
1426 
1427             mHistoryBottomSheet.show(requireFragmentManager(), mNote);
1428         }
1429     }
1430 
1431     @Override
1432     public void onDeleteObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1433     }
1434 
1435     @Override
<abbr title="1436     public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) {">1436     public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) ðŸ”µ</abbr>
1437         if (changeType == Bucket.ChangeType.MODIFY) {
1438             if (getNote() != null &amp;&amp; getNote().getSimperiumKey().equals(key)) {
1439                 try {
1440                     mNotesBucket = noteBucket;
1441                     final Note updatedNote = mNotesBucket.get(key);
1442                     if (getActivity() != null) {
1443                         getActivity().runOnUiThread(new Runnable() {
1444                             @Override
1445                             public void run() {
1446                                 if (mPublishTimeoutHandler != null) {
1447                                     mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
1448                                 }
1449 
1450                                 updateNote(updatedNote);
1451                                 updatePublishedState(true);
1452                             }
1453                         });
1454                     }
1455                 } catch (BucketObjectMissingException e) {
1456                     e.printStackTrace();
1457                 }
1458             }
1459         }
1460     }
1461 
1462     @Override
1463     public void onSaveObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1464         if (mIsPaused) {
1465             mNotesBucket.removeListener(this);
1466             mNotesBucket.stop();
1467             AppLog.add(Type.SYNC, &quot;Stopped note bucket (NoteEditorFragment)&quot;);
1468         }
1469 
1470         AppLog.add(
1471             Type.SYNC,
1472             &quot;Saved note callback in NoteEditorFragment (ID: &quot; + note.getSimperiumKey() +
1473                 &quot; / Title: &quot; + note.getTitle() +
1474                 &quot; / Characters: &quot; + NoteUtils.getCharactersCount(note.getContent()) +
1475                 &quot; / Words: &quot; + NoteUtils.getWordCount(note.getContent()) + &quot;)&quot;
1476         );
1477     }
1478 
1479     @Override
1480     public void onBeforeUpdateObject(Bucket&lt;Note&gt; bucket, Note note) {
1481         // Don&#x27;t apply updates if we haven&#x27;t loaded the note yet
1482         if (mIsLoadingNote)
1483             return;
1484 
1485         Note openNote = getNote();
1486         if (openNote == null || !openNote.getSimperiumKey().equals(note.getSimperiumKey()))
1487             return;
1488 
1489         note.setContent(mContentEditText.getPlainTextContent());
1490     }
1491 
1492     private static class LoadNoteTask extends AsyncTask&lt;String, Void, Void&gt; {
1493         WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1494 
1495         LoadNoteTask(NoteEditorFragment fragment) {
1496             mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1497         }
1498 
1499         @Override
1500         protected void onPreExecute() {
1501             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1502             if (fragment != null) {
1503                 fragment.mContentEditText.removeTextChangedListener(fragment);
1504                 fragment.mIsLoadingNote = true;
1505             }
1506         }
1507 
1508         @Override
1509         protected Void doInBackground(String... args) {
1510             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1511             if ((fragment == null) || (fragment.getActivity() == null)) {
1512                 return null;
1513             }
1514             String noteID = args[0];
1515             Simplenote application = ((Simplenote) (fragment.getActivity().getApplication()));
1516             Bucket&lt;Note&gt; notesBucket = application.getNotesBucket();
1517             try {
1518                 fragment.mNote = notesBucket.get(noteID);
1519                 // Set the current note in NotesActivity when on a tablet
1520                 if (fragment.getActivity() instanceof NotesActivity) {
1521                     ((NotesActivity) (fragment.getActivity())).setCurrentNote(fragment.mNote);
1522                 }
1523                 // Set markdown and preview flags for current note
1524                 if (fragment.mNote != null) {
1525                     fragment.mIsMarkdownEnabled = fragment.mNote.isMarkdownEnabled();
1526                     fragment.mIsPreviewEnabled = fragment.mNote.isPreviewEnabled();
<abbr title="1527                     AppLog.add(Type.SYNC, (((((((&quot;Loaded note (ID: &quot; + fragment.mNote.getSimperiumKey()) + &quot; / Title: &quot;) + fragment.mNote.getTitle()) + &quot; / Characters: &quot;) + NoteUtils.getCharactersCount(fragment.mNote.getContent())) + &quot; / Words: &quot;) + NoteUtils.getWordCount(fragment.mNote.getContent())) + &quot;)&quot;);">1527                     AppLog.add(Type.SYNC, (((((((&quot;Loaded note (ID: &quot; + fragment.mNote.getSimperiumKey()) ðŸ”µ</abbr>
1528                 }
1529             } catch (BucketObjectMissingException e) {
1530                 // See if the note is in the object store
1531                 Bucket.ObjectCursor&lt;Note&gt; notesCursor = notesBucket.allObjects();
1532                 while (notesCursor.moveToNext()) {
1533                     Note currentNote = notesCursor.getObject();
1534                     if ((currentNote != null) &amp;&amp; currentNote.getSimperiumKey().equals(noteID)) {
1535                         fragment.mNote = currentNote;
1536                         return null;
1537                     }
1538                 }
1539             }
1540             return null;
1541         }
1542 
1543         @Override
1544         protected void onPostExecute(Void nada) {
1545             final NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
<abbr title="1546             if (((fragment == null) || (fragment.getActivity() == null)) || fragment.getActivity().isFinishing()) {">1546             if (((fragment == null) || (fragment.getActivity() == null)) || fragment.getActivity().isFiniðŸ”µ</abbr>
1547                 return;
1548             }
1549             fragment.refreshContent(false);
1550             if (fragment.mMatchOffsets != null) {
<abbr title="1551                 int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.CONTENT_PROPERTY);">1551                 int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndeðŸ”µ</abbr>
1552                 fragment.mHighlighter.highlightMatches(fragment.mMatchOffsets, columnIndex);
1553                 fragment.mShouldScrollToSearchMatch = true;
1554             }
1555             fragment.mContentEditText.addTextChangedListener(fragment);
1556             if ((fragment.mNote != null) &amp;&amp; fragment.mNote.getContent().isEmpty()) {
1557                 // Show soft keyboard
1558                 fragment.mContentEditText.requestFocus();
1559                 new Handler().postDelayed(new Runnable() {
1560                     @Override
1561                     public void run() {
1562                         if (fragment.getActivity() == null) {
1563                             return;
1564                         }
<abbr title="1565                         InputMethodManager inputMethodManager = ((InputMethodManager) (fragment.getActivity().getSystemService(Context.INPUT_METHOD_SERVICE)));">1565                         InputMethodManager inputMethodManager = ((InputMethodManager) (fragment.getActiviðŸ”µ</abbr>
1566                         if (inputMethodManager != null) {
1567                             inputMethodManager.showSoftInput(fragment.mContentEditText, 0);
1568                         }
1569                     }
1570                 }, 100);
1571             } else if (fragment.mNote != null) {
1572                 // If we have a valid note, hide the placeholder
1573                 fragment.setPlaceholderVisible(false);
1574             }
1575             fragment.updateMarkdownView();
1576             fragment.requireActivity().invalidateOptionsMenu();
1577             fragment.linkifyEditorContent();
1578             fragment.mIsLoadingNote = false;
1579         }
1580     }
1581 
1582     private static class SaveNoteTask extends AsyncTask&lt;Void, Void, Void&gt; {
1583         WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1584 
1585         SaveNoteTask(NoteEditorFragment fragment) {
1586             mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1587         }
1588 
1589         @Override
1590         protected Void doInBackground(Void... args) {
1591             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1592             if (fragment != null) {
1593                 fragment.saveNote();
1594             }
1595             return null;
1596         }
1597 
1598         @Override
1599         protected void onPostExecute(Void nada) {
1600             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
<abbr title="1601             if (((fragment != null) &amp;&amp; (fragment.getActivity() != null)) &amp;&amp; (!fragment.getActivity().isFinishing())) {">1601             if (((fragment != null) &amp;&amp; (fragment.getActivity() != null)) &amp;&amp; (!fragment.getActivity().isFiðŸ”µ</abbr>
1602                 // Update links
1603                 fragment.linkifyEditorContent();
1604                 fragment.updateMarkdownView();
1605             }
1606         }
1607     }
1608 
1609     private void linkifyEditorContent() {
1610         if (getActivity() == null || getActivity().isFinishing()) {
1611             return;
1612         }
1613 
1614         if (PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_DETECT_LINKS)) {
1615             SimplenoteLinkify.addLinks(mContentEditText, Linkify.ALL);
1616         }
1617     }
1618 
1619     // Show tabs if markdown is enabled globally, for current note, and not tablet landscape
1620     private void updateMarkdownView() {
1621         if (!mIsMarkdownEnabled) {
1622             return;
1623         }
1624 
1625         Activity activity = getActivity();
1626         if (activity instanceof NotesActivity) {
1627             // This fragment lives in NotesActivity, so load markdown in this fragment&#x27;s WebView.
1628             loadMarkdownData();
1629         } else {
1630             // This fragment lives in the NoteEditorActivity&#x27;s ViewPager.
1631             if (mNoteMarkdownFragment == null) {
1632                 mNoteMarkdownFragment = ((NoteEditorActivity) requireActivity())
1633                         .getNoteMarkdownFragment();
1634                 ((NoteEditorActivity) requireActivity()).showTabs();
1635             }
1636             // Load markdown in the sibling NoteMarkdownFragment&#x27;s WebView.
1637             mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPreviewTextContent());
1638         }
1639     }
1640 
1641     private ColorStateList getChipBackgroundColor() {
1642         int[][] states = new int[][] {
1643             new int[] { android.R.attr.state_checked}, // checked
1644             new int[] {-android.R.attr.state_checked}  // unchecked
1645         };
1646 
1647         int[] colors = new int[] {
1648             ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOnBackgroundColor),
1649             ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOffBackgroundColor)
1650         };
1651 
1652         return new ColorStateList(states, colors);
1653     }
1654 
1655     private void setChips(CharSequence text) {
1656         mTagPadding.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1657         mTagChips.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1658         mTagChips.setSingleSelection(true);
1659         mTagChips.removeAllViews();
1660         SimpleStringSplitter tags = new SimpleStringSplitter(SPACE);
1661         tags.setString(text.toString());
1662 
1663         for (String tag : tags) {
1664             final Chip chip = new Chip(requireContext());
1665             chip.setText(tag);
1666             chip.setCheckable(true);
1667             chip.setCheckedIcon(null);
1668             chip.setChipBackgroundColor(getChipBackgroundColor());
1669             chip.setTextColor(ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipTextColor));
1670             chip.setStateListAnimator(null);
1671             chip.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
1672                 @Override
1673                 public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
1674                     chip.setCloseIconVisible(isChecked);
1675                 }
1676             });
1677             chip.setOnCloseIconClickListener(new View.OnClickListener() {
1678                 @Override
1679                 public void onClick(View view) {
1680                     mTagChips.removeView(view);
1681                     updateTags();
1682                     AnalyticsTracker.track(
1683                         EDITOR_TAG_REMOVED,
1684                         CATEGORY_NOTE,
1685                         &quot;tag_removed_from_note&quot;
1686                     );
1687                 }
1688             });
1689             mTagChips.addView(chip);
1690         }
1691     }
1692 
1693     private void updateTags() {
1694         if (mNote == null) {
1695             return;
1696         }
1697 
1698         mNote.setTagString(getNoteTagsString());
1699         mNote.setModificationDate(Calendar.getInstance());
1700         updateTagList();
1701         mNote.save();
1702     }
1703 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  package com.automattic.simplenote;
   2  
   3  import android.app.Activity;
   4  import android.content.Context;
   5  import android.content.SharedPreferences;
   6  import android.content.res.ColorStateList;
   7  import android.database.Cursor;
   8  import android.graphics.Typeface;
   9  import android.graphics.drawable.Drawable;
  10  import android.os.AsyncTask;
  11  import android.os.Bundle;
  12  import android.os.Handler;
  13  import android.text.Editable;
  14  import android.text.Layout;
  15  import android.text.Spanned;
  16  import android.text.TextUtils.SimpleStringSplitter;
  17  import android.text.TextWatcher;
  18  import android.text.style.MetricAffectingSpan;
  19  import android.text.style.RelativeSizeSpan;
  20  import android.text.style.StyleSpan;
  21  import android.text.style.URLSpan;
  22  import android.text.util.Linkify;
  23  import android.util.TypedValue;
  24  import android.view.LayoutInflater;
  25  import android.view.Menu;
  26  import android.view.MenuInflater;
  27  import android.view.MenuItem;
  28  import android.view.View;
  29  import android.view.ViewGroup;
  30  import android.view.ViewTreeObserver;
  31  import android.view.inputmethod.InputMethodManager;

  32  import android.webkit.WebView;

  33  import android.widget.CompoundButton;
  34  import android.widget.CursorAdapter;
  35  import android.widget.LinearLayout;
  36  import android.widget.TextView;
  37  import android.widget.Toast;
  38  
  39  import androidx.annotation.NonNull;
  40  import androidx.annotation.StringRes;
  41  import androidx.appcompat.app.AppCompatActivity;
  42  import androidx.appcompat.view.ActionMode;
  43  import androidx.core.app.ShareCompat;
  44  import androidx.core.view.MenuCompat;
  45  import androidx.core.widget.NestedScrollView;
  46  import androidx.fragment.app.Fragment;
  47  import androidx.fragment.app.FragmentTransaction;
  48  import androidx.preference.PreferenceManager;
  49  
  50  import com.automattic.simplenote.analytics.AnalyticsTracker;
  51  import com.automattic.simplenote.models.Note;
  52  import com.automattic.simplenote.models.Tag;
  53  import com.automattic.simplenote.utils.AppLog;
  54  import com.automattic.simplenote.utils.AppLog.Type;
  55  import com.automattic.simplenote.utils.AutoBullet;
  56  import com.automattic.simplenote.utils.BrowserUtils;
  57  import com.automattic.simplenote.utils.ContextUtils;
  58  import com.automattic.simplenote.utils.DisplayUtils;
  59  import com.automattic.simplenote.utils.DrawableUtils;
  60  import com.automattic.simplenote.utils.MatchOffsetHighlighter;
  61  import com.automattic.simplenote.utils.NetworkUtils;
  62  import com.automattic.simplenote.utils.NoteUtils;
  63  import com.automattic.simplenote.utils.PrefUtils;
  64  import com.automattic.simplenote.utils.SimplenoteLinkify;
  65  import com.automattic.simplenote.utils.SimplenoteMovementMethod;
  66  import com.automattic.simplenote.utils.SpaceTokenizer;
  67  import com.automattic.simplenote.utils.TagUtils;
  68  import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;
  69  import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;
  70  import com.automattic.simplenote.utils.TextHighlighter;
  71  import com.automattic.simplenote.utils.ThemeUtils;
  72  import com.automattic.simplenote.utils.WidgetUtils;
  73  import com.automattic.simplenote.widgets.SimplenoteEditText;
  74  import com.google.android.material.chip.Chip;
  75  import com.google.android.material.chip.ChipGroup;
  76  import com.google.android.material.snackbar.Snackbar;
  77  import com.simperium.client.Bucket;
  78  import com.simperium.client.BucketObjectMissingException;
  79  import com.simperium.client.Query;
  80  
  81  import java.lang.ref.WeakReference;
  82  import java.util.Calendar;
  83  
  84  import static com.automattic.simplenote.analytics.AnalyticsTracker.CATEGORY_NOTE;
  85  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_CHECKLIST_INSERTED;
  86  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_CONTENT_SHARED;
  87  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_EDITED;
  88  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_PUBLISHED;
  89  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_UNPUBLISHED;
  90  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_ADDED;
  91  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_REMOVED;
  92  import static com.automattic.simplenote.utils.SearchTokenizer.SPACE;

  93  
  94  public class NoteEditorFragment extends Fragment implements Bucket.Listener&lt;Note&gt;,
  95          TextWatcher, OnTagAddedListener, View.OnFocusChangeListener,
  96          SimplenoteEditText.OnSelectionChangedListener,
  97          ShareBottomSheetDialog.ShareSheetListener,
  98          HistoryBottomSheetDialog.HistorySheetListener,
  99          SimplenoteEditText.OnCheckboxToggledListener {
 100  
 101      public static final String ARG_IS_FROM_WIDGET = &quot;is_from_widget&quot;;
 102      public static final String ARG_ITEM_ID = &quot;item_id&quot;;
 103      public static final String ARG_NEW_NOTE = &quot;new_note&quot;;
 104      public static final String ARG_MATCH_OFFSETS = &quot;match_offsets&quot;;
 105      public static final String ARG_MARKDOWN_ENABLED = &quot;markdown_enabled&quot;;
 106      public static final String ARG_PREVIEW_ENABLED = &quot;preview_enabled&quot;;
 107      private static final String STATE_NOTE_ID = &quot;state_note_id&quot;;
 108      private static final int AUTOSAVE_DELAY_MILLIS = 2000;
 109      private static final int MAX_REVISIONS = 30;
 110      private static final int PUBLISH_TIMEOUT = 20000;
 111      private static final int HISTORY_TIMEOUT = 10000;
 112      private Note mNote;
 113      private final Runnable mAutoSaveRunnable = new Runnable() {
 114          @Override
 115          public void run() {
 116              saveAndSyncNote();
 117          }
 118      };
 119      private Bucket&lt;Note&gt; mNotesBucket;
 120      private View mRootView;
 121      private View mTagPadding;
 122      private SimplenoteEditText mContentEditText;
 123      private ChipGroup mTagChips;
 124      private TagsMultiAutoCompleteTextView mTagInput;
 125      private Handler mAutoSaveHandler;
 126      private Handler mPublishTimeoutHandler;
 127      private Handler mHistoryTimeoutHandler;
 128      private LinearLayout mPlaceholderView;
 129      private CursorAdapter mAutocompleteAdapter;
 130      private boolean mIsLoadingNote;
 131      private boolean mIsMarkdownEnabled;
 132      private boolean mIsPreviewEnabled;
 133      private boolean mShouldScrollToSearchMatch;
 134      private ActionMode mActionMode;
 135      private MenuItem mChecklistMenuItem;
 136      private MenuItem mCopyMenuItem;
 137      private MenuItem mInformationMenuItem;
 138      private MenuItem mShareMenuItem;
 139      private MenuItem mViewLinkMenuItem;
 140      private String mLinkUrl;
 141      private String mLinkText;
 142      private MatchOffsetHighlighter mHighlighter;

 143      private Drawable mCallIcon;
 144      private Drawable mCopyIcon;
 145      private Drawable mEmailIcon;

 146      private Drawable mMapIcon;
 147      private Drawable mShareIcon;
 148      private Drawable mBrowserIcon;
 149      private MatchOffsetHighlighter.SpanFactory mMatchHighlighter;
 150      private String mMatchOffsets;
 151      private int mCurrentCursorPosition;
 152      private HistoryBottomSheetDialog mHistoryBottomSheet;
 153      private boolean mIsPaused;
 154      private boolean mIsFromWidget;
 155  
 156      // Hides the history bottom sheet if no revisions are loaded
 157      private final Runnable mHistoryTimeoutRunnable = new Runnable() {
 158          @Override
 159          public void run() {
 160              if (!isAdded()) {
 161                  return;
 162              }
 163  
 164              requireActivity().runOnUiThread(new Runnable() {
 165                  @Override
 166                  public void run() {
<abbr title=" 167                      if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; !mHistoryBottomSheet.isHistoryLoaded()) {"> 167                      if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; ðŸ”µ</abbr>
 168                          mHistoryBottomSheet.dismiss();
 169                          Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 170                      }
 171                  }
 172              });
 173          }
 174      };
 175      private InfoBottomSheetDialog mInfoBottomSheet;
 176      private ShareBottomSheetDialog mShareBottomSheet;
 177      // Contextual action bar for dealing with links
 178      private final ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
 179          // Called when the action mode is created; startActionMode() was called
 180          @Override
 181          public boolean onCreateActionMode(ActionMode mode, Menu menu) {
 182              // Inflate a menu resource providing context menu items
 183              MenuInflater inflater = mode.getMenuInflater();
 184  
 185              if (inflater != null) {
 186                  inflater.inflate(R.menu.view_link, menu);
 187                  mCopyMenuItem = menu.findItem(R.id.menu_copy);
 188                  mShareMenuItem = menu.findItem(R.id.menu_share);
 189                  mViewLinkMenuItem = menu.findItem(R.id.menu_view_link);
 190                  mode.setTitle(getString(R.string.link));
 191                  mode.setTitleOptionalHint(false);
 192  
 193                  DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 194              }
 195  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 196 -            int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.background_dark;"> 196 -            int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.backgrðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 197 -            requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().getTheme()));"> 197 -            requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 198 +            requireActivity().getWindow().setStatusBarColor(ThemeUtils.getColorFromAttribute(requireContext(), R.attr.mainBackgroundColor));"> 198 +            requireActivity().getWindow().setStatusBarColor(ThemeUtils.getColorFromAttribute(requireContext(), R.aðŸ”µ</abbr></span>
 199              return true;
 200          }
 201  
 202          // Called each time the action mode is shown. Always called after onCreateActionMode, but
 203          // may be called multiple times if the mode is invalidated.
 204          @Override
 205          public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 206              return false; // Return false if nothing is done
 207          }
 208  
 209          // Called when the user selects a contextual menu item
 210          @Override
 211          public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 212              switch (item.getItemId()) {
 213                  case R.id.menu_view_link:
 214                      if (mLinkUrl != null) {
 215                          try {
 216                              BrowserUtils.launchBrowserOrShowError(requireContext(), mLinkUrl);
 217                          } catch (Exception e) {
 218                              e.printStackTrace();









 219                          }
 220  
 221                          mode.finish(); // Action picked, so close the CAB
 222                      }
 223  
 224                      return true;
 225                  case R.id.menu_copy:
 226                      if (mLinkText != null &amp;&amp; getActivity() != null) {
 227                          if (BrowserUtils.copyToClipboard(requireContext(), mLinkText)) {
 228                              Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 229                          } else {
 230                              Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();
 231                          }
 232  
 233                          mode.finish();
 234                      }
 235  
 236                      return true;
 237                  case R.id.menu_share:
 238                      if (mLinkText != null) {
 239                          showShare(mLinkText);
 240                          mode.finish();
 241                      }
 242  
 243                      return true;
 244                  default:
 245                      return false;
 246              }
 247          }
 248  
 249          // Called when the user exits the action mode
 250          @Override
 251          public void onDestroyActionMode(ActionMode mode) {
 252              mActionMode = null;





 253              new Handler().postDelayed(
 254                  new Runnable() {
 255                      @Override
 256                      public void run() {
<abbr title=" 257                          requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 257                          requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.trðŸ”µ</abbr>
 258                      }
 259                  },
 260                  requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime)
 261              );
 262          }
 263      };
 264      private Snackbar mPublishingSnackbar;
 265      private boolean mHideActionOnSuccess;
 266      // Resets note publish status if Simperium never returned the new publish status
 267      private final Runnable mPublishTimeoutRunnable = new Runnable() {
 268          @Override
 269          public void run() {
 270              if (!isAdded()) return;
 271  
 272              requireActivity().runOnUiThread(new Runnable() {
 273                  @Override
 274                  public void run() {
 275  
 276                      mNote.setPublished(!mNote.isPublished());
 277                      mNote.save();
 278  
 279                      updatePublishedState(false);
 280                  }
 281              });
 282          }
 283      };
 284      private NoteMarkdownFragment mNoteMarkdownFragment;
 285      private String mCss;
 286      private WebView mMarkdown;
 287  
 288      /**
 289       * Mandatory empty constructor for the fragment manager to instantiate the
 290       * fragment (e.g. upon screen orientation changes).
 291       */
 292      public NoteEditorFragment() {
 293      }
 294  
 295      @Override
 296      public void onCreate(Bundle savedInstanceState) {
 297          super.onCreate(savedInstanceState);
 298          AppLog.add(Type.NETWORK, NetworkUtils.getNetworkInfo(requireContext()));
 299          AppLog.add(Type.SCREEN, &quot;Created (NoteEditorFragment)&quot;);
 300          mInfoBottomSheet = new InfoBottomSheetDialog(this);
 301          mShareBottomSheet = new ShareBottomSheetDialog(this, this);
 302          mHistoryBottomSheet = new HistoryBottomSheetDialog(this, this);
 303  
 304          Simplenote currentApp = (Simplenote) requireActivity().getApplication();
 305          mNotesBucket = currentApp.getNotesBucket();
 306  
<abbr title=" 307          mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.actionModeTextColor);"> 307          mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.aðŸ”µ</abbr>
<abbr title=" 308          mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.attr.actionModeTextColor);"> 308          mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.attr.actioðŸ”µ</abbr>

<abbr title=" 309          mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.actionModeTextColor);"> 309          mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.actionModðŸ”µ</abbr>
<abbr title=" 310          mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp, R.attr.actionModeTextColor);"> 310          mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp, R.attr.aðŸ”µ</abbr>
<abbr title=" 311          mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attr.actionModeTextColor);"> 311          mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attr.actionMðŸ”µ</abbr>
<abbr title=" 312          mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.attr.actionModeTextColor);"> 312          mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.attr.actioðŸ”µ</abbr>
 313  
 314          mAutoSaveHandler = new Handler();
 315          mPublishTimeoutHandler = new Handler();
 316          mHistoryTimeoutHandler = new Handler();
 317  
 318          mMatchHighlighter = new TextHighlighter(requireActivity(),
 319                  R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor);
 320          mAutocompleteAdapter = new CursorAdapter(getActivity(), null, 0x0) {
 321              @Override
 322              public View newView(Context context, Cursor cursor, ViewGroup parent) {
 323                  Activity activity = (Activity) context;
 324                  if (activity == null) return null;
 325                  return activity.getLayoutInflater().inflate(R.layout.tag_autocomplete_list_item, null);
 326              }
 327  
 328              @Override
 329              public void bindView(View view, Context context, Cursor cursor) {
 330                  TextView textView = (TextView) view;
 331                  textView.setText(convertToString(cursor));
 332              }
 333  
 334              @Override
 335              public CharSequence convertToString(Cursor cursor) {
 336                  return cursor.getString(cursor.getColumnIndex(Tag.NAME_PROPERTY));
 337              }
 338  
 339              @Override
 340              public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 341                  Activity activity = getActivity();
 342                  if (activity == null) return null;
 343                  Simplenote application = (Simplenote) activity.getApplication();
 344                  Query&lt;Tag&gt; query = application.getTagsBucket().query();
 345                  // make the tag name available to the cursor
 346                  query.include(Tag.NAME_PROPERTY);
 347                  // sort the tags by their names
 348                  query.order(Tag.NAME_PROPERTY);
 349                  // if there&#x27;s a filter string find only matching tag names
 350                  if (filter != null)
 351                      query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filter));
 352                  return query.execute();
 353              }
 354          };
 355  
 356          WidgetUtils.updateNoteWidgets(requireActivity().getApplicationContext());
 357      }
 358  
 359      @Override
 360      public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
 361          mRootView = inflater.inflate(R.layout.fragment_note_editor, container, false);
 362          mContentEditText = mRootView.findViewById(R.id.note_content);
 363          mContentEditText.addOnSelectionChangedListener(this);
 364          mContentEditText.setOnCheckboxToggledListener(this);
 365          mContentEditText.setMovementMethod(SimplenoteMovementMethod.getInstance());
 366          mContentEditText.setOnFocusChangeListener(this);
 367          mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()));
 368          mTagInput = mRootView.findViewById(R.id.tag_input);
 369          mTagInput.setDropDownBackgroundResource(R.drawable.bg_list_popup);
 370          mTagInput.setTokenizer(new SpaceTokenizer());
 371          mTagInput.setOnFocusChangeListener(this);
 372          mTagChips = mRootView.findViewById(R.id.tag_chips);
 373          mTagPadding = mRootView.findViewById(R.id.tag_padding);
 374          mHighlighter = new MatchOffsetHighlighter(mMatchHighlighter, mContentEditText);
 375          mPlaceholderView = mRootView.findViewById(R.id.placeholder);
 376  
 377          if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote == null) {
 378              mPlaceholderView.setVisibility(View.VISIBLE);
 379              requireActivity().invalidateOptionsMenu();
 380              mMarkdown = mRootView.findViewById(R.id.markdown);
















<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 381 -            mCss = ThemeUtils.isLightTheme(requireContext())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 382 -                    ? ContextUtils.readCssFile(requireContext(), &quot;light.css&quot;)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 383 -                    : ContextUtils.readCssFile(requireContext(), &quot;dark.css&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 384 +            mCss = ContextUtils.readCssFile(requireContext(), ThemeUtils.getCssFromStyle(requireContext()));</span>

 385          }
 386  
 387          mTagInput.setAdapter(mAutocompleteAdapter);
 388          Bundle arguments = getArguments();
 389  
 390          if (arguments != null &amp;&amp; arguments.containsKey(ARG_ITEM_ID)) {
 391              // Load note if we were passed a note Id
 392              String key = arguments.getString(ARG_ITEM_ID);
 393  
 394              if (arguments.containsKey(ARG_MATCH_OFFSETS)) {
 395                  mMatchOffsets = arguments.getString(ARG_MATCH_OFFSETS);
 396              }
 397  
 398              mIsFromWidget = arguments.getBoolean(ARG_IS_FROM_WIDGET);
 399  
 400              if (mIsFromWidget) {
 401                  AppLog.add(Type.ACTION, &quot;Opened from widget (NoteEditorFragment)&quot;);
 402              } else {
 403                  AppLog.add(Type.ACTION, &quot;Opened from list (NoteEditorFragment)&quot;);
 404              }
 405  
 406              new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, key);
 407          } else if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; savedInstanceState != null) {
 408              // Restore selected note when in dual pane mode
 409              String noteId = savedInstanceState.getString(STATE_NOTE_ID);
 410  
 411              if (noteId != null) {
 412                  setNote(noteId);
 413              }
 414          }
 415  
 416          ViewTreeObserver viewTreeObserver = mContentEditText.getViewTreeObserver();
 417          viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
 418              @Override
 419              public void onGlobalLayout() {
 420                  // If a note was loaded with search matches, scroll to the first match in the editor
 421                  if (mShouldScrollToSearchMatch &amp;&amp; mMatchOffsets != null) {
 422                      if (!isAdded()) {
 423                          return;
 424                      }
 425  
 426                      // Get the character location of the first search match
 427                      int matchLocation = MatchOffsetHighlighter.getFirstMatchLocation(
 428                              mContentEditText.getText(),
 429                              mMatchOffsets
 430                      );
 431                      if (matchLocation == 0) {
 432                          return;
 433                      }
 434  
 435                      // Calculate how far to scroll to bring the match into view
 436                      Layout layout = mContentEditText.getLayout();
 437                      int lineTop = layout.getLineTop(layout.getLineForOffset(matchLocation));
 438                      ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 439                      mShouldScrollToSearchMatch = false;
 440                  }
 441              }
 442          });
 443          setHasOptionsMenu(true);
 444          return mRootView;
 445      }
 446  
 447      public void scrollToMatch(int location) {
 448          if (isAdded()) {
 449              // Calculate how far to scroll to bring the match into view
 450              Layout layout = mContentEditText.getLayout();
 451              int lineTop = layout.getLineTop(layout.getLineForOffset(location));
 452              ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 453          }
 454      }
 455  
 456      @Override
 457      public void onResume() {
 458          super.onResume();
 459          mNotesBucket.start();
 460          AppLog.add(Type.SYNC, &quot;Started note bucket (NoteEditorFragment)&quot;);
 461          mNotesBucket.addListener(this);
 462          mTagInput.setOnTagAddedListener(this);
 463  
 464          if (mContentEditText != null) {
 465              mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()));
 466  
 467              if (mContentEditText.hasFocus()) {
 468                  showSoftKeyboard();
 469              }
 470          }
 471      }
 472  
 473      private void showSoftKeyboard() {
 474          new Handler().postDelayed(new Runnable() {
 475              @Override
 476              public void run() {
 477                  if (getActivity() == null) {
 478                      return;
 479                  }
 480  
<abbr title=" 481                  InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);"> 481                  InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(ContexðŸ”µ</abbr>
 482                  if (inputMethodManager != null) {
 483                      inputMethodManager.showSoftInput(mContentEditText, 0);
 484                  }
 485              }
 486          }, 100);
 487      }
 488  
 489      @Override
 490      public void onPause() {
 491          super.onPause();  // Always call the superclass method first
 492          mIsPaused = true;
 493  
 494          // Hide soft keyboard if it is showing...
 495          DisplayUtils.hideKeyboard(mContentEditText);
 496  
 497          mTagInput.setOnTagAddedListener(null);
 498  
 499          if (mAutoSaveHandler != null) {
 500              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 501              mAutoSaveHandler.post(mAutoSaveRunnable);
 502          }
 503  
 504          if (mPublishTimeoutHandler != null) {
 505              mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
 506          }
 507  
 508          if (mHistoryTimeoutHandler != null) {
 509              mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 510          }
 511  
 512          mHighlighter.stop();
 513          saveNote();
 514          AppLog.add(Type.SCREEN, &quot;Paused (NoteEditorFragment)&quot;);
 515      }
 516  
 517      @Override
 518      public void onDestroy() {
 519          super.onDestroy();
 520          mNotesBucket.removeListener(this);
 521          mNotesBucket.stop();
 522          AppLog.add(Type.SYNC, &quot;Stopped note bucket (NoteEditorFragment)&quot;);
 523          AppLog.add(Type.SCREEN, &quot;Destroyed (NoteEditorFragment)&quot;);
 524      }
 525  
 526      @Override
 527      public void onSaveInstanceState(@NonNull Bundle outState) {
 528          super.onSaveInstanceState(outState);
 529  
 530          if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote != null) {
 531              outState.putString(STATE_NOTE_ID, mNote.getSimperiumKey());
 532          }
 533      }
 534  
 535      @Override
 536      public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
 537          super.onCreateOptionsMenu(menu, inflater);
 538  
<abbr title=" 539          if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFragment == null)) {"> 539          if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFrðŸ”µ</abbr>
 540              return;
 541          }
 542  
 543          inflater.inflate(R.menu.note_editor, menu);
 544          MenuCompat.setGroupDividerEnabled(menu, true);
 545      }
 546  
 547      @Override
 548      public boolean onOptionsItemSelected(@NonNull MenuItem item) {
 549          switch (item.getItemId()) {
 550              case R.id.menu_checklist:
 551                  insertChecklist();
 552                  return true;
 553              case R.id.menu_copy:
 554                  if (BrowserUtils.copyToClipboard(requireContext(), mNote.getPublishedUrl())) {








 555                      Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 556                  } else {
 557                      Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();
 558                  }
 559  
 560                  return true;
 561              case R.id.menu_history:
 562                  showHistory();
 563                  return true;
 564              case R.id.menu_info:
 565                  showInfo();
 566                  return true;
 567              case R.id.menu_markdown:
 568                  setMarkdown(!item.isChecked());
 569                  return true;
 570              case R.id.menu_pin:
 571                  NoteUtils.setNotePin(mNote, !item.isChecked());
 572                  requireActivity().invalidateOptionsMenu();
 573                  return true;
 574              case R.id.menu_publish:
 575                  if (item.isChecked()) {
 576                      unpublishNote();
 577                  } else {
 578                      publishNote();
 579                  }
 580  
 581                  return true;
 582              case R.id.menu_share:
 583                  shareNote();
 584                  return true;
 585              case R.id.menu_trash:
 586                  if (!isAdded()) {
 587                      return false;
 588                  }
 589  
 590                  deleteNote();
 591                  return true;
 592              case android.R.id.home:
 593                  AppLog.add(Type.ACTION, &quot;Tapped back arrow in app bar (NoteEditorFragment)&quot;);
 594                  if (!isAdded()) {
 595                      return false;
 596                  }
 597  
 598                  requireActivity().finish();
 599                  return true;
 600              default:
 601                  return super.onOptionsItemSelected(item);
 602          }
 603      }
 604  
 605      @Override
 606      public void onPrepareOptionsMenu(@NonNull Menu menu) {
 607          if (mNote != null) {
 608              MenuItem pinItem = menu.findItem(R.id.menu_pin);
 609              MenuItem shareItem = menu.findItem(R.id.menu_share);
 610              MenuItem historyItem = menu.findItem(R.id.menu_history);
 611              MenuItem publishItem = menu.findItem(R.id.menu_publish);
 612              MenuItem copyLinkItem = menu.findItem(R.id.menu_copy);
 613              MenuItem markdownItem = menu.findItem(R.id.menu_markdown);
 614              MenuItem trashItem = menu.findItem(R.id.menu_trash);
 615              mChecklistMenuItem = menu.findItem(R.id.menu_checklist);
 616              mInformationMenuItem = menu.findItem(R.id.menu_info).setVisible(true);
 617  
 618              pinItem.setChecked(mNote.isPinned());
 619              publishItem.setChecked(mNote.isPublished());
 620              markdownItem.setChecked(mNote.isMarkdownEnabled());
 621  
 622              // Disable actions when note is in Trash or markdown view is shown on large device.
 623              if (mNote.isDeleted() || (mMarkdown != null &amp;&amp; mMarkdown.getVisibility() == View.VISIBLE)) {
 624                  pinItem.setEnabled(false);
 625                  shareItem.setEnabled(false);
 626                  historyItem.setEnabled(false);
 627                  publishItem.setEnabled(false);
 628                  copyLinkItem.setEnabled(false);
 629                  markdownItem.setEnabled(false);
 630                  mChecklistMenuItem.setEnabled(false);
 631                  DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 0.3);  // 0.3 is 30% opacity.
 632              } else {
 633                  pinItem.setEnabled(true);
 634                  shareItem.setEnabled(true);
 635                  historyItem.setEnabled(true);
 636                  publishItem.setEnabled(true);
 637                  copyLinkItem.setEnabled(mNote.isPublished());
 638                  markdownItem.setEnabled(true);
 639                  mChecklistMenuItem.setEnabled(true);
 640                  DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 1.0);  // 1.0 is 100% opacity.
 641              }
 642  
 643              if (mNote.isDeleted()) {
 644                  trashItem.setTitle(R.string.restore);
 645              } else {
 646                  trashItem.setTitle(R.string.trash);
 647              }
 648          }
 649  
 650          DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 651          super.onPrepareOptionsMenu(menu);
 652      }
 653  
 654      public void insertChecklist() {
 655          DrawableUtils.startAnimatedVectorDrawable(mChecklistMenuItem.getIcon());
 656  
 657          try {
 658              mContentEditText.insertChecklist();
 659          } catch (Exception e) {
 660              e.printStackTrace();
 661              return;
 662          }
 663  
 664          AnalyticsTracker.track(
 665              EDITOR_CHECKLIST_INSERTED,
 666              CATEGORY_NOTE,
 667              &quot;toolbar_button&quot;
 668          );
 669      }
 670  
 671      @Override
 672      public void onCheckboxToggled() {
 673          // Save note (using delay) after toggling a checkbox
 674          if (mAutoSaveHandler != null) {
 675              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 676              mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 677          }
 678      }
 679  
 680      private void deleteNote() {
 681          NoteUtils.deleteNote(mNote, getActivity());
 682          requireActivity().finish();
 683      }
 684  
 685      protected void clearMarkdown() {
 686          mMarkdown.loadDataWithBaseURL(&quot;file:///android_asset/&quot;, mCss + &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 687      }
 688  
 689      protected void hideMarkdown() {
 690          mMarkdown.setVisibility(View.INVISIBLE);
 691      }
 692  
 693      protected void showMarkdown() {
 694          loadMarkdownData();
 695          mMarkdown.setVisibility(View.VISIBLE);
 696  
 697          new Handler().postDelayed(
 698              new Runnable() {
 699                  @Override
 700                  public void run() {
 701                      requireActivity().invalidateOptionsMenu();
 702                  }
 703              },
 704              getResources().getInteger(R.integer.time_animation)
 705          );
 706      }
 707  
 708      public void shareNote() {
 709          if (mNote != null) {
 710              mContentEditText.clearFocus();
 711              showShareSheet();
 712              AnalyticsTracker.track(
 713                  EDITOR_NOTE_CONTENT_SHARED,
 714                  CATEGORY_NOTE,
 715                  &quot;action_bar_share_button&quot;
 716              );
 717          }
 718      }
 719  
 720      public void showHistory() {
 721          if (mNote != null &amp;&amp; mNote.getVersion() &gt; 1) {
 722              mContentEditText.clearFocus();
 723              mHistoryTimeoutHandler.postDelayed(mHistoryTimeoutRunnable, HISTORY_TIMEOUT);
 724              showHistorySheet();
 725          } else {
 726              Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 727          }
 728      }
 729  
 730      public void showInfo() {
 731          DrawableUtils.startAnimatedVectorDrawable(mInformationMenuItem.getIcon());
 732  
 733          if (mNote != null) {
 734              mContentEditText.clearFocus();
 735              saveNote();
 736              showInfoSheet();
 737          }
 738      }
 739  
 740      private void setMarkdown(boolean isChecked) {
 741          mIsMarkdownEnabled = isChecked;
 742          showMarkdownActionOrTabs();
 743          saveNote();
 744  
 745          // Set preference so that next new note will have markdown enabled.
 746          SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(requireContext());
 747          SharedPreferences.Editor editor = prefs.edit();
 748          editor.putBoolean(PrefUtils.PREF_MARKDOWN_ENABLED, isChecked);
 749          editor.apply();
 750      }
 751  
 752      private void setMarkdownEnabled(boolean enabled) {
 753          mIsMarkdownEnabled = enabled;
 754  
 755          if (mIsMarkdownEnabled) {
 756              loadMarkdownData();
 757          }
 758      }
 759  
 760      private void showMarkdownActionOrTabs() {
 761          Activity activity = getActivity();
 762  
 763          if (activity instanceof NoteEditorActivity) {
 764              NoteEditorActivity editorActivity = (NoteEditorActivity) activity;
 765  
 766              if (mIsMarkdownEnabled) {
 767                  editorActivity.showTabs();
 768  
 769                  if (mNoteMarkdownFragment == null) {
 770                      // Get markdown fragment and update content
 771                      mNoteMarkdownFragment = editorActivity.getNoteMarkdownFragment();
 772                      mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPreviewTextContent());
 773                  }
 774              } else {
 775                  editorActivity.hideTabs();
 776              }
 777          } else if (activity instanceof NotesActivity) {
 778              setMarkdownEnabled(mIsMarkdownEnabled);
 779              ((NotesActivity) getActivity()).setMarkdownShowing(false);
 780          }
 781      }
 782  
 783      private void loadMarkdownData() {
 784          String formattedContent = NoteMarkdownFragment.getMarkdownFormattedContent(
 785                  mCss,
 786                  mContentEditText.getPreviewTextContent()
 787          );
 788  
 789          mMarkdown.loadDataWithBaseURL(null, formattedContent, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 790      }
 791  
 792      public void setNote(String noteID, String matchOffsets) {
 793          if (mAutoSaveHandler != null)
 794              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 795  
 796          mPlaceholderView.setVisibility(View.GONE);
 797  
 798          if (matchOffsets != null) {
 799              mMatchOffsets = matchOffsets;
 800          } else {
 801              mMatchOffsets = null;
 802          }
 803  
 804  
 805          saveNote();
 806  
 807          new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteID);
 808      }
 809  
 810      private void updateNote(Note updatedNote) {
 811          // update note if network change arrived
 812          mNote = updatedNote;
 813          refreshContent(true);
 814      }
 815  
 816      private void refreshContent(boolean isNoteUpdate) {
 817          if (mNote != null) {
 818              // Restore the cursor position if possible.
<abbr title=" 819              int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.getSelectionEnd());"> 819              int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.geðŸ”µ</abbr>
 820              mContentEditText.setText(mNote.getContent());
 821  
 822              if (isNoteUpdate) {
 823                  // Update markdown and preview flags from updated note.
 824                  mIsMarkdownEnabled = mNote.isMarkdownEnabled();
 825                  mIsPreviewEnabled = mNote.isPreviewEnabled();
 826  
 827                  // Show/Hide action/tabs based on markdown flag.
 828                  showMarkdownActionOrTabs();
 829  
 830                  // Save note so any local changes get synced.
 831                  mNote.save();
 832  
 833                  // Update current note object on large screen devices in landscape orientation.
 834                  if (DisplayUtils.isLargeScreenLandscape(requireContext())) {
 835                      ((NotesActivity) requireActivity()).setCurrentNote(mNote);
 836                  }
 837  
 838                  // Update overflow popup menu.
 839                  requireActivity().invalidateOptionsMenu();
 840  
 841                  if (mContentEditText.hasFocus()
 842                          &amp;&amp; cursorPosition != mContentEditText.getSelectionEnd()
 843                          &amp;&amp; cursorPosition &lt; mContentEditText.getText().length()) {
 844                      mContentEditText.setSelection(cursorPosition);
 845                  }
 846              }
 847  
 848              afterTextChanged(mContentEditText.getText());
 849              mContentEditText.processChecklists();
 850              updateTagList();
 851          }
 852      }
 853  
 854      private void updateTagList() {
 855          setChips(mNote.getTagString());
 856          mTagInput.setText(&quot;&quot;);
 857      }
 858  
 859      private int newCursorLocation(String newText, String oldText, int cursorLocation) {
 860          // Ported from the iOS app :)
 861          // Cases:
 862          // 0. All text after cursor (and possibly more) was removed ==&gt; put cursor at end
 863          // 1. Text was added after the cursor ==&gt; no change
 864          // 2. Text was added before the cursor ==&gt; location advances
 865          // 3. Text was removed after the cursor ==&gt; no change
 866          // 4. Text was removed before the cursor ==&gt; location retreats
 867          // 5. Text was added/removed on both sides of the cursor ==&gt; not handled
 868  
 869          cursorLocation = Math.max(cursorLocation, 0);
 870  
 871          int newCursorLocation = cursorLocation;
 872  
 873          int deltaLength = newText.length() - oldText.length();
 874  
 875          // Case 0
 876          if (newText.length() &lt; cursorLocation)
 877              return newText.length();
 878  
 879          boolean beforeCursorMatches = false;
 880          boolean afterCursorMatches = false;
 881  
 882          try {
<abbr title=" 883              beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation));"> 883              beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation)ðŸ”µ</abbr>
<abbr title=" 884              afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaLength));"> 884              afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaðŸ”µ</abbr>
 885          } catch (Exception e) {
 886              e.printStackTrace();
 887          }
 888  
 889          // Cases 2 and 4
 890          if (!beforeCursorMatches &amp;&amp; afterCursorMatches)
 891              newCursorLocation += deltaLength;
 892  
 893          // Cases 1, 3 and 5 have no change
 894          return newCursorLocation;
 895      }
 896  
 897      @Override
 898      public void onTagAdded(String tag) {
 899          if (mNote == null || !isAdded()) {
 900              return;
 901          }
 902  
 903          if (mNote.getTagString() != null &amp;&amp; tag.length() &gt; mNote.getTagString().length()) {
 904              AnalyticsTracker.track(
 905                  EDITOR_TAG_ADDED,
 906                  CATEGORY_NOTE,
 907                  &quot;tag_added_to_note&quot;
 908              );
 909          }
 910  
 911          mNote.setTagString(mNote.getTagString() + String.valueOf(SPACE) + tag);
 912          mNote.setModificationDate(Calendar.getInstance());
 913          updateTagList();
 914          mNote.save();
 915      }
 916  
 917      @Override
 918      public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
 919          // Unused
 920      }
 921  
 922      @Override
 923      public void afterTextChanged(Editable editable) {
 924          attemptAutoList(editable);
 925          setTitleSpan(editable);
 926          mContentEditText.fixLineSpacing();
 927      }
 928  
 929      @Override
 930      public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
 931          // When text changes, start timer that will fire after AUTOSAVE_DELAY_MILLIS passes
 932          if (mAutoSaveHandler != null) {
 933              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 934              mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 935          }
 936  
 937          // Remove search highlight spans when note content changes
 938          if (mMatchOffsets != null) {
 939              mMatchOffsets = null;
 940              mHighlighter.removeMatches();
 941          }
 942  
 943          if (!DisplayUtils.isLargeScreenLandscape(requireContext())) {
 944              ((NoteEditorActivity) requireActivity()).setSearchMatchBarVisible(false);
 945          }
 946  
 947          // Temporarily remove the text watcher as we process checklists to prevent callback looping
 948          mContentEditText.removeTextChangedListener(this);
 949          mContentEditText.processChecklists();
 950          mContentEditText.addTextChangedListener(this);
 951      }
 952  
 953      /**
 954       * Set the note title to be a larger size and bold style.
 955       *
 956       * Remove all existing spans before applying spans or performance issues will occur.  Since both
 957       * {@link RelativeSizeSpan} and {@link StyleSpan} inherit from {@link MetricAffectingSpan}, all
 958       * spans are removed when {@link MetricAffectingSpan} is removed.
 959       */
 960      private void setTitleSpan(Editable editable) {
 961          for (MetricAffectingSpan span : editable.getSpans(0, editable.length(), MetricAffectingSpan.class)) {
 962              if (span instanceof RelativeSizeSpan || span instanceof StyleSpan) {
 963                  editable.removeSpan(span);
 964              }
 965          }
 966  
 967          int newLinePosition = getNoteContentString().indexOf(&quot;\n&quot;);
 968  
 969          if (newLinePosition == 0) {
 970              return;
 971          }
 972  
 973          int titleEndPosition = (newLinePosition &gt; 0) ? newLinePosition : editable.length();
 974          editable.setSpan(new RelativeSizeSpan(1.3f), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
 975          editable.setSpan(new StyleSpan(Typeface.BOLD), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
 976      }
 977  
 978      private void attemptAutoList(Editable editable) {
 979          int oldCursorPosition = mCurrentCursorPosition;
 980          mCurrentCursorPosition = mContentEditText.getSelectionStart();
 981          AutoBullet.apply(editable, oldCursorPosition, mCurrentCursorPosition);
 982          mCurrentCursorPosition = mContentEditText.getSelectionStart();
 983      }
 984  
 985      private void saveAndSyncNote() {
 986          if (mNote == null) {
 987              return;
 988          }
 989  
 990          AppLog.add(
 991              Type.ACTION,
 992              &quot;Edited note (ID: &quot; + mNote.getSimperiumKey() +
 993                  &quot; / Title: &quot; + mNote.getTitle() +
 994                  &quot; / Characters: &quot; + NoteUtils.getCharactersCount(mNote.getContent()) +
 995                  &quot; / Words: &quot; + NoteUtils.getWordCount(mNote.getContent()) + &quot;)&quot;
 996          );
 997          new SaveNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 998      }
 999  
1000      public boolean isPlaceholderVisible() {
1001          if (mPlaceholderView != null) {
1002              return mPlaceholderView.getVisibility() == View.VISIBLE;
1003          } else {
1004              return false;
1005          }
1006      }
1007  
1008      public void setPlaceholderVisible(boolean isVisible) {
1009          if (isVisible) {
1010              mNote = null;
1011              mContentEditText.setText(&quot;&quot;);
1012          }
1013  
1014          if (mPlaceholderView != null) {
1015              mPlaceholderView.setVisibility(isVisible ? View.VISIBLE : View.GONE);
1016          }
1017      }
1018  
1019      @Override
1020      public void onFocusChange(View v, boolean hasFocus) {
1021          if (!hasFocus) {
1022              String tags = getNoteTagsString().trim();
1023  
1024              if (mTagInput.getText().toString().trim().length() &gt; 0
1025                  &amp;&amp; TagUtils.hashTagValid(mTagInput.getText().toString().trim())) {
1026                  onTagAdded(mTagInput.getText().toString());
1027              } else if (tags.length() &gt; 0) {
1028                  setChips(tags);
1029              }
1030          }
1031      }
1032  
1033      private Note getNote() {
1034          return mNote;
1035      }
1036  
1037      public void setNote(String noteID) {
1038          setNote(noteID, null);
1039      }
1040  
1041      private String getNoteContentString() {
1042          if (mContentEditText == null || mContentEditText.getText() == null) {
1043              return &quot;&quot;;
1044          } else {
1045              return mContentEditText.getText().toString();
1046          }
1047      }
1048  
1049      private String getNoteTagsString() {
1050          StringBuilder tags = new StringBuilder();
1051  
1052          for (int i= 0; i &lt; mTagChips.getChildCount(); i++) {
1053              tags.append(((Chip) mTagChips.getChildAt(i)).getText()).append(&quot; &quot;);
1054          }
1055  
1056          return tags.toString();
1057      }
1058  
1059      /**
1060       * Share bottom sheet callbacks
1061       */
1062  
1063      @Override
1064      public void onSharePublishClicked() {
1065          publishNote();
1066          if (mShareBottomSheet != null) {
1067              mShareBottomSheet.dismiss();
1068          }
1069      }
1070  
1071      @Override
1072      public void onShareUnpublishClicked() {
1073          unpublishNote();
1074          if (mShareBottomSheet != null) {
1075              mShareBottomSheet.dismiss();
1076          }
1077      }
1078  
1079      @Override
1080      public void onWordPressPostClicked() {
1081          if (mShareBottomSheet != null) {
1082              mShareBottomSheet.dismiss();
1083          }
1084  
1085          if (getFragmentManager() == null) {
1086              return;
1087          }
1088  
1089          FragmentTransaction ft = getFragmentManager().beginTransaction();
1090          Fragment prev = getFragmentManager().findFragmentByTag(WordPressDialogFragment.DIALOG_TAG);
1091          if (prev != null) {
1092              ft.remove(prev);
1093          }
1094          ft.addToBackStack(null);
1095  
1096          // Create and show the dialog.
1097          WordPressDialogFragment wpDialogFragment = new WordPressDialogFragment();
1098          wpDialogFragment.setNote(mNote);
1099          wpDialogFragment.show(ft, WordPressDialogFragment.DIALOG_TAG);
1100      }
1101  
1102      @Override
1103      public void onShareCollaborateClicked() {
1104          Toast.makeText(getActivity(), R.string.collaborate_message, Toast.LENGTH_LONG).show();
1105      }
1106  
1107      @Override
1108      public void onShareDismissed() {
1109  
1110      }
1111  
1112      /**
1113       * History bottom sheet listeners
1114       */
1115  
1116      @Override
1117      public void onHistoryCancelClicked() {
1118          mContentEditText.setText(mNote.getContent());
1119          if (mHistoryBottomSheet != null) {
1120              mHistoryBottomSheet.dismiss();
1121          }
1122      }
1123  
1124      @Override
1125      public void onHistoryRestoreClicked() {
1126          if (mHistoryBottomSheet != null) {
1127              mHistoryBottomSheet.dismiss();
1128          }
1129          saveAndSyncNote();
1130      }
1131  
1132      @Override
1133      public void onHistoryDismissed() {
1134          if (!mHistoryBottomSheet.didTapOnButton()) {
1135              mContentEditText.setText(mNote.getContent());
1136          }
1137  
1138          if (mHistoryTimeoutHandler != null) {
1139              mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
1140          }
1141      }
1142  
1143      @Override
1144      public void onHistoryUpdateNote(String content) {
1145          mContentEditText.setText(content);
1146      }
1147  
1148      private void saveNote() {
1149          try {
1150              if (mNote == null || mNotesBucket == null || mContentEditText == null || mIsLoadingNote ||
<abbr title="1151                  (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing())) {">1151                  (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getðŸ”µ</abbr>
1152                  return;
1153              } else {
1154                  mNote = mNotesBucket.get(mNote.getSimperiumKey());
1155                  mIsPreviewEnabled = mNote.isPreviewEnabled();
1156              }
1157  
1158              String content = mContentEditText.getPlainTextContent();
1159              String tagString = getNoteTagsString();
1160  
<abbr title="1161              if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnabled)) {">1161              if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnableðŸ”µ</abbr>
1162                  mNote.setContent(content);
1163                  mNote.setTagString(tagString);
1164                  mNote.setModificationDate(Calendar.getInstance());
1165                  mNote.setMarkdownEnabled(mIsMarkdownEnabled);
1166                  mNote.setPreviewEnabled(mIsPreviewEnabled);
1167                  mNote.save();
1168  
1169                  AnalyticsTracker.track(
1170                      EDITOR_NOTE_EDITED,
1171                      CATEGORY_NOTE,
1172                      &quot;editor_save&quot;
1173                  );
1174  
1175                  AppLog.add(
1176                      Type.SYNC,
1177                      &quot;Saved note locally in NoteEditorFragment (ID: &quot; + mNote.getSimperiumKey() +
1178                          &quot; / Title: &quot; + mNote.getTitle() +
1179                          &quot; / Characters: &quot; + NoteUtils.getCharactersCount(content) +
1180                          &quot; / Words: &quot; + NoteUtils.getWordCount(content) + &quot;)&quot;
1181                  );
1182              }
1183          } catch (BucketObjectMissingException exception) {
1184              exception.printStackTrace();
1185          }
1186      }
1187  
1188      // Checks if cursor is at a URL when the selection changes
1189      // If it is a URL, show the contextual action bar
1190      @Override
1191      public void onSelectionChanged(int selStart, int selEnd) {
1192          mCurrentCursorPosition = selEnd;

1193          if (selStart == selEnd) {
1194              Editable noteContent = mContentEditText.getText();
1195              if (noteContent == null)


1196                  return;

1197  
1198              URLSpan[] urlSpans = noteContent.getSpans(selStart, selStart, URLSpan.class);

1199              if (urlSpans.length &gt; 0) {
1200                  URLSpan urlSpan = urlSpans[0];
1201                  mLinkUrl = urlSpan.getURL();
<abbr title="1202                  mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSpan)).toString();">1202                  mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSðŸ”µ</abbr>

1203                  if (mActionMode != null) {
1204                      mActionMode.setSubtitle(mLinkText);
1205                      updateMenuItems();
1206                      return;
1207                  }
1208  
1209                  // Show the Contextual Action Bar
1210                  if (getActivity() != null) {
1211                      mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCallback);

1212                      if (mActionMode != null) {
1213                          mActionMode.setSubtitle(mLinkText);
1214                      }
1215  
1216                      updateMenuItems();
1217                  }
1218              } else if (mActionMode != null) {
1219                  mActionMode.finish();
1220                  mActionMode = null;
1221              }
1222          } else if (mActionMode != null) {
1223              mActionMode.finish();
1224              mActionMode = null;
1225          }
1226      }
1227  
1228      private void updateMenuItems() {
1229          mCopyMenuItem.setIcon(mCopyIcon);
1230          mShareMenuItem.setIcon(mShareIcon);
1231  
1232          if (mViewLinkMenuItem != null &amp;&amp; mLinkUrl != null) {
1233              if (mLinkUrl.startsWith(&quot;tel:&quot;)) {
1234                  mViewLinkMenuItem.setIcon(mCallIcon);
1235                  mViewLinkMenuItem.setTitle(getString(R.string.call));
1236              } else if (mLinkUrl.startsWith(&quot;mailto:&quot;)) {
1237                  mViewLinkMenuItem.setIcon(mEmailIcon);
1238                  mViewLinkMenuItem.setTitle(getString(R.string.email));
1239              } else if (mLinkUrl.startsWith(&quot;geo:&quot;)) {
1240                  mViewLinkMenuItem.setIcon(mMapIcon);
1241                  mViewLinkMenuItem.setTitle(getString(R.string.view_map));



1242              } else {
1243                  mViewLinkMenuItem.setIcon(mBrowserIcon);
1244                  mViewLinkMenuItem.setTitle(getString(R.string.view_in_browser));
1245              }
1246          }
1247      }
1248  
1249      private void setPublishedNote(boolean isPublished) {
1250          if (mNote != null) {
1251              mNote.setPublished(isPublished);
1252              mNote.save();
1253  
1254              // reset publish status in 20 seconds if we don&#x27;t hear back from Simperium
1255              mPublishTimeoutHandler.postDelayed(mPublishTimeoutRunnable, PUBLISH_TIMEOUT);
1256  
1257              AnalyticsTracker.track(
1258                  isPublished ? EDITOR_NOTE_PUBLISHED : EDITOR_NOTE_UNPUBLISHED,
1259                  CATEGORY_NOTE,
1260                  &quot;publish_note_button&quot;
1261              );
1262          }
1263      }
1264  
1265      private void updatePublishedState(boolean isSuccess) {
1266          if (mPublishingSnackbar == null) {
1267              return;
1268          }
1269  
1270          mPublishingSnackbar.dismiss();
1271          mPublishingSnackbar = null;
1272  
1273          if (isSuccess &amp;&amp; isAdded()) {
1274              if (mNote.isPublished()) {
1275                  @StringRes int text;
1276  
1277                  if (BrowserUtils.copyToClipboard(requireContext(), mNote.getPublishedUrl())) {
1278                      text = R.string.publish_successful_link;
1279                  } else {
1280                      text = R.string.publish_successful;
1281                  }
1282  
1283                  if (mHideActionOnSuccess) {
1284                      Snackbar.make(mRootView, text, Snackbar.LENGTH_LONG).show();
1285                  } else {
1286                      Snackbar.make(mRootView, text, Snackbar.LENGTH_LONG)
1287                          .setAction(
1288                              R.string.undo,
1289                              new View.OnClickListener() {
1290                                  @Override
1291                                  public void onClick(View v) {
1292                                      mHideActionOnSuccess = true;
1293                                      unpublishNote();
1294                                  }
1295                              }
1296                          )
1297                          .show();
1298                  }
1299              } else {
1300                  if (mHideActionOnSuccess) {
1301                      Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG)
1302                              .show();
1303                  } else {
1304                      Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG)
1305                              .setAction(
1306                                  R.string.undo,
1307                                  new View.OnClickListener() {
1308                                      @Override
1309                                      public void onClick(View v) {
1310                                          mHideActionOnSuccess = true;
1311                                          publishNote();
1312                                      }
1313                                  }
1314                              )
1315                              .show();
1316                  }
1317              }
1318          } else {
1319              if (mNote.isPublished()) {
1320                  Snackbar.make(mRootView, R.string.unpublish_error, Snackbar.LENGTH_LONG)
1321                          .setAction(
1322                              R.string.retry,
1323                              new View.OnClickListener() {
1324                                  @Override
1325                                  public void onClick(View v) {
1326                                      mHideActionOnSuccess = true;
1327                                      unpublishNote();
1328                                  }
1329                              }
1330                          ).show();
1331              } else {
1332                  Snackbar.make(mRootView, R.string.publish_error, Snackbar.LENGTH_LONG)
1333                          .setAction(
1334                              R.string.retry,
1335                              new View.OnClickListener() {
1336                                  @Override
1337                                  public void onClick(View v) {
1338                                      mHideActionOnSuccess = true;
1339                                      publishNote();
1340                                  }
1341                              }
1342                          ).show();
1343              }
1344          }
1345  
1346          mHideActionOnSuccess = false;
1347          requireActivity().invalidateOptionsMenu();
1348      }
1349  
1350      private void publishNote() {
1351          if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1352              Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1353              return;
1354          }
1355  
1356          if (isAdded()) {
1357              mPublishingSnackbar = Snackbar.make(mRootView, R.string.publishing, Snackbar.LENGTH_INDEFINITE);
1358              mPublishingSnackbar.show();
1359          }
1360  
1361          setPublishedNote(true);
1362      }
1363  
1364      private void unpublishNote() {
1365          if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1366              Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1367              return;
1368          }
1369  
1370          if (isAdded()) {
1371              mPublishingSnackbar = Snackbar.make(mRootView, R.string.unpublishing, Snackbar.LENGTH_INDEFINITE);
1372              mPublishingSnackbar.show();
1373          }
1374  
1375          setPublishedNote(false);
1376      }
1377  
1378      private void showShare(String text) {
1379          startActivity(
1380              ShareCompat.IntentBuilder.from(requireActivity())
1381                  .setText(text)
1382                  .setType(&quot;text/plain&quot;)
1383                  .createChooserIntent()
1384          );
1385      }
1386      private void showShareSheet() {
1387          if (isAdded() &amp;&amp; mShareBottomSheet != null &amp;&amp; !mShareBottomSheet.isAdded()) {
1388              mShareBottomSheet.show(requireFragmentManager(), mNote);
1389          }
1390      }
1391  
1392      private void showInfoSheet() {
1393          if (isAdded() &amp;&amp; mInfoBottomSheet != null &amp;&amp; !mInfoBottomSheet.isAdded()) {
1394              mInfoBottomSheet.show(requireFragmentManager(), mNote);
1395          }
1396      }
1397  
1398      private void showHistorySheet() {
1399          if (isAdded() &amp;&amp; mHistoryBottomSheet != null &amp;&amp; !mHistoryBottomSheet.isAdded()) {
1400              // Request revisions for the current note
1401              mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbacks());
1402              saveNote();
1403  
1404              mHistoryBottomSheet.show(requireFragmentManager(), mNote);
1405          }
1406      }
1407  
1408      /**
1409       * Simperium listeners
1410       */
1411  
1412      @Override
1413      public void onDeleteObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1414  
1415      }
1416  
1417      @Override
1418      public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) {
1419          if (changeType == Bucket.ChangeType.MODIFY) {
1420              if (getNote() != null &amp;&amp; getNote().getSimperiumKey().equals(key)) {
1421                  try {
1422                      mNotesBucket = noteBucket;
1423                      final Note updatedNote = mNotesBucket.get(key);
1424                      if (getActivity() != null) {
1425                          getActivity().runOnUiThread(new Runnable() {
1426                              @Override
1427                              public void run() {
1428                                  if (mPublishTimeoutHandler != null) {
1429                                      mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
1430                                  }
1431  
1432                                  updateNote(updatedNote);
1433                                  updatePublishedState(true);
1434                              }
1435                          });
1436                      }
1437                  } catch (BucketObjectMissingException e) {
1438                      e.printStackTrace();
1439                  }
1440              }
1441          }
1442      }
1443  
1444      @Override
1445      public void onSaveObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1446          if (mIsPaused) {
1447              mNotesBucket.removeListener(this);
1448              mNotesBucket.stop();
1449              AppLog.add(Type.SYNC, &quot;Stopped note bucket (NoteEditorFragment)&quot;);
1450          }
1451  
1452          AppLog.add(
1453              Type.SYNC,
1454              &quot;Saved note callback in NoteEditorFragment (ID: &quot; + note.getSimperiumKey() +
1455                  &quot; / Title: &quot; + note.getTitle() +
1456                  &quot; / Characters: &quot; + NoteUtils.getCharactersCount(note.getContent()) +
1457                  &quot; / Words: &quot; + NoteUtils.getWordCount(note.getContent()) + &quot;)&quot;
1458          );
1459      }
1460  
1461      @Override
1462      public void onBeforeUpdateObject(Bucket&lt;Note&gt; bucket, Note note) {
1463          // Don&#x27;t apply updates if we haven&#x27;t loaded the note yet
1464          if (mIsLoadingNote)
1465              return;
1466  
1467          Note openNote = getNote();
1468          if (openNote == null || !openNote.getSimperiumKey().equals(note.getSimperiumKey()))
1469              return;
1470  
1471          note.setContent(mContentEditText.getPlainTextContent());
1472      }
1473  
1474      private static class LoadNoteTask extends AsyncTask&lt;String, Void, Void&gt; {
1475          WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1476  
1477          LoadNoteTask(NoteEditorFragment fragment) {
1478              mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1479          }
1480  
1481          @Override
1482          protected void onPreExecute() {
1483              NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1484  
1485              if (fragment != null) {
1486                  fragment.mContentEditText.removeTextChangedListener(fragment);
1487                  fragment.mIsLoadingNote = true;
1488              }
1489          }
1490  
1491          @Override
1492          protected Void doInBackground(String... args) {
1493              NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1494  
1495              if (fragment == null || fragment.getActivity() == null) {
1496                  return null;
1497              }
1498  
1499              String noteID = args[0];
1500              Simplenote application = (Simplenote) fragment.getActivity().getApplication();
1501              Bucket&lt;Note&gt; notesBucket = application.getNotesBucket();
1502  
1503              try {
1504                  fragment.mNote = notesBucket.get(noteID);
1505  
1506                  // Set the current note in NotesActivity when on a tablet
1507                  if (fragment.getActivity() instanceof NotesActivity) {
1508                      ((NotesActivity) fragment.getActivity()).setCurrentNote(fragment.mNote);
1509                  }
1510  
1511                  // Set markdown and preview flags for current note
1512                  if (fragment.mNote != null) {
1513                      fragment.mIsMarkdownEnabled = fragment.mNote.isMarkdownEnabled();
1514                      fragment.mIsPreviewEnabled = fragment.mNote.isPreviewEnabled();
1515                      AppLog.add(
1516                          Type.SYNC,
1517                          &quot;Loaded note (ID: &quot; + fragment.mNote.getSimperiumKey() +
1518                              &quot; / Title: &quot; + fragment.mNote.getTitle() +
1519                              &quot; / Characters: &quot; + NoteUtils.getCharactersCount(fragment.mNote.getContent()) +
1520                              &quot; / Words: &quot; + NoteUtils.getWordCount(fragment.mNote.getContent()) + &quot;)&quot;
1521                      );
1522                  }
1523              } catch (BucketObjectMissingException e) {
1524                  // See if the note is in the object store
1525                  Bucket.ObjectCursor&lt;Note&gt; notesCursor = notesBucket.allObjects();
1526  
1527                  while (notesCursor.moveToNext()) {
1528                      Note currentNote = notesCursor.getObject();
1529  
1530                      if (currentNote != null &amp;&amp; currentNote.getSimperiumKey().equals(noteID)) {
1531                          fragment.mNote = currentNote;
1532                          return null;
1533                      }
1534                  }
1535              }
1536  
1537              return null;
1538          }
1539  
1540          @Override
1541          protected void onPostExecute(Void nada) {
1542              final NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1543              if (fragment == null || fragment.getActivity() == null || fragment.getActivity().isFinishing()) {
1544                  return;
1545              }
1546  
1547              fragment.refreshContent(false);
1548  
1549              if (fragment.mMatchOffsets != null) {
<abbr title="1550                  int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.CONTENT_PROPERTY);">1550                  int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.COðŸ”µ</abbr>
1551                  fragment.mHighlighter.highlightMatches(fragment.mMatchOffsets, columnIndex);
1552                  fragment.mShouldScrollToSearchMatch = true;
1553              }
1554  
1555              fragment.mContentEditText.addTextChangedListener(fragment);
1556  
1557              if (fragment.mNote != null &amp;&amp; fragment.mNote.getContent().isEmpty()) {
1558                  // Show soft keyboard
1559                  fragment.mContentEditText.requestFocus();
1560  
1561                  new Handler().postDelayed(new Runnable() {
1562                      @Override
1563                      public void run() {
1564                          if (fragment.getActivity() == null) {
1565                              return;
1566                          }
1567  
<abbr title="1568                          InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);">1568                          InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivity().getSysðŸ”µ</abbr>
1569  
1570                          if (inputMethodManager != null) {
1571                              inputMethodManager.showSoftInput(fragment.mContentEditText, 0);
1572                          }
1573                      }
1574                  }, 100);
1575              } else if (fragment.mNote != null) {
1576                  // If we have a valid note, hide the placeholder
1577                  fragment.setPlaceholderVisible(false);
1578              }
1579  
1580              fragment.updateMarkdownView();
1581              fragment.requireActivity().invalidateOptionsMenu();
1582              fragment.linkifyEditorContent();
1583              fragment.mIsLoadingNote = false;
1584          }
1585      }
1586  
1587      private static class SaveNoteTask extends AsyncTask&lt;Void, Void, Void&gt; {
1588          WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1589  
1590          SaveNoteTask(NoteEditorFragment fragment) {
1591              mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1592          }
1593  
1594          @Override
1595          protected Void doInBackground(Void... args) {
1596              NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1597  
1598              if (fragment != null) {
1599                  fragment.saveNote();
1600              }
1601  
1602              return null;
1603          }
1604  
1605          @Override
1606          protected void onPostExecute(Void nada) {
1607              NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1608  
1609              if (fragment != null &amp;&amp; fragment.getActivity() != null &amp;&amp; !fragment.getActivity().isFinishing()) {
1610                  // Update links
1611                  fragment.linkifyEditorContent();
1612                  fragment.updateMarkdownView();
1613              }
1614          }
1615      }
1616  
1617      private void linkifyEditorContent() {
1618          if (getActivity() == null || getActivity().isFinishing()) {
1619              return;
1620          }
1621  
1622          if (PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_DETECT_LINKS)) {
1623              SimplenoteLinkify.addLinks(mContentEditText, Linkify.ALL);
1624          }
1625      }
1626  
1627      // Show tabs if markdown is enabled globally, for current note, and not tablet landscape
1628      private void updateMarkdownView() {
1629          if (!mIsMarkdownEnabled) {
1630              return;
1631          }
1632  
1633          Activity activity = getActivity();
1634          if (activity instanceof NotesActivity) {
1635              // This fragment lives in NotesActivity, so load markdown in this fragment&#x27;s WebView.
1636              loadMarkdownData();
1637          } else {
1638              // This fragment lives in the NoteEditorActivity&#x27;s ViewPager.
1639              if (mNoteMarkdownFragment == null) {
1640                  mNoteMarkdownFragment = ((NoteEditorActivity) requireActivity())
1641                          .getNoteMarkdownFragment();
1642                  ((NoteEditorActivity) requireActivity()).showTabs();
1643              }
1644              // Load markdown in the sibling NoteMarkdownFragment&#x27;s WebView.
1645              mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPreviewTextContent());
1646          }
1647      }
1648  
1649      private ColorStateList getChipBackgroundColor() {
1650          int[][] states = new int[][] {
1651              new int[] { android.R.attr.state_checked}, // checked
1652              new int[] {-android.R.attr.state_checked}  // unchecked
1653          };
1654  
1655          int[] colors = new int[] {
1656              ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOnBackgroundColor),
1657              ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOffBackgroundColor)
1658          };
1659  
1660          return new ColorStateList(states, colors);
1661      }
1662  
1663      private void setChips(CharSequence text) {
1664          mTagPadding.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1665          mTagChips.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1666          mTagChips.setSingleSelection(true);
1667          mTagChips.removeAllViews();
1668          SimpleStringSplitter tags = new SimpleStringSplitter(SPACE);
1669          tags.setString(text.toString());
1670  
1671          for (String tag : tags) {
1672              final Chip chip = new Chip(requireContext());
1673              chip.setText(tag);
1674              chip.setCheckable(true);
1675              chip.setCheckedIcon(null);
1676              chip.setChipBackgroundColor(getChipBackgroundColor());
1677              chip.setTextColor(ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipTextColor));
1678              chip.setStateListAnimator(null);
1679              chip.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
1680                  @Override
1681                  public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
1682                      chip.setCloseIconVisible(isChecked);
1683                  }
1684              });
1685              chip.setOnCloseIconClickListener(new View.OnClickListener() {
1686                  @Override
1687                  public void onClick(View view) {
1688                      mTagChips.removeView(view);
1689                      updateTags();
1690                      AnalyticsTracker.track(
1691                          EDITOR_TAG_REMOVED,
1692                          CATEGORY_NOTE,
1693                          &quot;tag_removed_from_note&quot;
1694                      );
1695                  }
1696              });
1697              mTagChips.addView(chip);
1698          }
1699      }
1700  
1701      private void updateTags() {
1702          if (mNote == null) {
1703              return;
1704          }
1705  
1706          mNote.setTagString(getNoteTagsString());
1707          mNote.setModificationDate(Calendar.getInstance());
1708          updateTagList();
1709          mNote.save();
1710      }
1711  }</pre></td>
                            <td><pre>   1  package com.automattic.simplenote;
   2  
   3  import android.app.Activity;
   4  import android.content.Context;
   5  import android.content.SharedPreferences;
   6  import android.content.res.ColorStateList;
   7  import android.database.Cursor;
   8  import android.graphics.Typeface;
   9  import android.graphics.drawable.Drawable;
  10  import android.os.AsyncTask;
  11  import android.os.Bundle;
  12  import android.os.Handler;
  13  import android.text.Editable;
  14  import android.text.Layout;
  15  import android.text.Spanned;
  16  import android.text.TextUtils.SimpleStringSplitter;
  17  import android.text.TextWatcher;
  18  import android.text.style.MetricAffectingSpan;
  19  import android.text.style.RelativeSizeSpan;
  20  import android.text.style.StyleSpan;
  21  import android.text.style.URLSpan;
  22  import android.text.util.Linkify;
  23  import android.util.TypedValue;
  24  import android.view.LayoutInflater;
  25  import android.view.Menu;
  26  import android.view.MenuInflater;
  27  import android.view.MenuItem;
  28  import android.view.View;
  29  import android.view.ViewGroup;
  30  import android.view.ViewTreeObserver;
  31  import android.view.inputmethod.InputMethodManager;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  32 +import android.webkit.WebResourceRequest;</span>
  33  import android.webkit.WebView;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  34 +import android.webkit.WebViewClient;</span>
  35  import android.widget.CompoundButton;
  36  import android.widget.CursorAdapter;
  37  import android.widget.LinearLayout;
  38  import android.widget.TextView;
  39  import android.widget.Toast;
  40  
  41  import androidx.annotation.NonNull;
  42  import androidx.annotation.StringRes;
  43  import androidx.appcompat.app.AppCompatActivity;
  44  import androidx.appcompat.view.ActionMode;
  45  import androidx.core.app.ShareCompat;
  46  import androidx.core.view.MenuCompat;
  47  import androidx.core.widget.NestedScrollView;
  48  import androidx.fragment.app.Fragment;
  49  import androidx.fragment.app.FragmentTransaction;
  50  import androidx.preference.PreferenceManager;
  51  
  52  import com.automattic.simplenote.analytics.AnalyticsTracker;
  53  import com.automattic.simplenote.models.Note;
  54  import com.automattic.simplenote.models.Tag;
  55  import com.automattic.simplenote.utils.AppLog;
  56  import com.automattic.simplenote.utils.AppLog.Type;
  57  import com.automattic.simplenote.utils.AutoBullet;
  58  import com.automattic.simplenote.utils.BrowserUtils;
  59  import com.automattic.simplenote.utils.ContextUtils;
  60  import com.automattic.simplenote.utils.DisplayUtils;
  61  import com.automattic.simplenote.utils.DrawableUtils;
  62  import com.automattic.simplenote.utils.MatchOffsetHighlighter;
  63  import com.automattic.simplenote.utils.NetworkUtils;
  64  import com.automattic.simplenote.utils.NoteUtils;
  65  import com.automattic.simplenote.utils.PrefUtils;
  66  import com.automattic.simplenote.utils.SimplenoteLinkify;
  67  import com.automattic.simplenote.utils.SimplenoteMovementMethod;
  68  import com.automattic.simplenote.utils.SpaceTokenizer;
  69  import com.automattic.simplenote.utils.TagUtils;
  70  import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;
  71  import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;
  72  import com.automattic.simplenote.utils.TextHighlighter;
  73  import com.automattic.simplenote.utils.ThemeUtils;
  74  import com.automattic.simplenote.utils.WidgetUtils;
  75  import com.automattic.simplenote.widgets.SimplenoteEditText;
  76  import com.google.android.material.chip.Chip;
  77  import com.google.android.material.chip.ChipGroup;
  78  import com.google.android.material.snackbar.Snackbar;
  79  import com.simperium.client.Bucket;
  80  import com.simperium.client.BucketObjectMissingException;
  81  import com.simperium.client.Query;
  82  
  83  import java.lang.ref.WeakReference;
  84  import java.util.Calendar;
  85  
  86  import static com.automattic.simplenote.analytics.AnalyticsTracker.CATEGORY_NOTE;
  87  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_CHECKLIST_INSERTED;
  88  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_CONTENT_SHARED;
  89  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_EDITED;
  90  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_PUBLISHED;
  91  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_UNPUBLISHED;
  92  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_ADDED;
  93  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_REMOVED;
  94  import static com.automattic.simplenote.utils.SearchTokenizer.SPACE;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  95 +import static com.automattic.simplenote.utils.SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX;</span>
  96  
  97  public class NoteEditorFragment extends Fragment implements Bucket.Listener&lt;Note&gt;,
  98          TextWatcher, OnTagAddedListener, View.OnFocusChangeListener,
  99          SimplenoteEditText.OnSelectionChangedListener,
 100          ShareBottomSheetDialog.ShareSheetListener,
 101          HistoryBottomSheetDialog.HistorySheetListener,
 102          SimplenoteEditText.OnCheckboxToggledListener {
 103  
 104      public static final String ARG_IS_FROM_WIDGET = &quot;is_from_widget&quot;;
 105      public static final String ARG_ITEM_ID = &quot;item_id&quot;;
 106      public static final String ARG_NEW_NOTE = &quot;new_note&quot;;
 107      public static final String ARG_MATCH_OFFSETS = &quot;match_offsets&quot;;
 108      public static final String ARG_MARKDOWN_ENABLED = &quot;markdown_enabled&quot;;
 109      public static final String ARG_PREVIEW_ENABLED = &quot;preview_enabled&quot;;
 110      private static final String STATE_NOTE_ID = &quot;state_note_id&quot;;
 111      private static final int AUTOSAVE_DELAY_MILLIS = 2000;
 112      private static final int MAX_REVISIONS = 30;
 113      private static final int PUBLISH_TIMEOUT = 20000;
 114      private static final int HISTORY_TIMEOUT = 10000;
 115      private Note mNote;
 116      private final Runnable mAutoSaveRunnable = new Runnable() {
 117          @Override
 118          public void run() {
 119              saveAndSyncNote();
 120          }
 121      };
 122      private Bucket&lt;Note&gt; mNotesBucket;
 123      private View mRootView;
 124      private View mTagPadding;
 125      private SimplenoteEditText mContentEditText;
 126      private ChipGroup mTagChips;
 127      private TagsMultiAutoCompleteTextView mTagInput;
 128      private Handler mAutoSaveHandler;
 129      private Handler mPublishTimeoutHandler;
 130      private Handler mHistoryTimeoutHandler;
 131      private LinearLayout mPlaceholderView;
 132      private CursorAdapter mAutocompleteAdapter;
 133      private boolean mIsLoadingNote;
 134      private boolean mIsMarkdownEnabled;
 135      private boolean mIsPreviewEnabled;
 136      private boolean mShouldScrollToSearchMatch;
 137      private ActionMode mActionMode;
 138      private MenuItem mChecklistMenuItem;
 139      private MenuItem mCopyMenuItem;
 140      private MenuItem mInformationMenuItem;
 141      private MenuItem mShareMenuItem;
 142      private MenuItem mViewLinkMenuItem;
 143      private String mLinkUrl;
 144      private String mLinkText;
 145      private MatchOffsetHighlighter mHighlighter;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 146 +    private Drawable mBrowserIcon;</span>
 147      private Drawable mCallIcon;
 148      private Drawable mCopyIcon;
 149      private Drawable mEmailIcon;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 150 +    private Drawable mLinkIcon;</span>
 151      private Drawable mMapIcon;
 152      private Drawable mShareIcon;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 153 -    private Drawable mBrowserIcon;</span>
 154      private MatchOffsetHighlighter.SpanFactory mMatchHighlighter;
 155      private String mMatchOffsets;
 156      private int mCurrentCursorPosition;
 157      private HistoryBottomSheetDialog mHistoryBottomSheet;
 158      private boolean mIsPaused;
 159      private boolean mIsFromWidget;
 160  
 161      // Hides the history bottom sheet if no revisions are loaded
 162      private final Runnable mHistoryTimeoutRunnable = new Runnable() {
 163          @Override
 164          public void run() {
 165              if (!isAdded()) {
 166                  return;
 167              }
 168  
 169              requireActivity().runOnUiThread(new Runnable() {
 170                  @Override
 171                  public void run() {
<abbr title=" 172                      if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; !mHistoryBottomSheet.isHistoryLoaded()) {"> 172                      if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; ðŸ”µ</abbr>
 173                          mHistoryBottomSheet.dismiss();
 174                          Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 175                      }
 176                  }
 177              });
 178          }
 179      };
 180      private InfoBottomSheetDialog mInfoBottomSheet;
 181      private ShareBottomSheetDialog mShareBottomSheet;
 182      // Contextual action bar for dealing with links
 183      private final ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
 184          // Called when the action mode is created; startActionMode() was called
 185          @Override
 186          public boolean onCreateActionMode(ActionMode mode, Menu menu) {
 187              // Inflate a menu resource providing context menu items
 188              MenuInflater inflater = mode.getMenuInflater();
 189  
 190              if (inflater != null) {
 191                  inflater.inflate(R.menu.view_link, menu);
 192                  mCopyMenuItem = menu.findItem(R.id.menu_copy);
 193                  mShareMenuItem = menu.findItem(R.id.menu_share);
 194                  mViewLinkMenuItem = menu.findItem(R.id.menu_view_link);
 195                  mode.setTitle(getString(R.string.link));
 196                  mode.setTitleOptionalHint(false);
 197  
 198                  DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 199              }
 200  
<abbr title=" 201              int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.background_dark;"> 201              int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.backgrðŸ”µ</abbr>
<abbr title=" 202              requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().getTheme()));"> 202              requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().ðŸ”µ</abbr>

 203              return true;
 204          }
 205  
 206          // Called each time the action mode is shown. Always called after onCreateActionMode, but
 207          // may be called multiple times if the mode is invalidated.
 208          @Override
 209          public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 210              return false; // Return false if nothing is done
 211          }
 212  
 213          // Called when the user selects a contextual menu item
 214          @Override
 215          public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 216              switch (item.getItemId()) {
 217                  case R.id.menu_view_link:
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 218 -                    if (mLinkUrl != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 219 -                        try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 220 -                            BrowserUtils.launchBrowserOrShowError(requireContext(), mLinkUrl);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 221 -                        } catch (Exception e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 222 -                            e.printStackTrace();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 223 +                    if (mLinkText != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 224 +                        if (mLinkText.startsWith(SIMPLENOTE_LINK_PREFIX)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 225 +                            SimplenoteLinkify.openNote(requireActivity(), mLinkText.replace(SIMPLENOTE_LINK_PREFIX, &quot;&quot;));"> 225 +                            SimplenoteLinkify.openNote(requireActivity(), mLinkText.replace(SIMPLENOTE_LINK_PREFIXðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 226 +                        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 227 +                            try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 228 +                                BrowserUtils.launchBrowserOrShowError(requireContext(), mLinkText);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 229 +                            } catch (Exception e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 230 +                                e.printStackTrace();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 231 +                            }</span>
 232                          }
 233  
 234                          mode.finish(); // Action picked, so close the CAB
 235                      }
 236  
 237                      return true;
 238                  case R.id.menu_copy:
 239                      if (mLinkText != null &amp;&amp; getActivity() != null) {
 240                          if (BrowserUtils.copyToClipboard(requireContext(), mLinkText)) {
 241                              Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 242                          } else {
 243                              Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();
 244                          }
 245  
 246                          mode.finish();
 247                      }
 248  
 249                      return true;
 250                  case R.id.menu_share:
 251                      if (mLinkText != null) {
 252                          showShare(mLinkText);
 253                          mode.finish();
 254                      }
 255  
 256                      return true;
 257                  default:
 258                      return false;
 259              }
 260          }
 261  
 262          // Called when the user exits the action mode
 263          @Override
 264          public void onDestroyActionMode(ActionMode mode) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 265 -            mActionMode = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 266 +            if (mActionMode != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 267 +                mActionMode.setSubtitle(&quot;&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 268 +                mActionMode = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 269 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 270 +</span>
 271              new Handler().postDelayed(
 272                  new Runnable() {
 273                      @Override
 274                      public void run() {
<abbr title=" 275                          requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 275                          requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.trðŸ”µ</abbr>
 276                      }
 277                  },
 278                  requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime)
 279              );
 280          }
 281      };
 282      private Snackbar mPublishingSnackbar;
 283      private boolean mHideActionOnSuccess;
 284      // Resets note publish status if Simperium never returned the new publish status
 285      private final Runnable mPublishTimeoutRunnable = new Runnable() {
 286          @Override
 287          public void run() {
 288              if (!isAdded()) return;
 289  
 290              requireActivity().runOnUiThread(new Runnable() {
 291                  @Override
 292                  public void run() {
 293  
 294                      mNote.setPublished(!mNote.isPublished());
 295                      mNote.save();
 296  
 297                      updatePublishedState(false);
 298                  }
 299              });
 300          }
 301      };
 302      private NoteMarkdownFragment mNoteMarkdownFragment;
 303      private String mCss;
 304      private WebView mMarkdown;
 305  
 306      /**
 307       * Mandatory empty constructor for the fragment manager to instantiate the
 308       * fragment (e.g. upon screen orientation changes).
 309       */
 310      public NoteEditorFragment() {
 311      }
 312  
 313      @Override
 314      public void onCreate(Bundle savedInstanceState) {
 315          super.onCreate(savedInstanceState);
 316          AppLog.add(Type.NETWORK, NetworkUtils.getNetworkInfo(requireContext()));
 317          AppLog.add(Type.SCREEN, &quot;Created (NoteEditorFragment)&quot;);
 318          mInfoBottomSheet = new InfoBottomSheetDialog(this);
 319          mShareBottomSheet = new ShareBottomSheetDialog(this, this);
 320          mHistoryBottomSheet = new HistoryBottomSheetDialog(this, this);
 321  
 322          Simplenote currentApp = (Simplenote) requireActivity().getApplication();
 323          mNotesBucket = currentApp.getNotesBucket();
 324  
<abbr title=" 325          mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.actionModeTextColor);"> 325          mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.aðŸ”µ</abbr>
<abbr title=" 326          mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.attr.actionModeTextColor);"> 326          mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.attr.actioðŸ”µ</abbr>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 327 +        mLinkIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_note_24dp, R.attr.actionModeTextColor);"> 327 +        mLinkIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_note_24dp, R.attr.actionMðŸ”µ</abbr></span>
<abbr title=" 328          mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.actionModeTextColor);"> 328          mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.actionModðŸ”µ</abbr>
<abbr title=" 329          mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp, R.attr.actionModeTextColor);"> 329          mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp, R.attr.aðŸ”µ</abbr>
<abbr title=" 330          mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attr.actionModeTextColor);"> 330          mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attr.actionMðŸ”µ</abbr>
<abbr title=" 331          mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.attr.actionModeTextColor);"> 331          mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.attr.actioðŸ”µ</abbr>
 332  
 333          mAutoSaveHandler = new Handler();
 334          mPublishTimeoutHandler = new Handler();
 335          mHistoryTimeoutHandler = new Handler();
 336  
 337          mMatchHighlighter = new TextHighlighter(requireActivity(),
 338                  R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor);
 339          mAutocompleteAdapter = new CursorAdapter(getActivity(), null, 0x0) {
 340              @Override
 341              public View newView(Context context, Cursor cursor, ViewGroup parent) {
 342                  Activity activity = (Activity) context;
 343                  if (activity == null) return null;
 344                  return activity.getLayoutInflater().inflate(R.layout.tag_autocomplete_list_item, null);
 345              }
 346  
 347              @Override
 348              public void bindView(View view, Context context, Cursor cursor) {
 349                  TextView textView = (TextView) view;
 350                  textView.setText(convertToString(cursor));
 351              }
 352  
 353              @Override
 354              public CharSequence convertToString(Cursor cursor) {
 355                  return cursor.getString(cursor.getColumnIndex(Tag.NAME_PROPERTY));
 356              }
 357  
 358              @Override
 359              public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 360                  Activity activity = getActivity();
 361                  if (activity == null) return null;
 362                  Simplenote application = (Simplenote) activity.getApplication();
 363                  Query&lt;Tag&gt; query = application.getTagsBucket().query();
 364                  // make the tag name available to the cursor
 365                  query.include(Tag.NAME_PROPERTY);
 366                  // sort the tags by their names
 367                  query.order(Tag.NAME_PROPERTY);
 368                  // if there&#x27;s a filter string find only matching tag names
 369                  if (filter != null)
 370                      query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filter));
 371                  return query.execute();
 372              }
 373          };
 374  
 375          WidgetUtils.updateNoteWidgets(requireActivity().getApplicationContext());
 376      }
 377  
 378      @Override
 379      public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
 380          mRootView = inflater.inflate(R.layout.fragment_note_editor, container, false);
 381          mContentEditText = mRootView.findViewById(R.id.note_content);
 382          mContentEditText.addOnSelectionChangedListener(this);
 383          mContentEditText.setOnCheckboxToggledListener(this);
 384          mContentEditText.setMovementMethod(SimplenoteMovementMethod.getInstance());
 385          mContentEditText.setOnFocusChangeListener(this);
 386          mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()));
 387          mTagInput = mRootView.findViewById(R.id.tag_input);
 388          mTagInput.setDropDownBackgroundResource(R.drawable.bg_list_popup);
 389          mTagInput.setTokenizer(new SpaceTokenizer());
 390          mTagInput.setOnFocusChangeListener(this);
 391          mTagChips = mRootView.findViewById(R.id.tag_chips);
 392          mTagPadding = mRootView.findViewById(R.id.tag_padding);
 393          mHighlighter = new MatchOffsetHighlighter(mMatchHighlighter, mContentEditText);
 394          mPlaceholderView = mRootView.findViewById(R.id.placeholder);
 395  
 396          if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote == null) {
 397              mPlaceholderView.setVisibility(View.VISIBLE);
 398              requireActivity().invalidateOptionsMenu();
 399              mMarkdown = mRootView.findViewById(R.id.markdown);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 400 +            mMarkdown.setWebViewClient(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 401 +                new WebViewClient() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 402 +                    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 403 +                    public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 404 +                        String url = request.getUrl().toString();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 405 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 406 +                        if (url.startsWith(SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 407 +                            SimplenoteLinkify.openNote(requireActivity(), url.replace(SIMPLENOTE_LINK_PREFIX, &quot;&quot;));"> 407 +                            SimplenoteLinkify.openNote(requireActivity(), url.replace(SIMPLENOTE_LINK_PREFIX, &quot;&quot;))ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 408 +                        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 409 +                            BrowserUtils.launchBrowserOrShowError(requireContext(), url);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 410 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 411 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 412 +                        return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 413 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 414 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 415 +            );</span>
 416              mCss = ThemeUtils.isLightTheme(requireContext())
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 417 -                    ? ContextUtils.readCssFile(requireContext(), &quot;light.css&quot;)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 418 -                    : ContextUtils.readCssFile(requireContext(), &quot;dark.css&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 419 +                ? ContextUtils.readCssFile(requireContext(), &quot;light.css&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 420 +                : ContextUtils.readCssFile(requireContext(), &quot;dark.css&quot;);</span>
 421          }
 422  
 423          mTagInput.setAdapter(mAutocompleteAdapter);
 424          Bundle arguments = getArguments();
 425  
 426          if (arguments != null &amp;&amp; arguments.containsKey(ARG_ITEM_ID)) {
 427              // Load note if we were passed a note Id
 428              String key = arguments.getString(ARG_ITEM_ID);
 429  
 430              if (arguments.containsKey(ARG_MATCH_OFFSETS)) {
 431                  mMatchOffsets = arguments.getString(ARG_MATCH_OFFSETS);
 432              }
 433  
 434              mIsFromWidget = arguments.getBoolean(ARG_IS_FROM_WIDGET);
 435  
 436              if (mIsFromWidget) {
 437                  AppLog.add(Type.ACTION, &quot;Opened from widget (NoteEditorFragment)&quot;);
 438              } else {
 439                  AppLog.add(Type.ACTION, &quot;Opened from list (NoteEditorFragment)&quot;);
 440              }
 441  
 442              new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, key);
 443          } else if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; savedInstanceState != null) {
 444              // Restore selected note when in dual pane mode
 445              String noteId = savedInstanceState.getString(STATE_NOTE_ID);
 446  
 447              if (noteId != null) {
 448                  setNote(noteId);
 449              }
 450          }
 451  
 452          ViewTreeObserver viewTreeObserver = mContentEditText.getViewTreeObserver();
 453          viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
 454              @Override
 455              public void onGlobalLayout() {
 456                  // If a note was loaded with search matches, scroll to the first match in the editor
 457                  if (mShouldScrollToSearchMatch &amp;&amp; mMatchOffsets != null) {
 458                      if (!isAdded()) {
 459                          return;
 460                      }
 461  
 462                      // Get the character location of the first search match
 463                      int matchLocation = MatchOffsetHighlighter.getFirstMatchLocation(
 464                              mContentEditText.getText(),
 465                              mMatchOffsets
 466                      );
 467                      if (matchLocation == 0) {
 468                          return;
 469                      }
 470  
 471                      // Calculate how far to scroll to bring the match into view
 472                      Layout layout = mContentEditText.getLayout();
 473                      int lineTop = layout.getLineTop(layout.getLineForOffset(matchLocation));
 474                      ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 475                      mShouldScrollToSearchMatch = false;
 476                  }
 477              }
 478          });
 479          setHasOptionsMenu(true);
 480          return mRootView;
 481      }
 482  
 483      public void scrollToMatch(int location) {
 484          if (isAdded()) {
 485              // Calculate how far to scroll to bring the match into view
 486              Layout layout = mContentEditText.getLayout();
 487              int lineTop = layout.getLineTop(layout.getLineForOffset(location));
 488              ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 489          }
 490      }
 491  
 492      @Override
 493      public void onResume() {
 494          super.onResume();
 495          mNotesBucket.start();
 496          AppLog.add(Type.SYNC, &quot;Started note bucket (NoteEditorFragment)&quot;);
 497          mNotesBucket.addListener(this);
 498          mTagInput.setOnTagAddedListener(this);
 499  
 500          if (mContentEditText != null) {
 501              mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()));
 502  
 503              if (mContentEditText.hasFocus()) {
 504                  showSoftKeyboard();
 505              }
 506          }
 507      }
 508  
 509      private void showSoftKeyboard() {
 510          new Handler().postDelayed(new Runnable() {
 511              @Override
 512              public void run() {
 513                  if (getActivity() == null) {
 514                      return;
 515                  }
 516  
<abbr title=" 517                  InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);"> 517                  InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(ContexðŸ”µ</abbr>
 518                  if (inputMethodManager != null) {
 519                      inputMethodManager.showSoftInput(mContentEditText, 0);
 520                  }
 521              }
 522          }, 100);
 523      }
 524  
 525      @Override
 526      public void onPause() {
 527          super.onPause();  // Always call the superclass method first
 528          mIsPaused = true;
 529  
 530          // Hide soft keyboard if it is showing...
 531          DisplayUtils.hideKeyboard(mContentEditText);
 532  
 533          mTagInput.setOnTagAddedListener(null);
 534  
 535          if (mAutoSaveHandler != null) {
 536              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 537              mAutoSaveHandler.post(mAutoSaveRunnable);
 538          }
 539  
 540          if (mPublishTimeoutHandler != null) {
 541              mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
 542          }
 543  
 544          if (mHistoryTimeoutHandler != null) {
 545              mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 546          }
 547  
 548          mHighlighter.stop();
 549          saveNote();
 550          AppLog.add(Type.SCREEN, &quot;Paused (NoteEditorFragment)&quot;);
 551      }
 552  
 553      @Override
 554      public void onDestroy() {
 555          super.onDestroy();
 556          mNotesBucket.removeListener(this);
 557          mNotesBucket.stop();
 558          AppLog.add(Type.SYNC, &quot;Stopped note bucket (NoteEditorFragment)&quot;);
 559          AppLog.add(Type.SCREEN, &quot;Destroyed (NoteEditorFragment)&quot;);
 560      }
 561  
 562      @Override
 563      public void onSaveInstanceState(@NonNull Bundle outState) {
 564          super.onSaveInstanceState(outState);
 565  
 566          if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote != null) {
 567              outState.putString(STATE_NOTE_ID, mNote.getSimperiumKey());
 568          }
 569      }
 570  
 571      @Override
 572      public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
 573          super.onCreateOptionsMenu(menu, inflater);
 574  
<abbr title=" 575          if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFragment == null)) {"> 575          if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFrðŸ”µ</abbr>
 576              return;
 577          }
 578  
 579          inflater.inflate(R.menu.note_editor, menu);
 580          MenuCompat.setGroupDividerEnabled(menu, true);
 581      }
 582  
 583      @Override
 584      public boolean onOptionsItemSelected(@NonNull MenuItem item) {
 585          switch (item.getItemId()) {
 586              case R.id.menu_checklist:
 587                  insertChecklist();
 588                  return true;
 589              case R.id.menu_copy:
 590                  if (BrowserUtils.copyToClipboard(requireContext(), mNote.getPublishedUrl())) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 591 +                    Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 592 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 593 +                    Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 594 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 595 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 596 +                return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 597 +            case R.id.menu_copy_internal:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 598 +                if (BrowserUtils.copyToClipboard(requireContext(), SimplenoteLinkify.getNoteLinkWithTitle(mNote.getTitle(), mNote.getSimperiumKey()))) {"> 598 +                if (BrowserUtils.copyToClipboard(requireContext(), SimplenoteLinkify.getNoteLinkWithTitle(mNote.geðŸ”µ</abbr></span>
 599                      Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 600                  } else {
 601                      Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();
 602                  }
 603  
 604                  return true;
 605              case R.id.menu_history:
 606                  showHistory();
 607                  return true;
 608              case R.id.menu_info:
 609                  showInfo();
 610                  return true;
 611              case R.id.menu_markdown:
 612                  setMarkdown(!item.isChecked());
 613                  return true;
 614              case R.id.menu_pin:
 615                  NoteUtils.setNotePin(mNote, !item.isChecked());
 616                  requireActivity().invalidateOptionsMenu();
 617                  return true;
 618              case R.id.menu_publish:
 619                  if (item.isChecked()) {
 620                      unpublishNote();
 621                  } else {
 622                      publishNote();
 623                  }
 624  
 625                  return true;
 626              case R.id.menu_share:
 627                  shareNote();
 628                  return true;
 629              case R.id.menu_trash:
 630                  if (!isAdded()) {
 631                      return false;
 632                  }
 633  
 634                  deleteNote();
 635                  return true;
 636              case android.R.id.home:
 637                  AppLog.add(Type.ACTION, &quot;Tapped back arrow in app bar (NoteEditorFragment)&quot;);
 638                  if (!isAdded()) {
 639                      return false;
 640                  }
 641  
 642                  requireActivity().finish();
 643                  return true;
 644              default:
 645                  return super.onOptionsItemSelected(item);
 646          }
 647      }
 648  
 649      @Override
 650      public void onPrepareOptionsMenu(@NonNull Menu menu) {
 651          if (mNote != null) {
 652              MenuItem pinItem = menu.findItem(R.id.menu_pin);
 653              MenuItem shareItem = menu.findItem(R.id.menu_share);
 654              MenuItem historyItem = menu.findItem(R.id.menu_history);
 655              MenuItem publishItem = menu.findItem(R.id.menu_publish);
 656              MenuItem copyLinkItem = menu.findItem(R.id.menu_copy);
 657              MenuItem markdownItem = menu.findItem(R.id.menu_markdown);
 658              MenuItem trashItem = menu.findItem(R.id.menu_trash);
 659              mChecklistMenuItem = menu.findItem(R.id.menu_checklist);
 660              mInformationMenuItem = menu.findItem(R.id.menu_info).setVisible(true);
 661  
 662              pinItem.setChecked(mNote.isPinned());
 663              publishItem.setChecked(mNote.isPublished());
 664              markdownItem.setChecked(mNote.isMarkdownEnabled());
 665  
 666              // Disable actions when note is in Trash or markdown view is shown on large device.
 667              if (mNote.isDeleted() || (mMarkdown != null &amp;&amp; mMarkdown.getVisibility() == View.VISIBLE)) {
 668                  pinItem.setEnabled(false);
 669                  shareItem.setEnabled(false);
 670                  historyItem.setEnabled(false);
 671                  publishItem.setEnabled(false);
 672                  copyLinkItem.setEnabled(false);
 673                  markdownItem.setEnabled(false);
 674                  mChecklistMenuItem.setEnabled(false);
 675                  DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 0.3);  // 0.3 is 30% opacity.
 676              } else {
 677                  pinItem.setEnabled(true);
 678                  shareItem.setEnabled(true);
 679                  historyItem.setEnabled(true);
 680                  publishItem.setEnabled(true);
 681                  copyLinkItem.setEnabled(mNote.isPublished());
 682                  markdownItem.setEnabled(true);
 683                  mChecklistMenuItem.setEnabled(true);
 684                  DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 1.0);  // 1.0 is 100% opacity.
 685              }
 686  
 687              if (mNote.isDeleted()) {
 688                  trashItem.setTitle(R.string.restore);
 689              } else {
 690                  trashItem.setTitle(R.string.trash);
 691              }
 692          }
 693  
 694          DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 695          super.onPrepareOptionsMenu(menu);
 696      }
 697  
 698      public void insertChecklist() {
 699          DrawableUtils.startAnimatedVectorDrawable(mChecklistMenuItem.getIcon());
 700  
 701          try {
 702              mContentEditText.insertChecklist();
 703          } catch (Exception e) {
 704              e.printStackTrace();
 705              return;
 706          }
 707  
 708          AnalyticsTracker.track(
 709              EDITOR_CHECKLIST_INSERTED,
 710              CATEGORY_NOTE,
 711              &quot;toolbar_button&quot;
 712          );
 713      }
 714  
 715      @Override
 716      public void onCheckboxToggled() {
 717          // Save note (using delay) after toggling a checkbox
 718          if (mAutoSaveHandler != null) {
 719              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 720              mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 721          }
 722      }
 723  
 724      private void deleteNote() {
 725          NoteUtils.deleteNote(mNote, getActivity());
 726          requireActivity().finish();
 727      }
 728  
 729      protected void clearMarkdown() {
 730          mMarkdown.loadDataWithBaseURL(&quot;file:///android_asset/&quot;, mCss + &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 731      }
 732  
 733      protected void hideMarkdown() {
 734          mMarkdown.setVisibility(View.INVISIBLE);
 735      }
 736  
 737      protected void showMarkdown() {
 738          loadMarkdownData();
 739          mMarkdown.setVisibility(View.VISIBLE);
 740  
 741          new Handler().postDelayed(
 742              new Runnable() {
 743                  @Override
 744                  public void run() {
 745                      requireActivity().invalidateOptionsMenu();
 746                  }
 747              },
 748              getResources().getInteger(R.integer.time_animation)
 749          );
 750      }
 751  
 752      public void shareNote() {
 753          if (mNote != null) {
 754              mContentEditText.clearFocus();
 755              showShareSheet();
 756              AnalyticsTracker.track(
 757                  EDITOR_NOTE_CONTENT_SHARED,
 758                  CATEGORY_NOTE,
 759                  &quot;action_bar_share_button&quot;
 760              );
 761          }
 762      }
 763  
 764      public void showHistory() {
 765          if (mNote != null &amp;&amp; mNote.getVersion() &gt; 1) {
 766              mContentEditText.clearFocus();
 767              mHistoryTimeoutHandler.postDelayed(mHistoryTimeoutRunnable, HISTORY_TIMEOUT);
 768              showHistorySheet();
 769          } else {
 770              Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 771          }
 772      }
 773  
 774      public void showInfo() {
 775          DrawableUtils.startAnimatedVectorDrawable(mInformationMenuItem.getIcon());
 776  
 777          if (mNote != null) {
 778              mContentEditText.clearFocus();
 779              saveNote();
 780              showInfoSheet();
 781          }
 782      }
 783  
 784      private void setMarkdown(boolean isChecked) {
 785          mIsMarkdownEnabled = isChecked;
 786          showMarkdownActionOrTabs();
 787          saveNote();
 788  
 789          // Set preference so that next new note will have markdown enabled.
 790          SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(requireContext());
 791          SharedPreferences.Editor editor = prefs.edit();
 792          editor.putBoolean(PrefUtils.PREF_MARKDOWN_ENABLED, isChecked);
 793          editor.apply();
 794      }
 795  
 796      private void setMarkdownEnabled(boolean enabled) {
 797          mIsMarkdownEnabled = enabled;
 798  
 799          if (mIsMarkdownEnabled) {
 800              loadMarkdownData();
 801          }
 802      }
 803  
 804      private void showMarkdownActionOrTabs() {
 805          Activity activity = getActivity();
 806  
 807          if (activity instanceof NoteEditorActivity) {
 808              NoteEditorActivity editorActivity = (NoteEditorActivity) activity;
 809  
 810              if (mIsMarkdownEnabled) {
 811                  editorActivity.showTabs();
 812  
 813                  if (mNoteMarkdownFragment == null) {
 814                      // Get markdown fragment and update content
 815                      mNoteMarkdownFragment = editorActivity.getNoteMarkdownFragment();
 816                      mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPreviewTextContent());
 817                  }
 818              } else {
 819                  editorActivity.hideTabs();
 820              }
 821          } else if (activity instanceof NotesActivity) {
 822              setMarkdownEnabled(mIsMarkdownEnabled);
 823              ((NotesActivity) getActivity()).setMarkdownShowing(false);
 824          }
 825      }
 826  
 827      private void loadMarkdownData() {
 828          String formattedContent = NoteMarkdownFragment.getMarkdownFormattedContent(
 829                  mCss,
 830                  mContentEditText.getPreviewTextContent()
 831          );
 832  
 833          mMarkdown.loadDataWithBaseURL(null, formattedContent, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 834      }
 835  
 836      public void setNote(String noteID, String matchOffsets) {
 837          if (mAutoSaveHandler != null)
 838              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 839  
 840          mPlaceholderView.setVisibility(View.GONE);
 841  
 842          if (matchOffsets != null) {
 843              mMatchOffsets = matchOffsets;
 844          } else {
 845              mMatchOffsets = null;
 846          }
 847  
 848  
 849          saveNote();
 850  
 851          new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteID);
 852      }
 853  
 854      private void updateNote(Note updatedNote) {
 855          // update note if network change arrived
 856          mNote = updatedNote;
 857          refreshContent(true);
 858      }
 859  
 860      private void refreshContent(boolean isNoteUpdate) {
 861          if (mNote != null) {
 862              // Restore the cursor position if possible.
<abbr title=" 863              int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.getSelectionEnd());"> 863              int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.geðŸ”µ</abbr>
 864              mContentEditText.setText(mNote.getContent());
 865  
 866              if (isNoteUpdate) {
 867                  // Update markdown and preview flags from updated note.
 868                  mIsMarkdownEnabled = mNote.isMarkdownEnabled();
 869                  mIsPreviewEnabled = mNote.isPreviewEnabled();
 870  
 871                  // Show/Hide action/tabs based on markdown flag.
 872                  showMarkdownActionOrTabs();
 873  
 874                  // Save note so any local changes get synced.
 875                  mNote.save();
 876  
 877                  // Update current note object on large screen devices in landscape orientation.
 878                  if (DisplayUtils.isLargeScreenLandscape(requireContext())) {
 879                      ((NotesActivity) requireActivity()).setCurrentNote(mNote);
 880                  }
 881  
 882                  // Update overflow popup menu.
 883                  requireActivity().invalidateOptionsMenu();
 884  
 885                  if (mContentEditText.hasFocus()
 886                          &amp;&amp; cursorPosition != mContentEditText.getSelectionEnd()
 887                          &amp;&amp; cursorPosition &lt; mContentEditText.getText().length()) {
 888                      mContentEditText.setSelection(cursorPosition);
 889                  }
 890              }
 891  
 892              afterTextChanged(mContentEditText.getText());
 893              mContentEditText.processChecklists();
 894              updateTagList();
 895          }
 896      }
 897  
 898      private void updateTagList() {
 899          setChips(mNote.getTagString());
 900          mTagInput.setText(&quot;&quot;);
 901      }
 902  
 903      private int newCursorLocation(String newText, String oldText, int cursorLocation) {
 904          // Ported from the iOS app :)
 905          // Cases:
 906          // 0. All text after cursor (and possibly more) was removed ==&gt; put cursor at end
 907          // 1. Text was added after the cursor ==&gt; no change
 908          // 2. Text was added before the cursor ==&gt; location advances
 909          // 3. Text was removed after the cursor ==&gt; no change
 910          // 4. Text was removed before the cursor ==&gt; location retreats
 911          // 5. Text was added/removed on both sides of the cursor ==&gt; not handled
 912  
 913          cursorLocation = Math.max(cursorLocation, 0);
 914  
 915          int newCursorLocation = cursorLocation;
 916  
 917          int deltaLength = newText.length() - oldText.length();
 918  
 919          // Case 0
 920          if (newText.length() &lt; cursorLocation)
 921              return newText.length();
 922  
 923          boolean beforeCursorMatches = false;
 924          boolean afterCursorMatches = false;
 925  
 926          try {
<abbr title=" 927              beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation));"> 927              beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation)ðŸ”µ</abbr>
<abbr title=" 928              afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaLength));"> 928              afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaðŸ”µ</abbr>
 929          } catch (Exception e) {
 930              e.printStackTrace();
 931          }
 932  
 933          // Cases 2 and 4
 934          if (!beforeCursorMatches &amp;&amp; afterCursorMatches)
 935              newCursorLocation += deltaLength;
 936  
 937          // Cases 1, 3 and 5 have no change
 938          return newCursorLocation;
 939      }
 940  
 941      @Override
 942      public void onTagAdded(String tag) {
 943          if (mNote == null || !isAdded()) {
 944              return;
 945          }
 946  
 947          if (mNote.getTagString() != null &amp;&amp; tag.length() &gt; mNote.getTagString().length()) {
 948              AnalyticsTracker.track(
 949                  EDITOR_TAG_ADDED,
 950                  CATEGORY_NOTE,
 951                  &quot;tag_added_to_note&quot;
 952              );
 953          }
 954  
 955          mNote.setTagString(mNote.getTagString() + String.valueOf(SPACE) + tag);
 956          mNote.setModificationDate(Calendar.getInstance());
 957          updateTagList();
 958          mNote.save();
 959      }
 960  
 961      @Override
 962      public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
 963          // Unused
 964      }
 965  
 966      @Override
 967      public void afterTextChanged(Editable editable) {
 968          attemptAutoList(editable);
 969          setTitleSpan(editable);
 970          mContentEditText.fixLineSpacing();
 971      }
 972  
 973      @Override
 974      public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
 975          // When text changes, start timer that will fire after AUTOSAVE_DELAY_MILLIS passes
 976          if (mAutoSaveHandler != null) {
 977              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 978              mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 979          }
 980  
 981          // Remove search highlight spans when note content changes
 982          if (mMatchOffsets != null) {
 983              mMatchOffsets = null;
 984              mHighlighter.removeMatches();
 985          }
 986  
 987          if (!DisplayUtils.isLargeScreenLandscape(requireContext())) {
 988              ((NoteEditorActivity) requireActivity()).setSearchMatchBarVisible(false);
 989          }
 990  
 991          // Temporarily remove the text watcher as we process checklists to prevent callback looping
 992          mContentEditText.removeTextChangedListener(this);
 993          mContentEditText.processChecklists();
 994          mContentEditText.addTextChangedListener(this);
 995      }
 996  
 997      /**
 998       * Set the note title to be a larger size and bold style.
 999       *
1000       * Remove all existing spans before applying spans or performance issues will occur.  Since both
1001       * {@link RelativeSizeSpan} and {@link StyleSpan} inherit from {@link MetricAffectingSpan}, all
1002       * spans are removed when {@link MetricAffectingSpan} is removed.
1003       */
1004      private void setTitleSpan(Editable editable) {
1005          for (MetricAffectingSpan span : editable.getSpans(0, editable.length(), MetricAffectingSpan.class)) {
1006              if (span instanceof RelativeSizeSpan || span instanceof StyleSpan) {
1007                  editable.removeSpan(span);
1008              }
1009          }
1010  
1011          int newLinePosition = getNoteContentString().indexOf(&quot;\n&quot;);
1012  
1013          if (newLinePosition == 0) {
1014              return;
1015          }
1016  
1017          int titleEndPosition = (newLinePosition &gt; 0) ? newLinePosition : editable.length();
1018          editable.setSpan(new RelativeSizeSpan(1.3f), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
1019          editable.setSpan(new StyleSpan(Typeface.BOLD), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
1020      }
1021  
1022      private void attemptAutoList(Editable editable) {
1023          int oldCursorPosition = mCurrentCursorPosition;
1024          mCurrentCursorPosition = mContentEditText.getSelectionStart();
1025          AutoBullet.apply(editable, oldCursorPosition, mCurrentCursorPosition);
1026          mCurrentCursorPosition = mContentEditText.getSelectionStart();
1027      }
1028  
1029      private void saveAndSyncNote() {
1030          if (mNote == null) {
1031              return;
1032          }
1033  
1034          AppLog.add(
1035              Type.ACTION,
1036              &quot;Edited note (ID: &quot; + mNote.getSimperiumKey() +
1037                  &quot; / Title: &quot; + mNote.getTitle() +
1038                  &quot; / Characters: &quot; + NoteUtils.getCharactersCount(mNote.getContent()) +
1039                  &quot; / Words: &quot; + NoteUtils.getWordCount(mNote.getContent()) + &quot;)&quot;
1040          );
1041          new SaveNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
1042      }
1043  
1044      public boolean isPlaceholderVisible() {
1045          if (mPlaceholderView != null) {
1046              return mPlaceholderView.getVisibility() == View.VISIBLE;
1047          } else {
1048              return false;
1049          }
1050      }
1051  
1052      public void setPlaceholderVisible(boolean isVisible) {
1053          if (isVisible) {
1054              mNote = null;
1055              mContentEditText.setText(&quot;&quot;);
1056          }
1057  
1058          if (mPlaceholderView != null) {
1059              mPlaceholderView.setVisibility(isVisible ? View.VISIBLE : View.GONE);
1060          }
1061      }
1062  
1063      @Override
1064      public void onFocusChange(View v, boolean hasFocus) {
1065          if (!hasFocus) {
1066              String tags = getNoteTagsString().trim();
1067  
1068              if (mTagInput.getText().toString().trim().length() &gt; 0
1069                  &amp;&amp; TagUtils.hashTagValid(mTagInput.getText().toString().trim())) {
1070                  onTagAdded(mTagInput.getText().toString());
1071              } else if (tags.length() &gt; 0) {
1072                  setChips(tags);
1073              }
1074          }
1075      }
1076  
1077      private Note getNote() {
1078          return mNote;
1079      }
1080  
1081      public void setNote(String noteID) {
1082          setNote(noteID, null);
1083      }
1084  
1085      private String getNoteContentString() {
1086          if (mContentEditText == null || mContentEditText.getText() == null) {
1087              return &quot;&quot;;
1088          } else {
1089              return mContentEditText.getText().toString();
1090          }
1091      }
1092  
1093      private String getNoteTagsString() {
1094          StringBuilder tags = new StringBuilder();
1095  
1096          for (int i= 0; i &lt; mTagChips.getChildCount(); i++) {
1097              tags.append(((Chip) mTagChips.getChildAt(i)).getText()).append(&quot; &quot;);
1098          }
1099  
1100          return tags.toString();
1101      }
1102  
1103      /**
1104       * Share bottom sheet callbacks
1105       */
1106  
1107      @Override
1108      public void onSharePublishClicked() {
1109          publishNote();
1110          if (mShareBottomSheet != null) {
1111              mShareBottomSheet.dismiss();
1112          }
1113      }
1114  
1115      @Override
1116      public void onShareUnpublishClicked() {
1117          unpublishNote();
1118          if (mShareBottomSheet != null) {
1119              mShareBottomSheet.dismiss();
1120          }
1121      }
1122  
1123      @Override
1124      public void onWordPressPostClicked() {
1125          if (mShareBottomSheet != null) {
1126              mShareBottomSheet.dismiss();
1127          }
1128  
1129          if (getFragmentManager() == null) {
1130              return;
1131          }
1132  
1133          FragmentTransaction ft = getFragmentManager().beginTransaction();
1134          Fragment prev = getFragmentManager().findFragmentByTag(WordPressDialogFragment.DIALOG_TAG);
1135          if (prev != null) {
1136              ft.remove(prev);
1137          }
1138          ft.addToBackStack(null);
1139  
1140          // Create and show the dialog.
1141          WordPressDialogFragment wpDialogFragment = new WordPressDialogFragment();
1142          wpDialogFragment.setNote(mNote);
1143          wpDialogFragment.show(ft, WordPressDialogFragment.DIALOG_TAG);
1144      }
1145  
1146      @Override
1147      public void onShareCollaborateClicked() {
1148          Toast.makeText(getActivity(), R.string.collaborate_message, Toast.LENGTH_LONG).show();
1149      }
1150  
1151      @Override
1152      public void onShareDismissed() {
1153  
1154      }
1155  
1156      /**
1157       * History bottom sheet listeners
1158       */
1159  
1160      @Override
1161      public void onHistoryCancelClicked() {
1162          mContentEditText.setText(mNote.getContent());
1163          if (mHistoryBottomSheet != null) {
1164              mHistoryBottomSheet.dismiss();
1165          }
1166      }
1167  
1168      @Override
1169      public void onHistoryRestoreClicked() {
1170          if (mHistoryBottomSheet != null) {
1171              mHistoryBottomSheet.dismiss();
1172          }
1173          saveAndSyncNote();
1174      }
1175  
1176      @Override
1177      public void onHistoryDismissed() {
1178          if (!mHistoryBottomSheet.didTapOnButton()) {
1179              mContentEditText.setText(mNote.getContent());
1180          }
1181  
1182          if (mHistoryTimeoutHandler != null) {
1183              mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
1184          }
1185      }
1186  
1187      @Override
1188      public void onHistoryUpdateNote(String content) {
1189          mContentEditText.setText(content);
1190      }
1191  
1192      private void saveNote() {
1193          try {
1194              if (mNote == null || mNotesBucket == null || mContentEditText == null || mIsLoadingNote ||
<abbr title="1195                  (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing())) {">1195                  (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getðŸ”µ</abbr>
1196                  return;
1197              } else {
1198                  mNote = mNotesBucket.get(mNote.getSimperiumKey());
1199                  mIsPreviewEnabled = mNote.isPreviewEnabled();
1200              }
1201  
1202              String content = mContentEditText.getPlainTextContent();
1203              String tagString = getNoteTagsString();
1204  
<abbr title="1205              if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnabled)) {">1205              if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnableðŸ”µ</abbr>
1206                  mNote.setContent(content);
1207                  mNote.setTagString(tagString);
1208                  mNote.setModificationDate(Calendar.getInstance());
1209                  mNote.setMarkdownEnabled(mIsMarkdownEnabled);
1210                  mNote.setPreviewEnabled(mIsPreviewEnabled);
1211                  mNote.save();
1212  
1213                  AnalyticsTracker.track(
1214                      EDITOR_NOTE_EDITED,
1215                      CATEGORY_NOTE,
1216                      &quot;editor_save&quot;
1217                  );
1218  
1219                  AppLog.add(
1220                      Type.SYNC,
1221                      &quot;Saved note locally in NoteEditorFragment (ID: &quot; + mNote.getSimperiumKey() +
1222                          &quot; / Title: &quot; + mNote.getTitle() +
1223                          &quot; / Characters: &quot; + NoteUtils.getCharactersCount(content) +
1224                          &quot; / Words: &quot; + NoteUtils.getWordCount(content) + &quot;)&quot;
1225                  );
1226              }
1227          } catch (BucketObjectMissingException exception) {
1228              exception.printStackTrace();
1229          }
1230      }
1231  
1232      // Checks if cursor is at a URL when the selection changes
1233      // If it is a URL, show the contextual action bar
1234      @Override
1235      public void onSelectionChanged(int selStart, int selEnd) {
1236          mCurrentCursorPosition = selEnd;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1237 +</span>
1238          if (selStart == selEnd) {
1239              Editable noteContent = mContentEditText.getText();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1240 -            if (noteContent == null)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1241 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1242 +            if (noteContent == null) {</span>
1243                  return;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1244 +            }</span>
1245  
1246              URLSpan[] urlSpans = noteContent.getSpans(selStart, selStart, URLSpan.class);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1247 +</span>
1248              if (urlSpans.length &gt; 0) {
1249                  URLSpan urlSpan = urlSpans[0];
1250                  mLinkUrl = urlSpan.getURL();
<abbr title="1251                  mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSpan)).toString();">1251                  mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSðŸ”µ</abbr>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1252 +</span>
1253                  if (mActionMode != null) {
1254                      mActionMode.setSubtitle(mLinkText);
1255                      updateMenuItems();
1256                      return;
1257                  }
1258  
1259                  // Show the Contextual Action Bar
1260                  if (getActivity() != null) {
1261                      mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCallback);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1262 +</span>
1263                      if (mActionMode != null) {
1264                          mActionMode.setSubtitle(mLinkText);
1265                      }
1266  
1267                      updateMenuItems();
1268                  }
1269              } else if (mActionMode != null) {
1270                  mActionMode.finish();
1271                  mActionMode = null;
1272              }
1273          } else if (mActionMode != null) {
1274              mActionMode.finish();
1275              mActionMode = null;
1276          }
1277      }
1278  
1279      private void updateMenuItems() {
1280          mCopyMenuItem.setIcon(mCopyIcon);
1281          mShareMenuItem.setIcon(mShareIcon);
1282  
1283          if (mViewLinkMenuItem != null &amp;&amp; mLinkUrl != null) {
1284              if (mLinkUrl.startsWith(&quot;tel:&quot;)) {
1285                  mViewLinkMenuItem.setIcon(mCallIcon);
1286                  mViewLinkMenuItem.setTitle(getString(R.string.call));
1287              } else if (mLinkUrl.startsWith(&quot;mailto:&quot;)) {
1288                  mViewLinkMenuItem.setIcon(mEmailIcon);
1289                  mViewLinkMenuItem.setTitle(getString(R.string.email));
1290              } else if (mLinkUrl.startsWith(&quot;geo:&quot;)) {
1291                  mViewLinkMenuItem.setIcon(mMapIcon);
1292                  mViewLinkMenuItem.setTitle(getString(R.string.view_map));
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1293 +            } else if (mLinkUrl.startsWith(SIMPLENOTE_LINK_PREFIX)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1294 +                mViewLinkMenuItem.setIcon(mLinkIcon);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1295 +                mViewLinkMenuItem.setTitle(getString(R.string.open_note));</span>
1296              } else {
1297                  mViewLinkMenuItem.setIcon(mBrowserIcon);
1298                  mViewLinkMenuItem.setTitle(getString(R.string.view_in_browser));
1299              }
1300          }
1301      }
1302  
1303      private void setPublishedNote(boolean isPublished) {
1304          if (mNote != null) {
1305              mNote.setPublished(isPublished);
1306              mNote.save();
1307  
1308              // reset publish status in 20 seconds if we don&#x27;t hear back from Simperium
1309              mPublishTimeoutHandler.postDelayed(mPublishTimeoutRunnable, PUBLISH_TIMEOUT);
1310  
1311              AnalyticsTracker.track(
1312                  isPublished ? EDITOR_NOTE_PUBLISHED : EDITOR_NOTE_UNPUBLISHED,
1313                  CATEGORY_NOTE,
1314                  &quot;publish_note_button&quot;
1315              );
1316          }
1317      }
1318  
1319      private void updatePublishedState(boolean isSuccess) {
1320          if (mPublishingSnackbar == null) {
1321              return;
1322          }
1323  
1324          mPublishingSnackbar.dismiss();
1325          mPublishingSnackbar = null;
1326  
1327          if (isSuccess &amp;&amp; isAdded()) {
1328              if (mNote.isPublished()) {
1329                  @StringRes int text;
1330  
1331                  if (BrowserUtils.copyToClipboard(requireContext(), mNote.getPublishedUrl())) {
1332                      text = R.string.publish_successful_link;
1333                  } else {
1334                      text = R.string.publish_successful;
1335                  }
1336  
1337                  if (mHideActionOnSuccess) {
1338                      Snackbar.make(mRootView, text, Snackbar.LENGTH_LONG).show();
1339                  } else {
1340                      Snackbar.make(mRootView, text, Snackbar.LENGTH_LONG)
1341                          .setAction(
1342                              R.string.undo,
1343                              new View.OnClickListener() {
1344                                  @Override
1345                                  public void onClick(View v) {
1346                                      mHideActionOnSuccess = true;
1347                                      unpublishNote();
1348                                  }
1349                              }
1350                          )
1351                          .show();
1352                  }
1353              } else {
1354                  if (mHideActionOnSuccess) {
1355                      Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG)
1356                              .show();
1357                  } else {
1358                      Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG)
1359                              .setAction(
1360                                  R.string.undo,
1361                                  new View.OnClickListener() {
1362                                      @Override
1363                                      public void onClick(View v) {
1364                                          mHideActionOnSuccess = true;
1365                                          publishNote();
1366                                      }
1367                                  }
1368                              )
1369                              .show();
1370                  }
1371              }
1372          } else {
1373              if (mNote.isPublished()) {
1374                  Snackbar.make(mRootView, R.string.unpublish_error, Snackbar.LENGTH_LONG)
1375                          .setAction(
1376                              R.string.retry,
1377                              new View.OnClickListener() {
1378                                  @Override
1379                                  public void onClick(View v) {
1380                                      mHideActionOnSuccess = true;
1381                                      unpublishNote();
1382                                  }
1383                              }
1384                          ).show();
1385              } else {
1386                  Snackbar.make(mRootView, R.string.publish_error, Snackbar.LENGTH_LONG)
1387                          .setAction(
1388                              R.string.retry,
1389                              new View.OnClickListener() {
1390                                  @Override
1391                                  public void onClick(View v) {
1392                                      mHideActionOnSuccess = true;
1393                                      publishNote();
1394                                  }
1395                              }
1396                          ).show();
1397              }
1398          }
1399  
1400          mHideActionOnSuccess = false;
1401          requireActivity().invalidateOptionsMenu();
1402      }
1403  
1404      private void publishNote() {
1405          if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1406              Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1407              return;
1408          }
1409  
1410          if (isAdded()) {
1411              mPublishingSnackbar = Snackbar.make(mRootView, R.string.publishing, Snackbar.LENGTH_INDEFINITE);
1412              mPublishingSnackbar.show();
1413          }
1414  
1415          setPublishedNote(true);
1416      }
1417  
1418      private void unpublishNote() {
1419          if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1420              Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1421              return;
1422          }
1423  
1424          if (isAdded()) {
1425              mPublishingSnackbar = Snackbar.make(mRootView, R.string.unpublishing, Snackbar.LENGTH_INDEFINITE);
1426              mPublishingSnackbar.show();
1427          }
1428  
1429          setPublishedNote(false);
1430      }
1431  
1432      private void showShare(String text) {
1433          startActivity(
1434              ShareCompat.IntentBuilder.from(requireActivity())
1435                  .setText(text)
1436                  .setType(&quot;text/plain&quot;)
1437                  .createChooserIntent()
1438          );
1439      }
1440      private void showShareSheet() {
1441          if (isAdded() &amp;&amp; mShareBottomSheet != null &amp;&amp; !mShareBottomSheet.isAdded()) {
1442              mShareBottomSheet.show(requireFragmentManager(), mNote);
1443          }
1444      }
1445  
1446      private void showInfoSheet() {
1447          if (isAdded() &amp;&amp; mInfoBottomSheet != null &amp;&amp; !mInfoBottomSheet.isAdded()) {
1448              mInfoBottomSheet.show(requireFragmentManager(), mNote);
1449          }
1450      }
1451  
1452      private void showHistorySheet() {
1453          if (isAdded() &amp;&amp; mHistoryBottomSheet != null &amp;&amp; !mHistoryBottomSheet.isAdded()) {
1454              // Request revisions for the current note
1455              mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbacks());
1456              saveNote();
1457  
1458              mHistoryBottomSheet.show(requireFragmentManager(), mNote);
1459          }
1460      }
1461  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1462 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1463 -     * Simperium listeners</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1464 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1465 -</span>
1466      @Override
1467      public void onDeleteObject(Bucket&lt;Note&gt; noteBucket, Note note) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1468 -</span>
1469      }
1470  
1471      @Override
1472      public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) {
1473          if (changeType == Bucket.ChangeType.MODIFY) {
1474              if (getNote() != null &amp;&amp; getNote().getSimperiumKey().equals(key)) {
1475                  try {
1476                      mNotesBucket = noteBucket;
1477                      final Note updatedNote = mNotesBucket.get(key);
1478                      if (getActivity() != null) {
1479                          getActivity().runOnUiThread(new Runnable() {
1480                              @Override
1481                              public void run() {
1482                                  if (mPublishTimeoutHandler != null) {
1483                                      mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
1484                                  }
1485  
1486                                  updateNote(updatedNote);
1487                                  updatePublishedState(true);
1488                              }
1489                          });
1490                      }
1491                  } catch (BucketObjectMissingException e) {
1492                      e.printStackTrace();
1493                  }
1494              }
1495          }
1496      }
1497  
1498      @Override
1499      public void onSaveObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1500          if (mIsPaused) {
1501              mNotesBucket.removeListener(this);
1502              mNotesBucket.stop();
1503              AppLog.add(Type.SYNC, &quot;Stopped note bucket (NoteEditorFragment)&quot;);
1504          }
1505  
1506          AppLog.add(
1507              Type.SYNC,
1508              &quot;Saved note callback in NoteEditorFragment (ID: &quot; + note.getSimperiumKey() +
1509                  &quot; / Title: &quot; + note.getTitle() +
1510                  &quot; / Characters: &quot; + NoteUtils.getCharactersCount(note.getContent()) +
1511                  &quot; / Words: &quot; + NoteUtils.getWordCount(note.getContent()) + &quot;)&quot;
1512          );
1513      }
1514  
1515      @Override
1516      public void onBeforeUpdateObject(Bucket&lt;Note&gt; bucket, Note note) {
1517          // Don&#x27;t apply updates if we haven&#x27;t loaded the note yet
1518          if (mIsLoadingNote)
1519              return;
1520  
1521          Note openNote = getNote();
1522          if (openNote == null || !openNote.getSimperiumKey().equals(note.getSimperiumKey()))
1523              return;
1524  
1525          note.setContent(mContentEditText.getPlainTextContent());
1526      }
1527  
1528      private static class LoadNoteTask extends AsyncTask&lt;String, Void, Void&gt; {
1529          WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1530  
1531          LoadNoteTask(NoteEditorFragment fragment) {
1532              mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1533          }
1534  
1535          @Override
1536          protected void onPreExecute() {
1537              NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1538  
1539              if (fragment != null) {
1540                  fragment.mContentEditText.removeTextChangedListener(fragment);
1541                  fragment.mIsLoadingNote = true;
1542              }
1543          }
1544  
1545          @Override
1546          protected Void doInBackground(String... args) {
1547              NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1548  
1549              if (fragment == null || fragment.getActivity() == null) {
1550                  return null;
1551              }
1552  
1553              String noteID = args[0];
1554              Simplenote application = (Simplenote) fragment.getActivity().getApplication();
1555              Bucket&lt;Note&gt; notesBucket = application.getNotesBucket();
1556  
1557              try {
1558                  fragment.mNote = notesBucket.get(noteID);
1559  
1560                  // Set the current note in NotesActivity when on a tablet
1561                  if (fragment.getActivity() instanceof NotesActivity) {
1562                      ((NotesActivity) fragment.getActivity()).setCurrentNote(fragment.mNote);
1563                  }
1564  
1565                  // Set markdown and preview flags for current note
1566                  if (fragment.mNote != null) {
1567                      fragment.mIsMarkdownEnabled = fragment.mNote.isMarkdownEnabled();
1568                      fragment.mIsPreviewEnabled = fragment.mNote.isPreviewEnabled();
1569                      AppLog.add(
1570                          Type.SYNC,
1571                          &quot;Loaded note (ID: &quot; + fragment.mNote.getSimperiumKey() +
1572                              &quot; / Title: &quot; + fragment.mNote.getTitle() +
1573                              &quot; / Characters: &quot; + NoteUtils.getCharactersCount(fragment.mNote.getContent()) +
1574                              &quot; / Words: &quot; + NoteUtils.getWordCount(fragment.mNote.getContent()) + &quot;)&quot;
1575                      );
1576                  }
1577              } catch (BucketObjectMissingException e) {
1578                  // See if the note is in the object store
1579                  Bucket.ObjectCursor&lt;Note&gt; notesCursor = notesBucket.allObjects();
1580  
1581                  while (notesCursor.moveToNext()) {
1582                      Note currentNote = notesCursor.getObject();
1583  
1584                      if (currentNote != null &amp;&amp; currentNote.getSimperiumKey().equals(noteID)) {
1585                          fragment.mNote = currentNote;
1586                          return null;
1587                      }
1588                  }
1589              }
1590  
1591              return null;
1592          }
1593  
1594          @Override
1595          protected void onPostExecute(Void nada) {
1596              final NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1597              if (fragment == null || fragment.getActivity() == null || fragment.getActivity().isFinishing()) {
1598                  return;
1599              }
1600  
1601              fragment.refreshContent(false);
1602  
1603              if (fragment.mMatchOffsets != null) {
<abbr title="1604                  int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.CONTENT_PROPERTY);">1604                  int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.COðŸ”µ</abbr>
1605                  fragment.mHighlighter.highlightMatches(fragment.mMatchOffsets, columnIndex);
1606                  fragment.mShouldScrollToSearchMatch = true;
1607              }
1608  
1609              fragment.mContentEditText.addTextChangedListener(fragment);
1610  
1611              if (fragment.mNote != null &amp;&amp; fragment.mNote.getContent().isEmpty()) {
1612                  // Show soft keyboard
1613                  fragment.mContentEditText.requestFocus();
1614  
1615                  new Handler().postDelayed(new Runnable() {
1616                      @Override
1617                      public void run() {
1618                          if (fragment.getActivity() == null) {
1619                              return;
1620                          }
1621  
<abbr title="1622                          InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);">1622                          InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivity().getSysðŸ”µ</abbr>
1623  
1624                          if (inputMethodManager != null) {
1625                              inputMethodManager.showSoftInput(fragment.mContentEditText, 0);
1626                          }
1627                      }
1628                  }, 100);
1629              } else if (fragment.mNote != null) {
1630                  // If we have a valid note, hide the placeholder
1631                  fragment.setPlaceholderVisible(false);
1632              }
1633  
1634              fragment.updateMarkdownView();
1635              fragment.requireActivity().invalidateOptionsMenu();
1636              fragment.linkifyEditorContent();
1637              fragment.mIsLoadingNote = false;
1638          }
1639      }
1640  
1641      private static class SaveNoteTask extends AsyncTask&lt;Void, Void, Void&gt; {
1642          WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1643  
1644          SaveNoteTask(NoteEditorFragment fragment) {
1645              mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1646          }
1647  
1648          @Override
1649          protected Void doInBackground(Void... args) {
1650              NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1651  
1652              if (fragment != null) {
1653                  fragment.saveNote();
1654              }
1655  
1656              return null;
1657          }
1658  
1659          @Override
1660          protected void onPostExecute(Void nada) {
1661              NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1662  
1663              if (fragment != null &amp;&amp; fragment.getActivity() != null &amp;&amp; !fragment.getActivity().isFinishing()) {
1664                  // Update links
1665                  fragment.linkifyEditorContent();
1666                  fragment.updateMarkdownView();
1667              }
1668          }
1669      }
1670  
1671      private void linkifyEditorContent() {
1672          if (getActivity() == null || getActivity().isFinishing()) {
1673              return;
1674          }
1675  
1676          if (PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_DETECT_LINKS)) {
1677              SimplenoteLinkify.addLinks(mContentEditText, Linkify.ALL);
1678          }
1679      }
1680  
1681      // Show tabs if markdown is enabled globally, for current note, and not tablet landscape
1682      private void updateMarkdownView() {
1683          if (!mIsMarkdownEnabled) {
1684              return;
1685          }
1686  
1687          Activity activity = getActivity();
1688          if (activity instanceof NotesActivity) {
1689              // This fragment lives in NotesActivity, so load markdown in this fragment&#x27;s WebView.
1690              loadMarkdownData();
1691          } else {
1692              // This fragment lives in the NoteEditorActivity&#x27;s ViewPager.
1693              if (mNoteMarkdownFragment == null) {
1694                  mNoteMarkdownFragment = ((NoteEditorActivity) requireActivity())
1695                          .getNoteMarkdownFragment();
1696                  ((NoteEditorActivity) requireActivity()).showTabs();
1697              }
1698              // Load markdown in the sibling NoteMarkdownFragment&#x27;s WebView.
1699              mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPreviewTextContent());
1700          }
1701      }
1702  
1703      private ColorStateList getChipBackgroundColor() {
1704          int[][] states = new int[][] {
1705              new int[] { android.R.attr.state_checked}, // checked
1706              new int[] {-android.R.attr.state_checked}  // unchecked
1707          };
1708  
1709          int[] colors = new int[] {
1710              ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOnBackgroundColor),
1711              ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOffBackgroundColor)
1712          };
1713  
1714          return new ColorStateList(states, colors);
1715      }
1716  
1717      private void setChips(CharSequence text) {
1718          mTagPadding.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1719          mTagChips.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1720          mTagChips.setSingleSelection(true);
1721          mTagChips.removeAllViews();
1722          SimpleStringSplitter tags = new SimpleStringSplitter(SPACE);
1723          tags.setString(text.toString());
1724  
1725          for (String tag : tags) {
1726              final Chip chip = new Chip(requireContext());
1727              chip.setText(tag);
1728              chip.setCheckable(true);
1729              chip.setCheckedIcon(null);
1730              chip.setChipBackgroundColor(getChipBackgroundColor());
1731              chip.setTextColor(ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipTextColor));
1732              chip.setStateListAnimator(null);
1733              chip.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
1734                  @Override
1735                  public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
1736                      chip.setCloseIconVisible(isChecked);
1737                  }
1738              });
1739              chip.setOnCloseIconClickListener(new View.OnClickListener() {
1740                  @Override
1741                  public void onClick(View view) {
1742                      mTagChips.removeView(view);
1743                      updateTags();
1744                      AnalyticsTracker.track(
1745                          EDITOR_TAG_REMOVED,
1746                          CATEGORY_NOTE,
1747                          &quot;tag_removed_from_note&quot;
1748                      );
1749                  }
1750              });
1751              mTagChips.addView(chip);
1752          }
1753      }
1754  
1755      private void updateTags() {
1756          if (mNote == null) {
1757              return;
1758          }
1759  
1760          mNote.setTagString(getNoteTagsString());
1761          mNote.setModificationDate(Calendar.getInstance());
1762          updateTagList();
1763          mNote.save();
1764      }
1765  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            