<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>89 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*-\n&#x27;
                           &#x27; * #%L\n&#x27;
                           &#x27; * BroadleafCommerce Common Libraries\n&#x27;
                           &#x27; * %%\n&#x27;
                           &#x27; * Copyright (C) 2009 - 2024 Broadleaf Commerce\n&#x27;
                           &#x27; * %%\n&#x27;
                           &#x27; * Licensed under the Broadleaf Fair Use License &#x27;
                           &#x27;Agreement, Version 1.0\n&#x27;
                           &#x27; * (the &quot;Fair Use License&quot; located  at &#x27;
                           &#x27;http://license.broadleafcommerce.org/fair_use_license-1.0.txt)\n&#x27;
                           &#x27; * unless the restrictions on use therein are &#x27;
                           &#x27;violated and require payment to Broadleaf in which &#x27;
                           &#x27;case\n&#x27;
                           &#x27; * the Broadleaf End User License Agreement &#x27;
                           &#x27;(EULA), Version 1.1\n&#x27;
                           &#x27; * (the &quot;Commercial License&quot; located at &#x27;
                           &#x27;http://license.broadleafcommerce.org/commercial_license-1.1.txt)\n&#x27;
                           &#x27; * shall apply.\n&#x27;
                           &#x27; * \n&#x27;
                           &#x27; * Alternatively, the Commercial License may be &#x27;
                           &#x27;replaced with a mutually agreed upon license (the &#x27;
                           &#x27;&quot;Custom License&quot;)\n&#x27;
                           &#x27; * between you and Broadleaf Commerce. You may not &#x27;
                           &#x27;use this file except in compliance with the &#x27;
                           &#x27;applicable license.\n&#x27;
                           &#x27; * #L%\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;package &#x27;
                           &#x27;org.broadleafcommerce.common.cache.engine;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import org.apache.commons.logging.Log;\n&#x27;
                           &#x27;import org.apache.commons.logging.LogFactory;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.io.Serializable;\n&#x27;
                           &#x27;import java.lang.reflect.Method;\n&#x27;
                           &#x27;import java.util.Hashtable;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import net.sf.ehcache.CacheException;\n&#x27;
                           &#x27;import net.sf.ehcache.Ehcache;\n&#x27;
                           &#x27;import net.sf.ehcache.Element;\n&#x27;
                           &#x27;import net.sf.ehcache.event.CacheEventListener;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * \n&#x27;
                           &#x27; * @author jfischer\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;@Deprecated\n&#x27;
                           &#x27;public class HydratedCacheManagerImpl implements &#x27;
                           &#x27;CacheEventListener, HydratedCacheManager, &#x27;
                           &#x27;HydratedAnnotationManager {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final Log LOG = &#x27;
                           &#x27;LogFactory.getLog(HydratedCacheManagerImpl.class);\n&#x27;
                           &#x27;    private static final HydratedCacheManagerImpl &#x27;
                           &#x27;MANAGER = new HydratedCacheManagerImpl();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public static HydratedCacheManagerImpl &#x27;
                           &#x27;getInstance() {\n&#x27;
                           &#x27;        return MANAGER;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private HydratedCacheManagerImpl()  {}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private Map&lt;String, HydratedCache&gt; &#x27;
                           &#x27;hydratedCacheContainer = new Hashtable&lt;String, &#x27;
                           &#x27;HydratedCache&gt;(100);\n&#x27;
                           &#x27;    private Map&lt;String, HydrationDescriptor&gt; &#x27;
                           &#x27;hydrationDescriptors = new Hashtable&lt;String, &#x27;
                           &#x27;HydrationDescriptor&gt;(100);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void addHydratedCache(final &#x27;
                           &#x27;HydratedCache cache) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;hydratedCacheContainer.put(cache.getCacheRegion() &#x27;
                           &#x27;+ &quot;_&quot; + cache.getCacheName(), cache);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public HydratedCache removeHydratedCache(final &#x27;
                           &#x27;String cacheRegion, final String cacheName) {\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;hydratedCacheContainer.remove(cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public  HydratedCache getHydratedCache(final &#x27;
                           &#x27;String cacheRegion, final String cacheName) {\n&#x27;
                           &#x27;        if (!containsCache(cacheRegion, &#x27;
                           &#x27;cacheName)) {\n&#x27;
                           &#x27;            HydratedCache cache = new &#x27;
                           &#x27;HydratedCache(cacheRegion, cacheName);\n&#x27;
                           &#x27;            addHydratedCache(cache);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;hydratedCacheContainer.get(cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    \n&#x27;
                           &#x27;    public boolean containsCache(String &#x27;
                           &#x27;cacheRegion, String cacheName) {\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;hydratedCacheContainer.containsKey(cacheRegion + &#x27;
                           &#x27;&quot;_&quot; + cacheName);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    \n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public HydrationDescriptor &#x27;
                           &#x27;getHydrationDescriptor(Object entity) {\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(hydrationDescriptors.containsKey(entity.getClass().getName())) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;hydrationDescriptors.get(entity.getClass().getName());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        HydrationDescriptor descriptor = new &#x27;
                           &#x27;HydrationDescriptor();\n&#x27;
                           &#x27;        Class&lt;?&gt; topEntityClass = &#x27;
                           &#x27;getTopEntityClass(entity);\n&#x27;
                           &#x27;        HydrationScanner scanner = new &#x27;
                           &#x27;HydrationScanner(topEntityClass, &#x27;
                           &#x27;entity.getClass());\n&#x27;
                           &#x27;        scanner.init();\n&#x27;
                           &#x27;        &#x27;
                           &#x27;descriptor.setHydratedMutators(scanner.getCacheMutators());\n&#x27;
                           &#x27;        Map&lt;String, Method[]&gt; mutators = &#x27;
                           &#x27;scanner.getIdMutators();\n&#x27;
                           &#x27;        if (mutators.size() != 1) {\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;Broadleaf &#x27;
                           &#x27;Commerce Hydrated Cache currently only supports &#x27;
                           &#x27;entities with a single @Id annotation.&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        Method[] singleMutators = &#x27;
                           &#x27;mutators.values().iterator().next();\n&#x27;
                           &#x27;        descriptor.setIdMutators(singleMutators);\n&#x27;
                           &#x27;        String cacheRegion = &#x27;
                           &#x27;scanner.getCacheRegion();\n&#x27;
                           &#x27;        if (cacheRegion == null || &#x27;
                           &#x27;&quot;&quot;.equals(cacheRegion)) {\n&#x27;
                           &#x27;            cacheRegion = &#x27;
                           &#x27;topEntityClass.getName();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        descriptor.setCacheRegion(cacheRegion);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;hydrationDescriptors.put(entity.getClass().getName(), &#x27;
                           &#x27;descriptor);\n&#x27;
                           &#x27;        return descriptor;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    \n&#x27;
                           &#x27;    public Class&lt;?&gt; getTopEntityClass(Object &#x27;
                           &#x27;entity) {\n&#x27;
                           &#x27;        Class&lt;?&gt; myClass = entity.getClass();\n&#x27;
                           &#x27;        Class&lt;?&gt; superClass = &#x27;
                           &#x27;entity.getClass().getSuperclass();\n&#x27;
                           &#x27;        while (superClass != null &amp;&amp; &#x27;
                           &#x27;superClass.getName().startsWith(&quot;org.broadleaf&quot;)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            myClass = superClass;\n&#x27;
                           &#x27;            superClass = &#x27;
                           &#x27;superClass.getSuperclass();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return myClass;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    \n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public Object &#x27;
                           &#x27;getHydratedCacheElementItem(String cacheRegion, &#x27;
                           &#x27;String cacheName, Serializable elementKey, String &#x27;
                           &#x27;elementItemName) {\n&#x27;
                           &#x27;        Object response = null;\n&#x27;
                           &#x27;        HydratedCache hydratedCache = &#x27;
                           &#x27;getHydratedCache(cacheRegion, cacheName);\n&#x27;
                           &#x27;        HydratedCacheElement element = &#x27;
                           &#x27;hydratedCache.getCacheElement(cacheRegion, &#x27;
                           &#x27;cacheName, elementKey);\n&#x27;
                           &#x27;        if (element != null) {\n&#x27;
                           &#x27;            response = &#x27;
                           &#x27;element.getCacheElementItem(elementItemName, &#x27;
                           &#x27;elementKey);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return response;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    \n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void addHydratedCacheElementItem(String &#x27;
                           &#x27;cacheRegion, String cacheName, Serializable &#x27;
                           &#x27;elementKey, String elementItemName, Object &#x27;
                           &#x27;elementValue) {\n&#x27;
                           &#x27;        HydratedCache hydratedCache = &#x27;
                           &#x27;getHydratedCache(cacheRegion, cacheName);\n&#x27;
                           &#x27;        HydratedCacheElement element = &#x27;
                           &#x27;hydratedCache.getCacheElement(cacheRegion, &#x27;
                           &#x27;cacheName, elementKey);\n&#x27;
                           &#x27;        if (element == null) {\n&#x27;
                           &#x27;            element = new HydratedCacheElement();\n&#x27;
                           &#x27;            &#x27;
                           &#x27;hydratedCache.addCacheElement(cacheRegion, &#x27;
                           &#x27;cacheName, elementKey, element);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        &#x27;
                           &#x27;element.putCacheElementItem(elementItemName, &#x27;
                           &#x27;elementKey, elementValue);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void dispose() {\n&#x27;
                           &#x27;        if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;            LOG.info(&quot;Disposing of all hydrated &#x27;
                           &#x27;cache members&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        hydratedCacheContainer.clear();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void removeCache(String cacheRegion, &#x27;
                           &#x27;Serializable key) {\n&#x27;
                           &#x27;        String cacheName = cacheRegion;\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(key.getClass().getName().equals(&quot;org.hibernate.cache.internal.CacheKeyImplementation&quot;)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            // Since CacheKeyImplementation is a &#x27;
                           &quot;protected Class we can&#x27;t cast it nor can we access &quot;
                           &#x27;the entityOrRoleName property\n&#x27;
                           &#x27;            // therefore, to match how this worked &#x27;
                           &#x27;in pre Hibernate 5, we split the toString since &#x27;
                           &quot;it&#x27;s comprised of the fields we need\n&quot;
                           &#x27;            String[] keyPieces = &#x27;
                           &#x27;key.toString().split(&quot;#&quot;);\n&#x27;
                           &#x27;            cacheName = keyPieces[0];\n&#x27;
                           &#x27;            key = keyPieces[1];\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (containsCache(cacheRegion, cacheName)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            HydratedCache cache = &#x27;
                           &#x27;hydratedCacheContainer.get(cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName);\n&#x27;
                           &#x27;            String myKey = cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName + &quot;_&quot; + key;\n&#x27;
                           &#x27;            if (cache.containsKey(myKey)) {\n&#x27;
                           &#x27;                if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;                    LOG.info(&quot;Clearing hydrated &#x27;
                           &#x27;cache for cache name: &quot; + cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName + &quot;_&quot; + key);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                &#x27;
                           &#x27;cache.removeCacheElement(cacheRegion, cacheName, &#x27;
                           &#x27;key);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    \n&#x27;
                           &#x27;    private void removeAll(String cacheName) {\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(hydratedCacheContainer.containsKey(cacheName)) {\n&#x27;
                           &#x27;            if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;                LOG.info(&quot;Clearing all hydrated &#x27;
                           &#x27;caches for cache name: &quot; + cacheName);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            &#x27;
                           &#x27;hydratedCacheContainer.remove(cacheName);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementEvicted(Ehcache arg0, &#x27;
                           &#x27;Element arg1) {\n&#x27;
                           &#x27;        removeCache(arg0.getName(), &#x27;
                           &#x27;arg1.getKey());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementExpired(Ehcache arg0, &#x27;
                           &#x27;Element arg1) {\n&#x27;
                           &#x27;        removeCache(arg0.getName(), &#x27;
                           &#x27;arg1.getKey());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementPut(Ehcache arg0, &#x27;
                           &#x27;Element arg1) throws CacheException {\n&#x27;
                           &#x27;        //do nothing\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementRemoved(Ehcache arg0, &#x27;
                           &#x27;Element arg1) throws CacheException {\n&#x27;
                           &#x27;        removeCache(arg0.getName(), &#x27;
                           &#x27;arg1.getKey());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementUpdated(Ehcache arg0, &#x27;
                           &#x27;Element arg1) throws CacheException {\n&#x27;
                           &#x27;        removeCache(arg0.getName(), &#x27;
                           &#x27;arg1.getKey());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyRemoveAll(Ehcache arg0) {\n&#x27;
                           &#x27;        removeAll(arg0.getName());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public Object clone() throws &#x27;
                           &#x27;CloneNotSupportedException {\n&#x27;
                           &#x27;        return this;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*-\n&#x27;
                           &#x27; * #%L\n&#x27;
                           &#x27; * BroadleafCommerce Common Libraries\n&#x27;
                           &#x27; * %%\n&#x27;
                           &#x27; * Copyright (C) 2009 - 2024 Broadleaf Commerce\n&#x27;
                           &#x27; * %%\n&#x27;
                           &#x27; * Licensed under the Broadleaf Fair Use License &#x27;
                           &#x27;Agreement, Version 1.0\n&#x27;
                           &#x27; * (the &quot;Fair Use License&quot; located  at &#x27;
                           &#x27;http://license.broadleafcommerce.org/fair_use_license-1.0.txt)\n&#x27;
                           &#x27; * unless the restrictions on use therein are &#x27;
                           &#x27;violated and require payment to Broadleaf in which &#x27;
                           &#x27;case\n&#x27;
                           &#x27; * the Broadleaf End User License Agreement &#x27;
                           &#x27;(EULA), Version 1.1\n&#x27;
                           &#x27; * (the &quot;Commercial License&quot; located at &#x27;
                           &#x27;http://license.broadleafcommerce.org/commercial_license-1.1.txt)\n&#x27;
                           &#x27; * shall apply.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Alternatively, the Commercial License may be &#x27;
                           &#x27;replaced with a mutually agreed upon license (the &#x27;
                           &#x27;&quot;Custom License&quot;)\n&#x27;
                           &#x27; * between you and Broadleaf Commerce. You may not &#x27;
                           &#x27;use this file except in compliance with the &#x27;
                           &#x27;applicable license.\n&#x27;
                           &#x27; * #L%\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;package &#x27;
                           &#x27;org.broadleafcommerce.common.cache.engine;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import org.apache.commons.logging.Log;\n&#x27;
                           &#x27;import org.apache.commons.logging.LogFactory;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.io.Serializable;\n&#x27;
                           &#x27;import java.lang.reflect.Method;\n&#x27;
                           &#x27;import java.util.Hashtable;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import net.sf.ehcache.CacheException;\n&#x27;
                           &#x27;import net.sf.ehcache.Ehcache;\n&#x27;
                           &#x27;import net.sf.ehcache.Element;\n&#x27;
                           &#x27;import net.sf.ehcache.event.CacheEventListener;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * @author jfischer\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;@Deprecated\n&#x27;
                           &#x27;public class HydratedCacheManagerImpl implements &#x27;
                           &#x27;CacheEventListener, HydratedCacheManager, &#x27;
                           &#x27;HydratedAnnotationManager {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final Log LOG = &#x27;
                           &#x27;LogFactory.getLog(HydratedCacheManagerImpl.class);\n&#x27;
                           &#x27;    private static final HydratedCacheManagerImpl &#x27;
                           &#x27;MANAGER = new HydratedCacheManagerImpl();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public static HydratedCacheManagerImpl &#x27;
                           &#x27;getInstance() {\n&#x27;
                           &#x27;        return MANAGER;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private HydratedCacheManagerImpl()  {}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private Map&lt;String, HydratedCache&gt; &#x27;
                           &#x27;hydratedCacheContainer = new Hashtable&lt;String, &#x27;
                           &#x27;HydratedCache&gt;(100);\n&#x27;
                           &#x27;    private Map&lt;String, HydrationDescriptor&gt; &#x27;
                           &#x27;hydrationDescriptors = new Hashtable&lt;String, &#x27;
                           &#x27;HydrationDescriptor&gt;(100);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void addHydratedCache(final &#x27;
                           &#x27;HydratedCache cache) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;hydratedCacheContainer.put(cache.getCacheRegion() &#x27;
                           &#x27;+ &quot;_&quot; + cache.getCacheName(), cache);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public HydratedCache removeHydratedCache(final &#x27;
                           &#x27;String cacheRegion, final String cacheName) {\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;hydratedCacheContainer.remove(cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public  HydratedCache getHydratedCache(final &#x27;
                           &#x27;String cacheRegion, final String cacheName) {\n&#x27;
                           &#x27;        if (!containsCache(cacheRegion, &#x27;
                           &#x27;cacheName)) {\n&#x27;
                           &#x27;            HydratedCache cache = new &#x27;
                           &#x27;HydratedCache(cacheRegion, cacheName);\n&#x27;
                           &#x27;            addHydratedCache(cache);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;hydratedCacheContainer.get(cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public boolean containsCache(String &#x27;
                           &#x27;cacheRegion, String cacheName) {\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;hydratedCacheContainer.containsKey(cacheRegion + &#x27;
                           &#x27;&quot;_&quot; + cacheName);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public HydrationDescriptor &#x27;
                           &#x27;getHydrationDescriptor(Object entity) {\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(hydrationDescriptors.containsKey(entity.getClass().getName())) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;hydrationDescriptors.get(entity.getClass().getName());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        HydrationDescriptor descriptor = new &#x27;
                           &#x27;HydrationDescriptor();\n&#x27;
                           &#x27;        Class&lt;?&gt; topEntityClass = &#x27;
                           &#x27;getTopEntityClass(entity);\n&#x27;
                           &#x27;        HydrationScanner scanner = new &#x27;
                           &#x27;HydrationScanner(topEntityClass, &#x27;
                           &#x27;entity.getClass());\n&#x27;
                           &#x27;        scanner.init();\n&#x27;
                           &#x27;        &#x27;
                           &#x27;descriptor.setHydratedMutators(scanner.getCacheMutators());\n&#x27;
                           &#x27;        Map&lt;String, Method[]&gt; mutators = &#x27;
                           &#x27;scanner.getIdMutators();\n&#x27;
                           &#x27;        if (mutators.size() != 1) {\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;Broadleaf &#x27;
                           &#x27;Commerce Hydrated Cache currently only supports &#x27;
                           &#x27;entities with a single @Id annotation.&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        Method[] singleMutators = &#x27;
                           &#x27;mutators.values().iterator().next();\n&#x27;
                           &#x27;        descriptor.setIdMutators(singleMutators);\n&#x27;
                           &#x27;        String cacheRegion = &#x27;
                           &#x27;scanner.getCacheRegion();\n&#x27;
                           &#x27;        if (cacheRegion == null || &#x27;
                           &#x27;&quot;&quot;.equals(cacheRegion)) {\n&#x27;
                           &#x27;            cacheRegion = &#x27;
                           &#x27;topEntityClass.getName();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        descriptor.setCacheRegion(cacheRegion);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;hydrationDescriptors.put(entity.getClass().getName(), &#x27;
                           &#x27;descriptor);\n&#x27;
                           &#x27;        return descriptor;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public Class&lt;?&gt; getTopEntityClass(Object &#x27;
                           &#x27;entity) {\n&#x27;
                           &#x27;        Class&lt;?&gt; myClass = entity.getClass();\n&#x27;
                           &#x27;        Class&lt;?&gt; superClass = &#x27;
                           &#x27;entity.getClass().getSuperclass();\n&#x27;
                           &#x27;        while (superClass != null &amp;&amp; &#x27;
                           &#x27;superClass.getName().startsWith(&quot;org.broadleaf&quot;)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            myClass = superClass;\n&#x27;
                           &#x27;            superClass = &#x27;
                           &#x27;superClass.getSuperclass();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return myClass;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public Object &#x27;
                           &#x27;getHydratedCacheElementItem(String cacheRegion, &#x27;
                           &#x27;String cacheName, Serializable elementKey, String &#x27;
                           &#x27;elementItemName) {\n&#x27;
                           &#x27;        Object response = null;\n&#x27;
                           &#x27;        HydratedCache hydratedCache = &#x27;
                           &#x27;getHydratedCache(cacheRegion, cacheName);\n&#x27;
                           &#x27;        HydratedCacheElement element = &#x27;
                           &#x27;hydratedCache.getCacheElement(cacheRegion, &#x27;
                           &#x27;cacheName, elementKey);\n&#x27;
                           &#x27;        if (element != null) {\n&#x27;
                           &#x27;            response = &#x27;
                           &#x27;element.getCacheElementItem(elementItemName, &#x27;
                           &#x27;elementKey);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return response;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void addHydratedCacheElementItem(String &#x27;
                           &#x27;cacheRegion, String cacheName, Serializable &#x27;
                           &#x27;elementKey, String elementItemName, Object &#x27;
                           &#x27;elementValue) {\n&#x27;
                           &#x27;        HydratedCache hydratedCache = &#x27;
                           &#x27;getHydratedCache(cacheRegion, cacheName);\n&#x27;
                           &#x27;        HydratedCacheElement element = &#x27;
                           &#x27;hydratedCache.getCacheElement(cacheRegion, &#x27;
                           &#x27;cacheName, elementKey);\n&#x27;
                           &#x27;        if (element == null) {\n&#x27;
                           &#x27;            element = new HydratedCacheElement();\n&#x27;
                           &#x27;            &#x27;
                           &#x27;hydratedCache.addCacheElement(cacheRegion, &#x27;
                           &#x27;cacheName, elementKey, element);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        &#x27;
                           &#x27;element.putCacheElementItem(elementItemName, &#x27;
                           &#x27;elementKey, elementValue);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void dispose() {\n&#x27;
                           &#x27;        if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;            LOG.info(&quot;Disposing of all hydrated &#x27;
                           &#x27;cache members&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        hydratedCacheContainer.clear();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void removeCache(String cacheRegion, &#x27;
                           &#x27;Serializable key) {\n&#x27;
                           &#x27;        String cacheName = cacheRegion;\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(key.getClass().getName().equals(&quot;org.hibernate.cache.internal.CacheKeyImplementation&quot;)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            // Since CacheKeyImplementation is a &#x27;
                           &quot;protected Class we can&#x27;t cast it nor can we access &quot;
                           &#x27;the entityOrRoleName property\n&#x27;
                           &#x27;            // therefore, to match how this worked &#x27;
                           &#x27;in pre Hibernate 5, we split the toString since &#x27;
                           &quot;it&#x27;s comprised of the fields we need\n&quot;
                           &#x27;            String[] keyPieces = &#x27;
                           &#x27;key.toString().split(&quot;#&quot;);\n&#x27;
                           &#x27;            cacheName = keyPieces[0];\n&#x27;
                           &#x27;            key = keyPieces[1];\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (containsCache(cacheRegion, cacheName)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            HydratedCache cache = &#x27;
                           &#x27;hydratedCacheContainer.get(cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName);\n&#x27;
                           &#x27;            String myKey = cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName + &quot;_&quot; + key;\n&#x27;
                           &#x27;            if (cache.containsKey(myKey)) {\n&#x27;
                           &#x27;                if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;                    LOG.info(&quot;Clearing hydrated &#x27;
                           &#x27;cache for cache name: &quot; + cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName + &quot;_&quot; + key);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                &#x27;
                           &#x27;cache.removeCacheElement(cacheRegion, cacheName, &#x27;
                           &#x27;key);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void removeAll(String cacheName) {\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(hydratedCacheContainer.containsKey(cacheName)) {\n&#x27;
                           &#x27;            if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;                LOG.info(&quot;Clearing all hydrated &#x27;
                           &#x27;caches for cache name: &quot; + cacheName);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            &#x27;
                           &#x27;hydratedCacheContainer.remove(cacheName);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementEvicted(Ehcache arg0, &#x27;
                           &#x27;Element arg1) {\n&#x27;
                           &#x27;        removeCache(arg0.getName(), &#x27;
                           &#x27;arg1.getKey());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementExpired(Ehcache arg0, &#x27;
                           &#x27;Element arg1) {\n&#x27;
                           &#x27;        removeCache(arg0.getName(), &#x27;
                           &#x27;arg1.getKey());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementPut(Ehcache arg0, &#x27;
                           &#x27;Element arg1) throws CacheException {\n&#x27;
                           &#x27;        //do nothing\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementRemoved(Ehcache arg0, &#x27;
                           &#x27;Element arg1) throws CacheException {\n&#x27;
                           &#x27;        removeCache(arg0.getName(), &#x27;
                           &#x27;arg1.getKey());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementUpdated(Ehcache arg0, &#x27;
                           &#x27;Element arg1) throws CacheException {\n&#x27;
                           &#x27;        removeCache(arg0.getName(), &#x27;
                           &#x27;arg1.getKey());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyRemoveAll(Ehcache arg0) {\n&#x27;
                           &#x27;        removeAll(arg0.getName());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public Object clone() throws &#x27;
                           &#x27;CloneNotSupportedException {\n&#x27;
                           &#x27;        return this;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;/*-\n&#x27;
                           &#x27; * #%L\n&#x27;
                           &#x27; * BroadleafCommerce Common Libraries\n&#x27;
                           &#x27; * %%\n&#x27;
                           &#x27; * Copyright (C) 2009 - 2024 Broadleaf Commerce\n&#x27;
                           &#x27; * %%\n&#x27;
                           &#x27; * Licensed under the Broadleaf Fair Use License &#x27;
                           &#x27;Agreement, Version 1.0\n&#x27;
                           &#x27; * (the &quot;Fair Use License&quot; located  at &#x27;
                           &#x27;http://license.broadleafcommerce.org/fair_use_license-1.0.txt)\n&#x27;
                           &#x27; * unless the restrictions on use therein are &#x27;
                           &#x27;violated and require payment to Broadleaf in which &#x27;
                           &#x27;case\n&#x27;
                           &#x27; * the Broadleaf End User License Agreement &#x27;
                           &#x27;(EULA), Version 1.1\n&#x27;
                           &#x27; * (the &quot;Commercial License&quot; located at &#x27;
                           &#x27;http://license.broadleafcommerce.org/commercial_license-1.1.txt)\n&#x27;
                           &#x27; * shall apply.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Alternatively, the Commercial License may be &#x27;
                           &#x27;replaced with a mutually agreed upon license (the &#x27;
                           &#x27;&quot;Custom License&quot;)\n&#x27;
                           &#x27; * between you and Broadleaf Commerce. You may not &#x27;
                           &#x27;use this file except in compliance with the &#x27;
                           &#x27;applicable license.\n&#x27;
                           &#x27; * #L%\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;package &#x27;
                           &#x27;org.broadleafcommerce.common.cache.engine;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import org.apache.commons.logging.Log;\n&#x27;
                           &#x27;import org.apache.commons.logging.LogFactory;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.io.Serializable;\n&#x27;
                           &#x27;import java.lang.reflect.Method;\n&#x27;
                           &#x27;import java.util.Hashtable;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import net.sf.ehcache.CacheException;\n&#x27;
                           &#x27;import net.sf.ehcache.Ehcache;\n&#x27;
                           &#x27;import net.sf.ehcache.Element;\n&#x27;
                           &#x27;import net.sf.ehcache.event.CacheEventListener;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * @author jfischer\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;@Deprecated\n&#x27;
                           &#x27;public class HydratedCacheManagerImpl implements &#x27;
                           &#x27;CacheEventListener, HydratedCacheManager, &#x27;
                           &#x27;HydratedAnnotationManager {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final Log LOG = &#x27;
                           &#x27;LogFactory.getLog(HydratedCacheManagerImpl.class);\n&#x27;
                           &#x27;    private static final HydratedCacheManagerImpl &#x27;
                           &#x27;MANAGER = new HydratedCacheManagerImpl();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public static HydratedCacheManagerImpl &#x27;
                           &#x27;getInstance() {\n&#x27;
                           &#x27;        return MANAGER;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private HydratedCacheManagerImpl()  {}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private Map&lt;String, HydratedCache&gt; &#x27;
                           &#x27;hydratedCacheContainer = new Hashtable&lt;String, &#x27;
                           &#x27;HydratedCache&gt;(100);\n&#x27;
                           &#x27;    private Map&lt;String, HydrationDescriptor&gt; &#x27;
                           &#x27;hydrationDescriptors = new Hashtable&lt;String, &#x27;
                           &#x27;HydrationDescriptor&gt;(100);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void addHydratedCache(final &#x27;
                           &#x27;HydratedCache cache) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;hydratedCacheContainer.put(cache.getCacheRegion() &#x27;
                           &#x27;+ &quot;_&quot; + cache.getCacheName(), cache);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public HydratedCache removeHydratedCache(final &#x27;
                           &#x27;String cacheRegion, final String cacheName) {\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;hydratedCacheContainer.remove(cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public  HydratedCache getHydratedCache(final &#x27;
                           &#x27;String cacheRegion, final String cacheName) {\n&#x27;
                           &#x27;        if (!containsCache(cacheRegion, &#x27;
                           &#x27;cacheName)) {\n&#x27;
                           &#x27;            HydratedCache cache = new &#x27;
                           &#x27;HydratedCache(cacheRegion, cacheName);\n&#x27;
                           &#x27;            addHydratedCache(cache);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;hydratedCacheContainer.get(cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public boolean containsCache(String &#x27;
                           &#x27;cacheRegion, String cacheName) {\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;hydratedCacheContainer.containsKey(cacheRegion + &#x27;
                           &#x27;&quot;_&quot; + cacheName);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public HydrationDescriptor &#x27;
                           &#x27;getHydrationDescriptor(Object entity) {\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(hydrationDescriptors.containsKey(entity.getClass().getName())) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;hydrationDescriptors.get(entity.getClass().getName());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        HydrationDescriptor descriptor = new &#x27;
                           &#x27;HydrationDescriptor();\n&#x27;
                           &#x27;        Class&lt;?&gt; topEntityClass = &#x27;
                           &#x27;getTopEntityClass(entity);\n&#x27;
                           &#x27;        HydrationScanner scanner = new &#x27;
                           &#x27;HydrationScanner(topEntityClass, &#x27;
                           &#x27;entity.getClass());\n&#x27;
                           &#x27;        scanner.init();\n&#x27;
                           &#x27;        &#x27;
                           &#x27;descriptor.setHydratedMutators(scanner.getCacheMutators());\n&#x27;
                           &#x27;        Map&lt;String, Method[]&gt; mutators = &#x27;
                           &#x27;scanner.getIdMutators();\n&#x27;
                           &#x27;        if (mutators.size() != 1) {\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;Broadleaf &#x27;
                           &#x27;Commerce Hydrated Cache currently only supports &#x27;
                           &#x27;entities with a single @Id annotation.&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        Method[] singleMutators = &#x27;
                           &#x27;mutators.values().iterator().next();\n&#x27;
                           &#x27;        descriptor.setIdMutators(singleMutators);\n&#x27;
                           &#x27;        String cacheRegion = &#x27;
                           &#x27;scanner.getCacheRegion();\n&#x27;
                           &#x27;        if (cacheRegion == null || &#x27;
                           &#x27;&quot;&quot;.equals(cacheRegion)) {\n&#x27;
                           &#x27;            cacheRegion = &#x27;
                           &#x27;topEntityClass.getName();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        descriptor.setCacheRegion(cacheRegion);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;hydrationDescriptors.put(entity.getClass().getName(), &#x27;
                           &#x27;descriptor);\n&#x27;
                           &#x27;        return descriptor;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public Class&lt;?&gt; getTopEntityClass(Object &#x27;
                           &#x27;entity) {\n&#x27;
                           &#x27;        Class&lt;?&gt; myClass = entity.getClass();\n&#x27;
                           &#x27;        Class&lt;?&gt; superClass = &#x27;
                           &#x27;entity.getClass().getSuperclass();\n&#x27;
                           &#x27;        while (superClass != null &amp;&amp; &#x27;
                           &#x27;superClass.getName().startsWith(&quot;org.broadleaf&quot;)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            myClass = superClass;\n&#x27;
                           &#x27;            superClass = &#x27;
                           &#x27;superClass.getSuperclass();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return myClass;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public Object &#x27;
                           &#x27;getHydratedCacheElementItem(String cacheRegion, &#x27;
                           &#x27;String cacheName, Serializable elementKey, String &#x27;
                           &#x27;elementItemName) {\n&#x27;
                           &#x27;        Object response = null;\n&#x27;
                           &#x27;        HydratedCache hydratedCache = &#x27;
                           &#x27;getHydratedCache(cacheRegion, cacheName);\n&#x27;
                           &#x27;        HydratedCacheElement element = &#x27;
                           &#x27;hydratedCache.getCacheElement(cacheRegion, &#x27;
                           &#x27;cacheName, elementKey);\n&#x27;
                           &#x27;        if (element != null) {\n&#x27;
                           &#x27;            response = &#x27;
                           &#x27;element.getCacheElementItem(elementItemName, &#x27;
                           &#x27;elementKey);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return response;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void addHydratedCacheElementItem(String &#x27;
                           &#x27;cacheRegion, String cacheName, Serializable &#x27;
                           &#x27;elementKey, String elementItemName, Object &#x27;
                           &#x27;elementValue) {\n&#x27;
                           &#x27;        HydratedCache hydratedCache = &#x27;
                           &#x27;getHydratedCache(cacheRegion, cacheName);\n&#x27;
                           &#x27;        HydratedCacheElement element = &#x27;
                           &#x27;hydratedCache.getCacheElement(cacheRegion, &#x27;
                           &#x27;cacheName, elementKey);\n&#x27;
                           &#x27;        if (element == null) {\n&#x27;
                           &#x27;            element = new HydratedCacheElement();\n&#x27;
                           &#x27;            &#x27;
                           &#x27;hydratedCache.addCacheElement(cacheRegion, &#x27;
                           &#x27;cacheName, elementKey, element);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        &#x27;
                           &#x27;element.putCacheElementItem(elementItemName, &#x27;
                           &#x27;elementKey, elementValue);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void dispose() {\n&#x27;
                           &#x27;        if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;            LOG.info(&quot;Disposing of all hydrated &#x27;
                           &#x27;cache members&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        hydratedCacheContainer.clear();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void removeCache(String cacheRegion, &#x27;
                           &#x27;Serializable key) {\n&#x27;
                           &#x27;        String cacheName = cacheRegion;\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(key.getClass().getName().equals(&quot;org.hibernate.cache.internal.CacheKeyImplementation&quot;)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            // Since CacheKeyImplementation is a &#x27;
                           &quot;protected Class we can&#x27;t cast it nor can we access &quot;
                           &#x27;the entityOrRoleName property\n&#x27;
                           &#x27;            // therefore, to match how this worked &#x27;
                           &#x27;in pre Hibernate 5, we split the toString since &#x27;
                           &quot;it&#x27;s comprised of the fields we need\n&quot;
                           &#x27;            String[] keyPieces = &#x27;
                           &#x27;key.toString().split(&quot;#&quot;);\n&#x27;
                           &#x27;            cacheName = keyPieces[0];\n&#x27;
                           &#x27;            key = keyPieces[1];\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (containsCache(cacheRegion, cacheName)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            HydratedCache cache = &#x27;
                           &#x27;hydratedCacheContainer.get(cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName);\n&#x27;
                           &#x27;            String myKey = cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName + &quot;_&quot; + key;\n&#x27;
                           &#x27;            if (cache.containsKey(myKey)) {\n&#x27;
                           &#x27;                if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;                    LOG.info(&quot;Clearing hydrated &#x27;
                           &#x27;cache for cache name: &quot; + cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName + &quot;_&quot; + key);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                &#x27;
                           &#x27;cache.removeCacheElement(cacheRegion, cacheName, &#x27;
                           &#x27;key);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void removeAll(String cacheName) {\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(hydratedCacheContainer.containsKey(cacheName)) {\n&#x27;
                           &#x27;            if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;                LOG.info(&quot;Clearing all hydrated &#x27;
                           &#x27;caches for cache name: &quot; + cacheName);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            &#x27;
                           &#x27;hydratedCacheContainer.remove(cacheName);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementEvicted(Ehcache arg0, &#x27;
                           &#x27;Element arg1) {\n&#x27;
                           &#x27;        removeCache(arg0.getName(), &#x27;
                           &#x27;arg1.getKey());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementExpired(Ehcache arg0, &#x27;
                           &#x27;Element arg1) {\n&#x27;
                           &#x27;        removeCache(arg0.getName(), &#x27;
                           &#x27;arg1.getKey());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementPut(Ehcache arg0, &#x27;
                           &#x27;Element arg1) throws CacheException {\n&#x27;
                           &#x27;        //do nothing\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementRemoved(Ehcache arg0, &#x27;
                           &#x27;Element arg1) throws CacheException {\n&#x27;
                           &#x27;        removeCache(arg0.getName(), &#x27;
                           &#x27;arg1.getKey());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementUpdated(Ehcache arg0, &#x27;
                           &#x27;Element arg1) throws CacheException {\n&#x27;
                           &#x27;        removeCache(arg0.getName(), &#x27;
                           &#x27;arg1.getKey());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyRemoveAll(Ehcache arg0) {\n&#x27;
                           &#x27;        removeAll(arg0.getName());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public Object clone() throws &#x27;
                           &#x27;CloneNotSupportedException {\n&#x27;
                           &#x27;        return this;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;}\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*-\n&#x27;
                           &#x27; * #%L\n&#x27;
                           &#x27; * BroadleafCommerce Common Libraries\n&#x27;
                           &#x27; * %%\n&#x27;
                           &#x27; * Copyright (C) 2009 - 2024 Broadleaf Commerce\n&#x27;
                           &#x27; * %%\n&#x27;
                           &#x27; * Licensed under the Broadleaf Fair Use License &#x27;
                           &#x27;Agreement, Version 1.0\n&#x27;
                           &#x27; * (the &quot;Fair Use License&quot; located  at &#x27;
                           &#x27;http://license.broadleafcommerce.org/fair_use_license-1.0.txt)\n&#x27;
                           &#x27; * unless the restrictions on use therein are &#x27;
                           &#x27;violated and require payment to Broadleaf in which &#x27;
                           &#x27;case\n&#x27;
                           &#x27; * the Broadleaf End User License Agreement &#x27;
                           &#x27;(EULA), Version 1.1\n&#x27;
                           &#x27; * (the &quot;Commercial License&quot; located at &#x27;
                           &#x27;http://license.broadleafcommerce.org/commercial_license-1.1.txt)\n&#x27;
                           &#x27; * shall apply.\n&#x27;
                           &#x27; * \n&#x27;
                           &#x27; * Alternatively, the Commercial License may be &#x27;
                           &#x27;replaced with a mutually agreed upon license (the &#x27;
                           &#x27;&quot;Custom License&quot;)\n&#x27;
                           &#x27; * between you and Broadleaf Commerce. You may not &#x27;
                           &#x27;use this file except in compliance with the &#x27;
                           &#x27;applicable license.\n&#x27;
                           &#x27; * #L%\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;package &#x27;
                           &#x27;org.broadleafcommerce.common.cache.engine;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import org.apache.commons.logging.Log;\n&#x27;
                           &#x27;import org.apache.commons.logging.LogFactory;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.io.Serializable;\n&#x27;
                           &#x27;import java.lang.reflect.Method;\n&#x27;
                           &#x27;import java.util.Hashtable;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import net.sf.ehcache.CacheException;\n&#x27;
                           &#x27;import net.sf.ehcache.Ehcache;\n&#x27;
                           &#x27;import net.sf.ehcache.Element;\n&#x27;
                           &#x27;import net.sf.ehcache.event.CacheEventListener;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * \n&#x27;
                           &#x27; * @author jfischer\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;@Deprecated\n&#x27;
                           &#x27;public class HydratedCacheManagerImpl implements &#x27;
                           &#x27;CacheEventListener, HydratedCacheManager, &#x27;
                           &#x27;HydratedAnnotationManager {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final Log LOG = &#x27;
                           &#x27;LogFactory.getLog(HydratedCacheManagerImpl.class);\n&#x27;
                           &#x27;    private static final HydratedCacheManagerImpl &#x27;
                           &#x27;MANAGER = new HydratedCacheManagerImpl();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public static HydratedCacheManagerImpl &#x27;
                           &#x27;getInstance() {\n&#x27;
                           &#x27;        return MANAGER;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private HydratedCacheManagerImpl()  {}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private Map&lt;String, HydratedCache&gt; &#x27;
                           &#x27;hydratedCacheContainer = new Hashtable&lt;String, &#x27;
                           &#x27;HydratedCache&gt;(100);\n&#x27;
                           &#x27;    private Map&lt;String, HydrationDescriptor&gt; &#x27;
                           &#x27;hydrationDescriptors = new Hashtable&lt;String, &#x27;
                           &#x27;HydrationDescriptor&gt;(100);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void addHydratedCache(final &#x27;
                           &#x27;HydratedCache cache) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;hydratedCacheContainer.put(cache.getCacheRegion() &#x27;
                           &#x27;+ &quot;_&quot; + cache.getCacheName(), cache);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public HydratedCache removeHydratedCache(final &#x27;
                           &#x27;String cacheRegion, final String cacheName) {\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;hydratedCacheContainer.remove(cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public  HydratedCache getHydratedCache(final &#x27;
                           &#x27;String cacheRegion, final String cacheName) {\n&#x27;
                           &#x27;        if (!containsCache(cacheRegion, &#x27;
                           &#x27;cacheName)) {\n&#x27;
                           &#x27;            HydratedCache cache = new &#x27;
                           &#x27;HydratedCache(cacheRegion, cacheName);\n&#x27;
                           &#x27;            addHydratedCache(cache);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;hydratedCacheContainer.get(cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    \n&#x27;
                           &#x27;    public boolean containsCache(String &#x27;
                           &#x27;cacheRegion, String cacheName) {\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;hydratedCacheContainer.containsKey(cacheRegion + &#x27;
                           &#x27;&quot;_&quot; + cacheName);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    \n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public HydrationDescriptor &#x27;
                           &#x27;getHydrationDescriptor(Object entity) {\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(hydrationDescriptors.containsKey(entity.getClass().getName())) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;hydrationDescriptors.get(entity.getClass().getName());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        HydrationDescriptor descriptor = new &#x27;
                           &#x27;HydrationDescriptor();\n&#x27;
                           &#x27;        Class&lt;?&gt; topEntityClass = &#x27;
                           &#x27;getTopEntityClass(entity);\n&#x27;
                           &#x27;        HydrationScanner scanner = new &#x27;
                           &#x27;HydrationScanner(topEntityClass, &#x27;
                           &#x27;entity.getClass());\n&#x27;
                           &#x27;        scanner.init();\n&#x27;
                           &#x27;        &#x27;
                           &#x27;descriptor.setHydratedMutators(scanner.getCacheMutators());\n&#x27;
                           &#x27;        Map&lt;String, Method[]&gt; mutators = &#x27;
                           &#x27;scanner.getIdMutators();\n&#x27;
                           &#x27;        if (mutators.size() != 1) {\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;Broadleaf &#x27;
                           &#x27;Commerce Hydrated Cache currently only supports &#x27;
                           &#x27;entities with a single @Id annotation.&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        Method[] singleMutators = &#x27;
                           &#x27;mutators.values().iterator().next();\n&#x27;
                           &#x27;        descriptor.setIdMutators(singleMutators);\n&#x27;
                           &#x27;        String cacheRegion = &#x27;
                           &#x27;scanner.getCacheRegion();\n&#x27;
                           &#x27;        if (cacheRegion == null || &#x27;
                           &#x27;&quot;&quot;.equals(cacheRegion)) {\n&#x27;
                           &#x27;            cacheRegion = &#x27;
                           &#x27;topEntityClass.getName();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        descriptor.setCacheRegion(cacheRegion);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;hydrationDescriptors.put(entity.getClass().getName(), &#x27;
                           &#x27;descriptor);\n&#x27;
                           &#x27;        return descriptor;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    \n&#x27;
                           &#x27;    public Class&lt;?&gt; getTopEntityClass(Object &#x27;
                           &#x27;entity) {\n&#x27;
                           &#x27;        Class&lt;?&gt; myClass = entity.getClass();\n&#x27;
                           &#x27;        Class&lt;?&gt; superClass = &#x27;
                           &#x27;entity.getClass().getSuperclass();\n&#x27;
                           &#x27;        while (superClass != null &amp;&amp; &#x27;
                           &#x27;superClass.getName().startsWith(&quot;org.broadleaf&quot;)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            myClass = superClass;\n&#x27;
                           &#x27;            superClass = &#x27;
                           &#x27;superClass.getSuperclass();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return myClass;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    \n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public Object &#x27;
                           &#x27;getHydratedCacheElementItem(String cacheRegion, &#x27;
                           &#x27;String cacheName, Serializable elementKey, String &#x27;
                           &#x27;elementItemName) {\n&#x27;
                           &#x27;        Object response = null;\n&#x27;
                           &#x27;        HydratedCache hydratedCache = &#x27;
                           &#x27;getHydratedCache(cacheRegion, cacheName);\n&#x27;
                           &#x27;        HydratedCacheElement element = &#x27;
                           &#x27;hydratedCache.getCacheElement(cacheRegion, &#x27;
                           &#x27;cacheName, elementKey);\n&#x27;
                           &#x27;        if (element != null) {\n&#x27;
                           &#x27;            response = &#x27;
                           &#x27;element.getCacheElementItem(elementItemName, &#x27;
                           &#x27;elementKey);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return response;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    \n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void addHydratedCacheElementItem(String &#x27;
                           &#x27;cacheRegion, String cacheName, Serializable &#x27;
                           &#x27;elementKey, String elementItemName, Object &#x27;
                           &#x27;elementValue) {\n&#x27;
                           &#x27;        HydratedCache hydratedCache = &#x27;
                           &#x27;getHydratedCache(cacheRegion, cacheName);\n&#x27;
                           &#x27;        HydratedCacheElement element = &#x27;
                           &#x27;hydratedCache.getCacheElement(cacheRegion, &#x27;
                           &#x27;cacheName, elementKey);\n&#x27;
                           &#x27;        if (element == null) {\n&#x27;
                           &#x27;            element = new HydratedCacheElement();\n&#x27;
                           &#x27;            &#x27;
                           &#x27;hydratedCache.addCacheElement(cacheRegion, &#x27;
                           &#x27;cacheName, elementKey, element);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        &#x27;
                           &#x27;element.putCacheElementItem(elementItemName, &#x27;
                           &#x27;elementKey, elementValue);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void dispose() {\n&#x27;
                           &#x27;        if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;            LOG.info(&quot;Disposing of all hydrated &#x27;
                           &#x27;cache members&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        hydratedCacheContainer.clear();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void removeCache(String cacheRegion, &#x27;
                           &#x27;Serializable key) {\n&#x27;
                           &#x27;        String cacheName = cacheRegion;\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(key.getClass().getName().equals(&quot;org.hibernate.cache.internal.CacheKeyImplementation&quot;)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            // Since CacheKeyImplementation is a &#x27;
                           &quot;protected Class we can&#x27;t cast it nor can we access &quot;
                           &#x27;the entityOrRoleName property\n&#x27;
                           &#x27;            // therefore, to match how this worked &#x27;
                           &#x27;in pre Hibernate 5, we split the toString since &#x27;
                           &quot;it&#x27;s comprised of the fields we need\n&quot;
                           &#x27;            String[] keyPieces = &#x27;
                           &#x27;key.toString().split(&quot;#&quot;);\n&#x27;
                           &#x27;            cacheName = keyPieces[0];\n&#x27;
                           &#x27;            key = keyPieces[1];\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (containsCache(cacheRegion, cacheName)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            HydratedCache cache = &#x27;
                           &#x27;hydratedCacheContainer.get(cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName);\n&#x27;
                           &#x27;            String myKey = cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName + &quot;_&quot; + key;\n&#x27;
                           &#x27;            if (cache.containsKey(myKey)) {\n&#x27;
                           &#x27;                if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;                    LOG.info(&quot;Clearing hydrated &#x27;
                           &#x27;cache for cache name: &quot; + cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName + &quot;_&quot; + key);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                &#x27;
                           &#x27;cache.removeCacheElement(cacheRegion, cacheName, &#x27;
                           &#x27;key);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    \n&#x27;
                           &#x27;    private void removeAll(String cacheName) {\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(hydratedCacheContainer.containsKey(cacheName)) {\n&#x27;
                           &#x27;            if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;                LOG.info(&quot;Clearing all hydrated &#x27;
                           &#x27;caches for cache name: &quot; + cacheName);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            &#x27;
                           &#x27;hydratedCacheContainer.remove(cacheName);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementEvicted(Ehcache arg0, &#x27;
                           &#x27;Element arg1) {\n&#x27;
                           &#x27;        removeCache(arg0.getName(), &#x27;
                           &#x27;arg1.getKey());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementExpired(Ehcache arg0, &#x27;
                           &#x27;Element arg1) {\n&#x27;
                           &#x27;        removeCache(arg0.getName(), &#x27;
                           &#x27;arg1.getKey());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementPut(Ehcache arg0, &#x27;
                           &#x27;Element arg1) throws CacheException {\n&#x27;
                           &#x27;        //do nothing\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementRemoved(Ehcache arg0, &#x27;
                           &#x27;Element arg1) throws CacheException {\n&#x27;
                           &#x27;        removeCache(arg0.getName(), &#x27;
                           &#x27;arg1.getKey());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementUpdated(Ehcache arg0, &#x27;
                           &#x27;Element arg1) throws CacheException {\n&#x27;
                           &#x27;        removeCache(arg0.getName(), &#x27;
                           &#x27;arg1.getKey());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyRemoveAll(Ehcache arg0) {\n&#x27;
                           &#x27;        removeAll(arg0.getName());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public Object clone() throws &#x27;
                           &#x27;CloneNotSupportedException {\n&#x27;
                           &#x27;        return this;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*-\n&#x27;
                           &#x27; * #%L\n&#x27;
                           &#x27; * BroadleafCommerce Common Libraries\n&#x27;
                           &#x27; * %%\n&#x27;
                           &#x27; * Copyright (C) 2009 - 2024 Broadleaf Commerce\n&#x27;
                           &#x27; * %%\n&#x27;
                           &#x27; * Licensed under the Broadleaf Fair Use License &#x27;
                           &#x27;Agreement, Version 1.0\n&#x27;
                           &#x27; * (the &quot;Fair Use License&quot; located  at &#x27;
                           &#x27;http://license.broadleafcommerce.org/fair_use_license-1.0.txt)\n&#x27;
                           &#x27; * unless the restrictions on use therein are &#x27;
                           &#x27;violated and require payment to Broadleaf in which &#x27;
                           &#x27;case\n&#x27;
                           &#x27; * the Broadleaf End User License Agreement &#x27;
                           &#x27;(EULA), Version 1.1\n&#x27;
                           &#x27; * (the &quot;Commercial License&quot; located at &#x27;
                           &#x27;http://license.broadleafcommerce.org/commercial_license-1.1.txt)\n&#x27;
                           &#x27; * shall apply.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Alternatively, the Commercial License may be &#x27;
                           &#x27;replaced with a mutually agreed upon license (the &#x27;
                           &#x27;&quot;Custom License&quot;)\n&#x27;
                           &#x27; * between you and Broadleaf Commerce. You may not &#x27;
                           &#x27;use this file except in compliance with the &#x27;
                           &#x27;applicable license.\n&#x27;
                           &#x27; * #L%\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;package &#x27;
                           &#x27;org.broadleafcommerce.common.cache.engine;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import org.apache.commons.logging.Log;\n&#x27;
                           &#x27;import org.apache.commons.logging.LogFactory;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.io.Serializable;\n&#x27;
                           &#x27;import java.lang.reflect.Method;\n&#x27;
                           &#x27;import java.util.Hashtable;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import net.sf.ehcache.CacheException;\n&#x27;
                           &#x27;import net.sf.ehcache.Ehcache;\n&#x27;
                           &#x27;import net.sf.ehcache.Element;\n&#x27;
                           &#x27;import net.sf.ehcache.event.CacheEventListener;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * @author jfischer\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;@Deprecated\n&#x27;
                           &#x27;public class HydratedCacheManagerImpl implements &#x27;
                           &#x27;CacheEventListener, HydratedCacheManager, &#x27;
                           &#x27;HydratedAnnotationManager {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final Log LOG = &#x27;
                           &#x27;LogFactory.getLog(HydratedCacheManagerImpl.class);\n&#x27;
                           &#x27;    private static final HydratedCacheManagerImpl &#x27;
                           &#x27;MANAGER = new HydratedCacheManagerImpl();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public static HydratedCacheManagerImpl &#x27;
                           &#x27;getInstance() {\n&#x27;
                           &#x27;        return MANAGER;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private HydratedCacheManagerImpl()  {}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private Map&lt;String, HydratedCache&gt; &#x27;
                           &#x27;hydratedCacheContainer = new Hashtable&lt;String, &#x27;
                           &#x27;HydratedCache&gt;(100);\n&#x27;
                           &#x27;    private Map&lt;String, HydrationDescriptor&gt; &#x27;
                           &#x27;hydrationDescriptors = new Hashtable&lt;String, &#x27;
                           &#x27;HydrationDescriptor&gt;(100);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void addHydratedCache(final &#x27;
                           &#x27;HydratedCache cache) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;hydratedCacheContainer.put(cache.getCacheRegion() &#x27;
                           &#x27;+ &quot;_&quot; + cache.getCacheName(), cache);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public HydratedCache removeHydratedCache(final &#x27;
                           &#x27;String cacheRegion, final String cacheName) {\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;hydratedCacheContainer.remove(cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public  HydratedCache getHydratedCache(final &#x27;
                           &#x27;String cacheRegion, final String cacheName) {\n&#x27;
                           &#x27;        if (!containsCache(cacheRegion, &#x27;
                           &#x27;cacheName)) {\n&#x27;
                           &#x27;            HydratedCache cache = new &#x27;
                           &#x27;HydratedCache(cacheRegion, cacheName);\n&#x27;
                           &#x27;            addHydratedCache(cache);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;hydratedCacheContainer.get(cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public boolean containsCache(String &#x27;
                           &#x27;cacheRegion, String cacheName) {\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;hydratedCacheContainer.containsKey(cacheRegion + &#x27;
                           &#x27;&quot;_&quot; + cacheName);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public HydrationDescriptor &#x27;
                           &#x27;getHydrationDescriptor(Object entity) {\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(hydrationDescriptors.containsKey(entity.getClass().getName())) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;hydrationDescriptors.get(entity.getClass().getName());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        HydrationDescriptor descriptor = new &#x27;
                           &#x27;HydrationDescriptor();\n&#x27;
                           &#x27;        Class&lt;?&gt; topEntityClass = &#x27;
                           &#x27;getTopEntityClass(entity);\n&#x27;
                           &#x27;        HydrationScanner scanner = new &#x27;
                           &#x27;HydrationScanner(topEntityClass, &#x27;
                           &#x27;entity.getClass());\n&#x27;
                           &#x27;        scanner.init();\n&#x27;
                           &#x27;        &#x27;
                           &#x27;descriptor.setHydratedMutators(scanner.getCacheMutators());\n&#x27;
                           &#x27;        Map&lt;String, Method[]&gt; mutators = &#x27;
                           &#x27;scanner.getIdMutators();\n&#x27;
                           &#x27;        if (mutators.size() != 1) {\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;Broadleaf &#x27;
                           &#x27;Commerce Hydrated Cache currently only supports &#x27;
                           &#x27;entities with a single @Id annotation.&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        Method[] singleMutators = &#x27;
                           &#x27;mutators.values().iterator().next();\n&#x27;
                           &#x27;        descriptor.setIdMutators(singleMutators);\n&#x27;
                           &#x27;        String cacheRegion = &#x27;
                           &#x27;scanner.getCacheRegion();\n&#x27;
                           &#x27;        if (cacheRegion == null || &#x27;
                           &#x27;&quot;&quot;.equals(cacheRegion)) {\n&#x27;
                           &#x27;            cacheRegion = &#x27;
                           &#x27;topEntityClass.getName();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        descriptor.setCacheRegion(cacheRegion);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;hydrationDescriptors.put(entity.getClass().getName(), &#x27;
                           &#x27;descriptor);\n&#x27;
                           &#x27;        return descriptor;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public Class&lt;?&gt; getTopEntityClass(Object &#x27;
                           &#x27;entity) {\n&#x27;
                           &#x27;        Class&lt;?&gt; myClass = entity.getClass();\n&#x27;
                           &#x27;        Class&lt;?&gt; superClass = &#x27;
                           &#x27;entity.getClass().getSuperclass();\n&#x27;
                           &#x27;        while (superClass != null &amp;&amp; &#x27;
                           &#x27;superClass.getName().startsWith(&quot;org.broadleaf&quot;)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            myClass = superClass;\n&#x27;
                           &#x27;            superClass = &#x27;
                           &#x27;superClass.getSuperclass();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return myClass;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public Object &#x27;
                           &#x27;getHydratedCacheElementItem(String cacheRegion, &#x27;
                           &#x27;String cacheName, Serializable elementKey, String &#x27;
                           &#x27;elementItemName) {\n&#x27;
                           &#x27;        Object response = null;\n&#x27;
                           &#x27;        HydratedCache hydratedCache = &#x27;
                           &#x27;getHydratedCache(cacheRegion, cacheName);\n&#x27;
                           &#x27;        HydratedCacheElement element = &#x27;
                           &#x27;hydratedCache.getCacheElement(cacheRegion, &#x27;
                           &#x27;cacheName, elementKey);\n&#x27;
                           &#x27;        if (element != null) {\n&#x27;
                           &#x27;            response = &#x27;
                           &#x27;element.getCacheElementItem(elementItemName, &#x27;
                           &#x27;elementKey);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return response;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void addHydratedCacheElementItem(String &#x27;
                           &#x27;cacheRegion, String cacheName, Serializable &#x27;
                           &#x27;elementKey, String elementItemName, Object &#x27;
                           &#x27;elementValue) {\n&#x27;
                           &#x27;        HydratedCache hydratedCache = &#x27;
                           &#x27;getHydratedCache(cacheRegion, cacheName);\n&#x27;
                           &#x27;        HydratedCacheElement element = &#x27;
                           &#x27;hydratedCache.getCacheElement(cacheRegion, &#x27;
                           &#x27;cacheName, elementKey);\n&#x27;
                           &#x27;        if (element == null) {\n&#x27;
                           &#x27;            element = new HydratedCacheElement();\n&#x27;
                           &#x27;            &#x27;
                           &#x27;hydratedCache.addCacheElement(cacheRegion, &#x27;
                           &#x27;cacheName, elementKey, element);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        &#x27;
                           &#x27;element.putCacheElementItem(elementItemName, &#x27;
                           &#x27;elementKey, elementValue);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void dispose() {\n&#x27;
                           &#x27;        if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;            LOG.info(&quot;Disposing of all hydrated &#x27;
                           &#x27;cache members&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        hydratedCacheContainer.clear();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void removeCache(String cacheRegion, &#x27;
                           &#x27;Serializable key) {\n&#x27;
                           &#x27;        String cacheName = cacheRegion;\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(key.getClass().getName().equals(&quot;org.hibernate.cache.internal.CacheKeyImplementation&quot;)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            // Since CacheKeyImplementation is a &#x27;
                           &quot;protected Class we can&#x27;t cast it nor can we access &quot;
                           &#x27;the entityOrRoleName property\n&#x27;
                           &#x27;            // therefore, to match how this worked &#x27;
                           &#x27;in pre Hibernate 5, we split the toString since &#x27;
                           &quot;it&#x27;s comprised of the fields we need\n&quot;
                           &#x27;            String[] keyPieces = &#x27;
                           &#x27;key.toString().split(&quot;#&quot;);\n&#x27;
                           &#x27;            cacheName = keyPieces[0];\n&#x27;
                           &#x27;            key = keyPieces[1];\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (containsCache(cacheRegion, cacheName)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            HydratedCache cache = &#x27;
                           &#x27;hydratedCacheContainer.get(cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName);\n&#x27;
                           &#x27;            String myKey = cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName + &quot;_&quot; + key;\n&#x27;
                           &#x27;            if (cache.containsKey(myKey)) {\n&#x27;
                           &#x27;                if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;                    LOG.info(&quot;Clearing hydrated &#x27;
                           &#x27;cache for cache name: &quot; + cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName + &quot;_&quot; + key);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                &#x27;
                           &#x27;cache.removeCacheElement(cacheRegion, cacheName, &#x27;
                           &#x27;key);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void removeAll(String cacheName) {\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(hydratedCacheContainer.containsKey(cacheName)) {\n&#x27;
                           &#x27;            if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;                LOG.info(&quot;Clearing all hydrated &#x27;
                           &#x27;caches for cache name: &quot; + cacheName);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            &#x27;
                           &#x27;hydratedCacheContainer.remove(cacheName);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementEvicted(Ehcache arg0, &#x27;
                           &#x27;Element arg1) {\n&#x27;
                           &#x27;        removeCache(arg0.getName(), &#x27;
                           &#x27;arg1.getKey());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementExpired(Ehcache arg0, &#x27;
                           &#x27;Element arg1) {\n&#x27;
                           &#x27;        removeCache(arg0.getName(), &#x27;
                           &#x27;arg1.getKey());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementPut(Ehcache arg0, &#x27;
                           &#x27;Element arg1) throws CacheException {\n&#x27;
                           &#x27;        //do nothing\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementRemoved(Ehcache arg0, &#x27;
                           &#x27;Element arg1) throws CacheException {\n&#x27;
                           &#x27;        removeCache(arg0.getName(), &#x27;
                           &#x27;arg1.getKey());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementUpdated(Ehcache arg0, &#x27;
                           &#x27;Element arg1) throws CacheException {\n&#x27;
                           &#x27;        removeCache(arg0.getName(), &#x27;
                           &#x27;arg1.getKey());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyRemoveAll(Ehcache arg0) {\n&#x27;
                           &#x27;        removeAll(arg0.getName());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public Object clone() throws &#x27;
                           &#x27;CloneNotSupportedException {\n&#x27;
                           &#x27;        return this;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;/*-\n&#x27;
                           &#x27; * #%L\n&#x27;
                           &#x27; * BroadleafCommerce Common Libraries\n&#x27;
                           &#x27; * %%\n&#x27;
                           &#x27; * Copyright (C) 2009 - 2024 Broadleaf Commerce\n&#x27;
                           &#x27; * %%\n&#x27;
                           &#x27; * Licensed under the Broadleaf Fair Use License &#x27;
                           &#x27;Agreement, Version 1.0\n&#x27;
                           &#x27; * (the &quot;Fair Use License&quot; located  at &#x27;
                           &#x27;http://license.broadleafcommerce.org/fair_use_license-1.0.txt)\n&#x27;
                           &#x27; * unless the restrictions on use therein are &#x27;
                           &#x27;violated and require payment to Broadleaf in which &#x27;
                           &#x27;case\n&#x27;
                           &#x27; * the Broadleaf End User License Agreement &#x27;
                           &#x27;(EULA), Version 1.1\n&#x27;
                           &#x27; * (the &quot;Commercial License&quot; located at &#x27;
                           &#x27;http://license.broadleafcommerce.org/commercial_license-1.1.txt)\n&#x27;
                           &#x27; * shall apply.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Alternatively, the Commercial License may be &#x27;
                           &#x27;replaced with a mutually agreed upon license (the &#x27;
                           &#x27;&quot;Custom License&quot;)\n&#x27;
                           &#x27; * between you and Broadleaf Commerce. You may not &#x27;
                           &#x27;use this file except in compliance with the &#x27;
                           &#x27;applicable license.\n&#x27;
                           &#x27; * #L%\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;package &#x27;
                           &#x27;org.broadleafcommerce.common.cache.engine;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import org.apache.commons.logging.Log;\n&#x27;
                           &#x27;import org.apache.commons.logging.LogFactory;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.io.Serializable;\n&#x27;
                           &#x27;import java.lang.reflect.Method;\n&#x27;
                           &#x27;import java.util.Hashtable;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import net.sf.ehcache.CacheException;\n&#x27;
                           &#x27;import net.sf.ehcache.Ehcache;\n&#x27;
                           &#x27;import net.sf.ehcache.Element;\n&#x27;
                           &#x27;import net.sf.ehcache.event.CacheEventListener;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * @author jfischer\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;@Deprecated\n&#x27;
                           &#x27;public class HydratedCacheManagerImpl implements &#x27;
                           &#x27;CacheEventListener, HydratedCacheManager, &#x27;
                           &#x27;HydratedAnnotationManager {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final Log LOG = &#x27;
                           &#x27;LogFactory.getLog(HydratedCacheManagerImpl.class);\n&#x27;
                           &#x27;    private static final HydratedCacheManagerImpl &#x27;
                           &#x27;MANAGER = new HydratedCacheManagerImpl();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public static HydratedCacheManagerImpl &#x27;
                           &#x27;getInstance() {\n&#x27;
                           &#x27;        return MANAGER;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private HydratedCacheManagerImpl()  {}\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private Map&lt;String, HydratedCache&gt; &#x27;
                           &#x27;hydratedCacheContainer = new Hashtable&lt;String, &#x27;
                           &#x27;HydratedCache&gt;(100);\n&#x27;
                           &#x27;    private Map&lt;String, HydrationDescriptor&gt; &#x27;
                           &#x27;hydrationDescriptors = new Hashtable&lt;String, &#x27;
                           &#x27;HydrationDescriptor&gt;(100);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void addHydratedCache(final &#x27;
                           &#x27;HydratedCache cache) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;hydratedCacheContainer.put(cache.getCacheRegion() &#x27;
                           &#x27;+ &quot;_&quot; + cache.getCacheName(), cache);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public HydratedCache removeHydratedCache(final &#x27;
                           &#x27;String cacheRegion, final String cacheName) {\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;hydratedCacheContainer.remove(cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public  HydratedCache getHydratedCache(final &#x27;
                           &#x27;String cacheRegion, final String cacheName) {\n&#x27;
                           &#x27;        if (!containsCache(cacheRegion, &#x27;
                           &#x27;cacheName)) {\n&#x27;
                           &#x27;            HydratedCache cache = new &#x27;
                           &#x27;HydratedCache(cacheRegion, cacheName);\n&#x27;
                           &#x27;            addHydratedCache(cache);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;hydratedCacheContainer.get(cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public boolean containsCache(String &#x27;
                           &#x27;cacheRegion, String cacheName) {\n&#x27;
                           &#x27;        return &#x27;
                           &#x27;hydratedCacheContainer.containsKey(cacheRegion + &#x27;
                           &#x27;&quot;_&quot; + cacheName);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public HydrationDescriptor &#x27;
                           &#x27;getHydrationDescriptor(Object entity) {\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(hydrationDescriptors.containsKey(entity.getClass().getName())) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;hydrationDescriptors.get(entity.getClass().getName());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        HydrationDescriptor descriptor = new &#x27;
                           &#x27;HydrationDescriptor();\n&#x27;
                           &#x27;        Class&lt;?&gt; topEntityClass = &#x27;
                           &#x27;getTopEntityClass(entity);\n&#x27;
                           &#x27;        HydrationScanner scanner = new &#x27;
                           &#x27;HydrationScanner(topEntityClass, &#x27;
                           &#x27;entity.getClass());\n&#x27;
                           &#x27;        scanner.init();\n&#x27;
                           &#x27;        &#x27;
                           &#x27;descriptor.setHydratedMutators(scanner.getCacheMutators());\n&#x27;
                           &#x27;        Map&lt;String, Method[]&gt; mutators = &#x27;
                           &#x27;scanner.getIdMutators();\n&#x27;
                           &#x27;        if (mutators.size() != 1) {\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;Broadleaf &#x27;
                           &#x27;Commerce Hydrated Cache currently only supports &#x27;
                           &#x27;entities with a single @Id annotation.&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        Method[] singleMutators = &#x27;
                           &#x27;mutators.values().iterator().next();\n&#x27;
                           &#x27;        descriptor.setIdMutators(singleMutators);\n&#x27;
                           &#x27;        String cacheRegion = &#x27;
                           &#x27;scanner.getCacheRegion();\n&#x27;
                           &#x27;        if (cacheRegion == null || &#x27;
                           &#x27;&quot;&quot;.equals(cacheRegion)) {\n&#x27;
                           &#x27;            cacheRegion = &#x27;
                           &#x27;topEntityClass.getName();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        descriptor.setCacheRegion(cacheRegion);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;hydrationDescriptors.put(entity.getClass().getName(), &#x27;
                           &#x27;descriptor);\n&#x27;
                           &#x27;        return descriptor;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public Class&lt;?&gt; getTopEntityClass(Object &#x27;
                           &#x27;entity) {\n&#x27;
                           &#x27;        Class&lt;?&gt; myClass = entity.getClass();\n&#x27;
                           &#x27;        Class&lt;?&gt; superClass = &#x27;
                           &#x27;entity.getClass().getSuperclass();\n&#x27;
                           &#x27;        while (superClass != null &amp;&amp; &#x27;
                           &#x27;superClass.getName().startsWith(&quot;org.broadleaf&quot;)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            myClass = superClass;\n&#x27;
                           &#x27;            superClass = &#x27;
                           &#x27;superClass.getSuperclass();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return myClass;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public Object &#x27;
                           &#x27;getHydratedCacheElementItem(String cacheRegion, &#x27;
                           &#x27;String cacheName, Serializable elementKey, String &#x27;
                           &#x27;elementItemName) {\n&#x27;
                           &#x27;        Object response = null;\n&#x27;
                           &#x27;        HydratedCache hydratedCache = &#x27;
                           &#x27;getHydratedCache(cacheRegion, cacheName);\n&#x27;
                           &#x27;        HydratedCacheElement element = &#x27;
                           &#x27;hydratedCache.getCacheElement(cacheRegion, &#x27;
                           &#x27;cacheName, elementKey);\n&#x27;
                           &#x27;        if (element != null) {\n&#x27;
                           &#x27;            response = &#x27;
                           &#x27;element.getCacheElementItem(elementItemName, &#x27;
                           &#x27;elementKey);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return response;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void addHydratedCacheElementItem(String &#x27;
                           &#x27;cacheRegion, String cacheName, Serializable &#x27;
                           &#x27;elementKey, String elementItemName, Object &#x27;
                           &#x27;elementValue) {\n&#x27;
                           &#x27;        HydratedCache hydratedCache = &#x27;
                           &#x27;getHydratedCache(cacheRegion, cacheName);\n&#x27;
                           &#x27;        HydratedCacheElement element = &#x27;
                           &#x27;hydratedCache.getCacheElement(cacheRegion, &#x27;
                           &#x27;cacheName, elementKey);\n&#x27;
                           &#x27;        if (element == null) {\n&#x27;
                           &#x27;            element = new HydratedCacheElement();\n&#x27;
                           &#x27;            &#x27;
                           &#x27;hydratedCache.addCacheElement(cacheRegion, &#x27;
                           &#x27;cacheName, elementKey, element);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        &#x27;
                           &#x27;element.putCacheElementItem(elementItemName, &#x27;
                           &#x27;elementKey, elementValue);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void dispose() {\n&#x27;
                           &#x27;        if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;            LOG.info(&quot;Disposing of all hydrated &#x27;
                           &#x27;cache members&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        hydratedCacheContainer.clear();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void removeCache(String cacheRegion, &#x27;
                           &#x27;Serializable key) {\n&#x27;
                           &#x27;        String cacheName = cacheRegion;\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(key.getClass().getName().equals(&quot;org.hibernate.cache.internal.CacheKeyImplementation&quot;)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            // Since CacheKeyImplementation is a &#x27;
                           &quot;protected Class we can&#x27;t cast it nor can we access &quot;
                           &#x27;the entityOrRoleName property\n&#x27;
                           &#x27;            // therefore, to match how this worked &#x27;
                           &#x27;in pre Hibernate 5, we split the toString since &#x27;
                           &quot;it&#x27;s comprised of the fields we need\n&quot;
                           &#x27;            String[] keyPieces = &#x27;
                           &#x27;key.toString().split(&quot;#&quot;);\n&#x27;
                           &#x27;            cacheName = keyPieces[0];\n&#x27;
                           &#x27;            key = keyPieces[1];\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (containsCache(cacheRegion, cacheName)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            HydratedCache cache = &#x27;
                           &#x27;hydratedCacheContainer.get(cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName);\n&#x27;
                           &#x27;            String myKey = cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName + &quot;_&quot; + key;\n&#x27;
                           &#x27;            if (cache.containsKey(myKey)) {\n&#x27;
                           &#x27;                if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;                    LOG.info(&quot;Clearing hydrated &#x27;
                           &#x27;cache for cache name: &quot; + cacheRegion + &quot;_&quot; + &#x27;
                           &#x27;cacheName + &quot;_&quot; + key);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                &#x27;
                           &#x27;cache.removeCacheElement(cacheRegion, cacheName, &#x27;
                           &#x27;key);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void removeAll(String cacheName) {\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(hydratedCacheContainer.containsKey(cacheName)) {\n&#x27;
                           &#x27;            if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;                LOG.info(&quot;Clearing all hydrated &#x27;
                           &#x27;caches for cache name: &quot; + cacheName);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            &#x27;
                           &#x27;hydratedCacheContainer.remove(cacheName);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementEvicted(Ehcache arg0, &#x27;
                           &#x27;Element arg1) {\n&#x27;
                           &#x27;        removeCache(arg0.getName(), &#x27;
                           &#x27;arg1.getKey());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementExpired(Ehcache arg0, &#x27;
                           &#x27;Element arg1) {\n&#x27;
                           &#x27;        removeCache(arg0.getName(), &#x27;
                           &#x27;arg1.getKey());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementPut(Ehcache arg0, &#x27;
                           &#x27;Element arg1) throws CacheException {\n&#x27;
                           &#x27;        //do nothing\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementRemoved(Ehcache arg0, &#x27;
                           &#x27;Element arg1) throws CacheException {\n&#x27;
                           &#x27;        removeCache(arg0.getName(), &#x27;
                           &#x27;arg1.getKey());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyElementUpdated(Ehcache arg0, &#x27;
                           &#x27;Element arg1) throws CacheException {\n&#x27;
                           &#x27;        removeCache(arg0.getName(), &#x27;
                           &#x27;arg1.getKey());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void notifyRemoveAll(Ehcache arg0) {\n&#x27;
                           &#x27;        removeAll(arg0.getName());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public Object clone() throws &#x27;
                           &#x27;CloneNotSupportedException {\n&#x27;
                           &#x27;        return this;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;}\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        