<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>69 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Copyright (C) 2016 &#x27;
                         &#x27;AriaLyy(https://github.com/AriaLyy/Aria)\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                         &#x27;(the &quot;License&quot;);\n&#x27;
                         &#x27; * you may not use this file except in compliance &#x27;
                         &#x27;with the License.\n&#x27;
                         &#x27; * You may obtain a copy of the License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *      http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;package com.arialyy.aria.core.task;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import android.os.Handler;\n&#x27;
                         &#x27;import android.os.Looper;\n&#x27;
                         &#x27;import android.os.Message;\n&#x27;
                         &#x27;import android.util.Log;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.arialyy.aria.util.BufferedRandomAccessFile;\n&#x27;
                         &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                         &#x27;import java.io.File;\n&#x27;
                         &#x27;import java.io.IOException;\n&#x27;
                         &#x27;import java.io.InputStream;\n&#x27;
                         &#x27;import java.io.RandomAccessFile;\n&#x27;
                         &#x27;import java.net.HttpURLConnection;\n&#x27;
                         &#x27;import java.net.MalformedURLException;\n&#x27;
                         &#x27;import java.net.URL;\n&#x27;
                         &#x27;import java.util.Properties;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Created by lyy on 2017/1/18.\n&#x27;
                         &#x27; * 下载线程\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;final class SingleThreadTask implements Runnable {\n&#x27;
                         &#x27;  private static final String TAG      = &#x27;
                         &#x27;&quot;SingleThreadTask&quot;;\n&#x27;
                         &#x27;  // TODO: 2017/2/22 不能使用1024 否则最大速度不能超过3m\n&#x27;
                         &#x27;  private static final int    BUF_SIZE = 8192;\n&#x27;
                         &#x27;  private DownloadUtil.ConfigEntity mConfigEntity;\n&#x27;
                         &#x27;  private String                    mConfigFPath;\n&#x27;
                         &#x27;  private              long   mChildCurrentLocation &#x27;
                         &#x27;= 0;\n&#x27;
                         &#x27;  private static final Object LOCK                  &#x27;
                         &#x27;= new Object();\n&#x27;
                         &#x27;  private IDownloadListener      mListener;\n&#x27;
                         &#x27;  private DownloadStateConstance mConstance;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  SingleThreadTask(DownloadStateConstance constance, &#x27;
                         &#x27;IDownloadListener listener,\n&#x27;
                         &#x27;      DownloadUtil.ConfigEntity downloadInfo) {\n&#x27;
                         &#x27;    mConstance = constance;\n&#x27;
                         &#x27;    mListener = listener;\n&#x27;
                         &#x27;    this.mConfigEntity = downloadInfo;\n&#x27;
                         &#x27;    if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;      mConfigFPath = downloadInfo.CONFIG_FILE_PATH;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void run() {\n&#x27;
                         &#x27;    HttpURLConnection conn = null;\n&#x27;
                         &#x27;    InputStream is = null;\n&#x27;
                         &#x27;    try {\n&#x27;
                         &#x27;      URL url = new &#x27;
                         &#x27;URL(mConfigEntity.DOWNLOAD_URL);\n&#x27;
                         &#x27;      //conn = (HttpURLConnection) &#x27;
                         &#x27;url.openConnection();\n&#x27;
                         &#x27;      conn = ConnectionHelp.handleConnection(url);\n&#x27;
                         &#x27;      if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;        Log.d(TAG, &quot;线程_&quot;\n&#x27;
                         &#x27;            + mConfigEntity.THREAD_ID\n&#x27;
                         &#x27;            + &quot;_正在下载【开始位置 : &quot;\n&#x27;
                         &#x27;            + mConfigEntity.START_LOCATION\n&#x27;
                         &#x27;            + &quot;，结束位置：&quot;\n&#x27;
                         &#x27;            + mConfigEntity.END_LOCATION\n&#x27;
                         &#x27;            + &quot;】&quot;);\n&#x27;
                         &#x27;        //在头里面请求下载开始位置和结束位置\n&#x27;
                         &#x27;        conn.setRequestProperty(&quot;Range&quot;,\n&#x27;
                         &#x27;            &quot;bytes=&quot; + mConfigEntity.START_LOCATION &#x27;
                         &#x27;+ &quot;-&quot; + mConfigEntity.END_LOCATION);\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        Log.w(TAG, &quot;该下载不支持断点，即将重新下载&quot;);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      conn = ConnectionHelp.setConnectParam(conn);\n&#x27;
                         &#x27;      &#x27;
                         &#x27;conn.setConnectTimeout(mConstance.CONNECT_TIME_OUT);\n&#x27;
                         &#x27;      &#x27;
                         &#x27;conn.setReadTimeout(mConstance.READ_TIME_OUT);  &#x27;
                         &#x27;//设置读取流的等待时间,必须设置该参数\n&#x27;
                         &#x27;      is = conn.getInputStream();\n&#x27;
                         &#x27;      //创建可设置位置的文件\n&#x27;
                         &#x27;      BufferedRandomAccessFile file =\n&#x27;
                         &#x27;          new &#x27;
                         &#x27;BufferedRandomAccessFile(mConfigEntity.TEMP_FILE, &#x27;
                         &#x27;&quot;rwd&quot;, BUF_SIZE);\n&#x27;
                         &#x27;      //设置文件长度\n&#x27;
                         &#x27;      file.seek(mConfigEntity.START_LOCATION);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;      byte[] buffer = new byte[BUF_SIZE];\n&#x27;
                         &#x27;      int len;\n&#x27;
                         &#x27;      //当前子线程的下载位置\n&#x27;
                         &#x27;      mChildCurrentLocation = &#x27;
                         &#x27;mConfigEntity.START_LOCATION;\n&#x27;
                         &#x27;      while ((len = is.read(buffer)) != -1) {\n&#x27;
                         &#x27;        if (mConstance.isCancel) {\n&#x27;
                         &#x27;          break;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (mConstance.isStop) {\n&#x27;
                         &#x27;          Log.i(TAG, &quot;stop&quot;);\n&#x27;
                         &#x27;          break;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        //把下载数据数据写入文件\n&#x27;
                         &#x27;        file.write(buffer, 0, len);\n&#x27;
                         &#x27;        progress(len);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      file.close();\n&#x27;
                         &#x27;      //close 为阻塞的，需要使用线程池来处理\n&#x27;
                         &#x27;      is.close();\n&#x27;
                         &#x27;      conn.disconnect();\n&#x27;
                         &#x27;      if (mConstance.isCancel) {\n&#x27;
                         &#x27;        return;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      //停止状态不需要删除记录文件\n&#x27;
                         &#x27;      if (mConstance.isStop) {\n&#x27;
                         &#x27;        return;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      //支持断点的处理\n&#x27;
                         &#x27;      if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;        Log.i(TAG, &quot;线程【&quot; + mConfigEntity.THREAD_ID + &#x27;
                         &#x27;&quot;】下载完毕&quot;);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;writeConfig(mConfigEntity.TEMP_FILE.getName() + &#x27;
                         &#x27;&quot;_state_&quot; + mConfigEntity.THREAD_ID,\n&#x27;
                         &#x27;            1 + &quot;&quot;);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;mListener.onChildComplete(mConfigEntity.END_LOCATION);\n&#x27;
                         &#x27;        mConstance.COMPLETE_THREAD_NUM++;\n&#x27;
                         &#x27;        if (mConstance.isComplete()) {\n&#x27;
                         &#x27;          File configFile = new File(mConfigFPath);\n&#x27;
                         &#x27;          if (configFile.exists()) {\n&#x27;
                         &#x27;            configFile.delete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          mConstance.isDownloading = false;\n&#x27;
                         &#x27;          mListener.onComplete();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        Log.i(TAG, &quot;下载任务完成&quot;);\n&#x27;
                         &#x27;        mConstance.isDownloading = false;\n&#x27;
                         &#x27;        mListener.onComplete();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    } catch (MalformedURLException e) {\n&#x27;
                         &#x27;      mConstance.FAIL_NUM++;\n&#x27;
                         &#x27;      failDownload(mConfigEntity, &#x27;
                         &#x27;mChildCurrentLocation, &quot;下载链接异常&quot;, e);\n&#x27;
                         &#x27;    } catch (IOException e) {\n&#x27;
                         &#x27;      mConstance.FAIL_NUM++;\n&#x27;
                         &#x27;      failDownload(mConfigEntity, &#x27;
                         &#x27;mChildCurrentLocation, &quot;下载失败【&quot; + &#x27;
                         &#x27;mConfigEntity.DOWNLOAD_URL + &quot;】&quot;,\n&#x27;
                         &#x27;          e);\n&#x27;
                         &#x27;    } catch (Exception e) {\n&#x27;
                         &#x27;      mConstance.FAIL_NUM++;\n&#x27;
                         &#x27;      failDownload(mConfigEntity, &#x27;
                         &#x27;mChildCurrentLocation, &quot;获取流失败&quot;, e);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 停止下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  protected void stop() {\n&#x27;
                         &#x27;    synchronized (LOCK) {\n&#x27;
                         &#x27;      try {\n&#x27;
                         &#x27;        if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;          mConstance.STOP_NUM++;\n&#x27;
                         &#x27;          String location = &#x27;
                         &#x27;String.valueOf(mChildCurrentLocation);\n&#x27;
                         &#x27;          Log.d(TAG, &quot;thread_&quot;\n&#x27;
                         &#x27;              + mConfigEntity.THREAD_ID\n&#x27;
                         &#x27;              + &quot;_stop, stop location ==&gt; &quot;\n&#x27;
                         &#x27;              + mChildCurrentLocation);\n&#x27;
                         &#x27;          &#x27;
                         &#x27;writeConfig(mConfigEntity.TEMP_FILE.getName() + &#x27;
                         &#x27;&quot;_record_&quot; + mConfigEntity.THREAD_ID,\n&#x27;
                         &#x27;              location);\n&#x27;
                         &#x27;          if (mConstance.isStop()) {\n&#x27;
                         &#x27;            Log.d(TAG, &quot;++++++++++++++++ onStop &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;            mConstance.isDownloading = false;\n&#x27;
                         &#x27;            &#x27;
                         &#x27;mListener.onStop(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          Log.d(TAG, &quot;++++++++++++++++ onStop &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;          mConstance.isDownloading = false;\n&#x27;
                         &#x27;          &#x27;
                         &#x27;mListener.onStop(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      } catch (IOException e) {\n&#x27;
                         &#x27;        e.printStackTrace();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 下载中\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void progress(long len) {\n&#x27;
                         &#x27;    synchronized (LOCK) {\n&#x27;
                         &#x27;      mChildCurrentLocation += len;\n&#x27;
                         &#x27;      mConstance.CURRENT_LOCATION += len;\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onProgress(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;      //mHandler.sendEmptyMessage(1);\n&#x27;
                         &#x27;      //mHandler.post(t);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  Handler mHandler = new &#x27;
                         &#x27;Handler(Looper.getMainLooper()) {\n&#x27;
                         &#x27;    @Override public void handleMessage(Message msg) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      super.handleMessage(msg);\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onProgress(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  };\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  Thread t = new Thread(new Runnable() {\n&#x27;
                         &#x27;    @Override public void run() {\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onProgress(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  });\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  //Handler handler = new Handler(){\n&#x27;
                         &#x27;  //  @Override public void handleMessage(Message &#x27;
                         &#x27;msg) {\n&#x27;
                         &#x27;  //    super.handleMessage(msg);\n&#x27;
                         &#x27;  //    &#x27;
                         &#x27;mListener.onProgress(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;  //  }\n&#x27;
                         &#x27;  //};\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  Thread thread = new Thread();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 取消下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  protected void cancel() {\n&#x27;
                         &#x27;    synchronized (LOCK) {\n&#x27;
                         &#x27;      if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;        mConstance.CANCEL_NUM++;\n&#x27;
                         &#x27;        Log.d(TAG, &quot;++++++++++ thread_&quot; + &#x27;
                         &#x27;mConfigEntity.THREAD_ID + &quot;_cancel ++++++++++&quot;);\n&#x27;
                         &#x27;        if (mConstance.isCancel()) {\n&#x27;
                         &#x27;          File configFile = new File(mConfigFPath);\n&#x27;
                         &#x27;          if (configFile.exists()) {\n&#x27;
                         &#x27;            configFile.delete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          if (mConfigEntity.TEMP_FILE.exists()) {\n&#x27;
                         &#x27;            mConfigEntity.TEMP_FILE.delete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          Log.d(TAG, &quot;++++++++++++++++ onCancel &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;          mConstance.isDownloading = false;\n&#x27;
                         &#x27;          mListener.onCancel();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        Log.d(TAG, &quot;++++++++++++++++ onCancel &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;        mConstance.isDownloading = false;\n&#x27;
                         &#x27;        mListener.onCancel();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 下载失败\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void &#x27;
                         &#x27;failDownload(DownloadUtil.ConfigEntity dEntity, long &#x27;
                         &#x27;currentLocation, String msg,\n&#x27;
                         &#x27;      Exception ex) {\n&#x27;
                         &#x27;    synchronized (LOCK) {\n&#x27;
                         &#x27;      try {\n&#x27;
                         &#x27;        mConstance.isDownloading = false;\n&#x27;
                         &#x27;        mConstance.isStop = true;\n&#x27;
                         &#x27;        if (ex != null) {\n&#x27;
                         &#x27;          Log.e(TAG, &#x27;
                         &#x27;CommonUtil.getPrintException(ex));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;          if (currentLocation != -1) {\n&#x27;
                         &#x27;            String location = &#x27;
                         &#x27;String.valueOf(currentLocation);\n&#x27;
                         &#x27;            writeConfig(dEntity.TEMP_FILE.getName() &#x27;
                         &#x27;+ &quot;_record_&quot; + dEntity.THREAD_ID, location);\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          if (mConstance.isFail()) {\n&#x27;
                         &#x27;            Log.d(TAG, &quot;++++++++++++++++ onFail &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;            mListener.onFail();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          Log.d(TAG, &quot;++++++++++++++++ onFail &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;          mListener.onFail();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      } catch (IOException e) {\n&#x27;
                         &#x27;        e.printStackTrace();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 将记录写入到配置文件\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void writeConfig(String key, String &#x27;
                         &#x27;record) throws IOException {\n&#x27;
                         &#x27;    File configFile = new File(mConfigFPath);\n&#x27;
                         &#x27;    Properties pro = &#x27;
                         &#x27;CommonUtil.loadConfig(configFile);\n&#x27;
                         &#x27;    pro.setProperty(key, record);\n&#x27;
                         &#x27;    CommonUtil.saveConfig(configFile, pro);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Copyright (C) 2016 &#x27;
                         &#x27;AriaLyy(https://github.com/AriaLyy/Aria)\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                         &#x27;(the &quot;License&quot;);\n&#x27;
                         &#x27; * you may not use this file except in compliance &#x27;
                         &#x27;with the License.\n&#x27;
                         &#x27; * You may obtain a copy of the License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *      http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;package com.arialyy.aria.core.task;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import android.os.Handler;\n&#x27;
                         &#x27;import android.os.Looper;\n&#x27;
                         &#x27;import android.os.Message;\n&#x27;
                         &#x27;import android.util.Log;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.arialyy.aria.util.BufferedRandomAccessFile;\n&#x27;
                         &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                         &#x27;import java.io.File;\n&#x27;
                         &#x27;import java.io.IOException;\n&#x27;
                         &#x27;import java.io.InputStream;\n&#x27;
                         &#x27;import java.io.RandomAccessFile;\n&#x27;
                         &#x27;import java.net.HttpURLConnection;\n&#x27;
                         &#x27;import java.net.MalformedURLException;\n&#x27;
                         &#x27;import java.net.URL;\n&#x27;
                         &#x27;import java.util.Properties;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Created by lyy on 2017/1/18.\n&#x27;
                         &#x27; * 下载线程\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;final class SingleThreadTask implements Runnable {\n&#x27;
                         &#x27;  private static final String TAG      = &#x27;
                         &#x27;&quot;SingleThreadTask&quot;;\n&#x27;
                         &#x27;  // TODO: 2017/2/22 不能使用1024 否则最大速度不能超过3m\n&#x27;
                         &#x27;  private static final int    BUF_SIZE = 8192;\n&#x27;
                         &#x27;  private DownloadUtil.ConfigEntity mConfigEntity;\n&#x27;
                         &#x27;  private String                    mConfigFPath;\n&#x27;
                         &#x27;  private              long   mChildCurrentLocation &#x27;
                         &#x27;= 0;\n&#x27;
                         &#x27;  private static final Object LOCK                  &#x27;
                         &#x27;= new Object();\n&#x27;
                         &#x27;  private IDownloadListener      mListener;\n&#x27;
                         &#x27;  private DownloadStateConstance mConstance;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  SingleThreadTask(DownloadStateConstance constance, &#x27;
                         &#x27;IDownloadListener listener,\n&#x27;
                         &#x27;      DownloadUtil.ConfigEntity downloadInfo) {\n&#x27;
                         &#x27;    mConstance = constance;\n&#x27;
                         &#x27;    mListener = listener;\n&#x27;
                         &#x27;    this.mConfigEntity = downloadInfo;\n&#x27;
                         &#x27;    if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;      mConfigFPath = downloadInfo.CONFIG_FILE_PATH;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void run() {\n&#x27;
                         &#x27;    HttpURLConnection conn = null;\n&#x27;
                         &#x27;    InputStream is = null;\n&#x27;
                         &#x27;    try {\n&#x27;
                         &#x27;      URL url = new &#x27;
                         &#x27;URL(mConfigEntity.DOWNLOAD_URL);\n&#x27;
                         &#x27;      //conn = (HttpURLConnection) &#x27;
                         &#x27;url.openConnection();\n&#x27;
                         &#x27;      conn = ConnectionHelp.handleConnection(url);\n&#x27;
                         &#x27;      if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;        Log.d(TAG, &quot;线程_&quot;\n&#x27;
                         &#x27;            + mConfigEntity.THREAD_ID\n&#x27;
                         &#x27;            + &quot;_正在下载【开始位置 : &quot;\n&#x27;
                         &#x27;            + mConfigEntity.START_LOCATION\n&#x27;
                         &#x27;            + &quot;，结束位置：&quot;\n&#x27;
                         &#x27;            + mConfigEntity.END_LOCATION\n&#x27;
                         &#x27;            + &quot;】&quot;);\n&#x27;
                         &#x27;        //在头里面请求下载开始位置和结束位置\n&#x27;
                         &#x27;        conn.setRequestProperty(&quot;Range&quot;,\n&#x27;
                         &#x27;            &quot;bytes=&quot; + mConfigEntity.START_LOCATION &#x27;
                         &#x27;+ &quot;-&quot; + mConfigEntity.END_LOCATION);\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        Log.w(TAG, &quot;该下载不支持断点，即将重新下载&quot;);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      conn = ConnectionHelp.setConnectParam(conn);\n&#x27;
                         &#x27;      &#x27;
                         &#x27;conn.setConnectTimeout(mConstance.CONNECT_TIME_OUT);\n&#x27;
                         &#x27;      &#x27;
                         &#x27;conn.setReadTimeout(mConstance.READ_TIME_OUT);  &#x27;
                         &#x27;//设置读取流的等待时间,必须设置该参数\n&#x27;
                         &#x27;      is = conn.getInputStream();\n&#x27;
                         &#x27;      //创建可设置位置的文件\n&#x27;
                         &#x27;      BufferedRandomAccessFile file =\n&#x27;
                         &#x27;          new &#x27;
                         &#x27;BufferedRandomAccessFile(mConfigEntity.TEMP_FILE, &#x27;
                         &#x27;&quot;rwd&quot;, BUF_SIZE);\n&#x27;
                         &#x27;      //设置文件长度\n&#x27;
                         &#x27;      file.seek(mConfigEntity.START_LOCATION);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;      byte[] buffer = new byte[BUF_SIZE];\n&#x27;
                         &#x27;      int len;\n&#x27;
                         &#x27;      //当前子线程的下载位置\n&#x27;
                         &#x27;      mChildCurrentLocation = &#x27;
                         &#x27;mConfigEntity.START_LOCATION;\n&#x27;
                         &#x27;      while ((len = is.read(buffer)) != -1) {\n&#x27;
                         &#x27;        if (mConstance.isCancel) {\n&#x27;
                         &#x27;          break;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (mConstance.isStop) {\n&#x27;
                         &#x27;          Log.i(TAG, &quot;stop&quot;);\n&#x27;
                         &#x27;          break;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        //把下载数据数据写入文件\n&#x27;
                         &#x27;        file.write(buffer, 0, len);\n&#x27;
                         &#x27;        progress(len);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      file.close();\n&#x27;
                         &#x27;      //close 为阻塞的，需要使用线程池来处理\n&#x27;
                         &#x27;      is.close();\n&#x27;
                         &#x27;      conn.disconnect();\n&#x27;
                         &#x27;      if (mConstance.isCancel) {\n&#x27;
                         &#x27;        return;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      //停止状态不需要删除记录文件\n&#x27;
                         &#x27;      if (mConstance.isStop) {\n&#x27;
                         &#x27;        return;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      //支持断点的处理\n&#x27;
                         &#x27;      if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;        Log.i(TAG, &quot;线程【&quot; + mConfigEntity.THREAD_ID + &#x27;
                         &#x27;&quot;】下载完毕&quot;);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;writeConfig(mConfigEntity.TEMP_FILE.getName() + &#x27;
                         &#x27;&quot;_state_&quot; + mConfigEntity.THREAD_ID,\n&#x27;
                         &#x27;            1 + &quot;&quot;);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;mListener.onChildComplete(mConfigEntity.END_LOCATION);\n&#x27;
                         &#x27;        mConstance.COMPLETE_THREAD_NUM++;\n&#x27;
                         &#x27;        if (mConstance.isComplete()) {\n&#x27;
                         &#x27;          File configFile = new File(mConfigFPath);\n&#x27;
                         &#x27;          if (configFile.exists()) {\n&#x27;
                         &#x27;            configFile.delete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          mConstance.isDownloading = false;\n&#x27;
                         &#x27;          mListener.onComplete();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        Log.i(TAG, &quot;下载任务完成&quot;);\n&#x27;
                         &#x27;        mConstance.isDownloading = false;\n&#x27;
                         &#x27;        mListener.onComplete();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    } catch (MalformedURLException e) {\n&#x27;
                         &#x27;      mConstance.FAIL_NUM++;\n&#x27;
                         &#x27;      failDownload(mConfigEntity, &#x27;
                         &#x27;mChildCurrentLocation, &quot;下载链接异常&quot;, e);\n&#x27;
                         &#x27;    } catch (IOException e) {\n&#x27;
                         &#x27;      mConstance.FAIL_NUM++;\n&#x27;
                         &#x27;      failDownload(mConfigEntity, &#x27;
                         &#x27;mChildCurrentLocation, &quot;下载失败【&quot; + &#x27;
                         &#x27;mConfigEntity.DOWNLOAD_URL + &quot;】&quot;,\n&#x27;
                         &#x27;          e);\n&#x27;
                         &#x27;    } catch (Exception e) {\n&#x27;
                         &#x27;      mConstance.FAIL_NUM++;\n&#x27;
                         &#x27;      failDownload(mConfigEntity, &#x27;
                         &#x27;mChildCurrentLocation, &quot;获取流失败&quot;, e);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 停止下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  protected void stop() {\n&#x27;
                         &#x27;    synchronized (LOCK) {\n&#x27;
                         &#x27;      try {\n&#x27;
                         &#x27;        if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;          mConstance.STOP_NUM++;\n&#x27;
                         &#x27;          String location = &#x27;
                         &#x27;String.valueOf(mChildCurrentLocation);\n&#x27;
                         &#x27;          Log.d(TAG, &quot;thread_&quot;\n&#x27;
                         &#x27;              + mConfigEntity.THREAD_ID\n&#x27;
                         &#x27;              + &quot;_stop, stop location ==&gt; &quot;\n&#x27;
                         &#x27;              + mChildCurrentLocation);\n&#x27;
                         &#x27;          &#x27;
                         &#x27;writeConfig(mConfigEntity.TEMP_FILE.getName() + &#x27;
                         &#x27;&quot;_record_&quot; + mConfigEntity.THREAD_ID,\n&#x27;
                         &#x27;              location);\n&#x27;
                         &#x27;          if (mConstance.isStop()) {\n&#x27;
                         &#x27;            Log.d(TAG, &quot;++++++++++++++++ onStop &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;            mConstance.isDownloading = false;\n&#x27;
                         &#x27;            &#x27;
                         &#x27;mListener.onStop(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          Log.d(TAG, &quot;++++++++++++++++ onStop &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;          mConstance.isDownloading = false;\n&#x27;
                         &#x27;          &#x27;
                         &#x27;mListener.onStop(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      } catch (IOException e) {\n&#x27;
                         &#x27;        e.printStackTrace();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 下载中\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void progress(long len) {\n&#x27;
                         &#x27;    synchronized (LOCK) {\n&#x27;
                         &#x27;      mChildCurrentLocation += len;\n&#x27;
                         &#x27;      mConstance.CURRENT_LOCATION += len;\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onProgress(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;      //mHandler.sendEmptyMessage(1);\n&#x27;
                         &#x27;      //mHandler.post(t);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  Handler mHandler = new &#x27;
                         &#x27;Handler(Looper.getMainLooper()) {\n&#x27;
                         &#x27;    @Override public void handleMessage(Message msg) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      super.handleMessage(msg);\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onProgress(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  };\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  Thread t = new Thread(new Runnable() {\n&#x27;
                         &#x27;    @Override public void run() {\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onProgress(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  });\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  //Handler handler = new Handler(){\n&#x27;
                         &#x27;  //  @Override public void handleMessage(Message &#x27;
                         &#x27;msg) {\n&#x27;
                         &#x27;  //    super.handleMessage(msg);\n&#x27;
                         &#x27;  //    &#x27;
                         &#x27;mListener.onProgress(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;  //  }\n&#x27;
                         &#x27;  //};\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  Thread thread = new Thread();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 取消下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  protected void cancel() {\n&#x27;
                         &#x27;    synchronized (LOCK) {\n&#x27;
                         &#x27;      if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;        mConstance.CANCEL_NUM++;\n&#x27;
                         &#x27;        Log.d(TAG, &quot;++++++++++ thread_&quot; + &#x27;
                         &#x27;mConfigEntity.THREAD_ID + &quot;_cancel ++++++++++&quot;);\n&#x27;
                         &#x27;        if (mConstance.isCancel()) {\n&#x27;
                         &#x27;          File configFile = new File(mConfigFPath);\n&#x27;
                         &#x27;          if (configFile.exists()) {\n&#x27;
                         &#x27;            configFile.delete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          if (mConfigEntity.TEMP_FILE.exists()) {\n&#x27;
                         &#x27;            mConfigEntity.TEMP_FILE.delete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          Log.d(TAG, &quot;++++++++++++++++ onCancel &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;          mConstance.isDownloading = false;\n&#x27;
                         &#x27;          mListener.onCancel();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        Log.d(TAG, &quot;++++++++++++++++ onCancel &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;        mConstance.isDownloading = false;\n&#x27;
                         &#x27;        mListener.onCancel();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 下载失败\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void &#x27;
                         &#x27;failDownload(DownloadUtil.ConfigEntity dEntity, long &#x27;
                         &#x27;currentLocation, String msg,\n&#x27;
                         &#x27;      Exception ex) {\n&#x27;
                         &#x27;    synchronized (LOCK) {\n&#x27;
                         &#x27;      try {\n&#x27;
                         &#x27;        mConstance.isDownloading = false;\n&#x27;
                         &#x27;        mConstance.isStop = true;\n&#x27;
                         &#x27;        if (ex != null) {\n&#x27;
                         &#x27;          Log.e(TAG, &#x27;
                         &#x27;CommonUtil.getPrintException(ex));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;          if (currentLocation != -1) {\n&#x27;
                         &#x27;            String location = &#x27;
                         &#x27;String.valueOf(currentLocation);\n&#x27;
                         &#x27;            writeConfig(dEntity.TEMP_FILE.getName() &#x27;
                         &#x27;+ &quot;_record_&quot; + dEntity.THREAD_ID, location);\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          if (mConstance.isFail()) {\n&#x27;
                         &#x27;            Log.d(TAG, &quot;++++++++++++++++ onFail &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;            mListener.onFail();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          Log.d(TAG, &quot;++++++++++++++++ onFail &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;          mListener.onFail();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      } catch (IOException e) {\n&#x27;
                         &#x27;        e.printStackTrace();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 将记录写入到配置文件\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void writeConfig(String key, String &#x27;
                         &#x27;record) throws IOException {\n&#x27;
                         &#x27;    File configFile = new File(mConfigFPath);\n&#x27;
                         &#x27;    Properties pro = &#x27;
                         &#x27;CommonUtil.loadConfig(configFile);\n&#x27;
                         &#x27;    pro.setProperty(key, record);\n&#x27;
                         &#x27;    CommonUtil.saveConfig(configFile, pro);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Copyright (C) 2016 &#x27;
                         &#x27;AriaLyy(https://github.com/AriaLyy/Aria)\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                         &#x27;(the &quot;License&quot;);\n&#x27;
                         &#x27; * you may not use this file except in compliance &#x27;
                         &#x27;with the License.\n&#x27;
                         &#x27; * You may obtain a copy of the License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *      http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;package com.arialyy.aria.core.task;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import android.os.Handler;\n&#x27;
                         &#x27;import android.os.Looper;\n&#x27;
                         &#x27;import android.os.Message;\n&#x27;
                         &#x27;import android.util.Log;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.arialyy.aria.util.BufferedRandomAccessFile;\n&#x27;
                         &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                         &#x27;import java.io.File;\n&#x27;
                         &#x27;import java.io.IOException;\n&#x27;
                         &#x27;import java.io.InputStream;\n&#x27;
                         &#x27;import java.io.RandomAccessFile;\n&#x27;
                         &#x27;import java.net.HttpURLConnection;\n&#x27;
                         &#x27;import java.net.MalformedURLException;\n&#x27;
                         &#x27;import java.net.URL;\n&#x27;
                         &#x27;import java.util.Properties;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Created by lyy on 2017/1/18.\n&#x27;
                         &#x27; * 下载线程\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;final class SingleThreadTask implements Runnable {\n&#x27;
                         &#x27;  private static final String TAG      = &#x27;
                         &#x27;&quot;SingleThreadTask&quot;;\n&#x27;
                         &#x27;  // TODO: 2017/2/22 不能使用1024 否则最大速度不能超过3m\n&#x27;
                         &#x27;  private static final int    BUF_SIZE = 8192;\n&#x27;
                         &#x27;  private DownloadUtil.ConfigEntity mConfigEntity;\n&#x27;
                         &#x27;  private String                    mConfigFPath;\n&#x27;
                         &#x27;  private              long   mChildCurrentLocation &#x27;
                         &#x27;= 0;\n&#x27;
                         &#x27;  private static final Object LOCK                  &#x27;
                         &#x27;= new Object();\n&#x27;
                         &#x27;  private IDownloadListener      mListener;\n&#x27;
                         &#x27;  private DownloadStateConstance mConstance;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  SingleThreadTask(DownloadStateConstance constance, &#x27;
                         &#x27;IDownloadListener listener,\n&#x27;
                         &#x27;      DownloadUtil.ConfigEntity downloadInfo) {\n&#x27;
                         &#x27;    mConstance = constance;\n&#x27;
                         &#x27;    mListener = listener;\n&#x27;
                         &#x27;    this.mConfigEntity = downloadInfo;\n&#x27;
                         &#x27;    if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;      mConfigFPath = downloadInfo.CONFIG_FILE_PATH;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void run() {\n&#x27;
                         &#x27;    HttpURLConnection conn = null;\n&#x27;
                         &#x27;    InputStream is = null;\n&#x27;
                         &#x27;    try {\n&#x27;
                         &#x27;      URL url = new &#x27;
                         &#x27;URL(mConfigEntity.DOWNLOAD_URL);\n&#x27;
                         &#x27;      //conn = (HttpURLConnection) &#x27;
                         &#x27;url.openConnection();\n&#x27;
                         &#x27;      conn = ConnectionHelp.handleConnection(url);\n&#x27;
                         &#x27;      if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;        Log.d(TAG, &quot;线程_&quot;\n&#x27;
                         &#x27;            + mConfigEntity.THREAD_ID\n&#x27;
                         &#x27;            + &quot;_正在下载【开始位置 : &quot;\n&#x27;
                         &#x27;            + mConfigEntity.START_LOCATION\n&#x27;
                         &#x27;            + &quot;，结束位置：&quot;\n&#x27;
                         &#x27;            + mConfigEntity.END_LOCATION\n&#x27;
                         &#x27;            + &quot;】&quot;);\n&#x27;
                         &#x27;        //在头里面请求下载开始位置和结束位置\n&#x27;
                         &#x27;        conn.setRequestProperty(&quot;Range&quot;,\n&#x27;
                         &#x27;            &quot;bytes=&quot; + mConfigEntity.START_LOCATION &#x27;
                         &#x27;+ &quot;-&quot; + mConfigEntity.END_LOCATION);\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        Log.w(TAG, &quot;该下载不支持断点，即将重新下载&quot;);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      conn = ConnectionHelp.setConnectParam(conn);\n&#x27;
                         &#x27;      &#x27;
                         &#x27;conn.setConnectTimeout(mConstance.CONNECT_TIME_OUT);\n&#x27;
                         &#x27;      &#x27;
                         &#x27;conn.setReadTimeout(mConstance.READ_TIME_OUT);  &#x27;
                         &#x27;//设置读取流的等待时间,必须设置该参数\n&#x27;
                         &#x27;      is = conn.getInputStream();\n&#x27;
                         &#x27;      //创建可设置位置的文件\n&#x27;
                         &#x27;      BufferedRandomAccessFile file =\n&#x27;
                         &#x27;          new &#x27;
                         &#x27;BufferedRandomAccessFile(mConfigEntity.TEMP_FILE, &#x27;
                         &#x27;&quot;rwd&quot;, BUF_SIZE);\n&#x27;
                         &#x27;      //设置文件长度\n&#x27;
                         &#x27;      file.seek(mConfigEntity.START_LOCATION);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;      byte[] buffer = new byte[BUF_SIZE];\n&#x27;
                         &#x27;      int len;\n&#x27;
                         &#x27;      //当前子线程的下载位置\n&#x27;
                         &#x27;      mChildCurrentLocation = &#x27;
                         &#x27;mConfigEntity.START_LOCATION;\n&#x27;
                         &#x27;      while ((len = is.read(buffer)) != -1) {\n&#x27;
                         &#x27;        if (mConstance.isCancel) {\n&#x27;
                         &#x27;          break;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (mConstance.isStop) {\n&#x27;
                         &#x27;          Log.i(TAG, &quot;stop&quot;);\n&#x27;
                         &#x27;          break;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        //把下载数据数据写入文件\n&#x27;
                         &#x27;        file.write(buffer, 0, len);\n&#x27;
                         &#x27;        progress(len);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      file.close();\n&#x27;
                         &#x27;      //close 为阻塞的，需要使用线程池来处理\n&#x27;
                         &#x27;      is.close();\n&#x27;
                         &#x27;      conn.disconnect();\n&#x27;
                         &#x27;      if (mConstance.isCancel) {\n&#x27;
                         &#x27;        return;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      //停止状态不需要删除记录文件\n&#x27;
                         &#x27;      if (mConstance.isStop) {\n&#x27;
                         &#x27;        return;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      //支持断点的处理\n&#x27;
                         &#x27;      if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;        Log.i(TAG, &quot;线程【&quot; + mConfigEntity.THREAD_ID + &#x27;
                         &#x27;&quot;】下载完毕&quot;);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;writeConfig(mConfigEntity.TEMP_FILE.getName() + &#x27;
                         &#x27;&quot;_state_&quot; + mConfigEntity.THREAD_ID,\n&#x27;
                         &#x27;            1 + &quot;&quot;);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;mListener.onChildComplete(mConfigEntity.END_LOCATION);\n&#x27;
                         &#x27;        mConstance.COMPLETE_THREAD_NUM++;\n&#x27;
                         &#x27;        if (mConstance.isComplete()) {\n&#x27;
                         &#x27;          File configFile = new File(mConfigFPath);\n&#x27;
                         &#x27;          if (configFile.exists()) {\n&#x27;
                         &#x27;            configFile.delete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          mConstance.isDownloading = false;\n&#x27;
                         &#x27;          mListener.onComplete();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        Log.i(TAG, &quot;下载任务完成&quot;);\n&#x27;
                         &#x27;        mConstance.isDownloading = false;\n&#x27;
                         &#x27;        mListener.onComplete();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    } catch (MalformedURLException e) {\n&#x27;
                         &#x27;      mConstance.FAIL_NUM++;\n&#x27;
                         &#x27;      failDownload(mConfigEntity, &#x27;
                         &#x27;mChildCurrentLocation, &quot;下载链接异常&quot;, e);\n&#x27;
                         &#x27;    } catch (IOException e) {\n&#x27;
                         &#x27;      mConstance.FAIL_NUM++;\n&#x27;
                         &#x27;      failDownload(mConfigEntity, &#x27;
                         &#x27;mChildCurrentLocation, &quot;下载失败【&quot; + &#x27;
                         &#x27;mConfigEntity.DOWNLOAD_URL + &quot;】&quot;,\n&#x27;
                         &#x27;          e);\n&#x27;
                         &#x27;    } catch (Exception e) {\n&#x27;
                         &#x27;      mConstance.FAIL_NUM++;\n&#x27;
                         &#x27;      failDownload(mConfigEntity, &#x27;
                         &#x27;mChildCurrentLocation, &quot;获取流失败&quot;, e);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 停止下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  protected void stop() {\n&#x27;
                         &#x27;    synchronized (LOCK) {\n&#x27;
                         &#x27;      try {\n&#x27;
                         &#x27;        if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;          mConstance.STOP_NUM++;\n&#x27;
                         &#x27;          String location = &#x27;
                         &#x27;String.valueOf(mChildCurrentLocation);\n&#x27;
                         &#x27;          Log.d(TAG, &quot;thread_&quot;\n&#x27;
                         &#x27;              + mConfigEntity.THREAD_ID\n&#x27;
                         &#x27;              + &quot;_stop, stop location ==&gt; &quot;\n&#x27;
                         &#x27;              + mChildCurrentLocation);\n&#x27;
                         &#x27;          &#x27;
                         &#x27;writeConfig(mConfigEntity.TEMP_FILE.getName() + &#x27;
                         &#x27;&quot;_record_&quot; + mConfigEntity.THREAD_ID,\n&#x27;
                         &#x27;              location);\n&#x27;
                         &#x27;          if (mConstance.isStop()) {\n&#x27;
                         &#x27;            Log.d(TAG, &quot;++++++++++++++++ onStop &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;            mConstance.isDownloading = false;\n&#x27;
                         &#x27;            &#x27;
                         &#x27;mListener.onStop(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          Log.d(TAG, &quot;++++++++++++++++ onStop &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;          mConstance.isDownloading = false;\n&#x27;
                         &#x27;          &#x27;
                         &#x27;mListener.onStop(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      } catch (IOException e) {\n&#x27;
                         &#x27;        e.printStackTrace();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 下载中\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void progress(long len) {\n&#x27;
                         &#x27;    synchronized (LOCK) {\n&#x27;
                         &#x27;      mChildCurrentLocation += len;\n&#x27;
                         &#x27;      mConstance.CURRENT_LOCATION += len;\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onProgress(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;      //mHandler.sendEmptyMessage(1);\n&#x27;
                         &#x27;      //mHandler.post(t);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  Handler mHandler = new &#x27;
                         &#x27;Handler(Looper.getMainLooper()) {\n&#x27;
                         &#x27;    @Override public void handleMessage(Message msg) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      super.handleMessage(msg);\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onProgress(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  };\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  Thread t = new Thread(new Runnable() {\n&#x27;
                         &#x27;    @Override public void run() {\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onProgress(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  });\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  //Handler handler = new Handler(){\n&#x27;
                         &#x27;  //  @Override public void handleMessage(Message &#x27;
                         &#x27;msg) {\n&#x27;
                         &#x27;  //    super.handleMessage(msg);\n&#x27;
                         &#x27;  //    &#x27;
                         &#x27;mListener.onProgress(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;  //  }\n&#x27;
                         &#x27;  //};\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  Thread thread = new Thread();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 取消下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  protected void cancel() {\n&#x27;
                         &#x27;    synchronized (LOCK) {\n&#x27;
                         &#x27;      if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;        mConstance.CANCEL_NUM++;\n&#x27;
                         &#x27;        Log.d(TAG, &quot;++++++++++ thread_&quot; + &#x27;
                         &#x27;mConfigEntity.THREAD_ID + &quot;_cancel ++++++++++&quot;);\n&#x27;
                         &#x27;        if (mConstance.isCancel()) {\n&#x27;
                         &#x27;          File configFile = new File(mConfigFPath);\n&#x27;
                         &#x27;          if (configFile.exists()) {\n&#x27;
                         &#x27;            configFile.delete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          if (mConfigEntity.TEMP_FILE.exists()) {\n&#x27;
                         &#x27;            mConfigEntity.TEMP_FILE.delete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          Log.d(TAG, &quot;++++++++++++++++ onCancel &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;          mConstance.isDownloading = false;\n&#x27;
                         &#x27;          mListener.onCancel();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        Log.d(TAG, &quot;++++++++++++++++ onCancel &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;        mConstance.isDownloading = false;\n&#x27;
                         &#x27;        mListener.onCancel();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 下载失败\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void &#x27;
                         &#x27;failDownload(DownloadUtil.ConfigEntity dEntity, long &#x27;
                         &#x27;currentLocation, String msg,\n&#x27;
                         &#x27;      Exception ex) {\n&#x27;
                         &#x27;    synchronized (LOCK) {\n&#x27;
                         &#x27;      try {\n&#x27;
                         &#x27;        mConstance.isDownloading = false;\n&#x27;
                         &#x27;        mConstance.isStop = true;\n&#x27;
                         &#x27;        if (ex != null) {\n&#x27;
                         &#x27;          Log.e(TAG, &#x27;
                         &#x27;CommonUtil.getPrintException(ex));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;          if (currentLocation != -1) {\n&#x27;
                         &#x27;            String location = &#x27;
                         &#x27;String.valueOf(currentLocation);\n&#x27;
                         &#x27;            writeConfig(dEntity.TEMP_FILE.getName() &#x27;
                         &#x27;+ &quot;_record_&quot; + dEntity.THREAD_ID, location);\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          if (mConstance.isFail()) {\n&#x27;
                         &#x27;            Log.d(TAG, &quot;++++++++++++++++ onFail &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;            mListener.onFail();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          Log.d(TAG, &quot;++++++++++++++++ onFail &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;          mListener.onFail();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      } catch (IOException e) {\n&#x27;
                         &#x27;        e.printStackTrace();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 将记录写入到配置文件\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void writeConfig(String key, String &#x27;
                         &#x27;record) throws IOException {\n&#x27;
                         &#x27;    File configFile = new File(mConfigFPath);\n&#x27;
                         &#x27;    Properties pro = &#x27;
                         &#x27;CommonUtil.loadConfig(configFile);\n&#x27;
                         &#x27;    pro.setProperty(key, record);\n&#x27;
                         &#x27;    CommonUtil.saveConfig(configFile, pro);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Copyright (C) 2016 &#x27;
                         &#x27;AriaLyy(https://github.com/AriaLyy/Aria)\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                         &#x27;(the &quot;License&quot;);\n&#x27;
                         &#x27; * you may not use this file except in compliance &#x27;
                         &#x27;with the License.\n&#x27;
                         &#x27; * You may obtain a copy of the License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *      http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;package com.arialyy.aria.core.task;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import android.os.Handler;\n&#x27;
                         &#x27;import android.os.Looper;\n&#x27;
                         &#x27;import android.os.Message;\n&#x27;
                         &#x27;import android.util.Log;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.arialyy.aria.util.BufferedRandomAccessFile;\n&#x27;
                         &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                         &#x27;import java.io.File;\n&#x27;
                         &#x27;import java.io.IOException;\n&#x27;
                         &#x27;import java.io.InputStream;\n&#x27;
                         &#x27;import java.io.RandomAccessFile;\n&#x27;
                         &#x27;import java.net.HttpURLConnection;\n&#x27;
                         &#x27;import java.net.MalformedURLException;\n&#x27;
                         &#x27;import java.net.URL;\n&#x27;
                         &#x27;import java.util.Properties;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Created by lyy on 2017/1/18.\n&#x27;
                         &#x27; * 下载线程\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;final class SingleThreadTask implements Runnable {\n&#x27;
                         &#x27;  private static final String TAG      = &#x27;
                         &#x27;&quot;SingleThreadTask&quot;;\n&#x27;
                         &#x27;  // TODO: 2017/2/22 不能使用1024 否则最大速度不能超过3m\n&#x27;
                         &#x27;  private static final int    BUF_SIZE = 8192;\n&#x27;
                         &#x27;  private DownloadUtil.ConfigEntity mConfigEntity;\n&#x27;
                         &#x27;  private String                    mConfigFPath;\n&#x27;
                         &#x27;  private              long   mChildCurrentLocation &#x27;
                         &#x27;= 0;\n&#x27;
                         &#x27;  private static final Object LOCK                  &#x27;
                         &#x27;= new Object();\n&#x27;
                         &#x27;  private IDownloadListener      mListener;\n&#x27;
                         &#x27;  private DownloadStateConstance mConstance;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  SingleThreadTask(DownloadStateConstance constance, &#x27;
                         &#x27;IDownloadListener listener,\n&#x27;
                         &#x27;      DownloadUtil.ConfigEntity downloadInfo) {\n&#x27;
                         &#x27;    mConstance = constance;\n&#x27;
                         &#x27;    mListener = listener;\n&#x27;
                         &#x27;    this.mConfigEntity = downloadInfo;\n&#x27;
                         &#x27;    if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;      mConfigFPath = downloadInfo.CONFIG_FILE_PATH;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void run() {\n&#x27;
                         &#x27;    HttpURLConnection conn = null;\n&#x27;
                         &#x27;    InputStream is = null;\n&#x27;
                         &#x27;    try {\n&#x27;
                         &#x27;      URL url = new &#x27;
                         &#x27;URL(mConfigEntity.DOWNLOAD_URL);\n&#x27;
                         &#x27;      //conn = (HttpURLConnection) &#x27;
                         &#x27;url.openConnection();\n&#x27;
                         &#x27;      conn = ConnectionHelp.handleConnection(url);\n&#x27;
                         &#x27;      if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;        Log.d(TAG, &quot;线程_&quot;\n&#x27;
                         &#x27;            + mConfigEntity.THREAD_ID\n&#x27;
                         &#x27;            + &quot;_正在下载【开始位置 : &quot;\n&#x27;
                         &#x27;            + mConfigEntity.START_LOCATION\n&#x27;
                         &#x27;            + &quot;，结束位置：&quot;\n&#x27;
                         &#x27;            + mConfigEntity.END_LOCATION\n&#x27;
                         &#x27;            + &quot;】&quot;);\n&#x27;
                         &#x27;        //在头里面请求下载开始位置和结束位置\n&#x27;
                         &#x27;        conn.setRequestProperty(&quot;Range&quot;,\n&#x27;
                         &#x27;            &quot;bytes=&quot; + mConfigEntity.START_LOCATION &#x27;
                         &#x27;+ &quot;-&quot; + mConfigEntity.END_LOCATION);\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        Log.w(TAG, &quot;该下载不支持断点，即将重新下载&quot;);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      conn = ConnectionHelp.setConnectParam(conn);\n&#x27;
                         &#x27;      &#x27;
                         &#x27;conn.setConnectTimeout(mConstance.CONNECT_TIME_OUT);\n&#x27;
                         &#x27;      &#x27;
                         &#x27;conn.setReadTimeout(mConstance.READ_TIME_OUT);  &#x27;
                         &#x27;//设置读取流的等待时间,必须设置该参数\n&#x27;
                         &#x27;      is = conn.getInputStream();\n&#x27;
                         &#x27;      //创建可设置位置的文件\n&#x27;
                         &#x27;      BufferedRandomAccessFile file =\n&#x27;
                         &#x27;          new &#x27;
                         &#x27;BufferedRandomAccessFile(mConfigEntity.TEMP_FILE, &#x27;
                         &#x27;&quot;rwd&quot;, BUF_SIZE);\n&#x27;
                         &#x27;      //设置文件长度\n&#x27;
                         &#x27;      file.seek(mConfigEntity.START_LOCATION);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;      byte[] buffer = new byte[BUF_SIZE];\n&#x27;
                         &#x27;      int len;\n&#x27;
                         &#x27;      //当前子线程的下载位置\n&#x27;
                         &#x27;      mChildCurrentLocation = &#x27;
                         &#x27;mConfigEntity.START_LOCATION;\n&#x27;
                         &#x27;      while ((len = is.read(buffer)) != -1) {\n&#x27;
                         &#x27;        if (mConstance.isCancel) {\n&#x27;
                         &#x27;          break;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (mConstance.isStop) {\n&#x27;
                         &#x27;          Log.i(TAG, &quot;stop&quot;);\n&#x27;
                         &#x27;          break;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        //把下载数据数据写入文件\n&#x27;
                         &#x27;        file.write(buffer, 0, len);\n&#x27;
                         &#x27;        progress(len);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      file.close();\n&#x27;
                         &#x27;      //close 为阻塞的，需要使用线程池来处理\n&#x27;
                         &#x27;      is.close();\n&#x27;
                         &#x27;      conn.disconnect();\n&#x27;
                         &#x27;      if (mConstance.isCancel) {\n&#x27;
                         &#x27;        return;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      //停止状态不需要删除记录文件\n&#x27;
                         &#x27;      if (mConstance.isStop) {\n&#x27;
                         &#x27;        return;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      //支持断点的处理\n&#x27;
                         &#x27;      if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;        Log.i(TAG, &quot;线程【&quot; + mConfigEntity.THREAD_ID + &#x27;
                         &#x27;&quot;】下载完毕&quot;);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;writeConfig(mConfigEntity.TEMP_FILE.getName() + &#x27;
                         &#x27;&quot;_state_&quot; + mConfigEntity.THREAD_ID,\n&#x27;
                         &#x27;            1 + &quot;&quot;);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;mListener.onChildComplete(mConfigEntity.END_LOCATION);\n&#x27;
                         &#x27;        mConstance.COMPLETE_THREAD_NUM++;\n&#x27;
                         &#x27;        if (mConstance.isComplete()) {\n&#x27;
                         &#x27;          File configFile = new File(mConfigFPath);\n&#x27;
                         &#x27;          if (configFile.exists()) {\n&#x27;
                         &#x27;            configFile.delete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          mConstance.isDownloading = false;\n&#x27;
                         &#x27;          mListener.onComplete();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        Log.i(TAG, &quot;下载任务完成&quot;);\n&#x27;
                         &#x27;        mConstance.isDownloading = false;\n&#x27;
                         &#x27;        mListener.onComplete();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    } catch (MalformedURLException e) {\n&#x27;
                         &#x27;      mConstance.FAIL_NUM++;\n&#x27;
                         &#x27;      failDownload(mConfigEntity, &#x27;
                         &#x27;mChildCurrentLocation, &quot;下载链接异常&quot;, e);\n&#x27;
                         &#x27;    } catch (IOException e) {\n&#x27;
                         &#x27;      mConstance.FAIL_NUM++;\n&#x27;
                         &#x27;      failDownload(mConfigEntity, &#x27;
                         &#x27;mChildCurrentLocation, &quot;下载失败【&quot; + &#x27;
                         &#x27;mConfigEntity.DOWNLOAD_URL + &quot;】&quot;,\n&#x27;
                         &#x27;          e);\n&#x27;
                         &#x27;    } catch (Exception e) {\n&#x27;
                         &#x27;      mConstance.FAIL_NUM++;\n&#x27;
                         &#x27;      failDownload(mConfigEntity, &#x27;
                         &#x27;mChildCurrentLocation, &quot;获取流失败&quot;, e);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 停止下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  protected void stop() {\n&#x27;
                         &#x27;    synchronized (LOCK) {\n&#x27;
                         &#x27;      try {\n&#x27;
                         &#x27;        if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;          mConstance.STOP_NUM++;\n&#x27;
                         &#x27;          String location = &#x27;
                         &#x27;String.valueOf(mChildCurrentLocation);\n&#x27;
                         &#x27;          Log.d(TAG, &quot;thread_&quot;\n&#x27;
                         &#x27;              + mConfigEntity.THREAD_ID\n&#x27;
                         &#x27;              + &quot;_stop, stop location ==&gt; &quot;\n&#x27;
                         &#x27;              + mChildCurrentLocation);\n&#x27;
                         &#x27;          &#x27;
                         &#x27;writeConfig(mConfigEntity.TEMP_FILE.getName() + &#x27;
                         &#x27;&quot;_record_&quot; + mConfigEntity.THREAD_ID,\n&#x27;
                         &#x27;              location);\n&#x27;
                         &#x27;          if (mConstance.isStop()) {\n&#x27;
                         &#x27;            Log.d(TAG, &quot;++++++++++++++++ onStop &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;            mConstance.isDownloading = false;\n&#x27;
                         &#x27;            &#x27;
                         &#x27;mListener.onStop(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          Log.d(TAG, &quot;++++++++++++++++ onStop &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;          mConstance.isDownloading = false;\n&#x27;
                         &#x27;          &#x27;
                         &#x27;mListener.onStop(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      } catch (IOException e) {\n&#x27;
                         &#x27;        e.printStackTrace();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 下载中\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void progress(long len) {\n&#x27;
                         &#x27;    synchronized (LOCK) {\n&#x27;
                         &#x27;      mChildCurrentLocation += len;\n&#x27;
                         &#x27;      mConstance.CURRENT_LOCATION += len;\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onProgress(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;      //mHandler.sendEmptyMessage(1);\n&#x27;
                         &#x27;      //mHandler.post(t);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  Handler mHandler = new &#x27;
                         &#x27;Handler(Looper.getMainLooper()) {\n&#x27;
                         &#x27;    @Override public void handleMessage(Message msg) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      super.handleMessage(msg);\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onProgress(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  };\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  Thread t = new Thread(new Runnable() {\n&#x27;
                         &#x27;    @Override public void run() {\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onProgress(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  });\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  //Handler handler = new Handler(){\n&#x27;
                         &#x27;  //  @Override public void handleMessage(Message &#x27;
                         &#x27;msg) {\n&#x27;
                         &#x27;  //    super.handleMessage(msg);\n&#x27;
                         &#x27;  //    &#x27;
                         &#x27;mListener.onProgress(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;  //  }\n&#x27;
                         &#x27;  //};\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  Thread thread = new Thread();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 取消下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  protected void cancel() {\n&#x27;
                         &#x27;    synchronized (LOCK) {\n&#x27;
                         &#x27;      if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;        mConstance.CANCEL_NUM++;\n&#x27;
                         &#x27;        Log.d(TAG, &quot;++++++++++ thread_&quot; + &#x27;
                         &#x27;mConfigEntity.THREAD_ID + &quot;_cancel ++++++++++&quot;);\n&#x27;
                         &#x27;        if (mConstance.isCancel()) {\n&#x27;
                         &#x27;          File configFile = new File(mConfigFPath);\n&#x27;
                         &#x27;          if (configFile.exists()) {\n&#x27;
                         &#x27;            configFile.delete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          if (mConfigEntity.TEMP_FILE.exists()) {\n&#x27;
                         &#x27;            mConfigEntity.TEMP_FILE.delete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          Log.d(TAG, &quot;++++++++++++++++ onCancel &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;          mConstance.isDownloading = false;\n&#x27;
                         &#x27;          mListener.onCancel();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        Log.d(TAG, &quot;++++++++++++++++ onCancel &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;        mConstance.isDownloading = false;\n&#x27;
                         &#x27;        mListener.onCancel();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 下载失败\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void &#x27;
                         &#x27;failDownload(DownloadUtil.ConfigEntity dEntity, long &#x27;
                         &#x27;currentLocation, String msg,\n&#x27;
                         &#x27;      Exception ex) {\n&#x27;
                         &#x27;    synchronized (LOCK) {\n&#x27;
                         &#x27;      try {\n&#x27;
                         &#x27;        mConstance.isDownloading = false;\n&#x27;
                         &#x27;        mConstance.isStop = true;\n&#x27;
                         &#x27;        if (ex != null) {\n&#x27;
                         &#x27;          Log.e(TAG, &#x27;
                         &#x27;CommonUtil.getPrintException(ex));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;          if (currentLocation != -1) {\n&#x27;
                         &#x27;            String location = &#x27;
                         &#x27;String.valueOf(currentLocation);\n&#x27;
                         &#x27;            writeConfig(dEntity.TEMP_FILE.getName() &#x27;
                         &#x27;+ &quot;_record_&quot; + dEntity.THREAD_ID, location);\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          if (mConstance.isFail()) {\n&#x27;
                         &#x27;            Log.d(TAG, &quot;++++++++++++++++ onFail &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;            mListener.onFail();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          Log.d(TAG, &quot;++++++++++++++++ onFail &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;          mListener.onFail();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      } catch (IOException e) {\n&#x27;
                         &#x27;        e.printStackTrace();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 将记录写入到配置文件\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void writeConfig(String key, String &#x27;
                         &#x27;record) throws IOException {\n&#x27;
                         &#x27;    File configFile = new File(mConfigFPath);\n&#x27;
                         &#x27;    Properties pro = &#x27;
                         &#x27;CommonUtil.loadConfig(configFile);\n&#x27;
                         &#x27;    pro.setProperty(key, record);\n&#x27;
                         &#x27;    CommonUtil.saveConfig(configFile, pro);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Copyright (C) 2016 &#x27;
                         &#x27;AriaLyy(https://github.com/AriaLyy/Aria)\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                         &#x27;(the &quot;License&quot;);\n&#x27;
                         &#x27; * you may not use this file except in compliance &#x27;
                         &#x27;with the License.\n&#x27;
                         &#x27; * You may obtain a copy of the License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *      http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;package com.arialyy.aria.core.task;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import android.os.Handler;\n&#x27;
                         &#x27;import android.os.Looper;\n&#x27;
                         &#x27;import android.os.Message;\n&#x27;
                         &#x27;import android.util.Log;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.arialyy.aria.util.BufferedRandomAccessFile;\n&#x27;
                         &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                         &#x27;import java.io.File;\n&#x27;
                         &#x27;import java.io.IOException;\n&#x27;
                         &#x27;import java.io.InputStream;\n&#x27;
                         &#x27;import java.io.RandomAccessFile;\n&#x27;
                         &#x27;import java.net.HttpURLConnection;\n&#x27;
                         &#x27;import java.net.MalformedURLException;\n&#x27;
                         &#x27;import java.net.URL;\n&#x27;
                         &#x27;import java.util.Properties;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Created by lyy on 2017/1/18.\n&#x27;
                         &#x27; * 下载线程\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;final class SingleThreadTask implements Runnable {\n&#x27;
                         &#x27;  private static final String TAG      = &#x27;
                         &#x27;&quot;SingleThreadTask&quot;;\n&#x27;
                         &#x27;  // TODO: 2017/2/22 不能使用1024 否则最大速度不能超过3m\n&#x27;
                         &#x27;  private static final int    BUF_SIZE = 8192;\n&#x27;
                         &#x27;  private DownloadUtil.ConfigEntity mConfigEntity;\n&#x27;
                         &#x27;  private String                    mConfigFPath;\n&#x27;
                         &#x27;  private              long   mChildCurrentLocation &#x27;
                         &#x27;= 0;\n&#x27;
                         &#x27;  private static final Object LOCK                  &#x27;
                         &#x27;= new Object();\n&#x27;
                         &#x27;  private IDownloadListener      mListener;\n&#x27;
                         &#x27;  private DownloadStateConstance mConstance;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  SingleThreadTask(DownloadStateConstance constance, &#x27;
                         &#x27;IDownloadListener listener,\n&#x27;
                         &#x27;      DownloadUtil.ConfigEntity downloadInfo) {\n&#x27;
                         &#x27;    mConstance = constance;\n&#x27;
                         &#x27;    mListener = listener;\n&#x27;
                         &#x27;    this.mConfigEntity = downloadInfo;\n&#x27;
                         &#x27;    if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;      mConfigFPath = downloadInfo.CONFIG_FILE_PATH;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void run() {\n&#x27;
                         &#x27;    HttpURLConnection conn = null;\n&#x27;
                         &#x27;    InputStream is = null;\n&#x27;
                         &#x27;    try {\n&#x27;
                         &#x27;      URL url = new &#x27;
                         &#x27;URL(mConfigEntity.DOWNLOAD_URL);\n&#x27;
                         &#x27;      //conn = (HttpURLConnection) &#x27;
                         &#x27;url.openConnection();\n&#x27;
                         &#x27;      conn = ConnectionHelp.handleConnection(url);\n&#x27;
                         &#x27;      if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;        Log.d(TAG, &quot;线程_&quot;\n&#x27;
                         &#x27;            + mConfigEntity.THREAD_ID\n&#x27;
                         &#x27;            + &quot;_正在下载【开始位置 : &quot;\n&#x27;
                         &#x27;            + mConfigEntity.START_LOCATION\n&#x27;
                         &#x27;            + &quot;，结束位置：&quot;\n&#x27;
                         &#x27;            + mConfigEntity.END_LOCATION\n&#x27;
                         &#x27;            + &quot;】&quot;);\n&#x27;
                         &#x27;        //在头里面请求下载开始位置和结束位置\n&#x27;
                         &#x27;        conn.setRequestProperty(&quot;Range&quot;,\n&#x27;
                         &#x27;            &quot;bytes=&quot; + mConfigEntity.START_LOCATION &#x27;
                         &#x27;+ &quot;-&quot; + mConfigEntity.END_LOCATION);\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        Log.w(TAG, &quot;该下载不支持断点，即将重新下载&quot;);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      conn = ConnectionHelp.setConnectParam(conn);\n&#x27;
                         &#x27;      &#x27;
                         &#x27;conn.setConnectTimeout(mConstance.CONNECT_TIME_OUT);\n&#x27;
                         &#x27;      &#x27;
                         &#x27;conn.setReadTimeout(mConstance.READ_TIME_OUT);  &#x27;
                         &#x27;//设置读取流的等待时间,必须设置该参数\n&#x27;
                         &#x27;      is = conn.getInputStream();\n&#x27;
                         &#x27;      //创建可设置位置的文件\n&#x27;
                         &#x27;      BufferedRandomAccessFile file =\n&#x27;
                         &#x27;          new &#x27;
                         &#x27;BufferedRandomAccessFile(mConfigEntity.TEMP_FILE, &#x27;
                         &#x27;&quot;rwd&quot;, BUF_SIZE);\n&#x27;
                         &#x27;      //设置文件长度\n&#x27;
                         &#x27;      file.seek(mConfigEntity.START_LOCATION);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;      byte[] buffer = new byte[BUF_SIZE];\n&#x27;
                         &#x27;      int len;\n&#x27;
                         &#x27;      //当前子线程的下载位置\n&#x27;
                         &#x27;      mChildCurrentLocation = &#x27;
                         &#x27;mConfigEntity.START_LOCATION;\n&#x27;
                         &#x27;      while ((len = is.read(buffer)) != -1) {\n&#x27;
                         &#x27;        if (mConstance.isCancel) {\n&#x27;
                         &#x27;          break;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (mConstance.isStop) {\n&#x27;
                         &#x27;          Log.i(TAG, &quot;stop&quot;);\n&#x27;
                         &#x27;          break;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        //把下载数据数据写入文件\n&#x27;
                         &#x27;        file.write(buffer, 0, len);\n&#x27;
                         &#x27;        progress(len);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      file.close();\n&#x27;
                         &#x27;      //close 为阻塞的，需要使用线程池来处理\n&#x27;
                         &#x27;      is.close();\n&#x27;
                         &#x27;      conn.disconnect();\n&#x27;
                         &#x27;      if (mConstance.isCancel) {\n&#x27;
                         &#x27;        return;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      //停止状态不需要删除记录文件\n&#x27;
                         &#x27;      if (mConstance.isStop) {\n&#x27;
                         &#x27;        return;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      //支持断点的处理\n&#x27;
                         &#x27;      if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;        Log.i(TAG, &quot;线程【&quot; + mConfigEntity.THREAD_ID + &#x27;
                         &#x27;&quot;】下载完毕&quot;);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;writeConfig(mConfigEntity.TEMP_FILE.getName() + &#x27;
                         &#x27;&quot;_state_&quot; + mConfigEntity.THREAD_ID,\n&#x27;
                         &#x27;            1 + &quot;&quot;);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;mListener.onChildComplete(mConfigEntity.END_LOCATION);\n&#x27;
                         &#x27;        mConstance.COMPLETE_THREAD_NUM++;\n&#x27;
                         &#x27;        if (mConstance.isComplete()) {\n&#x27;
                         &#x27;          File configFile = new File(mConfigFPath);\n&#x27;
                         &#x27;          if (configFile.exists()) {\n&#x27;
                         &#x27;            configFile.delete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          mConstance.isDownloading = false;\n&#x27;
                         &#x27;          mListener.onComplete();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        Log.i(TAG, &quot;下载任务完成&quot;);\n&#x27;
                         &#x27;        mConstance.isDownloading = false;\n&#x27;
                         &#x27;        mListener.onComplete();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    } catch (MalformedURLException e) {\n&#x27;
                         &#x27;      mConstance.FAIL_NUM++;\n&#x27;
                         &#x27;      failDownload(mConfigEntity, &#x27;
                         &#x27;mChildCurrentLocation, &quot;下载链接异常&quot;, e);\n&#x27;
                         &#x27;    } catch (IOException e) {\n&#x27;
                         &#x27;      mConstance.FAIL_NUM++;\n&#x27;
                         &#x27;      failDownload(mConfigEntity, &#x27;
                         &#x27;mChildCurrentLocation, &quot;下载失败【&quot; + &#x27;
                         &#x27;mConfigEntity.DOWNLOAD_URL + &quot;】&quot;,\n&#x27;
                         &#x27;          e);\n&#x27;
                         &#x27;    } catch (Exception e) {\n&#x27;
                         &#x27;      mConstance.FAIL_NUM++;\n&#x27;
                         &#x27;      failDownload(mConfigEntity, &#x27;
                         &#x27;mChildCurrentLocation, &quot;获取流失败&quot;, e);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 停止下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  protected void stop() {\n&#x27;
                         &#x27;    synchronized (LOCK) {\n&#x27;
                         &#x27;      try {\n&#x27;
                         &#x27;        if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;          mConstance.STOP_NUM++;\n&#x27;
                         &#x27;          String location = &#x27;
                         &#x27;String.valueOf(mChildCurrentLocation);\n&#x27;
                         &#x27;          Log.d(TAG, &quot;thread_&quot;\n&#x27;
                         &#x27;              + mConfigEntity.THREAD_ID\n&#x27;
                         &#x27;              + &quot;_stop, stop location ==&gt; &quot;\n&#x27;
                         &#x27;              + mChildCurrentLocation);\n&#x27;
                         &#x27;          &#x27;
                         &#x27;writeConfig(mConfigEntity.TEMP_FILE.getName() + &#x27;
                         &#x27;&quot;_record_&quot; + mConfigEntity.THREAD_ID,\n&#x27;
                         &#x27;              location);\n&#x27;
                         &#x27;          if (mConstance.isStop()) {\n&#x27;
                         &#x27;            Log.d(TAG, &quot;++++++++++++++++ onStop &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;            mConstance.isDownloading = false;\n&#x27;
                         &#x27;            &#x27;
                         &#x27;mListener.onStop(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          Log.d(TAG, &quot;++++++++++++++++ onStop &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;          mConstance.isDownloading = false;\n&#x27;
                         &#x27;          &#x27;
                         &#x27;mListener.onStop(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      } catch (IOException e) {\n&#x27;
                         &#x27;        e.printStackTrace();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 下载中\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void progress(long len) {\n&#x27;
                         &#x27;    synchronized (LOCK) {\n&#x27;
                         &#x27;      mChildCurrentLocation += len;\n&#x27;
                         &#x27;      mConstance.CURRENT_LOCATION += len;\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onProgress(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;      //mHandler.sendEmptyMessage(1);\n&#x27;
                         &#x27;      //mHandler.post(t);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  Handler mHandler = new &#x27;
                         &#x27;Handler(Looper.getMainLooper()) {\n&#x27;
                         &#x27;    @Override public void handleMessage(Message msg) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      super.handleMessage(msg);\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onProgress(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  };\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  Thread t = new Thread(new Runnable() {\n&#x27;
                         &#x27;    @Override public void run() {\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onProgress(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  });\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  //Handler handler = new Handler(){\n&#x27;
                         &#x27;  //  @Override public void handleMessage(Message &#x27;
                         &#x27;msg) {\n&#x27;
                         &#x27;  //    super.handleMessage(msg);\n&#x27;
                         &#x27;  //    &#x27;
                         &#x27;mListener.onProgress(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;  //  }\n&#x27;
                         &#x27;  //};\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  Thread thread = new Thread();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 取消下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  protected void cancel() {\n&#x27;
                         &#x27;    synchronized (LOCK) {\n&#x27;
                         &#x27;      if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;        mConstance.CANCEL_NUM++;\n&#x27;
                         &#x27;        Log.d(TAG, &quot;++++++++++ thread_&quot; + &#x27;
                         &#x27;mConfigEntity.THREAD_ID + &quot;_cancel ++++++++++&quot;);\n&#x27;
                         &#x27;        if (mConstance.isCancel()) {\n&#x27;
                         &#x27;          File configFile = new File(mConfigFPath);\n&#x27;
                         &#x27;          if (configFile.exists()) {\n&#x27;
                         &#x27;            configFile.delete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          if (mConfigEntity.TEMP_FILE.exists()) {\n&#x27;
                         &#x27;            mConfigEntity.TEMP_FILE.delete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          Log.d(TAG, &quot;++++++++++++++++ onCancel &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;          mConstance.isDownloading = false;\n&#x27;
                         &#x27;          mListener.onCancel();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        Log.d(TAG, &quot;++++++++++++++++ onCancel &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;        mConstance.isDownloading = false;\n&#x27;
                         &#x27;        mListener.onCancel();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 下载失败\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void &#x27;
                         &#x27;failDownload(DownloadUtil.ConfigEntity dEntity, long &#x27;
                         &#x27;currentLocation, String msg,\n&#x27;
                         &#x27;      Exception ex) {\n&#x27;
                         &#x27;    synchronized (LOCK) {\n&#x27;
                         &#x27;      try {\n&#x27;
                         &#x27;        mConstance.isDownloading = false;\n&#x27;
                         &#x27;        mConstance.isStop = true;\n&#x27;
                         &#x27;        if (ex != null) {\n&#x27;
                         &#x27;          Log.e(TAG, &#x27;
                         &#x27;CommonUtil.getPrintException(ex));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;          if (currentLocation != -1) {\n&#x27;
                         &#x27;            String location = &#x27;
                         &#x27;String.valueOf(currentLocation);\n&#x27;
                         &#x27;            writeConfig(dEntity.TEMP_FILE.getName() &#x27;
                         &#x27;+ &quot;_record_&quot; + dEntity.THREAD_ID, location);\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          if (mConstance.isFail()) {\n&#x27;
                         &#x27;            Log.d(TAG, &quot;++++++++++++++++ onFail &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;            mListener.onFail();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          Log.d(TAG, &quot;++++++++++++++++ onFail &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;          mListener.onFail();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      } catch (IOException e) {\n&#x27;
                         &#x27;        e.printStackTrace();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 将记录写入到配置文件\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void writeConfig(String key, String &#x27;
                         &#x27;record) throws IOException {\n&#x27;
                         &#x27;    File configFile = new File(mConfigFPath);\n&#x27;
                         &#x27;    Properties pro = &#x27;
                         &#x27;CommonUtil.loadConfig(configFile);\n&#x27;
                         &#x27;    pro.setProperty(key, record);\n&#x27;
                         &#x27;    CommonUtil.saveConfig(configFile, pro);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Copyright (C) 2016 &#x27;
                         &#x27;AriaLyy(https://github.com/AriaLyy/Aria)\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                         &#x27;(the &quot;License&quot;);\n&#x27;
                         &#x27; * you may not use this file except in compliance &#x27;
                         &#x27;with the License.\n&#x27;
                         &#x27; * You may obtain a copy of the License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *      http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;package com.arialyy.aria.core.task;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import android.os.Handler;\n&#x27;
                         &#x27;import android.os.Looper;\n&#x27;
                         &#x27;import android.os.Message;\n&#x27;
                         &#x27;import android.util.Log;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.arialyy.aria.util.BufferedRandomAccessFile;\n&#x27;
                         &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                         &#x27;import java.io.File;\n&#x27;
                         &#x27;import java.io.IOException;\n&#x27;
                         &#x27;import java.io.InputStream;\n&#x27;
                         &#x27;import java.io.RandomAccessFile;\n&#x27;
                         &#x27;import java.net.HttpURLConnection;\n&#x27;
                         &#x27;import java.net.MalformedURLException;\n&#x27;
                         &#x27;import java.net.URL;\n&#x27;
                         &#x27;import java.util.Properties;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Created by lyy on 2017/1/18.\n&#x27;
                         &#x27; * 下载线程\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;final class SingleThreadTask implements Runnable {\n&#x27;
                         &#x27;  private static final String TAG      = &#x27;
                         &#x27;&quot;SingleThreadTask&quot;;\n&#x27;
                         &#x27;  // TODO: 2017/2/22 不能使用1024 否则最大速度不能超过3m\n&#x27;
                         &#x27;  private static final int    BUF_SIZE = 8192;\n&#x27;
                         &#x27;  private DownloadUtil.ConfigEntity mConfigEntity;\n&#x27;
                         &#x27;  private String                    mConfigFPath;\n&#x27;
                         &#x27;  private              long   mChildCurrentLocation &#x27;
                         &#x27;= 0;\n&#x27;
                         &#x27;  private static final Object LOCK                  &#x27;
                         &#x27;= new Object();\n&#x27;
                         &#x27;  private IDownloadListener      mListener;\n&#x27;
                         &#x27;  private DownloadStateConstance mConstance;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  SingleThreadTask(DownloadStateConstance constance, &#x27;
                         &#x27;IDownloadListener listener,\n&#x27;
                         &#x27;      DownloadUtil.ConfigEntity downloadInfo) {\n&#x27;
                         &#x27;    mConstance = constance;\n&#x27;
                         &#x27;    mListener = listener;\n&#x27;
                         &#x27;    this.mConfigEntity = downloadInfo;\n&#x27;
                         &#x27;    if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;      mConfigFPath = downloadInfo.CONFIG_FILE_PATH;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void run() {\n&#x27;
                         &#x27;    HttpURLConnection conn = null;\n&#x27;
                         &#x27;    InputStream is = null;\n&#x27;
                         &#x27;    try {\n&#x27;
                         &#x27;      URL url = new &#x27;
                         &#x27;URL(mConfigEntity.DOWNLOAD_URL);\n&#x27;
                         &#x27;      //conn = (HttpURLConnection) &#x27;
                         &#x27;url.openConnection();\n&#x27;
                         &#x27;      conn = ConnectionHelp.handleConnection(url);\n&#x27;
                         &#x27;      if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;        Log.d(TAG, &quot;线程_&quot;\n&#x27;
                         &#x27;            + mConfigEntity.THREAD_ID\n&#x27;
                         &#x27;            + &quot;_正在下载【开始位置 : &quot;\n&#x27;
                         &#x27;            + mConfigEntity.START_LOCATION\n&#x27;
                         &#x27;            + &quot;，结束位置：&quot;\n&#x27;
                         &#x27;            + mConfigEntity.END_LOCATION\n&#x27;
                         &#x27;            + &quot;】&quot;);\n&#x27;
                         &#x27;        //在头里面请求下载开始位置和结束位置\n&#x27;
                         &#x27;        conn.setRequestProperty(&quot;Range&quot;,\n&#x27;
                         &#x27;            &quot;bytes=&quot; + mConfigEntity.START_LOCATION &#x27;
                         &#x27;+ &quot;-&quot; + mConfigEntity.END_LOCATION);\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        Log.w(TAG, &quot;该下载不支持断点，即将重新下载&quot;);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      conn = ConnectionHelp.setConnectParam(conn);\n&#x27;
                         &#x27;      &#x27;
                         &#x27;conn.setConnectTimeout(mConstance.CONNECT_TIME_OUT);\n&#x27;
                         &#x27;      &#x27;
                         &#x27;conn.setReadTimeout(mConstance.READ_TIME_OUT);  &#x27;
                         &#x27;//设置读取流的等待时间,必须设置该参数\n&#x27;
                         &#x27;      is = conn.getInputStream();\n&#x27;
                         &#x27;      //创建可设置位置的文件\n&#x27;
                         &#x27;      BufferedRandomAccessFile file =\n&#x27;
                         &#x27;          new &#x27;
                         &#x27;BufferedRandomAccessFile(mConfigEntity.TEMP_FILE, &#x27;
                         &#x27;&quot;rwd&quot;, BUF_SIZE);\n&#x27;
                         &#x27;      //设置文件长度\n&#x27;
                         &#x27;      file.seek(mConfigEntity.START_LOCATION);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;      byte[] buffer = new byte[BUF_SIZE];\n&#x27;
                         &#x27;      int len;\n&#x27;
                         &#x27;      //当前子线程的下载位置\n&#x27;
                         &#x27;      mChildCurrentLocation = &#x27;
                         &#x27;mConfigEntity.START_LOCATION;\n&#x27;
                         &#x27;      while ((len = is.read(buffer)) != -1) {\n&#x27;
                         &#x27;        if (mConstance.isCancel) {\n&#x27;
                         &#x27;          break;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (mConstance.isStop) {\n&#x27;
                         &#x27;          Log.i(TAG, &quot;stop&quot;);\n&#x27;
                         &#x27;          break;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        //把下载数据数据写入文件\n&#x27;
                         &#x27;        file.write(buffer, 0, len);\n&#x27;
                         &#x27;        progress(len);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      file.close();\n&#x27;
                         &#x27;      //close 为阻塞的，需要使用线程池来处理\n&#x27;
                         &#x27;      is.close();\n&#x27;
                         &#x27;      conn.disconnect();\n&#x27;
                         &#x27;      if (mConstance.isCancel) {\n&#x27;
                         &#x27;        return;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      //停止状态不需要删除记录文件\n&#x27;
                         &#x27;      if (mConstance.isStop) {\n&#x27;
                         &#x27;        return;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      //支持断点的处理\n&#x27;
                         &#x27;      if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;        Log.i(TAG, &quot;线程【&quot; + mConfigEntity.THREAD_ID + &#x27;
                         &#x27;&quot;】下载完毕&quot;);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;writeConfig(mConfigEntity.TEMP_FILE.getName() + &#x27;
                         &#x27;&quot;_state_&quot; + mConfigEntity.THREAD_ID,\n&#x27;
                         &#x27;            1 + &quot;&quot;);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;mListener.onChildComplete(mConfigEntity.END_LOCATION);\n&#x27;
                         &#x27;        mConstance.COMPLETE_THREAD_NUM++;\n&#x27;
                         &#x27;        if (mConstance.isComplete()) {\n&#x27;
                         &#x27;          File configFile = new File(mConfigFPath);\n&#x27;
                         &#x27;          if (configFile.exists()) {\n&#x27;
                         &#x27;            configFile.delete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          mConstance.isDownloading = false;\n&#x27;
                         &#x27;          mListener.onComplete();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        Log.i(TAG, &quot;下载任务完成&quot;);\n&#x27;
                         &#x27;        mConstance.isDownloading = false;\n&#x27;
                         &#x27;        mListener.onComplete();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    } catch (MalformedURLException e) {\n&#x27;
                         &#x27;      mConstance.FAIL_NUM++;\n&#x27;
                         &#x27;      failDownload(mConfigEntity, &#x27;
                         &#x27;mChildCurrentLocation, &quot;下载链接异常&quot;, e);\n&#x27;
                         &#x27;    } catch (IOException e) {\n&#x27;
                         &#x27;      mConstance.FAIL_NUM++;\n&#x27;
                         &#x27;      failDownload(mConfigEntity, &#x27;
                         &#x27;mChildCurrentLocation, &quot;下载失败【&quot; + &#x27;
                         &#x27;mConfigEntity.DOWNLOAD_URL + &quot;】&quot;,\n&#x27;
                         &#x27;          e);\n&#x27;
                         &#x27;    } catch (Exception e) {\n&#x27;
                         &#x27;      mConstance.FAIL_NUM++;\n&#x27;
                         &#x27;      failDownload(mConfigEntity, &#x27;
                         &#x27;mChildCurrentLocation, &quot;获取流失败&quot;, e);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 停止下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  protected void stop() {\n&#x27;
                         &#x27;    synchronized (LOCK) {\n&#x27;
                         &#x27;      try {\n&#x27;
                         &#x27;        if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;          mConstance.STOP_NUM++;\n&#x27;
                         &#x27;          String location = &#x27;
                         &#x27;String.valueOf(mChildCurrentLocation);\n&#x27;
                         &#x27;          Log.d(TAG, &quot;thread_&quot;\n&#x27;
                         &#x27;              + mConfigEntity.THREAD_ID\n&#x27;
                         &#x27;              + &quot;_stop, stop location ==&gt; &quot;\n&#x27;
                         &#x27;              + mChildCurrentLocation);\n&#x27;
                         &#x27;          &#x27;
                         &#x27;writeConfig(mConfigEntity.TEMP_FILE.getName() + &#x27;
                         &#x27;&quot;_record_&quot; + mConfigEntity.THREAD_ID,\n&#x27;
                         &#x27;              location);\n&#x27;
                         &#x27;          if (mConstance.isStop()) {\n&#x27;
                         &#x27;            Log.d(TAG, &quot;++++++++++++++++ onStop &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;            mConstance.isDownloading = false;\n&#x27;
                         &#x27;            &#x27;
                         &#x27;mListener.onStop(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          Log.d(TAG, &quot;++++++++++++++++ onStop &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;          mConstance.isDownloading = false;\n&#x27;
                         &#x27;          &#x27;
                         &#x27;mListener.onStop(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      } catch (IOException e) {\n&#x27;
                         &#x27;        e.printStackTrace();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 下载中\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void progress(long len) {\n&#x27;
                         &#x27;    synchronized (LOCK) {\n&#x27;
                         &#x27;      mChildCurrentLocation += len;\n&#x27;
                         &#x27;      mConstance.CURRENT_LOCATION += len;\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onProgress(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;      //mHandler.sendEmptyMessage(1);\n&#x27;
                         &#x27;      //mHandler.post(t);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  Handler mHandler = new &#x27;
                         &#x27;Handler(Looper.getMainLooper()) {\n&#x27;
                         &#x27;    @Override public void handleMessage(Message msg) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      super.handleMessage(msg);\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onProgress(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  };\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  Thread t = new Thread(new Runnable() {\n&#x27;
                         &#x27;    @Override public void run() {\n&#x27;
                         &#x27;      &#x27;
                         &#x27;mListener.onProgress(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  });\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  //Handler handler = new Handler(){\n&#x27;
                         &#x27;  //  @Override public void handleMessage(Message &#x27;
                         &#x27;msg) {\n&#x27;
                         &#x27;  //    super.handleMessage(msg);\n&#x27;
                         &#x27;  //    &#x27;
                         &#x27;mListener.onProgress(mConstance.CURRENT_LOCATION);\n&#x27;
                         &#x27;  //  }\n&#x27;
                         &#x27;  //};\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  Thread thread = new Thread();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 取消下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  protected void cancel() {\n&#x27;
                         &#x27;    synchronized (LOCK) {\n&#x27;
                         &#x27;      if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;        mConstance.CANCEL_NUM++;\n&#x27;
                         &#x27;        Log.d(TAG, &quot;++++++++++ thread_&quot; + &#x27;
                         &#x27;mConfigEntity.THREAD_ID + &quot;_cancel ++++++++++&quot;);\n&#x27;
                         &#x27;        if (mConstance.isCancel()) {\n&#x27;
                         &#x27;          File configFile = new File(mConfigFPath);\n&#x27;
                         &#x27;          if (configFile.exists()) {\n&#x27;
                         &#x27;            configFile.delete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          if (mConfigEntity.TEMP_FILE.exists()) {\n&#x27;
                         &#x27;            mConfigEntity.TEMP_FILE.delete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          Log.d(TAG, &quot;++++++++++++++++ onCancel &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;          mConstance.isDownloading = false;\n&#x27;
                         &#x27;          mListener.onCancel();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        Log.d(TAG, &quot;++++++++++++++++ onCancel &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;        mConstance.isDownloading = false;\n&#x27;
                         &#x27;        mListener.onCancel();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 下载失败\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void &#x27;
                         &#x27;failDownload(DownloadUtil.ConfigEntity dEntity, long &#x27;
                         &#x27;currentLocation, String msg,\n&#x27;
                         &#x27;      Exception ex) {\n&#x27;
                         &#x27;    synchronized (LOCK) {\n&#x27;
                         &#x27;      try {\n&#x27;
                         &#x27;        mConstance.isDownloading = false;\n&#x27;
                         &#x27;        mConstance.isStop = true;\n&#x27;
                         &#x27;        if (ex != null) {\n&#x27;
                         &#x27;          Log.e(TAG, &#x27;
                         &#x27;CommonUtil.getPrintException(ex));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (mConfigEntity.isSupportBreakpoint) {\n&#x27;
                         &#x27;          if (currentLocation != -1) {\n&#x27;
                         &#x27;            String location = &#x27;
                         &#x27;String.valueOf(currentLocation);\n&#x27;
                         &#x27;            writeConfig(dEntity.TEMP_FILE.getName() &#x27;
                         &#x27;+ &quot;_record_&quot; + dEntity.THREAD_ID, location);\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          if (mConstance.isFail()) {\n&#x27;
                         &#x27;            Log.d(TAG, &quot;++++++++++++++++ onFail &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;            mListener.onFail();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          Log.d(TAG, &quot;++++++++++++++++ onFail &#x27;
                         &#x27;+++++++++++++++++&quot;);\n&#x27;
                         &#x27;          mListener.onFail();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      } catch (IOException e) {\n&#x27;
                         &#x27;        e.printStackTrace();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 将记录写入到配置文件\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void writeConfig(String key, String &#x27;
                         &#x27;record) throws IOException {\n&#x27;
                         &#x27;    File configFile = new File(mConfigFPath);\n&#x27;
                         &#x27;    Properties pro = &#x27;
                         &#x27;CommonUtil.loadConfig(configFile);\n&#x27;
                         &#x27;    pro.setProperty(key, record);\n&#x27;
                         &#x27;    CommonUtil.saveConfig(configFile, pro);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        