<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>321 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;, &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}], &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public AbstractDirtyDataConsumer consumer;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private final ExecutorService executor = &#x27;
                         &#x27;Executors.newSingleThreadExecutor();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    private double errorLimitRate;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public static AbstractDirtyDataConsumer &#x27;
                           &#x27;consumer;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        manager.blockingInterval = &#x27;
                         &#x27;Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, &#x27;
                         &#x27;&quot;60&quot;));\n&#x27;
                         &#x27;        manager.consumer = &#x27;
                         &#x27;createConsumer(properties);\n&#x27;
                         &#x27;        manager.consumer.init(properties);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;manager.executor.execute(manager.consumer);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        manager.blockingInterval = &#x27;
                           &#x27;Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, &#x27;
                           &#x27;DEFAULT_BLOCKING_INTERVAL));\n&#x27;
                           &#x27;        manager.errorLimitRate = &#x27;
                           &#x27;Double.parseDouble(properties.getOrDefault(&quot;errorLimitRate&quot;, &#x27;
                           &#x27;DEFAULT_ERROR_LIMIT_RATE));\n&#x27;
                           &#x27;        consumer = createConsumer(properties);\n&#x27;
                           &#x27;        consumer.init(properties);\n&#x27;
                           &#x27;        consumer.setQueue(manager.queue);\n&#x27;
                           &#x27;        dirtyDataConsumer = new &#x27;
                           &#x27;ThreadPoolExecutor(MAX_POOL_SIZE_LIMIT, &#x27;
                           &#x27;MAX_POOL_SIZE_LIMIT, 0, TimeUnit.MILLISECONDS,\n&#x27;
                           &#x27;                new &#x27;
                           &#x27;LinkedBlockingQueue&lt;&gt;(MAX_TASK_QUEUE_SIZE), new &#x27;
                           &#x27;DTThreadFactory(&quot;dirtyDataConsumer&quot;), new &#x27;
                           &#x27;ThreadPoolExecutor.CallerRunsPolicy());\n&#x27;
                           &#x27;        dirtyDataConsumer.execute(consumer);\n&#x27;
                           &#x27;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;        manager.blockingInterval = &#x27;
                         &#x27;Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, &#x27;
                         &#x27;&quot;60&quot;));\n&#x27;
                         &#x27;        manager.consumer = &#x27;
                         &#x27;createConsumer(properties);\n&#x27;
                         &#x27;        manager.consumer.init(properties);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;manager.executor.execute(manager.consumer);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        manager.blockingInterval = &#x27;
                           &#x27;Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, &#x27;
                           &#x27;DEFAULT_BLOCKING_INTERVAL));\n&#x27;
                           &#x27;        manager.errorLimitRate = &#x27;
                           &#x27;Double.parseDouble(properties.getOrDefault(&quot;errorLimitRate&quot;, &#x27;
                           &#x27;DEFAULT_ERROR_LIMIT_RATE));\n&#x27;
                           &#x27;        consumer = createConsumer(properties);\n&#x27;
                           &#x27;        consumer.init(properties);\n&#x27;
                           &#x27;        consumer.setQueue(manager.queue);\n&#x27;
                           &#x27;        dirtyDataConsumer = new &#x27;
                           &#x27;ThreadPoolExecutor(MAX_POOL_SIZE_LIMIT, &#x27;
                           &#x27;MAX_POOL_SIZE_LIMIT, 0, TimeUnit.MILLISECONDS,\n&#x27;
                           &#x27;                new &#x27;
                           &#x27;LinkedBlockingQueue&lt;&gt;(MAX_TASK_QUEUE_SIZE), new &#x27;
                           &#x27;DTThreadFactory(&quot;dirtyDataConsumer&quot;), new &#x27;
                           &#x27;ThreadPoolExecutor.CallerRunsPolicy());\n&#x27;
                           &#x27;        dirtyDataConsumer.execute(consumer);\n&#x27;
                           &#x27;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;        manager.blockingInterval = &#x27;
                         &#x27;Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, &#x27;
                         &#x27;&quot;60&quot;));\n&#x27;
                         &#x27;        manager.consumer = &#x27;
                         &#x27;createConsumer(properties);\n&#x27;
                         &#x27;        manager.consumer.init(properties);\n&#x27;
                         &#x27;        manager.executor.execute(manager.consumer);\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;        manager.blockingInterval = &#x27;
                           &#x27;Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, &#x27;
                           &#x27;DEFAULT_BLOCKING_INTERVAL));\n&#x27;
                           &#x27;        manager.errorLimitRate = &#x27;
                           &#x27;Double.parseDouble(properties.getOrDefault(&quot;errorLimitRate&quot;, &#x27;
                           &#x27;DEFAULT_ERROR_LIMIT_RATE));\n&#x27;
                           &#x27;        consumer = createConsumer(properties);\n&#x27;
                           &#x27;        consumer.init(properties);\n&#x27;
                           &#x27;        consumer.setQueue(manager.queue);\n&#x27;
                           &#x27;        dirtyDataConsumer = new &#x27;
                           &#x27;ThreadPoolExecutor(MAX_POOL_SIZE_LIMIT, &#x27;
                           &#x27;MAX_POOL_SIZE_LIMIT, 0, TimeUnit.MILLISECONDS,\n&#x27;
                           &#x27;                new &#x27;
                           &#x27;LinkedBlockingQueue&lt;&gt;(MAX_TASK_QUEUE_SIZE), new &#x27;
                           &#x27;DTThreadFactory(&quot;dirtyDataConsumer&quot;), new &#x27;
                           &#x27;ThreadPoolExecutor.CallerRunsPolicy());\n&#x27;
                           &#x27;        dirtyDataConsumer.execute(consumer);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        if (!queue.isEmpty() &amp;&amp; checkConsumer()) {\n&#x27;
                         &#x27;            executor.shutdown();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        if (checkConsumer()) {\n&#x27;
                           &#x27;            LOG.info(&quot;dirty consumer is closing &#x27;
                           &#x27;...&quot;);\n&#x27;
                           &#x27;            consumer.close();\n&#x27;
                           &#x27;            dirtyDataConsumer.shutdownNow();\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        LOG.info(&quot;dirty consumer is closing ...&quot;);\n&#x27;
                         &#x27;        this.consumer.isRunning.compareAndSet(true, &#x27;
                         &#x27;false);\n&#x27;
                         &#x27;        executor.shutdownNow();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        if (!queue.isEmpty() &amp;&amp; checkConsumer()) {\n&#x27;
                         &#x27;            executor.shutdown();\n&#x27;
                         &#x27;        }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        if (checkConsumer()) {\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        this.consumer.isRunning.compareAndSet(true, &#x27;
                         &#x27;false);\n&#x27;
                         &#x27;        executor.shutdownNow();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;            consumer.close();\n&#x27;
                           &#x27;            dirtyDataConsumer.shutdownNow();\n&#x27;
                           &#x27;        }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;{\n&#x27;
                         &#x27;        if (!queue.isEmpty() &amp;&amp; checkConsumer()) {\n&#x27;
                         &#x27;            executor.shutdown();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        LOG.info(&quot;dirty consumer is closing ...&quot;);\n&#x27;
                         &#x27;        this.consumer.isRunning.compareAndSet(true, &#x27;
                         &#x27;false);\n&#x27;
                         &#x27;        executor.shutdownNow();\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;{\n&#x27;
                           &#x27;        if (checkConsumer()) {\n&#x27;
                           &#x27;            LOG.info(&quot;dirty consumer is closing &#x27;
                           &#x27;...&quot;);\n&#x27;
                           &#x27;            consumer.close();\n&#x27;
                           &#x27;            dirtyDataConsumer.shutdownNow();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;, &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    public AbstractDirtyDataConsumer consumer;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private final ExecutorService executor = &#x27;
                         &#x27;Executors.newSingleThreadExecutor();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    private double errorLimitRate;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public static AbstractDirtyDataConsumer &#x27;
                           &#x27;consumer;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;        manager.blockingInterval = &#x27;
                         &#x27;Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, &#x27;
                         &#x27;&quot;60&quot;));\n&#x27;
                         &#x27;        manager.consumer = &#x27;
                         &#x27;createConsumer(properties);\n&#x27;
                         &#x27;        manager.consumer.init(properties);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;manager.executor.execute(manager.consumer);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        manager.blockingInterval = &#x27;
                           &#x27;Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, &#x27;
                           &#x27;DEFAULT_BLOCKING_INTERVAL));\n&#x27;
                           &#x27;        manager.errorLimitRate = &#x27;
                           &#x27;Double.parseDouble(properties.getOrDefault(&quot;errorLimitRate&quot;, &#x27;
                           &#x27;DEFAULT_ERROR_LIMIT_RATE));\n&#x27;
                           &#x27;        consumer = createConsumer(properties);\n&#x27;
                           &#x27;        consumer.init(properties);\n&#x27;
                           &#x27;        consumer.setQueue(manager.queue);\n&#x27;
                           &#x27;        dirtyDataConsumer = new &#x27;
                           &#x27;ThreadPoolExecutor(MAX_POOL_SIZE_LIMIT, &#x27;
                           &#x27;MAX_POOL_SIZE_LIMIT, 0, TimeUnit.MILLISECONDS,\n&#x27;
                           &#x27;                new &#x27;
                           &#x27;LinkedBlockingQueue&lt;&gt;(MAX_TASK_QUEUE_SIZE), new &#x27;
                           &#x27;DTThreadFactory(&quot;dirtyDataConsumer&quot;), new &#x27;
                           &#x27;ThreadPoolExecutor.CallerRunsPolicy());\n&#x27;
                           &#x27;        dirtyDataConsumer.execute(consumer);\n&#x27;
                           &#x27;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;        if (!queue.isEmpty() &amp;&amp; checkConsumer()) {\n&#x27;
                         &#x27;            executor.shutdown();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        if (checkConsumer()) {\n&#x27;
                           &#x27;            LOG.info(&quot;dirty consumer is closing &#x27;
                           &#x27;...&quot;);\n&#x27;
                           &#x27;            consumer.close();\n&#x27;
                           &#x27;            dirtyDataConsumer.shutdownNow();\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;        LOG.info(&quot;dirty consumer is closing ...&quot;);\n&#x27;
                         &#x27;        this.consumer.isRunning.compareAndSet(true, &#x27;
                         &#x27;false);\n&#x27;
                         &#x27;        executor.shutdownNow();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;        manager.blockingInterval = &#x27;
                         &#x27;Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, &#x27;
                         &#x27;&quot;60&quot;));\n&#x27;
                         &#x27;        manager.consumer = &#x27;
                         &#x27;createConsumer(properties);\n&#x27;
                         &#x27;        manager.consumer.init(properties);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;manager.executor.execute(manager.consumer);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        manager.blockingInterval = &#x27;
                           &#x27;Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, &#x27;
                           &#x27;DEFAULT_BLOCKING_INTERVAL));\n&#x27;
                           &#x27;        manager.errorLimitRate = &#x27;
                           &#x27;Double.parseDouble(properties.getOrDefault(&quot;errorLimitRate&quot;, &#x27;
                           &#x27;DEFAULT_ERROR_LIMIT_RATE));\n&#x27;
                           &#x27;        consumer = createConsumer(properties);\n&#x27;
                           &#x27;        consumer.init(properties);\n&#x27;
                           &#x27;        consumer.setQueue(manager.queue);\n&#x27;
                           &#x27;        dirtyDataConsumer = new &#x27;
                           &#x27;ThreadPoolExecutor(MAX_POOL_SIZE_LIMIT, &#x27;
                           &#x27;MAX_POOL_SIZE_LIMIT, 0, TimeUnit.MILLISECONDS,\n&#x27;
                           &#x27;                new &#x27;
                           &#x27;LinkedBlockingQueue&lt;&gt;(MAX_TASK_QUEUE_SIZE), new &#x27;
                           &#x27;DTThreadFactory(&quot;dirtyDataConsumer&quot;), new &#x27;
                           &#x27;ThreadPoolExecutor.CallerRunsPolicy());\n&#x27;
                           &#x27;        dirtyDataConsumer.execute(consumer);\n&#x27;
                           &#x27;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;        if (!queue.isEmpty() &amp;&amp; checkConsumer()) {\n&#x27;
                         &#x27;            executor.shutdown();\n&#x27;
                         &#x27;        }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        if (checkConsumer()) {\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;        this.consumer.isRunning.compareAndSet(true, &#x27;
                         &#x27;false);\n&#x27;
                         &#x27;        executor.shutdownNow();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;            consumer.close();\n&#x27;
                           &#x27;            dirtyDataConsumer.shutdownNow();\n&#x27;
                           &#x27;        }\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;        manager.blockingInterval = &#x27;
                         &#x27;Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, &#x27;
                         &#x27;&quot;60&quot;));\n&#x27;
                         &#x27;        manager.consumer = &#x27;
                         &#x27;createConsumer(properties);\n&#x27;
                         &#x27;        manager.consumer.init(properties);\n&#x27;
                         &#x27;        manager.executor.execute(manager.consumer);\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;        manager.blockingInterval = &#x27;
                           &#x27;Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, &#x27;
                           &#x27;DEFAULT_BLOCKING_INTERVAL));\n&#x27;
                           &#x27;        manager.errorLimitRate = &#x27;
                           &#x27;Double.parseDouble(properties.getOrDefault(&quot;errorLimitRate&quot;, &#x27;
                           &#x27;DEFAULT_ERROR_LIMIT_RATE));\n&#x27;
                           &#x27;        consumer = createConsumer(properties);\n&#x27;
                           &#x27;        consumer.init(properties);\n&#x27;
                           &#x27;        consumer.setQueue(manager.queue);\n&#x27;
                           &#x27;        dirtyDataConsumer = new &#x27;
                           &#x27;ThreadPoolExecutor(MAX_POOL_SIZE_LIMIT, &#x27;
                           &#x27;MAX_POOL_SIZE_LIMIT, 0, TimeUnit.MILLISECONDS,\n&#x27;
                           &#x27;                new &#x27;
                           &#x27;LinkedBlockingQueue&lt;&gt;(MAX_TASK_QUEUE_SIZE), new &#x27;
                           &#x27;DTThreadFactory(&quot;dirtyDataConsumer&quot;), new &#x27;
                           &#x27;ThreadPoolExecutor.CallerRunsPolicy());\n&#x27;
                           &#x27;        dirtyDataConsumer.execute(consumer);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;{\n&#x27;
                         &#x27;        if (!queue.isEmpty() &amp;&amp; checkConsumer()) {\n&#x27;
                         &#x27;            executor.shutdown();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        LOG.info(&quot;dirty consumer is closing ...&quot;);\n&#x27;
                         &#x27;        this.consumer.isRunning.compareAndSet(true, &#x27;
                         &#x27;false);\n&#x27;
                         &#x27;        executor.shutdownNow();\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;{\n&#x27;
                           &#x27;        if (checkConsumer()) {\n&#x27;
                           &#x27;            LOG.info(&quot;dirty consumer is closing &#x27;
                           &#x27;...&quot;);\n&#x27;
                           &#x27;            consumer.close();\n&#x27;
                           &#x27;            dirtyDataConsumer.shutdownNow();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        