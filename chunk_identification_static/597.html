<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>597</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    597
                    <a href="596.html">prev</a>
                    <a href="598.html">next</a>
                    <a href="597_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_720e0d17e130e2a7face1e1a2aa8a2bdbccd35a2_redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;720e0d17e130e2a7face1e1a2aa8a2bdbccd35a2:redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;720e0d17e130e2a7face1e1a2aa8a2bdbccd35a2^1:redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;720e0d17e130e2a7face1e1a2aa8a2bdbccd35a2^2:redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;3df78d7ec37de341c5abef90d10a1abd2bd348f5:redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b], [bj], [b], [j], [j], [j]], subset: [[b], [b], [bj], [bj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.side.redis;
  20 
  21 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  22 import org.apache.flink.configuration.Configuration;
  23 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  24 import org.apache.flink.table.runtime.types.CRow;
  25 import org.apache.flink.types.Row;
  26 
  27 import com.dtstack.flink.sql.enums.ECacheContentType;
  28 import com.dtstack.flink.sql.side.AsyncReqRow;
  29 import com.dtstack.flink.sql.side.CacheMissVal;
  30 import com.dtstack.flink.sql.side.FieldInfo;
  31 import com.dtstack.flink.sql.side.JoinInfo;
  32 import com.dtstack.flink.sql.side.SideTableInfo;
  33 import com.dtstack.flink.sql.side.cache.CacheObj;
  34 import com.dtstack.flink.sql.side.redis.enums.RedisType;
  35 import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  36 import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  37 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
  38 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  39 import io.lettuce.core.RedisClient;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  40 import io.lettuce.core.RedisFuture;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  41 import io.lettuce.core.api.StatefulRedisConnection;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  42 import io.lettuce.core.api.async.RedisKeyAsyncCommands;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  43 import io.lettuce.core.api.async.RedisStringAsyncCommands;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  44 import io.lettuce.core.cluster.RedisClusterClient;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  45 import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  46 import org.apache.flink.api.java.typeutils.RowTypeInfo;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  47 import com.google.common.collect.Lists;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  48 import com.google.common.collect.Maps;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  49 import org.apache.flink.configuration.Configuration;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  50 import org.apache.flink.streaming.api.functions.async.ResultFuture;</span>
  51 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  52 import com.google.common.collect.Lists;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  53 import com.google.common.collect.Maps;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  54 import io.lettuce.core.KeyValue;</span>
  55 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  56 import io.lettuce.core.RedisClient;
  57 import io.lettuce.core.RedisFuture;
  58 import io.lettuce.core.api.StatefulRedisConnection;
  59 import io.lettuce.core.api.async.RedisHashAsyncCommands;
  60 import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  61 import io.lettuce.core.api.async.RedisStringAsyncCommands;
  62 import io.lettuce.core.cluster.RedisClusterClient;
  63 import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  64 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  65 import org.apache.commons.collections.MapUtils;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  66 import org.apache.commons.lang.StringUtils;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  67 import org.apache.flink.api.java.typeutils.RowTypeInfo;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  68 import com.google.common.collect.Maps;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  69 import org.apache.flink.configuration.Configuration;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  70 import org.apache.flink.streaming.api.functions.async.ResultFuture;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  71 import org.apache.flink.types.Row;</span>
  72 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  73 import com.google.common.collect.Lists;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  74 import com.google.common.collect.Maps;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  75 import org.apache.flink.configuration.Configuration;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  76 import org.apache.flink.streaming.api.functions.async.ResultFuture;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  77 import org.apache.flink.types.Row;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  78 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  79 import java.util.Collections;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  80 import java.util.List;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  81 import java.util.Map;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  82 import java.util.function.Consumer;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  83 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  84 public class RedisAsyncReqRow extends AsyncReqRow {</span>
  85 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  86 import org.apache.commons.lang3.StringUtils;</span>
  87 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  88 
  89 import java.util.Collections;
  90 import java.util.List;
  91 import java.util.Map;
  92 import java.util.function.Consumer;
  93 
  94 public class RedisAsyncReqRow extends AsyncReqRow {
  95 
  96     private static final long serialVersionUID = -2079908694523987738L;
  97 
  98     private RedisClient redisClient;
  99 
 100     private StatefulRedisConnection&lt;String, String&gt; connection;
 101 
 102     private RedisClusterClient clusterClient;
 103 
 104     private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
 105 
 106     private RedisKeyAsyncCommands&lt;String, String&gt; async;
 107 
 108     private RedisSideTableInfo redisSideTableInfo;
 109 
 110     private RedisSideReqRow redisSideReqRow;
 111 
<abbr title=" 112     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, SideTableInfo sideTableInfo) {"> 112     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList,🔵</abbr>
 113         super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
 114         redisSideReqRow = new RedisSideReqRow(super.sideInfo);
 115     }
 116 
 117     @Override
 118     public void open(Configuration parameters) throws Exception {
 119         super.open(parameters);
 120         redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
 121         buildRedisClient(redisSideTableInfo);
 122     }
 123 
 124     private void buildRedisClient(RedisSideTableInfo tableInfo){
 125         String url = redisSideTableInfo.getUrl();
 126         String password = redisSideTableInfo.getPassword();
 127         if (password != null){
 128             password = password + &quot;@&quot;;
 129         } else {
 130             password = &quot;&quot;;
 131         }
 132         String database = redisSideTableInfo.getDatabase();
 133         if (database == null){
 134             database = &quot;0&quot;;
 135         }
 136         switch (RedisType.parse(tableInfo.getRedisType())){
 137             case STANDALONE:
 138                 StringBuilder redisUri = new StringBuilder();
 139                 redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 140                 redisClient = RedisClient.create(redisUri.toString());
 141                 connection = redisClient.connect();
 142                 async = connection.async();
 143                 break;
 144             case SENTINEL:
 145                 StringBuilder sentinelUri = new StringBuilder();
 146                 sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 147                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 147                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.g🔵</abbr>
 148                 redisClient = RedisClient.create(sentinelUri.toString());
 149                 connection = redisClient.connect();
 150                 async = connection.async();
 151                 break;
 152             case CLUSTER:
 153                 StringBuilder clusterUri = new StringBuilder();
 154                 clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 155                 clusterClient = RedisClusterClient.create(clusterUri.toString());
 156                 clusterConnection = clusterClient.connect();
 157                 async = clusterConnection.async();
 158             default:
 159                 break;
 160         }
 161     }
 162 
 163     @Override
 164     public Row fillData(Row input, Object sideInput) {
 165         return redisSideReqRow.fillData(input, sideInput);
 166     }
 167 
 168     @Override
 169 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 170     public void asyncInvoke(Row input, ResultFuture&lt;Row&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 171         Row inputRow = Row.copy(input);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 172         Map&lt;String, Object&gt; refData = Maps.newHashMap();</span>
 173 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 174             Integer conValIndex = sideInfo.getEqualValIndex().get(i);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 175             Object equalObj = inputRow.getField(conValIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 176             if(equalObj == null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 177                 dealMissKey(inputRow, resultFuture);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 178                 return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 179             }</span>
 180 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 181     public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 182         CRow inputCopy = new CRow(input.row(),input.change());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 183         List&lt;String&gt; keyData = Lists.newLinkedList();</span>
 184 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 185         for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 186             Integer conValIndex = sideInfo.getEqualValIndex().get(i);
 187             Object equalObj = inputCopy.row().getField(conValIndex);
 188             if(equalObj == null){
 189                 dealMissKey(inputCopy, resultFuture);
 190                 return;
 191             }
 192             refData.put(sideInfo.getEqualFieldList().get(i), equalObj);
 193         }
 194 
 195         String key = buildCacheKey(refData);
 196         if(StringUtils.isBlank(key)){
 197             return;
 198         }
 199         if(openCache()){
 200             CacheObj val = getFromCache(key);
 201             if(val != null){
 202                 if(ECacheContentType.MissVal == val.getType()){
 203                     dealMissKey(inputCopy, resultFuture);
 204                     return;
 205                 }else if(ECacheContentType.MultiLine == val.getType()){
 206                     try {
 207                         Row row = fillData(inputCopy.row(), val.getContent());
 208                         resultFuture.complete(Collections.singleton(new CRow(row, input.change())));
 209                     } catch (Exception e) {
 210                         dealFillDataError(resultFuture, e, inputCopy);
 211                     }
 212                 }else{
<abbr title=" 213                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType());"> 213                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val🔵</abbr>
 214                     resultFuture.completeExceptionally(exception);
 215                 }
 216                 return;
 217             }
 218         }
 219 
 220 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 221         RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 222         future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 223             @Override</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 224             public void accept(Map&lt;String, String&gt; values) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 225                 if (MapUtils.isNotEmpty(values)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 226                     try {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 227                         Row row = fillData(inputRow, values);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 228                         dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 229                         resultFuture.complete(Collections.singleton(row));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 230                     } catch (Exception e) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 231                         dealFillDataError(resultFuture, e, inputRow);</span>
 232 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 233             dealMissKey(inputRow, resultFuture);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 234         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 235             RedisFuture&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt; future = ((RedisStringAsyncCommands) async).mget(values);"> 235             RedisFuture&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt; future = ((RedisStringAsyncCommands) async).mget(🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 236             future.thenAccept(new Consumer&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt;() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 237                 @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 238                 public void accept(List&lt;KeyValue&lt;String, String&gt;&gt; keyValues) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 239                     if (keyValues.size() != 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 240                         for (int i = 0; i &lt; keyValues.size(); i++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 241                             String[] splitKeys = keyValues.get(i).getKey().split(&quot;:&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 242                             keyValue.put(splitKeys[1], splitKeys[2]);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 243                             keyValue.put(splitKeys[3], keyValues.get(i).getValue());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 244                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 245                         try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 246                             Row row = fillData(inputRow, keyValue);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 247                             dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, keyValue));"> 247                             dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, keyValu🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 248                             resultFuture.complete(Collections.singleton(row));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 249                         } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 250                             dealFillDataError(resultFuture, e, inputRow);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 251                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 252                     } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 253                         dealMissKey(inputRow, resultFuture);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 254                         dealCacheData(key,CacheMissVal.getMissKeyObj());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 255                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 256                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 257             });</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 258         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 259     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 260 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 261     private String buildCacheKey(List&lt;String&gt; keyData) {</span>
 262 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 263         Map&lt;String, String&gt; keyValue = Maps.newHashMap();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 264         List&lt;String&gt; value = async.keys(key + &quot;:*&quot;).get();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 265         String[] values = value.toArray(new String[value.size()]);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 266         if (values.length == 0) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 267             dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 268         } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 269             RedisFuture&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt; future = ((RedisStringAsyncCommands) async).mget(values);"> 269             RedisFuture&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt; future = ((RedisStringAsyncCommands) async).mget(🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 270             future.thenAccept(new Consumer&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt;() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 271                 @Override</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 272                 public void accept(List&lt;KeyValue&lt;String, String&gt;&gt; keyValues) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 273                     if (keyValues.size() != 0) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 274                         for (int i = 0; i &lt; keyValues.size(); i++) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 275                             String[] splitKeys = StringUtils.split(keyValues.get(i).getKey(), &quot;:&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 276                             keyValue.put(splitKeys[1], splitKeys[2]);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 277                             keyValue.put(splitKeys[3], keyValues.get(i).getValue());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 278                         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 279                         try {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 280                             Row row = fillData(inputCopy.row(), keyValue);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 281                             dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, keyValue));"> 281                             dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, keyVal🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 282                             resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));"> 282                             resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 283                         } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 284                             dealFillDataError(resultFuture, e, inputCopy);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 285                         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 286                     } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 287                         dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 288                         dealCacheData(key, CacheMissVal.getMissKeyObj());</span>
 289 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 290                     }
 291                 } else {
 292                     dealMissKey(inputRow, resultFuture);
 293                     dealCacheData(key,CacheMissVal.getMissKeyObj());
 294                 }
 295             }
 296         });
 297     }
 298 
 299     private String buildCacheKey(Map&lt;String, Object&gt; refData) {
 300         StringBuilder keyBuilder = new StringBuilder(redisSideTableInfo.getTableName());
 301         List&lt;String&gt; primaryKeys = redisSideTableInfo.getPrimaryKeys();
 302         for(String primaryKey : primaryKeys){
 303             if(!refData.containsKey(primaryKey)){
 304                 return null;
 305             }
 306             keyBuilder.append(&quot;_&quot;).append(refData.get(primaryKey));
 307         }
 308         return keyBuilder.toString();
 309     }
 310 
 311     @Override
 312     public void close() throws Exception {
 313         super.close();
 314         if (connection != null){
 315             connection.close();
 316         }
 317         if (redisClient != null){
 318             redisClient.shutdown();
 319         }
 320         if (clusterConnection != null){
 321             clusterConnection.close();
 322         }
 323         if (clusterClient != null){
 324             clusterClient.shutdown();
 325         }
 326     }
 327 
 328 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.side.redis;
  20 
  21 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  22 import org.apache.flink.configuration.Configuration;
  23 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  24 import org.apache.flink.table.runtime.types.CRow;
  25 import org.apache.flink.types.Row;
  26 
  27 import com.dtstack.flink.sql.enums.ECacheContentType;
  28 import com.dtstack.flink.sql.side.AsyncReqRow;
  29 import com.dtstack.flink.sql.side.CacheMissVal;
  30 import com.dtstack.flink.sql.side.FieldInfo;
  31 import com.dtstack.flink.sql.side.JoinInfo;
  32 import com.dtstack.flink.sql.side.SideTableInfo;
  33 import com.dtstack.flink.sql.side.cache.CacheObj;
  34 import com.dtstack.flink.sql.side.redis.enums.RedisType;
  35 import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  36 import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  37 import com.google.common.collect.Maps;
  38 import io.lettuce.core.RedisClient;
  39 import io.lettuce.core.RedisFuture;
  40 import io.lettuce.core.api.StatefulRedisConnection;
  41 import io.lettuce.core.api.async.RedisHashAsyncCommands;
  42 import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  43 import io.lettuce.core.api.async.RedisStringAsyncCommands;
  44 import io.lettuce.core.cluster.RedisClusterClient;
  45 import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  46 import org.apache.commons.collections.MapUtils;
  47 import org.apache.commons.lang.StringUtils;
  48 import org.apache.commons.lang3.StringUtils;
  49 
  50 import java.util.Collections;
  51 import java.util.List;
  52 import java.util.Map;
  53 import java.util.function.Consumer;
  54 
  55 public class RedisAsyncReqRow extends AsyncReqRow {
  56 
  57     private static final long serialVersionUID = -2079908694523987738L;
  58 
  59     private RedisClient redisClient;
  60 
  61     private StatefulRedisConnection&lt;String, String&gt; connection;
  62 
  63     private RedisClusterClient clusterClient;
  64 
  65     private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  66 
  67     private RedisKeyAsyncCommands&lt;String, String&gt; async;
  68 
  69     private RedisSideTableInfo redisSideTableInfo;
  70 
  71     private RedisSideReqRow redisSideReqRow;
  72 
<abbr title="  73     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, SideTableInfo sideTableInfo) {">  73     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList,🔵</abbr>
  74         super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  75         redisSideReqRow = new RedisSideReqRow(super.sideInfo);
  76     }
  77 
  78     @Override
  79     public void open(Configuration parameters) throws Exception {
  80         super.open(parameters);
  81         redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  82         buildRedisClient(redisSideTableInfo);
  83     }
  84 
  85     private void buildRedisClient(RedisSideTableInfo tableInfo){
  86         String url = redisSideTableInfo.getUrl();
  87         String password = redisSideTableInfo.getPassword();
  88         if (password != null){
  89             password = password + &quot;@&quot;;
  90         } else {
  91             password = &quot;&quot;;
  92         }
  93         String database = redisSideTableInfo.getDatabase();
  94         if (database == null){
  95             database = &quot;0&quot;;
  96         }
  97         switch (RedisType.parse(tableInfo.getRedisType())){
  98             case STANDALONE:
  99                 StringBuilder redisUri = new StringBuilder();
 100                 redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 101                 redisClient = RedisClient.create(redisUri.toString());
 102                 connection = redisClient.connect();
 103                 async = connection.async();
 104                 break;
 105             case SENTINEL:
 106                 StringBuilder sentinelUri = new StringBuilder();
 107                 sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 108                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 108                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.g🔵</abbr>
 109                 redisClient = RedisClient.create(sentinelUri.toString());
 110                 connection = redisClient.connect();
 111                 async = connection.async();
 112                 break;
 113             case CLUSTER:
 114                 StringBuilder clusterUri = new StringBuilder();
 115                 clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 116                 clusterClient = RedisClusterClient.create(clusterUri.toString());
 117                 clusterConnection = clusterClient.connect();
 118                 async = clusterConnection.async();
 119             default:
 120                 break;
 121         }
 122     }
 123 
 124     @Override
 125     public Row fillData(Row input, Object sideInput) {
 126         return redisSideReqRow.fillData(input, sideInput);
 127     }
 128 
 129     @Override
 130 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 131     public void asyncInvoke(Row input, ResultFuture&lt;Row&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 132         Row inputRow = Row.copy(input);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 133         Map&lt;String, Object&gt; refData = Maps.newHashMap();</span>
 134 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 135     public void asyncInvoke(Row input, ResultFuture&lt;Row&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 136         Row inputRow = Row.copy(input);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 137         List&lt;String&gt; keyData = Lists.newLinkedList();</span>
 138 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 139     public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 140         CRow inputCopy = new CRow(input.row(),input.change());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 141         List&lt;String&gt; keyData = Lists.newLinkedList();</span>
 142 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 143         for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 144             Integer conValIndex = sideInfo.getEqualValIndex().get(i);
 145             Object equalObj = inputCopy.row().getField(conValIndex);
 146             if(equalObj == null){
 147                 dealMissKey(inputCopy, resultFuture);
 148                 return;
 149             }
 150             refData.put(sideInfo.getEqualFieldList().get(i), equalObj);
 151         }
 152 
 153         String key = buildCacheKey(refData);
 154         if(StringUtils.isBlank(key)){
 155             return;
 156         }
 157         if(openCache()){
 158             CacheObj val = getFromCache(key);
 159             if(val != null){
 160                 if(ECacheContentType.MissVal == val.getType()){
 161                     dealMissKey(inputCopy, resultFuture);
 162                     return;
 163                 }else if(ECacheContentType.MultiLine == val.getType()){
 164                     try {
 165                         Row row = fillData(inputCopy.row(), val.getContent());
 166                         resultFuture.complete(Collections.singleton(new CRow(row, input.change())));
 167                     } catch (Exception e) {
 168                         dealFillDataError(resultFuture, e, inputCopy);
 169                     }
 170                 }else{
<abbr title=" 171                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType());"> 171                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val🔵</abbr>
 172                     resultFuture.completeExceptionally(exception);
 173                 }
 174                 return;
 175             }
 176         }
 177 
 178 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 179         RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 180         future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {</span>
 181 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 182         Map&lt;String, String&gt; keyValue = Maps.newHashMap();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 183         List&lt;String&gt; value = async.keys(key + &quot;:*&quot;).get();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 184         String[] values = value.toArray(new String[value.size()]);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 185         if (values.length == 0){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 186             dealMissKey(inputRow, resultFuture);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 187         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 188             RedisFuture&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt; future = ((RedisStringAsyncCommands) async).mget(values);"> 188             RedisFuture&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt; future = ((RedisStringAsyncCommands) async).mget(🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 189             future.thenAccept(new Consumer&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt;() {</span>
 190 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 191         Map&lt;String, String&gt; keyValue = Maps.newHashMap();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 192         List&lt;String&gt; value = async.keys(key + &quot;:*&quot;).get();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 193         String[] values = value.toArray(new String[value.size()]);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 194         if (values.length == 0) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 195             dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 196         } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 197             RedisFuture&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt; future = ((RedisStringAsyncCommands) async).mget(values);"> 197             RedisFuture&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt; future = ((RedisStringAsyncCommands) async).mget(🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 198             future.thenAccept(new Consumer&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt;() {</span>
 199 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 200                 @Override
 201 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 202             public void accept(Map&lt;String, String&gt; values) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 203                 if (MapUtils.isNotEmpty(values)) {</span>
 204 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 205         if (values.length == 0){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 206             dealMissKey(inputRow, resultFuture);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 207         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 208             RedisFuture&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt; future = ((RedisStringAsyncCommands) async).mget(values);"> 208             RedisFuture&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt; future = ((RedisStringAsyncCommands) async).mget(🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 209             future.thenAccept(new Consumer&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt;() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 210                 @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 211                 public void accept(List&lt;KeyValue&lt;String, String&gt;&gt; keyValues) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 212                     if (keyValues.size() != 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 213                         for (int i = 0; i &lt; keyValues.size(); i++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 214                             String[] splitKeys = keyValues.get(i).getKey().split(&quot;:&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 215                             keyValue.put(splitKeys[1], splitKeys[2]);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 216                             keyValue.put(splitKeys[3], keyValues.get(i).getValue());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 217                         }</span>
 218 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 219                 public void accept(List&lt;KeyValue&lt;String, String&gt;&gt; keyValues) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 220                     if (keyValues.size() != 0) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 221                         for (int i = 0; i &lt; keyValues.size(); i++) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 222                             String[] splitKeys = StringUtils.split(keyValues.get(i).getKey(), &quot;:&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 223                             keyValue.put(splitKeys[1], splitKeys[2]);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 224                             keyValue.put(splitKeys[3], keyValues.get(i).getValue());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 225                         }</span>
 226 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 227                         try {
 228 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 229                         Row row = fillData(inputRow, values);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 230                         dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 231                         resultFuture.complete(Collections.singleton(row));</span>
 232 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 233             RedisFuture&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt; future = ((RedisStringAsyncCommands) async).mget(values);"> 233             RedisFuture&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt; future = ((RedisStringAsyncCommands) async).mget(🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 234             future.thenAccept(new Consumer&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt;() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 235                 @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 236                 public void accept(List&lt;KeyValue&lt;String, String&gt;&gt; keyValues) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 237                     if (keyValues.size() != 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 238                         for (int i = 0; i &lt; keyValues.size(); i++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 239                             String[] splitKeys = keyValues.get(i).getKey().split(&quot;:&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 240                             keyValue.put(splitKeys[1], splitKeys[2]);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 241                             keyValue.put(splitKeys[3], keyValues.get(i).getValue());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 242                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 243                         try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 244                             Row row = fillData(inputRow, keyValue);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 245                             dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, keyValue));"> 245                             dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, keyValu🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 246                             resultFuture.complete(Collections.singleton(row));</span>
 247 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 248                             Row row = fillData(inputCopy.row(), keyValue);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 249                             dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, keyValue));"> 249                             dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, keyVal🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 250                             resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));"> 250                             resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())🔵</abbr></span>
 251 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 252                         } catch (Exception e) {
 253                             dealFillDataError(resultFuture, e, inputCopy);
 254                         }
 255                     } else {
 256                         dealMissKey(inputCopy, resultFuture);
 257                         dealCacheData(key,CacheMissVal.getMissKeyObj());
 258                     }
 259                 }
 260             });
 261         }
 262 
 263     private String buildCacheKey(Map&lt;String, Object&gt; refData) {
 264         StringBuilder keyBuilder = new StringBuilder(redisSideTableInfo.getTableName());
 265         List&lt;String&gt; primaryKeys = redisSideTableInfo.getPrimaryKeys();
 266         for(String primaryKey : primaryKeys){
 267             if(!refData.containsKey(primaryKey)){
 268                 return null;
 269             }
 270             keyBuilder.append(&quot;_&quot;).append(refData.get(primaryKey));
 271         }
 272         return keyBuilder.toString();
 273     }
 274 
 275     @Override
 276     public void close() throws Exception {
 277         super.close();
 278         if (connection != null){
 279             connection.close();
 280         }
 281         if (redisClient != null){
 282             redisClient.shutdown();
 283         }
 284         if (clusterConnection != null){
 285             clusterConnection.close();
 286         }
 287         if (clusterClient != null){
 288             clusterClient.shutdown();
 289         }
 290     }
 291 
 292 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side.redis;
  19 
  20 import com.dtstack.flink.sql.enums.ECacheContentType;
  21 import com.dtstack.flink.sql.side.AsyncReqRow;
  22 import com.dtstack.flink.sql.side.CacheMissVal;
  23 import com.dtstack.flink.sql.side.FieldInfo;
  24 import com.dtstack.flink.sql.side.JoinInfo;
  25 import com.dtstack.flink.sql.side.SideTableInfo;
  26 import com.dtstack.flink.sql.side.cache.CacheObj;
  27 import com.dtstack.flink.sql.side.redis.enums.RedisType;
  28 import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  29 import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  30 import com.google.common.collect.Maps;
  31 import io.lettuce.core.RedisClient;
  32 import io.lettuce.core.RedisFuture;
  33 import io.lettuce.core.api.StatefulRedisConnection;
  34 import io.lettuce.core.api.async.RedisHashAsyncCommands;
  35 import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  36 import io.lettuce.core.api.async.RedisStringAsyncCommands;
  37 import io.lettuce.core.cluster.RedisClusterClient;
  38 import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  39 import java.util.Collections;
  40 import java.util.List;
  41 import java.util.Map;
  42 import java.util.function.Consumer;
  43 import org.apache.commons.collections.MapUtils;
  44 import org.apache.commons.lang.StringUtils;
  45 import org.apache.commons.lang3.StringUtils;
  46 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  47 import org.apache.flink.configuration.Configuration;
  48 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  49 import org.apache.flink.table.runtime.types.CRow;
  50 import org.apache.flink.types.Row;
  51 
  52 
  53 public class RedisAsyncReqRow extends AsyncReqRow {
  54     private static final long serialVersionUID = -2079908694523987738L;
  55 
  56     private RedisClient redisClient;
  57 
  58     private StatefulRedisConnection&lt;String, String&gt; connection;
  59 
  60     private RedisClusterClient clusterClient;
  61 
  62     private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  63 
  64     private RedisKeyAsyncCommands&lt;String, String&gt; async;
  65 
  66     private RedisSideTableInfo redisSideTableInfo;
  67 
  68     private RedisSideReqRow redisSideReqRow;
  69 
<abbr title="  70     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, SideTableInfo sideTableInfo) {">  70     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList,🔵</abbr>
  71         super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  72         redisSideReqRow = new RedisSideReqRow(super.sideInfo);
  73     }
  74 
  75     @Override
  76     public void open(Configuration parameters) throws Exception {
  77         super.open(parameters);
  78         redisSideTableInfo = ((RedisSideTableInfo) (sideInfo.getSideTableInfo()));
  79         buildRedisClient(redisSideTableInfo);
  80     }
  81 
  82     private void buildRedisClient(RedisSideTableInfo tableInfo) {
  83         String url = redisSideTableInfo.getUrl();
  84         String password = redisSideTableInfo.getPassword();
  85         if (password != null) {
  86             password = password + &quot;@&quot;;
  87         } else {
  88             password = &quot;&quot;;
  89         }
  90         String database = redisSideTableInfo.getDatabase();
  91         if (database == null) {
  92             database = &quot;0&quot;;
  93         }
  94         switch (RedisType.parse(tableInfo.getRedisType())) {
  95             case STANDALONE :
  96                 StringBuilder redisUri = new StringBuilder();
  97                 redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
  98                 redisClient = RedisClient.create(redisUri.toString());
  99                 connection = redisClient.connect();
 100                 async = connection.async();
 101                 break;
 102             case SENTINEL :
 103                 StringBuilder sentinelUri = new StringBuilder();
<abbr title=" 104                 sentinelUri.append(&quot;redis-sentinel://&quot;).append(password).append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 104                 sentinelUri.append(&quot;redis-sentinel://&quot;).append(password).append(url).append(&quot;/&quot;).append(d🔵</abbr>
 105                 redisClient = RedisClient.create(sentinelUri.toString());
 106                 connection = redisClient.connect();
 107                 async = connection.async();
 108                 break;
 109             case CLUSTER :
 110                 StringBuilder clusterUri = new StringBuilder();
 111                 clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 112                 clusterClient = RedisClusterClient.create(clusterUri.toString());
 113                 clusterConnection = clusterClient.connect();
 114                 async = clusterConnection.async();
 115             default :
 116                 break;
 117         }
 118     }
 119 
 120     @Override
 121     public Row fillData(Row input, Object sideInput) {
 122         return redisSideReqRow.fillData(input, sideInput);
 123     }
 124 
 125     @Override
 126     public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {
 127         CRow inputCopy = new CRow(input.row(), input.change());
 128         Map&lt;String, Object&gt; refData = Maps.newHashMap();
 129         for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 130             Integer conValIndex = sideInfo.getEqualValIndex().get(i);
 131             Object equalObj = inputCopy.row().getField(conValIndex);
 132             if (equalObj == null) {
 133                 dealMissKey(inputCopy, resultFuture);
 134                 return;
 135             }
 136             refData.put(sideInfo.getEqualFieldList().get(i), equalObj);
 137         }
 138         String key = buildCacheKey(refData);
 139         if (StringUtils.isBlank(key)) {
 140             return;
 141         }
 142         if (openCache()) {
 143             CacheObj val = getFromCache(key);
 144             if (val != null) {
 145                 if (ECacheContentType.MissVal == val.getType()) {
 146                     dealMissKey(inputCopy, resultFuture);
 147                     return;
 148                 } else if (ECacheContentType.MultiLine == val.getType()) {
 149                     try {
 150                         Row row = fillData(inputCopy.row(), val.getContent());
 151                         resultFuture.complete(Collections.singleton(new CRow(row, input.change())));
 152                     } catch (java.lang.Exception e) {
 153                         dealFillDataError(resultFuture, e, inputCopy);
 154                     }
 155                 } else {
<abbr title=" 156                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType());"> 156                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val🔵</abbr>
 157                     resultFuture.completeExceptionally(exception);
 158                 }
 159                 return;
 160             }
 161         }
 162         RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) (async)).hgetall(key);
 163         future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {
 164             @Override
 165             public void accept(Map&lt;String, String&gt; values) {
 166                 if (MapUtils.isNotEmpty(values)) {
 167                     try {
 168                         Row row = fillData(inputCopy.row(), values);
 169                         dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));
 170                         resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));
 171                     } catch (java.lang.Exception e) {
 172                         dealFillDataError(resultFuture, e, inputCopy);
 173                     }
 174                 } else {
 175                     dealMissKey(inputCopy, resultFuture);
 176                     dealCacheData(key, CacheMissVal.getMissKeyObj());
 177                 }
 178             }
 179         });
 180     }
 181 
 182     private String buildCacheKey(Map&lt;String, Object&gt; refData) {
 183         StringBuilder keyBuilder = new StringBuilder(redisSideTableInfo.getTableName());
 184         List&lt;String&gt; primaryKeys = redisSideTableInfo.getPrimaryKeys();
 185         for (String primaryKey : primaryKeys) {
 186             if (!refData.containsKey(primaryKey)) {
 187                 return null;
 188             }
 189             keyBuilder.append(&quot;_&quot;).append(refData.get(primaryKey));
 190         }
 191         return keyBuilder.toString();
 192     }
 193 
 194     @Override
 195     public void close() throws Exception {
 196         super.close();
 197         if (connection != null) {
 198             connection.close();
 199         }
 200         if (redisClient != null) {
 201             redisClient.shutdown();
 202         }
 203         if (clusterConnection != null) {
 204             clusterConnection.close();
 205         }
 206         if (clusterClient != null) {
 207             clusterClient.shutdown();
 208         }
 209     }
 210 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.side.redis;
  20  






  21  import com.dtstack.flink.sql.enums.ECacheContentType;
  22  import com.dtstack.flink.sql.side.*;





  23  import com.dtstack.flink.sql.side.cache.CacheObj;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  24 +import com.dtstack.flink.sql.side.redis.enums.RedisType;</span>
  25  import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  26  import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;


<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  27 -import io.lettuce.core.KeyValue;</span>
  28  import io.lettuce.core.RedisClient;
  29  import io.lettuce.core.RedisFuture;
  30  import io.lettuce.core.api.StatefulRedisConnection;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  31 +import io.lettuce.core.api.async.RedisHashAsyncCommands;</span>
  32  import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  33  import io.lettuce.core.api.async.RedisStringAsyncCommands;
  34  import io.lettuce.core.cluster.RedisClusterClient;
  35  import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  36 +import org.apache.commons.collections.MapUtils;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  37 +import org.apache.commons.lang.StringUtils;</span>
  38  import org.apache.flink.api.java.typeutils.RowTypeInfo;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  39 -import com.google.common.collect.Lists;</span>
  40  import com.google.common.collect.Maps;
  41  import org.apache.flink.configuration.Configuration;
  42  import org.apache.flink.streaming.api.functions.async.ResultFuture;
  43  import org.apache.flink.types.Row;

  44  
  45  import java.util.Collections;
  46  import java.util.List;
  47  import java.util.Map;
  48  import java.util.function.Consumer;
  49  
  50  public class RedisAsyncReqRow extends AsyncReqRow {
  51  
  52      private static final long serialVersionUID = -2079908694523987738L;
  53  
  54      private RedisClient redisClient;
  55  
  56      private StatefulRedisConnection&lt;String, String&gt; connection;
  57  
  58      private RedisClusterClient clusterClient;
  59  
  60      private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  61  
  62      private RedisKeyAsyncCommands&lt;String, String&gt; async;
  63  
  64      private RedisSideTableInfo redisSideTableInfo;
  65  
  66      private RedisSideReqRow redisSideReqRow;
  67  
<abbr title="  68      public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, SideTableInfo sideTableInfo) {">  68      public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, SideTabl🔵</abbr>
  69          super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  70          redisSideReqRow = new RedisSideReqRow(super.sideInfo);
  71      }
  72  
  73      @Override
  74      public void open(Configuration parameters) throws Exception {
  75          super.open(parameters);
  76          redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  77          buildRedisClient(redisSideTableInfo);
  78      }
  79  
  80      private void buildRedisClient(RedisSideTableInfo tableInfo){
  81          String url = redisSideTableInfo.getUrl();
  82          String password = redisSideTableInfo.getPassword();
  83          if (password != null){
  84              password = password + &quot;@&quot;;
  85          } else {
  86              password = &quot;&quot;;
  87          }
  88          String database = redisSideTableInfo.getDatabase();
  89          if (database == null){
  90              database = &quot;0&quot;;
  91          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  92 -        switch (tableInfo.getRedisType()){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  93 -            case 1:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  94 +        switch (RedisType.parse(tableInfo.getRedisType())){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  95 +            case STANDALONE:</span>
  96                  StringBuilder redisUri = new StringBuilder();
  97                  redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
  98                  redisClient = RedisClient.create(redisUri.toString());
  99                  connection = redisClient.connect();
 100                  async = connection.async();
 101                  break;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 102 -            case 2:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 103 +            case SENTINEL:</span>
 104                  StringBuilder sentinelUri = new StringBuilder();
 105                  sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 106                          .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 106                          .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterN🔵</abbr>
 107                  redisClient = RedisClient.create(sentinelUri.toString());
 108                  connection = redisClient.connect();
 109                  async = connection.async();
 110                  break;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 111 -            case 3:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 112 +            case CLUSTER:</span>
 113                  StringBuilder clusterUri = new StringBuilder();
 114                  clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 115                  clusterClient = RedisClusterClient.create(clusterUri.toString());
 116                  clusterConnection = clusterClient.connect();
 117                  async = clusterConnection.async();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 118 +            default:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 119 +                break;</span>
 120          }
 121      }
 122  
 123      @Override
 124      public Row fillData(Row input, Object sideInput) {
 125          return redisSideReqRow.fillData(input, sideInput);
 126      }
 127  
 128      @Override
 129      public void asyncInvoke(Row input, ResultFuture&lt;Row&gt; resultFuture) throws Exception {
 130          Row inputRow = Row.copy(input);


<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 131 -        List&lt;String&gt; keyData = Lists.newLinkedList();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 132 +        Map&lt;String, Object&gt; refData = Maps.newHashMap();</span>
 133          for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 134              Integer conValIndex = sideInfo.getEqualValIndex().get(i);
 135              Object equalObj = inputRow.getField(conValIndex);

 136              if(equalObj == null){
 137                  dealMissKey(inputRow, resultFuture);

 138                  return;
 139              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 140 -            String value = equalObj.toString();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 141 -            keyData.add(sideInfo.getEqualFieldList().get(i));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 142 -            keyData.add(value);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 143 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 144 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 145 -        String key = buildCacheKey(keyData);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 146 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 147 +            refData.put(sideInfo.getEqualFieldList().get(i), equalObj);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 148 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 149 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 150 +        String key = buildCacheKey(refData);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 151 +        if(StringUtils.isBlank(key)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 152 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 153 +        }</span>
 154          if(openCache()){
 155              CacheObj val = getFromCache(key);
 156              if(val != null){
 157                  if(ECacheContentType.MissVal == val.getType()){
 158                      dealMissKey(inputRow, resultFuture);

 159                      return;
 160                  }else if(ECacheContentType.MultiLine == val.getType()){
 161                      try {
 162                          Row row = fillData(inputRow, val.getContent());
 163                          resultFuture.complete(Collections.singleton(row));


 164                      } catch (Exception e) {
 165                          dealFillDataError(resultFuture, e, inputRow);

 166                      }
 167                  }else{
<abbr title=" 168                      RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType());"> 168                      RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType(🔵</abbr>
 169                      resultFuture.completeExceptionally(exception);
 170                  }
 171                  return;
 172              }
 173          }
 174  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 175 -        Map&lt;String, String&gt; keyValue = Maps.newHashMap();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 176 -        List&lt;String&gt; value = async.keys(key + &quot;:*&quot;).get();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 177 -        String[] values = value.toArray(new String[value.size()]);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 178 -        if (values.length == 0){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 179 -            dealMissKey(inputRow, resultFuture);</span>


<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 180 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 181 -            RedisFuture&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt; future = ((RedisStringAsyncCommands) async).mget(values);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 182 -            future.thenAccept(new Consumer&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt;() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 183 -                @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 184 -                public void accept(List&lt;KeyValue&lt;String, String&gt;&gt; keyValues) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 185 -                    if (keyValues.size() != 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 186 -                        for (int i = 0; i &lt; keyValues.size(); i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 187 -                            String[] splitKeys = keyValues.get(i).getKey().split(&quot;:&quot;);</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 188 -                            keyValue.put(splitKeys[1], splitKeys[2]);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 189 -                            keyValue.put(splitKeys[3], keyValues.get(i).getValue());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 190 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 191 -                        try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 192 -                            Row row = fillData(inputRow, keyValue);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 193 -                            dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, keyValue));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 194 -                            resultFuture.complete(Collections.singleton(row));</span>



<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 195 -                        } catch (Exception e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 196 -                            dealFillDataError(resultFuture, e, inputRow);</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 197 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 198 -                    } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 199 -                        dealMissKey(inputRow, resultFuture);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 200 -                        dealCacheData(key,CacheMissVal.getMissKeyObj());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 201 +        RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 202 +        future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 203 +            @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 204 +            public void accept(Map&lt;String, String&gt; values) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 205 +                if (MapUtils.isNotEmpty(values)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 206 +                    try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 207 +                        Row row = fillData(inputRow, values);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 208 +                        dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 209 +                        resultFuture.complete(Collections.singleton(row));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 210 +                    } catch (Exception e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 211 +                        dealFillDataError(resultFuture, e, inputRow);</span>
 212                      }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 213 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 214 +                    dealMissKey(inputRow, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 215 +                    dealCacheData(key,CacheMissVal.getMissKeyObj());</span>
 216                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 217 -            });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 218 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 219 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 220 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 221 -    private String buildCacheKey(List&lt;String&gt; keyData) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 222 -        String kv = String.join(&quot;:&quot;, keyData);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 223 -        String tableName = redisSideTableInfo.getTableName();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 224 -        StringBuilder preKey =  new StringBuilder();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 225 -        preKey.append(tableName).append(&quot;:&quot;).append(kv);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 226 -        return preKey.toString();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 227 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 228 +        });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 229 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 230 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 231 +    private String buildCacheKey(Map&lt;String, Object&gt; refData) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 232 +        StringBuilder keyBuilder = new StringBuilder(redisSideTableInfo.getTableName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 233 +        List&lt;String&gt; primaryKeys = redisSideTableInfo.getPrimaryKeys();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 234 +        for(String primaryKey : primaryKeys){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 235 +            if(!refData.containsKey(primaryKey)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 236 +                return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 237 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 238 +            keyBuilder.append(&quot;_&quot;).append(refData.get(primaryKey));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 239 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 240 +        return keyBuilder.toString();</span>
 241      }
 242  
 243      @Override
 244      public void close() throws Exception {
 245          super.close();
 246          if (connection != null){
 247              connection.close();
 248          }
 249          if (redisClient != null){
 250              redisClient.shutdown();
 251          }
 252          if (clusterConnection != null){
 253              clusterConnection.close();
 254          }
 255          if (clusterClient != null){
 256              clusterClient.shutdown();
 257          }
 258      }
 259  
 260  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.side.redis;
  20  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  21 +import org.apache.flink.api.java.typeutils.RowTypeInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  22 +import org.apache.flink.configuration.Configuration;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  23 +import org.apache.flink.streaming.api.functions.async.ResultFuture;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  24 +import org.apache.flink.table.runtime.types.CRow;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  25 +import org.apache.flink.types.Row;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  26 +</span>
  27  import com.dtstack.flink.sql.enums.ECacheContentType;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  28 -import com.dtstack.flink.sql.side.*;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 +import com.dtstack.flink.sql.side.AsyncReqRow;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  30 +import com.dtstack.flink.sql.side.CacheMissVal;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  31 +import com.dtstack.flink.sql.side.FieldInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  32 +import com.dtstack.flink.sql.side.JoinInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  33 +import com.dtstack.flink.sql.side.SideTableInfo;</span>
  34  import com.dtstack.flink.sql.side.cache.CacheObj;

  35  import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  36  import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  37 +import com.google.common.collect.Lists;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  38 +import com.google.common.collect.Maps;</span>
  39  import io.lettuce.core.KeyValue;
  40  import io.lettuce.core.RedisClient;
  41  import io.lettuce.core.RedisFuture;
  42  import io.lettuce.core.api.StatefulRedisConnection;

  43  import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  44  import io.lettuce.core.api.async.RedisStringAsyncCommands;
  45  import io.lettuce.core.cluster.RedisClusterClient;
  46  import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;


<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  47 -import org.apache.flink.api.java.typeutils.RowTypeInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  48 -import com.google.common.collect.Lists;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  49 -import com.google.common.collect.Maps;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  50 -import org.apache.flink.configuration.Configuration;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  51 -import org.apache.flink.streaming.api.functions.async.ResultFuture;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  52 -import org.apache.flink.types.Row;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  53 +import org.apache.commons.lang3.StringUtils;</span>
  54  
  55  import java.util.Collections;
  56  import java.util.List;
  57  import java.util.Map;
  58  import java.util.function.Consumer;
  59  
  60  public class RedisAsyncReqRow extends AsyncReqRow {
  61  
  62      private static final long serialVersionUID = -2079908694523987738L;
  63  
  64      private RedisClient redisClient;
  65  
  66      private StatefulRedisConnection&lt;String, String&gt; connection;
  67  
  68      private RedisClusterClient clusterClient;
  69  
  70      private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  71  
  72      private RedisKeyAsyncCommands&lt;String, String&gt; async;
  73  
  74      private RedisSideTableInfo redisSideTableInfo;
  75  
  76      private RedisSideReqRow redisSideReqRow;
  77  
<abbr title="  78      public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, SideTableInfo sideTableInfo) {">  78      public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, SideTabl🔵</abbr>
  79          super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  80          redisSideReqRow = new RedisSideReqRow(super.sideInfo);
  81      }
  82  
  83      @Override
  84      public void open(Configuration parameters) throws Exception {
  85          super.open(parameters);
  86          redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  87          buildRedisClient(redisSideTableInfo);
  88      }
  89  
  90      private void buildRedisClient(RedisSideTableInfo tableInfo){
  91          String url = redisSideTableInfo.getUrl();
  92          String password = redisSideTableInfo.getPassword();
  93          if (password != null){
  94              password = password + &quot;@&quot;;
  95          } else {
  96              password = &quot;&quot;;
  97          }
  98          String database = redisSideTableInfo.getDatabase();
  99          if (database == null){
 100              database = &quot;0&quot;;
 101          }
 102          switch (tableInfo.getRedisType()){
 103              case 1:


 104                  StringBuilder redisUri = new StringBuilder();
 105                  redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 106                  redisClient = RedisClient.create(redisUri.toString());
 107                  connection = redisClient.connect();
 108                  async = connection.async();
 109                  break;
 110              case 2:

 111                  StringBuilder sentinelUri = new StringBuilder();
 112                  sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 113                          .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 113                          .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterN🔵</abbr>
 114                  redisClient = RedisClient.create(sentinelUri.toString());
 115                  connection = redisClient.connect();
 116                  async = connection.async();
 117                  break;
 118              case 3:

 119                  StringBuilder clusterUri = new StringBuilder();
 120                  clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 121                  clusterClient = RedisClusterClient.create(clusterUri.toString());
 122                  clusterConnection = clusterClient.connect();
 123                  async = clusterConnection.async();


 124          }
 125      }
 126  
 127      @Override
 128      public Row fillData(Row input, Object sideInput) {
 129          return redisSideReqRow.fillData(input, sideInput);
 130      }
 131  
 132      @Override
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 133 -    public void asyncInvoke(Row input, ResultFuture&lt;Row&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 134 -        Row inputRow = Row.copy(input);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 135 +    public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 136 +        CRow inputCopy = new CRow(input.row(),input.change());</span>
 137          List&lt;String&gt; keyData = Lists.newLinkedList();

 138          for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 139              Integer conValIndex = sideInfo.getEqualValIndex().get(i);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 140 -            Object equalObj = inputRow.getField(conValIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 141 +            Object equalObj = inputCopy.row().getField(conValIndex);</span>
 142              if(equalObj == null){
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 143 -                dealMissKey(inputRow, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 144 +                dealMissKey(inputCopy, resultFuture);</span>
 145                  return;
 146              }
 147              String value = equalObj.toString();
 148              keyData.add(sideInfo.getEqualFieldList().get(i));
 149              keyData.add(value);
 150          }
 151  
 152          String key = buildCacheKey(keyData);
 153  







 154          if(openCache()){
 155              CacheObj val = getFromCache(key);
 156              if(val != null){
 157                  if(ECacheContentType.MissVal == val.getType()){
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 158 -                    dealMissKey(inputRow, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 159 +                    dealMissKey(inputCopy, resultFuture);</span>
 160                      return;
 161                  }else if(ECacheContentType.MultiLine == val.getType()){
 162                      try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 163 -                        Row row = fillData(inputRow, val.getContent());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 164 -                        resultFuture.complete(Collections.singleton(row));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 165 +                        Row row = fillData(inputCopy.row(), val.getContent());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 166 +                        resultFuture.complete(Collections.singleton(new CRow(row, input.change())));</span>
 167                      } catch (Exception e) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 168 -                        dealFillDataError(resultFuture, e, inputRow);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 169 +                        dealFillDataError(resultFuture, e, inputCopy);</span>
 170                      }
 171                  }else{
<abbr title=" 172                      RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType());"> 172                      RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType(🔵</abbr>
 173                      resultFuture.completeExceptionally(exception);
 174                  }
 175                  return;
 176              }
 177          }
 178  
 179          Map&lt;String, String&gt; keyValue = Maps.newHashMap();
 180          List&lt;String&gt; value = async.keys(key + &quot;:*&quot;).get();
 181          String[] values = value.toArray(new String[value.size()]);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 182 -        if (values.length == 0){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 183 -            dealMissKey(inputRow, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 184 +        if (values.length == 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 185 +            dealMissKey(inputCopy, resultFuture);</span>
 186          } else {
 187              RedisFuture&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt; future = ((RedisStringAsyncCommands) async).mget(values);
 188              future.thenAccept(new Consumer&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt;() {
 189                  @Override
 190                  public void accept(List&lt;KeyValue&lt;String, String&gt;&gt; keyValues) {
 191                      if (keyValues.size() != 0) {
 192                          for (int i = 0; i &lt; keyValues.size(); i++) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 193 -                            String[] splitKeys = keyValues.get(i).getKey().split(&quot;:&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 194 +                            String[] splitKeys = StringUtils.split(keyValues.get(i).getKey(), &quot;:&quot;);</span>
 195                              keyValue.put(splitKeys[1], splitKeys[2]);
 196                              keyValue.put(splitKeys[3], keyValues.get(i).getValue());
 197                          }
 198                          try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 199 -                            Row row = fillData(inputRow, keyValue);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 200 -                            dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, keyValue));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 201 -                            resultFuture.complete(Collections.singleton(row));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 202 +                            Row row = fillData(inputCopy.row(), keyValue);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 203 +                            dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, keyValue));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 204 +                            resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));</span>
 205                          } catch (Exception e) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 206 -                            dealFillDataError(resultFuture, e, inputRow);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 207 +                            dealFillDataError(resultFuture, e, inputCopy);</span>
 208                          }
 209                      } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 210 -                        dealMissKey(inputRow, resultFuture);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 211 -                        dealCacheData(key,CacheMissVal.getMissKeyObj());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 212 +                        dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 213 +                        dealCacheData(key, CacheMissVal.getMissKeyObj());</span>









 214                      }



 215                  }
 216              });
 217          }
 218      }
 219  
 220      private String buildCacheKey(List&lt;String&gt; keyData) {
 221          String kv = String.join(&quot;:&quot;, keyData);
 222          String tableName = redisSideTableInfo.getTableName();
 223          StringBuilder preKey =  new StringBuilder();
 224          preKey.append(tableName).append(&quot;:&quot;).append(kv);
 225          return preKey.toString();














 226      }
 227  
 228      @Override
 229      public void close() throws Exception {
 230          super.close();
 231          if (connection != null){
 232              connection.close();
 233          }
 234          if (redisClient != null){
 235              redisClient.shutdown();
 236          }
 237          if (clusterConnection != null){
 238              clusterConnection.close();
 239          }
 240          if (clusterClient != null){
 241              clusterClient.shutdown();
 242          }
 243      }
 244  
 245  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            