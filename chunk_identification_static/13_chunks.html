<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>13 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;package com.arialyy.aria.core.common.ftp;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.arialyy.aria.core.upload.UploadEntity;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * &#x27;
                         &#x27;FTP文件上传拦截器，如果远端已有同名文件，可使用该拦截器控制覆盖文件或修改该文件上传到服务器端端文件名\n&#x27;
                         &#x27; * simple\n&#x27;
                         &#x27; * &lt;pre&gt;\n&#x27;
                         &#x27; *   &lt;code&gt;\n&#x27;
                         &#x27; *     Aria.upload(this)\n&#x27;
                         &#x27; *         .loadFtp(FILE_PATH)\n&#x27;
                         &#x27; *         .setUploadUrl(URL)\n&#x27;
                         &#x27; *         .setUploadInterceptor(\n&#x27;
                         &#x27; *             new IFtpUploadInterceptor() {\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *               @Override\n&#x27;
                         &#x27; *               public FtpInterceptHandler &#x27;
                         &#x27;onIntercept(UploadEntity entity, List&lt;String&gt; &#x27;
                         &#x27;fileList) {\n&#x27;
                         &#x27; *                 FtpInterceptHandler.Builder &#x27;
                         &#x27;builder = new FtpInterceptHandler.Builder();\n&#x27;
                         &#x27; *                 builder.coverServerFile();\n&#x27;
                         &#x27; *                 //builder.resetFileName(&quot;test&quot;);\n&#x27;
                         &#x27; *                 return builder.build();\n&#x27;
                         &#x27; *               }\n&#x27;
                         &#x27; *          })\n&#x27;
                         &#x27; *         .start();\n&#x27;
                         &#x27; *   &lt;/code&gt;\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * &lt;/pre&gt;\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public interface IFtpUploadInterceptor {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理拦截事件\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @param entity 上传信息实体\n&#x27;
                         &#x27;   * @param fileList ftp服务器端remotePath下的文件列表\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  FtpInterceptHandler onIntercept(UploadEntity &#x27;
                         &#x27;entity, List&lt;String&gt; fileList);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;package com.arialyy.aria.core.inf;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.arialyy.aria.core.upload.UploadEntity;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * &#x27;
                           &#x27;FTP文件上传拦截器，如果远端已有同名文件，可使用该拦截器控制覆盖文件或修改该文件上传到服务器端端文件名\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public interface IFtpUploadInterceptor {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 如果ftp服务器端已经有同名文件，控制是否覆盖远端的同名文件；\n&#x27;
                           &#x27;   * 如果你不希望覆盖远端文件，可以使用{@link &#x27;
                           &#x27;#resetFileName(UploadEntity, List)}\n&#x27;
                           &#x27;   * 如果使用者同时实现{@link #resetFileName(UploadEntity, &#x27;
                           &#x27;List)}和{@link #coverServerFile(UploadEntity,\n&#x27;
                           &#x27;   * List)}，将优先使用{@link &#x27;
                           &#x27;#resetFileName(UploadEntity, List)}\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param entity 上传信息实体\n&#x27;
                           &#x27;   * @param fileList ftp服务器端remotePath下的文件列表\n&#x27;
                           &#x27;   * @return {@code true} &#x27;
                           &#x27;如果ftp服务器端已经有同名文件，覆盖服务器端的同名文件\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  boolean coverServerFile(UploadEntity entity, &#x27;
                           &#x27;List&lt;String&gt; fileList);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 如果ftp服务器端已经有同名文件，修改该文件上传到远端的文件名，该操作不会修改本地文件名\n&#x27;
                           &#x27;   * 如果你希望覆盖远端的同名文件，可以使用{@link &#x27;
                           &#x27;#coverServerFile(UploadEntity, List)}\n&#x27;
                           &#x27;   * 如果使用者同时实现{@link #resetFileName(UploadEntity, &#x27;
                           &#x27;List)}和{@link #coverServerFile(UploadEntity,\n&#x27;
                           &#x27;   * List)}，将优先使用{@link &#x27;
                           &#x27;#resetFileName(UploadEntity, List)}\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param entity 上传信息实体\n&#x27;
                           &#x27;   * @param fileList ftp服务器端remotePath下的文件列表\n&#x27;
                           &#x27;   * @return 该文件上传到远端的新的文件名\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  String resetFileName(UploadEntity entity, &#x27;
                           &#x27;List&lt;String&gt; fileList);\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;package com.arialyy.aria.core.common.ftp;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.arialyy.aria.core.upload.UploadEntity;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * &#x27;
                         &#x27;FTP文件上传拦截器，如果远端已有同名文件，可使用该拦截器控制覆盖文件或修改该文件上传到服务器端端文件名\n&#x27;
                         &#x27; * simple\n&#x27;
                         &#x27; * &lt;pre&gt;\n&#x27;
                         &#x27; *   &lt;code&gt;\n&#x27;
                         &#x27; *     Aria.upload(this)\n&#x27;
                         &#x27; *         .loadFtp(FILE_PATH)\n&#x27;
                         &#x27; *         .setUploadUrl(URL)\n&#x27;
                         &#x27; *         .setUploadInterceptor(\n&#x27;
                         &#x27; *             new IFtpUploadInterceptor() {\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *               @Override\n&#x27;
                         &#x27; *               public FtpInterceptHandler &#x27;
                         &#x27;onIntercept(UploadEntity entity, List&lt;String&gt; &#x27;
                         &#x27;fileList) {\n&#x27;
                         &#x27; *                 FtpInterceptHandler.Builder &#x27;
                         &#x27;builder = new FtpInterceptHandler.Builder();\n&#x27;
                         &#x27; *                 builder.coverServerFile();\n&#x27;
                         &#x27; *                 //builder.resetFileName(&quot;test&quot;);\n&#x27;
                         &#x27; *                 return builder.build();\n&#x27;
                         &#x27; *               }\n&#x27;
                         &#x27; *          })\n&#x27;
                         &#x27; *         .start();\n&#x27;
                         &#x27; *   &lt;/code&gt;\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * &lt;/pre&gt;\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public interface IFtpUploadInterceptor {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理拦截事件\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @param entity 上传信息实体\n&#x27;
                         &#x27;   * @param fileList ftp服务器端remotePath下的文件列表\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  FtpInterceptHandler onIntercept(UploadEntity &#x27;
                         &#x27;entity, List&lt;String&gt; fileList);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;package com.arialyy.aria.core.inf;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.arialyy.aria.core.upload.UploadEntity;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * &#x27;
                           &#x27;FTP文件上传拦截器，如果远端已有同名文件，可使用该拦截器控制覆盖文件或修改该文件上传到服务器端端文件名\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public interface IFtpUploadInterceptor {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 如果ftp服务器端已经有同名文件，控制是否覆盖远端的同名文件；\n&#x27;
                           &#x27;   * 如果你不希望覆盖远端文件，可以使用{@link &#x27;
                           &#x27;#resetFileName(UploadEntity, List)}\n&#x27;
                           &#x27;   * 如果使用者同时实现{@link #resetFileName(UploadEntity, &#x27;
                           &#x27;List)}和{@link #coverServerFile(UploadEntity,\n&#x27;
                           &#x27;   * List)}，将优先使用{@link &#x27;
                           &#x27;#resetFileName(UploadEntity, List)}\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param entity 上传信息实体\n&#x27;
                           &#x27;   * @param fileList ftp服务器端remotePath下的文件列表\n&#x27;
                           &#x27;   * @return {@code true} &#x27;
                           &#x27;如果ftp服务器端已经有同名文件，覆盖服务器端的同名文件\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  boolean coverServerFile(UploadEntity entity, &#x27;
                           &#x27;List&lt;String&gt; fileList);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 如果ftp服务器端已经有同名文件，修改该文件上传到远端的文件名，该操作不会修改本地文件名\n&#x27;
                           &#x27;   * 如果你希望覆盖远端的同名文件，可以使用{@link &#x27;
                           &#x27;#coverServerFile(UploadEntity, List)}\n&#x27;
                           &#x27;   * 如果使用者同时实现{@link #resetFileName(UploadEntity, &#x27;
                           &#x27;List)}和{@link #coverServerFile(UploadEntity,\n&#x27;
                           &#x27;   * List)}，将优先使用{@link &#x27;
                           &#x27;#resetFileName(UploadEntity, List)}\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param entity 上传信息实体\n&#x27;
                           &#x27;   * @param fileList ftp服务器端remotePath下的文件列表\n&#x27;
                           &#x27;   * @return 该文件上传到远端的新的文件名\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  String resetFileName(UploadEntity entity, &#x27;
                           &#x27;List&lt;String&gt; fileList);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;package com.arialyy.aria.core.common.ftp;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.arialyy.aria.core.upload.UploadEntity;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * &#x27;
                         &#x27;FTP文件上传拦截器，如果远端已有同名文件，可使用该拦截器控制覆盖文件或修改该文件上传到服务器端端文件名\n&#x27;
                         &#x27; * simple\n&#x27;
                         &#x27; * &lt;pre&gt;\n&#x27;
                         &#x27; *   &lt;code&gt;\n&#x27;
                         &#x27; *     Aria.upload(this)\n&#x27;
                         &#x27; *         .loadFtp(FILE_PATH)\n&#x27;
                         &#x27; *         .setUploadUrl(URL)\n&#x27;
                         &#x27; *         .setUploadInterceptor(\n&#x27;
                         &#x27; *             new IFtpUploadInterceptor() {\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *               @Override\n&#x27;
                         &#x27; *               public FtpInterceptHandler &#x27;
                         &#x27;onIntercept(UploadEntity entity, List&lt;String&gt; &#x27;
                         &#x27;fileList) {\n&#x27;
                         &#x27; *                 FtpInterceptHandler.Builder &#x27;
                         &#x27;builder = new FtpInterceptHandler.Builder();\n&#x27;
                         &#x27; *                 builder.coverServerFile();\n&#x27;
                         &#x27; *                 //builder.resetFileName(&quot;test&quot;);\n&#x27;
                         &#x27; *                 return builder.build();\n&#x27;
                         &#x27; *               }\n&#x27;
                         &#x27; *          })\n&#x27;
                         &#x27; *         .start();\n&#x27;
                         &#x27; *   &lt;/code&gt;\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * &lt;/pre&gt;\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public interface IFtpUploadInterceptor {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理拦截事件\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @param entity 上传信息实体\n&#x27;
                         &#x27;   * @param fileList ftp服务器端remotePath下的文件列表\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  FtpInterceptHandler onIntercept(UploadEntity &#x27;
                         &#x27;entity, List&lt;String&gt; fileList);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;package com.arialyy.aria.core.inf;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.arialyy.aria.core.upload.UploadEntity;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * &#x27;
                           &#x27;FTP文件上传拦截器，如果远端已有同名文件，可使用该拦截器控制覆盖文件或修改该文件上传到服务器端端文件名\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public interface IFtpUploadInterceptor {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 如果ftp服务器端已经有同名文件，控制是否覆盖远端的同名文件；\n&#x27;
                           &#x27;   * 如果你不希望覆盖远端文件，可以使用{@link &#x27;
                           &#x27;#resetFileName(UploadEntity, List)}\n&#x27;
                           &#x27;   * 如果使用者同时实现{@link #resetFileName(UploadEntity, &#x27;
                           &#x27;List)}和{@link #coverServerFile(UploadEntity,\n&#x27;
                           &#x27;   * List)}，将优先使用{@link &#x27;
                           &#x27;#resetFileName(UploadEntity, List)}\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param entity 上传信息实体\n&#x27;
                           &#x27;   * @param fileList ftp服务器端remotePath下的文件列表\n&#x27;
                           &#x27;   * @return {@code true} &#x27;
                           &#x27;如果ftp服务器端已经有同名文件，覆盖服务器端的同名文件\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  boolean coverServerFile(UploadEntity entity, &#x27;
                           &#x27;List&lt;String&gt; fileList);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 如果ftp服务器端已经有同名文件，修改该文件上传到远端的文件名，该操作不会修改本地文件名\n&#x27;
                           &#x27;   * 如果你希望覆盖远端的同名文件，可以使用{@link &#x27;
                           &#x27;#coverServerFile(UploadEntity, List)}\n&#x27;
                           &#x27;   * 如果使用者同时实现{@link #resetFileName(UploadEntity, &#x27;
                           &#x27;List)}和{@link #coverServerFile(UploadEntity,\n&#x27;
                           &#x27;   * List)}，将优先使用{@link &#x27;
                           &#x27;#resetFileName(UploadEntity, List)}\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param entity 上传信息实体\n&#x27;
                           &#x27;   * @param fileList ftp服务器端remotePath下的文件列表\n&#x27;
                           &#x27;   * @return 该文件上传到远端的新的文件名\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  String resetFileName(UploadEntity entity, &#x27;
                           &#x27;List&lt;String&gt; fileList);\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;package com.arialyy.aria.core.common.ftp;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.arialyy.aria.core.upload.UploadEntity;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * &#x27;
                         &#x27;FTP文件上传拦截器，如果远端已有同名文件，可使用该拦截器控制覆盖文件或修改该文件上传到服务器端端文件名\n&#x27;
                         &#x27; * simple\n&#x27;
                         &#x27; * &lt;pre&gt;\n&#x27;
                         &#x27; *   &lt;code&gt;\n&#x27;
                         &#x27; *     Aria.upload(this)\n&#x27;
                         &#x27; *         .loadFtp(FILE_PATH)\n&#x27;
                         &#x27; *         .setUploadUrl(URL)\n&#x27;
                         &#x27; *         .setUploadInterceptor(\n&#x27;
                         &#x27; *             new IFtpUploadInterceptor() {\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *               @Override\n&#x27;
                         &#x27; *               public FtpInterceptHandler &#x27;
                         &#x27;onIntercept(UploadEntity entity, List&lt;String&gt; &#x27;
                         &#x27;fileList) {\n&#x27;
                         &#x27; *                 FtpInterceptHandler.Builder &#x27;
                         &#x27;builder = new FtpInterceptHandler.Builder();\n&#x27;
                         &#x27; *                 builder.coverServerFile();\n&#x27;
                         &#x27; *                 //builder.resetFileName(&quot;test&quot;);\n&#x27;
                         &#x27; *                 return builder.build();\n&#x27;
                         &#x27; *               }\n&#x27;
                         &#x27; *          })\n&#x27;
                         &#x27; *         .start();\n&#x27;
                         &#x27; *   &lt;/code&gt;\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * &lt;/pre&gt;\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public interface IFtpUploadInterceptor {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理拦截事件\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @param entity 上传信息实体\n&#x27;
                         &#x27;   * @param fileList ftp服务器端remotePath下的文件列表\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  FtpInterceptHandler onIntercept(UploadEntity &#x27;
                         &#x27;entity, List&lt;String&gt; fileList);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;package com.arialyy.aria.core.inf;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.arialyy.aria.core.upload.UploadEntity;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * &#x27;
                           &#x27;FTP文件上传拦截器，如果远端已有同名文件，可使用该拦截器控制覆盖文件或修改该文件上传到服务器端端文件名\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public interface IFtpUploadInterceptor {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 如果ftp服务器端已经有同名文件，控制是否覆盖远端的同名文件；\n&#x27;
                           &#x27;   * 如果你不希望覆盖远端文件，可以使用{@link &#x27;
                           &#x27;#resetFileName(UploadEntity, List)}\n&#x27;
                           &#x27;   * 如果使用者同时实现{@link #resetFileName(UploadEntity, &#x27;
                           &#x27;List)}和{@link #coverServerFile(UploadEntity,\n&#x27;
                           &#x27;   * List)}，将优先使用{@link &#x27;
                           &#x27;#resetFileName(UploadEntity, List)}\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param entity 上传信息实体\n&#x27;
                           &#x27;   * @param fileList ftp服务器端remotePath下的文件列表\n&#x27;
                           &#x27;   * @return {@code true} &#x27;
                           &#x27;如果ftp服务器端已经有同名文件，覆盖服务器端的同名文件\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  boolean coverServerFile(UploadEntity entity, &#x27;
                           &#x27;List&lt;String&gt; fileList);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 如果ftp服务器端已经有同名文件，修改该文件上传到远端的文件名，该操作不会修改本地文件名\n&#x27;
                           &#x27;   * 如果你希望覆盖远端的同名文件，可以使用{@link &#x27;
                           &#x27;#coverServerFile(UploadEntity, List)}\n&#x27;
                           &#x27;   * 如果使用者同时实现{@link #resetFileName(UploadEntity, &#x27;
                           &#x27;List)}和{@link #coverServerFile(UploadEntity,\n&#x27;
                           &#x27;   * List)}，将优先使用{@link &#x27;
                           &#x27;#resetFileName(UploadEntity, List)}\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param entity 上传信息实体\n&#x27;
                           &#x27;   * @param fileList ftp服务器端remotePath下的文件列表\n&#x27;
                           &#x27;   * @return 该文件上传到远端的新的文件名\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  String resetFileName(UploadEntity entity, &#x27;
                           &#x27;List&lt;String&gt; fileList);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        