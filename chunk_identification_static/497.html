<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>497</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    497
                    <a href="496.html">prev</a>
                    <a href="498.html">next</a>
                    <a href="497_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_e346a804d69c8cd0124b4eb3d35156cfb5cd0779_redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e346a804d69c8cd0124b4eb3d35156cfb5cd0779:redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e346a804d69c8cd0124b4eb3d35156cfb5cd0779^1:redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e346a804d69c8cd0124b4eb3d35156cfb5cd0779^2:redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;6e351a99f6e8449c76ad55e517a5da6cbb108379:redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b], [b], [b], [j]], subset: [[b], [b], [bj], [b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.side.redis;
  20 
  21 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  22 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  23 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  24 import com.google.common.collect.Lists;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  25 import com.google.common.collect.Maps;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  26 import org.apache.flink.api.java.tuple.Tuple2;</span>
  27 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  28 import org.apache.flink.api.java.typeutils.RowTypeInfo;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  29 import org.apache.flink.configuration.Configuration;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  30 import org.apache.flink.streaming.api.functions.async.ResultFuture;</span>
  31 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  32 import io.lettuce.core.KeyValue;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  33 import io.lettuce.core.api.async.RedisStringAsyncCommands;</span>
  34 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  35 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  36 import org.apache.flink.configuration.Configuration;
  37 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  38 import org.apache.flink.types.Row;
  39 
  40 import com.dtstack.flink.sql.enums.ECacheContentType;
  41 import com.dtstack.flink.sql.side.CacheMissVal;
  42 import com.dtstack.flink.sql.side.FieldInfo;
  43 import com.dtstack.flink.sql.side.JoinInfo;
  44 import com.dtstack.flink.sql.side.cache.CacheObj;
  45 import com.dtstack.flink.sql.side.redis.enums.RedisType;
  46 import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  47 import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  48 import io.lettuce.core.RedisClient;
  49 import io.lettuce.core.RedisFuture;
  50 import io.lettuce.core.api.StatefulRedisConnection;
  51 import io.lettuce.core.api.async.RedisHashAsyncCommands;
  52 import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  53 import io.lettuce.core.cluster.RedisClusterClient;
  54 import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  55 import org.apache.commons.collections.MapUtils;
  56 import org.apache.commons.lang.StringUtils;
  57 
  58 import java.util.Collections;
  59 import java.util.List;
  60 import java.util.Map;
  61 import java.util.function.Consumer;
  62 /**
  63  * @author yanxi
  64  */
  65 public class RedisAsyncReqRow extends BaseAsyncReqRow {
  66 
  67     private static final long serialVersionUID = -2079908694523987738L;
  68 
  69     private RedisClient redisClient;
  70 
  71     private StatefulRedisConnection&lt;String, String&gt; connection;
  72 
  73     private RedisClusterClient clusterClient;
  74 
  75     private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  76 
  77     private RedisKeyAsyncCommands&lt;String, String&gt; async;
  78 
  79     private RedisSideTableInfo redisSideTableInfo;
  80 
  81     private RedisSideReqRow redisSideReqRow;
  82 
<abbr title="  83     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  83     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList,ðŸ”µ</abbr>
  84         super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  85         redisSideReqRow = new RedisSideReqRow(super.sideInfo);
  86     }
  87 
  88     @Override
  89     public void open(Configuration parameters) throws Exception {
  90         super.open(parameters);
  91         redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  92         buildRedisClient(redisSideTableInfo);
  93     }
  94 
  95     private void buildRedisClient(RedisSideTableInfo tableInfo){
  96         String url = redisSideTableInfo.getUrl();
  97         String password = redisSideTableInfo.getPassword();
  98         if (password != null){
  99             password = password + &quot;@&quot;;
 100         } else {
 101             password = &quot;&quot;;
 102         }
 103         String database = redisSideTableInfo.getDatabase();
 104         if (database == null){
 105             database = &quot;0&quot;;
 106         }
 107         switch (RedisType.parse(tableInfo.getRedisType())){
 108             case STANDALONE:
 109                 StringBuilder redisUri = new StringBuilder();
 110                 redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 111                 redisClient = RedisClient.create(redisUri.toString());
 112                 connection = redisClient.connect();
 113                 async = connection.async();
 114                 break;
 115             case SENTINEL:
 116                 StringBuilder sentinelUri = new StringBuilder();
 117                 sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 118                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 118                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.gðŸ”µ</abbr>
 119                 redisClient = RedisClient.create(sentinelUri.toString());
 120                 connection = redisClient.connect();
 121                 async = connection.async();
 122                 break;
 123             case CLUSTER:
 124                 StringBuilder clusterUri = new StringBuilder();
 125                 clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 126                 clusterClient = RedisClusterClient.create(clusterUri.toString());
 127                 clusterConnection = clusterClient.connect();
 128                 async = clusterConnection.async();
 129             default:
 130                 break;
 131         }
 132     }
 133 
 134     @Override
 135     public Row fillData(Row input, Object sideInput) {
 136         return redisSideReqRow.fillData(input, sideInput);
 137     }
 138 
 139     @Override
 140 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 141     public void asyncInvoke(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws Exception {"> 141     public void asyncInvoke(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) thðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 142         Tuple2&lt;Boolean, Row&gt; inputCopy = Tuple2.of(input.f0, input.f1);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 143         Map&lt;String, Object&gt; refData = Maps.newHashMap();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 144         for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 145             Integer conValIndex = sideInfo.getEqualValIndex().get(i);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 146             Object equalObj = inputCopy.f1.getField(conValIndex);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 147             if(equalObj == null){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 148                 dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 149                 return;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 150             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 151             refData.put(sideInfo.getEqualFieldList().get(i), equalObj);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 152         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 153 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 154         String key = buildCacheKey(refData);</span>
 155 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 156         CRow inputCopy = new CRow(input.row(), input.change());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 157         Map&lt;String, Object&gt; refData = Maps.newHashMap();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 158         for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 159             Integer conValIndex = sideInfo.getEqualValIndex().get(i);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 160             Object equalObj = input.row().getField(conValIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 161             if(equalObj == null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 162                 dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 163                 return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 164             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 165             refData.put(sideInfo.getEqualFieldList().get(i), equalObj);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 166         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 167 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 168         String key = buildCacheKey(refData);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 169         if(StringUtils.isBlank(key)){</span>
 170 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 171     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 171     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 172         String key = buildCacheKey(inputParams);</span>
 173 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 174         if(StringUtils.isBlank(key)){
 175             return;
 176         }
 177 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 178         if(openCache()){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 179             CacheObj val = getFromCache(key);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 180             if(val != null){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 181                 if(ECacheContentType.MissVal == val.getType()){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 182                     dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 183                     return;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 184                 }else if(ECacheContentType.MultiLine == val.getType()){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 185                     try {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 186                         Row row = fillData(inputCopy.f1, val.getContent());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 187                         resultFuture.complete(Collections.singleton(Tuple2.of(input.f0, row)));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 188                     } catch (Exception e) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 189                         dealFillDataError(resultFuture, e, inputCopy);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 190                     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 191                 }else{</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 192                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType());"> 192                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + valðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 193                     resultFuture.completeExceptionally(exception);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 194                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 195                 return;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 196             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 197         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 198 </span>
 199 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 200                 dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 201                 return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 202             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 203             refData.put(sideInfo.getEqualFieldList().get(i), equalObj);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 204         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 205 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 206         String key = buildCacheKey(refData);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 207         if(StringUtils.isBlank(key)){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 208             return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 209         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 210         if(openCache()){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 211             CacheObj val = getFromCache(key);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 212             if(val != null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 213                 if(ECacheContentType.MissVal == val.getType()){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 214                     dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 215                     return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 216                 }else if(ECacheContentType.MultiLine == val.getType()){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 217                     try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 218                         Row row = fillData(input.row(), val.getContent());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 219                         resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 220                     } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 221                         dealFillDataError(resultFuture, e, inputCopy);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 222                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 223                 }else{</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 224                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType());"> 224                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + valðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 225                     resultFuture.completeExceptionally(exception);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 226                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 227                 return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 228             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 229         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 230 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 231         RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);</span>
 232 =======
 233 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 234         RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);
 235         future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {
 236             @Override
 237             public void accept(Map&lt;String, String&gt; values) {
 238                 if (MapUtils.isNotEmpty(values)) {
 239                     try {
 240                         Row row = fillData(input.f1, values);
 241                         dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));
 242 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 243                         resultFuture.complete(Collections.singleton(Tuple2.of(inputCopy.f0, row)));</span>
 244 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 245             return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 246         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 247         if(openCache()){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 248             CacheObj val = getFromCache(key);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 249             if(val != null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 250                 if(ECacheContentType.MissVal == val.getType()){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 251                     dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 252                     return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 253                 }else if(ECacheContentType.MultiLine == val.getType()){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 254                     try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 255                         Row row = fillData(input.row(), val.getContent());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 256                         resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 257                     } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 258                         dealFillDataError(resultFuture, e, inputCopy);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 259                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 260                 }else{</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 261                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType());"> 261                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + valðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 262                     resultFuture.completeExceptionally(exception);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 263                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 264                 return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 265             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 266         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 267 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 268         RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 269         future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 270             @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 271             public void accept(Map&lt;String, String&gt; values) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 272                 if (MapUtils.isNotEmpty(values)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 273                     try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 274                         Row row = fillData(input.row(), values);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 275                         dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 276                         resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 277                     } catch (Exception e) {</span>
 278 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 279                         resultFuture.complete(Collections.singleton(new CRow(row, input.change())));</span>
 280 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 281                     } catch (Exception e) {
 282                         dealFillDataError(input, resultFuture, e);
 283                     }
 284                 } else {
 285                     dealMissKey(input, resultFuture);
 286                     dealCacheData(key,CacheMissVal.getMissKeyObj());
 287                 }
 288             }
 289         });
 290     }
 291 
 292     @Override
 293     public String buildCacheKey(Map&lt;String, Object&gt; refData) {
 294         StringBuilder keyBuilder = new StringBuilder(redisSideTableInfo.getTableName());
 295         List&lt;String&gt; primaryKeys = redisSideTableInfo.getPrimaryKeys();
 296         for(String primaryKey : primaryKeys){
 297             if(!refData.containsKey(primaryKey)){
 298                 return null;
 299             }
 300             keyBuilder.append(&quot;_&quot;).append(refData.get(primaryKey));
 301         }
 302         return keyBuilder.toString();
 303     }
 304 
 305     @Override
 306     public void close() throws Exception {
 307         super.close();
 308         if (connection != null){
 309             connection.close();
 310         }
 311         if (redisClient != null){
 312             redisClient.shutdown();
 313         }
 314         if (clusterConnection != null){
 315             clusterConnection.close();
 316         }
 317         if (clusterClient != null){
 318             clusterClient.shutdown();
 319         }
 320     }
 321 
 322 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.side.redis;
  20 
  21 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  22 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  23 import com.google.common.collect.Lists;
  24 import io.lettuce.core.KeyValue;
  25 import io.lettuce.core.api.async.RedisStringAsyncCommands;
  26 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  27 import org.apache.flink.configuration.Configuration;
  28 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  29 import org.apache.flink.types.Row;
  30 
  31 import com.dtstack.flink.sql.enums.ECacheContentType;
  32 import com.dtstack.flink.sql.side.CacheMissVal;
  33 import com.dtstack.flink.sql.side.FieldInfo;
  34 import com.dtstack.flink.sql.side.JoinInfo;
  35 import com.dtstack.flink.sql.side.cache.CacheObj;
  36 import com.dtstack.flink.sql.side.redis.enums.RedisType;
  37 import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  38 import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  39 import io.lettuce.core.RedisClient;
  40 import io.lettuce.core.RedisFuture;
  41 import io.lettuce.core.api.StatefulRedisConnection;
  42 import io.lettuce.core.api.async.RedisHashAsyncCommands;
  43 import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  44 import io.lettuce.core.cluster.RedisClusterClient;
  45 import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  46 import org.apache.commons.collections.MapUtils;
  47 import org.apache.commons.lang.StringUtils;
  48 import com.google.common.collect.Maps;
  49 import org.apache.flink.api.java.tuple.Tuple2;
  50 
  51 import java.util.Collections;
  52 import java.util.List;
  53 import java.util.Map;
  54 import java.util.function.Consumer;
  55 /**
  56  * @author yanxi
  57  */
  58 public class RedisAsyncReqRow extends BaseAsyncReqRow {
  59 
  60     private static final long serialVersionUID = -2079908694523987738L;
  61 
  62     private RedisClient redisClient;
  63 
  64     private StatefulRedisConnection&lt;String, String&gt; connection;
  65 
  66     private RedisClusterClient clusterClient;
  67 
  68     private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  69 
  70     private RedisKeyAsyncCommands&lt;String, String&gt; async;
  71 
  72     private RedisSideTableInfo redisSideTableInfo;
  73 
  74     private RedisSideReqRow redisSideReqRow;
  75 
<abbr title="  76     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  76     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList,ðŸ”µ</abbr>
  77         super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  78         redisSideReqRow = new RedisSideReqRow(super.sideInfo);
  79     }
  80 
  81     @Override
  82     public void open(Configuration parameters) throws Exception {
  83         super.open(parameters);
  84         redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  85         buildRedisClient(redisSideTableInfo);
  86     }
  87 
  88     private void buildRedisClient(RedisSideTableInfo tableInfo){
  89         String url = redisSideTableInfo.getUrl();
  90         String password = redisSideTableInfo.getPassword();
  91         if (password != null){
  92             password = password + &quot;@&quot;;
  93         } else {
  94             password = &quot;&quot;;
  95         }
  96         String database = redisSideTableInfo.getDatabase();
  97         if (database == null){
  98             database = &quot;0&quot;;
  99         }
 100         switch (RedisType.parse(tableInfo.getRedisType())){
 101             case STANDALONE:
 102                 StringBuilder redisUri = new StringBuilder();
 103                 redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 104                 redisClient = RedisClient.create(redisUri.toString());
 105                 connection = redisClient.connect();
 106                 async = connection.async();
 107                 break;
 108             case SENTINEL:
 109                 StringBuilder sentinelUri = new StringBuilder();
 110                 sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 111                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 111                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.gðŸ”µ</abbr>
 112                 redisClient = RedisClient.create(sentinelUri.toString());
 113                 connection = redisClient.connect();
 114                 async = connection.async();
 115                 break;
 116             case CLUSTER:
 117                 StringBuilder clusterUri = new StringBuilder();
 118                 clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 119                 clusterClient = RedisClusterClient.create(clusterUri.toString());
 120                 clusterConnection = clusterClient.connect();
 121                 async = clusterConnection.async();
 122             default:
 123                 break;
 124         }
 125     }
 126 
 127     @Override
 128     public Row fillData(Row input, Object sideInput) {
 129         return redisSideReqRow.fillData(input, sideInput);
 130     }
 131 
 132 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 133     @Override</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 134     public void asyncInvoke(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws Exception {"> 134     public void asyncInvoke(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) thðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 135         Tuple2&lt;Boolean, Row&gt; inputCopy = Tuple2.of(input.f0, input.f1);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 136         Map&lt;String, Object&gt; refData = Maps.newHashMap();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 137         for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 138             Integer conValIndex = sideInfo.getEqualValIndex().get(i);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 139             Object equalObj = inputCopy.f1.getField(conValIndex);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 140             if(equalObj == null){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 141                 dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 142                 return;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 143             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 144             refData.put(sideInfo.getEqualFieldList().get(i), equalObj);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 145         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 146 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 147         String key = buildCacheKey(refData);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 148         if(StringUtils.isBlank(key)){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 149             return;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 150         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 151         if(openCache()){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 152             CacheObj val = getFromCache(key);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 153             if(val != null){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 154                 if(ECacheContentType.MissVal == val.getType()){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 155                     dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 156                     return;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 157                 }else if(ECacheContentType.MultiLine == val.getType()){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 158                     try {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 159                         Row row = fillData(inputCopy.f1, val.getContent());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 160                         resultFuture.complete(Collections.singleton(Tuple2.of(input.f0, row)));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 161                     } catch (Exception e) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 162                         dealFillDataError(resultFuture, e, inputCopy);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 163                     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 164                 }else{</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 165                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType());"> 165                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + valðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 166                     resultFuture.completeExceptionally(exception);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 167                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 168                 return;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 169             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 170         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 171 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 172         RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 173         future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 174             @Override</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 175             public void accept(Map&lt;String, String&gt; values) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 176                 if (MapUtils.isNotEmpty(values)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 177                     try {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 178                         Row row = fillData(input.f1, values);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 179                         dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 180                         resultFuture.complete(Collections.singleton(Tuple2.of(inputCopy.f0, row)));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 181                     } catch (Exception e) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 182                         dealFillDataError(resultFuture, e, inputCopy);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 183                     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 184                 } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 185                     dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 186                     dealCacheData(key,CacheMissVal.getMissKeyObj());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 187                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 188             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 189         });</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 190     }</span>
 191 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 192     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 193     public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 194         CRow inputCopy = new CRow(input.row(), input.change());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 195         Map&lt;String, Object&gt; refData = Maps.newHashMap();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 196         for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 197             Integer conValIndex = sideInfo.getEqualValIndex().get(i);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 198             Object equalObj = input.row().getField(conValIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 199             if(equalObj == null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 200                 dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 201                 return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 202             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 203             refData.put(sideInfo.getEqualFieldList().get(i), equalObj);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 204         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 205 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 206         String key = buildCacheKey(refData);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 207         if(StringUtils.isBlank(key)){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 208             return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 209         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 210         if(openCache()){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 211             CacheObj val = getFromCache(key);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 212             if(val != null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 213                 if(ECacheContentType.MissVal == val.getType()){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 214                     dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 215                     return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 216                 }else if(ECacheContentType.MultiLine == val.getType()){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 217                     try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 218                         Row row = fillData(input.row(), val.getContent());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 219                         resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 220                     } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 221                         dealFillDataError(resultFuture, e, inputCopy);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 222                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 223                 }else{</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 224                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType());"> 224                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + valðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 225                     resultFuture.completeExceptionally(exception);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 226                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 227                 return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 228             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 229         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 230 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 231         RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 232         future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 233             @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 234             public void accept(Map&lt;String, String&gt; values) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 235                 if (MapUtils.isNotEmpty(values)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 236                     try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 237                         Row row = fillData(input.row(), values);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 238                         dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 239                         resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 240                     } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 241                         dealFillDataError(resultFuture, e, inputCopy);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 242                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 243                 } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 244                     dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 245                     dealCacheData(key,CacheMissVal.getMissKeyObj());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 246                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 247             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 248         });</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 249     }</span>
 250 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 251 </span>
 252 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 253 
 254     @Override
<abbr title=" 255     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 255     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFðŸ”µ</abbr>
 256         String key = buildCacheKey(inputParams);
 257         if(StringUtils.isBlank(key)){
 258             return;
 259         }
 260         RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);
 261         future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {
 262             @Override
 263             public void accept(Map&lt;String, String&gt; values) {
 264                 if (MapUtils.isNotEmpty(values)) {
 265                     try {
 266                         Row row = fillData(input.row(), values);
 267                         dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));
 268                         resultFuture.complete(Collections.singleton(new CRow(row, input.change())));
 269                     } catch (Exception e) {
 270                         dealFillDataError(input, resultFuture, e);
 271                     }
 272                 } else {
 273                     dealMissKey(input, resultFuture);
 274                     dealCacheData(key,CacheMissVal.getMissKeyObj());
 275                 }
 276             }
 277         });
 278     }
 279 
 280     @Override
 281     public String buildCacheKey(Map&lt;String, Object&gt; refData) {
 282         StringBuilder keyBuilder = new StringBuilder(redisSideTableInfo.getTableName());
 283         List&lt;String&gt; primaryKeys = redisSideTableInfo.getPrimaryKeys();
 284         for(String primaryKey : primaryKeys){
 285             if(!refData.containsKey(primaryKey)){
 286                 return null;
 287             }
 288             keyBuilder.append(&quot;_&quot;).append(refData.get(primaryKey));
 289         }
 290         return keyBuilder.toString();
 291     }
 292 
 293     @Override
 294     public void close() throws Exception {
 295         super.close();
 296         if (connection != null){
 297             connection.close();
 298         }
 299         if (redisClient != null){
 300             redisClient.shutdown();
 301         }
 302         if (clusterConnection != null){
 303             clusterConnection.close();
 304         }
 305         if (clusterClient != null){
 306             clusterClient.shutdown();
 307         }
 308     }
 309 
 310 }
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side.redis;
  19 
  20 import com.dtstack.flink.sql.enums.ECacheContentType;
  21 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  22 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  23 import com.dtstack.flink.sql.side.CacheMissVal;
  24 import com.dtstack.flink.sql.side.FieldInfo;
  25 import com.dtstack.flink.sql.side.JoinInfo;
  26 import com.dtstack.flink.sql.side.cache.CacheObj;
  27 import com.dtstack.flink.sql.side.redis.enums.RedisType;
  28 import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  29 import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  30 import com.google.common.collect.Lists;
  31 import com.google.common.collect.Maps;
  32 import io.lettuce.core.KeyValue;
  33 import io.lettuce.core.RedisClient;
  34 import io.lettuce.core.RedisFuture;
  35 import io.lettuce.core.api.StatefulRedisConnection;
  36 import io.lettuce.core.api.async.RedisHashAsyncCommands;
  37 import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  38 import io.lettuce.core.api.async.RedisStringAsyncCommands;
  39 import io.lettuce.core.cluster.RedisClusterClient;
  40 import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  41 import java.util.Collections;
  42 import java.util.List;
  43 import java.util.Map;
  44 import java.util.function.Consumer;
  45 import org.apache.commons.collections.MapUtils;
  46 import org.apache.commons.lang.StringUtils;
  47 import org.apache.flink.api.java.tuple.Tuple2;
  48 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  49 import org.apache.flink.configuration.Configuration;
  50 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  51 import org.apache.flink.types.Row;
  52 
  53 
  54 /**
  55  * @author yanxi
  56  */
  57 public class RedisAsyncReqRow extends BaseAsyncReqRow {
  58     private static final long serialVersionUID = -2079908694523987738L;
  59 
  60     private RedisClient redisClient;
  61 
  62     private StatefulRedisConnection&lt;String, String&gt; connection;
  63 
  64     private RedisClusterClient clusterClient;
  65 
  66     private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  67 
  68     private RedisKeyAsyncCommands&lt;String, String&gt; async;
  69 
  70     private RedisSideTableInfo redisSideTableInfo;
  71 
  72     private RedisSideReqRow redisSideReqRow;
  73 
<abbr title="  74     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  74     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList,ðŸ”µ</abbr>
  75         super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  76         redisSideReqRow = new RedisSideReqRow(super.sideInfo);
  77     }
  78 
  79     @Override
  80     public void open(Configuration parameters) throws Exception {
  81         super.open(parameters);
  82         redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  83         buildRedisClient(redisSideTableInfo);
  84     }
  85 
  86     private void buildRedisClient(RedisSideTableInfo tableInfo){
  87         String url = redisSideTableInfo.getUrl();
  88         String password = redisSideTableInfo.getPassword();
  89         if (password != null){
  90             password = password + &quot;@&quot;;
  91         } else {
  92             password = &quot;&quot;;
  93         }
  94         String database = redisSideTableInfo.getDatabase();
  95         if (database == null){
  96             database = &quot;0&quot;;
  97         }
  98         switch (RedisType.parse(tableInfo.getRedisType())){
  99             case STANDALONE:
 100                 StringBuilder redisUri = new StringBuilder();
 101                 redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 102                 redisClient = RedisClient.create(redisUri.toString());
 103                 connection = redisClient.connect();
 104                 async = connection.async();
 105                 break;
 106             case SENTINEL:
 107                 StringBuilder sentinelUri = new StringBuilder();
 108                 sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 109                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 109                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.gðŸ”µ</abbr>
 110                 redisClient = RedisClient.create(sentinelUri.toString());
 111                 connection = redisClient.connect();
 112                 async = connection.async();
 113                 break;
 114             case CLUSTER:
 115                 StringBuilder clusterUri = new StringBuilder();
 116                 clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 117                 clusterClient = RedisClusterClient.create(clusterUri.toString());
 118                 clusterConnection = clusterClient.connect();
 119                 async = clusterConnection.async();
 120             default:
 121                 break;
 122         }
 123     }
 124 
 125     @Override
 126     public Row fillData(Row input, Object sideInput) {
 127         return redisSideReqRow.fillData(input, sideInput);
 128     }
 129 
 130     @Override
<abbr title=" 131     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture) throws Exception {"> 131     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFutuðŸ”µ</abbr>
 132         String key = buildCacheKey(inputParams);
 133         if (StringUtils.isBlank(key)) {
 134             return;
 135         }
 136         RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) (async)).hgetall(key);
 137         future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {
 138             @Override
 139             public void accept(Map&lt;String, String&gt; values) {
 140                 if (MapUtils.isNotEmpty(values)) {
 141                     try {
 142                         Row row = fillData(input.f1, values);
 143                         dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));
 144                         resultFuture.complete(Collections.singleton(Tuple2.of(inputCopy.f0, row)));
 145                     } catch (java.lang.Exception e) {
 146                         dealFillDataError(input, resultFuture, e);
 147                     }
 148                 } else {
 149                     dealMissKey(input, resultFuture);
 150                     dealCacheData(key, CacheMissVal.getMissKeyObj());
 151                 }
 152             }
 153         });
 154     }
 155 
 156     @Override
 157     public String buildCacheKey(Map&lt;String, Object&gt; refData) {
 158         StringBuilder keyBuilder = new StringBuilder(redisSideTableInfo.getTableName());
 159         List&lt;String&gt; primaryKeys = redisSideTableInfo.getPrimaryKeys();
 160         for (String primaryKey : primaryKeys) {
 161             if (!refData.containsKey(primaryKey)) {
 162                 return null;
 163             }
 164             keyBuilder.append(&quot;_&quot;).append(refData.get(primaryKey));
 165         }
 166         return keyBuilder.toString();
 167     }
 168 
 169     @Override
 170     public void close() throws Exception {
 171         super.close();
 172         if (connection != null){
 173             connection.close();
 174         }
 175         if (redisClient != null){
 176             redisClient.shutdown();
 177         }
 178         if (clusterConnection != null){
 179             clusterConnection.close();
 180         }
 181         if (clusterClient != null){
 182             clusterClient.shutdown();
 183         }
 184     }
 185 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.side.redis;
  20  
  21  import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  22  import com.dtstack.flink.sql.side.BaseAsyncReqRow;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  23 +import com.google.common.collect.Lists;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  24 +import com.google.common.collect.Maps;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  25 +import org.apache.flink.api.java.tuple.Tuple2;</span>
  26  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  27  import org.apache.flink.configuration.Configuration;
  28  import org.apache.flink.streaming.api.functions.async.ResultFuture;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  29 -import org.apache.flink.table.runtime.types.CRow;</span>
  30  import org.apache.flink.types.Row;
  31  
  32  import com.dtstack.flink.sql.enums.ECacheContentType;
  33  import com.dtstack.flink.sql.side.CacheMissVal;
  34  import com.dtstack.flink.sql.side.FieldInfo;
  35  import com.dtstack.flink.sql.side.JoinInfo;
  36  import com.dtstack.flink.sql.side.cache.CacheObj;
  37  import com.dtstack.flink.sql.side.redis.enums.RedisType;
  38  import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  39  import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  40  import io.lettuce.core.RedisClient;
  41  import io.lettuce.core.RedisFuture;
  42  import io.lettuce.core.api.StatefulRedisConnection;
  43  import io.lettuce.core.api.async.RedisHashAsyncCommands;
  44  import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  45  import io.lettuce.core.cluster.RedisClusterClient;
  46  import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  47  import org.apache.commons.collections.MapUtils;
  48  import org.apache.commons.lang.StringUtils;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  49 -import com.google.common.collect.Maps;</span>
  50  
  51  import java.util.Collections;
  52  import java.util.List;
  53  import java.util.Map;
  54  import java.util.function.Consumer;
  55  /**
  56   * @author yanxi
  57   */
  58  public class RedisAsyncReqRow extends BaseAsyncReqRow {
  59  
  60      private static final long serialVersionUID = -2079908694523987738L;
  61  
  62      private RedisClient redisClient;
  63  
  64      private StatefulRedisConnection&lt;String, String&gt; connection;
  65  
  66      private RedisClusterClient clusterClient;
  67  
  68      private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  69  
  70      private RedisKeyAsyncCommands&lt;String, String&gt; async;
  71  
  72      private RedisSideTableInfo redisSideTableInfo;
  73  
  74      private RedisSideReqRow redisSideReqRow;
  75  
<abbr title="  76      public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  76      public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractðŸ”µ</abbr>
  77          super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  78          redisSideReqRow = new RedisSideReqRow(super.sideInfo);
  79      }
  80  
  81      @Override
  82      public void open(Configuration parameters) throws Exception {
  83          super.open(parameters);
  84          redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  85          buildRedisClient(redisSideTableInfo);
  86      }
  87  
  88      private void buildRedisClient(RedisSideTableInfo tableInfo){
  89          String url = redisSideTableInfo.getUrl();
  90          String password = redisSideTableInfo.getPassword();
  91          if (password != null){
  92              password = password + &quot;@&quot;;
  93          } else {
  94              password = &quot;&quot;;
  95          }
  96          String database = redisSideTableInfo.getDatabase();
  97          if (database == null){
  98              database = &quot;0&quot;;
  99          }
 100          switch (RedisType.parse(tableInfo.getRedisType())){
 101              case STANDALONE:
 102                  StringBuilder redisUri = new StringBuilder();
 103                  redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 104                  redisClient = RedisClient.create(redisUri.toString());
 105                  connection = redisClient.connect();
 106                  async = connection.async();
 107                  break;
 108              case SENTINEL:
 109                  StringBuilder sentinelUri = new StringBuilder();
 110                  sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 111                          .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 111                          .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterNðŸ”µ</abbr>
 112                  redisClient = RedisClient.create(sentinelUri.toString());
 113                  connection = redisClient.connect();
 114                  async = connection.async();
 115                  break;
 116              case CLUSTER:
 117                  StringBuilder clusterUri = new StringBuilder();
 118                  clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 119                  clusterClient = RedisClusterClient.create(clusterUri.toString());
 120                  clusterConnection = clusterClient.connect();
 121                  async = clusterConnection.async();
 122              default:
 123                  break;
 124          }
 125      }
 126  
 127      @Override
 128      public Row fillData(Row input, Object sideInput) {
 129          return redisSideReqRow.fillData(input, sideInput);
 130      }
 131  
 132      @Override
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 133 -    public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 134 -        CRow inputCopy = new CRow(input.row(), input.change());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 135 +    public void asyncInvoke(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws Exception {"> 135 +    public void asyncInvoke(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws ExceðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 136 +        Tuple2&lt;Boolean, Row&gt; inputCopy = Tuple2.of(input.f0, input.f1);</span>
 137          Map&lt;String, Object&gt; refData = Maps.newHashMap();
 138          for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 139              Integer conValIndex = sideInfo.getEqualValIndex().get(i);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 140 -            Object equalObj = input.row().getField(conValIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 141 +            Object equalObj = inputCopy.f1.getField(conValIndex);</span>
 142              if(equalObj == null){
 143                  dealMissKey(inputCopy, resultFuture);
 144                  return;
 145              }
 146              refData.put(sideInfo.getEqualFieldList().get(i), equalObj);
 147          }
 148  
 149          String key = buildCacheKey(refData);


 150          if(StringUtils.isBlank(key)){
 151              return;
 152          }
 153          if(openCache()){
 154              CacheObj val = getFromCache(key);
 155              if(val != null){
 156                  if(ECacheContentType.MissVal == val.getType()){
 157                      dealMissKey(inputCopy, resultFuture);
 158                      return;
 159                  }else if(ECacheContentType.MultiLine == val.getType()){
 160                      try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 161 -                        Row row = fillData(input.row(), val.getContent());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 162 -                        resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 163 +                        Row row = fillData(inputCopy.f1, val.getContent());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 164 +                        resultFuture.complete(Collections.singleton(Tuple2.of(input.f0, row)));</span>
 165                      } catch (Exception e) {
 166                          dealFillDataError(resultFuture, e, inputCopy);
 167                      }
 168                  }else{
<abbr title=" 169                      RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType());"> 169                      RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType(ðŸ”µ</abbr>
 170                      resultFuture.completeExceptionally(exception);
 171                  }
 172                  return;
 173              }
 174          }
 175  
 176          RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);
 177          future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {
 178              @Override
 179              public void accept(Map&lt;String, String&gt; values) {
 180                  if (MapUtils.isNotEmpty(values)) {
 181                      try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 182 -                        Row row = fillData(input.row(), values);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 183 +                        Row row = fillData(input.f1, values);</span>
 184                          dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 185 -                        resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 186 +                        resultFuture.complete(Collections.singleton(Tuple2.of(inputCopy.f0, row)));</span>
 187                      } catch (Exception e) {
 188                          dealFillDataError(resultFuture, e, inputCopy);

 189                      }
 190                  } else {
 191                      dealMissKey(inputCopy, resultFuture);

 192                      dealCacheData(key,CacheMissVal.getMissKeyObj());
 193                  }
 194              }
 195          });
 196      }
 197  
 198      private String buildCacheKey(Map&lt;String, Object&gt; refData) {


 199          StringBuilder keyBuilder = new StringBuilder(redisSideTableInfo.getTableName());
 200          List&lt;String&gt; primaryKeys = redisSideTableInfo.getPrimaryKeys();
 201          for(String primaryKey : primaryKeys){
 202              if(!refData.containsKey(primaryKey)){
 203                  return null;
 204              }
 205              keyBuilder.append(&quot;_&quot;).append(refData.get(primaryKey));
 206          }
 207          return keyBuilder.toString();
 208      }
 209  
 210      @Override
 211      public void close() throws Exception {
 212          super.close();
 213          if (connection != null){
 214              connection.close();
 215          }
 216          if (redisClient != null){
 217              redisClient.shutdown();
 218          }
 219          if (clusterConnection != null){
 220              clusterConnection.close();
 221          }
 222          if (clusterClient != null){
 223              clusterClient.shutdown();
 224          }
 225      }
 226  
 227  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.side.redis;
  20  
  21  import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  22  import com.dtstack.flink.sql.side.BaseAsyncReqRow;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  23 +import io.lettuce.core.KeyValue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  24 +import io.lettuce.core.api.async.RedisStringAsyncCommands;</span>

  25  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  26  import org.apache.flink.configuration.Configuration;
  27  import org.apache.flink.streaming.api.functions.async.ResultFuture;
  28  import org.apache.flink.table.runtime.types.CRow;
  29  import org.apache.flink.types.Row;
  30  
  31  import com.dtstack.flink.sql.enums.ECacheContentType;
  32  import com.dtstack.flink.sql.side.CacheMissVal;
  33  import com.dtstack.flink.sql.side.FieldInfo;
  34  import com.dtstack.flink.sql.side.JoinInfo;
  35  import com.dtstack.flink.sql.side.cache.CacheObj;
  36  import com.dtstack.flink.sql.side.redis.enums.RedisType;
  37  import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  38  import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  39  import io.lettuce.core.RedisClient;
  40  import io.lettuce.core.RedisFuture;
  41  import io.lettuce.core.api.StatefulRedisConnection;
  42  import io.lettuce.core.api.async.RedisHashAsyncCommands;
  43  import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  44  import io.lettuce.core.cluster.RedisClusterClient;
  45  import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  46  import org.apache.commons.collections.MapUtils;
  47  import org.apache.commons.lang.StringUtils;
  48  import com.google.common.collect.Maps;
  49  
  50  import java.util.Collections;
  51  import java.util.List;
  52  import java.util.Map;
  53  import java.util.function.Consumer;
  54  /**
  55   * @author yanxi
  56   */
  57  public class RedisAsyncReqRow extends BaseAsyncReqRow {
  58  
  59      private static final long serialVersionUID = -2079908694523987738L;
  60  
  61      private RedisClient redisClient;
  62  
  63      private StatefulRedisConnection&lt;String, String&gt; connection;
  64  
  65      private RedisClusterClient clusterClient;
  66  
  67      private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  68  
  69      private RedisKeyAsyncCommands&lt;String, String&gt; async;
  70  
  71      private RedisSideTableInfo redisSideTableInfo;
  72  
  73      private RedisSideReqRow redisSideReqRow;
  74  
<abbr title="  75      public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  75      public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractðŸ”µ</abbr>
  76          super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  77          redisSideReqRow = new RedisSideReqRow(super.sideInfo);
  78      }
  79  
  80      @Override
  81      public void open(Configuration parameters) throws Exception {
  82          super.open(parameters);
  83          redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  84          buildRedisClient(redisSideTableInfo);
  85      }
  86  
  87      private void buildRedisClient(RedisSideTableInfo tableInfo){
  88          String url = redisSideTableInfo.getUrl();
  89          String password = redisSideTableInfo.getPassword();
  90          if (password != null){
  91              password = password + &quot;@&quot;;
  92          } else {
  93              password = &quot;&quot;;
  94          }
  95          String database = redisSideTableInfo.getDatabase();
  96          if (database == null){
  97              database = &quot;0&quot;;
  98          }
  99          switch (RedisType.parse(tableInfo.getRedisType())){
 100              case STANDALONE:
 101                  StringBuilder redisUri = new StringBuilder();
 102                  redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 103                  redisClient = RedisClient.create(redisUri.toString());
 104                  connection = redisClient.connect();
 105                  async = connection.async();
 106                  break;
 107              case SENTINEL:
 108                  StringBuilder sentinelUri = new StringBuilder();
 109                  sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 110                          .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 110                          .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterNðŸ”µ</abbr>
 111                  redisClient = RedisClient.create(sentinelUri.toString());
 112                  connection = redisClient.connect();
 113                  async = connection.async();
 114                  break;
 115              case CLUSTER:
 116                  StringBuilder clusterUri = new StringBuilder();
 117                  clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 118                  clusterClient = RedisClusterClient.create(clusterUri.toString());
 119                  clusterConnection = clusterClient.connect();
 120                  async = clusterConnection.async();
 121              default:
 122                  break;
 123          }
 124      }
 125  
 126      @Override
 127      public Row fillData(Row input, Object sideInput) {
 128          return redisSideReqRow.fillData(input, sideInput);
 129      }
 130  
 131      @Override
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 132 -    public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 133 -        CRow inputCopy = new CRow(input.row(), input.change());</span>


<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 134 -        Map&lt;String, Object&gt; refData = Maps.newHashMap();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 135 -        for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 136 -            Integer conValIndex = sideInfo.getEqualValIndex().get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 137 -            Object equalObj = input.row().getField(conValIndex);</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 138 -            if(equalObj == null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 139 -                dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 140 -                return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 141 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 142 -            refData.put(sideInfo.getEqualFieldList().get(i), equalObj);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 143 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 144 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 145 -        String key = buildCacheKey(refData);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 146 +    public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 146 +    public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) thðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 147 +        String key = buildCacheKey(inputParams);</span>
 148          if(StringUtils.isBlank(key)){
 149              return;
 150          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 151 -        if(openCache()){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 152 -            CacheObj val = getFromCache(key);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 153 -            if(val != null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 154 -                if(ECacheContentType.MissVal == val.getType()){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 155 -                    dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 156 -                    return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 157 -                }else if(ECacheContentType.MultiLine == val.getType()){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 158 -                    try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 159 -                        Row row = fillData(input.row(), val.getContent());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 160 -                        resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));</span>


<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 161 -                    } catch (Exception e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 162 -                        dealFillDataError(resultFuture, e, inputCopy);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 163 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 164 -                }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 165 -                    RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType());"> 165 -                    RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType(ðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 166 -                    resultFuture.completeExceptionally(exception);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 167 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 168 -                return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 169 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 170 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 171 -</span>
 172          RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);
 173          future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {
 174              @Override
 175              public void accept(Map&lt;String, String&gt; values) {
 176                  if (MapUtils.isNotEmpty(values)) {
 177                      try {
 178                          Row row = fillData(input.row(), values);

 179                          dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 180 -                        resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 181 +                        resultFuture.complete(Collections.singleton(new CRow(row, input.change())));</span>
 182                      } catch (Exception e) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 183 -                        dealFillDataError(resultFuture, e, inputCopy);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 184 +                        dealFillDataError(input, resultFuture, e);</span>
 185                      }
 186                  } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 187 -                    dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 188 +                    dealMissKey(input, resultFuture);</span>
 189                      dealCacheData(key,CacheMissVal.getMissKeyObj());
 190                  }
 191              }
 192          });
 193      }
 194  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 195 -    private String buildCacheKey(Map&lt;String, Object&gt; refData) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 196 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 197 +    public String buildCacheKey(Map&lt;String, Object&gt; refData) {</span>
 198          StringBuilder keyBuilder = new StringBuilder(redisSideTableInfo.getTableName());
 199          List&lt;String&gt; primaryKeys = redisSideTableInfo.getPrimaryKeys();
 200          for(String primaryKey : primaryKeys){
 201              if(!refData.containsKey(primaryKey)){
 202                  return null;
 203              }
 204              keyBuilder.append(&quot;_&quot;).append(refData.get(primaryKey));
 205          }
 206          return keyBuilder.toString();
 207      }
 208  
 209      @Override
 210      public void close() throws Exception {
 211          super.close();
 212          if (connection != null){
 213              connection.close();
 214          }
 215          if (redisClient != null){
 216              redisClient.shutdown();
 217          }
 218          if (clusterConnection != null){
 219              clusterConnection.close();
 220          }
 221          if (clusterClient != null){
 222              clusterClient.shutdown();
 223          }
 224      }
 225  
 226  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            