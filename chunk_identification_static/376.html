<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>376</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    376
                    <a href="375.html">prev</a>
                    <a href="377.html">next</a>
                    <a href="376_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_e346a804d69c8cd0124b4eb3d35156cfb5cd0779_core/src/main/java/com/dtstack/flink/sql/environment/MyLocalStreamEnvironment.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e346a804d69c8cd0124b4eb3d35156cfb5cd0779:core/src/main/java/com/dtstack/flink/sql/environment/MyLocalStreamEnvironment.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e346a804d69c8cd0124b4eb3d35156cfb5cd0779^1:core/src/main/java/com/dtstack/flink/sql/environment/MyLocalStreamEnvironment.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e346a804d69c8cd0124b4eb3d35156cfb5cd0779^2:core/src/main/java/com/dtstack/flink/sql/environment/MyLocalStreamEnvironment.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;6e351a99f6e8449c76ad55e517a5da6cbb108379:core/src/main/java/com/dtstack/flink/sql/environment/MyLocalStreamEnvironment.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b], [j]], subset: [[bj], [b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.environment;
  20 
  21 import org.apache.flink.api.common.InvalidProgramException;
  22 import org.apache.flink.api.common.JobExecutionResult;
  23 import org.apache.flink.api.java.ExecutionEnvironment;
  24 import org.apache.flink.configuration.Configuration;
  25 import org.apache.flink.configuration.RestOptions;
  26 import org.apache.flink.configuration.TaskManagerOptions;
  27 import org.apache.flink.runtime.jobgraph.JobGraph;
  28 import org.apache.flink.runtime.minicluster.MiniCluster;
  29 import org.apache.flink.runtime.minicluster.MiniClusterConfiguration;
  30 import org.apache.flink.streaming.api.environment.LocalStreamEnvironment;
  31 import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
  32 import org.apache.flink.streaming.api.graph.StreamGraph;
  33 import org.slf4j.Logger;
  34 import org.slf4j.LoggerFactory;
  35 
  36 import java.net.URL;
  37 import java.util.Collections;
  38 import java.util.List;
  39 
  40 /**
  41  * Local Stream Environment
  42  *
  43  * Company: www.dtstack.com
  44  * @author huyifan.zju@163.com
  45  */
  46 public class MyLocalStreamEnvironment extends StreamExecutionEnvironment {
  47     private static final Logger LOG = LoggerFactory.getLogger(LocalStreamEnvironment.class);
  48 
  49     /** The configuration to use for the local cluster. */
  50     private final Configuration conf;
  51 
  52     public List&lt;URL&gt; getClasspaths() {
  53         return classpaths;
  54     }
  55 
  56     public void setClasspaths(List&lt;URL&gt; classpaths) {
  57         this.classpaths = classpaths;
  58     }
  59 
  60     private List&lt;URL&gt; classpaths = Collections.emptyList();
  61 
  62     /**
  63      * Creates a new local stream environment that uses the default configuration.
  64      */
  65     public MyLocalStreamEnvironment() {
  66         this(null);
  67     }
  68 
  69     /**
<abbr title="  70      * Creates a new local stream environment that configures its local executor with the given configuration.">  70      * Creates a new local stream environment that configures its local executor with the given configuraðŸ”µ</abbr>
  71      *
  72      * @param config The configuration used to configure the local executor.
  73      */
  74     public MyLocalStreamEnvironment(Configuration config) {
  75         if (!ExecutionEnvironment.areExplicitEnvironmentsAllowed()) {
  76             throw new InvalidProgramException(
<abbr title="  77                     &quot;The LocalStreamEnvironment cannot be used when submitting a program through a client, &quot; +">  77                     &quot;The LocalStreamEnvironment cannot be used when submitting a program through a clientðŸ”µ</abbr>
  78                             &quot;or running in a TestEnvironment context.&quot;);
  79         }
  80 
  81         this.conf = config == null ? new Configuration() : config;
  82     }
  83 
  84     /**
  85      * Executes the JobGraph of the on a mini cluster of CLusterUtil with a user
  86      * specified name.
  87      *
  88      * @param jobName
  89      *            name of the job
  90      * @return The result of the job execution, containing elapsed time and accumulators.
  91      */
  92     @Override
  93     public JobExecutionResult execute(String jobName) throws Exception {
  94         // transform the streaming program into a JobGraph
  95         StreamGraph streamGraph = getStreamGraph();
  96         streamGraph.setJobName(jobName);
  97         return execute(streamGraph);
  98     }
  99 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
 100 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 101         jobGraph.setClasspaths(classpaths);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 102 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 103         Configuration configuration = new Configuration();</span>
 104 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 105 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 106     public JobExecutionResult execute(StreamGraph streamGraph) throws Exception {</span>
 107 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 108 
 109     @Override
 110     public JobExecutionResult execute(StreamGraph streamGraph) throws Exception {
 111         JobGraph jobGraph = streamGraph.getJobGraph();
 112         jobGraph.setClasspaths(classpaths);
 113         jobGraph.setAllowQueuedScheduling(true);
 114 
 115         Configuration configuration = new Configuration();
 116         configuration.addAll(jobGraph.getJobConfiguration());
 117 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 118 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 119         configuration.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE.key(), &quot;512M&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 120         configuration.setInteger(TaskManagerOptions.NUM_TASK_SLOTS.key(), jobGraph.getMaximumParallelism());"> 120         configuration.setInteger(TaskManagerOptions.NUM_TASK_SLOTS.key(), jobGraph.getMaximumParallelism(ðŸ”µ</abbr></span>
 121 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 122         // add (and override) the settings with what the user defined</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 123         configuration.addAll(this.conf);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 124 </span>
 125 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 126         configuration.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE, &quot;0&quot;);</span>
 127 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 128 
 129         // add (and override) the settings with what the user defined
 130         configuration.addAll(this.conf);
 131 
 132         if (!configuration.contains(RestOptions.BIND_PORT)) {
 133             configuration.setString(RestOptions.BIND_PORT, &quot;0&quot;);
 134         }
 135 
<abbr title=" 136         int numSlotsPerTaskManager = configuration.getInteger(TaskManagerOptions.NUM_TASK_SLOTS, jobGraph.getMaximumParallelism());"> 136         int numSlotsPerTaskManager = configuration.getInteger(TaskManagerOptions.NUM_TASK_SLOTS, jobGraphðŸ”µ</abbr>
 137 
 138         MiniClusterConfiguration cfg = new MiniClusterConfiguration.Builder()
 139                 .setConfiguration(configuration)
 140                 .setNumSlotsPerTaskManager(numSlotsPerTaskManager)
 141                 .build();
 142 
 143         if (LOG.isInfoEnabled()) {
 144             LOG.info(&quot;Running job on local embedded Flink mini cluster&quot;);
 145         }
 146 
 147         MiniCluster miniCluster = new MiniCluster(cfg);
 148 
 149         try {
 150             miniCluster.start();
 151             configuration.setInteger(RestOptions.PORT, miniCluster.getRestAddress().get().getPort());
 152 
 153             return miniCluster.executeJobBlocking(jobGraph);
 154         }
 155         finally {
 156             transformations.clear();
 157             miniCluster.close();
 158         }
 159     }
 160 }
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.environment;
  20 
  21 import org.apache.flink.api.common.InvalidProgramException;
  22 import org.apache.flink.api.common.JobExecutionResult;
  23 import org.apache.flink.api.java.ExecutionEnvironment;
  24 import org.apache.flink.configuration.Configuration;
  25 import org.apache.flink.configuration.RestOptions;
  26 import org.apache.flink.configuration.TaskManagerOptions;
  27 import org.apache.flink.runtime.jobgraph.JobGraph;
  28 import org.apache.flink.runtime.minicluster.MiniCluster;
  29 import org.apache.flink.runtime.minicluster.MiniClusterConfiguration;
  30 import org.apache.flink.streaming.api.environment.LocalStreamEnvironment;
  31 import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
  32 import org.apache.flink.streaming.api.graph.StreamGraph;
  33 import org.slf4j.Logger;
  34 import org.slf4j.LoggerFactory;
  35 
  36 import java.net.URL;
  37 import java.util.Collections;
  38 import java.util.List;
  39 
  40 /**
  41  * Local Stream Environment
  42  *
  43  * Company: www.dtstack.com
  44  * @author huyifan.zju@163.com
  45  */
  46 public class MyLocalStreamEnvironment extends StreamExecutionEnvironment {
  47     private static final Logger LOG = LoggerFactory.getLogger(LocalStreamEnvironment.class);
  48 
  49     /** The configuration to use for the local cluster. */
  50     private final Configuration conf;
  51 
  52     public List&lt;URL&gt; getClasspaths() {
  53         return classpaths;
  54     }
  55 
  56     public void setClasspaths(List&lt;URL&gt; classpaths) {
  57         this.classpaths = classpaths;
  58     }
  59 
  60     private List&lt;URL&gt; classpaths = Collections.emptyList();
  61 
  62     /**
  63      * Creates a new local stream environment that uses the default configuration.
  64      */
  65     public MyLocalStreamEnvironment() {
  66         this(null);
  67     }
  68 
  69     /**
<abbr title="  70      * Creates a new local stream environment that configures its local executor with the given configuration.">  70      * Creates a new local stream environment that configures its local executor with the given configuraðŸ”µ</abbr>
  71      *
  72      * @param config The configuration used to configure the local executor.
  73      */
  74     public MyLocalStreamEnvironment(Configuration config) {
  75         if (!ExecutionEnvironment.areExplicitEnvironmentsAllowed()) {
  76             throw new InvalidProgramException(
<abbr title="  77                     &quot;The LocalStreamEnvironment cannot be used when submitting a program through a client, &quot; +">  77                     &quot;The LocalStreamEnvironment cannot be used when submitting a program through a clientðŸ”µ</abbr>
  78                             &quot;or running in a TestEnvironment context.&quot;);
  79         }
  80 
  81         this.conf = config == null ? new Configuration() : config;
  82     }
  83 
  84     /**
  85      * Executes the JobGraph of the on a mini cluster of CLusterUtil with a user
  86      * specified name.
  87      *
  88      * @param jobName
  89      *            name of the job
  90      * @return The result of the job execution, containing elapsed time and accumulators.
  91      */
  92     @Override
  93     public JobExecutionResult execute(String jobName) throws Exception {
  94         // transform the streaming program into a JobGraph
  95         StreamGraph streamGraph = getStreamGraph();
  96         streamGraph.setJobName(jobName);
  97         return execute(streamGraph);
  98     }
  99 
 100 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 101 @Override</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 102     public JobExecutionResult execute(StreamGraph streamGraph) throws Exception {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 103         JobGraph jobGraph = streamGraph.getJobGraph();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 104         jobGraph.setClasspaths(classpaths);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 105 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 106         Configuration configuration = new Configuration();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 107         configuration.addAll(jobGraph.getJobConfiguration());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 108 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 109         configuration.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE.key(), &quot;512M&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 110         configuration.setInteger(TaskManagerOptions.NUM_TASK_SLOTS.key(), jobGraph.getMaximumParallelism());"> 110         configuration.setInteger(TaskManagerOptions.NUM_TASK_SLOTS.key(), jobGraph.getMaximumParallelism(ðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 111 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 112         // add (and override) the settings with what the user defined</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 113         configuration.addAll(this.conf);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 114 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 115         MiniClusterConfiguration.Builder configBuilder = new MiniClusterConfiguration.Builder();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 116         configBuilder.setConfiguration(configuration);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 117 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 118         if (LOG.isInfoEnabled()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 119             LOG.info(&quot;Running job on local embedded Flink mini cluster&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 120         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 121 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 122         try (MiniCluster exec = new MiniCluster(configBuilder.build());) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 123             exec.start();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 124             JobExecutionResult jobExecutionResult = exec.executeJobBlocking(jobGraph);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 125             transformations.clear();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 126             return jobExecutionResult;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 127         } catch (Exception e) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 128             throw new RuntimeException(e);</span>
 129 ||||||| BASE
 130 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 131 public JobExecutionResult execute(StreamGraph streamGraph) throws Exception {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 132 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 133         JobGraph jobGraph = streamGraph.getJobGraph();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 134         jobGraph.setClasspaths(classpaths);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 135         jobGraph.setAllowQueuedScheduling(true);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 136 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 137         Configuration configuration = new Configuration();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 138         configuration.addAll(jobGraph.getJobConfiguration());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 139         configuration.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE, &quot;0&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 140 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 141         // add (and override) the settings with what the user defined</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 142         configuration.addAll(this.conf);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 143 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 144         if (!configuration.contains(RestOptions.BIND_PORT)) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 145             configuration.setString(RestOptions.BIND_PORT, &quot;0&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 146         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 147 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 148         int numSlotsPerTaskManager = configuration.getInteger(TaskManagerOptions.NUM_TASK_SLOTS, jobGraph.getMaximumParallelism());"> 148         int numSlotsPerTaskManager = configuration.getInteger(TaskManagerOptions.NUM_TASK_SLOTS, jobGraphðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 149 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 150         MiniClusterConfiguration cfg = new MiniClusterConfiguration.Builder()</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 151                 .setConfiguration(configuration)</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 152                 .setNumSlotsPerTaskManager(numSlotsPerTaskManager)</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 153                 .build();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 154 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 155         if (LOG.isInfoEnabled()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 156             LOG.info(&quot;Running job on local embedded Flink mini cluster&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 157         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 158 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 159         MiniCluster miniCluster = new MiniCluster(cfg);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 160 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 161         try {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 162             miniCluster.start();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 163             configuration.setInteger(RestOptions.PORT, miniCluster.getRestAddress().get().getPort());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 164 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 165             return miniCluster.executeJobBlocking(jobGraph);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 166         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 167         finally {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 168             transformations.clear();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 169             miniCluster.close();</span>
 170 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 171         }
 172     }
 173 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.environment;
  19 
  20 import java.net.URL;
  21 import java.util.Collections;
  22 import java.util.List;
  23 import org.apache.flink.api.common.InvalidProgramException;
  24 import org.apache.flink.api.common.JobExecutionResult;
  25 import org.apache.flink.api.java.ExecutionEnvironment;
  26 import org.apache.flink.configuration.Configuration;
  27 import org.apache.flink.configuration.RestOptions;
  28 import org.apache.flink.configuration.TaskManagerOptions;
  29 import org.apache.flink.runtime.jobgraph.JobGraph;
  30 import org.apache.flink.runtime.minicluster.MiniCluster;
  31 import org.apache.flink.runtime.minicluster.MiniClusterConfiguration;
  32 import org.apache.flink.streaming.api.environment.LocalStreamEnvironment;
  33 import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
  34 import org.apache.flink.streaming.api.graph.StreamGraph;
  35 import org.slf4j.Logger;
  36 import org.slf4j.LoggerFactory;
  37 
  38 
  39 /**
  40  * Local Stream Environment
  41  *
  42  * Company: www.dtstack.com
  43  * @author huyifan.zju@163.com
  44  */
  45 public class MyLocalStreamEnvironment extends StreamExecutionEnvironment {
  46     private static final Logger LOG = LoggerFactory.getLogger(LocalStreamEnvironment.class);
  47 
  48     /** The configuration to use for the local cluster. */
  49     private final Configuration conf;
  50 
  51     public List&lt;URL&gt; getClasspaths() {
  52         return classpaths;
  53     }
  54 
  55     public void setClasspaths(List&lt;URL&gt; classpaths) {
  56         this.classpaths = classpaths;
  57     }
  58 
  59     private List&lt;URL&gt; classpaths = Collections.emptyList();
  60 
  61     /**
  62      * Creates a new local stream environment that uses the default configuration.
  63      */
  64     public MyLocalStreamEnvironment() {
  65         this(null);
  66     }
  67 
  68     /**
<abbr title="  69      * Creates a new local stream environment that configures its local executor with the given configuration.">  69      * Creates a new local stream environment that configures its local executor with the given configuraðŸ”µ</abbr>
  70      *
  71      * @param config
  72      * 		The configuration used to configure the local executor.
  73      */
  74     public MyLocalStreamEnvironment(Configuration config) {
  75         if (!ExecutionEnvironment.areExplicitEnvironmentsAllowed()) {
<abbr title="  76             throw new InvalidProgramException(&quot;The LocalStreamEnvironment cannot be used when submitting a program through a client, &quot; + &quot;or running in a TestEnvironment context.&quot;);">  76             throw new InvalidProgramException(&quot;The LocalStreamEnvironment cannot be used when submitting ðŸ”µ</abbr>
  77         }
  78         this.conf = (config == null) ? new Configuration() : config;
  79     }
  80 
  81     /**
  82      * Executes the JobGraph of the on a mini cluster of CLusterUtil with a user
  83      * specified name.
  84      *
  85      * @param jobName
  86      *            name of the job
  87      * @return The result of the job execution, containing elapsed time and accumulators.
  88      */
  89     @Override
  90     public JobExecutionResult execute(String jobName) throws Exception {
  91         // transform the streaming program into a JobGraph
  92         StreamGraph streamGraph = getStreamGraph();
  93         streamGraph.setJobName(jobName);
  94         return execute(streamGraph);
  95     }
  96 
  97     public JobExecutionResult execute(StreamGraph streamGraph) throws Exception {
  98         JobGraph jobGraph = streamGraph.getJobGraph();
  99         jobGraph.setClasspaths(classpaths);
 100         jobGraph.setAllowQueuedScheduling(true);
 101         Configuration configuration = new Configuration();
 102         configuration.addAll(jobGraph.getJobConfiguration());
 103         configuration.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE.key(), &quot;0&quot;);
 104         // add (and override) the settings with what the user defined
 105         configuration.addAll(this.conf);
 106         if (!configuration.contains(RestOptions.BIND_PORT)) {
 107             configuration.setString(RestOptions.BIND_PORT, &quot;0&quot;);
 108         }
<abbr title=" 109         int numSlotsPerTaskManager = configuration.getInteger(TaskManagerOptions.NUM_TASK_SLOTS, jobGraph.getMaximumParallelism());"> 109         int numSlotsPerTaskManager = configuration.getInteger(TaskManagerOptions.NUM_TASK_SLOTS, jobGraphðŸ”µ</abbr>
<abbr title=" 110         MiniClusterConfiguration cfg = new MiniClusterConfiguration.Builder().setConfiguration(configuration).setNumSlotsPerTaskManager(numSlotsPerTaskManager).build();"> 110         MiniClusterConfiguration cfg = new MiniClusterConfiguration.Builder().setConfiguration(configuratðŸ”µ</abbr>
 111         if (LOG.isInfoEnabled()) {
 112             LOG.info(&quot;Running job on local embedded Flink mini cluster&quot;);
 113         }
 114         MiniCluster miniCluster = new MiniCluster(cfg);
 115         try {
 116             miniCluster.start();
 117             configuration.setInteger(RestOptions.PORT, miniCluster.getRestAddress().get().getPort());
 118             return miniCluster.executeJobBlocking(jobGraph);
 119         } finally {
 120             transformations.clear();
 121             miniCluster.close();
 122         }
 123     }
 124 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.environment;
  20  
  21  import org.apache.flink.api.common.InvalidProgramException;
  22  import org.apache.flink.api.common.JobExecutionResult;
  23  import org.apache.flink.api.java.ExecutionEnvironment;
  24  import org.apache.flink.configuration.Configuration;

  25  import org.apache.flink.configuration.TaskManagerOptions;
  26  import org.apache.flink.runtime.jobgraph.JobGraph;
  27  import org.apache.flink.runtime.minicluster.MiniCluster;
  28  import org.apache.flink.runtime.minicluster.MiniClusterConfiguration;
  29  import org.apache.flink.streaming.api.environment.LocalStreamEnvironment;
  30  import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
  31  import org.apache.flink.streaming.api.graph.StreamGraph;
  32  import org.slf4j.Logger;
  33  import org.slf4j.LoggerFactory;
  34  
  35  import java.net.URL;
  36  import java.util.Collections;
  37  import java.util.List;
  38  
  39  /**
  40   * Local Stream Environment
  41   *
  42   * Company: www.dtstack.com
  43   * @author huyifan.zju@163.com
  44   */
  45  public class MyLocalStreamEnvironment extends StreamExecutionEnvironment {
  46      private static final Logger LOG = LoggerFactory.getLogger(LocalStreamEnvironment.class);
  47  
  48      /** The configuration to use for the local cluster. */
  49      private final Configuration conf;
  50  
  51      public List&lt;URL&gt; getClasspaths() {
  52          return classpaths;
  53      }
  54  
  55      public void setClasspaths(List&lt;URL&gt; classpaths) {
  56          this.classpaths = classpaths;
  57      }
  58  
  59      private List&lt;URL&gt; classpaths = Collections.emptyList();
  60  
  61      /**
  62       * Creates a new local stream environment that uses the default configuration.
  63       */
  64      public MyLocalStreamEnvironment() {
  65          this(null);
  66      }
  67  
  68      /**
  69       * Creates a new local stream environment that configures its local executor with the given configuration.
  70       *
  71       * @param config The configuration used to configure the local executor.
  72       */
  73      public MyLocalStreamEnvironment(Configuration config) {
  74          if (!ExecutionEnvironment.areExplicitEnvironmentsAllowed()) {
  75              throw new InvalidProgramException(
  76                      &quot;The LocalStreamEnvironment cannot be used when submitting a program through a client, &quot; +
  77                              &quot;or running in a TestEnvironment context.&quot;);
  78          }
  79  
  80          this.conf = config == null ? new Configuration() : config;
  81      }
  82  
  83      /**
  84       * Executes the JobGraph of the on a mini cluster of CLusterUtil with a user
  85       * specified name.
  86       *
  87       * @param jobName
  88       *            name of the job
  89       * @return The result of the job execution, containing elapsed time and accumulators.
  90       */
  91      @Override
  92      public JobExecutionResult execute(String jobName) throws Exception {
  93          // transform the streaming program into a JobGraph
  94          StreamGraph streamGraph = getStreamGraph();
  95          streamGraph.setJobName(jobName);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  96 +        return execute(streamGraph);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  97 +    }</span>


  98  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  99 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 100 +    public JobExecutionResult execute(StreamGraph streamGraph) throws Exception {</span>
 101          JobGraph jobGraph = streamGraph.getJobGraph();
 102          jobGraph.setClasspaths(classpaths);

 103  
 104          Configuration configuration = new Configuration();
 105          configuration.addAll(jobGraph.getJobConfiguration());
 106  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 107 -        configuration.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE, &quot;512M&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 108 -        configuration.setInteger(TaskManagerOptions.NUM_TASK_SLOTS, jobGraph.getMaximumParallelism());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 109 +        configuration.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE.key(), &quot;512M&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 110 +        configuration.setInteger(TaskManagerOptions.NUM_TASK_SLOTS.key(), jobGraph.getMaximumParallelism());</span>
 111  
 112          // add (and override) the settings with what the user defined
 113          configuration.addAll(this.conf);
 114  
 115          MiniClusterConfiguration.Builder configBuilder = new MiniClusterConfiguration.Builder();
 116          configBuilder.setConfiguration(configuration);










 117  
 118          if (LOG.isInfoEnabled()) {
 119              LOG.info(&quot;Running job on local embedded Flink mini cluster&quot;);
 120          }
 121  
 122          try (MiniCluster exec = new MiniCluster(configBuilder.build());) {
 123              exec.start();
 124              JobExecutionResult jobExecutionResult = exec.executeJobBlocking(jobGraph);









 125              transformations.clear();
 126              return jobExecutionResult;
 127          } catch (Exception e) {
 128              throw new RuntimeException(e);

 129          }
 130      }
 131  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.environment;
  20  
  21  import org.apache.flink.api.common.InvalidProgramException;
  22  import org.apache.flink.api.common.JobExecutionResult;
  23  import org.apache.flink.api.java.ExecutionEnvironment;
  24  import org.apache.flink.configuration.Configuration;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  25 +import org.apache.flink.configuration.RestOptions;</span>
  26  import org.apache.flink.configuration.TaskManagerOptions;
  27  import org.apache.flink.runtime.jobgraph.JobGraph;
  28  import org.apache.flink.runtime.minicluster.MiniCluster;
  29  import org.apache.flink.runtime.minicluster.MiniClusterConfiguration;
  30  import org.apache.flink.streaming.api.environment.LocalStreamEnvironment;
  31  import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
  32  import org.apache.flink.streaming.api.graph.StreamGraph;
  33  import org.slf4j.Logger;
  34  import org.slf4j.LoggerFactory;
  35  
  36  import java.net.URL;
  37  import java.util.Collections;
  38  import java.util.List;
  39  
  40  /**
  41   * Local Stream Environment
  42   *
  43   * Company: www.dtstack.com
  44   * @author huyifan.zju@163.com
  45   */
  46  public class MyLocalStreamEnvironment extends StreamExecutionEnvironment {
  47      private static final Logger LOG = LoggerFactory.getLogger(LocalStreamEnvironment.class);
  48  
  49      /** The configuration to use for the local cluster. */
  50      private final Configuration conf;
  51  
  52      public List&lt;URL&gt; getClasspaths() {
  53          return classpaths;
  54      }
  55  
  56      public void setClasspaths(List&lt;URL&gt; classpaths) {
  57          this.classpaths = classpaths;
  58      }
  59  
  60      private List&lt;URL&gt; classpaths = Collections.emptyList();
  61  
  62      /**
  63       * Creates a new local stream environment that uses the default configuration.
  64       */
  65      public MyLocalStreamEnvironment() {
  66          this(null);
  67      }
  68  
  69      /**
  70       * Creates a new local stream environment that configures its local executor with the given configuration.
  71       *
  72       * @param config The configuration used to configure the local executor.
  73       */
  74      public MyLocalStreamEnvironment(Configuration config) {
  75          if (!ExecutionEnvironment.areExplicitEnvironmentsAllowed()) {
  76              throw new InvalidProgramException(
  77                      &quot;The LocalStreamEnvironment cannot be used when submitting a program through a client, &quot; +
  78                              &quot;or running in a TestEnvironment context.&quot;);
  79          }
  80  
  81          this.conf = config == null ? new Configuration() : config;
  82      }
  83  
  84      /**
  85       * Executes the JobGraph of the on a mini cluster of CLusterUtil with a user
  86       * specified name.
  87       *
  88       * @param jobName
  89       *            name of the job
  90       * @return The result of the job execution, containing elapsed time and accumulators.
  91       */
  92      @Override
  93      public JobExecutionResult execute(String jobName) throws Exception {
  94          // transform the streaming program into a JobGraph
  95          StreamGraph streamGraph = getStreamGraph();
  96          streamGraph.setJobName(jobName);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  97 +        return execute(streamGraph);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  98 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  99 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 100 +    public JobExecutionResult execute(StreamGraph streamGraph) throws Exception {</span>
 101  


 102          JobGraph jobGraph = streamGraph.getJobGraph();
 103          jobGraph.setClasspaths(classpaths);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 104 +        jobGraph.setAllowQueuedScheduling(true);</span>
 105  
 106          Configuration configuration = new Configuration();
 107          configuration.addAll(jobGraph.getJobConfiguration());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 108 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 109 -        configuration.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE, &quot;512M&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 110 -        configuration.setInteger(TaskManagerOptions.NUM_TASK_SLOTS, jobGraph.getMaximumParallelism());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 111 +        configuration.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE, &quot;0&quot;);</span>

 112  
 113          // add (and override) the settings with what the user defined
 114          configuration.addAll(this.conf);
 115  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 116 -        MiniClusterConfiguration.Builder configBuilder = new MiniClusterConfiguration.Builder();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 117 -        configBuilder.setConfiguration(configuration);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 118 +        if (!configuration.contains(RestOptions.BIND_PORT)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 119 +            configuration.setString(RestOptions.BIND_PORT, &quot;0&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 120 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 121 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 122 +        int numSlotsPerTaskManager = configuration.getInteger(TaskManagerOptions.NUM_TASK_SLOTS, jobGraph.getMaximumParallelism());"> 122 +        int numSlotsPerTaskManager = configuration.getInteger(TaskManagerOptions.NUM_TASK_SLOTS, jobGraph.getMaximðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 123 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 124 +        MiniClusterConfiguration cfg = new MiniClusterConfiguration.Builder()</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 125 +                .setConfiguration(configuration)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 126 +                .setNumSlotsPerTaskManager(numSlotsPerTaskManager)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 127 +                .build();</span>
 128  
 129          if (LOG.isInfoEnabled()) {
 130              LOG.info(&quot;Running job on local embedded Flink mini cluster&quot;);
 131          }
 132  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 133 -        try (MiniCluster exec = new MiniCluster(configBuilder.build());) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 134 -            exec.start();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 135 -            JobExecutionResult jobExecutionResult = exec.executeJobBlocking(jobGraph);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 136 +        MiniCluster miniCluster = new MiniCluster(cfg);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 137 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 138 +        try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 139 +            miniCluster.start();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 140 +            configuration.setInteger(RestOptions.PORT, miniCluster.getRestAddress().get().getPort());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 141 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 142 +            return miniCluster.executeJobBlocking(jobGraph);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 143 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 144 +        finally {</span>
 145              transformations.clear();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 146 -            return jobExecutionResult;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 147 -        } catch (Exception e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 148 -            throw new RuntimeException(e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 149 +            miniCluster.close();</span>
 150          }
 151      }
 152  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            