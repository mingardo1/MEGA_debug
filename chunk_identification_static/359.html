<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>359</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    359
                    <a href="358.html">prev</a>
                    <a href="360.html">next</a>
                    <a href="359_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_5553ee5c6410a412ab4ed61d9499805adee8995a_core/src/main/java/com/dtstack/flink/sql/parser/CreateTmpTableParser.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;5553ee5c6410a412ab4ed61d9499805adee8995a:core/src/main/java/com/dtstack/flink/sql/parser/CreateTmpTableParser.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;5553ee5c6410a412ab4ed61d9499805adee8995a^1:core/src/main/java/com/dtstack/flink/sql/parser/CreateTmpTableParser.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;5553ee5c6410a412ab4ed61d9499805adee8995a^2:core/src/main/java/com/dtstack/flink/sql/parser/CreateTmpTableParser.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e0a10435dcb243a911c0405daebc6aa667d5119d:core/src/main/java/com/dtstack/flink/sql/parser/CreateTmpTableParser.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.parser;
  22 
  23 import com.dtstack.flink.sql.util.DtStringUtil;
  24 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  25 import org.apache.calcite.sql.SqlBasicCall;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  26 import org.apache.calcite.sql.SqlJoin;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  27 import org.apache.calcite.sql.SqlKind;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  28 import org.apache.calcite.sql.SqlNode;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  29 import org.apache.calcite.sql.SqlSelect;</span>
  30 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  31 import org.apache.calcite.config.Lex;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  32 import org.apache.calcite.sql.SqlBasicCall;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  33 import org.apache.calcite.sql.SqlJoin;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  34 import org.apache.calcite.sql.SqlKind;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  35 import org.apache.calcite.sql.SqlNode;</span>
  36 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  37 import org.apache.calcite.config.Lex;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  38 import org.apache.calcite.sql.*;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  39 import org.apache.calcite.sql.parser.SqlParseException;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  40 import org.apache.calcite.sql.parser.SqlParser;</span>
  41 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  42 import com.google.common.collect.Lists;
  43 import java.util.List;
  44 import java.util.regex.Matcher;
  45 import java.util.regex.Pattern;
  46 
  47 import static org.apache.calcite.sql.SqlKind.IDENTIFIER;
  48 
  49 /**
  50  * parser create tmp table sql
  51  * Date: 2018/6/26
  52  * Company: www.dtstack.com
  53  * @author yanxi
  54  */
  55 public class CreateTmpTableParser implements IParser {
  56 
  57     //select table tableName as select
  58     private static final String PATTERN_STR = &quot;(?i)create\\s+view\\s+([^\\s]+)\\s+as\\s+select\\s+(.*)&quot;;
  59 
  60     private static final String EMPTY_STR = &quot;(?i)^\\screate\\s+view\\s+(\\S+)\\s*\\((.+)\\)$&quot;;
  61 
  62     private static final Pattern NONEMPTYVIEW = Pattern.compile(PATTERN_STR);
  63 
  64     private static final Pattern EMPTYVIEW = Pattern.compile(EMPTY_STR);
  65 
  66     private FlinkPlanner flinkPlanner = new FlinkPlanner();
  67 
  68     public static CreateTmpTableParser newInstance(){
  69         return new CreateTmpTableParser();
  70     }
  71 
  72     @Override
  73     public boolean verify(String sql) {
  74         if (Pattern.compile(EMPTY_STR).matcher(sql).find()){
  75             return true;
  76         }
  77         return NONEMPTYVIEW.matcher(sql).find();
  78     }
  79 
  80     @Override
  81     public void parseSql(String sql, SqlTree sqlTree) {
  82         if (NONEMPTYVIEW.matcher(sql).find()){
  83             Matcher matcher = NONEMPTYVIEW.matcher(sql);
  84             String tableName = null;
  85             String selectSql = null;
  86             if(matcher.find()) {
  87                 tableName = matcher.group(1);
  88                 selectSql = &quot;select &quot; + matcher.group(2);
  89             }
  90 
  91             SqlNode sqlNode = null;
  92             try {
  93                 sqlNode = flinkPlanner.getParser().parse(selectSql);
  94             } catch (Exception e) {
  95                 throw new RuntimeException(&quot;&quot;, e);
  96             }
  97 
<abbr title="  98             CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResult();">  98             CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResul🔵</abbr>
  99             parseNode(sqlNode, sqlParseResult);
 100 
 101             sqlParseResult.setTableName(tableName);
 102             String transformSelectSql = DtStringUtil.replaceIgnoreQuota(sqlNode.toString(), &quot;`&quot;, &quot;&quot;);
 103             sqlParseResult.setExecSql(transformSelectSql);
 104             sqlTree.addTmpSql(sqlParseResult);
 105             sqlTree.addTmplTableInfo(tableName, sqlParseResult);
 106         } else {
 107             if (EMPTYVIEW.matcher(sql).find())
 108             {
 109                 Matcher matcher = EMPTYVIEW.matcher(sql);
 110                 String tableName = null;
 111                 String fieldsInfoStr = null;
 112                 if (matcher.find()){
 113                     tableName = matcher.group(1);
 114                     fieldsInfoStr = matcher.group(2);
 115                 }
<abbr title=" 116                 CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResult();"> 116                 CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserR🔵</abbr>
 117                 sqlParseResult.setFieldsInfoStr(fieldsInfoStr);
 118                 sqlParseResult.setTableName(tableName);
 119                 sqlTree.addTmplTableInfo(tableName, sqlParseResult);
 120             }
 121 
 122         }
 123 
 124     }
 125 
 126     private static void parseNode(SqlNode sqlNode, CreateTmpTableParser.SqlParserResult sqlParseResult){
 127         SqlKind sqlKind = sqlNode.getKind();
 128         switch (sqlKind){
 129             case SELECT:
 130                 SqlNode sqlFrom = ((SqlSelect)sqlNode).getFrom();
 131                 if(sqlFrom.getKind() == IDENTIFIER){
 132                     sqlParseResult.addSourceTable(sqlFrom.toString());
 133                 }else{
 134                     parseNode(sqlFrom, sqlParseResult);
 135                 }
 136                 break;
 137             case JOIN:
 138                 SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 139                 SqlNode rightNode = ((SqlJoin)sqlNode).getRight();
 140 
 141                 if(leftNode.getKind() == IDENTIFIER){
 142                     sqlParseResult.addSourceTable(leftNode.toString());
 143                 }else{
 144                     parseNode(leftNode, sqlParseResult);
 145                 }
 146 
 147                 if(rightNode.getKind() == IDENTIFIER){
 148                     sqlParseResult.addSourceTable(rightNode.toString());
 149                 }else{
 150                     parseNode(rightNode, sqlParseResult);
 151                 }
 152                 break;
 153             case AS:
 154                 //不解析column,所以 as 相关的都是表
 155                 SqlNode identifierNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 156                 if(identifierNode.getKind() != IDENTIFIER){
 157                     parseNode(identifierNode, sqlParseResult);
 158                 }else {
 159                     sqlParseResult.addSourceTable(identifierNode.toString());
 160                 }
 161                 break;
 162             case UNION:
 163                 SqlNode unionLeft = ((SqlBasicCall)sqlNode).getOperands()[0];
 164                 SqlNode unionRight = ((SqlBasicCall)sqlNode).getOperands()[1];
 165                 if(unionLeft.getKind() == IDENTIFIER){
 166                     sqlParseResult.addSourceTable(unionLeft.toString());
 167                 }else{
 168                     parseNode(unionLeft, sqlParseResult);
 169                 }
 170                 if(unionRight.getKind() == IDENTIFIER){
 171                     sqlParseResult.addSourceTable(unionRight.toString());
 172                 }else{
 173                     parseNode(unionRight, sqlParseResult);
 174                 }
 175                 break;
 176             case MATCH_RECOGNIZE:
 177                 SqlMatchRecognize node = (SqlMatchRecognize) sqlNode;
 178                 sqlParseResult.addSourceTable(node.getTableRef().toString());
 179                 break;
 180             default:
 181                 //do nothing
 182                 break;
 183         }
 184     }
 185 
 186     public static class SqlParserResult {
 187         private String tableName;
 188 
 189         private String fieldsInfoStr;
 190 
 191         private String execSql;
 192 
 193         private List&lt;String&gt; sourceTableList = Lists.newArrayList();
 194 
 195         public String getTableName() {
 196             return tableName;
 197         }
 198 
 199         public void setTableName(String tableName) {
 200             this.tableName = tableName;
 201         }
 202 
 203         public String getExecSql() {
 204             return execSql;
 205         }
 206 
 207         public void setExecSql(String execSql) {
 208             this.execSql = execSql;
 209         }
 210 
 211         public String getFieldsInfoStr() {
 212             return fieldsInfoStr;
 213         }
 214 
 215         public void setFieldsInfoStr(String fieldsInfoStr) {
 216             this.fieldsInfoStr = fieldsInfoStr;
 217         }
 218 
 219         public void addSourceTable(String sourceTable){
 220             sourceTableList.add(sourceTable);
 221         }
 222 
 223         public List&lt;String&gt; getSourceTableList() {
 224             return sourceTableList;
 225         }
 226 
 227     }
 228 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.parser;
  22 
  23 import com.dtstack.flink.sql.util.DtStringUtil;
  24 import org.apache.calcite.sql.*;
  25 import com.google.common.collect.Lists;
  26 import java.util.List;
  27 import java.util.regex.Matcher;
  28 import java.util.regex.Pattern;
  29 
  30 import static org.apache.calcite.sql.SqlKind.IDENTIFIER;
  31 
  32 /**
  33  * parser create tmp table sql
  34  * Date: 2018/6/26
  35  * Company: www.dtstack.com
  36  * @author yanxi
  37  */
  38 public class CreateTmpTableParser implements IParser {
  39 
  40     //select table tableName as select
  41     private static final String PATTERN_STR = &quot;(?i)create\\s+view\\s+([^\\s]+)\\s+as\\s+select\\s+(.*)&quot;;
  42 
  43     private static final String EMPTY_STR = &quot;(?i)^\\screate\\s+view\\s+(\\S+)\\s*\\((.+)\\)$&quot;;
  44 
  45     private static final Pattern NONEMPTYVIEW = Pattern.compile(PATTERN_STR);
  46 
  47     private static final Pattern EMPTYVIEW = Pattern.compile(EMPTY_STR);
  48 
  49     private FlinkPlanner flinkPlanner = new FlinkPlanner();
  50 
  51     public static CreateTmpTableParser newInstance(){
  52         return new CreateTmpTableParser();
  53     }
  54 
  55     @Override
  56     public boolean verify(String sql) {
  57         if (Pattern.compile(EMPTY_STR).matcher(sql).find()){
  58             return true;
  59         }
  60         return NONEMPTYVIEW.matcher(sql).find();
  61     }
  62 
  63     @Override
  64     public void parseSql(String sql, SqlTree sqlTree) {
  65         if (NONEMPTYVIEW.matcher(sql).find()){
  66             Matcher matcher = NONEMPTYVIEW.matcher(sql);
  67             String tableName = null;
  68             String selectSql = null;
  69             if(matcher.find()) {
  70                 tableName = matcher.group(1);
  71                 selectSql = &quot;select &quot; + matcher.group(2);
  72             }
  73 
  74             SqlNode sqlNode = null;
  75             try {
  76                 sqlNode = flinkPlanner.getParser().parse(selectSql);
  77             } catch (Exception e) {
  78                 throw new RuntimeException(&quot;&quot;, e);
  79             }
  80 
<abbr title="  81             CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResult();">  81             CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResul🔵</abbr>
  82             parseNode(sqlNode, sqlParseResult);
  83 
  84             sqlParseResult.setTableName(tableName);
  85             String transformSelectSql = DtStringUtil.replaceIgnoreQuota(sqlNode.toString(), &quot;`&quot;, &quot;&quot;);
  86             sqlParseResult.setExecSql(transformSelectSql);
  87             sqlTree.addTmpSql(sqlParseResult);
  88             sqlTree.addTmplTableInfo(tableName, sqlParseResult);
  89         } else {
  90             if (EMPTYVIEW.matcher(sql).find())
  91             {
  92                 Matcher matcher = EMPTYVIEW.matcher(sql);
  93                 String tableName = null;
  94                 String fieldsInfoStr = null;
  95                 if (matcher.find()){
  96                     tableName = matcher.group(1);
  97                     fieldsInfoStr = matcher.group(2);
  98                 }
<abbr title="  99                 CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResult();">  99                 CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserR🔵</abbr>
 100                 sqlParseResult.setFieldsInfoStr(fieldsInfoStr);
 101                 sqlParseResult.setTableName(tableName);
 102                 sqlTree.addTmplTableInfo(tableName, sqlParseResult);
 103             }
 104 
 105         }
 106 
 107     }
 108 
 109     private static void parseNode(SqlNode sqlNode, CreateTmpTableParser.SqlParserResult sqlParseResult){
 110         SqlKind sqlKind = sqlNode.getKind();
 111         switch (sqlKind){
 112             case SELECT:
 113                 SqlNode sqlFrom = ((SqlSelect)sqlNode).getFrom();
 114                 if(sqlFrom.getKind() == IDENTIFIER){
 115                     sqlParseResult.addSourceTable(sqlFrom.toString());
 116                 }else{
 117                     parseNode(sqlFrom, sqlParseResult);
 118                 }
 119                 break;
 120             case JOIN:
 121                 SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 122                 SqlNode rightNode = ((SqlJoin)sqlNode).getRight();
 123 
 124                 if(leftNode.getKind() == IDENTIFIER){
 125                     sqlParseResult.addSourceTable(leftNode.toString());
 126                 }else{
 127                     parseNode(leftNode, sqlParseResult);
 128                 }
 129 
 130                 if(rightNode.getKind() == IDENTIFIER){
 131                     sqlParseResult.addSourceTable(rightNode.toString());
 132                 }else{
 133                     parseNode(rightNode, sqlParseResult);
 134                 }
 135                 break;
 136             case AS:
 137                 //不解析column,所以 as 相关的都是表
 138                 SqlNode identifierNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 139                 if(identifierNode.getKind() != IDENTIFIER){
 140                     parseNode(identifierNode, sqlParseResult);
 141                 }else {
 142                     sqlParseResult.addSourceTable(identifierNode.toString());
 143                 }
 144                 break;
 145             case UNION:
 146                 SqlNode unionLeft = ((SqlBasicCall)sqlNode).getOperands()[0];
 147                 SqlNode unionRight = ((SqlBasicCall)sqlNode).getOperands()[1];
 148                 if(unionLeft.getKind() == IDENTIFIER){
 149                     sqlParseResult.addSourceTable(unionLeft.toString());
 150                 }else{
 151                     parseNode(unionLeft, sqlParseResult);
 152                 }
 153                 if(unionRight.getKind() == IDENTIFIER){
 154                     sqlParseResult.addSourceTable(unionRight.toString());
 155                 }else{
 156                     parseNode(unionRight, sqlParseResult);
 157                 }
 158                 break;
 159             case MATCH_RECOGNIZE:
 160                 SqlMatchRecognize node = (SqlMatchRecognize) sqlNode;
 161                 sqlParseResult.addSourceTable(node.getTableRef().toString());
 162                 break;
 163             default:
 164                 //do nothing
 165                 break;
 166         }
 167     }
 168 
 169     public static class SqlParserResult {
 170         private String tableName;
 171 
 172         private String fieldsInfoStr;
 173 
 174         private String execSql;
 175 
 176         private List&lt;String&gt; sourceTableList = Lists.newArrayList();
 177 
 178         public String getTableName() {
 179             return tableName;
 180         }
 181 
 182         public void setTableName(String tableName) {
 183             this.tableName = tableName;
 184         }
 185 
 186         public String getExecSql() {
 187             return execSql;
 188         }
 189 
 190         public void setExecSql(String execSql) {
 191             this.execSql = execSql;
 192         }
 193 
 194         public String getFieldsInfoStr() {
 195             return fieldsInfoStr;
 196         }
 197 
 198         public void setFieldsInfoStr(String fieldsInfoStr) {
 199             this.fieldsInfoStr = fieldsInfoStr;
 200         }
 201 
 202         public void addSourceTable(String sourceTable){
 203             sourceTableList.add(sourceTable);
 204         }
 205 
 206         public List&lt;String&gt; getSourceTableList() {
 207             return sourceTableList;
 208         }
 209 
 210     }
 211 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.parser;
  19 
  20 import com.dtstack.flink.sql.util.DtStringUtil;
  21 import com.google.common.collect.Lists;
  22 import java.util.List;
  23 import java.util.regex.Matcher;
  24 import java.util.regex.Pattern;
  25 import org.apache.calcite.sql.*;
  26 import static org.apache.calcite.sql.SqlKind.IDENTIFIER;
  27 
  28 
  29 /**
  30  * parser create tmp table sql
  31  * Date: 2018/6/26
  32  * Company: www.dtstack.com
  33  * @author yanxi
  34  */
  35 public class CreateTmpTableParser implements IParser {
  36     //select table tableName as select
  37     //select table tableName as select
  38     private static final String PATTERN_STR = &quot;(?i)create\\s+view\\s+([^\\s]+)\\s+as\\s+select\\s+(.*)&quot;;
  39 
  40     private static final String EMPTY_STR = &quot;(?i)^\\screate\\s+view\\s+(\\S+)\\s*\\((.+)\\)$&quot;;
  41 
  42     private static final Pattern NONEMPTYVIEW = Pattern.compile(PATTERN_STR);
  43 
  44     private static final Pattern EMPTYVIEW = Pattern.compile(EMPTY_STR);
  45 
  46     private FlinkPlanner flinkPlanner = new FlinkPlanner();
  47 
  48     public static CreateTmpTableParser newInstance(){
  49         return new CreateTmpTableParser();
  50     }
  51 
  52     @Override
  53     public boolean verify(String sql) {
  54         if (Pattern.compile(EMPTY_STR).matcher(sql).find()){
  55             return true;
  56         }
  57         return NONEMPTYVIEW.matcher(sql).find();
  58     }
  59 
  60     @Override
  61     public void parseSql(String sql, SqlTree sqlTree) {
  62         if (NONEMPTYVIEW.matcher(sql).find()) {
  63             Matcher matcher = NONEMPTYVIEW.matcher(sql);
  64             String tableName = null;
  65             String selectSql = null;
  66             if (matcher.find()) {
  67                 tableName = matcher.group(1);
  68                 selectSql = &quot;select &quot; + matcher.group(2);
  69             }
  70             SqlNode sqlNode = null;
  71             try {
  72                 sqlNode = flinkPlanner.getParser().parse(selectSql);
  73             } catch (java.lang.Exception e) {
  74                 throw new RuntimeException(&quot;&quot;, e);
  75             }
<abbr title="  76             CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResult();">  76             CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResul🔵</abbr>
  77             parseNode(sqlNode, sqlParseResult);
  78             sqlParseResult.setTableName(tableName);
  79             String transformSelectSql = DtStringUtil.replaceIgnoreQuota(sqlNode.toString(), &quot;`&quot;, &quot;&quot;);
  80             sqlParseResult.setExecSql(transformSelectSql);
  81             sqlTree.addTmpSql(sqlParseResult);
  82             sqlTree.addTmplTableInfo(tableName, sqlParseResult);
  83         } else if (EMPTYVIEW.matcher(sql).find()) {
  84             Matcher matcher = EMPTYVIEW.matcher(sql);
  85             String tableName = null;
  86             String fieldsInfoStr = null;
  87             if (matcher.find()) {
  88                 tableName = matcher.group(1);
  89                 fieldsInfoStr = matcher.group(2);
  90             }
<abbr title="  91             CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResult();">  91             CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResul🔵</abbr>
  92             sqlParseResult.setFieldsInfoStr(fieldsInfoStr);
  93             sqlParseResult.setTableName(tableName);
  94             sqlTree.addTmplTableInfo(tableName, sqlParseResult);
  95         }
  96     }
  97 
  98     private static void parseNode(SqlNode sqlNode, CreateTmpTableParser.SqlParserResult sqlParseResult) {
  99         SqlKind sqlKind = sqlNode.getKind();
 100         switch (sqlKind) {
 101             case SELECT :
 102                 SqlNode sqlFrom = ((SqlSelect) (sqlNode)).getFrom();
 103                 if (sqlFrom.getKind() == IDENTIFIER) {
 104                     sqlParseResult.addSourceTable(sqlFrom.toString());
 105                 } else {
 106                     parseNode(sqlFrom, sqlParseResult);
 107                 }
 108                 break;
 109             case JOIN :
 110                 SqlNode leftNode = ((SqlJoin) (sqlNode)).getLeft();
 111                 SqlNode rightNode = ((SqlJoin) (sqlNode)).getRight();
 112                 if (leftNode.getKind() == IDENTIFIER) {
 113                     sqlParseResult.addSourceTable(leftNode.toString());
 114                 } else {
 115                     parseNode(leftNode, sqlParseResult);
 116                 }
 117                 if (rightNode.getKind() == IDENTIFIER) {
 118                     sqlParseResult.addSourceTable(rightNode.toString());
 119                 } else {
 120                     parseNode(rightNode, sqlParseResult);
 121                 }
 122                 break;
 123             case AS :
 124                 //不解析column,所以 as 相关的都是表
 125                 SqlNode identifierNode = ((SqlBasicCall) (sqlNode)).getOperands()[0];
 126                 if (identifierNode.getKind() != IDENTIFIER) {
 127                     parseNode(identifierNode, sqlParseResult);
 128                 } else {
 129                     sqlParseResult.addSourceTable(identifierNode.toString());
 130                 }
 131                 break;
 132             case UNION :
 133                 SqlNode unionLeft = ((SqlBasicCall) (sqlNode)).getOperands()[0];
 134                 SqlNode unionRight = ((SqlBasicCall) (sqlNode)).getOperands()[1];
 135                 if (unionLeft.getKind() == IDENTIFIER) {
 136                     sqlParseResult.addSourceTable(unionLeft.toString());
 137                 } else {
 138                     parseNode(unionLeft, sqlParseResult);
 139                 }
 140                 if (unionRight.getKind() == IDENTIFIER) {
 141                     sqlParseResult.addSourceTable(unionRight.toString());
 142                 } else {
 143                     parseNode(unionRight, sqlParseResult);
 144                 }
 145                 break;
 146             case MATCH_RECOGNIZE :
 147                 SqlMatchRecognize node = ((SqlMatchRecognize) (sqlNode));
 148                 sqlParseResult.addSourceTable(node.getTableRef().toString());
 149                 break;
 150             default :
 151                 // do nothing
 152                 break;
 153         }
 154     }
 155 
 156     public static class SqlParserResult {
 157         private String tableName;
 158 
 159         private String fieldsInfoStr;
 160 
 161         private String execSql;
 162 
 163         private List&lt;String&gt; sourceTableList = Lists.newArrayList();
 164 
 165         public String getTableName() {
 166             return tableName;
 167         }
 168 
 169         public void setTableName(String tableName) {
 170             this.tableName = tableName;
 171         }
 172 
 173         public String getExecSql() {
 174             return execSql;
 175         }
 176 
 177         public void setExecSql(String execSql) {
 178             this.execSql = execSql;
 179         }
 180 
 181         public String getFieldsInfoStr() {
 182             return fieldsInfoStr;
 183         }
 184 
 185         public void setFieldsInfoStr(String fieldsInfoStr) {
 186             this.fieldsInfoStr = fieldsInfoStr;
 187         }
 188 
 189         public void addSourceTable(String sourceTable) {
 190             sourceTableList.add(sourceTable);
 191         }
 192 
 193         public List&lt;String&gt; getSourceTableList() {
 194             return sourceTableList;
 195         }
 196     }
 197 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.parser;
  22  
  23  import com.dtstack.flink.sql.util.DtStringUtil;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  24 -import org.apache.calcite.config.Lex;</span>
  25  import org.apache.calcite.sql.SqlBasicCall;
  26  import org.apache.calcite.sql.SqlJoin;
  27  import org.apache.calcite.sql.SqlKind;
  28  import org.apache.calcite.sql.SqlNode;
  29  import org.apache.calcite.sql.SqlSelect;

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  30 -import org.apache.calcite.sql.parser.SqlParseException;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  31 -import org.apache.calcite.sql.parser.SqlParser;</span>
  32  import com.google.common.collect.Lists;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  33 -import org.apache.flink.table.calcite.FlinkPlannerImpl;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  34 -</span>
  35  import java.util.List;
  36  import java.util.regex.Matcher;
  37  import java.util.regex.Pattern;
  38  
  39  import static org.apache.calcite.sql.SqlKind.IDENTIFIER;
  40  
  41  /**
  42   * parser create tmp table sql
  43   * Date: 2018/6/26
  44   * Company: www.dtstack.com
  45   * @author yanxi
  46   */
  47  public class CreateTmpTableParser implements IParser {
  48  
  49      //select table tableName as select
  50      private static final String PATTERN_STR = &quot;(?i)create\\s+view\\s+([^\\s]+)\\s+as\\s+select\\s+(.*)&quot;;
  51  
  52      private static final String EMPTY_STR = &quot;(?i)^\\screate\\s+view\\s+(\\S+)\\s*\\((.+)\\)$&quot;;
  53  
  54      private static final Pattern NONEMPTYVIEW = Pattern.compile(PATTERN_STR);
  55  
  56      private static final Pattern EMPTYVIEW = Pattern.compile(EMPTY_STR);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  57 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  58 +    private FlinkPlanner flinkPlanner = new FlinkPlanner();</span>
  59  
  60      public static CreateTmpTableParser newInstance(){
  61          return new CreateTmpTableParser();
  62      }
  63  
  64      @Override
  65      public boolean verify(String sql) {
  66          if (Pattern.compile(EMPTY_STR).matcher(sql).find()){
  67              return true;
  68          }
  69          return NONEMPTYVIEW.matcher(sql).find();
  70      }
  71  
  72      @Override
  73      public void parseSql(String sql, SqlTree sqlTree) {
  74          if (NONEMPTYVIEW.matcher(sql).find()){
  75              Matcher matcher = NONEMPTYVIEW.matcher(sql);
  76              String tableName = null;
  77              String selectSql = null;
  78              if(matcher.find()) {
  79                  tableName = matcher.group(1);
  80                  selectSql = &quot;select &quot; + matcher.group(2);
  81              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  82 -            FlinkPlannerImpl flinkPlanner = FlinkPlanner.getFlinkPlanner();</span>
  83  
  84              SqlNode sqlNode = null;
  85              try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  86 -                sqlNode = flinkPlanner.parse(selectSql);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  87 +                sqlNode = flinkPlanner.getParser().parse(selectSql);</span>
  88              } catch (Exception e) {
  89                  throw new RuntimeException(&quot;&quot;, e);
  90              }
  91  
  92              CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResult();
  93              parseNode(sqlNode, sqlParseResult);
  94  
  95              sqlParseResult.setTableName(tableName);
  96              String transformSelectSql = DtStringUtil.replaceIgnoreQuota(sqlNode.toString(), &quot;`&quot;, &quot;&quot;);
  97              sqlParseResult.setExecSql(transformSelectSql);
  98              sqlTree.addTmpSql(sqlParseResult);
  99              sqlTree.addTmplTableInfo(tableName, sqlParseResult);
 100          } else {
 101              if (EMPTYVIEW.matcher(sql).find())
 102              {
 103                  Matcher matcher = EMPTYVIEW.matcher(sql);
 104                  String tableName = null;
 105                  String fieldsInfoStr = null;
 106                  if (matcher.find()){
 107                      tableName = matcher.group(1);
 108                      fieldsInfoStr = matcher.group(2);
 109                  }
 110                  CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResult();
 111                  sqlParseResult.setFieldsInfoStr(fieldsInfoStr);
 112                  sqlParseResult.setTableName(tableName);
 113                  sqlTree.addTmplTableInfo(tableName, sqlParseResult);
 114              }
 115  
 116          }
 117  
 118      }
 119  
 120      private static void parseNode(SqlNode sqlNode, CreateTmpTableParser.SqlParserResult sqlParseResult){
 121          SqlKind sqlKind = sqlNode.getKind();
 122          switch (sqlKind){
 123              case SELECT:
 124                  SqlNode sqlFrom = ((SqlSelect)sqlNode).getFrom();
 125                  if(sqlFrom.getKind() == IDENTIFIER){
 126                      sqlParseResult.addSourceTable(sqlFrom.toString());
 127                  }else{
 128                      parseNode(sqlFrom, sqlParseResult);
 129                  }
 130                  break;
 131              case JOIN:
 132                  SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 133                  SqlNode rightNode = ((SqlJoin)sqlNode).getRight();
 134  
 135                  if(leftNode.getKind() == IDENTIFIER){
 136                      sqlParseResult.addSourceTable(leftNode.toString());
 137                  }else{
 138                      parseNode(leftNode, sqlParseResult);
 139                  }
 140  
 141                  if(rightNode.getKind() == IDENTIFIER){
 142                      sqlParseResult.addSourceTable(rightNode.toString());
 143                  }else{
 144                      parseNode(rightNode, sqlParseResult);
 145                  }
 146                  break;
 147              case AS:
 148                  //不解析column,所以 as 相关的都是表
 149                  SqlNode identifierNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 150                  if(identifierNode.getKind() != IDENTIFIER){
 151                      parseNode(identifierNode, sqlParseResult);
 152                  }else {
 153                      sqlParseResult.addSourceTable(identifierNode.toString());
 154                  }
 155                  break;
 156              case UNION:
 157                  SqlNode unionLeft = ((SqlBasicCall)sqlNode).getOperands()[0];
 158                  SqlNode unionRight = ((SqlBasicCall)sqlNode).getOperands()[1];
 159                  if(unionLeft.getKind() == IDENTIFIER){
 160                      sqlParseResult.addSourceTable(unionLeft.toString());
 161                  }else{
 162                      parseNode(unionLeft, sqlParseResult);
 163                  }
 164                  if(unionRight.getKind() == IDENTIFIER){
 165                      sqlParseResult.addSourceTable(unionRight.toString());
 166                  }else{
 167                      parseNode(unionRight, sqlParseResult);
 168                  }
 169                  break;




 170              default:
 171                  //do nothing
 172                  break;
 173          }
 174      }
 175  
 176      public static class SqlParserResult {
 177          private String tableName;
 178  
 179          private String fieldsInfoStr;
 180  
 181          private String execSql;
 182  
 183          private List&lt;String&gt; sourceTableList = Lists.newArrayList();
 184  
 185          public String getTableName() {
 186              return tableName;
 187          }
 188  
 189          public void setTableName(String tableName) {
 190              this.tableName = tableName;
 191          }
 192  
 193          public String getExecSql() {
 194              return execSql;
 195          }
 196  
 197          public void setExecSql(String execSql) {
 198              this.execSql = execSql;
 199          }
 200  
 201          public String getFieldsInfoStr() {
 202              return fieldsInfoStr;
 203          }
 204  
 205          public void setFieldsInfoStr(String fieldsInfoStr) {
 206              this.fieldsInfoStr = fieldsInfoStr;
 207          }
 208  
 209          public void addSourceTable(String sourceTable){
 210              sourceTableList.add(sourceTable);
 211          }
 212  
 213          public List&lt;String&gt; getSourceTableList() {
 214              return sourceTableList;
 215          }
 216  
 217      }
 218  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.parser;
  22  
  23  import com.dtstack.flink.sql.util.DtStringUtil;
  24  import org.apache.calcite.config.Lex;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  25 -import org.apache.calcite.sql.SqlBasicCall;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  26 -import org.apache.calcite.sql.SqlJoin;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  27 -import org.apache.calcite.sql.SqlKind;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  28 -import org.apache.calcite.sql.SqlNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  29 -import org.apache.calcite.sql.SqlSelect;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  30 +import org.apache.calcite.sql.*;</span>
  31  import org.apache.calcite.sql.parser.SqlParseException;
  32  import org.apache.calcite.sql.parser.SqlParser;
  33  import com.google.common.collect.Lists;
  34  import org.apache.flink.table.calcite.FlinkPlannerImpl;
  35  
  36  import java.util.List;
  37  import java.util.regex.Matcher;
  38  import java.util.regex.Pattern;
  39  
  40  import static org.apache.calcite.sql.SqlKind.IDENTIFIER;
  41  
  42  /**
  43   * parser create tmp table sql
  44   * Date: 2018/6/26
  45   * Company: www.dtstack.com
  46   * @author yanxi
  47   */
  48  public class CreateTmpTableParser implements IParser {
  49  
  50      //select table tableName as select
  51      private static final String PATTERN_STR = &quot;(?i)create\\s+view\\s+([^\\s]+)\\s+as\\s+select\\s+(.*)&quot;;
  52  
  53      private static final String EMPTY_STR = &quot;(?i)^\\screate\\s+view\\s+(\\S+)\\s*\\((.+)\\)$&quot;;
  54  
  55      private static final Pattern NONEMPTYVIEW = Pattern.compile(PATTERN_STR);
  56  
  57      private static final Pattern EMPTYVIEW = Pattern.compile(EMPTY_STR);


  58  
  59      public static CreateTmpTableParser newInstance(){
  60          return new CreateTmpTableParser();
  61      }
  62  
  63      @Override
  64      public boolean verify(String sql) {
  65          if (Pattern.compile(EMPTY_STR).matcher(sql).find()){
  66              return true;
  67          }
  68          return NONEMPTYVIEW.matcher(sql).find();
  69      }
  70  
  71      @Override
  72      public void parseSql(String sql, SqlTree sqlTree) {
  73          if (NONEMPTYVIEW.matcher(sql).find()){
  74              Matcher matcher = NONEMPTYVIEW.matcher(sql);
  75              String tableName = null;
  76              String selectSql = null;
  77              if(matcher.find()) {
  78                  tableName = matcher.group(1);
  79                  selectSql = &quot;select &quot; + matcher.group(2);
  80              }
  81              FlinkPlannerImpl flinkPlanner = FlinkPlanner.getFlinkPlanner();
  82  
  83              SqlNode sqlNode = null;
  84              try {
  85                  sqlNode = flinkPlanner.parse(selectSql);

  86              } catch (Exception e) {
  87                  throw new RuntimeException(&quot;&quot;, e);
  88              }
  89  
  90              CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResult();
  91              parseNode(sqlNode, sqlParseResult);
  92  
  93              sqlParseResult.setTableName(tableName);
  94              String transformSelectSql = DtStringUtil.replaceIgnoreQuota(sqlNode.toString(), &quot;`&quot;, &quot;&quot;);
  95              sqlParseResult.setExecSql(transformSelectSql);
  96              sqlTree.addTmpSql(sqlParseResult);
  97              sqlTree.addTmplTableInfo(tableName, sqlParseResult);
  98          } else {
  99              if (EMPTYVIEW.matcher(sql).find())
 100              {
 101                  Matcher matcher = EMPTYVIEW.matcher(sql);
 102                  String tableName = null;
 103                  String fieldsInfoStr = null;
 104                  if (matcher.find()){
 105                      tableName = matcher.group(1);
 106                      fieldsInfoStr = matcher.group(2);
 107                  }
 108                  CreateTmpTableParser.SqlParserResult sqlParseResult = new CreateTmpTableParser.SqlParserResult();
 109                  sqlParseResult.setFieldsInfoStr(fieldsInfoStr);
 110                  sqlParseResult.setTableName(tableName);
 111                  sqlTree.addTmplTableInfo(tableName, sqlParseResult);
 112              }
 113  
 114          }
 115  
 116      }
 117  
 118      private static void parseNode(SqlNode sqlNode, CreateTmpTableParser.SqlParserResult sqlParseResult){
 119          SqlKind sqlKind = sqlNode.getKind();
 120          switch (sqlKind){
 121              case SELECT:
 122                  SqlNode sqlFrom = ((SqlSelect)sqlNode).getFrom();
 123                  if(sqlFrom.getKind() == IDENTIFIER){
 124                      sqlParseResult.addSourceTable(sqlFrom.toString());
 125                  }else{
 126                      parseNode(sqlFrom, sqlParseResult);
 127                  }
 128                  break;
 129              case JOIN:
 130                  SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 131                  SqlNode rightNode = ((SqlJoin)sqlNode).getRight();
 132  
 133                  if(leftNode.getKind() == IDENTIFIER){
 134                      sqlParseResult.addSourceTable(leftNode.toString());
 135                  }else{
 136                      parseNode(leftNode, sqlParseResult);
 137                  }
 138  
 139                  if(rightNode.getKind() == IDENTIFIER){
 140                      sqlParseResult.addSourceTable(rightNode.toString());
 141                  }else{
 142                      parseNode(rightNode, sqlParseResult);
 143                  }
 144                  break;
 145              case AS:
 146                  //不解析column,所以 as 相关的都是表
 147                  SqlNode identifierNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 148                  if(identifierNode.getKind() != IDENTIFIER){
 149                      parseNode(identifierNode, sqlParseResult);
 150                  }else {
 151                      sqlParseResult.addSourceTable(identifierNode.toString());
 152                  }
 153                  break;
 154              case UNION:
 155                  SqlNode unionLeft = ((SqlBasicCall)sqlNode).getOperands()[0];
 156                  SqlNode unionRight = ((SqlBasicCall)sqlNode).getOperands()[1];
 157                  if(unionLeft.getKind() == IDENTIFIER){
 158                      sqlParseResult.addSourceTable(unionLeft.toString());
 159                  }else{
 160                      parseNode(unionLeft, sqlParseResult);
 161                  }
 162                  if(unionRight.getKind() == IDENTIFIER){
 163                      sqlParseResult.addSourceTable(unionRight.toString());
 164                  }else{
 165                      parseNode(unionRight, sqlParseResult);
 166                  }
 167                  break;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 168 +            case MATCH_RECOGNIZE:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 169 +                SqlMatchRecognize node = (SqlMatchRecognize) sqlNode;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 170 +                sqlParseResult.addSourceTable(node.getTableRef().toString());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 171 +                break;</span>
 172              default:
 173                  //do nothing
 174                  break;
 175          }
 176      }
 177  
 178      public static class SqlParserResult {
 179          private String tableName;
 180  
 181          private String fieldsInfoStr;
 182  
 183          private String execSql;
 184  
 185          private List&lt;String&gt; sourceTableList = Lists.newArrayList();
 186  
 187          public String getTableName() {
 188              return tableName;
 189          }
 190  
 191          public void setTableName(String tableName) {
 192              this.tableName = tableName;
 193          }
 194  
 195          public String getExecSql() {
 196              return execSql;
 197          }
 198  
 199          public void setExecSql(String execSql) {
 200              this.execSql = execSql;
 201          }
 202  
 203          public String getFieldsInfoStr() {
 204              return fieldsInfoStr;
 205          }
 206  
 207          public void setFieldsInfoStr(String fieldsInfoStr) {
 208              this.fieldsInfoStr = fieldsInfoStr;
 209          }
 210  
 211          public void addSourceTable(String sourceTable){
 212              sourceTableList.add(sourceTable);
 213          }
 214  
 215          public List&lt;String&gt; getSourceTableList() {
 216              return sourceTableList;
 217          }
 218  
 219      }
 220  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            