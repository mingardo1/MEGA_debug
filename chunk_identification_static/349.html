<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>349</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    349
                    <a href="348.html">prev</a>
                    <a href="350.html">next</a>
                    <a href="349_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_56df6ec562e5de006c036fc5b7dfd89cbd445219_redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;56df6ec562e5de006c036fc5b7dfd89cbd445219:redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;56df6ec562e5de006c036fc5b7dfd89cbd445219^1:redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;56df6ec562e5de006c036fc5b7dfd89cbd445219^2:redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;6d396e5a6320f951f7b6e0f9f656b5ded67bea85:redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bj]], subset: [[bj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.side.redis;
  20 
  21 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  22 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  23 import com.dtstack.flink.sql.util.RowDataComplete;
  24 import com.google.common.collect.Lists;
  25 import com.google.common.collect.Maps;
  26 import org.apache.flink.api.java.tuple.Tuple2;
  27 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  28 import org.apache.flink.configuration.Configuration;
  29 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  30 import org.apache.flink.table.dataformat.BaseRow;
  31 import org.apache.flink.types.Row;
  32 
  33 import com.dtstack.flink.sql.enums.ECacheContentType;
  34 import com.dtstack.flink.sql.side.CacheMissVal;
  35 import com.dtstack.flink.sql.side.FieldInfo;
  36 import com.dtstack.flink.sql.side.JoinInfo;
  37 import com.dtstack.flink.sql.side.cache.CacheObj;
  38 import com.dtstack.flink.sql.side.redis.enums.RedisType;
  39 import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  40 import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  41 import io.lettuce.core.RedisClient;
  42 import io.lettuce.core.RedisFuture;
  43 import io.lettuce.core.api.StatefulRedisConnection;
  44 import io.lettuce.core.api.async.RedisHashAsyncCommands;
  45 import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  46 import io.lettuce.core.cluster.RedisClusterClient;
  47 import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  48 import org.apache.commons.collections.MapUtils;
  49 import org.apache.commons.lang.StringUtils;
  50 
  51 import java.util.Collections;
  52 import java.util.List;
  53 import java.util.Map;
  54 import java.util.function.Consumer;
  55 /**
  56  * @author yanxi
  57  */
  58 public class RedisAsyncReqRow extends BaseAsyncReqRow {
  59 
  60     private static final long serialVersionUID = -2079908694523987738L;
  61 
  62     private RedisClient redisClient;
  63 
  64     private StatefulRedisConnection&lt;String, String&gt; connection;
  65 
  66     private RedisClusterClient clusterClient;
  67 
  68     private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  69 
  70     private RedisKeyAsyncCommands&lt;String, String&gt; async;
  71 
  72     private RedisSideTableInfo redisSideTableInfo;
  73 
  74     private RedisSideReqRow redisSideReqRow;
  75 
<abbr title="  76     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  76     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList,ðŸ”µ</abbr>
  77         super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  78         redisSideReqRow = new RedisSideReqRow(super.sideInfo);
  79     }
  80 
  81     @Override
  82     public void open(Configuration parameters) throws Exception {
  83         super.open(parameters);
  84         redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  85         buildRedisClient(redisSideTableInfo);
  86     }
  87 
  88     private void buildRedisClient(RedisSideTableInfo tableInfo){
  89         String url = redisSideTableInfo.getUrl();
  90         String password = redisSideTableInfo.getPassword();
  91         if (password != null){
  92             password = password + &quot;@&quot;;
  93         } else {
  94             password = &quot;&quot;;
  95         }
  96         String database = redisSideTableInfo.getDatabase();
  97         if (database == null){
  98             database = &quot;0&quot;;
  99         }
 100         switch (RedisType.parse(tableInfo.getRedisType())){
 101             case STANDALONE:
 102                 StringBuilder redisUri = new StringBuilder();
 103                 redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 104                 redisClient = RedisClient.create(redisUri.toString());
 105                 connection = redisClient.connect();
 106                 async = connection.async();
 107                 break;
 108             case SENTINEL:
 109                 StringBuilder sentinelUri = new StringBuilder();
 110                 sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 111                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 111                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.gðŸ”µ</abbr>
 112                 redisClient = RedisClient.create(sentinelUri.toString());
 113                 connection = redisClient.connect();
 114                 async = connection.async();
 115                 break;
 116             case CLUSTER:
 117                 StringBuilder clusterUri = new StringBuilder();
 118                 clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 119                 clusterClient = RedisClusterClient.create(clusterUri.toString());
 120                 clusterConnection = clusterClient.connect();
 121                 async = clusterConnection.async();
 122             default:
 123                 break;
 124         }
 125     }
 126 
 127     @Override
 128     public Row fillData(Row input, Object sideInput) {
 129         return redisSideReqRow.fillData(input, sideInput);
 130     }
 131 
 132     @Override
<abbr title=" 133     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Row input, ResultFuture&lt;BaseRow&gt; resultFuture) throws Exception {"> 133     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Row input, ResultFuture&lt;BaseRow&gt; resulðŸ”µ</abbr>
 134         String key = buildCacheKey(inputParams);
 135         if(StringUtils.isBlank(key)){
 136             return;
 137         }
 138         RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);
 139         future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {
 140             @Override
 141             public void accept(Map&lt;String, String&gt; values) {
 142                 if (MapUtils.isNotEmpty(values)) {
 143                     try {
 144 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 145                         Row row = fillData(input.row(), values);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 146                         dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.SingleLine, row));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 147                         resultFuture.complete(Collections.singleton(new CRow(row, input.change())));</span>
 148 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 149                         Row row = fillData(input.row(), values);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 150                         dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 151                         resultFuture.complete(Collections.singleton(new CRow(row, input.change())));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 152                     } catch (Exception e) {</span>
 153 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 154                         Row row = fillData(input, values);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 155                         dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 156                         RowDataComplete.completeRow(resultFuture, row);</span>
 157 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 158                     } catch (Exception e) {
 159                         dealFillDataError(input, resultFuture, e);
 160                     }
 161                 } else {
 162                     dealMissKey(input, resultFuture);
 163                     dealCacheData(key,CacheMissVal.getMissKeyObj());
 164                 }
 165             }
 166         });
 167     }
 168 
 169     @Override
 170     public String buildCacheKey(Map&lt;String, Object&gt; refData) {
 171         StringBuilder keyBuilder = new StringBuilder(redisSideTableInfo.getTableName());
 172         List&lt;String&gt; primaryKeys = redisSideTableInfo.getPrimaryKeys();
 173         for(String primaryKey : primaryKeys){
 174             if(!refData.containsKey(primaryKey)){
 175                 return null;
 176             }
 177             keyBuilder.append(&quot;_&quot;).append(refData.get(primaryKey));
 178         }
 179         return keyBuilder.toString();
 180     }
 181 
 182     @Override
 183     public void close() throws Exception {
 184         super.close();
 185         if (connection != null){
 186             connection.close();
 187         }
 188         if (redisClient != null){
 189             redisClient.shutdown();
 190         }
 191         if (clusterConnection != null){
 192             clusterConnection.close();
 193         }
 194         if (clusterClient != null){
 195             clusterClient.shutdown();
 196         }
 197     }
 198 
 199 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.side.redis;
  20 
  21 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  22 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  23 import com.dtstack.flink.sql.util.RowDataComplete;
  24 import com.google.common.collect.Lists;
  25 import com.google.common.collect.Maps;
  26 import org.apache.flink.api.java.tuple.Tuple2;
  27 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  28 import org.apache.flink.configuration.Configuration;
  29 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  30 import org.apache.flink.table.dataformat.BaseRow;
  31 import org.apache.flink.types.Row;
  32 
  33 import com.dtstack.flink.sql.enums.ECacheContentType;
  34 import com.dtstack.flink.sql.side.CacheMissVal;
  35 import com.dtstack.flink.sql.side.FieldInfo;
  36 import com.dtstack.flink.sql.side.JoinInfo;
  37 import com.dtstack.flink.sql.side.cache.CacheObj;
  38 import com.dtstack.flink.sql.side.redis.enums.RedisType;
  39 import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  40 import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  41 import io.lettuce.core.RedisClient;
  42 import io.lettuce.core.RedisFuture;
  43 import io.lettuce.core.api.StatefulRedisConnection;
  44 import io.lettuce.core.api.async.RedisHashAsyncCommands;
  45 import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  46 import io.lettuce.core.cluster.RedisClusterClient;
  47 import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  48 import org.apache.commons.collections.MapUtils;
  49 import org.apache.commons.lang.StringUtils;
  50 
  51 import java.util.Collections;
  52 import java.util.List;
  53 import java.util.Map;
  54 import java.util.function.Consumer;
  55 /**
  56  * @author yanxi
  57  */
  58 public class RedisAsyncReqRow extends BaseAsyncReqRow {
  59 
  60     private static final long serialVersionUID = -2079908694523987738L;
  61 
  62     private RedisClient redisClient;
  63 
  64     private StatefulRedisConnection&lt;String, String&gt; connection;
  65 
  66     private RedisClusterClient clusterClient;
  67 
  68     private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  69 
  70     private RedisKeyAsyncCommands&lt;String, String&gt; async;
  71 
  72     private RedisSideTableInfo redisSideTableInfo;
  73 
  74     private RedisSideReqRow redisSideReqRow;
  75 
<abbr title="  76     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  76     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList,ðŸ”µ</abbr>
  77         super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  78         redisSideReqRow = new RedisSideReqRow(super.sideInfo);
  79     }
  80 
  81     @Override
  82     public void open(Configuration parameters) throws Exception {
  83         super.open(parameters);
  84         redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  85         buildRedisClient(redisSideTableInfo);
  86     }
  87 
  88     private void buildRedisClient(RedisSideTableInfo tableInfo){
  89         String url = redisSideTableInfo.getUrl();
  90         String password = redisSideTableInfo.getPassword();
  91         if (password != null){
  92             password = password + &quot;@&quot;;
  93         } else {
  94             password = &quot;&quot;;
  95         }
  96         String database = redisSideTableInfo.getDatabase();
  97         if (database == null){
  98             database = &quot;0&quot;;
  99         }
 100         switch (RedisType.parse(tableInfo.getRedisType())){
 101             case STANDALONE:
 102                 StringBuilder redisUri = new StringBuilder();
 103                 redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 104                 redisClient = RedisClient.create(redisUri.toString());
 105                 connection = redisClient.connect();
 106                 async = connection.async();
 107                 break;
 108             case SENTINEL:
 109                 StringBuilder sentinelUri = new StringBuilder();
 110                 sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 111                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 111                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.gðŸ”µ</abbr>
 112                 redisClient = RedisClient.create(sentinelUri.toString());
 113                 connection = redisClient.connect();
 114                 async = connection.async();
 115                 break;
 116             case CLUSTER:
 117                 StringBuilder clusterUri = new StringBuilder();
 118                 clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 119                 clusterClient = RedisClusterClient.create(clusterUri.toString());
 120                 clusterConnection = clusterClient.connect();
 121                 async = clusterConnection.async();
 122             default:
 123                 break;
 124         }
 125     }
 126 
 127     @Override
 128     public Row fillData(Row input, Object sideInput) {
 129         return redisSideReqRow.fillData(input, sideInput);
 130     }
 131 
 132     @Override
<abbr title=" 133     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Row input, ResultFuture&lt;BaseRow&gt; resultFuture) throws Exception {"> 133     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Row input, ResultFuture&lt;BaseRow&gt; resulðŸ”µ</abbr>
 134         String key = buildCacheKey(inputParams);
 135         if(StringUtils.isBlank(key)){
 136             return;
 137         }
 138         RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);
 139         future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {
 140             @Override
 141             public void accept(Map&lt;String, String&gt; values) {
 142                 if (MapUtils.isNotEmpty(values)) {
 143                     try {
 144 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 145                         Row row = fillData(input.row(), values);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 146                         dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.SingleLine, row));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 147                         resultFuture.complete(Collections.singleton(new CRow(row, input.change())));</span>
 148 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 149                         Row row = fillData(input.row(), values);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 150                         dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 151                         resultFuture.complete(Collections.singleton(new CRow(row, input.change())));</span>
 152 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 153                         Row row = fillData(input, values);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 154                         dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 155                         RowDataComplete.completeRow(resultFuture, row);</span>
 156 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 157                     } catch (Exception e) {
 158                         dealFillDataError(input, resultFuture, e);
 159                     }
 160                 } else {
 161                     dealMissKey(input, resultFuture);
 162                     dealCacheData(key,CacheMissVal.getMissKeyObj());
 163                 }
 164             }
 165         });
 166     }
 167 
 168     @Override
 169     public String buildCacheKey(Map&lt;String, Object&gt; refData) {
 170         StringBuilder keyBuilder = new StringBuilder(redisSideTableInfo.getTableName());
 171         List&lt;String&gt; primaryKeys = redisSideTableInfo.getPrimaryKeys();
 172         for(String primaryKey : primaryKeys){
 173             if(!refData.containsKey(primaryKey)){
 174                 return null;
 175             }
 176             keyBuilder.append(&quot;_&quot;).append(refData.get(primaryKey));
 177         }
 178         return keyBuilder.toString();
 179     }
 180 
 181     @Override
 182     public void close() throws Exception {
 183         super.close();
 184         if (connection != null){
 185             connection.close();
 186         }
 187         if (redisClient != null){
 188             redisClient.shutdown();
 189         }
 190         if (clusterConnection != null){
 191             clusterConnection.close();
 192         }
 193         if (clusterClient != null){
 194             clusterClient.shutdown();
 195         }
 196     }
 197 
 198 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side.redis;
  19 
  20 import com.dtstack.flink.sql.enums.ECacheContentType;
  21 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  22 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  23 import com.dtstack.flink.sql.side.CacheMissVal;
  24 import com.dtstack.flink.sql.side.FieldInfo;
  25 import com.dtstack.flink.sql.side.JoinInfo;
  26 import com.dtstack.flink.sql.side.cache.CacheObj;
  27 import com.dtstack.flink.sql.side.redis.enums.RedisType;
  28 import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  29 import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  30 import com.dtstack.flink.sql.util.RowDataComplete;
  31 import com.google.common.collect.Lists;
  32 import com.google.common.collect.Maps;
  33 import io.lettuce.core.RedisClient;
  34 import io.lettuce.core.RedisFuture;
  35 import io.lettuce.core.api.StatefulRedisConnection;
  36 import io.lettuce.core.api.async.RedisHashAsyncCommands;
  37 import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  38 import io.lettuce.core.cluster.RedisClusterClient;
  39 import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  40 import java.util.Collections;
  41 import java.util.List;
  42 import java.util.Map;
  43 import java.util.function.Consumer;
  44 import org.apache.commons.collections.MapUtils;
  45 import org.apache.commons.lang.StringUtils;
  46 import org.apache.flink.api.java.tuple.Tuple2;
  47 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  48 import org.apache.flink.configuration.Configuration;
  49 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  50 import org.apache.flink.table.dataformat.BaseRow;
  51 import org.apache.flink.types.Row;
  52 
  53 
  54 /**
  55  * @author yanxi
  56  */
  57 public class RedisAsyncReqRow extends BaseAsyncReqRow {
  58     private static final long serialVersionUID = -2079908694523987738L;
  59 
  60     private RedisClient redisClient;
  61 
  62     private StatefulRedisConnection&lt;String, String&gt; connection;
  63 
  64     private RedisClusterClient clusterClient;
  65 
  66     private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  67 
  68     private RedisKeyAsyncCommands&lt;String, String&gt; async;
  69 
  70     private RedisSideTableInfo redisSideTableInfo;
  71 
  72     private RedisSideReqRow redisSideReqRow;
  73 
<abbr title="  74     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  74     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList,ðŸ”µ</abbr>
  75         super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  76         redisSideReqRow = new RedisSideReqRow(super.sideInfo);
  77     }
  78 
  79     @Override
  80     public void open(Configuration parameters) throws Exception {
  81         super.open(parameters);
  82         redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  83         buildRedisClient(redisSideTableInfo);
  84     }
  85 
  86     private void buildRedisClient(RedisSideTableInfo tableInfo){
  87         String url = redisSideTableInfo.getUrl();
  88         String password = redisSideTableInfo.getPassword();
  89         if (password != null){
  90             password = password + &quot;@&quot;;
  91         } else {
  92             password = &quot;&quot;;
  93         }
  94         String database = redisSideTableInfo.getDatabase();
  95         if (database == null){
  96             database = &quot;0&quot;;
  97         }
  98         switch (RedisType.parse(tableInfo.getRedisType())){
  99             case STANDALONE:
 100                 StringBuilder redisUri = new StringBuilder();
 101                 redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 102                 redisClient = RedisClient.create(redisUri.toString());
 103                 connection = redisClient.connect();
 104                 async = connection.async();
 105                 break;
 106             case SENTINEL:
 107                 StringBuilder sentinelUri = new StringBuilder();
 108                 sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 109                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 109                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.gðŸ”µ</abbr>
 110                 redisClient = RedisClient.create(sentinelUri.toString());
 111                 connection = redisClient.connect();
 112                 async = connection.async();
 113                 break;
 114             case CLUSTER:
 115                 StringBuilder clusterUri = new StringBuilder();
 116                 clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 117                 clusterClient = RedisClusterClient.create(clusterUri.toString());
 118                 clusterConnection = clusterClient.connect();
 119                 async = clusterConnection.async();
 120             default:
 121                 break;
 122         }
 123     }
 124 
 125     @Override
 126     public Row fillData(Row input, Object sideInput) {
 127         return redisSideReqRow.fillData(input, sideInput);
 128     }
 129 
 130     @Override
<abbr title=" 131     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Row input, ResultFuture&lt;BaseRow&gt; resultFuture) throws Exception {"> 131     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Row input, ResultFuture&lt;BaseRow&gt; resulðŸ”µ</abbr>
 132         String key = buildCacheKey(inputParams);
 133         if (StringUtils.isBlank(key)) {
 134             return;
 135         }
 136         RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) (async)).hgetall(key);
 137         future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {
 138             @Override
 139             public void accept(Map&lt;String, String&gt; values) {
 140                 if (MapUtils.isNotEmpty(values)) {
 141                     try {
 142                         Row row = fillData(input, values);
 143                         dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.SingleLine, row));
 144                         RowDataComplete.completeRow(resultFuture, row);
 145                     } catch (java.lang.Exception e) {
 146                         dealFillDataError(input, resultFuture, e);
 147                     }
 148                 } else {
 149                     dealMissKey(input, resultFuture);
 150                     dealCacheData(key, CacheMissVal.getMissKeyObj());
 151                 }
 152             }
 153         });
 154     }
 155 
 156     @Override
 157     public String buildCacheKey(Map&lt;String, Object&gt; refData) {
 158         StringBuilder keyBuilder = new StringBuilder(redisSideTableInfo.getTableName());
 159         List&lt;String&gt; primaryKeys = redisSideTableInfo.getPrimaryKeys();
 160         for(String primaryKey : primaryKeys){
 161             if(!refData.containsKey(primaryKey)){
 162                 return null;
 163             }
 164             keyBuilder.append(&quot;_&quot;).append(refData.get(primaryKey));
 165         }
 166         return keyBuilder.toString();
 167     }
 168 
 169     @Override
 170     public void close() throws Exception {
 171         super.close();
 172         if (connection != null){
 173             connection.close();
 174         }
 175         if (redisClient != null){
 176             redisClient.shutdown();
 177         }
 178         if (clusterConnection != null){
 179             clusterConnection.close();
 180         }
 181         if (clusterClient != null){
 182             clusterClient.shutdown();
 183         }
 184     }
 185 }
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.side.redis;
  20  
  21  import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  22  import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  23  import io.lettuce.core.KeyValue;
  24  import io.lettuce.core.api.async.RedisStringAsyncCommands;




  25  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  26  import org.apache.flink.configuration.Configuration;
  27  import org.apache.flink.streaming.api.functions.async.ResultFuture;
  28  import org.apache.flink.table.runtime.types.CRow;

  29  import org.apache.flink.types.Row;
  30  
  31  import com.dtstack.flink.sql.enums.ECacheContentType;
  32  import com.dtstack.flink.sql.side.CacheMissVal;
  33  import com.dtstack.flink.sql.side.FieldInfo;
  34  import com.dtstack.flink.sql.side.JoinInfo;
  35  import com.dtstack.flink.sql.side.cache.CacheObj;
  36  import com.dtstack.flink.sql.side.redis.enums.RedisType;
  37  import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  38  import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  39  import io.lettuce.core.RedisClient;
  40  import io.lettuce.core.RedisFuture;
  41  import io.lettuce.core.api.StatefulRedisConnection;
  42  import io.lettuce.core.api.async.RedisHashAsyncCommands;
  43  import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  44  import io.lettuce.core.cluster.RedisClusterClient;
  45  import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  46  import org.apache.commons.collections.MapUtils;
  47  import org.apache.commons.lang.StringUtils;
  48  import com.google.common.collect.Maps;
  49  
  50  import java.util.Collections;
  51  import java.util.List;
  52  import java.util.Map;
  53  import java.util.function.Consumer;
  54  /**
  55   * @author yanxi
  56   */
  57  public class RedisAsyncReqRow extends BaseAsyncReqRow {
  58  
  59      private static final long serialVersionUID = -2079908694523987738L;
  60  
  61      private RedisClient redisClient;
  62  
  63      private StatefulRedisConnection&lt;String, String&gt; connection;
  64  
  65      private RedisClusterClient clusterClient;
  66  
  67      private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  68  
  69      private RedisKeyAsyncCommands&lt;String, String&gt; async;
  70  
  71      private RedisSideTableInfo redisSideTableInfo;
  72  
  73      private RedisSideReqRow redisSideReqRow;
  74  
<abbr title="  75      public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  75      public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractðŸ”µ</abbr>
  76          super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  77          redisSideReqRow = new RedisSideReqRow(super.sideInfo);
  78      }
  79  
  80      @Override
  81      public void open(Configuration parameters) throws Exception {
  82          super.open(parameters);
  83          redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  84          buildRedisClient(redisSideTableInfo);
  85      }
  86  
  87      private void buildRedisClient(RedisSideTableInfo tableInfo){
  88          String url = redisSideTableInfo.getUrl();
  89          String password = redisSideTableInfo.getPassword();
  90          if (password != null){
  91              password = password + &quot;@&quot;;
  92          } else {
  93              password = &quot;&quot;;
  94          }
  95          String database = redisSideTableInfo.getDatabase();
  96          if (database == null){
  97              database = &quot;0&quot;;
  98          }
  99          switch (RedisType.parse(tableInfo.getRedisType())){
 100              case STANDALONE:
 101                  StringBuilder redisUri = new StringBuilder();
 102                  redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 103                  redisClient = RedisClient.create(redisUri.toString());
 104                  connection = redisClient.connect();
 105                  async = connection.async();
 106                  break;
 107              case SENTINEL:
 108                  StringBuilder sentinelUri = new StringBuilder();
 109                  sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 110                          .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 110                          .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterNðŸ”µ</abbr>
 111                  redisClient = RedisClient.create(sentinelUri.toString());
 112                  connection = redisClient.connect();
 113                  async = connection.async();
 114                  break;
 115              case CLUSTER:
 116                  StringBuilder clusterUri = new StringBuilder();
 117                  clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 118                  clusterClient = RedisClusterClient.create(clusterUri.toString());
 119                  clusterConnection = clusterClient.connect();
 120                  async = clusterConnection.async();
 121              default:
 122                  break;
 123          }
 124      }
 125  
 126      @Override
 127      public Row fillData(Row input, Object sideInput) {
 128          return redisSideReqRow.fillData(input, sideInput);
 129      }
 130  
 131      @Override
<abbr title=" 132      public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 132      public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) thðŸ”µ</abbr>

 133          String key = buildCacheKey(inputParams);
 134          if(StringUtils.isBlank(key)){
 135              return;
 136          }
 137          RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);
 138          future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {
 139              @Override
 140              public void accept(Map&lt;String, String&gt; values) {
 141                  if (MapUtils.isNotEmpty(values)) {
 142                      try {
 143                          Row row = fillData(input.row(), values);

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 144 -                        dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 145 +                        dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.SingleLine, row));</span>
 146                          resultFuture.complete(Collections.singleton(new CRow(row, input.change())));

 147                      } catch (Exception e) {
 148                          dealFillDataError(input, resultFuture, e);
 149                      }
 150                  } else {
 151                      dealMissKey(input, resultFuture);
 152                      dealCacheData(key,CacheMissVal.getMissKeyObj());
 153                  }
 154              }
 155          });
 156      }
 157  
 158      @Override
 159      public String buildCacheKey(Map&lt;String, Object&gt; refData) {
 160          StringBuilder keyBuilder = new StringBuilder(redisSideTableInfo.getTableName());
 161          List&lt;String&gt; primaryKeys = redisSideTableInfo.getPrimaryKeys();
 162          for(String primaryKey : primaryKeys){
 163              if(!refData.containsKey(primaryKey)){
 164                  return null;
 165              }
 166              keyBuilder.append(&quot;_&quot;).append(refData.get(primaryKey));
 167          }
 168          return keyBuilder.toString();
 169      }
 170  
 171      @Override
 172      public void close() throws Exception {
 173          super.close();
 174          if (connection != null){
 175              connection.close();
 176          }
 177          if (redisClient != null){
 178              redisClient.shutdown();
 179          }
 180          if (clusterConnection != null){
 181              clusterConnection.close();
 182          }
 183          if (clusterClient != null){
 184              clusterClient.shutdown();
 185          }
 186      }
 187  
 188  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.side.redis;
  20  
  21  import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  22  import com.dtstack.flink.sql.side.BaseAsyncReqRow;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  23 -import io.lettuce.core.KeyValue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  24 -import io.lettuce.core.api.async.RedisStringAsyncCommands;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  25 +import com.dtstack.flink.sql.util.RowDataComplete;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  26 +import com.google.common.collect.Lists;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  27 +import com.google.common.collect.Maps;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  28 +import org.apache.flink.api.java.tuple.Tuple2;</span>
  29  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  30  import org.apache.flink.configuration.Configuration;
  31  import org.apache.flink.streaming.api.functions.async.ResultFuture;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  32 -import org.apache.flink.table.runtime.types.CRow;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  33 +import org.apache.flink.table.dataformat.BaseRow;</span>
  34  import org.apache.flink.types.Row;
  35  
  36  import com.dtstack.flink.sql.enums.ECacheContentType;
  37  import com.dtstack.flink.sql.side.CacheMissVal;
  38  import com.dtstack.flink.sql.side.FieldInfo;
  39  import com.dtstack.flink.sql.side.JoinInfo;
  40  import com.dtstack.flink.sql.side.cache.CacheObj;
  41  import com.dtstack.flink.sql.side.redis.enums.RedisType;
  42  import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  43  import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  44  import io.lettuce.core.RedisClient;
  45  import io.lettuce.core.RedisFuture;
  46  import io.lettuce.core.api.StatefulRedisConnection;
  47  import io.lettuce.core.api.async.RedisHashAsyncCommands;
  48  import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  49  import io.lettuce.core.cluster.RedisClusterClient;
  50  import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  51  import org.apache.commons.collections.MapUtils;
  52  import org.apache.commons.lang.StringUtils;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  53 -import com.google.common.collect.Maps;</span>
  54  
  55  import java.util.Collections;
  56  import java.util.List;
  57  import java.util.Map;
  58  import java.util.function.Consumer;
  59  /**
  60   * @author yanxi
  61   */
  62  public class RedisAsyncReqRow extends BaseAsyncReqRow {
  63  
  64      private static final long serialVersionUID = -2079908694523987738L;
  65  
  66      private RedisClient redisClient;
  67  
  68      private StatefulRedisConnection&lt;String, String&gt; connection;
  69  
  70      private RedisClusterClient clusterClient;
  71  
  72      private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  73  
  74      private RedisKeyAsyncCommands&lt;String, String&gt; async;
  75  
  76      private RedisSideTableInfo redisSideTableInfo;
  77  
  78      private RedisSideReqRow redisSideReqRow;
  79  
<abbr title="  80      public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  80      public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractðŸ”µ</abbr>
  81          super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  82          redisSideReqRow = new RedisSideReqRow(super.sideInfo);
  83      }
  84  
  85      @Override
  86      public void open(Configuration parameters) throws Exception {
  87          super.open(parameters);
  88          redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  89          buildRedisClient(redisSideTableInfo);
  90      }
  91  
  92      private void buildRedisClient(RedisSideTableInfo tableInfo){
  93          String url = redisSideTableInfo.getUrl();
  94          String password = redisSideTableInfo.getPassword();
  95          if (password != null){
  96              password = password + &quot;@&quot;;
  97          } else {
  98              password = &quot;&quot;;
  99          }
 100          String database = redisSideTableInfo.getDatabase();
 101          if (database == null){
 102              database = &quot;0&quot;;
 103          }
 104          switch (RedisType.parse(tableInfo.getRedisType())){
 105              case STANDALONE:
 106                  StringBuilder redisUri = new StringBuilder();
 107                  redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 108                  redisClient = RedisClient.create(redisUri.toString());
 109                  connection = redisClient.connect();
 110                  async = connection.async();
 111                  break;
 112              case SENTINEL:
 113                  StringBuilder sentinelUri = new StringBuilder();
 114                  sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 115                          .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 115                          .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterNðŸ”µ</abbr>
 116                  redisClient = RedisClient.create(sentinelUri.toString());
 117                  connection = redisClient.connect();
 118                  async = connection.async();
 119                  break;
 120              case CLUSTER:
 121                  StringBuilder clusterUri = new StringBuilder();
 122                  clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 123                  clusterClient = RedisClusterClient.create(clusterUri.toString());
 124                  clusterConnection = clusterClient.connect();
 125                  async = clusterConnection.async();
 126              default:
 127                  break;
 128          }
 129      }
 130  
 131      @Override
 132      public Row fillData(Row input, Object sideInput) {
 133          return redisSideReqRow.fillData(input, sideInput);
 134      }
 135  
 136      @Override
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 137 -    public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 137 -    public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) thðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 138 +    public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Row input, ResultFuture&lt;BaseRow&gt; resultFuture) throws Exception {"> 138 +    public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Row input, ResultFuture&lt;BaseRow&gt; resultFuture) ðŸ”µ</abbr></span>
 139          String key = buildCacheKey(inputParams);
 140          if(StringUtils.isBlank(key)){
 141              return;
 142          }
 143          RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);
 144          future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {
 145              @Override
 146              public void accept(Map&lt;String, String&gt; values) {
 147                  if (MapUtils.isNotEmpty(values)) {
 148                      try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 149 -                        Row row = fillData(input.row(), values);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 150 +                        Row row = fillData(input, values);</span>
 151                          dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 152 -                        resultFuture.complete(Collections.singleton(new CRow(row, input.change())));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 153 +                        RowDataComplete.completeRow(resultFuture, row);</span>
 154                      } catch (Exception e) {
 155                          dealFillDataError(input, resultFuture, e);
 156                      }
 157                  } else {
 158                      dealMissKey(input, resultFuture);
 159                      dealCacheData(key,CacheMissVal.getMissKeyObj());
 160                  }
 161              }
 162          });
 163      }
 164  
 165      @Override
 166      public String buildCacheKey(Map&lt;String, Object&gt; refData) {
 167          StringBuilder keyBuilder = new StringBuilder(redisSideTableInfo.getTableName());
 168          List&lt;String&gt; primaryKeys = redisSideTableInfo.getPrimaryKeys();
 169          for(String primaryKey : primaryKeys){
 170              if(!refData.containsKey(primaryKey)){
 171                  return null;
 172              }
 173              keyBuilder.append(&quot;_&quot;).append(refData.get(primaryKey));
 174          }
 175          return keyBuilder.toString();
 176      }
 177  
 178      @Override
 179      public void close() throws Exception {
 180          super.close();
 181          if (connection != null){
 182              connection.close();
 183          }
 184          if (redisClient != null){
 185              redisClient.shutdown();
 186          }
 187          if (clusterConnection != null){
 188              clusterConnection.close();
 189          }
 190          if (clusterClient != null){
 191              clusterClient.shutdown();
 192          }
 193      }
 194  
 195  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            