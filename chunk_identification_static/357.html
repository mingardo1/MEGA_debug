<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>357</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    357
                    <a href="356.html">prev</a>
                    <a href="358.html">next</a>
                    <a href="357_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_7118d9dd17f51d998440f257935d6670c927383f_src/com/android/launcher3/LauncherProvider.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;7118d9dd17f51d998440f257935d6670c927383f:src/com/android/launcher3/LauncherProvider.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;7118d9dd17f51d998440f257935d6670c927383f^1:src/com/android/launcher3/LauncherProvider.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;7118d9dd17f51d998440f257935d6670c927383f^2:src/com/android/launcher3/LauncherProvider.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;58dcef7b28ec0bbc8e097b2cd45a6c6542a4cdef:src/com/android/launcher3/LauncherProvider.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b]], subset: [[b], [b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher3;
  18 
  19 import android.app.SearchManager;
  20 import android.appwidget.AppWidgetHost;
  21 import android.appwidget.AppWidgetManager;
  22 import android.appwidget.AppWidgetProviderInfo;
  23 import android.content.ComponentName;
  24 import android.content.ContentProvider;
  25 import android.content.ContentProviderOperation;
  26 import android.content.ContentProviderResult;
  27 import android.content.ContentResolver;
  28 import android.content.ContentUris;
  29 import android.content.ContentValues;
  30 import android.content.Context;
  31 import android.content.Intent;
  32 import android.content.OperationApplicationException;
  33 import android.content.SharedPreferences;
  34 import android.content.pm.ActivityInfo;
  35 import android.content.pm.ApplicationInfo;
  36 import android.content.pm.PackageManager;
  37 import android.content.pm.ResolveInfo;
  38 import android.content.res.Resources;
  39 import android.content.res.XmlResourceParser;
  40 import android.database.Cursor;
  41 import android.database.SQLException;
  42 import android.database.sqlite.SQLiteDatabase;
  43 import android.database.sqlite.SQLiteOpenHelper;
  44 import android.database.sqlite.SQLiteQueryBuilder;
  45 import android.database.sqlite.SQLiteStatement;
  46 import android.graphics.Bitmap;
  47 import android.graphics.BitmapFactory;
  48 import android.net.Uri;
  49 import android.os.Bundle;
  50 import android.provider.Settings;
  51 import android.text.TextUtils;
  52 import android.util.Log;
  53 import android.util.SparseArray;
  54 
  55 import com.android.launcher3.AutoInstallsLayout.LayoutParserCallback;
  56 import com.android.launcher3.LauncherSettings.Favorites;
  57 import com.android.launcher3.compat.UserHandleCompat;
  58 import com.android.launcher3.compat.UserManagerCompat;
  59 import com.android.launcher3.config.ProviderConfig;
  60 
  61 import org.xmlpull.v1.XmlPullParser;
  62 import org.xmlpull.v1.XmlPullParserException;
  63 
  64 import java.io.File;
  65 import java.io.IOException;
  66 import java.net.URISyntaxException;
  67 import java.util.ArrayList;
  68 import java.util.Collections;
  69 import java.util.HashSet;
  70 import java.util.List;
  71 
  72 public class LauncherProvider extends ContentProvider {
  73     private static final String TAG = &quot;Launcher.LauncherProvider&quot;;
  74     private static final boolean LOGD = false;
  75 
  76     private static final String DATABASE_NAME = &quot;launcher.db&quot;;
  77 
  78 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  79     private static final int DATABASE_VERSION = 20;</span>
  80 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  81     private static final int DATABASE_VERSION = 17;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  82 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  83     static final String OLD_AUTHORITY = &quot;com.android.launcher2.settings&quot;;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  84     static final String AUTHORITY = ProviderConfig.AUTHORITY;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  85 </span>
  86 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  87     private static final int DATABASE_VERSION = 16;</span>
  88 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  89 
  90     static final String OLD_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
  91     static final String AUTHORITY = ProviderConfig.AUTHORITY;
  92 
  93     // Should we attempt to load anything from the com.android.launcher2 provider?
  94     static final boolean IMPORT_LAUNCHER2_DATABASE = false;
  95 
  96     static final String TABLE_FAVORITES = &quot;favorites&quot;;
  97     static final String TABLE_WORKSPACE_SCREENS = &quot;workspaceScreens&quot;;
  98     static final String PARAMETER_NOTIFY = &quot;notify&quot;;
  99     static final String UPGRADED_FROM_OLD_DATABASE =
 100             &quot;UPGRADED_FROM_OLD_DATABASE&quot;;
 101     static final String EMPTY_DATABASE_CREATED =
 102             &quot;EMPTY_DATABASE_CREATED&quot;;
 103 
 104     private static final String ACTION_APPWIDGET_DEFAULT_WORKSPACE_CONFIGURE =
 105             &quot;com.android.launcher.action.APPWIDGET_DEFAULT_WORKSPACE_CONFIGURE&quot;;
 106 
 107     private static final String URI_PARAM_IS_EXTERNAL_ADD = &quot;isExternalAdd&quot;;
 108 
 109     private LauncherProviderChangeListener mListener;
 110 
 111     /**
 112      * {@link Uri} triggered at any registered {@link android.database.ContentObserver} when
 113      * {@link AppWidgetHost#deleteHost()} is called during database creation.
 114      * Use this to recall {@link AppWidgetHost#startListening()} if needed.
 115      */
 116     static final Uri CONTENT_APPWIDGET_RESET_URI =
 117             Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/appWidgetReset&quot;);
 118 
 119     private DatabaseHelper mOpenHelper;
 120     private static boolean sJustLoadedFromOldDb;
 121 
 122     @Override
 123     public boolean onCreate() {
 124         final Context context = getContext();
 125         mOpenHelper = new DatabaseHelper(context);
 126         LauncherAppState.setLauncherProvider(this);
 127         return true;
 128     }
 129 
 130     public boolean wasNewDbCreated() {
 131         return mOpenHelper.wasNewDbCreated();
 132     }
 133 
 134     public void setLauncherProviderChangeListener(LauncherProviderChangeListener listener) {
 135         mListener = listener;
 136     }
 137 
 138     @Override
 139     public String getType(Uri uri) {
 140         SqlArguments args = new SqlArguments(uri, null, null);
 141         if (TextUtils.isEmpty(args.where)) {
 142             return &quot;vnd.android.cursor.dir/&quot; + args.table;
 143         } else {
 144             return &quot;vnd.android.cursor.item/&quot; + args.table;
 145         }
 146     }
 147 
 148     @Override
 149     public Cursor query(Uri uri, String[] projection, String selection,
 150             String[] selectionArgs, String sortOrder) {
 151 
 152         SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 153         SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
 154         qb.setTables(args.table);
 155 
 156         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 157         Cursor result = qb.query(db, projection, args.where, args.args, null, null, sortOrder);
 158         result.setNotificationUri(getContext().getContentResolver(), uri);
 159 
 160         return result;
 161     }
 162 
 163     private static long dbInsertAndCheck(DatabaseHelper helper,
 164             SQLiteDatabase db, String table, String nullColumnHack, ContentValues values) {
 165         if (values == null) {
 166             throw new RuntimeException(&quot;Error: attempting to insert null values&quot;);
 167         }
 168         if (!values.containsKey(LauncherSettings.ChangeLogColumns._ID)) {
 169             throw new RuntimeException(&quot;Error: attempting to add item without specifying an id&quot;);
 170         }
 171         helper.checkId(table, values);
 172         return db.insert(table, nullColumnHack, values);
 173     }
 174 
 175     private static void deleteId(SQLiteDatabase db, long id) {
 176         Uri uri = LauncherSettings.Favorites.getContentUri(id, false);
 177         SqlArguments args = new SqlArguments(uri, null, null);
 178         db.delete(args.table, args.where, args.args);
 179     }
 180 
 181     @Override
 182     public Uri insert(Uri uri, ContentValues initialValues) {
 183         SqlArguments args = new SqlArguments(uri);
 184 
 185         // In very limited cases, we support system|signature permission apps to add to the db
 186         String externalAdd = uri.getQueryParameter(URI_PARAM_IS_EXTERNAL_ADD);
 187         if (externalAdd != null &amp;&amp; &quot;true&quot;.equals(externalAdd)) {
 188             if (!mOpenHelper.initializeExternalAdd(initialValues)) {
 189                 return null;
 190             }
 191         }
 192 
 193         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 194         addModifiedTime(initialValues);
 195         final long rowId = dbInsertAndCheck(mOpenHelper, db, args.table, null, initialValues);
 196         if (rowId &lt;= 0) return null;
 197 
 198         uri = ContentUris.withAppendedId(uri, rowId);
 199         sendNotify(uri);
 200 
 201         return uri;
 202     }
 203 
 204 
 205     @Override
 206     public int bulkInsert(Uri uri, ContentValues[] values) {
 207         SqlArguments args = new SqlArguments(uri);
 208 
 209         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 210         db.beginTransaction();
 211         try {
 212             int numValues = values.length;
 213             for (int i = 0; i &lt; numValues; i++) {
 214                 addModifiedTime(values[i]);
 215                 if (dbInsertAndCheck(mOpenHelper, db, args.table, null, values[i]) &lt; 0) {
 216                     return 0;
 217                 }
 218             }
 219             db.setTransactionSuccessful();
 220         } finally {
 221             db.endTransaction();
 222         }
 223 
 224         sendNotify(uri);
 225         return values.length;
 226     }
 227 
 228     @Override
 229     public ContentProviderResult[] applyBatch(ArrayList&lt;ContentProviderOperation&gt; operations)
 230             throws OperationApplicationException {
 231         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 232         db.beginTransaction();
 233         try {
 234             ContentProviderResult[] result =  super.applyBatch(operations);
 235             db.setTransactionSuccessful();
 236             return result;
 237         } finally {
 238             db.endTransaction();
 239         }
 240     }
 241 
 242     @Override
 243     public int delete(Uri uri, String selection, String[] selectionArgs) {
 244         SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 245 
 246         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 247         int count = db.delete(args.table, args.where, args.args);
 248         if (count &gt; 0) sendNotify(uri);
 249 
 250         return count;
 251     }
 252 
 253     @Override
 254     public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
 255         SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 256 
 257         addModifiedTime(values);
 258         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 259         int count = db.update(args.table, values, args.where, args.args);
 260         if (count &gt; 0) sendNotify(uri);
 261 
 262         return count;
 263     }
 264 
 265     private void sendNotify(Uri uri) {
 266         String notify = uri.getQueryParameter(PARAMETER_NOTIFY);
 267         if (notify == null || &quot;true&quot;.equals(notify)) {
 268             getContext().getContentResolver().notifyChange(uri, null);
 269         }
 270 
 271         // always notify the backup agent
 272         LauncherBackupAgentHelper.dataChanged(getContext());
 273         if (mListener != null) {
 274             mListener.onLauncherProviderChange();
 275         }
 276     }
 277 
 278     private void addModifiedTime(ContentValues values) {
 279         values.put(LauncherSettings.ChangeLogColumns.MODIFIED, System.currentTimeMillis());
 280     }
 281 
 282     public long generateNewItemId() {
 283         return mOpenHelper.generateNewItemId();
 284     }
 285 
 286     public void updateMaxItemId(long id) {
 287         mOpenHelper.updateMaxItemId(id);
 288     }
 289 
 290     public long generateNewScreenId() {
 291         return mOpenHelper.generateNewScreenId();
 292     }
 293 
 294     // This is only required one time while loading the workspace during the
 295     // upgrade path, and should never be called from anywhere else.
 296     public void updateMaxScreenId(long maxScreenId) {
 297         mOpenHelper.updateMaxScreenId(maxScreenId);
 298     }
 299 
 300     /**
 301      * @param Should we load the old db for upgrade? first run only.
 302      */
 303     synchronized public boolean justLoadedOldDb() {
 304         String spKey = LauncherAppState.getSharedPreferencesKey();
 305         SharedPreferences sp = getContext().getSharedPreferences(spKey, Context.MODE_PRIVATE);
 306 
 307         boolean loadedOldDb = false || sJustLoadedFromOldDb;
 308 
 309         sJustLoadedFromOldDb = false;
 310         if (sp.getBoolean(UPGRADED_FROM_OLD_DATABASE, false)) {
 311 
 312             SharedPreferences.Editor editor = sp.edit();
 313             editor.remove(UPGRADED_FROM_OLD_DATABASE);
 314             editor.commit();
 315             loadedOldDb = true;
 316         }
 317         return loadedOldDb;
 318     }
 319 
 320     /**
 321      * Clears all the data for a fresh start.
 322      */
 323     synchronized public void createEmptyDB() {
 324         mOpenHelper.createEmptyDB(mOpenHelper.getWritableDatabase());
 325     }
 326 
 327     /**
 328      * Loads the default workspace based on the following priority scheme:
 329      *   1) From a package provided by play store
 330      *   2) From a partner configuration APK, already in the system image
 331      *   3) The default configuration for the particular device
 332      */
 333     synchronized public void loadDefaultFavoritesIfNecessary() {
 334         String spKey = LauncherAppState.getSharedPreferencesKey();
 335         SharedPreferences sp = getContext().getSharedPreferences(spKey, Context.MODE_PRIVATE);
 336 
 337         if (sp.getBoolean(EMPTY_DATABASE_CREATED, false)) {
 338             Log.d(TAG, &quot;loading default workspace&quot;);
 339 
 340             WorkspaceLoader loader = AutoInstallsLayout.get(getContext(),
 341                     mOpenHelper.mAppWidgetHost, mOpenHelper);
 342 
 343             if (loader == null) {
 344                 final Partner partner = Partner.get(getContext().getPackageManager());
 345                 if (partner != null &amp;&amp; partner.hasDefaultLayout()) {
 346                     final Resources partnerRes = partner.getResources();
 347                     int workspaceResId = partnerRes.getIdentifier(Partner.RES_DEFAULT_LAYOUT,
 348                             &quot;xml&quot;, partner.getPackageName());
 349                     if (workspaceResId != 0) {
 350                         loader = new SimpleWorkspaceLoader(mOpenHelper, partnerRes, workspaceResId);
 351                     }
 352                 }
 353             }
 354 
 355             if (loader == null) {
 356                 loader = new SimpleWorkspaceLoader(mOpenHelper, getContext().getResources(),
 357                         getDefaultWorkspaceResourceId());
 358             }
 359 
 360             // Populate favorites table with initial favorites
 361             SharedPreferences.Editor editor = sp.edit().remove(EMPTY_DATABASE_CREATED);
 362             mOpenHelper.loadFavorites(mOpenHelper.getWritableDatabase(), loader);
 363             editor.commit();
 364         }
 365     }
 366 
 367     public void migrateLauncher2Shortcuts() {
 368         mOpenHelper.migrateLauncher2Shortcuts(mOpenHelper.getWritableDatabase(),
 369                 Uri.parse(getContext().getString(R.string.old_launcher_provider_uri)));
 370     }
 371 
 372     private static int getDefaultWorkspaceResourceId() {
 373         LauncherAppState app = LauncherAppState.getInstance();
 374         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 375         if (LauncherAppState.isDisableAllApps()) {
 376             return grid.defaultNoAllAppsLayoutId;
 377         } else {
 378             return grid.defaultLayoutId;
 379         }
 380     }
 381 
 382     private static interface ContentValuesCallback {
 383         public void onRow(ContentValues values);
 384     }
 385 
 386     private static boolean shouldImportLauncher2Database(Context context) {
 387         boolean isTablet = context.getResources().getBoolean(R.bool.is_tablet);
 388 
 389         // We don&#x27;t import the old databse for tablets, as the grid size has changed.
 390         return !isTablet &amp;&amp; IMPORT_LAUNCHER2_DATABASE;
 391     }
 392 
 393     public void deleteDatabase() {
 394         // Are you sure? (y/n)
 395         final SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 396         final File dbFile = new File(db.getPath());
 397         mOpenHelper.close();
 398         if (dbFile.exists()) {
 399             SQLiteDatabase.deleteDatabase(dbFile);
 400         }
 401         mOpenHelper = new DatabaseHelper(getContext());
 402     }
 403 
 404     private static class DatabaseHelper extends SQLiteOpenHelper implements LayoutParserCallback {
 405         private static final String TAG_RESOLVE = &quot;resolve&quot;;
 406         private static final String TAG_FAVORITES = &quot;favorites&quot;;
 407         private static final String TAG_FAVORITE = &quot;favorite&quot;;
 408         private static final String TAG_APPWIDGET = &quot;appwidget&quot;;
 409         private static final String TAG_SHORTCUT = &quot;shortcut&quot;;
 410         private static final String TAG_FOLDER = &quot;folder&quot;;
 411         private static final String TAG_PARTNER_FOLDER = &quot;partner-folder&quot;;
 412         private static final String TAG_EXTRA = &quot;extra&quot;;
 413         private static final String TAG_INCLUDE = &quot;include&quot;;
 414 
 415         // Style attrs -- &quot;Favorite&quot;
 416         private static final String ATTR_CLASS_NAME = &quot;className&quot;;
 417         private static final String ATTR_PACKAGE_NAME = &quot;packageName&quot;;
 418         private static final String ATTR_CONTAINER = &quot;container&quot;;
 419         private static final String ATTR_SCREEN = &quot;screen&quot;;
 420         private static final String ATTR_X = &quot;x&quot;;
 421         private static final String ATTR_Y = &quot;y&quot;;
 422         private static final String ATTR_SPAN_X = &quot;spanX&quot;;
 423         private static final String ATTR_SPAN_Y = &quot;spanY&quot;;
 424         private static final String ATTR_ICON = &quot;icon&quot;;
 425         private static final String ATTR_TITLE = &quot;title&quot;;
 426         private static final String ATTR_URI = &quot;uri&quot;;
 427 
 428         // Style attrs -- &quot;Include&quot;
 429         private static final String ATTR_WORKSPACE = &quot;workspace&quot;;
 430 
 431         // Style attrs -- &quot;Extra&quot;
 432         private static final String ATTR_KEY = &quot;key&quot;;
 433         private static final String ATTR_VALUE = &quot;value&quot;;
 434 
 435         private final Context mContext;
 436         private final PackageManager mPackageManager;
 437         private final AppWidgetHost mAppWidgetHost;
 438         private long mMaxItemId = -1;
 439         private long mMaxScreenId = -1;
 440 
 441         private boolean mNewDbCreated = false;
 442 
 443         DatabaseHelper(Context context) {
 444             super(context, DATABASE_NAME, null, DATABASE_VERSION);
 445             mContext = context;
 446             mPackageManager = context.getPackageManager();
 447             mAppWidgetHost = new AppWidgetHost(context, Launcher.APPWIDGET_HOST_ID);
 448 
 449             // In the case where neither onCreate nor onUpgrade gets called, we read the maxId from
 450             // the DB here
 451             if (mMaxItemId == -1) {
 452                 mMaxItemId = initializeMaxItemId(getWritableDatabase());
 453             }
 454             if (mMaxScreenId == -1) {
 455                 mMaxScreenId = initializeMaxScreenId(getWritableDatabase());
 456             }
 457         }
 458 
 459         public boolean wasNewDbCreated() {
 460             return mNewDbCreated;
 461         }
 462 
 463         /**
 464          * Send notification that we&#x27;ve deleted the {@link AppWidgetHost},
 465          * probably as part of the initial database creation. The receiver may
 466          * want to re-call {@link AppWidgetHost#startListening()} to ensure
 467          * callbacks are correctly set.
 468          */
 469         private void sendAppWidgetResetNotify() {
 470             final ContentResolver resolver = mContext.getContentResolver();
 471             resolver.notifyChange(CONTENT_APPWIDGET_RESET_URI, null);
 472         }
 473 
 474         @Override
 475         public void onCreate(SQLiteDatabase db) {
 476             if (LOGD) Log.d(TAG, &quot;creating new launcher database&quot;);
 477 
 478             mMaxItemId = 1;
 479             mMaxScreenId = 0;
 480             mNewDbCreated = true;
 481 
 482             UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 483             long userSerialNumber = userManager.getSerialNumberForUser(
 484                     UserHandleCompat.myUserHandle());
 485 
 486             db.execSQL(&quot;CREATE TABLE favorites (&quot; +
 487                     &quot;_id INTEGER PRIMARY KEY,&quot; +
 488                     &quot;title TEXT,&quot; +
 489                     &quot;intent TEXT,&quot; +
 490                     &quot;container INTEGER,&quot; +
 491                     &quot;screen INTEGER,&quot; +
 492                     &quot;cellX INTEGER,&quot; +
 493                     &quot;cellY INTEGER,&quot; +
 494                     &quot;spanX INTEGER,&quot; +
 495                     &quot;spanY INTEGER,&quot; +
 496                     &quot;itemType INTEGER,&quot; +
 497                     &quot;appWidgetId INTEGER NOT NULL DEFAULT -1,&quot; +
 498                     &quot;isShortcut INTEGER,&quot; +
 499                     &quot;iconType INTEGER,&quot; +
 500                     &quot;iconPackage TEXT,&quot; +
 501                     &quot;iconResource TEXT,&quot; +
 502                     &quot;icon BLOB,&quot; +
 503                     &quot;uri TEXT,&quot; +
 504                     &quot;displayMode INTEGER,&quot; +
 505                     &quot;appWidgetProvider TEXT,&quot; +
 506                     &quot;modified INTEGER NOT NULL DEFAULT 0,&quot; +
 507                     &quot;restored INTEGER NOT NULL DEFAULT 0,&quot; +
 508                     &quot;profileId INTEGER DEFAULT &quot; + userSerialNumber +
 509                     &quot;);&quot;);
 510             addWorkspacesTable(db);
 511 
 512             // Database was just created, so wipe any previous widgets
 513             if (mAppWidgetHost != null) {
 514                 mAppWidgetHost.deleteHost();
 515                 sendAppWidgetResetNotify();
 516             }
 517 
 518             if (shouldImportLauncher2Database(mContext)) {
 519                 // Try converting the old database
 520                 ContentValuesCallback permuteScreensCb = new ContentValuesCallback() {
 521                     public void onRow(ContentValues values) {
 522                         int container = values.getAsInteger(LauncherSettings.Favorites.CONTAINER);
 523                         if (container == Favorites.CONTAINER_DESKTOP) {
 524                             int screen = values.getAsInteger(LauncherSettings.Favorites.SCREEN);
 525                             screen = (int) upgradeLauncherDb_permuteScreens(screen);
 526                             values.put(LauncherSettings.Favorites.SCREEN, screen);
 527                         }
 528                     }
 529                 };
 530                 Uri uri = Uri.parse(&quot;content://&quot; + Settings.AUTHORITY +
 531                         &quot;/old_favorites?notify=true&quot;);
 532                 if (!convertDatabase(db, uri, permuteScreensCb, true)) {
 533                     // Try and upgrade from the Launcher2 db
 534                     uri = Uri.parse(mContext.getString(R.string.old_launcher_provider_uri));
 535                     if (!convertDatabase(db, uri, permuteScreensCb, false)) {
 536                         // If we fail, then set a flag to load the default workspace
 537                         setFlagEmptyDbCreated();
 538                         return;
 539                     }
 540                 }
 541                 // Right now, in non-default workspace cases, we want to run the final
 542                 // upgrade code (ie. to fix workspace screen indices -&gt; ids, etc.), so
 543                 // set that flag too.
 544                 setFlagJustLoadedOldDb();
 545             } else {
 546                 // Fresh and clean launcher DB.
 547                 mMaxItemId = initializeMaxItemId(db);
 548                 setFlagEmptyDbCreated();
 549             }
 550         }
 551 
 552         private void addWorkspacesTable(SQLiteDatabase db) {
 553             db.execSQL(&quot;CREATE TABLE &quot; + TABLE_WORKSPACE_SCREENS + &quot; (&quot; +
 554                     LauncherSettings.WorkspaceScreens._ID + &quot; INTEGER,&quot; +
 555                     LauncherSettings.WorkspaceScreens.SCREEN_RANK + &quot; INTEGER,&quot; +
 556                     LauncherSettings.ChangeLogColumns.MODIFIED + &quot; INTEGER NOT NULL DEFAULT 0&quot; +
 557                     &quot;);&quot;);
 558         }
 559 
 560         private void removeOrphanedItems(SQLiteDatabase db) {
 561             // Delete items directly on the workspace who&#x27;s screen id doesn&#x27;t exist
 562             //  &quot;DELETE FROM favorites WHERE screen NOT IN (SELECT _id FROM workspaceScreens)
 563             //   AND container = -100&quot;
 564             String removeOrphanedDesktopItems = &quot;DELETE FROM &quot; + TABLE_FAVORITES +
 565                     &quot; WHERE &quot; +
 566                     LauncherSettings.Favorites.SCREEN + &quot; NOT IN (SELECT &quot; +
 567                     LauncherSettings.WorkspaceScreens._ID + &quot; FROM &quot; + TABLE_WORKSPACE_SCREENS + &quot;)&quot; +
 568                     &quot; AND &quot; +
 569                     LauncherSettings.Favorites.CONTAINER + &quot; = &quot; +
 570                     LauncherSettings.Favorites.CONTAINER_DESKTOP;
 571             db.execSQL(removeOrphanedDesktopItems);
 572 
 573             // Delete items contained in folders which no longer exist (after above statement)
 574             //  &quot;DELETE FROM favorites  WHERE container &lt;&gt; -100 AND container &lt;&gt; -101 AND container
 575             //   NOT IN (SELECT _id FROM favorites WHERE itemType = 2)&quot;
 576             String removeOrphanedFolderItems = &quot;DELETE FROM &quot; + TABLE_FAVORITES +
 577                     &quot; WHERE &quot; +
 578                     LauncherSettings.Favorites.CONTAINER + &quot; &lt;&gt; &quot; +
 579                     LauncherSettings.Favorites.CONTAINER_DESKTOP +
 580                     &quot; AND &quot;
 581                     + LauncherSettings.Favorites.CONTAINER + &quot; &lt;&gt; &quot; +
 582                     LauncherSettings.Favorites.CONTAINER_HOTSEAT +
 583                     &quot; AND &quot;
 584                     + LauncherSettings.Favorites.CONTAINER + &quot; NOT IN (SELECT &quot; +
 585                     LauncherSettings.Favorites._ID + &quot; FROM &quot; + TABLE_FAVORITES +
 586                     &quot; WHERE &quot; + LauncherSettings.Favorites.ITEM_TYPE + &quot; = &quot; +
 587                     LauncherSettings.Favorites.ITEM_TYPE_FOLDER + &quot;)&quot;;
 588             db.execSQL(removeOrphanedFolderItems);
 589         }
 590 
 591         private void setFlagJustLoadedOldDb() {
 592             String spKey = LauncherAppState.getSharedPreferencesKey();
 593             SharedPreferences sp = mContext.getSharedPreferences(spKey, Context.MODE_PRIVATE);
 594             SharedPreferences.Editor editor = sp.edit();
 595             editor.putBoolean(UPGRADED_FROM_OLD_DATABASE, true);
 596             editor.putBoolean(EMPTY_DATABASE_CREATED, false);
 597             editor.commit();
 598         }
 599 
 600         private void setFlagEmptyDbCreated() {
 601             String spKey = LauncherAppState.getSharedPreferencesKey();
 602             SharedPreferences sp = mContext.getSharedPreferences(spKey, Context.MODE_PRIVATE);
 603             SharedPreferences.Editor editor = sp.edit();
 604             editor.putBoolean(EMPTY_DATABASE_CREATED, true);
 605             editor.putBoolean(UPGRADED_FROM_OLD_DATABASE, false);
 606             editor.commit();
 607         }
 608 
 609         // We rearrange the screens from the old launcher
 610         // 12345 -&gt; 34512
 611         private long upgradeLauncherDb_permuteScreens(long screen) {
 612             if (screen &gt;= 2) {
 613                 return screen - 2;
 614             } else {
 615                 return screen + 3;
 616             }
 617         }
 618 
 619         private boolean convertDatabase(SQLiteDatabase db, Uri uri,
 620                                         ContentValuesCallback cb, boolean deleteRows) {
 621             if (LOGD) Log.d(TAG, &quot;converting database from an older format, but not onUpgrade&quot;);
 622             boolean converted = false;
 623 
 624             final ContentResolver resolver = mContext.getContentResolver();
 625             Cursor cursor = null;
 626 
 627             try {
 628                 cursor = resolver.query(uri, null, null, null, null);
 629             } catch (Exception e) {
 630                 // Ignore
 631             }
 632 
 633             // We already have a favorites database in the old provider
 634             if (cursor != null) {
 635                 try {
 636                      if (cursor.getCount() &gt; 0) {
 637                         converted = copyFromCursor(db, cursor, cb) &gt; 0;
 638                         if (converted &amp;&amp; deleteRows) {
 639                             resolver.delete(uri, null, null);
 640                         }
 641                     }
 642                 } finally {
 643                     cursor.close();
 644                 }
 645             }
 646 
 647             if (converted) {
 648                 // Convert widgets from this import into widgets
 649                 if (LOGD) Log.d(TAG, &quot;converted and now triggering widget upgrade&quot;);
 650                 convertWidgets(db);
 651 
 652                 // Update max item id
 653                 mMaxItemId = initializeMaxItemId(db);
 654                 if (LOGD) Log.d(TAG, &quot;mMaxItemId: &quot; + mMaxItemId);
 655             }
 656 
 657             return converted;
 658         }
 659 
 660         private int copyFromCursor(SQLiteDatabase db, Cursor c, ContentValuesCallback cb) {
 661             final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
 662             final int intentIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.INTENT);
 663             final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 664             final int iconTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_TYPE);
 665             final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
<abbr title=" 666             final int iconPackageIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_PACKAGE);"> 666             final int iconPackageIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_PACKAGE)🔵</abbr>
<abbr title=" 667             final int iconResourceIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_RESOURCE);"> 667             final int iconResourceIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_RESOURC🔵</abbr>
 668             final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 669             final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 670             final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 671             final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 672             final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 673             final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
<abbr title=" 674             final int displayModeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.DISPLAY_MODE);"> 674             final int displayModeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.DISPLAY_MODE)🔵</abbr>
 675 
 676             ContentValues[] rows = new ContentValues[c.getCount()];
 677             int i = 0;
 678             while (c.moveToNext()) {
 679                 ContentValues values = new ContentValues(c.getColumnCount());
 680                 values.put(LauncherSettings.Favorites._ID, c.getLong(idIndex));
 681                 values.put(LauncherSettings.Favorites.INTENT, c.getString(intentIndex));
 682                 values.put(LauncherSettings.Favorites.TITLE, c.getString(titleIndex));
 683                 values.put(LauncherSettings.Favorites.ICON_TYPE, c.getInt(iconTypeIndex));
 684                 values.put(LauncherSettings.Favorites.ICON, c.getBlob(iconIndex));
 685                 values.put(LauncherSettings.Favorites.ICON_PACKAGE, c.getString(iconPackageIndex));
 686                 values.put(LauncherSettings.Favorites.ICON_RESOURCE, c.getString(iconResourceIndex));
 687                 values.put(LauncherSettings.Favorites.CONTAINER, c.getInt(containerIndex));
 688                 values.put(LauncherSettings.Favorites.ITEM_TYPE, c.getInt(itemTypeIndex));
 689                 values.put(LauncherSettings.Favorites.APPWIDGET_ID, -1);
 690                 values.put(LauncherSettings.Favorites.SCREEN, c.getInt(screenIndex));
 691                 values.put(LauncherSettings.Favorites.CELLX, c.getInt(cellXIndex));
 692                 values.put(LauncherSettings.Favorites.CELLY, c.getInt(cellYIndex));
 693                 values.put(LauncherSettings.Favorites.URI, c.getString(uriIndex));
 694                 values.put(LauncherSettings.Favorites.DISPLAY_MODE, c.getInt(displayModeIndex));
 695                 if (cb != null) {
 696                     cb.onRow(values);
 697                 }
 698                 rows[i++] = values;
 699             }
 700 
 701             int total = 0;
 702             if (i &gt; 0) {
 703                 db.beginTransaction();
 704                 try {
 705                     int numValues = rows.length;
 706                     for (i = 0; i &lt; numValues; i++) {
 707                         if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, rows[i]) &lt; 0) {
 708                             return 0;
 709                         } else {
 710                             total++;
 711                         }
 712                     }
 713                     db.setTransactionSuccessful();
 714                 } finally {
 715                     db.endTransaction();
 716                 }
 717             }
 718 
 719             return total;
 720         }
 721 
 722         @Override
 723         public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 724             if (LOGD) Log.d(TAG, &quot;onUpgrade triggered: &quot; + oldVersion);
 725 
 726             int version = oldVersion;
 727             if (version &lt; 3) {
 728                 // upgrade 1,2 -&gt; 3 added appWidgetId column
 729                 db.beginTransaction();
 730                 try {
 731                     // Insert new column for holding appWidgetIds
 732                     db.execSQL(&quot;ALTER TABLE favorites &quot; +
 733                         &quot;ADD COLUMN appWidgetId INTEGER NOT NULL DEFAULT -1;&quot;);
 734                     db.setTransactionSuccessful();
 735                     version = 3;
 736                 } catch (SQLException ex) {
 737                     // Old version remains, which means we wipe old data
 738                     Log.e(TAG, ex.getMessage(), ex);
 739                 } finally {
 740                     db.endTransaction();
 741                 }
 742 
 743                 // Convert existing widgets only if table upgrade was successful
 744                 if (version == 3) {
 745                     convertWidgets(db);
 746                 }
 747             }
 748 
 749             if (version &lt; 4) {
 750                 version = 4;
 751             }
 752 
 753             // Where&#x27;s version 5?
 754             // - Donut and sholes on 2.0 shipped with version 4 of launcher1.
 755             // - Passion shipped on 2.1 with version 6 of launcher3
 756             // - Sholes shipped on 2.1r1 (aka Mr. 3) with version 5 of launcher 1
 757             //   but version 5 on there was the updateContactsShortcuts change
 758             //   which was version 6 in launcher 2 (first shipped on passion 2.1r1).
 759             // The updateContactsShortcuts change is idempotent, so running it twice
 760             // is okay so we&#x27;ll do that when upgrading the devices that shipped with it.
 761             if (version &lt; 6) {
 762                 // We went from 3 to 5 screens. Move everything 1 to the right
 763                 db.beginTransaction();
 764                 try {
 765                     db.execSQL(&quot;UPDATE favorites SET screen=(screen + 1);&quot;);
 766                     db.setTransactionSuccessful();
 767                 } catch (SQLException ex) {
 768                     // Old version remains, which means we wipe old data
 769                     Log.e(TAG, ex.getMessage(), ex);
 770                 } finally {
 771                     db.endTransaction();
 772                 }
 773 
 774                // We added the fast track.
 775                 if (updateContactsShortcuts(db)) {
 776                     version = 6;
 777                 }
 778             }
 779 
 780             if (version &lt; 7) {
 781                 // Version 7 gets rid of the special search widget.
 782                 convertWidgets(db);
 783                 version = 7;
 784             }
 785 
 786             if (version &lt; 8) {
 787                 // Version 8 (froyo) has the icons all normalized.  This should
 788                 // already be the case in practice, but we now rely on it and don&#x27;t
 789                 // resample the images each time.
 790                 normalizeIcons(db);
 791                 version = 8;
 792             }
 793 
 794             if (version &lt; 9) {
 795                 // The max id is not yet set at this point (onUpgrade is triggered in the ctor
 796                 // before it gets a change to get set, so we need to read it here when we use it)
 797                 if (mMaxItemId == -1) {
 798                     mMaxItemId = initializeMaxItemId(db);
 799                 }
 800 
 801                 // Add default hotseat icons
 802                 loadFavorites(db, new SimpleWorkspaceLoader(this, mContext.getResources(),
 803                         R.xml.update_workspace));
 804                 version = 9;
 805             }
 806 
 807             // We bumped the version three time during JB, once to update the launch flags, once to
 808             // update the override for the default launch animation and once to set the mimetype
 809             // to improve startup performance
 810             if (version &lt; 12) {
 811                 // Contact shortcuts need a different set of flags to be launched now
 812                 // The updateContactsShortcuts change is idempotent, so we can keep using it like
 813                 // back in the Donut days
 814                 updateContactsShortcuts(db);
 815                 version = 12;
 816             }
 817 
 818             if (version &lt; 13) {
 819                 // With the new shrink-wrapped and re-orderable workspaces, it makes sense
 820                 // to persist workspace screens and their relative order.
 821                 mMaxScreenId = 0;
 822 
 823                 // This will never happen in the wild, but when we switch to using workspace
 824                 // screen ids, redo the import from old launcher.
 825                 sJustLoadedFromOldDb = true;
 826 
 827                 addWorkspacesTable(db);
 828                 version = 13;
 829             }
 830 
 831             if (version &lt; 14) {
 832                 db.beginTransaction();
 833                 try {
 834                     // Insert new column for holding widget provider name
 835                     db.execSQL(&quot;ALTER TABLE favorites &quot; +
 836                             &quot;ADD COLUMN appWidgetProvider TEXT;&quot;);
 837                     db.setTransactionSuccessful();
 838                     version = 14;
 839                 } catch (SQLException ex) {
 840                     // Old version remains, which means we wipe old data
 841                     Log.e(TAG, ex.getMessage(), ex);
 842                 } finally {
 843                     db.endTransaction();
 844                 }
 845             }
 846 
 847             if (version &lt; 15) {
 848                 db.beginTransaction();
 849                 try {
 850                     // Insert new column for holding update timestamp
 851                     db.execSQL(&quot;ALTER TABLE favorites &quot; +
 852                             &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;&quot;);
 853                     db.execSQL(&quot;ALTER TABLE workspaceScreens &quot; +
 854                             &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;&quot;);
 855                     db.setTransactionSuccessful();
 856                     version = 15;
 857                 } catch (SQLException ex) {
 858                     // Old version remains, which means we wipe old data
 859                     Log.e(TAG, ex.getMessage(), ex);
 860                 } finally {
 861                     db.endTransaction();
 862                 }
 863             }
 864 
 865 
 866             if (version &lt; 16) {
 867                 db.beginTransaction();
 868                 try {
 869                     // Insert new column for holding restore status
 870                     db.execSQL(&quot;ALTER TABLE favorites &quot; +
 871                             &quot;ADD COLUMN restored INTEGER NOT NULL DEFAULT 0;&quot;);
 872                     db.setTransactionSuccessful();
 873                     version = 16;
 874                 } catch (SQLException ex) {
 875                     // Old version remains, which means we wipe old data
 876                     Log.e(TAG, ex.getMessage(), ex);
 877                 } finally {
 878                     db.endTransaction();
 879                 }
 880             }
 881 
 882 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 883             if (version &lt; 17) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 884                 // We use the db version upgrade here to identify users who may not have seen</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 885                 // clings yet (because they weren&#x27;t available), but for whom the clings are now</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 886                 // available (tablet users). Because one of the possible cling flows (migration)</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 887                 // is very destructive (wipes out workspaces), we want to prevent this from showing</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 888                 // until clear data. We do so by marking that the clings have been shown.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 889                 LauncherClings.synchonouslyMarkFirstRunClingDismissed(mContext);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 890                 version = 17;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 891             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 892 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 893             if (version &lt; 18) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 894                 // No-op</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 895                 version = 18;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 896             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 897 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 898             if (version &lt; 19) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 899                 // Due to a data loss bug, some users may have items associated with screen ids</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 900                 // which no longer exist. Since this can cause other problems, and since the user</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 901                 // will never see these items anyway, we use database upgrade as an opportunity to</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 902                 // clean things up.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 903                 removeOrphanedItems(db);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 904                 version = 19;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 905             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 906 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 907             if (version &lt; 20) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 908                 // Add userId column</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 909                 if (addProfileColumn(db)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 910                     version = 20;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 911                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 912                 // else old version remains, which means we wipe old data</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 913             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 914 </span>
 915 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 916             if (version &lt; 17) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 917                 // We use the db version upgrade here to identify users who may not have seen</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 918                 // clings yet (because they weren&#x27;t available), but for whom the clings are now</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 919                 // available (tablet users). Because one of the possible cling flows (migration)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 920                 // is very destructive (wipes out workspaces), we want to prevent this from showing</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 921                 // until clear data. We do so by marking that the clings have been shown.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 922                 LauncherClings.synchonouslyMarkFirstRunClingDismissed(mContext);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 923                 version = 17;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 924             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 925 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 926             if (version != DATABASE_VERSION) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 927                 Log.w(TAG, &quot;Destroying all old data.&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 928                 db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_FAVORITES);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 929                 db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_WORKSPACE_SCREENS);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 930 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 931                 onCreate(db);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 932             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 933         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 934 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 935         private boolean updateContactsShortcuts(SQLiteDatabase db) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 936             final String selectWhere = buildOrWhereString(Favorites.ITEM_TYPE,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 937                     new int[] { Favorites.ITEM_TYPE_SHORTCUT });</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 938 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 939             Cursor c = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 940             final String actionQuickContact = &quot;com.android.contacts.action.QUICK_CONTACT&quot;;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 941             db.beginTransaction();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 942             try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 943                 // Select and iterate through each matching widget</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 944                 c = db.query(TABLE_FAVORITES,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 945                         new String[] { Favorites._ID, Favorites.INTENT },</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 946                         selectWhere, null, null, null, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 947                 if (c == null) return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 948 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 949                 if (LOGD) Log.d(TAG, &quot;found upgrade cursor count=&quot; + c.getCount());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 950 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 951                 final int idIndex = c.getColumnIndex(Favorites._ID);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 952                 final int intentIndex = c.getColumnIndex(Favorites.INTENT);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 953 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 954                 while (c.moveToNext()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 955                     long favoriteId = c.getLong(idIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 956                     final String intentUri = c.getString(intentIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 957                     if (intentUri != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 958                         try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 959                             final Intent intent = Intent.parseUri(intentUri, 0);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 960                             android.util.Log.d(&quot;Home&quot;, intent.toString());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 961                             final Uri uri = intent.getData();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 962                             if (uri != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 963                                 final String data = uri.toString();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 964                                 if ((Intent.ACTION_VIEW.equals(intent.getAction()) ||</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 965                                         actionQuickContact.equals(intent.getAction())) &amp;&amp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 966                                         (data.startsWith(&quot;content://contacts/people/&quot;) ||</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 967                                         data.startsWith(&quot;content://com.android.contacts/&quot; +</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 968                                                 &quot;contacts/lookup/&quot;))) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 969 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 970                                     final Intent newIntent = new Intent(actionQuickContact);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 971                                     // When starting from the launcher, start in a new, cleared task</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 972                                     // CLEAR_WHEN_TASK_RESET cannot reset the root of a task, so we</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 973                                     // clear the whole thing preemptively here since</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 974                                     // QuickContactActivity will finish itself when launching other</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 975                                     // detail activities.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 976                                     newIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK |</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 977                                             Intent.FLAG_ACTIVITY_CLEAR_TASK);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 978                                     newIntent.putExtra(</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 979                                             Launcher.INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION, true);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 980                                     newIntent.setData(uri);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 981                                     // Determine the type and also put that in the shortcut</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 982                                     // (that can speed up launch a bit)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 983                                     newIntent.setDataAndType(uri, newIntent.resolveType(mContext));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 984 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 985                                     final ContentValues values = new ContentValues();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 986                                     values.put(LauncherSettings.Favorites.INTENT,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 987                                             newIntent.toUri(0));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 988 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 989                                     String updateWhere = Favorites._ID + &quot;=&quot; + favoriteId;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 990                                     db.update(TABLE_FAVORITES, values, updateWhere, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 991                                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 992                             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 993                         } catch (RuntimeException ex) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 994                             Log.e(TAG, &quot;Problem upgrading shortcut&quot;, ex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 995                         } catch (URISyntaxException e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 996                             Log.e(TAG, &quot;Problem upgrading shortcut&quot;, e);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 997                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 998                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 999                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1000 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1001                 db.setTransactionSuccessful();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1002             } catch (SQLException ex) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1003                 Log.w(TAG, &quot;Problem while upgrading contacts&quot;, ex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1004                 return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1005             } finally {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1006                 db.endTransaction();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1007                 if (c != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1008                     c.close();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1009                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1010             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1011 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1012             return true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1013         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1014 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1015         private void normalizeIcons(SQLiteDatabase db) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1016             Log.d(TAG, &quot;normalizing icons&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1017 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1018             db.beginTransaction();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1019             Cursor c = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1020             SQLiteStatement update = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1021             try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1022                 boolean logged = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1023                 update = db.compileStatement(&quot;UPDATE favorites &quot;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1024                         + &quot;SET icon=? WHERE _id=?&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1025 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1026                 c = db.rawQuery(&quot;SELECT _id, icon FROM favorites WHERE iconType=&quot; +</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1027                         Favorites.ICON_TYPE_BITMAP, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1028 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1029                 final int idIndex = c.getColumnIndexOrThrow(Favorites._ID);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1030                 final int iconIndex = c.getColumnIndexOrThrow(Favorites.ICON);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1031 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1032                 while (c.moveToNext()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1033                     long id = c.getLong(idIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1034                     byte[] data = c.getBlob(iconIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1035                     try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1036                         Bitmap bitmap = Utilities.resampleIconBitmap(</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1037                                 BitmapFactory.decodeByteArray(data, 0, data.length),</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1038                                 mContext);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1039                         if (bitmap != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1040                             update.bindLong(1, id);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1041                             data = ItemInfo.flattenBitmap(bitmap);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1042                             if (data != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1043                                 update.bindBlob(2, data);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1044                                 update.execute();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1045                             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1046                             bitmap.recycle();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1047                         }</span>
1048 =======
1049 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
1050             if (version != DATABASE_VERSION) {
1051                 Log.w(TAG, &quot;Destroying all old data.&quot;);
1052                 db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_FAVORITES);
1053                 db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_WORKSPACE_SCREENS);
1054 
1055                 onCreate(db);
1056             }
1057         }
1058 
1059         @Override
1060         public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
1061             // This shouldn&#x27;t happen -- throw our hands up in the air and start over.
1062             Log.w(TAG, &quot;Database version downgrade from: &quot; + oldVersion + &quot; to &quot; + newVersion +
1063                     &quot;. Wiping databse.&quot;);
1064             createEmptyDB(db);
1065         }
1066 
1067 
1068         /**
1069          * Clears all the data for a fresh start.
1070          */
1071         public void createEmptyDB(SQLiteDatabase db) {
1072             db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_FAVORITES);
1073             db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_WORKSPACE_SCREENS);
1074             onCreate(db);
1075         }
1076 
1077         private boolean addProfileColumn(SQLiteDatabase db) {
1078             db.beginTransaction();
1079             try {
1080                 UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
1081                 // Default to the serial number of this user, for older
1082                 // shortcuts.
1083                 long userSerialNumber = userManager.getSerialNumberForUser(
1084                         UserHandleCompat.myUserHandle());
1085                 // Insert new column for holding user serial number
1086                 db.execSQL(&quot;ALTER TABLE favorites &quot; +
1087                         &quot;ADD COLUMN profileId INTEGER DEFAULT &quot;
1088                                         + userSerialNumber + &quot;;&quot;);
1089                 db.setTransactionSuccessful();
1090             } catch (SQLException ex) {
1091                 // Old version remains, which means we wipe old data
1092                 Log.e(TAG, ex.getMessage(), ex);
1093                 return false;
1094             } finally {
1095                 db.endTransaction();
1096             }
1097             return true;
1098         }
1099 
1100         private boolean updateContactsShortcuts(SQLiteDatabase db) {
1101             final String selectWhere = buildOrWhereString(Favorites.ITEM_TYPE,
1102                     new int[] { Favorites.ITEM_TYPE_SHORTCUT });
1103 
1104             Cursor c = null;
1105             final String actionQuickContact = &quot;com.android.contacts.action.QUICK_CONTACT&quot;;
1106             db.beginTransaction();
1107             try {
1108                 // Select and iterate through each matching widget
1109                 c = db.query(TABLE_FAVORITES,
1110                         new String[] { Favorites._ID, Favorites.INTENT },
1111                         selectWhere, null, null, null, null);
1112                 if (c == null) return false;
1113 
1114                 if (LOGD) Log.d(TAG, &quot;found upgrade cursor count=&quot; + c.getCount());
1115 
1116                 final int idIndex = c.getColumnIndex(Favorites._ID);
1117                 final int intentIndex = c.getColumnIndex(Favorites.INTENT);
1118 
1119                 while (c.moveToNext()) {
1120                     long favoriteId = c.getLong(idIndex);
1121                     final String intentUri = c.getString(intentIndex);
1122                     if (intentUri != null) {
1123                         try {
1124                             final Intent intent = Intent.parseUri(intentUri, 0);
1125                             android.util.Log.d(&quot;Home&quot;, intent.toString());
1126                             final Uri uri = intent.getData();
1127                             if (uri != null) {
1128                                 final String data = uri.toString();
1129                                 if ((Intent.ACTION_VIEW.equals(intent.getAction()) ||
1130                                         actionQuickContact.equals(intent.getAction())) &amp;&amp;
1131                                         (data.startsWith(&quot;content://contacts/people/&quot;) ||
1132                                         data.startsWith(&quot;content://com.android.contacts/&quot; +
1133                                                 &quot;contacts/lookup/&quot;))) {
1134 
1135                                     final Intent newIntent = new Intent(actionQuickContact);
1136                                     // When starting from the launcher, start in a new, cleared task
1137                                     // CLEAR_WHEN_TASK_RESET cannot reset the root of a task, so we
1138                                     // clear the whole thing preemptively here since
1139                                     // QuickContactActivity will finish itself when launching other
1140                                     // detail activities.
1141                                     newIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
1142                                             Intent.FLAG_ACTIVITY_CLEAR_TASK);
1143                                     newIntent.putExtra(
1144                                             Launcher.INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION, true);
1145                                     newIntent.setData(uri);
1146                                     // Determine the type and also put that in the shortcut
1147                                     // (that can speed up launch a bit)
1148                                     newIntent.setDataAndType(uri, newIntent.resolveType(mContext));
1149 
1150                                     final ContentValues values = new ContentValues();
1151                                     values.put(LauncherSettings.Favorites.INTENT,
1152                                             newIntent.toUri(0));
1153 
1154                                     String updateWhere = Favorites._ID + &quot;=&quot; + favoriteId;
1155                                     db.update(TABLE_FAVORITES, values, updateWhere, null);
1156                                 }
1157                             }
1158                         } catch (RuntimeException ex) {
1159                             Log.e(TAG, &quot;Problem upgrading shortcut&quot;, ex);
1160                         } catch (URISyntaxException e) {
1161                             Log.e(TAG, &quot;Problem upgrading shortcut&quot;, e);
1162                         }
1163                     }
1164                 }
1165 
1166                 db.setTransactionSuccessful();
1167             } catch (SQLException ex) {
1168                 Log.w(TAG, &quot;Problem while upgrading contacts&quot;, ex);
1169                 return false;
1170             } finally {
1171                 db.endTransaction();
1172                 if (c != null) {
1173                     c.close();
1174                 }
1175             }
1176 
1177             return true;
1178         }
1179 
1180         private void normalizeIcons(SQLiteDatabase db) {
1181             Log.d(TAG, &quot;normalizing icons&quot;);
1182 
1183             db.beginTransaction();
1184             Cursor c = null;
1185             SQLiteStatement update = null;
1186             try {
1187                 boolean logged = false;
1188                 update = db.compileStatement(&quot;UPDATE favorites &quot;
1189                         + &quot;SET icon=? WHERE _id=?&quot;);
1190 
1191                 c = db.rawQuery(&quot;SELECT _id, icon FROM favorites WHERE iconType=&quot; +
1192                         Favorites.ICON_TYPE_BITMAP, null);
1193 
1194                 final int idIndex = c.getColumnIndexOrThrow(Favorites._ID);
1195                 final int iconIndex = c.getColumnIndexOrThrow(Favorites.ICON);
1196 
1197                 while (c.moveToNext()) {
1198                     long id = c.getLong(idIndex);
1199                     byte[] data = c.getBlob(iconIndex);
1200                     try {
1201                         Bitmap bitmap = Utilities.resampleIconBitmap(
1202                                 BitmapFactory.decodeByteArray(data, 0, data.length),
1203                                 mContext);
1204                         if (bitmap != null) {
1205                             update.bindLong(1, id);
1206                             data = ItemInfo.flattenBitmap(bitmap);
1207                             if (data != null) {
1208                                 update.bindBlob(2, data);
1209                                 update.execute();
1210                             }
1211                             bitmap.recycle();
1212                         }
1213                     } catch (Exception e) {
1214                         if (!logged) {
1215                             Log.e(TAG, &quot;Failed normalizing icon &quot; + id, e);
1216                         } else {
1217                             Log.e(TAG, &quot;Also failed normalizing icon &quot; + id);
1218                         }
1219                         logged = true;
1220                     }
1221                 }
1222                 db.setTransactionSuccessful();
1223             } catch (SQLException ex) {
1224                 Log.w(TAG, &quot;Problem while allocating appWidgetIds for existing widgets&quot;, ex);
1225             } finally {
1226                 db.endTransaction();
1227                 if (update != null) {
1228                     update.close();
1229                 }
1230                 if (c != null) {
1231                     c.close();
1232                 }
1233             }
1234         }
1235 
1236         // Generates a new ID to use for an object in your database. This method should be only
1237         // called from the main UI thread. As an exception, we do call it when we call the
1238         // constructor from the worker thread; however, this doesn&#x27;t extend until after the
1239         // constructor is called, and we only pass a reference to LauncherProvider to LauncherApp
1240         // after that point
1241         @Override
1242         public long generateNewItemId() {
1243             if (mMaxItemId &lt; 0) {
1244                 throw new RuntimeException(&quot;Error: max item id was not initialized&quot;);
1245             }
1246             mMaxItemId += 1;
1247             return mMaxItemId;
1248         }
1249 
1250         @Override
1251         public long insertAndCheck(SQLiteDatabase db, ContentValues values) {
1252             return dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values);
1253         }
1254 
1255         public void updateMaxItemId(long id) {
1256             mMaxItemId = id + 1;
1257         }
1258 
1259         public void checkId(String table, ContentValues values) {
1260             long id = values.getAsLong(LauncherSettings.BaseLauncherColumns._ID);
1261             if (table == LauncherProvider.TABLE_WORKSPACE_SCREENS) {
1262                 mMaxScreenId = Math.max(id, mMaxScreenId);
1263             }  else {
1264                 mMaxItemId = Math.max(id, mMaxItemId);
1265             }
1266         }
1267 
1268         private long initializeMaxItemId(SQLiteDatabase db) {
1269             Cursor c = db.rawQuery(&quot;SELECT MAX(_id) FROM favorites&quot;, null);
1270 
1271             // get the result
1272             final int maxIdIndex = 0;
1273             long id = -1;
1274             if (c != null &amp;&amp; c.moveToNext()) {
1275                 id = c.getLong(maxIdIndex);
1276             }
1277             if (c != null) {
1278                 c.close();
1279             }
1280 
1281             if (id == -1) {
1282                 throw new RuntimeException(&quot;Error: could not query max item id&quot;);
1283             }
1284 
1285             return id;
1286         }
1287 
1288         // Generates a new ID to use for an workspace screen in your database. This method
1289         // should be only called from the main UI thread. As an exception, we do call it when we
1290         // call the constructor from the worker thread; however, this doesn&#x27;t extend until after the
1291         // constructor is called, and we only pass a reference to LauncherProvider to LauncherApp
1292         // after that point
1293         public long generateNewScreenId() {
1294             if (mMaxScreenId &lt; 0) {
1295                 throw new RuntimeException(&quot;Error: max screen id was not initialized&quot;);
1296             }
1297             mMaxScreenId += 1;
1298             // Log to disk
1299             Launcher.addDumpLog(TAG, &quot;11683562 - generateNewScreenId(): &quot; + mMaxScreenId, true);
1300             return mMaxScreenId;
1301         }
1302 
1303         public void updateMaxScreenId(long maxScreenId) {
1304             // Log to disk
1305             Launcher.addDumpLog(TAG, &quot;11683562 - updateMaxScreenId(): &quot; + maxScreenId, true);
1306             mMaxScreenId = maxScreenId;
1307         }
1308 
1309         private long initializeMaxScreenId(SQLiteDatabase db) {
<abbr title="1310             Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens._ID + &quot;) FROM &quot; + TABLE_WORKSPACE_SCREENS, null);">1310             Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens._ID + &quot;) FROM &quot; + TA🔵</abbr>
1311 
1312             // get the result
1313             final int maxIdIndex = 0;
1314             long id = -1;
1315             if (c != null &amp;&amp; c.moveToNext()) {
1316                 id = c.getLong(maxIdIndex);
1317             }
1318             if (c != null) {
1319                 c.close();
1320             }
1321 
1322             if (id == -1) {
1323                 throw new RuntimeException(&quot;Error: could not query max screen id&quot;);
1324             }
1325 
1326             // Log to disk
1327             Launcher.addDumpLog(TAG, &quot;11683562 - initializeMaxScreenId(): &quot; + id, true);
1328             return id;
1329         }
1330 
1331         /**
1332          * Upgrade existing clock and photo frame widgets into their new widget
1333          * equivalents.
1334          */
1335         private void convertWidgets(SQLiteDatabase db) {
1336             final AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(mContext);
1337             final int[] bindSources = new int[] {
1338                     Favorites.ITEM_TYPE_WIDGET_CLOCK,
1339                     Favorites.ITEM_TYPE_WIDGET_PHOTO_FRAME,
1340                     Favorites.ITEM_TYPE_WIDGET_SEARCH,
1341             };
1342 
1343             final String selectWhere = buildOrWhereString(Favorites.ITEM_TYPE, bindSources);
1344 
1345             Cursor c = null;
1346 
1347             db.beginTransaction();
1348             try {
1349                 // Select and iterate through each matching widget
1350                 c = db.query(TABLE_FAVORITES, new String[] { Favorites._ID, Favorites.ITEM_TYPE },
1351                         selectWhere, null, null, null, null);
1352 
1353                 if (LOGD) Log.d(TAG, &quot;found upgrade cursor count=&quot; + c.getCount());
1354 
1355                 final ContentValues values = new ContentValues();
1356                 while (c != null &amp;&amp; c.moveToNext()) {
1357                     long favoriteId = c.getLong(0);
1358                     int favoriteType = c.getInt(1);
1359 
1360                     // Allocate and update database with new appWidgetId
1361                     try {
1362                         int appWidgetId = mAppWidgetHost.allocateAppWidgetId();
1363 
1364                         if (LOGD) {
1365                             Log.d(TAG, &quot;allocated appWidgetId=&quot; + appWidgetId
1366                                     + &quot; for favoriteId=&quot; + favoriteId);
1367                         }
1368                         values.clear();
1369                         values.put(Favorites.ITEM_TYPE, Favorites.ITEM_TYPE_APPWIDGET);
1370                         values.put(Favorites.APPWIDGET_ID, appWidgetId);
1371 
1372                         // Original widgets might not have valid spans when upgrading
1373                         if (favoriteType == Favorites.ITEM_TYPE_WIDGET_SEARCH) {
1374                             values.put(LauncherSettings.Favorites.SPANX, 4);
1375                             values.put(LauncherSettings.Favorites.SPANY, 1);
1376                         } else {
1377                             values.put(LauncherSettings.Favorites.SPANX, 2);
1378                             values.put(LauncherSettings.Favorites.SPANY, 2);
1379                         }
1380 
1381                         String updateWhere = Favorites._ID + &quot;=&quot; + favoriteId;
1382                         db.update(TABLE_FAVORITES, values, updateWhere, null);
1383 
1384                         if (favoriteType == Favorites.ITEM_TYPE_WIDGET_CLOCK) {
1385                             // TODO: check return value
1386                             appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId,
1387                                     new ComponentName(&quot;com.android.alarmclock&quot;,
1388                                     &quot;com.android.alarmclock.AnalogAppWidgetProvider&quot;));
1389                         } else if (favoriteType == Favorites.ITEM_TYPE_WIDGET_PHOTO_FRAME) {
1390                             // TODO: check return value
1391                             appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId,
1392                                     new ComponentName(&quot;com.android.camera&quot;,
1393                                     &quot;com.android.camera.PhotoAppWidgetProvider&quot;));
1394                         } else if (favoriteType == Favorites.ITEM_TYPE_WIDGET_SEARCH) {
1395                             // TODO: check return value
1396                             appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId,
1397                                     getSearchWidgetProvider());
1398                         }
1399                     } catch (RuntimeException ex) {
1400                         Log.e(TAG, &quot;Problem allocating appWidgetId&quot;, ex);
1401                     }
1402                 }
1403 
1404                 db.setTransactionSuccessful();
1405             } catch (SQLException ex) {
1406                 Log.w(TAG, &quot;Problem while allocating appWidgetIds for existing widgets&quot;, ex);
1407             } finally {
1408                 db.endTransaction();
1409                 if (c != null) {
1410                     c.close();
1411                 }
1412             }
1413 
1414             // Update max item id
1415             mMaxItemId = initializeMaxItemId(db);
1416             if (LOGD) Log.d(TAG, &quot;mMaxItemId: &quot; + mMaxItemId);
1417         }
1418 
1419         private boolean initializeExternalAdd(ContentValues values) {
1420             // 1. Ensure that externally added items have a valid item id
1421             long id = generateNewItemId();
1422             values.put(LauncherSettings.Favorites._ID, id);
1423 
1424             // 2. In the case of an app widget, and if no app widget id is specified, we
1425             // attempt allocate and bind the widget.
1426             Integer itemType = values.getAsInteger(LauncherSettings.Favorites.ITEM_TYPE);
1427             if (itemType != null &amp;&amp;
1428                     itemType.intValue() == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET &amp;&amp;
1429                     !values.containsKey(LauncherSettings.Favorites.APPWIDGET_ID)) {
1430 
1431                 final AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(mContext);
1432                 ComponentName cn = ComponentName.unflattenFromString(
1433                         values.getAsString(Favorites.APPWIDGET_PROVIDER));
1434 
1435                 if (cn != null) {
1436                     try {
1437                         int appWidgetId = mAppWidgetHost.allocateAppWidgetId();
1438                         values.put(LauncherSettings.Favorites.APPWIDGET_ID, appWidgetId);
1439                         if (!appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId,cn)) {
1440                             return false;
1441                         }
1442                     } catch (RuntimeException e) {
1443                         Log.e(TAG, &quot;Failed to initialize external widget&quot;, e);
1444                         return false;
1445                     }
1446                 } else {
1447                     return false;
1448                 }
1449             }
1450 
1451             // Add screen id if not present
1452             long screenId = values.getAsLong(LauncherSettings.Favorites.SCREEN);
1453             if (!addScreenIdIfNecessary(screenId)) {
1454                 return false;
1455             }
1456             return true;
1457         }
1458 
1459         // Returns true of screen id exists, or if successfully added
1460         private boolean addScreenIdIfNecessary(long screenId) {
1461             if (!hasScreenId(screenId)) {
1462                 int rank = getMaxScreenRank() + 1;
1463 
1464                 ContentValues v = new ContentValues();
1465                 v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1466                 v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, rank);
1467                 if (dbInsertAndCheck(this, getWritableDatabase(),
1468                         TABLE_WORKSPACE_SCREENS, null, v) &lt; 0) {
1469                     return false;
1470                 }
1471             }
1472             return true;
1473         }
1474 
1475         private boolean hasScreenId(long screenId) {
1476             SQLiteDatabase db = getWritableDatabase();
1477             Cursor c = db.rawQuery(&quot;SELECT * FROM &quot; + TABLE_WORKSPACE_SCREENS + &quot; WHERE &quot;
1478                     + LauncherSettings.WorkspaceScreens._ID + &quot; = &quot; + screenId, null);
1479             if (c != null) {
1480                 int count = c.getCount();
1481                 c.close();
1482                 return count &gt; 0;
1483             } else {
1484                 return false;
1485             }
1486         }
1487 
1488         private int getMaxScreenRank() {
1489             SQLiteDatabase db = getWritableDatabase();
1490             Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens.SCREEN_RANK
1491                     + &quot;) FROM &quot; + TABLE_WORKSPACE_SCREENS, null);
1492 
1493             // get the result
1494             final int maxRankIndex = 0;
1495             int rank = -1;
1496             if (c != null &amp;&amp; c.moveToNext()) {
1497                 rank = c.getInt(maxRankIndex);
1498             }
1499             if (c != null) {
1500                 c.close();
1501             }
1502 
1503             return rank;
1504         }
1505 
1506         private static final void beginDocument(XmlPullParser parser, String firstElementName)
1507                 throws XmlPullParserException, IOException {
1508             int type;
1509             while ((type = parser.next()) != XmlPullParser.START_TAG
1510                     &amp;&amp; type != XmlPullParser.END_DOCUMENT) {
1511                 ;
1512             }
1513 
1514             if (type != XmlPullParser.START_TAG) {
1515                 throw new XmlPullParserException(&quot;No start tag found&quot;);
1516             }
1517 
1518             if (!parser.getName().equals(firstElementName)) {
1519                 throw new XmlPullParserException(&quot;Unexpected start tag: found &quot; + parser.getName() +
1520                         &quot;, expected &quot; + firstElementName);
1521             }
1522         }
1523 
1524         private static Intent buildMainIntent() {
1525             Intent intent = new Intent(Intent.ACTION_MAIN, null);
1526             intent.addCategory(Intent.CATEGORY_LAUNCHER);
1527             return intent;
1528         }
1529 
1530         private int loadFavorites(SQLiteDatabase db, WorkspaceLoader loader) {
1531             ArrayList&lt;Long&gt; screenIds = new ArrayList&lt;Long&gt;();
1532             // TODO: Use multiple loaders with fall-back and transaction.
1533             int count = loader.loadLayout(db, screenIds);
1534 
1535             // Add the screens specified by the items above
1536             Collections.sort(screenIds);
1537             int rank = 0;
1538             ContentValues values = new ContentValues();
1539             for (Long id : screenIds) {
1540                 values.clear();
1541                 values.put(LauncherSettings.WorkspaceScreens._ID, id);
1542                 values.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, rank);
1543                 if (dbInsertAndCheck(this, db, TABLE_WORKSPACE_SCREENS, null, values) &lt; 0) {
1544                     throw new RuntimeException(&quot;Failed initialize screen table&quot;
1545                             + &quot;from default layout&quot;);
1546                 }
1547                 rank++;
1548             }
1549 
1550             // Ensure that the max ids are initialized
1551             mMaxItemId = initializeMaxItemId(db);
1552             mMaxScreenId = initializeMaxScreenId(db);
1553 
1554             return count;
1555         }
1556 
1557         /**
1558          * Loads the default set of favorite packages from an xml file.
1559          *
1560          * @param db The database to write the values into
1561          * @param filterContainerId The specific container id of items to load
1562          * @param the set of screenIds which are used by the favorites
1563          */
1564         private int loadFavoritesRecursive(SQLiteDatabase db, Resources res, int workspaceResourceId,
1565                 ArrayList&lt;Long&gt; screenIds) {
1566 
1567             ContentValues values = new ContentValues();
<abbr title="1568             if (LOGD) Log.v(TAG, String.format(&quot;Loading favorites from resid=0x%08x&quot;, workspaceResourceId));">1568             if (LOGD) Log.v(TAG, String.format(&quot;Loading favorites from resid=0x%08x&quot;, workspaceResourceId🔵</abbr>
1569 
1570             int count = 0;
1571             try {
1572                 XmlResourceParser parser = res.getXml(workspaceResourceId);
1573                 beginDocument(parser, TAG_FAVORITES);
1574 
1575                 final int depth = parser.getDepth();
1576 
1577                 int type;
1578                 while (((type = parser.next()) != XmlPullParser.END_TAG ||
1579                         parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {
1580 
1581                     if (type != XmlPullParser.START_TAG) {
1582                         continue;
1583                     }
1584 
1585                     boolean added = false;
1586                     final String name = parser.getName();
1587 
1588                     if (TAG_INCLUDE.equals(name)) {
1589 
1590                         final int resId = getAttributeResourceValue(parser, ATTR_WORKSPACE, 0);
1591 
<abbr title="1592                         if (LOGD) Log.v(TAG, String.format((&quot;%&quot; + (2*(depth+1)) + &quot;s&lt;include workspace=%08x&gt;&quot;),">1592                         if (LOGD) Log.v(TAG, String.format((&quot;%&quot; + (2*(depth+1)) + &quot;s&lt;include workspace=%0🔵</abbr>
1593                                 &quot;&quot;, resId));
1594 
1595                         if (resId != 0 &amp;&amp; resId != workspaceResourceId) {
1596                             // recursively load some more favorites, why not?
1597                             count += loadFavoritesRecursive(db, res, resId, screenIds);
1598                             added = false;
1599                         } else {
1600                             Log.w(TAG, String.format(&quot;Skipping &lt;include workspace=0x%08x&gt;&quot;, resId));
1601                         }
1602 
1603                         if (LOGD) Log.v(TAG, String.format((&quot;%&quot; + (2*(depth+1)) + &quot;s&lt;/include&gt;&quot;), &quot;&quot;));
1604                         continue;
1605                     }
1606 
1607                     // Assuming it&#x27;s a &lt;favorite&gt; at this point
1608                     long container = LauncherSettings.Favorites.CONTAINER_DESKTOP;
1609                     String strContainer = getAttributeValue(parser, ATTR_CONTAINER);
1610                     if (strContainer != null) {
1611                         container = Long.valueOf(strContainer);
1612                     }
1613 
1614                     String screen = getAttributeValue(parser, ATTR_SCREEN);
1615                     String x = getAttributeValue(parser, ATTR_X);
1616                     String y = getAttributeValue(parser, ATTR_Y);
1617 
1618                     values.clear();
1619                     values.put(LauncherSettings.Favorites.CONTAINER, container);
1620                     values.put(LauncherSettings.Favorites.SCREEN, screen);
1621                     values.put(LauncherSettings.Favorites.CELLX, x);
1622                     values.put(LauncherSettings.Favorites.CELLY, y);
1623 
1624                     if (LOGD) {
1625                         final String title = getAttributeValue(parser, ATTR_TITLE);
1626                         final String pkg = getAttributeValue(parser, ATTR_PACKAGE_NAME);
1627                         final String something = title != null ? title : pkg;
1628                         Log.v(TAG, String.format(
1629                                 (&quot;%&quot; + (2*(depth+1)) + &quot;s&lt;%s%s c=%d s=%s x=%s y=%s&gt;&quot;),
1630                                 &quot;&quot;, name,
1631                                 (something == null ? &quot;&quot; : (&quot; \&quot;&quot; + something + &quot;\&quot;&quot;)),
1632                                 container, screen, x, y));
1633                     }
1634 
1635                     if (TAG_FAVORITE.equals(name)) {
1636                         long id = addAppShortcut(db, values, parser);
1637                         added = id &gt;= 0;
1638                     } else if (TAG_APPWIDGET.equals(name)) {
1639                         added = addAppWidget(parser, type, db, values);
1640                     } else if (TAG_SHORTCUT.equals(name)) {
1641                         long id = addUriShortcut(db, values, res, parser);
1642                         added = id &gt;= 0;
1643                     } else if (TAG_RESOLVE.equals(name)) {
1644                         // This looks through the contained favorites (or meta-favorites) and
1645                         // attempts to add them as shortcuts in the fallback group&#x27;s location
1646                         // until one is added successfully.
1647                         added = false;
1648                         final int groupDepth = parser.getDepth();
1649                         while ((type = parser.next()) != XmlPullParser.END_TAG ||
1650                                 parser.getDepth() &gt; groupDepth) {
1651                             if (type != XmlPullParser.START_TAG) {
1652                                 continue;
1653                             }
1654                             final String fallback_item_name = parser.getName();
1655                             if (!added) {
1656                                 if (TAG_FAVORITE.equals(fallback_item_name)) {
1657                                     final long id = addAppShortcut(db, values, parser);
1658                                     added = id &gt;= 0;
1659                                 } else {
1660                                     Log.e(TAG, &quot;Fallback groups can contain only favorites, found &quot;
1661                                             + fallback_item_name);
1662                                 }
1663                             }
1664                         }
1665                     } else if (TAG_FOLDER.equals(name)) {
1666                         // Folder contents are nested in this XML file
1667                         added = loadFolder(db, values, res, parser);
1668 
1669                     } else if (TAG_PARTNER_FOLDER.equals(name)) {
1670                         // Folder contents come from an external XML resource
1671                         final Partner partner = Partner.get(mPackageManager);
1672                         if (partner != null) {
1673                             final Resources partnerRes = partner.getResources();
1674                             final int resId = partnerRes.getIdentifier(Partner.RES_FOLDER,
1675                                     &quot;xml&quot;, partner.getPackageName());
1676                             if (resId != 0) {
1677                                 final XmlResourceParser partnerParser = partnerRes.getXml(resId);
1678                                 beginDocument(partnerParser, TAG_FOLDER);
1679                                 added = loadFolder(db, values, partnerRes, partnerParser);
1680                             }
1681                         }
1682                     }
1683                     if (added) {
1684                         long screenId = Long.parseLong(screen);
1685                         // Keep track of the set of screens which need to be added to the db.
1686                         if (!screenIds.contains(screenId) &amp;&amp;
1687                                 container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1688                             screenIds.add(screenId);
1689                         }
1690                         count++;
1691                     }
1692                 }
1693             } catch (XmlPullParserException e) {
1694                 Log.w(TAG, &quot;Got exception parsing favorites.&quot;, e);
1695             } catch (IOException e) {
1696                 Log.w(TAG, &quot;Got exception parsing favorites.&quot;, e);
1697             } catch (RuntimeException e) {
1698                 Log.w(TAG, &quot;Got exception parsing favorites.&quot;, e);
1699             }
1700             return count;
1701         }
1702 
1703         /**
1704          * Parse folder items starting at {@link XmlPullParser} location. Allow recursive
1705          * includes of items.
1706          */
1707         private void addToFolder(SQLiteDatabase db, Resources res, XmlResourceParser parser,
1708                 ArrayList&lt;Long&gt; folderItems, long folderId) throws IOException, XmlPullParserException {
1709             int type;
1710             int folderDepth = parser.getDepth();
1711             while ((type = parser.next()) != XmlPullParser.END_TAG ||
1712                     parser.getDepth() &gt; folderDepth) {
1713                 if (type != XmlPullParser.START_TAG) {
1714                     continue;
1715                 }
1716                 final String tag = parser.getName();
1717 
1718                 final ContentValues childValues = new ContentValues();
1719                 childValues.put(LauncherSettings.Favorites.CONTAINER, folderId);
1720 
1721                 if (LOGD) {
1722                     final String pkg = getAttributeValue(parser, ATTR_PACKAGE_NAME);
1723                     final String uri = getAttributeValue(parser, ATTR_URI);
1724                     Log.v(TAG, String.format((&quot;%&quot; + (2*(folderDepth+1)) + &quot;s&lt;%s \&quot;%s\&quot;&gt;&quot;), &quot;&quot;,
1725                             tag, uri != null ? uri : pkg));
1726                 }
1727 
1728                 if (TAG_FAVORITE.equals(tag) &amp;&amp; folderId &gt;= 0) {
1729                     final long id = addAppShortcut(db, childValues, parser);
1730                     if (id &gt;= 0) {
1731                         folderItems.add(id);
1732                     }
1733                 } else if (TAG_SHORTCUT.equals(tag) &amp;&amp; folderId &gt;= 0) {
1734                     final long id = addUriShortcut(db, childValues, res, parser);
1735                     if (id &gt;= 0) {
1736                         folderItems.add(id);
1737                     }
1738                 } else if (TAG_INCLUDE.equals(tag) &amp;&amp; folderId &gt;= 0) {
1739                     addToFolder(db, res, parser, folderItems, folderId);
1740                 } else {
1741                     throw new RuntimeException(&quot;Folders can contain only shortcuts&quot;);
1742                 }
1743             }
1744         }
1745 
1746         /**
1747          * Parse folder starting at current {@link XmlPullParser} location.
1748          */
1749         private boolean loadFolder(SQLiteDatabase db, ContentValues values, Resources res,
1750                 XmlResourceParser parser) throws IOException, XmlPullParserException {
1751             final String title;
1752             final int titleResId = getAttributeResourceValue(parser, ATTR_TITLE, 0);
1753             if (titleResId != 0) {
1754                 title = res.getString(titleResId);
1755             } else {
1756                 title = mContext.getResources().getString(R.string.folder_name);
1757             }
1758 
1759             values.put(LauncherSettings.Favorites.TITLE, title);
1760             long folderId = addFolder(db, values);
1761             boolean added = folderId &gt;= 0;
1762 
1763             ArrayList&lt;Long&gt; folderItems = new ArrayList&lt;Long&gt;();
1764             addToFolder(db, res, parser, folderItems, folderId);
1765 
1766             // We can only have folders with &gt;= 2 items, so we need to remove the
1767             // folder and clean up if less than 2 items were included, or some
1768             // failed to add, and less than 2 were actually added
1769             if (folderItems.size() &lt; 2 &amp;&amp; folderId &gt;= 0) {
1770                 // Delete the folder
1771                 deleteId(db, folderId);
1772 
1773                 // If we have a single item, promote it to where the folder
1774                 // would have been.
1775                 if (folderItems.size() == 1) {
1776                     final ContentValues childValues = new ContentValues();
1777                     copyInteger(values, childValues, LauncherSettings.Favorites.CONTAINER);
1778                     copyInteger(values, childValues, LauncherSettings.Favorites.SCREEN);
1779                     copyInteger(values, childValues, LauncherSettings.Favorites.CELLX);
1780                     copyInteger(values, childValues, LauncherSettings.Favorites.CELLY);
1781 
1782                     final long id = folderItems.get(0);
1783                     db.update(TABLE_FAVORITES, childValues,
1784                             LauncherSettings.Favorites._ID + &quot;=&quot; + id, null);
1785                 } else {
1786                     added = false;
1787                 }
1788             }
1789             return added;
1790         }
1791 
1792         // A meta shortcut attempts to resolve an intent specified as a URI in the XML, if a
1793         // logical choice for what shortcut should be used for that intent exists, then it is
1794         // added. Otherwise add nothing.
1795         private long addAppShortcutByUri(SQLiteDatabase db, ContentValues values,
1796                 String intentUri) {
1797             Intent metaIntent;
1798             try {
1799                 metaIntent = Intent.parseUri(intentUri, 0);
1800             } catch (URISyntaxException e) {
1801                 Log.e(TAG, &quot;Unable to add meta-favorite: &quot; + intentUri, e);
1802                 return -1;
1803             }
1804 
1805             ResolveInfo resolved = mPackageManager.resolveActivity(metaIntent,
1806                     PackageManager.MATCH_DEFAULT_ONLY);
1807             final List&lt;ResolveInfo&gt; appList = mPackageManager.queryIntentActivities(
1808                     metaIntent, PackageManager.MATCH_DEFAULT_ONLY);
1809 
1810             // Verify that the result is an app and not just the resolver dialog asking which
1811             // app to use.
1812             if (wouldLaunchResolverActivity(resolved, appList)) {
1813                 // If only one of the results is a system app then choose that as the default.
1814                 final ResolveInfo systemApp = getSingleSystemActivity(appList);
1815                 if (systemApp == null) {
1816                     // There is no logical choice for this meta-favorite, so rather than making
1817                     // a bad choice just add nothing.
1818                     Log.w(TAG, &quot;No preference or single system activity found for &quot;
1819                             + metaIntent.toString());
1820                     return -1;
1821                 }
1822                 resolved = systemApp;
1823             }
1824             final ActivityInfo info = resolved.activityInfo;
1825             final Intent intent = mPackageManager.getLaunchIntentForPackage(info.packageName);
1826             if (intent == null) {
1827                 return -1;
1828             }
1829             intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
1830                     Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
1831 
1832             return addAppShortcut(db, values, info.loadLabel(mPackageManager).toString(), intent);
1833         }
1834 
1835         private ResolveInfo getSingleSystemActivity(List&lt;ResolveInfo&gt; appList) {
1836             ResolveInfo systemResolve = null;
1837             final int N = appList.size();
1838             for (int i = 0; i &lt; N; ++i) {
1839                 try {
1840                     ApplicationInfo info = mPackageManager.getApplicationInfo(
1841                             appList.get(i).activityInfo.packageName, 0);
1842                     if ((info.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) {
1843                         if (systemResolve != null) {
1844                             return null;
1845                         } else {
1846                             systemResolve = appList.get(i);
1847                         }
1848                     }
1849                 } catch (PackageManager.NameNotFoundException e) {
1850                     Log.w(TAG, &quot;Unable to get info about resolve results&quot;, e);
1851                     return null;
1852                 }
1853             }
1854             return systemResolve;
1855         }
1856 
1857         private boolean wouldLaunchResolverActivity(ResolveInfo resolved,
1858                 List&lt;ResolveInfo&gt; appList) {
1859             // If the list contains the above resolved activity, then it can&#x27;t be
1860             // ResolverActivity itself.
1861             for (int i = 0; i &lt; appList.size(); ++i) {
1862                 ResolveInfo tmp = appList.get(i);
1863                 if (tmp.activityInfo.name.equals(resolved.activityInfo.name)
1864                         &amp;&amp; tmp.activityInfo.packageName.equals(resolved.activityInfo.packageName)) {
1865                     return false;
1866                 }
1867             }
1868             return true;
1869         }
1870 
1871         private long addAppShortcut(SQLiteDatabase db, ContentValues values,
1872                 XmlResourceParser parser) {
1873             final String packageName = getAttributeValue(parser, ATTR_PACKAGE_NAME);
1874             final String className = getAttributeValue(parser, ATTR_CLASS_NAME);
1875             final String uri = getAttributeValue(parser, ATTR_URI);
1876 
1877             if (!TextUtils.isEmpty(packageName) &amp;&amp; !TextUtils.isEmpty(className)) {
1878                 ActivityInfo info;
1879                 try {
1880                     ComponentName cn;
1881                     try {
1882                         cn = new ComponentName(packageName, className);
1883                         info = mPackageManager.getActivityInfo(cn, 0);
1884                     } catch (PackageManager.NameNotFoundException nnfe) {
1885                         String[] packages = mPackageManager.currentToCanonicalPackageNames(
1886                                 new String[] { packageName });
1887                         cn = new ComponentName(packages[0], className);
1888                         info = mPackageManager.getActivityInfo(cn, 0);
1889                     }
1890                     final Intent intent = buildMainIntent();
1891                     intent.setComponent(cn);
1892                     intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
1893                             Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
1894 
1895                     return addAppShortcut(db, values, info.loadLabel(mPackageManager).toString(),
1896                             intent);
1897                 } catch (PackageManager.NameNotFoundException e) {
1898                     Log.w(TAG, &quot;Unable to add favorite: &quot; + packageName +
1899                             &quot;/&quot; + className, e);
1900                 }
1901                 return -1;
1902             } else if (!TextUtils.isEmpty(uri)) {
1903                 // If no component specified try to find a shortcut to add from the URI.
1904                 return addAppShortcutByUri(db, values, uri);
1905             } else {
1906                 Log.e(TAG, &quot;Skipping invalid &lt;favorite&gt; with no component or uri&quot;);
1907                 return -1;
1908             }
1909         }
1910 
1911         private long addAppShortcut(SQLiteDatabase db, ContentValues values, String title,
1912                 Intent intent) {
1913             long id = generateNewItemId();
1914             values.put(Favorites.INTENT, intent.toUri(0));
1915             values.put(Favorites.TITLE, title);
1916             values.put(Favorites.ITEM_TYPE, Favorites.ITEM_TYPE_APPLICATION);
1917             values.put(Favorites.SPANX, 1);
1918             values.put(Favorites.SPANY, 1);
1919             values.put(Favorites._ID, id);
1920             if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values) &lt; 0) {
1921                 return -1;
1922             } else {
1923                 return id;
1924             }
1925         }
1926 
1927         private long addFolder(SQLiteDatabase db, ContentValues values) {
1928             values.put(Favorites.ITEM_TYPE, Favorites.ITEM_TYPE_FOLDER);
1929             values.put(Favorites.SPANX, 1);
1930             values.put(Favorites.SPANY, 1);
1931             long id = generateNewItemId();
1932             values.put(Favorites._ID, id);
1933             if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values) &lt;= 0) {
1934                 return -1;
1935             } else {
1936                 return id;
1937             }
1938         }
1939 
1940         private ComponentName getSearchWidgetProvider() {
1941             SearchManager searchManager =
1942                     (SearchManager) mContext.getSystemService(Context.SEARCH_SERVICE);
1943             ComponentName searchComponent = searchManager.getGlobalSearchActivity();
1944             if (searchComponent == null) return null;
1945             return getProviderInPackage(searchComponent.getPackageName());
1946         }
1947 
1948         /**
1949          * Gets an appwidget provider from the given package. If the package contains more than
1950          * one appwidget provider, an arbitrary one is returned.
1951          */
1952         private ComponentName getProviderInPackage(String packageName) {
1953             AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(mContext);
1954             List&lt;AppWidgetProviderInfo&gt; providers = appWidgetManager.getInstalledProviders();
1955             if (providers == null) return null;
1956             final int providerCount = providers.size();
1957             for (int i = 0; i &lt; providerCount; i++) {
1958                 ComponentName provider = providers.get(i).provider;
1959                 if (provider != null &amp;&amp; provider.getPackageName().equals(packageName)) {
1960                     return provider;
1961                 }
1962             }
1963             return null;
1964         }
1965 
1966         private boolean addAppWidget(XmlResourceParser parser, int type,
1967                 SQLiteDatabase db, ContentValues values)
1968                 throws XmlPullParserException, IOException {
1969 
1970             String packageName = getAttributeValue(parser, ATTR_PACKAGE_NAME);
1971             String className = getAttributeValue(parser, ATTR_CLASS_NAME);
1972 
1973             if (packageName == null || className == null) {
1974                 return false;
1975             }
1976 
1977             boolean hasPackage = true;
1978             ComponentName cn = new ComponentName(packageName, className);
1979             try {
1980                 mPackageManager.getReceiverInfo(cn, 0);
1981             } catch (Exception e) {
1982                 String[] packages = mPackageManager.currentToCanonicalPackageNames(
1983                         new String[] { packageName });
1984                 cn = new ComponentName(packages[0], className);
1985                 try {
1986                     mPackageManager.getReceiverInfo(cn, 0);
1987                 } catch (Exception e1) {
1988                     System.out.println(&quot;Can&#x27;t find widget provider: &quot; + className);
1989                     hasPackage = false;
1990                 }
1991             }
1992 
1993             if (hasPackage) {
1994                 String spanX = getAttributeValue(parser, ATTR_SPAN_X);
1995                 String spanY = getAttributeValue(parser, ATTR_SPAN_Y);
1996 
1997                 values.put(Favorites.SPANX, spanX);
1998                 values.put(Favorites.SPANY, spanY);
1999 
2000                 // Read the extras
2001                 Bundle extras = new Bundle();
2002                 int widgetDepth = parser.getDepth();
2003                 while ((type = parser.next()) != XmlPullParser.END_TAG ||
2004                         parser.getDepth() &gt; widgetDepth) {
2005                     if (type != XmlPullParser.START_TAG) {
2006                         continue;
2007                     }
2008 
2009                     if (TAG_EXTRA.equals(parser.getName())) {
2010                         String key = getAttributeValue(parser, ATTR_KEY);
2011                         String value = getAttributeValue(parser, ATTR_VALUE);
2012                         if (key != null &amp;&amp; value != null) {
2013                             extras.putString(key, value);
2014                         } else {
2015                             throw new RuntimeException(&quot;Widget extras must have a key and value&quot;);
2016                         }
2017                     } else {
2018                         throw new RuntimeException(&quot;Widgets can contain only extras&quot;);
2019                     }
2020                 }
2021 
2022                 return addAppWidget(db, values, cn, extras);
2023             }
2024 
2025             return false;
2026         }
2027 
2028         private boolean addAppWidget(SQLiteDatabase db, ContentValues values, ComponentName cn,
2029                Bundle extras) {
2030             boolean allocatedAppWidgets = false;
2031             final AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(mContext);
2032 
2033             try {
2034                 int appWidgetId = mAppWidgetHost.allocateAppWidgetId();
2035 
2036                 values.put(Favorites.ITEM_TYPE, Favorites.ITEM_TYPE_APPWIDGET);
2037                 values.put(Favorites.APPWIDGET_ID, appWidgetId);
2038                 values.put(Favorites.APPWIDGET_PROVIDER, cn.flattenToString());
2039                 values.put(Favorites._ID, generateNewItemId());
2040                 dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values);
2041 
2042                 allocatedAppWidgets = true;
2043 
2044                 // TODO: need to check return value
2045                 appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId, cn);
2046 
2047                 // Send a broadcast to configure the widget
2048                 if (extras != null &amp;&amp; !extras.isEmpty()) {
2049                     Intent intent = new Intent(ACTION_APPWIDGET_DEFAULT_WORKSPACE_CONFIGURE);
2050                     intent.setComponent(cn);
2051                     intent.putExtras(extras);
2052                     intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);
2053                     mContext.sendBroadcast(intent);
2054                 }
2055             } catch (RuntimeException ex) {
2056                 Log.e(TAG, &quot;Problem allocating appWidgetId&quot;, ex);
2057             }
2058 
2059             return allocatedAppWidgets;
2060         }
2061 
2062         private long addUriShortcut(SQLiteDatabase db, ContentValues values, Resources res,
2063                 XmlResourceParser parser) {
2064             final int iconResId = getAttributeResourceValue(parser, ATTR_ICON, 0);
2065             final int titleResId = getAttributeResourceValue(parser, ATTR_TITLE, 0);
2066 
2067             Intent intent;
2068             String uri = null;
2069             try {
2070                 uri = getAttributeValue(parser, ATTR_URI);
2071                 intent = Intent.parseUri(uri, 0);
2072             } catch (URISyntaxException e) {
2073                 Log.w(TAG, &quot;Shortcut has malformed uri: &quot; + uri);
2074                 return -1; // Oh well
2075             }
2076 
2077             if (iconResId == 0 || titleResId == 0) {
2078                 Log.w(TAG, &quot;Shortcut is missing title or icon resource ID&quot;);
2079                 return -1;
2080             }
2081 
2082             long id = generateNewItemId();
2083             intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
2084             values.put(Favorites.INTENT, intent.toUri(0));
2085             values.put(Favorites.TITLE, res.getString(titleResId));
2086             values.put(Favorites.ITEM_TYPE, Favorites.ITEM_TYPE_SHORTCUT);
2087             values.put(Favorites.SPANX, 1);
2088             values.put(Favorites.SPANY, 1);
2089             values.put(Favorites.ICON_TYPE, Favorites.ICON_TYPE_RESOURCE);
2090             values.put(Favorites.ICON_PACKAGE, res.getResourcePackageName(iconResId));
2091             values.put(Favorites.ICON_RESOURCE, res.getResourceName(iconResId));
2092             values.put(Favorites._ID, id);
2093 
2094             if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values) &lt; 0) {
2095                 return -1;
2096             }
2097             return id;
2098         }
2099 
2100         private void migrateLauncher2Shortcuts(SQLiteDatabase db, Uri uri) {
2101             final ContentResolver resolver = mContext.getContentResolver();
2102             Cursor c = null;
2103             int count = 0;
2104             int curScreen = 0;
2105 
2106             try {
2107                 c = resolver.query(uri, null, null, null, &quot;title ASC&quot;);
2108             } catch (Exception e) {
2109                 // Ignore
2110             }
2111 
2112             // We already have a favorites database in the old provider
2113             if (c != null) {
2114                 try {
2115                     if (c.getCount() &gt; 0) {
2116                         final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
2117                         final int intentIndex
2118                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.INTENT);
2119                         final int titleIndex
2120                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
2121                         final int iconTypeIndex
2122                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_TYPE);
2123                         final int iconIndex
2124                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
2125                         final int iconPackageIndex
2126                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_PACKAGE);
2127                         final int iconResourceIndex
2128                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_RESOURCE);
2129                         final int containerIndex
2130                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
2131                         final int itemTypeIndex
2132                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
2133                         final int screenIndex
2134                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
2135                         final int cellXIndex
2136                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
2137                         final int cellYIndex
2138                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
2139                         final int uriIndex
2140                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
2141                         final int displayModeIndex
2142                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.DISPLAY_MODE);
2143                         final int profileIndex
2144                                 = c.getColumnIndex(LauncherSettings.Favorites.PROFILE_ID);
2145 
2146                         int i = 0;
2147                         int curX = 0;
2148                         int curY = 0;
2149 
2150                         final LauncherAppState app = LauncherAppState.getInstance();
2151                         final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2152                         final int width = (int) grid.numColumns;
2153                         final int height = (int) grid.numRows;
2154                         final int hotseatWidth = (int) grid.numHotseatIcons;
2155 
2156                         final HashSet&lt;String&gt; seenIntents = new HashSet&lt;String&gt;(c.getCount());
2157 
2158                         final ArrayList&lt;ContentValues&gt; shortcuts = new ArrayList&lt;ContentValues&gt;();
2159                         final ArrayList&lt;ContentValues&gt; folders = new ArrayList&lt;ContentValues&gt;();
2160                         final SparseArray&lt;ContentValues&gt; hotseat = new SparseArray&lt;ContentValues&gt;();
2161 
2162                         while (c.moveToNext()) {
2163                             final int itemType = c.getInt(itemTypeIndex);
2164                             if (itemType != Favorites.ITEM_TYPE_APPLICATION
2165                                     &amp;&amp; itemType != Favorites.ITEM_TYPE_SHORTCUT
2166                                     &amp;&amp; itemType != Favorites.ITEM_TYPE_FOLDER) {
2167                                 continue;
2168                             }
2169 
2170                             final int cellX = c.getInt(cellXIndex);
2171                             final int cellY = c.getInt(cellYIndex);
2172                             final int screen = c.getInt(screenIndex);
2173                             int container = c.getInt(containerIndex);
2174                             final String intentStr = c.getString(intentIndex);
2175 
2176                             UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
2177                             UserHandleCompat userHandle;
2178                             final long userSerialNumber;
2179                             if (profileIndex != -1 &amp;&amp; !c.isNull(profileIndex)) {
2180                                 userSerialNumber = c.getInt(profileIndex);
2181                                 userHandle = userManager.getUserForSerialNumber(userSerialNumber);
2182                             } else {
2183                                 // Default to the serial number of this user, for older
2184                                 // shortcuts.
2185                                 userHandle = UserHandleCompat.myUserHandle();
2186                                 userSerialNumber = userManager.getSerialNumberForUser(userHandle);
2187                             }
2188                             Launcher.addDumpLog(TAG, &quot;migrating \&quot;&quot;
2189                                 + c.getString(titleIndex) + &quot;\&quot; (&quot;
2190                                 + cellX + &quot;,&quot; + cellY + &quot;@&quot;
2191                                 + LauncherSettings.Favorites.containerToString(container)
2192                                 + &quot;/&quot; + screen
2193                                 + &quot;): &quot; + intentStr, true);
2194 
2195                             if (itemType != Favorites.ITEM_TYPE_FOLDER) {
2196 
2197                                 final Intent intent;
2198                                 final ComponentName cn;
2199                                 try {
2200                                     intent = Intent.parseUri(intentStr, 0);
2201                                 } catch (URISyntaxException e) {
2202                                     // bogus intent?
2203                                     Launcher.addDumpLog(TAG,
2204                                             &quot;skipping invalid intent uri&quot;, true);
2205                                     continue;
2206                                 }
2207 
2208                                 cn = intent.getComponent();
2209                                 if (TextUtils.isEmpty(intentStr)) {
2210                                     // no intent? no icon
2211                                     Launcher.addDumpLog(TAG, &quot;skipping empty intent&quot;, true);
2212                                     continue;
2213                                 } else if (cn != null &amp;&amp;
2214                                         !LauncherModel.isValidPackageActivity(mContext, cn,
2215                                                 userHandle)) {
2216                                     // component no longer exists.
2217                                     Launcher.addDumpLog(TAG, &quot;skipping item whose component &quot; +
2218                                             &quot;no longer exists.&quot;, true);
2219                                     continue;
2220                                 } else if (container ==
2221                                         LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2222                                     // Dedupe icons directly on the workspace
2223 
2224                                     // Canonicalize
2225                                     // the Play Store sets the package parameter, but Launcher
2226                                     // does not, so we clear that out to keep them the same
2227                                     intent.setPackage(null);
2228                                     final String key = intent.toUri(0);
2229                                     if (seenIntents.contains(key)) {
2230                                         Launcher.addDumpLog(TAG, &quot;skipping duplicate&quot;, true);
2231                                         continue;
2232                                     } else {
2233                                         seenIntents.add(key);
2234                                     }
2235                                 }
2236                             }
2237 
2238                             ContentValues values = new ContentValues(c.getColumnCount());
2239                             values.put(LauncherSettings.Favorites._ID, c.getInt(idIndex));
2240                             values.put(LauncherSettings.Favorites.INTENT, intentStr);
2241                             values.put(LauncherSettings.Favorites.TITLE, c.getString(titleIndex));
2242                             values.put(LauncherSettings.Favorites.ICON_TYPE,
2243                                     c.getInt(iconTypeIndex));
2244                             values.put(LauncherSettings.Favorites.ICON, c.getBlob(iconIndex));
2245                             values.put(LauncherSettings.Favorites.ICON_PACKAGE,
2246                                     c.getString(iconPackageIndex));
2247                             values.put(LauncherSettings.Favorites.ICON_RESOURCE,
2248                                     c.getString(iconResourceIndex));
2249                             values.put(LauncherSettings.Favorites.ITEM_TYPE, itemType);
2250                             values.put(LauncherSettings.Favorites.APPWIDGET_ID, -1);
2251                             values.put(LauncherSettings.Favorites.URI, c.getString(uriIndex));
2252                             values.put(LauncherSettings.Favorites.DISPLAY_MODE,
2253                                     c.getInt(displayModeIndex));
2254                             values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
2255 
2256                             if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2257                                 hotseat.put(screen, values);
2258                             }
2259 
2260                             if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2261                                 // In a folder or in the hotseat, preserve position
2262                                 values.put(LauncherSettings.Favorites.SCREEN, screen);
2263                                 values.put(LauncherSettings.Favorites.CELLX, cellX);
2264                                 values.put(LauncherSettings.Favorites.CELLY, cellY);
2265                             } else {
2266                                 // For items contained directly on one of the workspace screen,
2267                                 // we&#x27;ll determine their location (screen, x, y) in a second pass.
2268                             }
2269 
2270                             values.put(LauncherSettings.Favorites.CONTAINER, container);
2271 
2272                             if (itemType != Favorites.ITEM_TYPE_FOLDER) {
2273                                 shortcuts.add(values);
2274                             } else {
2275                                 folders.add(values);
2276                             }
2277                         }
2278 
2279                         // Now that we have all the hotseat icons, let&#x27;s go through them left-right
2280                         // and assign valid locations for them in the new hotseat
2281                         final int N = hotseat.size();
2282                         for (int idx=0; idx&lt;N; idx++) {
2283                             int hotseatX = hotseat.keyAt(idx);
2284                             ContentValues values = hotseat.valueAt(idx);
2285 
2286                             if (hotseatX == grid.hotseatAllAppsRank) {
2287                                 // let&#x27;s drop this in the next available hole in the hotseat
2288                                 while (++hotseatX &lt; hotseatWidth) {
2289                                     if (hotseat.get(hotseatX) == null) {
2290                                         // found a spot! move it here
2291                                         values.put(LauncherSettings.Favorites.SCREEN,
2292                                                 hotseatX);
2293                                         break;
2294                                     }
2295                                 }
2296                             }
2297                             if (hotseatX &gt;= hotseatWidth) {
2298                                 // no room for you in the hotseat? it&#x27;s off to the desktop with you
2299                                 values.put(LauncherSettings.Favorites.CONTAINER,
2300                                            Favorites.CONTAINER_DESKTOP);
2301                             }
2302                         }
2303 
2304                         final ArrayList&lt;ContentValues&gt; allItems = new ArrayList&lt;ContentValues&gt;();
2305                         // Folders first
2306                         allItems.addAll(folders);
2307                         // Then shortcuts
2308                         allItems.addAll(shortcuts);
2309 
2310                         // Layout all the folders
2311                         for (ContentValues values: allItems) {
2312                             if (values.getAsInteger(LauncherSettings.Favorites.CONTAINER) !=
2313                                     LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2314                                 // Hotseat items and folder items have already had their
2315                                 // location information set. Nothing to be done here.
2316                                 continue;
2317                             }
2318                             values.put(LauncherSettings.Favorites.SCREEN, curScreen);
2319                             values.put(LauncherSettings.Favorites.CELLX, curX);
2320                             values.put(LauncherSettings.Favorites.CELLY, curY);
2321                             curX = (curX + 1) % width;
2322                             if (curX == 0) {
2323                                 curY = (curY + 1);
2324                             }
2325                             // Leave the last row of icons blank on every screen
2326                             if (curY == height - 1) {
2327                                 curScreen = (int) generateNewScreenId();
2328                                 curY = 0;
2329                             }
2330                         }
2331 
2332                         if (allItems.size() &gt; 0) {
2333                             db.beginTransaction();
2334                             try {
2335                                 for (ContentValues row: allItems) {
2336                                     if (row == null) continue;
2337                                     if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, row)
2338                                             &lt; 0) {
2339                                         return;
2340                                     } else {
2341                                         count++;
2342                                     }
2343                                 }
2344                                 db.setTransactionSuccessful();
2345                             } finally {
2346                                 db.endTransaction();
2347                             }
2348                         }
2349 
2350                         db.beginTransaction();
2351                         try {
2352                             for (i=0; i&lt;=curScreen; i++) {
2353                                 final ContentValues values = new ContentValues();
2354                                 values.put(LauncherSettings.WorkspaceScreens._ID, i);
2355                                 values.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
2356                                 if (dbInsertAndCheck(this, db, TABLE_WORKSPACE_SCREENS, null, values)
2357                                         &lt; 0) {
2358                                     return;
2359                                 }
2360                             }
2361                             db.setTransactionSuccessful();
2362                         } finally {
2363                             db.endTransaction();
2364                         }
2365                     }
2366                 } finally {
2367                     c.close();
2368                 }
2369             }
2370 
2371             Launcher.addDumpLog(TAG, &quot;migrated &quot; + count + &quot; icons from Launcher2 into &quot;
2372                     + (curScreen+1) + &quot; screens&quot;, true);
2373 
2374             // ensure that new screens are created to hold these icons
2375             setFlagJustLoadedOldDb();
2376 
2377             // Update max IDs; very important since we just grabbed IDs from another database
2378             mMaxItemId = initializeMaxItemId(db);
2379             mMaxScreenId = initializeMaxScreenId(db);
2380             if (LOGD) Log.d(TAG, &quot;mMaxItemId: &quot; + mMaxItemId + &quot; mMaxScreenId: &quot; + mMaxScreenId);
2381         }
2382     }
2383 
2384     /**
2385      * Build a query string that will match any row where the column matches
2386      * anything in the values list.
2387      */
2388     private static String buildOrWhereString(String column, int[] values) {
2389         StringBuilder selectWhere = new StringBuilder();
2390         for (int i = values.length - 1; i &gt;= 0; i--) {
2391             selectWhere.append(column).append(&quot;=&quot;).append(values[i]);
2392             if (i &gt; 0) {
2393                 selectWhere.append(&quot; OR &quot;);
2394             }
2395         }
2396         return selectWhere.toString();
2397     }
2398 
2399     /**
2400      * Return attribute value, attempting launcher-specific namespace first
2401      * before falling back to anonymous attribute.
2402      */
2403     private static String getAttributeValue(XmlResourceParser parser, String attribute) {
2404         String value = parser.getAttributeValue(
2405                 &quot;http://schemas.android.com/apk/res-auto/com.android.launcher3&quot;, attribute);
2406         if (value == null) {
2407             value = parser.getAttributeValue(null, attribute);
2408         }
2409         return value;
2410     }
2411 
2412     /**
2413      * Return attribute resource value, attempting launcher-specific namespace
2414      * first before falling back to anonymous attribute.
2415      */
2416     private static int getAttributeResourceValue(XmlResourceParser parser, String attribute,
2417             int defaultValue) {
2418         int value = parser.getAttributeResourceValue(
2419                 &quot;http://schemas.android.com/apk/res-auto/com.android.launcher3&quot;, attribute,
2420                 defaultValue);
2421         if (value == defaultValue) {
2422             value = parser.getAttributeResourceValue(null, attribute, defaultValue);
2423         }
2424         return value;
2425     }
2426 
2427     private static void copyInteger(ContentValues from, ContentValues to, String key) {
2428         to.put(key, from.getAsInteger(key));
2429     }
2430 
2431     static class SqlArguments {
2432         public final String table;
2433         public final String where;
2434         public final String[] args;
2435 
2436         SqlArguments(Uri url, String where, String[] args) {
2437             if (url.getPathSegments().size() == 1) {
2438                 this.table = url.getPathSegments().get(0);
2439                 this.where = where;
2440                 this.args = args;
2441             } else if (url.getPathSegments().size() != 2) {
2442                 throw new IllegalArgumentException(&quot;Invalid URI: &quot; + url);
2443             } else if (!TextUtils.isEmpty(where)) {
2444                 throw new UnsupportedOperationException(&quot;WHERE clause not supported: &quot; + url);
2445             } else {
2446                 this.table = url.getPathSegments().get(0);
2447                 this.where = &quot;_id=&quot; + ContentUris.parseId(url);
2448                 this.args = null;
2449             }
2450         }
2451 
2452         SqlArguments(Uri url) {
2453             if (url.getPathSegments().size() == 1) {
2454                 table = url.getPathSegments().get(0);
2455                 where = null;
2456                 args = null;
2457             } else {
2458                 throw new IllegalArgumentException(&quot;Invalid URI: &quot; + url);
2459             }
2460         }
2461     }
2462 
2463     static interface WorkspaceLoader {
2464         /**
2465          * @param screenIds A mutable list of screen its
2466          * @return the number of workspace items added.
2467          */
2468         int loadLayout(SQLiteDatabase db, ArrayList&lt;Long&gt; screenIds);
2469     }
2470 
2471     private static class SimpleWorkspaceLoader implements WorkspaceLoader {
2472         private final Resources mRes;
2473         private final int mWorkspaceId;
2474         private final DatabaseHelper mHelper;
2475 
2476         SimpleWorkspaceLoader(DatabaseHelper helper, Resources res, int workspaceId) {
2477             mHelper = helper;
2478             mRes = res;
2479             mWorkspaceId = workspaceId;
2480         }
2481 
2482         @Override
2483         public int loadLayout(SQLiteDatabase db, ArrayList&lt;Long&gt; screenIds) {
2484             return mHelper.loadFavoritesRecursive(db, mRes, mWorkspaceId, screenIds);
2485         }
2486     }
2487 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher3;
  18 
  19 import android.app.SearchManager;
  20 import android.appwidget.AppWidgetHost;
  21 import android.appwidget.AppWidgetManager;
  22 import android.appwidget.AppWidgetProviderInfo;
  23 import android.content.ComponentName;
  24 import android.content.ContentProvider;
  25 import android.content.ContentProviderOperation;
  26 import android.content.ContentProviderResult;
  27 import android.content.ContentResolver;
  28 import android.content.ContentUris;
  29 import android.content.ContentValues;
  30 import android.content.Context;
  31 import android.content.Intent;
  32 import android.content.OperationApplicationException;
  33 import android.content.SharedPreferences;
  34 import android.content.pm.ActivityInfo;
  35 import android.content.pm.ApplicationInfo;
  36 import android.content.pm.PackageManager;
  37 import android.content.pm.ResolveInfo;
  38 import android.content.res.Resources;
  39 import android.content.res.XmlResourceParser;
  40 import android.database.Cursor;
  41 import android.database.SQLException;
  42 import android.database.sqlite.SQLiteDatabase;
  43 import android.database.sqlite.SQLiteOpenHelper;
  44 import android.database.sqlite.SQLiteQueryBuilder;
  45 import android.database.sqlite.SQLiteStatement;
  46 import android.graphics.Bitmap;
  47 import android.graphics.BitmapFactory;
  48 import android.net.Uri;
  49 import android.os.Bundle;
  50 import android.provider.Settings;
  51 import android.text.TextUtils;
  52 import android.util.Log;
  53 import android.util.SparseArray;
  54 
  55 import com.android.launcher3.AutoInstallsLayout.LayoutParserCallback;
  56 import com.android.launcher3.LauncherSettings.Favorites;
  57 import com.android.launcher3.compat.UserHandleCompat;
  58 import com.android.launcher3.compat.UserManagerCompat;
  59 import com.android.launcher3.config.ProviderConfig;
  60 
  61 import org.xmlpull.v1.XmlPullParser;
  62 import org.xmlpull.v1.XmlPullParserException;
  63 
  64 import java.io.File;
  65 import java.io.IOException;
  66 import java.net.URISyntaxException;
  67 import java.util.ArrayList;
  68 import java.util.Collections;
  69 import java.util.HashSet;
  70 import java.util.List;
  71 
  72 public class LauncherProvider extends ContentProvider {
  73     private static final String TAG = &quot;Launcher.LauncherProvider&quot;;
  74     private static final boolean LOGD = false;
  75 
  76     private static final String DATABASE_NAME = &quot;launcher.db&quot;;
  77 
  78     private static final int DATABASE_VERSION = 20;
  79 
  80     static final String OLD_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
  81     static final String AUTHORITY = ProviderConfig.AUTHORITY;
  82 
  83     // Should we attempt to load anything from the com.android.launcher2 provider?
  84     static final boolean IMPORT_LAUNCHER2_DATABASE = false;
  85 
  86     static final String TABLE_FAVORITES = &quot;favorites&quot;;
  87     static final String TABLE_WORKSPACE_SCREENS = &quot;workspaceScreens&quot;;
  88     static final String PARAMETER_NOTIFY = &quot;notify&quot;;
  89     static final String UPGRADED_FROM_OLD_DATABASE =
  90             &quot;UPGRADED_FROM_OLD_DATABASE&quot;;
  91     static final String EMPTY_DATABASE_CREATED =
  92             &quot;EMPTY_DATABASE_CREATED&quot;;
  93 
  94     private static final String ACTION_APPWIDGET_DEFAULT_WORKSPACE_CONFIGURE =
  95             &quot;com.android.launcher.action.APPWIDGET_DEFAULT_WORKSPACE_CONFIGURE&quot;;
  96 
  97     private static final String URI_PARAM_IS_EXTERNAL_ADD = &quot;isExternalAdd&quot;;
  98 
  99     private LauncherProviderChangeListener mListener;
 100 
 101     /**
 102      * {@link Uri} triggered at any registered {@link android.database.ContentObserver} when
 103      * {@link AppWidgetHost#deleteHost()} is called during database creation.
 104      * Use this to recall {@link AppWidgetHost#startListening()} if needed.
 105      */
 106     static final Uri CONTENT_APPWIDGET_RESET_URI =
 107             Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/appWidgetReset&quot;);
 108 
 109     private DatabaseHelper mOpenHelper;
 110     private static boolean sJustLoadedFromOldDb;
 111 
 112     @Override
 113     public boolean onCreate() {
 114         final Context context = getContext();
 115         mOpenHelper = new DatabaseHelper(context);
 116         LauncherAppState.setLauncherProvider(this);
 117         return true;
 118     }
 119 
 120     public boolean wasNewDbCreated() {
 121         return mOpenHelper.wasNewDbCreated();
 122     }
 123 
 124     public void setLauncherProviderChangeListener(LauncherProviderChangeListener listener) {
 125         mListener = listener;
 126     }
 127 
 128     @Override
 129     public String getType(Uri uri) {
 130         SqlArguments args = new SqlArguments(uri, null, null);
 131         if (TextUtils.isEmpty(args.where)) {
 132             return &quot;vnd.android.cursor.dir/&quot; + args.table;
 133         } else {
 134             return &quot;vnd.android.cursor.item/&quot; + args.table;
 135         }
 136     }
 137 
 138     @Override
 139     public Cursor query(Uri uri, String[] projection, String selection,
 140             String[] selectionArgs, String sortOrder) {
 141 
 142         SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 143         SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
 144         qb.setTables(args.table);
 145 
 146         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 147         Cursor result = qb.query(db, projection, args.where, args.args, null, null, sortOrder);
 148         result.setNotificationUri(getContext().getContentResolver(), uri);
 149 
 150         return result;
 151     }
 152 
 153     private static long dbInsertAndCheck(DatabaseHelper helper,
 154             SQLiteDatabase db, String table, String nullColumnHack, ContentValues values) {
 155         if (values == null) {
 156             throw new RuntimeException(&quot;Error: attempting to insert null values&quot;);
 157         }
 158         if (!values.containsKey(LauncherSettings.ChangeLogColumns._ID)) {
 159             throw new RuntimeException(&quot;Error: attempting to add item without specifying an id&quot;);
 160         }
 161         helper.checkId(table, values);
 162         return db.insert(table, nullColumnHack, values);
 163     }
 164 
 165     private static void deleteId(SQLiteDatabase db, long id) {
 166         Uri uri = LauncherSettings.Favorites.getContentUri(id, false);
 167         SqlArguments args = new SqlArguments(uri, null, null);
 168         db.delete(args.table, args.where, args.args);
 169     }
 170 
 171     @Override
 172     public Uri insert(Uri uri, ContentValues initialValues) {
 173         SqlArguments args = new SqlArguments(uri);
 174 
 175         // In very limited cases, we support system|signature permission apps to add to the db
 176         String externalAdd = uri.getQueryParameter(URI_PARAM_IS_EXTERNAL_ADD);
 177         if (externalAdd != null &amp;&amp; &quot;true&quot;.equals(externalAdd)) {
 178             if (!mOpenHelper.initializeExternalAdd(initialValues)) {
 179                 return null;
 180             }
 181         }
 182 
 183         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 184         addModifiedTime(initialValues);
 185         final long rowId = dbInsertAndCheck(mOpenHelper, db, args.table, null, initialValues);
 186         if (rowId &lt;= 0) return null;
 187 
 188         uri = ContentUris.withAppendedId(uri, rowId);
 189         sendNotify(uri);
 190 
 191         return uri;
 192     }
 193 
 194 
 195     @Override
 196     public int bulkInsert(Uri uri, ContentValues[] values) {
 197         SqlArguments args = new SqlArguments(uri);
 198 
 199         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 200         db.beginTransaction();
 201         try {
 202             int numValues = values.length;
 203             for (int i = 0; i &lt; numValues; i++) {
 204                 addModifiedTime(values[i]);
 205                 if (dbInsertAndCheck(mOpenHelper, db, args.table, null, values[i]) &lt; 0) {
 206                     return 0;
 207                 }
 208             }
 209             db.setTransactionSuccessful();
 210         } finally {
 211             db.endTransaction();
 212         }
 213 
 214         sendNotify(uri);
 215         return values.length;
 216     }
 217 
 218     @Override
 219     public ContentProviderResult[] applyBatch(ArrayList&lt;ContentProviderOperation&gt; operations)
 220             throws OperationApplicationException {
 221         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 222         db.beginTransaction();
 223         try {
 224             ContentProviderResult[] result =  super.applyBatch(operations);
 225             db.setTransactionSuccessful();
 226             return result;
 227         } finally {
 228             db.endTransaction();
 229         }
 230     }
 231 
 232     @Override
 233     public int delete(Uri uri, String selection, String[] selectionArgs) {
 234         SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 235 
 236         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 237         int count = db.delete(args.table, args.where, args.args);
 238         if (count &gt; 0) sendNotify(uri);
 239 
 240         return count;
 241     }
 242 
 243     @Override
 244     public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
 245         SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 246 
 247         addModifiedTime(values);
 248         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 249         int count = db.update(args.table, values, args.where, args.args);
 250         if (count &gt; 0) sendNotify(uri);
 251 
 252         return count;
 253     }
 254 
 255     private void sendNotify(Uri uri) {
 256         String notify = uri.getQueryParameter(PARAMETER_NOTIFY);
 257         if (notify == null || &quot;true&quot;.equals(notify)) {
 258             getContext().getContentResolver().notifyChange(uri, null);
 259         }
 260 
 261         // always notify the backup agent
 262         LauncherBackupAgentHelper.dataChanged(getContext());
 263         if (mListener != null) {
 264             mListener.onLauncherProviderChange();
 265         }
 266     }
 267 
 268     private void addModifiedTime(ContentValues values) {
 269         values.put(LauncherSettings.ChangeLogColumns.MODIFIED, System.currentTimeMillis());
 270     }
 271 
 272     public long generateNewItemId() {
 273         return mOpenHelper.generateNewItemId();
 274     }
 275 
 276     public void updateMaxItemId(long id) {
 277         mOpenHelper.updateMaxItemId(id);
 278     }
 279 
 280     public long generateNewScreenId() {
 281         return mOpenHelper.generateNewScreenId();
 282     }
 283 
 284     // This is only required one time while loading the workspace during the
 285     // upgrade path, and should never be called from anywhere else.
 286     public void updateMaxScreenId(long maxScreenId) {
 287         mOpenHelper.updateMaxScreenId(maxScreenId);
 288     }
 289 
 290     /**
 291      * @param Should we load the old db for upgrade? first run only.
 292      */
 293     synchronized public boolean justLoadedOldDb() {
 294         String spKey = LauncherAppState.getSharedPreferencesKey();
 295         SharedPreferences sp = getContext().getSharedPreferences(spKey, Context.MODE_PRIVATE);
 296 
 297         boolean loadedOldDb = false || sJustLoadedFromOldDb;
 298 
 299         sJustLoadedFromOldDb = false;
 300         if (sp.getBoolean(UPGRADED_FROM_OLD_DATABASE, false)) {
 301 
 302             SharedPreferences.Editor editor = sp.edit();
 303             editor.remove(UPGRADED_FROM_OLD_DATABASE);
 304             editor.commit();
 305             loadedOldDb = true;
 306         }
 307         return loadedOldDb;
 308     }
 309 
 310     /**
 311      * Clears all the data for a fresh start.
 312      */
 313     synchronized public void createEmptyDB() {
 314         mOpenHelper.createEmptyDB(mOpenHelper.getWritableDatabase());
 315     }
 316 
 317     /**
 318      * Loads the default workspace based on the following priority scheme:
 319      *   1) From a package provided by play store
 320      *   2) From a partner configuration APK, already in the system image
 321      *   3) The default configuration for the particular device
 322      */
 323     synchronized public void loadDefaultFavoritesIfNecessary() {
 324         String spKey = LauncherAppState.getSharedPreferencesKey();
 325         SharedPreferences sp = getContext().getSharedPreferences(spKey, Context.MODE_PRIVATE);
 326 
 327         if (sp.getBoolean(EMPTY_DATABASE_CREATED, false)) {
 328             Log.d(TAG, &quot;loading default workspace&quot;);
 329 
 330             WorkspaceLoader loader = AutoInstallsLayout.get(getContext(),
 331                     mOpenHelper.mAppWidgetHost, mOpenHelper);
 332 
 333             if (loader == null) {
 334                 final Partner partner = Partner.get(getContext().getPackageManager());
 335                 if (partner != null &amp;&amp; partner.hasDefaultLayout()) {
 336                     final Resources partnerRes = partner.getResources();
 337                     int workspaceResId = partnerRes.getIdentifier(Partner.RES_DEFAULT_LAYOUT,
 338                             &quot;xml&quot;, partner.getPackageName());
 339                     if (workspaceResId != 0) {
 340                         loader = new SimpleWorkspaceLoader(mOpenHelper, partnerRes, workspaceResId);
 341                     }
 342                 }
 343             }
 344 
 345             if (loader == null) {
 346                 loader = new SimpleWorkspaceLoader(mOpenHelper, getContext().getResources(),
 347                         getDefaultWorkspaceResourceId());
 348             }
 349 
 350             // Populate favorites table with initial favorites
 351             SharedPreferences.Editor editor = sp.edit().remove(EMPTY_DATABASE_CREATED);
 352             mOpenHelper.loadFavorites(mOpenHelper.getWritableDatabase(), loader);
 353             editor.commit();
 354         }
 355     }
 356 
 357     public void migrateLauncher2Shortcuts() {
 358         mOpenHelper.migrateLauncher2Shortcuts(mOpenHelper.getWritableDatabase(),
 359                 Uri.parse(getContext().getString(R.string.old_launcher_provider_uri)));
 360     }
 361 
 362     private static int getDefaultWorkspaceResourceId() {
 363         LauncherAppState app = LauncherAppState.getInstance();
 364         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 365         if (LauncherAppState.isDisableAllApps()) {
 366             return grid.defaultNoAllAppsLayoutId;
 367         } else {
 368             return grid.defaultLayoutId;
 369         }
 370     }
 371 
 372     private static interface ContentValuesCallback {
 373         public void onRow(ContentValues values);
 374     }
 375 
 376     private static boolean shouldImportLauncher2Database(Context context) {
 377         boolean isTablet = context.getResources().getBoolean(R.bool.is_tablet);
 378 
 379         // We don&#x27;t import the old databse for tablets, as the grid size has changed.
 380         return !isTablet &amp;&amp; IMPORT_LAUNCHER2_DATABASE;
 381     }
 382 
 383     public void deleteDatabase() {
 384         // Are you sure? (y/n)
 385         final SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 386         final File dbFile = new File(db.getPath());
 387         mOpenHelper.close();
 388         if (dbFile.exists()) {
 389             SQLiteDatabase.deleteDatabase(dbFile);
 390         }
 391         mOpenHelper = new DatabaseHelper(getContext());
 392     }
 393 
 394     private static class DatabaseHelper extends SQLiteOpenHelper implements LayoutParserCallback {
 395         private static final String TAG_RESOLVE = &quot;resolve&quot;;
 396         private static final String TAG_FAVORITES = &quot;favorites&quot;;
 397         private static final String TAG_FAVORITE = &quot;favorite&quot;;
 398         private static final String TAG_APPWIDGET = &quot;appwidget&quot;;
 399         private static final String TAG_SHORTCUT = &quot;shortcut&quot;;
 400         private static final String TAG_FOLDER = &quot;folder&quot;;
 401         private static final String TAG_PARTNER_FOLDER = &quot;partner-folder&quot;;
 402         private static final String TAG_EXTRA = &quot;extra&quot;;
 403         private static final String TAG_INCLUDE = &quot;include&quot;;
 404 
 405         // Style attrs -- &quot;Favorite&quot;
 406         private static final String ATTR_CLASS_NAME = &quot;className&quot;;
 407         private static final String ATTR_PACKAGE_NAME = &quot;packageName&quot;;
 408         private static final String ATTR_CONTAINER = &quot;container&quot;;
 409         private static final String ATTR_SCREEN = &quot;screen&quot;;
 410         private static final String ATTR_X = &quot;x&quot;;
 411         private static final String ATTR_Y = &quot;y&quot;;
 412         private static final String ATTR_SPAN_X = &quot;spanX&quot;;
 413         private static final String ATTR_SPAN_Y = &quot;spanY&quot;;
 414         private static final String ATTR_ICON = &quot;icon&quot;;
 415         private static final String ATTR_TITLE = &quot;title&quot;;
 416         private static final String ATTR_URI = &quot;uri&quot;;
 417 
 418         // Style attrs -- &quot;Include&quot;
 419         private static final String ATTR_WORKSPACE = &quot;workspace&quot;;
 420 
 421         // Style attrs -- &quot;Extra&quot;
 422         private static final String ATTR_KEY = &quot;key&quot;;
 423         private static final String ATTR_VALUE = &quot;value&quot;;
 424 
 425         private final Context mContext;
 426         private final PackageManager mPackageManager;
 427         private final AppWidgetHost mAppWidgetHost;
 428         private long mMaxItemId = -1;
 429         private long mMaxScreenId = -1;
 430 
 431         private boolean mNewDbCreated = false;
 432 
 433         DatabaseHelper(Context context) {
 434             super(context, DATABASE_NAME, null, DATABASE_VERSION);
 435             mContext = context;
 436             mPackageManager = context.getPackageManager();
 437             mAppWidgetHost = new AppWidgetHost(context, Launcher.APPWIDGET_HOST_ID);
 438 
 439             // In the case where neither onCreate nor onUpgrade gets called, we read the maxId from
 440             // the DB here
 441             if (mMaxItemId == -1) {
 442                 mMaxItemId = initializeMaxItemId(getWritableDatabase());
 443             }
 444             if (mMaxScreenId == -1) {
 445                 mMaxScreenId = initializeMaxScreenId(getWritableDatabase());
 446             }
 447         }
 448 
 449         public boolean wasNewDbCreated() {
 450             return mNewDbCreated;
 451         }
 452 
 453         /**
 454          * Send notification that we&#x27;ve deleted the {@link AppWidgetHost},
 455          * probably as part of the initial database creation. The receiver may
 456          * want to re-call {@link AppWidgetHost#startListening()} to ensure
 457          * callbacks are correctly set.
 458          */
 459         private void sendAppWidgetResetNotify() {
 460             final ContentResolver resolver = mContext.getContentResolver();
 461             resolver.notifyChange(CONTENT_APPWIDGET_RESET_URI, null);
 462         }
 463 
 464         @Override
 465         public void onCreate(SQLiteDatabase db) {
 466             if (LOGD) Log.d(TAG, &quot;creating new launcher database&quot;);
 467 
 468             mMaxItemId = 1;
 469             mMaxScreenId = 0;
 470             mNewDbCreated = true;
 471 
 472             UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 473             long userSerialNumber = userManager.getSerialNumberForUser(
 474                     UserHandleCompat.myUserHandle());
 475 
 476             db.execSQL(&quot;CREATE TABLE favorites (&quot; +
 477                     &quot;_id INTEGER PRIMARY KEY,&quot; +
 478                     &quot;title TEXT,&quot; +
 479                     &quot;intent TEXT,&quot; +
 480                     &quot;container INTEGER,&quot; +
 481                     &quot;screen INTEGER,&quot; +
 482                     &quot;cellX INTEGER,&quot; +
 483                     &quot;cellY INTEGER,&quot; +
 484                     &quot;spanX INTEGER,&quot; +
 485                     &quot;spanY INTEGER,&quot; +
 486                     &quot;itemType INTEGER,&quot; +
 487                     &quot;appWidgetId INTEGER NOT NULL DEFAULT -1,&quot; +
 488                     &quot;isShortcut INTEGER,&quot; +
 489                     &quot;iconType INTEGER,&quot; +
 490                     &quot;iconPackage TEXT,&quot; +
 491                     &quot;iconResource TEXT,&quot; +
 492                     &quot;icon BLOB,&quot; +
 493                     &quot;uri TEXT,&quot; +
 494                     &quot;displayMode INTEGER,&quot; +
 495                     &quot;appWidgetProvider TEXT,&quot; +
 496                     &quot;modified INTEGER NOT NULL DEFAULT 0,&quot; +
 497                     &quot;restored INTEGER NOT NULL DEFAULT 0,&quot; +
 498                     &quot;profileId INTEGER DEFAULT &quot; + userSerialNumber +
 499                     &quot;);&quot;);
 500             addWorkspacesTable(db);
 501 
 502             // Database was just created, so wipe any previous widgets
 503             if (mAppWidgetHost != null) {
 504                 mAppWidgetHost.deleteHost();
 505                 sendAppWidgetResetNotify();
 506             }
 507 
 508             if (shouldImportLauncher2Database(mContext)) {
 509                 // Try converting the old database
 510                 ContentValuesCallback permuteScreensCb = new ContentValuesCallback() {
 511                     public void onRow(ContentValues values) {
 512                         int container = values.getAsInteger(LauncherSettings.Favorites.CONTAINER);
 513                         if (container == Favorites.CONTAINER_DESKTOP) {
 514                             int screen = values.getAsInteger(LauncherSettings.Favorites.SCREEN);
 515                             screen = (int) upgradeLauncherDb_permuteScreens(screen);
 516                             values.put(LauncherSettings.Favorites.SCREEN, screen);
 517                         }
 518                     }
 519                 };
 520                 Uri uri = Uri.parse(&quot;content://&quot; + Settings.AUTHORITY +
 521                         &quot;/old_favorites?notify=true&quot;);
 522                 if (!convertDatabase(db, uri, permuteScreensCb, true)) {
 523                     // Try and upgrade from the Launcher2 db
 524                     uri = Uri.parse(mContext.getString(R.string.old_launcher_provider_uri));
 525                     if (!convertDatabase(db, uri, permuteScreensCb, false)) {
 526                         // If we fail, then set a flag to load the default workspace
 527                         setFlagEmptyDbCreated();
 528                         return;
 529                     }
 530                 }
 531                 // Right now, in non-default workspace cases, we want to run the final
 532                 // upgrade code (ie. to fix workspace screen indices -&gt; ids, etc.), so
 533                 // set that flag too.
 534                 setFlagJustLoadedOldDb();
 535             } else {
 536                 // Fresh and clean launcher DB.
 537                 mMaxItemId = initializeMaxItemId(db);
 538                 setFlagEmptyDbCreated();
 539             }
 540         }
 541 
 542         private void addWorkspacesTable(SQLiteDatabase db) {
 543             db.execSQL(&quot;CREATE TABLE &quot; + TABLE_WORKSPACE_SCREENS + &quot; (&quot; +
 544                     LauncherSettings.WorkspaceScreens._ID + &quot; INTEGER,&quot; +
 545                     LauncherSettings.WorkspaceScreens.SCREEN_RANK + &quot; INTEGER,&quot; +
 546                     LauncherSettings.ChangeLogColumns.MODIFIED + &quot; INTEGER NOT NULL DEFAULT 0&quot; +
 547                     &quot;);&quot;);
 548         }
 549 
 550         private void removeOrphanedItems(SQLiteDatabase db) {
 551             // Delete items directly on the workspace who&#x27;s screen id doesn&#x27;t exist
 552             //  &quot;DELETE FROM favorites WHERE screen NOT IN (SELECT _id FROM workspaceScreens)
 553             //   AND container = -100&quot;
 554             String removeOrphanedDesktopItems = &quot;DELETE FROM &quot; + TABLE_FAVORITES +
 555                     &quot; WHERE &quot; +
 556                     LauncherSettings.Favorites.SCREEN + &quot; NOT IN (SELECT &quot; +
 557                     LauncherSettings.WorkspaceScreens._ID + &quot; FROM &quot; + TABLE_WORKSPACE_SCREENS + &quot;)&quot; +
 558                     &quot; AND &quot; +
 559                     LauncherSettings.Favorites.CONTAINER + &quot; = &quot; +
 560                     LauncherSettings.Favorites.CONTAINER_DESKTOP;
 561             db.execSQL(removeOrphanedDesktopItems);
 562 
 563             // Delete items contained in folders which no longer exist (after above statement)
 564             //  &quot;DELETE FROM favorites  WHERE container &lt;&gt; -100 AND container &lt;&gt; -101 AND container
 565             //   NOT IN (SELECT _id FROM favorites WHERE itemType = 2)&quot;
 566             String removeOrphanedFolderItems = &quot;DELETE FROM &quot; + TABLE_FAVORITES +
 567                     &quot; WHERE &quot; +
 568                     LauncherSettings.Favorites.CONTAINER + &quot; &lt;&gt; &quot; +
 569                     LauncherSettings.Favorites.CONTAINER_DESKTOP +
 570                     &quot; AND &quot;
 571                     + LauncherSettings.Favorites.CONTAINER + &quot; &lt;&gt; &quot; +
 572                     LauncherSettings.Favorites.CONTAINER_HOTSEAT +
 573                     &quot; AND &quot;
 574                     + LauncherSettings.Favorites.CONTAINER + &quot; NOT IN (SELECT &quot; +
 575                     LauncherSettings.Favorites._ID + &quot; FROM &quot; + TABLE_FAVORITES +
 576                     &quot; WHERE &quot; + LauncherSettings.Favorites.ITEM_TYPE + &quot; = &quot; +
 577                     LauncherSettings.Favorites.ITEM_TYPE_FOLDER + &quot;)&quot;;
 578             db.execSQL(removeOrphanedFolderItems);
 579         }
 580 
 581         private void setFlagJustLoadedOldDb() {
 582             String spKey = LauncherAppState.getSharedPreferencesKey();
 583             SharedPreferences sp = mContext.getSharedPreferences(spKey, Context.MODE_PRIVATE);
 584             SharedPreferences.Editor editor = sp.edit();
 585             editor.putBoolean(UPGRADED_FROM_OLD_DATABASE, true);
 586             editor.putBoolean(EMPTY_DATABASE_CREATED, false);
 587             editor.commit();
 588         }
 589 
 590         private void setFlagEmptyDbCreated() {
 591             String spKey = LauncherAppState.getSharedPreferencesKey();
 592             SharedPreferences sp = mContext.getSharedPreferences(spKey, Context.MODE_PRIVATE);
 593             SharedPreferences.Editor editor = sp.edit();
 594             editor.putBoolean(EMPTY_DATABASE_CREATED, true);
 595             editor.putBoolean(UPGRADED_FROM_OLD_DATABASE, false);
 596             editor.commit();
 597         }
 598 
 599         // We rearrange the screens from the old launcher
 600         // 12345 -&gt; 34512
 601         private long upgradeLauncherDb_permuteScreens(long screen) {
 602             if (screen &gt;= 2) {
 603                 return screen - 2;
 604             } else {
 605                 return screen + 3;
 606             }
 607         }
 608 
 609         private boolean convertDatabase(SQLiteDatabase db, Uri uri,
 610                                         ContentValuesCallback cb, boolean deleteRows) {
 611             if (LOGD) Log.d(TAG, &quot;converting database from an older format, but not onUpgrade&quot;);
 612             boolean converted = false;
 613 
 614             final ContentResolver resolver = mContext.getContentResolver();
 615             Cursor cursor = null;
 616 
 617             try {
 618                 cursor = resolver.query(uri, null, null, null, null);
 619             } catch (Exception e) {
 620                 // Ignore
 621             }
 622 
 623             // We already have a favorites database in the old provider
 624             if (cursor != null) {
 625                 try {
 626                      if (cursor.getCount() &gt; 0) {
 627                         converted = copyFromCursor(db, cursor, cb) &gt; 0;
 628                         if (converted &amp;&amp; deleteRows) {
 629                             resolver.delete(uri, null, null);
 630                         }
 631                     }
 632                 } finally {
 633                     cursor.close();
 634                 }
 635             }
 636 
 637             if (converted) {
 638                 // Convert widgets from this import into widgets
 639                 if (LOGD) Log.d(TAG, &quot;converted and now triggering widget upgrade&quot;);
 640                 convertWidgets(db);
 641 
 642                 // Update max item id
 643                 mMaxItemId = initializeMaxItemId(db);
 644                 if (LOGD) Log.d(TAG, &quot;mMaxItemId: &quot; + mMaxItemId);
 645             }
 646 
 647             return converted;
 648         }
 649 
 650         private int copyFromCursor(SQLiteDatabase db, Cursor c, ContentValuesCallback cb) {
 651             final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
 652             final int intentIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.INTENT);
 653             final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 654             final int iconTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_TYPE);
 655             final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
<abbr title=" 656             final int iconPackageIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_PACKAGE);"> 656             final int iconPackageIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_PACKAGE)🔵</abbr>
<abbr title=" 657             final int iconResourceIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_RESOURCE);"> 657             final int iconResourceIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_RESOURC🔵</abbr>
 658             final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 659             final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 660             final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 661             final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 662             final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 663             final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
<abbr title=" 664             final int displayModeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.DISPLAY_MODE);"> 664             final int displayModeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.DISPLAY_MODE)🔵</abbr>
 665 
 666             ContentValues[] rows = new ContentValues[c.getCount()];
 667             int i = 0;
 668             while (c.moveToNext()) {
 669                 ContentValues values = new ContentValues(c.getColumnCount());
 670                 values.put(LauncherSettings.Favorites._ID, c.getLong(idIndex));
 671                 values.put(LauncherSettings.Favorites.INTENT, c.getString(intentIndex));
 672                 values.put(LauncherSettings.Favorites.TITLE, c.getString(titleIndex));
 673                 values.put(LauncherSettings.Favorites.ICON_TYPE, c.getInt(iconTypeIndex));
 674                 values.put(LauncherSettings.Favorites.ICON, c.getBlob(iconIndex));
 675                 values.put(LauncherSettings.Favorites.ICON_PACKAGE, c.getString(iconPackageIndex));
 676                 values.put(LauncherSettings.Favorites.ICON_RESOURCE, c.getString(iconResourceIndex));
 677                 values.put(LauncherSettings.Favorites.CONTAINER, c.getInt(containerIndex));
 678                 values.put(LauncherSettings.Favorites.ITEM_TYPE, c.getInt(itemTypeIndex));
 679                 values.put(LauncherSettings.Favorites.APPWIDGET_ID, -1);
 680                 values.put(LauncherSettings.Favorites.SCREEN, c.getInt(screenIndex));
 681                 values.put(LauncherSettings.Favorites.CELLX, c.getInt(cellXIndex));
 682                 values.put(LauncherSettings.Favorites.CELLY, c.getInt(cellYIndex));
 683                 values.put(LauncherSettings.Favorites.URI, c.getString(uriIndex));
 684                 values.put(LauncherSettings.Favorites.DISPLAY_MODE, c.getInt(displayModeIndex));
 685                 if (cb != null) {
 686                     cb.onRow(values);
 687                 }
 688                 rows[i++] = values;
 689             }
 690 
 691             int total = 0;
 692             if (i &gt; 0) {
 693                 db.beginTransaction();
 694                 try {
 695                     int numValues = rows.length;
 696                     for (i = 0; i &lt; numValues; i++) {
 697                         if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, rows[i]) &lt; 0) {
 698                             return 0;
 699                         } else {
 700                             total++;
 701                         }
 702                     }
 703                     db.setTransactionSuccessful();
 704                 } finally {
 705                     db.endTransaction();
 706                 }
 707             }
 708 
 709             return total;
 710         }
 711 
 712         @Override
 713         public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 714             if (LOGD) Log.d(TAG, &quot;onUpgrade triggered: &quot; + oldVersion);
 715 
 716             int version = oldVersion;
 717             if (version &lt; 3) {
 718                 // upgrade 1,2 -&gt; 3 added appWidgetId column
 719                 db.beginTransaction();
 720                 try {
 721                     // Insert new column for holding appWidgetIds
 722                     db.execSQL(&quot;ALTER TABLE favorites &quot; +
 723                         &quot;ADD COLUMN appWidgetId INTEGER NOT NULL DEFAULT -1;&quot;);
 724                     db.setTransactionSuccessful();
 725                     version = 3;
 726                 } catch (SQLException ex) {
 727                     // Old version remains, which means we wipe old data
 728                     Log.e(TAG, ex.getMessage(), ex);
 729                 } finally {
 730                     db.endTransaction();
 731                 }
 732 
 733                 // Convert existing widgets only if table upgrade was successful
 734                 if (version == 3) {
 735                     convertWidgets(db);
 736                 }
 737             }
 738 
 739             if (version &lt; 4) {
 740                 version = 4;
 741             }
 742 
 743             // Where&#x27;s version 5?
 744             // - Donut and sholes on 2.0 shipped with version 4 of launcher1.
 745             // - Passion shipped on 2.1 with version 6 of launcher3
 746             // - Sholes shipped on 2.1r1 (aka Mr. 3) with version 5 of launcher 1
 747             //   but version 5 on there was the updateContactsShortcuts change
 748             //   which was version 6 in launcher 2 (first shipped on passion 2.1r1).
 749             // The updateContactsShortcuts change is idempotent, so running it twice
 750             // is okay so we&#x27;ll do that when upgrading the devices that shipped with it.
 751             if (version &lt; 6) {
 752                 // We went from 3 to 5 screens. Move everything 1 to the right
 753                 db.beginTransaction();
 754                 try {
 755                     db.execSQL(&quot;UPDATE favorites SET screen=(screen + 1);&quot;);
 756                     db.setTransactionSuccessful();
 757                 } catch (SQLException ex) {
 758                     // Old version remains, which means we wipe old data
 759                     Log.e(TAG, ex.getMessage(), ex);
 760                 } finally {
 761                     db.endTransaction();
 762                 }
 763 
 764                // We added the fast track.
 765                 if (updateContactsShortcuts(db)) {
 766                     version = 6;
 767                 }
 768             }
 769 
 770             if (version &lt; 7) {
 771                 // Version 7 gets rid of the special search widget.
 772                 convertWidgets(db);
 773                 version = 7;
 774             }
 775 
 776             if (version &lt; 8) {
 777                 // Version 8 (froyo) has the icons all normalized.  This should
 778                 // already be the case in practice, but we now rely on it and don&#x27;t
 779                 // resample the images each time.
 780                 normalizeIcons(db);
 781                 version = 8;
 782             }
 783 
 784             if (version &lt; 9) {
 785                 // The max id is not yet set at this point (onUpgrade is triggered in the ctor
 786                 // before it gets a change to get set, so we need to read it here when we use it)
 787                 if (mMaxItemId == -1) {
 788                     mMaxItemId = initializeMaxItemId(db);
 789                 }
 790 
 791                 // Add default hotseat icons
 792                 loadFavorites(db, new SimpleWorkspaceLoader(this, mContext.getResources(),
 793                         R.xml.update_workspace));
 794                 version = 9;
 795             }
 796 
 797             // We bumped the version three time during JB, once to update the launch flags, once to
 798             // update the override for the default launch animation and once to set the mimetype
 799             // to improve startup performance
 800             if (version &lt; 12) {
 801                 // Contact shortcuts need a different set of flags to be launched now
 802                 // The updateContactsShortcuts change is idempotent, so we can keep using it like
 803                 // back in the Donut days
 804                 updateContactsShortcuts(db);
 805                 version = 12;
 806             }
 807 
 808             if (version &lt; 13) {
 809                 // With the new shrink-wrapped and re-orderable workspaces, it makes sense
 810                 // to persist workspace screens and their relative order.
 811                 mMaxScreenId = 0;
 812 
 813                 // This will never happen in the wild, but when we switch to using workspace
 814                 // screen ids, redo the import from old launcher.
 815                 sJustLoadedFromOldDb = true;
 816 
 817                 addWorkspacesTable(db);
 818                 version = 13;
 819             }
 820 
 821             if (version &lt; 14) {
 822                 db.beginTransaction();
 823                 try {
 824                     // Insert new column for holding widget provider name
 825                     db.execSQL(&quot;ALTER TABLE favorites &quot; +
 826                             &quot;ADD COLUMN appWidgetProvider TEXT;&quot;);
 827                     db.setTransactionSuccessful();
 828                     version = 14;
 829                 } catch (SQLException ex) {
 830                     // Old version remains, which means we wipe old data
 831                     Log.e(TAG, ex.getMessage(), ex);
 832                 } finally {
 833                     db.endTransaction();
 834                 }
 835             }
 836 
 837             if (version &lt; 15) {
 838                 db.beginTransaction();
 839                 try {
 840                     // Insert new column for holding update timestamp
 841                     db.execSQL(&quot;ALTER TABLE favorites &quot; +
 842                             &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;&quot;);
 843                     db.execSQL(&quot;ALTER TABLE workspaceScreens &quot; +
 844                             &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;&quot;);
 845                     db.setTransactionSuccessful();
 846                     version = 15;
 847                 } catch (SQLException ex) {
 848                     // Old version remains, which means we wipe old data
 849                     Log.e(TAG, ex.getMessage(), ex);
 850                 } finally {
 851                     db.endTransaction();
 852                 }
 853             }
 854 
 855 
 856             if (version &lt; 16) {
 857                 db.beginTransaction();
 858                 try {
 859                     // Insert new column for holding restore status
 860                     db.execSQL(&quot;ALTER TABLE favorites &quot; +
 861                             &quot;ADD COLUMN restored INTEGER NOT NULL DEFAULT 0;&quot;);
 862                     db.setTransactionSuccessful();
 863                     version = 16;
 864                 } catch (SQLException ex) {
 865                     // Old version remains, which means we wipe old data
 866                     Log.e(TAG, ex.getMessage(), ex);
 867                 } finally {
 868                     db.endTransaction();
 869                 }
 870             }
 871 
 872             if (version &lt; 17) {
 873                 // We use the db version upgrade here to identify users who may not have seen
 874                 // clings yet (because they weren&#x27;t available), but for whom the clings are now
 875                 // available (tablet users). Because one of the possible cling flows (migration)
 876                 // is very destructive (wipes out workspaces), we want to prevent this from showing
 877                 // until clear data. We do so by marking that the clings have been shown.
 878                 LauncherClings.synchonouslyMarkFirstRunClingDismissed(mContext);
 879                 version = 17;
 880             }
 881 
 882             if (version &lt; 18) {
 883                 // No-op
 884                 version = 18;
 885             }
 886 
 887             if (version &lt; 19) {
 888                 // Due to a data loss bug, some users may have items associated with screen ids
 889                 // which no longer exist. Since this can cause other problems, and since the user
 890                 // will never see these items anyway, we use database upgrade as an opportunity to
 891                 // clean things up.
 892                 removeOrphanedItems(db);
 893                 version = 19;
 894             }
 895 
 896             if (version &lt; 20) {
 897                 // Add userId column
 898                 if (addProfileColumn(db)) {
 899                     version = 20;
 900                 }
 901                 // else old version remains, which means we wipe old data
 902             }
 903 
 904             if (version != DATABASE_VERSION) {
 905                 Log.w(TAG, &quot;Destroying all old data.&quot;);
 906                 db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_FAVORITES);
 907                 db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_WORKSPACE_SCREENS);
 908 
 909                 onCreate(db);
 910             }
 911         }
 912 
 913         @Override
 914         public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 915             // This shouldn&#x27;t happen -- throw our hands up in the air and start over.
 916             Log.w(TAG, &quot;Database version downgrade from: &quot; + oldVersion + &quot; to &quot; + newVersion +
 917                     &quot;. Wiping databse.&quot;);
 918             createEmptyDB(db);
 919         }
 920 
 921 
 922         /**
 923          * Clears all the data for a fresh start.
 924          */
 925         public void createEmptyDB(SQLiteDatabase db) {
 926             db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_FAVORITES);
 927             db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_WORKSPACE_SCREENS);
 928             onCreate(db);
 929         }
 930 
 931         private boolean addProfileColumn(SQLiteDatabase db) {
 932             db.beginTransaction();
 933             try {
 934                 UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 935                 // Default to the serial number of this user, for older
 936                 // shortcuts.
 937                 long userSerialNumber = userManager.getSerialNumberForUser(
 938                         UserHandleCompat.myUserHandle());
 939                 // Insert new column for holding user serial number
 940                 db.execSQL(&quot;ALTER TABLE favorites &quot; +
 941                         &quot;ADD COLUMN profileId INTEGER DEFAULT &quot;
 942                                         + userSerialNumber + &quot;;&quot;);
 943                 db.setTransactionSuccessful();
 944             } catch (SQLException ex) {
 945                 // Old version remains, which means we wipe old data
 946                 Log.e(TAG, ex.getMessage(), ex);
 947                 return false;
 948             } finally {
 949                 db.endTransaction();
 950             }
 951             return true;
 952         }
 953 
 954         private boolean updateContactsShortcuts(SQLiteDatabase db) {
 955             final String selectWhere = buildOrWhereString(Favorites.ITEM_TYPE,
 956                     new int[] { Favorites.ITEM_TYPE_SHORTCUT });
 957 
 958             Cursor c = null;
 959             final String actionQuickContact = &quot;com.android.contacts.action.QUICK_CONTACT&quot;;
 960             db.beginTransaction();
 961             try {
 962                 // Select and iterate through each matching widget
 963                 c = db.query(TABLE_FAVORITES,
 964                         new String[] { Favorites._ID, Favorites.INTENT },
 965                         selectWhere, null, null, null, null);
 966                 if (c == null) return false;
 967 
 968                 if (LOGD) Log.d(TAG, &quot;found upgrade cursor count=&quot; + c.getCount());
 969 
 970                 final int idIndex = c.getColumnIndex(Favorites._ID);
 971                 final int intentIndex = c.getColumnIndex(Favorites.INTENT);
 972 
 973                 while (c.moveToNext()) {
 974                     long favoriteId = c.getLong(idIndex);
 975                     final String intentUri = c.getString(intentIndex);
 976                     if (intentUri != null) {
 977                         try {
 978                             final Intent intent = Intent.parseUri(intentUri, 0);
 979                             android.util.Log.d(&quot;Home&quot;, intent.toString());
 980                             final Uri uri = intent.getData();
 981                             if (uri != null) {
 982                                 final String data = uri.toString();
 983                                 if ((Intent.ACTION_VIEW.equals(intent.getAction()) ||
 984                                         actionQuickContact.equals(intent.getAction())) &amp;&amp;
 985                                         (data.startsWith(&quot;content://contacts/people/&quot;) ||
 986                                         data.startsWith(&quot;content://com.android.contacts/&quot; +
 987                                                 &quot;contacts/lookup/&quot;))) {
 988 
 989                                     final Intent newIntent = new Intent(actionQuickContact);
 990                                     // When starting from the launcher, start in a new, cleared task
 991                                     // CLEAR_WHEN_TASK_RESET cannot reset the root of a task, so we
 992                                     // clear the whole thing preemptively here since
 993                                     // QuickContactActivity will finish itself when launching other
 994                                     // detail activities.
 995                                     newIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
 996                                             Intent.FLAG_ACTIVITY_CLEAR_TASK);
 997                                     newIntent.putExtra(
 998                                             Launcher.INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION, true);
 999                                     newIntent.setData(uri);
1000                                     // Determine the type and also put that in the shortcut
1001                                     // (that can speed up launch a bit)
1002                                     newIntent.setDataAndType(uri, newIntent.resolveType(mContext));
1003 
1004                                     final ContentValues values = new ContentValues();
1005                                     values.put(LauncherSettings.Favorites.INTENT,
1006                                             newIntent.toUri(0));
1007 
1008                                     String updateWhere = Favorites._ID + &quot;=&quot; + favoriteId;
1009                                     db.update(TABLE_FAVORITES, values, updateWhere, null);
1010                                 }
1011                             }
1012                         } catch (RuntimeException ex) {
1013                             Log.e(TAG, &quot;Problem upgrading shortcut&quot;, ex);
1014                         } catch (URISyntaxException e) {
1015                             Log.e(TAG, &quot;Problem upgrading shortcut&quot;, e);
1016                         }
1017                     }
1018                 }
1019 
1020                 db.setTransactionSuccessful();
1021             } catch (SQLException ex) {
1022                 Log.w(TAG, &quot;Problem while upgrading contacts&quot;, ex);
1023                 return false;
1024             } finally {
1025                 db.endTransaction();
1026                 if (c != null) {
1027                     c.close();
1028                 }
1029             }
1030 
1031             return true;
1032         }
1033 
1034         private void normalizeIcons(SQLiteDatabase db) {
1035             Log.d(TAG, &quot;normalizing icons&quot;);
1036 
1037             db.beginTransaction();
1038             Cursor c = null;
1039             SQLiteStatement update = null;
1040             try {
1041                 boolean logged = false;
1042                 update = db.compileStatement(&quot;UPDATE favorites &quot;
1043                         + &quot;SET icon=? WHERE _id=?&quot;);
1044 
1045                 c = db.rawQuery(&quot;SELECT _id, icon FROM favorites WHERE iconType=&quot; +
1046                         Favorites.ICON_TYPE_BITMAP, null);
1047 
1048                 final int idIndex = c.getColumnIndexOrThrow(Favorites._ID);
1049                 final int iconIndex = c.getColumnIndexOrThrow(Favorites.ICON);
1050 
1051                 while (c.moveToNext()) {
1052                     long id = c.getLong(idIndex);
1053                     byte[] data = c.getBlob(iconIndex);
1054                     try {
1055                         Bitmap bitmap = Utilities.resampleIconBitmap(
1056                                 BitmapFactory.decodeByteArray(data, 0, data.length),
1057                                 mContext);
1058                         if (bitmap != null) {
1059                             update.bindLong(1, id);
1060                             data = ItemInfo.flattenBitmap(bitmap);
1061                             if (data != null) {
1062                                 update.bindBlob(2, data);
1063                                 update.execute();
1064                             }
1065                             bitmap.recycle();
1066                         }
1067                     } catch (Exception e) {
1068                         if (!logged) {
1069                             Log.e(TAG, &quot;Failed normalizing icon &quot; + id, e);
1070                         } else {
1071                             Log.e(TAG, &quot;Also failed normalizing icon &quot; + id);
1072                         }
1073                         logged = true;
1074                     }
1075                 }
1076                 db.setTransactionSuccessful();
1077             } catch (SQLException ex) {
1078                 Log.w(TAG, &quot;Problem while allocating appWidgetIds for existing widgets&quot;, ex);
1079             } finally {
1080                 db.endTransaction();
1081                 if (update != null) {
1082                     update.close();
1083                 }
1084                 if (c != null) {
1085                     c.close();
1086                 }
1087             }
1088         }
1089 
1090         // Generates a new ID to use for an object in your database. This method should be only
1091         // called from the main UI thread. As an exception, we do call it when we call the
1092         // constructor from the worker thread; however, this doesn&#x27;t extend until after the
1093         // constructor is called, and we only pass a reference to LauncherProvider to LauncherApp
1094         // after that point
1095         @Override
1096         public long generateNewItemId() {
1097             if (mMaxItemId &lt; 0) {
1098                 throw new RuntimeException(&quot;Error: max item id was not initialized&quot;);
1099             }
1100             mMaxItemId += 1;
1101             return mMaxItemId;
1102         }
1103 
1104         @Override
1105         public long insertAndCheck(SQLiteDatabase db, ContentValues values) {
1106             return dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values);
1107         }
1108 
1109         public void updateMaxItemId(long id) {
1110             mMaxItemId = id + 1;
1111         }
1112 
1113         public void checkId(String table, ContentValues values) {
1114             long id = values.getAsLong(LauncherSettings.BaseLauncherColumns._ID);
1115             if (table == LauncherProvider.TABLE_WORKSPACE_SCREENS) {
1116                 mMaxScreenId = Math.max(id, mMaxScreenId);
1117             }  else {
1118                 mMaxItemId = Math.max(id, mMaxItemId);
1119             }
1120         }
1121 
1122         private long initializeMaxItemId(SQLiteDatabase db) {
1123             Cursor c = db.rawQuery(&quot;SELECT MAX(_id) FROM favorites&quot;, null);
1124 
1125             // get the result
1126             final int maxIdIndex = 0;
1127             long id = -1;
1128             if (c != null &amp;&amp; c.moveToNext()) {
1129                 id = c.getLong(maxIdIndex);
1130             }
1131             if (c != null) {
1132                 c.close();
1133             }
1134 
1135             if (id == -1) {
1136                 throw new RuntimeException(&quot;Error: could not query max item id&quot;);
1137             }
1138 
1139             return id;
1140         }
1141 
1142         // Generates a new ID to use for an workspace screen in your database. This method
1143         // should be only called from the main UI thread. As an exception, we do call it when we
1144         // call the constructor from the worker thread; however, this doesn&#x27;t extend until after the
1145         // constructor is called, and we only pass a reference to LauncherProvider to LauncherApp
1146         // after that point
1147         public long generateNewScreenId() {
1148             if (mMaxScreenId &lt; 0) {
1149                 throw new RuntimeException(&quot;Error: max screen id was not initialized&quot;);
1150             }
1151             mMaxScreenId += 1;
1152             // Log to disk
1153             Launcher.addDumpLog(TAG, &quot;11683562 - generateNewScreenId(): &quot; + mMaxScreenId, true);
1154             return mMaxScreenId;
1155         }
1156 
1157         public void updateMaxScreenId(long maxScreenId) {
1158             // Log to disk
1159             Launcher.addDumpLog(TAG, &quot;11683562 - updateMaxScreenId(): &quot; + maxScreenId, true);
1160             mMaxScreenId = maxScreenId;
1161         }
1162 
1163         private long initializeMaxScreenId(SQLiteDatabase db) {
<abbr title="1164             Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens._ID + &quot;) FROM &quot; + TABLE_WORKSPACE_SCREENS, null);">1164             Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens._ID + &quot;) FROM &quot; + TA🔵</abbr>
1165 
1166             // get the result
1167             final int maxIdIndex = 0;
1168             long id = -1;
1169             if (c != null &amp;&amp; c.moveToNext()) {
1170                 id = c.getLong(maxIdIndex);
1171             }
1172             if (c != null) {
1173                 c.close();
1174             }
1175 
1176             if (id == -1) {
1177                 throw new RuntimeException(&quot;Error: could not query max screen id&quot;);
1178             }
1179 
1180             // Log to disk
1181             Launcher.addDumpLog(TAG, &quot;11683562 - initializeMaxScreenId(): &quot; + id, true);
1182             return id;
1183         }
1184 
1185         /**
1186          * Upgrade existing clock and photo frame widgets into their new widget
1187          * equivalents.
1188          */
1189         private void convertWidgets(SQLiteDatabase db) {
1190             final AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(mContext);
1191             final int[] bindSources = new int[] {
1192                     Favorites.ITEM_TYPE_WIDGET_CLOCK,
1193                     Favorites.ITEM_TYPE_WIDGET_PHOTO_FRAME,
1194                     Favorites.ITEM_TYPE_WIDGET_SEARCH,
1195             };
1196 
1197             final String selectWhere = buildOrWhereString(Favorites.ITEM_TYPE, bindSources);
1198 
1199             Cursor c = null;
1200 
1201             db.beginTransaction();
1202             try {
1203                 // Select and iterate through each matching widget
1204                 c = db.query(TABLE_FAVORITES, new String[] { Favorites._ID, Favorites.ITEM_TYPE },
1205                         selectWhere, null, null, null, null);
1206 
1207                 if (LOGD) Log.d(TAG, &quot;found upgrade cursor count=&quot; + c.getCount());
1208 
1209                 final ContentValues values = new ContentValues();
1210                 while (c != null &amp;&amp; c.moveToNext()) {
1211                     long favoriteId = c.getLong(0);
1212                     int favoriteType = c.getInt(1);
1213 
1214                     // Allocate and update database with new appWidgetId
1215                     try {
1216                         int appWidgetId = mAppWidgetHost.allocateAppWidgetId();
1217 
1218                         if (LOGD) {
1219                             Log.d(TAG, &quot;allocated appWidgetId=&quot; + appWidgetId
1220                                     + &quot; for favoriteId=&quot; + favoriteId);
1221                         }
1222                         values.clear();
1223                         values.put(Favorites.ITEM_TYPE, Favorites.ITEM_TYPE_APPWIDGET);
1224                         values.put(Favorites.APPWIDGET_ID, appWidgetId);
1225 
1226                         // Original widgets might not have valid spans when upgrading
1227                         if (favoriteType == Favorites.ITEM_TYPE_WIDGET_SEARCH) {
1228                             values.put(LauncherSettings.Favorites.SPANX, 4);
1229                             values.put(LauncherSettings.Favorites.SPANY, 1);
1230                         } else {
1231                             values.put(LauncherSettings.Favorites.SPANX, 2);
1232                             values.put(LauncherSettings.Favorites.SPANY, 2);
1233                         }
1234 
1235                         String updateWhere = Favorites._ID + &quot;=&quot; + favoriteId;
1236                         db.update(TABLE_FAVORITES, values, updateWhere, null);
1237 
1238                         if (favoriteType == Favorites.ITEM_TYPE_WIDGET_CLOCK) {
1239                             // TODO: check return value
1240                             appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId,
1241                                     new ComponentName(&quot;com.android.alarmclock&quot;,
1242                                     &quot;com.android.alarmclock.AnalogAppWidgetProvider&quot;));
1243                         } else if (favoriteType == Favorites.ITEM_TYPE_WIDGET_PHOTO_FRAME) {
1244                             // TODO: check return value
1245                             appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId,
1246                                     new ComponentName(&quot;com.android.camera&quot;,
1247                                     &quot;com.android.camera.PhotoAppWidgetProvider&quot;));
1248                         } else if (favoriteType == Favorites.ITEM_TYPE_WIDGET_SEARCH) {
1249                             // TODO: check return value
1250                             appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId,
1251                                     getSearchWidgetProvider());
1252                         }
1253                     } catch (RuntimeException ex) {
1254                         Log.e(TAG, &quot;Problem allocating appWidgetId&quot;, ex);
1255                     }
1256                 }
1257 
1258                 db.setTransactionSuccessful();
1259             } catch (SQLException ex) {
1260                 Log.w(TAG, &quot;Problem while allocating appWidgetIds for existing widgets&quot;, ex);
1261             } finally {
1262                 db.endTransaction();
1263                 if (c != null) {
1264                     c.close();
1265                 }
1266             }
1267 
1268             // Update max item id
1269             mMaxItemId = initializeMaxItemId(db);
1270             if (LOGD) Log.d(TAG, &quot;mMaxItemId: &quot; + mMaxItemId);
1271         }
1272 
1273         private boolean initializeExternalAdd(ContentValues values) {
1274             // 1. Ensure that externally added items have a valid item id
1275             long id = generateNewItemId();
1276             values.put(LauncherSettings.Favorites._ID, id);
1277 
1278             // 2. In the case of an app widget, and if no app widget id is specified, we
1279             // attempt allocate and bind the widget.
1280             Integer itemType = values.getAsInteger(LauncherSettings.Favorites.ITEM_TYPE);
1281             if (itemType != null &amp;&amp;
1282                     itemType.intValue() == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET &amp;&amp;
1283                     !values.containsKey(LauncherSettings.Favorites.APPWIDGET_ID)) {
1284 
1285                 final AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(mContext);
1286                 ComponentName cn = ComponentName.unflattenFromString(
1287                         values.getAsString(Favorites.APPWIDGET_PROVIDER));
1288 
1289                 if (cn != null) {
1290                     try {
1291                         int appWidgetId = mAppWidgetHost.allocateAppWidgetId();
1292                         values.put(LauncherSettings.Favorites.APPWIDGET_ID, appWidgetId);
1293                         if (!appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId,cn)) {
1294                             return false;
1295                         }
1296                     } catch (RuntimeException e) {
1297                         Log.e(TAG, &quot;Failed to initialize external widget&quot;, e);
1298                         return false;
1299                     }
1300                 } else {
1301                     return false;
1302                 }
1303             }
1304 
1305             // Add screen id if not present
1306             long screenId = values.getAsLong(LauncherSettings.Favorites.SCREEN);
1307             if (!addScreenIdIfNecessary(screenId)) {
1308                 return false;
1309             }
1310             return true;
1311         }
1312 
1313         // Returns true of screen id exists, or if successfully added
1314         private boolean addScreenIdIfNecessary(long screenId) {
1315             if (!hasScreenId(screenId)) {
1316                 int rank = getMaxScreenRank() + 1;
1317 
1318                 ContentValues v = new ContentValues();
1319                 v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1320                 v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, rank);
1321                 if (dbInsertAndCheck(this, getWritableDatabase(),
1322                         TABLE_WORKSPACE_SCREENS, null, v) &lt; 0) {
1323                     return false;
1324                 }
1325             }
1326             return true;
1327         }
1328 
1329         private boolean hasScreenId(long screenId) {
1330             SQLiteDatabase db = getWritableDatabase();
1331             Cursor c = db.rawQuery(&quot;SELECT * FROM &quot; + TABLE_WORKSPACE_SCREENS + &quot; WHERE &quot;
1332                     + LauncherSettings.WorkspaceScreens._ID + &quot; = &quot; + screenId, null);
1333             if (c != null) {
1334                 int count = c.getCount();
1335                 c.close();
1336                 return count &gt; 0;
1337             } else {
1338                 return false;
1339             }
1340         }
1341 
1342         private int getMaxScreenRank() {
1343             SQLiteDatabase db = getWritableDatabase();
1344             Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens.SCREEN_RANK
1345                     + &quot;) FROM &quot; + TABLE_WORKSPACE_SCREENS, null);
1346 
1347             // get the result
1348             final int maxRankIndex = 0;
1349             int rank = -1;
1350             if (c != null &amp;&amp; c.moveToNext()) {
1351                 rank = c.getInt(maxRankIndex);
1352             }
1353             if (c != null) {
1354                 c.close();
1355             }
1356 
1357             return rank;
1358         }
1359 
1360         private static final void beginDocument(XmlPullParser parser, String firstElementName)
1361                 throws XmlPullParserException, IOException {
1362             int type;
1363             while ((type = parser.next()) != XmlPullParser.START_TAG
1364                     &amp;&amp; type != XmlPullParser.END_DOCUMENT) {
1365                 ;
1366             }
1367 
1368             if (type != XmlPullParser.START_TAG) {
1369                 throw new XmlPullParserException(&quot;No start tag found&quot;);
1370             }
1371 
1372             if (!parser.getName().equals(firstElementName)) {
1373                 throw new XmlPullParserException(&quot;Unexpected start tag: found &quot; + parser.getName() +
1374                         &quot;, expected &quot; + firstElementName);
1375             }
1376         }
1377 
1378         private static Intent buildMainIntent() {
1379             Intent intent = new Intent(Intent.ACTION_MAIN, null);
1380             intent.addCategory(Intent.CATEGORY_LAUNCHER);
1381             return intent;
1382         }
1383 
1384         private int loadFavorites(SQLiteDatabase db, WorkspaceLoader loader) {
1385             ArrayList&lt;Long&gt; screenIds = new ArrayList&lt;Long&gt;();
1386             // TODO: Use multiple loaders with fall-back and transaction.
1387             int count = loader.loadLayout(db, screenIds);
1388 
1389             // Add the screens specified by the items above
1390             Collections.sort(screenIds);
1391             int rank = 0;
1392             ContentValues values = new ContentValues();
1393             for (Long id : screenIds) {
1394                 values.clear();
1395                 values.put(LauncherSettings.WorkspaceScreens._ID, id);
1396                 values.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, rank);
1397                 if (dbInsertAndCheck(this, db, TABLE_WORKSPACE_SCREENS, null, values) &lt; 0) {
1398                     throw new RuntimeException(&quot;Failed initialize screen table&quot;
1399                             + &quot;from default layout&quot;);
1400                 }
1401                 rank++;
1402             }
1403 
1404             // Ensure that the max ids are initialized
1405             mMaxItemId = initializeMaxItemId(db);
1406             mMaxScreenId = initializeMaxScreenId(db);
1407 
1408             return count;
1409         }
1410 
1411         /**
1412          * Loads the default set of favorite packages from an xml file.
1413          *
1414          * @param db The database to write the values into
1415          * @param filterContainerId The specific container id of items to load
1416          * @param the set of screenIds which are used by the favorites
1417          */
1418         private int loadFavoritesRecursive(SQLiteDatabase db, Resources res, int workspaceResourceId,
1419                 ArrayList&lt;Long&gt; screenIds) {
1420 
1421             ContentValues values = new ContentValues();
<abbr title="1422             if (LOGD) Log.v(TAG, String.format(&quot;Loading favorites from resid=0x%08x&quot;, workspaceResourceId));">1422             if (LOGD) Log.v(TAG, String.format(&quot;Loading favorites from resid=0x%08x&quot;, workspaceResourceId🔵</abbr>
1423 
1424             int count = 0;
1425             try {
1426                 XmlResourceParser parser = res.getXml(workspaceResourceId);
1427                 beginDocument(parser, TAG_FAVORITES);
1428 
1429                 final int depth = parser.getDepth();
1430 
1431                 int type;
1432                 while (((type = parser.next()) != XmlPullParser.END_TAG ||
1433                         parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {
1434 
1435                     if (type != XmlPullParser.START_TAG) {
1436                         continue;
1437                     }
1438 
1439                     boolean added = false;
1440                     final String name = parser.getName();
1441 
1442                     if (TAG_INCLUDE.equals(name)) {
1443 
1444                         final int resId = getAttributeResourceValue(parser, ATTR_WORKSPACE, 0);
1445 
<abbr title="1446                         if (LOGD) Log.v(TAG, String.format((&quot;%&quot; + (2*(depth+1)) + &quot;s&lt;include workspace=%08x&gt;&quot;),">1446                         if (LOGD) Log.v(TAG, String.format((&quot;%&quot; + (2*(depth+1)) + &quot;s&lt;include workspace=%0🔵</abbr>
1447                                 &quot;&quot;, resId));
1448 
1449                         if (resId != 0 &amp;&amp; resId != workspaceResourceId) {
1450                             // recursively load some more favorites, why not?
1451                             count += loadFavoritesRecursive(db, res, resId, screenIds);
1452                             added = false;
1453                         } else {
1454                             Log.w(TAG, String.format(&quot;Skipping &lt;include workspace=0x%08x&gt;&quot;, resId));
1455                         }
1456 
1457                         if (LOGD) Log.v(TAG, String.format((&quot;%&quot; + (2*(depth+1)) + &quot;s&lt;/include&gt;&quot;), &quot;&quot;));
1458                         continue;
1459                     }
1460 
1461                     // Assuming it&#x27;s a &lt;favorite&gt; at this point
1462                     long container = LauncherSettings.Favorites.CONTAINER_DESKTOP;
1463                     String strContainer = getAttributeValue(parser, ATTR_CONTAINER);
1464                     if (strContainer != null) {
1465                         container = Long.valueOf(strContainer);
1466                     }
1467 
1468                     String screen = getAttributeValue(parser, ATTR_SCREEN);
1469                     String x = getAttributeValue(parser, ATTR_X);
1470                     String y = getAttributeValue(parser, ATTR_Y);
1471 
1472                     values.clear();
1473                     values.put(LauncherSettings.Favorites.CONTAINER, container);
1474                     values.put(LauncherSettings.Favorites.SCREEN, screen);
1475                     values.put(LauncherSettings.Favorites.CELLX, x);
1476                     values.put(LauncherSettings.Favorites.CELLY, y);
1477 
1478                     if (LOGD) {
1479                         final String title = getAttributeValue(parser, ATTR_TITLE);
1480                         final String pkg = getAttributeValue(parser, ATTR_PACKAGE_NAME);
1481                         final String something = title != null ? title : pkg;
1482                         Log.v(TAG, String.format(
1483                                 (&quot;%&quot; + (2*(depth+1)) + &quot;s&lt;%s%s c=%d s=%s x=%s y=%s&gt;&quot;),
1484                                 &quot;&quot;, name,
1485                                 (something == null ? &quot;&quot; : (&quot; \&quot;&quot; + something + &quot;\&quot;&quot;)),
1486                                 container, screen, x, y));
1487                     }
1488 
1489                     if (TAG_FAVORITE.equals(name)) {
1490                         long id = addAppShortcut(db, values, parser);
1491                         added = id &gt;= 0;
1492                     } else if (TAG_APPWIDGET.equals(name)) {
1493                         added = addAppWidget(parser, type, db, values);
1494                     } else if (TAG_SHORTCUT.equals(name)) {
1495                         long id = addUriShortcut(db, values, res, parser);
1496                         added = id &gt;= 0;
1497                     } else if (TAG_RESOLVE.equals(name)) {
1498                         // This looks through the contained favorites (or meta-favorites) and
1499                         // attempts to add them as shortcuts in the fallback group&#x27;s location
1500                         // until one is added successfully.
1501                         added = false;
1502                         final int groupDepth = parser.getDepth();
1503                         while ((type = parser.next()) != XmlPullParser.END_TAG ||
1504                                 parser.getDepth() &gt; groupDepth) {
1505                             if (type != XmlPullParser.START_TAG) {
1506                                 continue;
1507                             }
1508                             final String fallback_item_name = parser.getName();
1509                             if (!added) {
1510                                 if (TAG_FAVORITE.equals(fallback_item_name)) {
1511                                     final long id = addAppShortcut(db, values, parser);
1512                                     added = id &gt;= 0;
1513                                 } else {
1514                                     Log.e(TAG, &quot;Fallback groups can contain only favorites, found &quot;
1515                                             + fallback_item_name);
1516                                 }
1517                             }
1518                         }
1519                     } else if (TAG_FOLDER.equals(name)) {
1520                         // Folder contents are nested in this XML file
1521                         added = loadFolder(db, values, res, parser);
1522 
1523                     } else if (TAG_PARTNER_FOLDER.equals(name)) {
1524                         // Folder contents come from an external XML resource
1525                         final Partner partner = Partner.get(mPackageManager);
1526                         if (partner != null) {
1527                             final Resources partnerRes = partner.getResources();
1528                             final int resId = partnerRes.getIdentifier(Partner.RES_FOLDER,
1529                                     &quot;xml&quot;, partner.getPackageName());
1530                             if (resId != 0) {
1531                                 final XmlResourceParser partnerParser = partnerRes.getXml(resId);
1532                                 beginDocument(partnerParser, TAG_FOLDER);
1533                                 added = loadFolder(db, values, partnerRes, partnerParser);
1534                             }
1535                         }
1536                     }
1537                     if (added) {
1538                         long screenId = Long.parseLong(screen);
1539                         // Keep track of the set of screens which need to be added to the db.
1540                         if (!screenIds.contains(screenId) &amp;&amp;
1541                                 container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1542                             screenIds.add(screenId);
1543                         }
1544                         count++;
1545                     }
1546                 }
1547             } catch (XmlPullParserException e) {
1548                 Log.w(TAG, &quot;Got exception parsing favorites.&quot;, e);
1549             } catch (IOException e) {
1550                 Log.w(TAG, &quot;Got exception parsing favorites.&quot;, e);
1551             } catch (RuntimeException e) {
1552                 Log.w(TAG, &quot;Got exception parsing favorites.&quot;, e);
1553             }
1554             return count;
1555         }
1556 
1557         /**
1558          * Parse folder items starting at {@link XmlPullParser} location. Allow recursive
1559          * includes of items.
1560          */
1561         private void addToFolder(SQLiteDatabase db, Resources res, XmlResourceParser parser,
1562                 ArrayList&lt;Long&gt; folderItems, long folderId) throws IOException, XmlPullParserException {
1563             int type;
1564             int folderDepth = parser.getDepth();
1565             while ((type = parser.next()) != XmlPullParser.END_TAG ||
1566                     parser.getDepth() &gt; folderDepth) {
1567                 if (type != XmlPullParser.START_TAG) {
1568                     continue;
1569                 }
1570                 final String tag = parser.getName();
1571 
1572                 final ContentValues childValues = new ContentValues();
1573                 childValues.put(LauncherSettings.Favorites.CONTAINER, folderId);
1574 
1575                 if (LOGD) {
1576                     final String pkg = getAttributeValue(parser, ATTR_PACKAGE_NAME);
1577                     final String uri = getAttributeValue(parser, ATTR_URI);
1578                     Log.v(TAG, String.format((&quot;%&quot; + (2*(folderDepth+1)) + &quot;s&lt;%s \&quot;%s\&quot;&gt;&quot;), &quot;&quot;,
1579                             tag, uri != null ? uri : pkg));
1580                 }
1581 
1582                 if (TAG_FAVORITE.equals(tag) &amp;&amp; folderId &gt;= 0) {
1583                     final long id = addAppShortcut(db, childValues, parser);
1584                     if (id &gt;= 0) {
1585                         folderItems.add(id);
1586                     }
1587                 } else if (TAG_SHORTCUT.equals(tag) &amp;&amp; folderId &gt;= 0) {
1588                     final long id = addUriShortcut(db, childValues, res, parser);
1589                     if (id &gt;= 0) {
1590                         folderItems.add(id);
1591                     }
1592                 } else if (TAG_INCLUDE.equals(tag) &amp;&amp; folderId &gt;= 0) {
1593                     addToFolder(db, res, parser, folderItems, folderId);
1594                 } else {
1595                     throw new RuntimeException(&quot;Folders can contain only shortcuts&quot;);
1596                 }
1597             }
1598         }
1599 
1600         /**
1601          * Parse folder starting at current {@link XmlPullParser} location.
1602          */
1603         private boolean loadFolder(SQLiteDatabase db, ContentValues values, Resources res,
1604                 XmlResourceParser parser) throws IOException, XmlPullParserException {
1605             final String title;
1606             final int titleResId = getAttributeResourceValue(parser, ATTR_TITLE, 0);
1607             if (titleResId != 0) {
1608                 title = res.getString(titleResId);
1609             } else {
1610                 title = mContext.getResources().getString(R.string.folder_name);
1611             }
1612 
1613             values.put(LauncherSettings.Favorites.TITLE, title);
1614             long folderId = addFolder(db, values);
1615             boolean added = folderId &gt;= 0;
1616 
1617             ArrayList&lt;Long&gt; folderItems = new ArrayList&lt;Long&gt;();
1618             addToFolder(db, res, parser, folderItems, folderId);
1619 
1620             // We can only have folders with &gt;= 2 items, so we need to remove the
1621             // folder and clean up if less than 2 items were included, or some
1622             // failed to add, and less than 2 were actually added
1623             if (folderItems.size() &lt; 2 &amp;&amp; folderId &gt;= 0) {
1624                 // Delete the folder
1625                 deleteId(db, folderId);
1626 
1627                 // If we have a single item, promote it to where the folder
1628                 // would have been.
1629                 if (folderItems.size() == 1) {
1630                     final ContentValues childValues = new ContentValues();
1631                     copyInteger(values, childValues, LauncherSettings.Favorites.CONTAINER);
1632                     copyInteger(values, childValues, LauncherSettings.Favorites.SCREEN);
1633                     copyInteger(values, childValues, LauncherSettings.Favorites.CELLX);
1634                     copyInteger(values, childValues, LauncherSettings.Favorites.CELLY);
1635 
1636                     final long id = folderItems.get(0);
1637                     db.update(TABLE_FAVORITES, childValues,
1638                             LauncherSettings.Favorites._ID + &quot;=&quot; + id, null);
1639                 } else {
1640                     added = false;
1641                 }
1642             }
1643             return added;
1644         }
1645 
1646         // A meta shortcut attempts to resolve an intent specified as a URI in the XML, if a
1647         // logical choice for what shortcut should be used for that intent exists, then it is
1648         // added. Otherwise add nothing.
1649         private long addAppShortcutByUri(SQLiteDatabase db, ContentValues values,
1650                 String intentUri) {
1651             Intent metaIntent;
1652             try {
1653                 metaIntent = Intent.parseUri(intentUri, 0);
1654             } catch (URISyntaxException e) {
1655                 Log.e(TAG, &quot;Unable to add meta-favorite: &quot; + intentUri, e);
1656                 return -1;
1657             }
1658 
1659             ResolveInfo resolved = mPackageManager.resolveActivity(metaIntent,
1660                     PackageManager.MATCH_DEFAULT_ONLY);
1661             final List&lt;ResolveInfo&gt; appList = mPackageManager.queryIntentActivities(
1662                     metaIntent, PackageManager.MATCH_DEFAULT_ONLY);
1663 
1664             // Verify that the result is an app and not just the resolver dialog asking which
1665             // app to use.
1666             if (wouldLaunchResolverActivity(resolved, appList)) {
1667                 // If only one of the results is a system app then choose that as the default.
1668                 final ResolveInfo systemApp = getSingleSystemActivity(appList);
1669                 if (systemApp == null) {
1670                     // There is no logical choice for this meta-favorite, so rather than making
1671                     // a bad choice just add nothing.
1672                     Log.w(TAG, &quot;No preference or single system activity found for &quot;
1673                             + metaIntent.toString());
1674                     return -1;
1675                 }
1676                 resolved = systemApp;
1677             }
1678             final ActivityInfo info = resolved.activityInfo;
1679             final Intent intent = mPackageManager.getLaunchIntentForPackage(info.packageName);
1680             if (intent == null) {
1681                 return -1;
1682             }
1683             intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
1684                     Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
1685 
1686             return addAppShortcut(db, values, info.loadLabel(mPackageManager).toString(), intent);
1687         }
1688 
1689         private ResolveInfo getSingleSystemActivity(List&lt;ResolveInfo&gt; appList) {
1690             ResolveInfo systemResolve = null;
1691             final int N = appList.size();
1692             for (int i = 0; i &lt; N; ++i) {
1693                 try {
1694                     ApplicationInfo info = mPackageManager.getApplicationInfo(
1695                             appList.get(i).activityInfo.packageName, 0);
1696                     if ((info.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) {
1697                         if (systemResolve != null) {
1698                             return null;
1699                         } else {
1700                             systemResolve = appList.get(i);
1701                         }
1702                     }
1703                 } catch (PackageManager.NameNotFoundException e) {
1704                     Log.w(TAG, &quot;Unable to get info about resolve results&quot;, e);
1705                     return null;
1706                 }
1707             }
1708             return systemResolve;
1709         }
1710 
1711         private boolean wouldLaunchResolverActivity(ResolveInfo resolved,
1712                 List&lt;ResolveInfo&gt; appList) {
1713             // If the list contains the above resolved activity, then it can&#x27;t be
1714             // ResolverActivity itself.
1715             for (int i = 0; i &lt; appList.size(); ++i) {
1716                 ResolveInfo tmp = appList.get(i);
1717                 if (tmp.activityInfo.name.equals(resolved.activityInfo.name)
1718                         &amp;&amp; tmp.activityInfo.packageName.equals(resolved.activityInfo.packageName)) {
1719                     return false;
1720                 }
1721             }
1722             return true;
1723         }
1724 
1725         private long addAppShortcut(SQLiteDatabase db, ContentValues values,
1726                 XmlResourceParser parser) {
1727             final String packageName = getAttributeValue(parser, ATTR_PACKAGE_NAME);
1728             final String className = getAttributeValue(parser, ATTR_CLASS_NAME);
1729             final String uri = getAttributeValue(parser, ATTR_URI);
1730 
1731             if (!TextUtils.isEmpty(packageName) &amp;&amp; !TextUtils.isEmpty(className)) {
1732                 ActivityInfo info;
1733                 try {
1734                     ComponentName cn;
1735                     try {
1736                         cn = new ComponentName(packageName, className);
1737                         info = mPackageManager.getActivityInfo(cn, 0);
1738                     } catch (PackageManager.NameNotFoundException nnfe) {
1739                         String[] packages = mPackageManager.currentToCanonicalPackageNames(
1740                                 new String[] { packageName });
1741                         cn = new ComponentName(packages[0], className);
1742                         info = mPackageManager.getActivityInfo(cn, 0);
1743                     }
1744                     final Intent intent = buildMainIntent();
1745                     intent.setComponent(cn);
1746                     intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
1747                             Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
1748 
1749                     return addAppShortcut(db, values, info.loadLabel(mPackageManager).toString(),
1750                             intent);
1751                 } catch (PackageManager.NameNotFoundException e) {
1752                     Log.w(TAG, &quot;Unable to add favorite: &quot; + packageName +
1753                             &quot;/&quot; + className, e);
1754                 }
1755                 return -1;
1756             } else if (!TextUtils.isEmpty(uri)) {
1757                 // If no component specified try to find a shortcut to add from the URI.
1758                 return addAppShortcutByUri(db, values, uri);
1759             } else {
1760                 Log.e(TAG, &quot;Skipping invalid &lt;favorite&gt; with no component or uri&quot;);
1761                 return -1;
1762             }
1763         }
1764 
1765         private long addAppShortcut(SQLiteDatabase db, ContentValues values, String title,
1766                 Intent intent) {
1767             long id = generateNewItemId();
1768             values.put(Favorites.INTENT, intent.toUri(0));
1769             values.put(Favorites.TITLE, title);
1770             values.put(Favorites.ITEM_TYPE, Favorites.ITEM_TYPE_APPLICATION);
1771             values.put(Favorites.SPANX, 1);
1772             values.put(Favorites.SPANY, 1);
1773             values.put(Favorites._ID, id);
1774             if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values) &lt; 0) {
1775                 return -1;
1776             } else {
1777                 return id;
1778             }
1779         }
1780 
1781         private long addFolder(SQLiteDatabase db, ContentValues values) {
1782             values.put(Favorites.ITEM_TYPE, Favorites.ITEM_TYPE_FOLDER);
1783             values.put(Favorites.SPANX, 1);
1784             values.put(Favorites.SPANY, 1);
1785             long id = generateNewItemId();
1786             values.put(Favorites._ID, id);
1787             if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values) &lt;= 0) {
1788                 return -1;
1789             } else {
1790                 return id;
1791             }
1792         }
1793 
1794         private ComponentName getSearchWidgetProvider() {
1795             SearchManager searchManager =
1796                     (SearchManager) mContext.getSystemService(Context.SEARCH_SERVICE);
1797             ComponentName searchComponent = searchManager.getGlobalSearchActivity();
1798             if (searchComponent == null) return null;
1799             return getProviderInPackage(searchComponent.getPackageName());
1800         }
1801 
1802         /**
1803          * Gets an appwidget provider from the given package. If the package contains more than
1804          * one appwidget provider, an arbitrary one is returned.
1805          */
1806         private ComponentName getProviderInPackage(String packageName) {
1807             AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(mContext);
1808             List&lt;AppWidgetProviderInfo&gt; providers = appWidgetManager.getInstalledProviders();
1809             if (providers == null) return null;
1810             final int providerCount = providers.size();
1811             for (int i = 0; i &lt; providerCount; i++) {
1812                 ComponentName provider = providers.get(i).provider;
1813                 if (provider != null &amp;&amp; provider.getPackageName().equals(packageName)) {
1814                     return provider;
1815                 }
1816             }
1817             return null;
1818         }
1819 
1820         private boolean addAppWidget(XmlResourceParser parser, int type,
1821                 SQLiteDatabase db, ContentValues values)
1822                 throws XmlPullParserException, IOException {
1823 
1824             String packageName = getAttributeValue(parser, ATTR_PACKAGE_NAME);
1825             String className = getAttributeValue(parser, ATTR_CLASS_NAME);
1826 
1827             if (packageName == null || className == null) {
1828                 return false;
1829             }
1830 
1831             boolean hasPackage = true;
1832             ComponentName cn = new ComponentName(packageName, className);
1833             try {
1834                 mPackageManager.getReceiverInfo(cn, 0);
1835             } catch (Exception e) {
1836                 String[] packages = mPackageManager.currentToCanonicalPackageNames(
1837                         new String[] { packageName });
1838                 cn = new ComponentName(packages[0], className);
1839                 try {
1840                     mPackageManager.getReceiverInfo(cn, 0);
1841                 } catch (Exception e1) {
1842                     System.out.println(&quot;Can&#x27;t find widget provider: &quot; + className);
1843                     hasPackage = false;
1844                 }
1845             }
1846 
1847             if (hasPackage) {
1848                 String spanX = getAttributeValue(parser, ATTR_SPAN_X);
1849                 String spanY = getAttributeValue(parser, ATTR_SPAN_Y);
1850 
1851                 values.put(Favorites.SPANX, spanX);
1852                 values.put(Favorites.SPANY, spanY);
1853 
1854                 // Read the extras
1855                 Bundle extras = new Bundle();
1856                 int widgetDepth = parser.getDepth();
1857                 while ((type = parser.next()) != XmlPullParser.END_TAG ||
1858                         parser.getDepth() &gt; widgetDepth) {
1859                     if (type != XmlPullParser.START_TAG) {
1860                         continue;
1861                     }
1862 
1863                     if (TAG_EXTRA.equals(parser.getName())) {
1864                         String key = getAttributeValue(parser, ATTR_KEY);
1865                         String value = getAttributeValue(parser, ATTR_VALUE);
1866                         if (key != null &amp;&amp; value != null) {
1867                             extras.putString(key, value);
1868                         } else {
1869                             throw new RuntimeException(&quot;Widget extras must have a key and value&quot;);
1870                         }
1871                     } else {
1872                         throw new RuntimeException(&quot;Widgets can contain only extras&quot;);
1873                     }
1874                 }
1875 
1876                 return addAppWidget(db, values, cn, extras);
1877             }
1878 
1879             return false;
1880         }
1881 
1882         private boolean addAppWidget(SQLiteDatabase db, ContentValues values, ComponentName cn,
1883                Bundle extras) {
1884             boolean allocatedAppWidgets = false;
1885             final AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(mContext);
1886 
1887             try {
1888                 int appWidgetId = mAppWidgetHost.allocateAppWidgetId();
1889 
1890                 values.put(Favorites.ITEM_TYPE, Favorites.ITEM_TYPE_APPWIDGET);
1891                 values.put(Favorites.APPWIDGET_ID, appWidgetId);
1892                 values.put(Favorites.APPWIDGET_PROVIDER, cn.flattenToString());
1893                 values.put(Favorites._ID, generateNewItemId());
1894                 dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values);
1895 
1896                 allocatedAppWidgets = true;
1897 
1898                 // TODO: need to check return value
1899                 appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId, cn);
1900 
1901                 // Send a broadcast to configure the widget
1902                 if (extras != null &amp;&amp; !extras.isEmpty()) {
1903                     Intent intent = new Intent(ACTION_APPWIDGET_DEFAULT_WORKSPACE_CONFIGURE);
1904                     intent.setComponent(cn);
1905                     intent.putExtras(extras);
1906                     intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);
1907                     mContext.sendBroadcast(intent);
1908                 }
1909             } catch (RuntimeException ex) {
1910                 Log.e(TAG, &quot;Problem allocating appWidgetId&quot;, ex);
1911             }
1912 
1913             return allocatedAppWidgets;
1914         }
1915 
1916         private long addUriShortcut(SQLiteDatabase db, ContentValues values, Resources res,
1917                 XmlResourceParser parser) {
1918             final int iconResId = getAttributeResourceValue(parser, ATTR_ICON, 0);
1919             final int titleResId = getAttributeResourceValue(parser, ATTR_TITLE, 0);
1920 
1921             Intent intent;
1922             String uri = null;
1923             try {
1924                 uri = getAttributeValue(parser, ATTR_URI);
1925                 intent = Intent.parseUri(uri, 0);
1926             } catch (URISyntaxException e) {
1927                 Log.w(TAG, &quot;Shortcut has malformed uri: &quot; + uri);
1928                 return -1; // Oh well
1929             }
1930 
1931             if (iconResId == 0 || titleResId == 0) {
1932                 Log.w(TAG, &quot;Shortcut is missing title or icon resource ID&quot;);
1933                 return -1;
1934             }
1935 
1936             long id = generateNewItemId();
1937             intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
1938             values.put(Favorites.INTENT, intent.toUri(0));
1939             values.put(Favorites.TITLE, res.getString(titleResId));
1940             values.put(Favorites.ITEM_TYPE, Favorites.ITEM_TYPE_SHORTCUT);
1941             values.put(Favorites.SPANX, 1);
1942             values.put(Favorites.SPANY, 1);
1943             values.put(Favorites.ICON_TYPE, Favorites.ICON_TYPE_RESOURCE);
1944             values.put(Favorites.ICON_PACKAGE, res.getResourcePackageName(iconResId));
1945             values.put(Favorites.ICON_RESOURCE, res.getResourceName(iconResId));
1946             values.put(Favorites._ID, id);
1947 
1948             if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values) &lt; 0) {
1949                 return -1;
1950             }
1951             return id;
1952         }
1953 
1954         private void migrateLauncher2Shortcuts(SQLiteDatabase db, Uri uri) {
1955             final ContentResolver resolver = mContext.getContentResolver();
1956             Cursor c = null;
1957             int count = 0;
1958             int curScreen = 0;
1959 
1960             try {
1961                 c = resolver.query(uri, null, null, null, &quot;title ASC&quot;);
1962             } catch (Exception e) {
1963                 // Ignore
1964             }
1965 
1966             // We already have a favorites database in the old provider
1967             if (c != null) {
1968                 try {
1969                     if (c.getCount() &gt; 0) {
1970                         final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1971                         final int intentIndex
1972                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.INTENT);
1973                         final int titleIndex
1974                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
1975                         final int iconTypeIndex
1976                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_TYPE);
1977                         final int iconIndex
1978                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
1979                         final int iconPackageIndex
1980                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_PACKAGE);
1981                         final int iconResourceIndex
1982                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_RESOURCE);
1983                         final int containerIndex
1984                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
1985                         final int itemTypeIndex
1986                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
1987                         final int screenIndex
1988                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
1989                         final int cellXIndex
1990                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
1991                         final int cellYIndex
1992                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
1993                         final int uriIndex
1994                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1995                         final int displayModeIndex
1996                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.DISPLAY_MODE);
1997                         final int profileIndex
1998                                 = c.getColumnIndex(LauncherSettings.Favorites.PROFILE_ID);
1999 
2000                         int i = 0;
2001                         int curX = 0;
2002                         int curY = 0;
2003 
2004                         final LauncherAppState app = LauncherAppState.getInstance();
2005                         final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2006                         final int width = (int) grid.numColumns;
2007                         final int height = (int) grid.numRows;
2008                         final int hotseatWidth = (int) grid.numHotseatIcons;
2009 
2010                         final HashSet&lt;String&gt; seenIntents = new HashSet&lt;String&gt;(c.getCount());
2011 
2012                         final ArrayList&lt;ContentValues&gt; shortcuts = new ArrayList&lt;ContentValues&gt;();
2013                         final ArrayList&lt;ContentValues&gt; folders = new ArrayList&lt;ContentValues&gt;();
2014                         final SparseArray&lt;ContentValues&gt; hotseat = new SparseArray&lt;ContentValues&gt;();
2015 
2016                         while (c.moveToNext()) {
2017                             final int itemType = c.getInt(itemTypeIndex);
2018                             if (itemType != Favorites.ITEM_TYPE_APPLICATION
2019                                     &amp;&amp; itemType != Favorites.ITEM_TYPE_SHORTCUT
2020                                     &amp;&amp; itemType != Favorites.ITEM_TYPE_FOLDER) {
2021                                 continue;
2022                             }
2023 
2024                             final int cellX = c.getInt(cellXIndex);
2025                             final int cellY = c.getInt(cellYIndex);
2026                             final int screen = c.getInt(screenIndex);
2027                             int container = c.getInt(containerIndex);
2028                             final String intentStr = c.getString(intentIndex);
2029 
2030                             UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
2031                             UserHandleCompat userHandle;
2032                             final long userSerialNumber;
2033                             if (profileIndex != -1 &amp;&amp; !c.isNull(profileIndex)) {
2034                                 userSerialNumber = c.getInt(profileIndex);
2035                                 userHandle = userManager.getUserForSerialNumber(userSerialNumber);
2036                             } else {
2037                                 // Default to the serial number of this user, for older
2038                                 // shortcuts.
2039                                 userHandle = UserHandleCompat.myUserHandle();
2040                                 userSerialNumber = userManager.getSerialNumberForUser(userHandle);
2041                             }
2042                             Launcher.addDumpLog(TAG, &quot;migrating \&quot;&quot;
2043                                 + c.getString(titleIndex) + &quot;\&quot; (&quot;
2044                                 + cellX + &quot;,&quot; + cellY + &quot;@&quot;
2045                                 + LauncherSettings.Favorites.containerToString(container)
2046                                 + &quot;/&quot; + screen
2047                                 + &quot;): &quot; + intentStr, true);
2048 
2049                             if (itemType != Favorites.ITEM_TYPE_FOLDER) {
2050 
2051                                 final Intent intent;
2052                                 final ComponentName cn;
2053                                 try {
2054                                     intent = Intent.parseUri(intentStr, 0);
2055                                 } catch (URISyntaxException e) {
2056                                     // bogus intent?
2057                                     Launcher.addDumpLog(TAG,
2058                                             &quot;skipping invalid intent uri&quot;, true);
2059                                     continue;
2060                                 }
2061 
2062                                 cn = intent.getComponent();
2063                                 if (TextUtils.isEmpty(intentStr)) {
2064                                     // no intent? no icon
2065                                     Launcher.addDumpLog(TAG, &quot;skipping empty intent&quot;, true);
2066                                     continue;
2067                                 } else if (cn != null &amp;&amp;
2068                                         !LauncherModel.isValidPackageActivity(mContext, cn,
2069                                                 userHandle)) {
2070                                     // component no longer exists.
2071                                     Launcher.addDumpLog(TAG, &quot;skipping item whose component &quot; +
2072                                             &quot;no longer exists.&quot;, true);
2073                                     continue;
2074                                 } else if (container ==
2075                                         LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2076                                     // Dedupe icons directly on the workspace
2077 
2078                                     // Canonicalize
2079                                     // the Play Store sets the package parameter, but Launcher
2080                                     // does not, so we clear that out to keep them the same
2081                                     intent.setPackage(null);
2082                                     final String key = intent.toUri(0);
2083                                     if (seenIntents.contains(key)) {
2084                                         Launcher.addDumpLog(TAG, &quot;skipping duplicate&quot;, true);
2085                                         continue;
2086                                     } else {
2087                                         seenIntents.add(key);
2088                                     }
2089                                 }
2090                             }
2091 
2092                             ContentValues values = new ContentValues(c.getColumnCount());
2093                             values.put(LauncherSettings.Favorites._ID, c.getInt(idIndex));
2094                             values.put(LauncherSettings.Favorites.INTENT, intentStr);
2095                             values.put(LauncherSettings.Favorites.TITLE, c.getString(titleIndex));
2096                             values.put(LauncherSettings.Favorites.ICON_TYPE,
2097                                     c.getInt(iconTypeIndex));
2098                             values.put(LauncherSettings.Favorites.ICON, c.getBlob(iconIndex));
2099                             values.put(LauncherSettings.Favorites.ICON_PACKAGE,
2100                                     c.getString(iconPackageIndex));
2101                             values.put(LauncherSettings.Favorites.ICON_RESOURCE,
2102                                     c.getString(iconResourceIndex));
2103                             values.put(LauncherSettings.Favorites.ITEM_TYPE, itemType);
2104                             values.put(LauncherSettings.Favorites.APPWIDGET_ID, -1);
2105                             values.put(LauncherSettings.Favorites.URI, c.getString(uriIndex));
2106                             values.put(LauncherSettings.Favorites.DISPLAY_MODE,
2107                                     c.getInt(displayModeIndex));
2108                             values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
2109 
2110                             if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2111                                 hotseat.put(screen, values);
2112                             }
2113 
2114                             if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2115                                 // In a folder or in the hotseat, preserve position
2116                                 values.put(LauncherSettings.Favorites.SCREEN, screen);
2117                                 values.put(LauncherSettings.Favorites.CELLX, cellX);
2118                                 values.put(LauncherSettings.Favorites.CELLY, cellY);
2119                             } else {
2120                                 // For items contained directly on one of the workspace screen,
2121                                 // we&#x27;ll determine their location (screen, x, y) in a second pass.
2122                             }
2123 
2124                             values.put(LauncherSettings.Favorites.CONTAINER, container);
2125 
2126                             if (itemType != Favorites.ITEM_TYPE_FOLDER) {
2127                                 shortcuts.add(values);
2128                             } else {
2129                                 folders.add(values);
2130                             }
2131                         }
2132 
2133                         // Now that we have all the hotseat icons, let&#x27;s go through them left-right
2134                         // and assign valid locations for them in the new hotseat
2135                         final int N = hotseat.size();
2136                         for (int idx=0; idx&lt;N; idx++) {
2137                             int hotseatX = hotseat.keyAt(idx);
2138                             ContentValues values = hotseat.valueAt(idx);
2139 
2140                             if (hotseatX == grid.hotseatAllAppsRank) {
2141                                 // let&#x27;s drop this in the next available hole in the hotseat
2142                                 while (++hotseatX &lt; hotseatWidth) {
2143                                     if (hotseat.get(hotseatX) == null) {
2144                                         // found a spot! move it here
2145                                         values.put(LauncherSettings.Favorites.SCREEN,
2146                                                 hotseatX);
2147                                         break;
2148                                     }
2149                                 }
2150                             }
2151                             if (hotseatX &gt;= hotseatWidth) {
2152                                 // no room for you in the hotseat? it&#x27;s off to the desktop with you
2153                                 values.put(LauncherSettings.Favorites.CONTAINER,
2154                                            Favorites.CONTAINER_DESKTOP);
2155                             }
2156                         }
2157 
2158                         final ArrayList&lt;ContentValues&gt; allItems = new ArrayList&lt;ContentValues&gt;();
2159                         // Folders first
2160                         allItems.addAll(folders);
2161                         // Then shortcuts
2162                         allItems.addAll(shortcuts);
2163 
2164                         // Layout all the folders
2165                         for (ContentValues values: allItems) {
2166                             if (values.getAsInteger(LauncherSettings.Favorites.CONTAINER) !=
2167                                     LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2168                                 // Hotseat items and folder items have already had their
2169                                 // location information set. Nothing to be done here.
2170                                 continue;
2171                             }
2172                             values.put(LauncherSettings.Favorites.SCREEN, curScreen);
2173                             values.put(LauncherSettings.Favorites.CELLX, curX);
2174                             values.put(LauncherSettings.Favorites.CELLY, curY);
2175                             curX = (curX + 1) % width;
2176                             if (curX == 0) {
2177                                 curY = (curY + 1);
2178                             }
2179                             // Leave the last row of icons blank on every screen
2180                             if (curY == height - 1) {
2181                                 curScreen = (int) generateNewScreenId();
2182                                 curY = 0;
2183                             }
2184                         }
2185 
2186                         if (allItems.size() &gt; 0) {
2187                             db.beginTransaction();
2188                             try {
2189                                 for (ContentValues row: allItems) {
2190                                     if (row == null) continue;
2191                                     if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, row)
2192                                             &lt; 0) {
2193                                         return;
2194                                     } else {
2195                                         count++;
2196                                     }
2197                                 }
2198                                 db.setTransactionSuccessful();
2199                             } finally {
2200                                 db.endTransaction();
2201                             }
2202                         }
2203 
2204                         db.beginTransaction();
2205                         try {
2206                             for (i=0; i&lt;=curScreen; i++) {
2207                                 final ContentValues values = new ContentValues();
2208                                 values.put(LauncherSettings.WorkspaceScreens._ID, i);
2209                                 values.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
2210                                 if (dbInsertAndCheck(this, db, TABLE_WORKSPACE_SCREENS, null, values)
2211                                         &lt; 0) {
2212                                     return;
2213                                 }
2214                             }
2215                             db.setTransactionSuccessful();
2216                         } finally {
2217                             db.endTransaction();
2218                         }
2219                     }
2220                 } finally {
2221                     c.close();
2222                 }
2223             }
2224 
2225             Launcher.addDumpLog(TAG, &quot;migrated &quot; + count + &quot; icons from Launcher2 into &quot;
2226                     + (curScreen+1) + &quot; screens&quot;, true);
2227 
2228             // ensure that new screens are created to hold these icons
2229             setFlagJustLoadedOldDb();
2230 
2231             // Update max IDs; very important since we just grabbed IDs from another database
2232             mMaxItemId = initializeMaxItemId(db);
2233             mMaxScreenId = initializeMaxScreenId(db);
2234             if (LOGD) Log.d(TAG, &quot;mMaxItemId: &quot; + mMaxItemId + &quot; mMaxScreenId: &quot; + mMaxScreenId);
2235         }
2236     }
2237 
2238     /**
2239      * Build a query string that will match any row where the column matches
2240      * anything in the values list.
2241      */
2242     private static String buildOrWhereString(String column, int[] values) {
2243         StringBuilder selectWhere = new StringBuilder();
2244         for (int i = values.length - 1; i &gt;= 0; i--) {
2245             selectWhere.append(column).append(&quot;=&quot;).append(values[i]);
2246             if (i &gt; 0) {
2247                 selectWhere.append(&quot; OR &quot;);
2248             }
2249         }
2250         return selectWhere.toString();
2251     }
2252 
2253     /**
2254      * Return attribute value, attempting launcher-specific namespace first
2255      * before falling back to anonymous attribute.
2256      */
2257     private static String getAttributeValue(XmlResourceParser parser, String attribute) {
2258         String value = parser.getAttributeValue(
2259                 &quot;http://schemas.android.com/apk/res-auto/com.android.launcher3&quot;, attribute);
2260         if (value == null) {
2261             value = parser.getAttributeValue(null, attribute);
2262         }
2263         return value;
2264     }
2265 
2266     /**
2267      * Return attribute resource value, attempting launcher-specific namespace
2268      * first before falling back to anonymous attribute.
2269      */
2270     private static int getAttributeResourceValue(XmlResourceParser parser, String attribute,
2271             int defaultValue) {
2272         int value = parser.getAttributeResourceValue(
2273                 &quot;http://schemas.android.com/apk/res-auto/com.android.launcher3&quot;, attribute,
2274                 defaultValue);
2275         if (value == defaultValue) {
2276             value = parser.getAttributeResourceValue(null, attribute, defaultValue);
2277         }
2278         return value;
2279     }
2280 
2281     private static void copyInteger(ContentValues from, ContentValues to, String key) {
2282         to.put(key, from.getAsInteger(key));
2283     }
2284 
2285     static class SqlArguments {
2286         public final String table;
2287         public final String where;
2288         public final String[] args;
2289 
2290         SqlArguments(Uri url, String where, String[] args) {
2291             if (url.getPathSegments().size() == 1) {
2292                 this.table = url.getPathSegments().get(0);
2293                 this.where = where;
2294                 this.args = args;
2295             } else if (url.getPathSegments().size() != 2) {
2296                 throw new IllegalArgumentException(&quot;Invalid URI: &quot; + url);
2297             } else if (!TextUtils.isEmpty(where)) {
2298                 throw new UnsupportedOperationException(&quot;WHERE clause not supported: &quot; + url);
2299             } else {
2300                 this.table = url.getPathSegments().get(0);
2301                 this.where = &quot;_id=&quot; + ContentUris.parseId(url);
2302                 this.args = null;
2303             }
2304         }
2305 
2306         SqlArguments(Uri url) {
2307             if (url.getPathSegments().size() == 1) {
2308                 table = url.getPathSegments().get(0);
2309                 where = null;
2310                 args = null;
2311             } else {
2312                 throw new IllegalArgumentException(&quot;Invalid URI: &quot; + url);
2313             }
2314         }
2315     }
2316 
2317     static interface WorkspaceLoader {
2318         /**
2319          * @param screenIds A mutable list of screen its
2320          * @return the number of workspace items added.
2321          */
2322         int loadLayout(SQLiteDatabase db, ArrayList&lt;Long&gt; screenIds);
2323     }
2324 
2325     private static class SimpleWorkspaceLoader implements WorkspaceLoader {
2326         private final Resources mRes;
2327         private final int mWorkspaceId;
2328         private final DatabaseHelper mHelper;
2329 
2330         SimpleWorkspaceLoader(DatabaseHelper helper, Resources res, int workspaceId) {
2331             mHelper = helper;
2332             mRes = res;
2333             mWorkspaceId = workspaceId;
2334         }
2335 
2336         @Override
2337         public int loadLayout(SQLiteDatabase db, ArrayList&lt;Long&gt; screenIds) {
2338             return mHelper.loadFavoritesRecursive(db, mRes, mWorkspaceId, screenIds);
2339         }
2340     }
2341 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.app.SearchManager;
  19 import android.appwidget.AppWidgetHost;
  20 import android.appwidget.AppWidgetManager;
  21 import android.appwidget.AppWidgetProviderInfo;
  22 import android.content.ComponentName;
  23 import android.content.ContentProvider;
  24 import android.content.ContentProviderOperation;
  25 import android.content.ContentProviderResult;
  26 import android.content.ContentResolver;
  27 import android.content.ContentUris;
  28 import android.content.ContentValues;
  29 import android.content.Context;
  30 import android.content.Intent;
  31 import android.content.OperationApplicationException;
  32 import android.content.SharedPreferences;
  33 import android.content.pm.ActivityInfo;
  34 import android.content.pm.ApplicationInfo;
  35 import android.content.pm.PackageManager;
  36 import android.content.pm.ResolveInfo;
  37 import android.content.res.Resources;
  38 import android.content.res.XmlResourceParser;
  39 import android.database.Cursor;
  40 import android.database.SQLException;
  41 import android.database.sqlite.SQLiteDatabase;
  42 import android.database.sqlite.SQLiteOpenHelper;
  43 import android.database.sqlite.SQLiteQueryBuilder;
  44 import android.database.sqlite.SQLiteStatement;
  45 import android.graphics.Bitmap;
  46 import android.graphics.BitmapFactory;
  47 import android.net.Uri;
  48 import android.os.Bundle;
  49 import android.provider.Settings;
  50 import android.text.TextUtils;
  51 import android.util.Log;
  52 import android.util.SparseArray;
  53 import com.android.launcher3.AutoInstallsLayout.LayoutParserCallback;
  54 import com.android.launcher3.LauncherSettings.Favorites;
  55 import com.android.launcher3.compat.UserHandleCompat;
  56 import com.android.launcher3.compat.UserManagerCompat;
  57 import com.android.launcher3.config.ProviderConfig;
  58 import java.io.File;
  59 import java.io.IOException;
  60 import java.net.URISyntaxException;
  61 import java.util.ArrayList;
  62 import java.util.Collections;
  63 import java.util.HashSet;
  64 import java.util.List;
  65 import org.xmlpull.v1.XmlPullParser;
  66 import org.xmlpull.v1.XmlPullParserException;
  67 
  68 
  69 public class LauncherProvider extends ContentProvider {
  70     private static final String TAG = &quot;Launcher.LauncherProvider&quot;;
  71 
  72     private static final boolean LOGD = false;
  73 
  74     private static final String DATABASE_NAME = &quot;launcher.db&quot;;
  75 
  76     private static final int DATABASE_VERSION = 20;
  77 
  78     static final String OLD_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
  79 
  80     static final String AUTHORITY = ProviderConfig.AUTHORITY;
  81 
  82     // Should we attempt to load anything from the com.android.launcher2 provider?
  83     // Should we attempt to load anything from the com.android.launcher2 provider?
  84     static final boolean IMPORT_LAUNCHER2_DATABASE = false;
  85 
  86     static final String TABLE_FAVORITES = &quot;favorites&quot;;
  87 
  88     static final String TABLE_WORKSPACE_SCREENS = &quot;workspaceScreens&quot;;
  89 
  90     static final String PARAMETER_NOTIFY = &quot;notify&quot;;
  91 
  92     static final String UPGRADED_FROM_OLD_DATABASE =
  93             &quot;UPGRADED_FROM_OLD_DATABASE&quot;;
  94 
  95     static final String EMPTY_DATABASE_CREATED =
  96             &quot;EMPTY_DATABASE_CREATED&quot;;
  97 
  98     private static final String ACTION_APPWIDGET_DEFAULT_WORKSPACE_CONFIGURE =
  99             &quot;com.android.launcher.action.APPWIDGET_DEFAULT_WORKSPACE_CONFIGURE&quot;;
 100 
 101     private static final String URI_PARAM_IS_EXTERNAL_ADD = &quot;isExternalAdd&quot;;
 102 
 103     private LauncherProviderChangeListener mListener;
 104 
 105     /**
 106      * {@link Uri} triggered at any registered {@link android.database.ContentObserver} when
 107      * {@link AppWidgetHost#deleteHost()} is called during database creation.
 108      * Use this to recall {@link AppWidgetHost#startListening()} if needed.
 109      */
 110     static final Uri CONTENT_APPWIDGET_RESET_URI =
 111             Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/appWidgetReset&quot;);
 112 
 113     private DatabaseHelper mOpenHelper;
 114 
 115     private static boolean sJustLoadedFromOldDb;
 116 
 117     @Override
 118     public boolean onCreate() {
 119         final Context context = getContext();
 120         mOpenHelper = new DatabaseHelper(context);
 121         LauncherAppState.setLauncherProvider(this);
 122         return true;
 123     }
 124 
 125     public boolean wasNewDbCreated() {
 126         return mOpenHelper.wasNewDbCreated();
 127     }
 128 
 129     public void setLauncherProviderChangeListener(LauncherProviderChangeListener listener) {
 130         mListener = listener;
 131     }
 132 
 133     @Override
 134     public String getType(Uri uri) {
 135         SqlArguments args = new SqlArguments(uri, null, null);
 136         if (TextUtils.isEmpty(args.where)) {
 137             return &quot;vnd.android.cursor.dir/&quot; + args.table;
 138         } else {
 139             return &quot;vnd.android.cursor.item/&quot; + args.table;
 140         }
 141     }
 142 
 143     @Override
 144     public Cursor query(Uri uri, String[] projection, String selection,
 145             String[] selectionArgs, String sortOrder) {
 146 
 147         SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 148         SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
 149         qb.setTables(args.table);
 150 
 151         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 152         Cursor result = qb.query(db, projection, args.where, args.args, null, null, sortOrder);
 153         result.setNotificationUri(getContext().getContentResolver(), uri);
 154 
 155         return result;
 156     }
 157 
<abbr title=" 158     private static long dbInsertAndCheck(DatabaseHelper helper, SQLiteDatabase db, String table, String nullColumnHack, ContentValues values) {"> 158     private static long dbInsertAndCheck(DatabaseHelper helper, SQLiteDatabase db, String table, String n🔵</abbr>
 159         if (values == null) {
 160             throw new RuntimeException(&quot;Error: attempting to insert null values&quot;);
 161         }
 162         if (!values.containsKey(LauncherSettings.ChangeLogColumns._ID)) {
 163             throw new RuntimeException(&quot;Error: attempting to add item without specifying an id&quot;);
 164         }
 165         helper.checkId(table, values);
 166         return db.insert(table, nullColumnHack, values);
 167     }
 168 
 169     private static void deleteId(SQLiteDatabase db, long id) {
 170         Uri uri = LauncherSettings.Favorites.getContentUri(id, false);
 171         SqlArguments args = new SqlArguments(uri, null, null);
 172         db.delete(args.table, args.where, args.args);
 173     }
 174 
 175     @Override
 176     public Uri insert(Uri uri, ContentValues initialValues) {
 177         SqlArguments args = new SqlArguments(uri);
 178         // In very limited cases, we support system|signature permission apps to add to the db
 179         String externalAdd = uri.getQueryParameter(URI_PARAM_IS_EXTERNAL_ADD);
 180         if ((externalAdd != null) &amp;&amp; &quot;true&quot;.equals(externalAdd)) {
 181             if (!mOpenHelper.initializeExternalAdd(initialValues)) {
 182                 return null;
 183             }
 184         }
 185         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 186         addModifiedTime(initialValues);
 187         final long rowId = dbInsertAndCheck(mOpenHelper, db, args.table, null, initialValues);
 188         if (rowId &lt;= 0) {
 189             return null;
 190         }
 191         uri = ContentUris.withAppendedId(uri, rowId);
 192         sendNotify(uri);
 193         return uri;
 194     }
 195 
 196     @Override
 197     public int bulkInsert(Uri uri, ContentValues[] values) {
 198         SqlArguments args = new SqlArguments(uri);
 199 
 200         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 201         db.beginTransaction();
 202         try {
 203             int numValues = values.length;
 204             for (int i = 0; i &lt; numValues; i++) {
 205                 addModifiedTime(values[i]);
 206                 if (dbInsertAndCheck(mOpenHelper, db, args.table, null, values[i]) &lt; 0) {
 207                     return 0;
 208                 }
 209             }
 210             db.setTransactionSuccessful();
 211         } finally {
 212             db.endTransaction();
 213         }
 214 
 215         sendNotify(uri);
 216         return values.length;
 217     }
 218 
 219     @Override
 220     public ContentProviderResult[] applyBatch(ArrayList&lt;ContentProviderOperation&gt; operations)
 221             throws OperationApplicationException {
 222         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 223         db.beginTransaction();
 224         try {
 225             ContentProviderResult[] result =  super.applyBatch(operations);
 226             db.setTransactionSuccessful();
 227             return result;
 228         } finally {
 229             db.endTransaction();
 230         }
 231     }
 232 
 233     @Override
 234     public int delete(Uri uri, String selection, String[] selectionArgs) {
 235         SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 236 
 237         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 238         int count = db.delete(args.table, args.where, args.args);
 239         if (count &gt; 0) sendNotify(uri);
 240 
 241         return count;
 242     }
 243 
 244     @Override
 245     public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
 246         SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 247 
 248         addModifiedTime(values);
 249         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 250         int count = db.update(args.table, values, args.where, args.args);
 251         if (count &gt; 0) sendNotify(uri);
 252 
 253         return count;
 254     }
 255 
 256     private void sendNotify(Uri uri) {
 257         String notify = uri.getQueryParameter(PARAMETER_NOTIFY);
 258         if ((notify == null) || &quot;true&quot;.equals(notify)) {
 259             getContext().getContentResolver().notifyChange(uri, null);
 260         }
 261         // always notify the backup agent
 262         LauncherBackupAgentHelper.dataChanged(getContext());
 263         if (mListener != null) {
 264             mListener.onLauncherProviderChange();
 265         }
 266     }
 267 
 268     private void addModifiedTime(ContentValues values) {
 269         values.put(LauncherSettings.ChangeLogColumns.MODIFIED, System.currentTimeMillis());
 270     }
 271 
 272     public long generateNewItemId() {
 273         return mOpenHelper.generateNewItemId();
 274     }
 275 
 276     public void updateMaxItemId(long id) {
 277         mOpenHelper.updateMaxItemId(id);
 278     }
 279 
 280     public long generateNewScreenId() {
 281         return mOpenHelper.generateNewScreenId();
 282     }
 283 
 284     // This is only required one time while loading the workspace during the
 285     // upgrade path, and should never be called from anywhere else.
 286     public void updateMaxScreenId(long maxScreenId) {
 287         mOpenHelper.updateMaxScreenId(maxScreenId);
 288     }
 289 
 290     /**
 291      * @param Should we load the old db for upgrade? first run only.
 292      */
 293     synchronized public boolean justLoadedOldDb() {
 294         String spKey = LauncherAppState.getSharedPreferencesKey();
 295         SharedPreferences sp = getContext().getSharedPreferences(spKey, Context.MODE_PRIVATE);
 296 
 297         boolean loadedOldDb = false || sJustLoadedFromOldDb;
 298 
 299         sJustLoadedFromOldDb = false;
 300         if (sp.getBoolean(UPGRADED_FROM_OLD_DATABASE, false)) {
 301 
 302             SharedPreferences.Editor editor = sp.edit();
 303             editor.remove(UPGRADED_FROM_OLD_DATABASE);
 304             editor.commit();
 305             loadedOldDb = true;
 306         }
 307         return loadedOldDb;
 308     }
 309 
 310     /**
 311      * Clears all the data for a fresh start.
 312      */
 313     public synchronized void createEmptyDB() {
 314         mOpenHelper.createEmptyDB(mOpenHelper.getWritableDatabase());
 315     }
 316 
 317     /**
 318      * Loads the default workspace based on the following priority scheme:
 319      * 1) From a package provided by play store
 320      * 2) From a partner configuration APK, already in the system image
 321      * 3) The default configuration for the particular device
 322      */
 323     public synchronized void loadDefaultFavoritesIfNecessary() {
 324         String spKey = LauncherAppState.getSharedPreferencesKey();
 325         SharedPreferences sp = getContext().getSharedPreferences(spKey, Context.MODE_PRIVATE);
 326         if (sp.getBoolean(EMPTY_DATABASE_CREATED, false)) {
 327             Log.d(TAG, &quot;loading default workspace&quot;);
<abbr title=" 328             WorkspaceLoader loader = AutoInstallsLayout.get(getContext(), mOpenHelper.mAppWidgetHost, mOpenHelper);"> 328             WorkspaceLoader loader = AutoInstallsLayout.get(getContext(), mOpenHelper.mAppWidgetHost, mOp🔵</abbr>
 329             if (loader == null) {
 330                 final Partner partner = Partner.get(getContext().getPackageManager());
 331                 if ((partner != null) &amp;&amp; partner.hasDefaultLayout()) {
 332                     final Resources partnerRes = partner.getResources();
<abbr title=" 333                     int workspaceResId = partnerRes.getIdentifier(Partner.RES_DEFAULT_LAYOUT, &quot;xml&quot;, partner.getPackageName());"> 333                     int workspaceResId = partnerRes.getIdentifier(Partner.RES_DEFAULT_LAYOUT, &quot;xml&quot;, part🔵</abbr>
 334                     if (workspaceResId != 0) {
 335                         loader = new SimpleWorkspaceLoader(mOpenHelper, partnerRes, workspaceResId);
 336                     }
 337                 }
 338             }
 339             if (loader == null) {
<abbr title=" 340                 loader = new SimpleWorkspaceLoader(mOpenHelper, getContext().getResources(), getDefaultWorkspaceResourceId());"> 340                 loader = new SimpleWorkspaceLoader(mOpenHelper, getContext().getResources(), getDefaultWo🔵</abbr>
 341             }
 342             // Populate favorites table with initial favorites
 343             SharedPreferences.Editor editor = sp.edit().remove(EMPTY_DATABASE_CREATED);
 344             mOpenHelper.loadFavorites(mOpenHelper.getWritableDatabase(), loader);
 345             editor.commit();
 346         }
 347     }
 348 
 349     public void migrateLauncher2Shortcuts() {
<abbr title=" 350         mOpenHelper.migrateLauncher2Shortcuts(mOpenHelper.getWritableDatabase(), Uri.parse(getContext().getString(R.string.old_launcher_provider_uri)));"> 350         mOpenHelper.migrateLauncher2Shortcuts(mOpenHelper.getWritableDatabase(), Uri.parse(getContext().g🔵</abbr>
 351     }
 352 
 353     private static int getDefaultWorkspaceResourceId() {
 354         LauncherAppState app = LauncherAppState.getInstance();
 355         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 356         if (LauncherAppState.isDisableAllApps()) {
 357             return grid.defaultNoAllAppsLayoutId;
 358         } else {
 359             return grid.defaultLayoutId;
 360         }
 361     }
 362 
 363     private static interface ContentValuesCallback {
 364         public abstract void onRow(ContentValues values);
 365     }
 366 
 367     private static boolean shouldImportLauncher2Database(Context context) {
 368         boolean isTablet = context.getResources().getBoolean(R.bool.is_tablet);
 369 
 370         // We don&#x27;t import the old databse for tablets, as the grid size has changed.
 371         return !isTablet &amp;&amp; IMPORT_LAUNCHER2_DATABASE;
 372     }
 373 
 374     public void deleteDatabase() {
 375         // Are you sure? (y/n)
 376         final SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 377         final File dbFile = new File(db.getPath());
 378         mOpenHelper.close();
 379         if (dbFile.exists()) {
 380             SQLiteDatabase.deleteDatabase(dbFile);
 381         }
 382         mOpenHelper = new DatabaseHelper(getContext());
 383     }
 384 
 385     private static class DatabaseHelper extends SQLiteOpenHelper implements LayoutParserCallback {
 386         private static final String TAG_RESOLVE = &quot;resolve&quot;;
 387 
 388         private static final String TAG_FAVORITES = &quot;favorites&quot;;
 389 
 390         private static final String TAG_FAVORITE = &quot;favorite&quot;;
 391 
 392         private static final String TAG_APPWIDGET = &quot;appwidget&quot;;
 393 
 394         private static final String TAG_SHORTCUT = &quot;shortcut&quot;;
 395 
 396         private static final String TAG_FOLDER = &quot;folder&quot;;
 397 
 398         private static final String TAG_PARTNER_FOLDER = &quot;partner-folder&quot;;
 399 
 400         private static final String TAG_EXTRA = &quot;extra&quot;;
 401 
 402         private static final String TAG_INCLUDE = &quot;include&quot;;
 403 
 404         // Style attrs -- &quot;Favorite&quot;
 405         // Style attrs -- &quot;Favorite&quot;
 406         private static final String ATTR_CLASS_NAME = &quot;className&quot;;
 407 
 408         private static final String ATTR_PACKAGE_NAME = &quot;packageName&quot;;
 409 
 410         private static final String ATTR_CONTAINER = &quot;container&quot;;
 411 
 412         private static final String ATTR_SCREEN = &quot;screen&quot;;
 413 
 414         private static final String ATTR_X = &quot;x&quot;;
 415 
 416         private static final String ATTR_Y = &quot;y&quot;;
 417 
 418         private static final String ATTR_SPAN_X = &quot;spanX&quot;;
 419 
 420         private static final String ATTR_SPAN_Y = &quot;spanY&quot;;
 421 
 422         private static final String ATTR_ICON = &quot;icon&quot;;
 423 
 424         private static final String ATTR_TITLE = &quot;title&quot;;
 425 
 426         private static final String ATTR_URI = &quot;uri&quot;;
 427 
 428         // Style attrs -- &quot;Include&quot;
 429         // Style attrs -- &quot;Include&quot;
 430         private static final String ATTR_WORKSPACE = &quot;workspace&quot;;
 431 
 432         // Style attrs -- &quot;Extra&quot;
 433         // Style attrs -- &quot;Extra&quot;
 434         private static final String ATTR_KEY = &quot;key&quot;;
 435 
 436         private static final String ATTR_VALUE = &quot;value&quot;;
 437 
 438         private final Context mContext;
 439 
 440         private final PackageManager mPackageManager;
 441 
 442         private final AppWidgetHost mAppWidgetHost;
 443 
 444         private long mMaxItemId = -1;
 445 
 446         private long mMaxScreenId = -1;
 447 
 448         private boolean mNewDbCreated = false;
 449 
 450         DatabaseHelper(Context context) {
 451             super(context, DATABASE_NAME, null, DATABASE_VERSION);
 452             mContext = context;
 453             mPackageManager = context.getPackageManager();
 454             mAppWidgetHost = new AppWidgetHost(context, Launcher.APPWIDGET_HOST_ID);
 455             // In the case where neither onCreate nor onUpgrade gets called, we read the maxId from
 456             // the DB here
 457             if (mMaxItemId == (-1)) {
 458                 mMaxItemId = initializeMaxItemId(getWritableDatabase());
 459             }
 460             if (mMaxScreenId == (-1)) {
 461                 mMaxScreenId = initializeMaxScreenId(getWritableDatabase());
 462             }
 463         }
 464 
 465         public boolean wasNewDbCreated() {
 466             return mNewDbCreated;
 467         }
 468 
 469         /**
 470          * Send notification that we&#x27;ve deleted the {@link AppWidgetHost},
 471          * probably as part of the initial database creation. The receiver may
 472          * want to re-call {@link AppWidgetHost#startListening()} to ensure
 473          * callbacks are correctly set.
 474          */
 475         private void sendAppWidgetResetNotify() {
 476             final ContentResolver resolver = mContext.getContentResolver();
 477             resolver.notifyChange(CONTENT_APPWIDGET_RESET_URI, null);
 478         }
 479 
 480         @Override
 481         public void onCreate(SQLiteDatabase db) {
 482             if (LOGD) {
 483                 Log.d(TAG, &quot;creating new launcher database&quot;);
 484             }
 485             mMaxItemId = 1;
 486             mMaxScreenId = 0;
 487             mNewDbCreated = true;
 488             UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 489             long userSerialNumber = userManager.getSerialNumberForUser(UserHandleCompat.myUserHandle());
<abbr title=" 490             db.execSQL(((&quot;CREATE TABLE favorites (&quot; + (((((((((((((((((((((&quot;_id INTEGER PRIMARY KEY,&quot; + &quot;title TEXT,&quot;) + &quot;intent TEXT,&quot;) + &quot;container INTEGER,&quot;) + &quot;screen INTEGER,&quot;) + &quot;cellX INTEGER,&quot;) + &quot;cellY INTEGER,&quot;) + &quot;spanX INTEGER,&quot;) + &quot;spanY INTEGER,&quot;) + &quot;itemType INTEGER,&quot;) + &quot;appWidgetId INTEGER NOT NULL DEFAULT -1,&quot;) + &quot;isShortcut INTEGER,&quot;) + &quot;iconType INTEGER,&quot;) + &quot;iconPackage TEXT,&quot;) + &quot;iconResource TEXT,&quot;) + &quot;icon BLOB,&quot;) + &quot;uri TEXT,&quot;) + &quot;displayMode INTEGER,&quot;) + &quot;appWidgetProvider TEXT,&quot;) + &quot;modified INTEGER NOT NULL DEFAULT 0,&quot;) + &quot;restored INTEGER NOT NULL DEFAULT 0,&quot;) + &quot;profileId INTEGER DEFAULT &quot;)) + userSerialNumber) + &quot;);&quot;);"> 490             db.execSQL(((&quot;CREATE TABLE favorites (&quot; + (((((((((((((((((((((&quot;_id INTEGER PRIMARY KEY,&quot; + &quot;🔵</abbr>
 491             addWorkspacesTable(db);
 492             // Database was just created, so wipe any previous widgets
 493             if (mAppWidgetHost != null) {
 494                 mAppWidgetHost.deleteHost();
 495                 sendAppWidgetResetNotify();
 496             }
 497             if (shouldImportLauncher2Database(mContext)) {
 498                 // Try converting the old database
 499                 ContentValuesCallback permuteScreensCb = new ContentValuesCallback() {
 500                     public void onRow(ContentValues values) {
 501                         int container = values.getAsInteger(LauncherSettings.Favorites.CONTAINER);
 502                         if (container == Favorites.CONTAINER_DESKTOP) {
 503                             int screen = values.getAsInteger(LauncherSettings.Favorites.SCREEN);
 504                             screen = ((int) (upgradeLauncherDb_permuteScreens(screen)));
 505                             values.put(LauncherSettings.Favorites.SCREEN, screen);
 506                         }
 507                     }
 508                 };
 509                 Uri uri = Uri.parse((&quot;content://&quot; + Settings.AUTHORITY) + &quot;/old_favorites?notify=true&quot;);
 510                 if (!convertDatabase(db, uri, permuteScreensCb, true)) {
 511                     // Try and upgrade from the Launcher2 db
 512                     uri = Uri.parse(mContext.getString(R.string.old_launcher_provider_uri));
 513                     if (!convertDatabase(db, uri, permuteScreensCb, false)) {
 514                         // If we fail, then set a flag to load the default workspace
 515                         setFlagEmptyDbCreated();
 516                         return;
 517                     }
 518                 }
 519                 // Right now, in non-default workspace cases, we want to run the final
 520                 // upgrade code (ie. to fix workspace screen indices -&gt; ids, etc.), so
 521                 // set that flag too.
 522                 setFlagJustLoadedOldDb();
 523             } else {
 524                 // Fresh and clean launcher DB.
 525                 mMaxItemId = initializeMaxItemId(db);
 526                 setFlagEmptyDbCreated();
 527             }
 528         }
 529 
 530         private void addWorkspacesTable(SQLiteDatabase db) {
 531             db.execSQL(&quot;CREATE TABLE &quot; + TABLE_WORKSPACE_SCREENS + &quot; (&quot; +
 532                     LauncherSettings.WorkspaceScreens._ID + &quot; INTEGER,&quot; +
 533                     LauncherSettings.WorkspaceScreens.SCREEN_RANK + &quot; INTEGER,&quot; +
 534                     LauncherSettings.ChangeLogColumns.MODIFIED + &quot; INTEGER NOT NULL DEFAULT 0&quot; +
 535                     &quot;);&quot;);
 536         }
 537 
 538         private void removeOrphanedItems(SQLiteDatabase db) {
 539             // Delete items directly on the workspace who&#x27;s screen id doesn&#x27;t exist
 540             // &quot;DELETE FROM favorites WHERE screen NOT IN (SELECT _id FROM workspaceScreens)
 541             // AND container = -100&quot;
<abbr title=" 542             String removeOrphanedDesktopItems = (((((((((((&quot;DELETE FROM &quot; + TABLE_FAVORITES) + &quot; WHERE &quot;) + Favorites.SCREEN) + &quot; NOT IN (SELECT &quot;) + LauncherSettings.WorkspaceScreens._ID) + &quot; FROM &quot;) + TABLE_WORKSPACE_SCREENS) + &quot;)&quot;) + &quot; AND &quot;) + Favorites.CONTAINER) + &quot; = &quot;) + Favorites.CONTAINER_DESKTOP;"> 542             String removeOrphanedDesktopItems = (((((((((((&quot;DELETE FROM &quot; + TABLE_FAVORITES) + &quot; WHERE &quot;)🔵</abbr>
 543             db.execSQL(removeOrphanedDesktopItems);
 544             // Delete items contained in folders which no longer exist (after above statement)
 545             // &quot;DELETE FROM favorites  WHERE container &lt;&gt; -100 AND container &lt;&gt; -101 AND container
 546             // NOT IN (SELECT _id FROM favorites WHERE itemType = 2)&quot;
<abbr title=" 547             String removeOrphanedFolderItems = (((((((((((((((((((&quot;DELETE FROM &quot; + TABLE_FAVORITES) + &quot; WHERE &quot;) + Favorites.CONTAINER) + &quot; &lt;&gt; &quot;) + Favorites.CONTAINER_DESKTOP) + &quot; AND &quot;) + Favorites.CONTAINER) + &quot; &lt;&gt; &quot;) + Favorites.CONTAINER_HOTSEAT) + &quot; AND &quot;) + Favorites.CONTAINER) + &quot; NOT IN (SELECT &quot;) + Favorites._ID) + &quot; FROM &quot;) + TABLE_FAVORITES) + &quot; WHERE &quot;) + Favorites.ITEM_TYPE) + &quot; = &quot;) + Favorites.ITEM_TYPE_FOLDER) + &quot;)&quot;;"> 547             String removeOrphanedFolderItems = (((((((((((((((((((&quot;DELETE FROM &quot; + TABLE_FAVORITES) + &quot; W🔵</abbr>
 548             db.execSQL(removeOrphanedFolderItems);
 549         }
 550 
 551         private void setFlagJustLoadedOldDb() {
 552             String spKey = LauncherAppState.getSharedPreferencesKey();
 553             SharedPreferences sp = mContext.getSharedPreferences(spKey, Context.MODE_PRIVATE);
 554             SharedPreferences.Editor editor = sp.edit();
 555             editor.putBoolean(UPGRADED_FROM_OLD_DATABASE, true);
 556             editor.putBoolean(EMPTY_DATABASE_CREATED, false);
 557             editor.commit();
 558         }
 559 
 560         private void setFlagEmptyDbCreated() {
 561             String spKey = LauncherAppState.getSharedPreferencesKey();
 562             SharedPreferences sp = mContext.getSharedPreferences(spKey, Context.MODE_PRIVATE);
 563             SharedPreferences.Editor editor = sp.edit();
 564             editor.putBoolean(EMPTY_DATABASE_CREATED, true);
 565             editor.putBoolean(UPGRADED_FROM_OLD_DATABASE, false);
 566             editor.commit();
 567         }
 568 
 569         // We rearrange the screens from the old launcher
 570         // 12345 -&gt; 34512
 571         private long upgradeLauncherDb_permuteScreens(long screen) {
 572             if (screen &gt;= 2) {
 573                 return screen - 2;
 574             } else {
 575                 return screen + 3;
 576             }
 577         }
 578 
 579         private boolean convertDatabase(SQLiteDatabase db, Uri uri,
 580                                         ContentValuesCallback cb, boolean deleteRows) {
 581             if (LOGD) Log.d(TAG, &quot;converting database from an older format, but not onUpgrade&quot;);
 582             boolean converted = false;
 583 
 584             final ContentResolver resolver = mContext.getContentResolver();
 585             Cursor cursor = null;
 586 
 587             try {
 588                 cursor = resolver.query(uri, null, null, null, null);
 589             } catch (Exception e) {
 590                 // Ignore
 591             }
 592 
 593             // We already have a favorites database in the old provider
 594             if (cursor != null) {
 595                 try {
 596                      if (cursor.getCount() &gt; 0) {
 597                         converted = copyFromCursor(db, cursor, cb) &gt; 0;
 598                         if (converted &amp;&amp; deleteRows) {
 599                             resolver.delete(uri, null, null);
 600                         }
 601                     }
 602                 } finally {
 603                     cursor.close();
 604                 }
 605             }
 606 
 607             if (converted) {
 608                 // Convert widgets from this import into widgets
 609                 if (LOGD) Log.d(TAG, &quot;converted and now triggering widget upgrade&quot;);
 610                 convertWidgets(db);
 611 
 612                 // Update max item id
 613                 mMaxItemId = initializeMaxItemId(db);
 614                 if (LOGD) Log.d(TAG, &quot;mMaxItemId: &quot; + mMaxItemId);
 615             }
 616 
 617             return converted;
 618         }
 619 
 620         private int copyFromCursor(SQLiteDatabase db, Cursor c, ContentValuesCallback cb) {
 621             final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
 622             final int intentIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.INTENT);
 623             final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 624             final int iconTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_TYPE);
 625             final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
<abbr title=" 626             final int iconPackageIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_PACKAGE);"> 626             final int iconPackageIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_PACKAGE)🔵</abbr>
<abbr title=" 627             final int iconResourceIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_RESOURCE);"> 627             final int iconResourceIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_RESOURC🔵</abbr>
 628             final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 629             final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 630             final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 631             final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 632             final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 633             final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
<abbr title=" 634             final int displayModeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.DISPLAY_MODE);"> 634             final int displayModeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.DISPLAY_MODE)🔵</abbr>
 635 
 636             ContentValues[] rows = new ContentValues[c.getCount()];
 637             int i = 0;
 638             while (c.moveToNext()) {
 639                 ContentValues values = new ContentValues(c.getColumnCount());
 640                 values.put(LauncherSettings.Favorites._ID, c.getLong(idIndex));
 641                 values.put(LauncherSettings.Favorites.INTENT, c.getString(intentIndex));
 642                 values.put(LauncherSettings.Favorites.TITLE, c.getString(titleIndex));
 643                 values.put(LauncherSettings.Favorites.ICON_TYPE, c.getInt(iconTypeIndex));
 644                 values.put(LauncherSettings.Favorites.ICON, c.getBlob(iconIndex));
 645                 values.put(LauncherSettings.Favorites.ICON_PACKAGE, c.getString(iconPackageIndex));
 646                 values.put(LauncherSettings.Favorites.ICON_RESOURCE, c.getString(iconResourceIndex));
 647                 values.put(LauncherSettings.Favorites.CONTAINER, c.getInt(containerIndex));
 648                 values.put(LauncherSettings.Favorites.ITEM_TYPE, c.getInt(itemTypeIndex));
 649                 values.put(LauncherSettings.Favorites.APPWIDGET_ID, -1);
 650                 values.put(LauncherSettings.Favorites.SCREEN, c.getInt(screenIndex));
 651                 values.put(LauncherSettings.Favorites.CELLX, c.getInt(cellXIndex));
 652                 values.put(LauncherSettings.Favorites.CELLY, c.getInt(cellYIndex));
 653                 values.put(LauncherSettings.Favorites.URI, c.getString(uriIndex));
 654                 values.put(LauncherSettings.Favorites.DISPLAY_MODE, c.getInt(displayModeIndex));
 655                 if (cb != null) {
 656                     cb.onRow(values);
 657                 }
 658                 rows[i++] = values;
 659             }
 660 
 661             int total = 0;
 662             if (i &gt; 0) {
 663                 db.beginTransaction();
 664                 try {
 665                     int numValues = rows.length;
 666                     for (i = 0; i &lt; numValues; i++) {
 667                         if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, rows[i]) &lt; 0) {
 668                             return 0;
 669                         } else {
 670                             total++;
 671                         }
 672                     }
 673                     db.setTransactionSuccessful();
 674                 } finally {
 675                     db.endTransaction();
 676                 }
 677             }
 678 
 679             return total;
 680         }
 681 
 682         @Override
 683         public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 684             if (LOGD) {
 685                 Log.d(TAG, &quot;onUpgrade triggered: &quot; + oldVersion);
 686             }
 687             int version = oldVersion;
 688             if (version &lt; 3) {
 689                 // upgrade 1,2 -&gt; 3 added appWidgetId column
 690                 db.beginTransaction();
 691                 try {
 692                     // Insert new column for holding appWidgetIds
<abbr title=" 693                     db.execSQL(&quot;ALTER TABLE favorites &quot; + &quot;ADD COLUMN appWidgetId INTEGER NOT NULL DEFAULT -1;&quot;);"> 693                     db.execSQL(&quot;ALTER TABLE favorites &quot; + &quot;ADD COLUMN appWidgetId INTEGER NOT NULL DEFAUL🔵</abbr>
 694                     db.setTransactionSuccessful();
 695                     version = 3;
 696                 } catch (SQLException ex) {
 697                     // Old version remains, which means we wipe old data
 698                     Log.e(TAG, ex.getMessage(), ex);
 699                 } finally {
 700                     db.endTransaction();
 701                 }
 702                 // Convert existing widgets only if table upgrade was successful
 703                 if (version == 3) {
 704                     convertWidgets(db);
 705                 }
 706             }
 707             if (version &lt; 4) {
 708                 version = 4;
 709             }
 710             // Where&#x27;s version 5?
 711             // - Donut and sholes on 2.0 shipped with version 4 of launcher1.
 712             // - Passion shipped on 2.1 with version 6 of launcher3
 713             // - Sholes shipped on 2.1r1 (aka Mr. 3) with version 5 of launcher 1
 714             // but version 5 on there was the updateContactsShortcuts change
 715             // which was version 6 in launcher 2 (first shipped on passion 2.1r1).
 716             // The updateContactsShortcuts change is idempotent, so running it twice
 717             // is okay so we&#x27;ll do that when upgrading the devices that shipped with it.
 718             if (version &lt; 6) {
 719                 // We went from 3 to 5 screens. Move everything 1 to the right
 720                 db.beginTransaction();
 721                 try {
 722                     db.execSQL(&quot;UPDATE favorites SET screen=(screen + 1);&quot;);
 723                     db.setTransactionSuccessful();
 724                 } catch (SQLException ex) {
 725                     // Old version remains, which means we wipe old data
 726                     Log.e(TAG, ex.getMessage(), ex);
 727                 } finally {
 728                     db.endTransaction();
 729                 }
 730                 // We added the fast track.
 731                 if (updateContactsShortcuts(db)) {
 732                     version = 6;
 733                 }
 734             }
 735             if (version &lt; 7) {
 736                 // Version 7 gets rid of the special search widget.
 737                 convertWidgets(db);
 738                 version = 7;
 739             }
 740             if (version &lt; 8) {
 741                 // Version 8 (froyo) has the icons all normalized.  This should
 742                 // already be the case in practice, but we now rely on it and don&#x27;t
 743                 // resample the images each time.
 744                 normalizeIcons(db);
 745                 version = 8;
 746             }
 747             if (version &lt; 9) {
 748                 // The max id is not yet set at this point (onUpgrade is triggered in the ctor
 749                 // before it gets a change to get set, so we need to read it here when we use it)
 750                 if (mMaxItemId == (-1)) {
 751                     mMaxItemId = initializeMaxItemId(db);
 752                 }
 753                 // Add default hotseat icons
<abbr title=" 754                 loadFavorites(db, new SimpleWorkspaceLoader(this, mContext.getResources(), R.xml.update_workspace));"> 754                 loadFavorites(db, new SimpleWorkspaceLoader(this, mContext.getResources(), R.xml.update_w🔵</abbr>
 755                 version = 9;
 756             }
 757             // We bumped the version three time during JB, once to update the launch flags, once to
 758             // update the override for the default launch animation and once to set the mimetype
 759             // to improve startup performance
 760             if (version &lt; 12) {
 761                 // Contact shortcuts need a different set of flags to be launched now
 762                 // The updateContactsShortcuts change is idempotent, so we can keep using it like
 763                 // back in the Donut days
 764                 updateContactsShortcuts(db);
 765                 version = 12;
 766             }
 767             if (version &lt; 13) {
 768                 // With the new shrink-wrapped and re-orderable workspaces, it makes sense
 769                 // to persist workspace screens and their relative order.
 770                 mMaxScreenId = 0;
 771                 // This will never happen in the wild, but when we switch to using workspace
 772                 // screen ids, redo the import from old launcher.
 773                 sJustLoadedFromOldDb = true;
 774                 addWorkspacesTable(db);
 775                 version = 13;
 776             }
 777             if (version &lt; 14) {
 778                 db.beginTransaction();
 779                 try {
 780                     // Insert new column for holding widget provider name
 781                     db.execSQL(&quot;ALTER TABLE favorites &quot; + &quot;ADD COLUMN appWidgetProvider TEXT;&quot;);
 782                     db.setTransactionSuccessful();
 783                     version = 14;
 784                 } catch (SQLException ex) {
 785                     // Old version remains, which means we wipe old data
 786                     Log.e(TAG, ex.getMessage(), ex);
 787                 } finally {
 788                     db.endTransaction();
 789                 }
 790             }
 791             if (version &lt; 15) {
 792                 db.beginTransaction();
 793                 try {
 794                     // Insert new column for holding update timestamp
<abbr title=" 795                     db.execSQL(&quot;ALTER TABLE favorites &quot; + &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;&quot;);"> 795                     db.execSQL(&quot;ALTER TABLE favorites &quot; + &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0🔵</abbr>
<abbr title=" 796                     db.execSQL(&quot;ALTER TABLE workspaceScreens &quot; + &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;&quot;);"> 796                     db.execSQL(&quot;ALTER TABLE workspaceScreens &quot; + &quot;ADD COLUMN modified INTEGER NOT NULL DE🔵</abbr>
 797                     db.setTransactionSuccessful();
 798                     version = 15;
 799                 } catch (SQLException ex) {
 800                     // Old version remains, which means we wipe old data
 801                     Log.e(TAG, ex.getMessage(), ex);
 802                 } finally {
 803                     db.endTransaction();
 804                 }
 805             }
 806             if (version &lt; 16) {
 807                 db.beginTransaction();
 808                 try {
 809                     // Insert new column for holding restore status
<abbr title=" 810                     db.execSQL(&quot;ALTER TABLE favorites &quot; + &quot;ADD COLUMN restored INTEGER NOT NULL DEFAULT 0;&quot;);"> 810                     db.execSQL(&quot;ALTER TABLE favorites &quot; + &quot;ADD COLUMN restored INTEGER NOT NULL DEFAULT 0🔵</abbr>
 811                     db.setTransactionSuccessful();
 812                     version = 16;
 813                 } catch (SQLException ex) {
 814                     // Old version remains, which means we wipe old data
 815                     Log.e(TAG, ex.getMessage(), ex);
 816                 } finally {
 817                     db.endTransaction();
 818                 }
 819             }
 820             if (version &lt; 17) {
 821                 // We use the db version upgrade here to identify users who may not have seen
 822                 // clings yet (because they weren&#x27;t available), but for whom the clings are now
 823                 // available (tablet users). Because one of the possible cling flows (migration)
 824                 // is very destructive (wipes out workspaces), we want to prevent this from showing
 825                 // until clear data. We do so by marking that the clings have been shown.
 826                 LauncherClings.synchonouslyMarkFirstRunClingDismissed(mContext);
 827                 version = 17;
 828             }
 829             if (version &lt; 18) {
 830                 // No-op
 831                 version = 18;
 832             }
 833             if (version &lt; 19) {
 834                 // Due to a data loss bug, some users may have items associated with screen ids
 835                 // which no longer exist. Since this can cause other problems, and since the user
 836                 // will never see these items anyway, we use database upgrade as an opportunity to
 837                 // clean things up.
 838                 removeOrphanedItems(db);
 839                 version = 19;
 840             }
 841             if (version &lt; 20) {
 842                 // Add userId column
 843                 if (addProfileColumn(db)) {
 844                     version = 20;
 845                 }
 846                 // else old version remains, which means we wipe old data
 847             }
 848             if (version != DATABASE_VERSION) {
 849                 Log.w(TAG, &quot;Destroying all old data.&quot;);
 850                 db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_FAVORITES);
 851                 db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_WORKSPACE_SCREENS);
 852                 onCreate(db);
 853             }
 854         }
 855 
 856         @Override
 857         public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 858             // This shouldn&#x27;t happen -- throw our hands up in the air and start over.
 859             Log.w(TAG, &quot;Database version downgrade from: &quot; + oldVersion + &quot; to &quot; + newVersion +
 860                     &quot;. Wiping databse.&quot;);
 861             createEmptyDB(db);
 862         }
 863 
 864         /**
 865          * Clears all the data for a fresh start.
 866          */
 867         public void createEmptyDB(SQLiteDatabase db) {
 868             db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_FAVORITES);
 869             db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_WORKSPACE_SCREENS);
 870             onCreate(db);
 871         }
 872 
 873         private boolean addProfileColumn(SQLiteDatabase db) {
 874             db.beginTransaction();
 875             try {
 876                 UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 877                 // Default to the serial number of this user, for older
 878                 // shortcuts.
<abbr title=" 879                 long userSerialNumber = userManager.getSerialNumberForUser(UserHandleCompat.myUserHandle());"> 879                 long userSerialNumber = userManager.getSerialNumberForUser(UserHandleCompat.myUserHandle(🔵</abbr>
 880                 // Insert new column for holding user serial number
<abbr title=" 881                 db.execSQL(((&quot;ALTER TABLE favorites &quot; + &quot;ADD COLUMN profileId INTEGER DEFAULT &quot;) + userSerialNumber) + &quot;;&quot;);"> 881                 db.execSQL(((&quot;ALTER TABLE favorites &quot; + &quot;ADD COLUMN profileId INTEGER DEFAULT &quot;) + userSe🔵</abbr>
 882                 db.setTransactionSuccessful();
 883             } catch (SQLException ex) {
 884                 // Old version remains, which means we wipe old data
 885                 Log.e(TAG, ex.getMessage(), ex);
 886                 return false;
 887             } finally {
 888                 db.endTransaction();
 889             }
 890             return true;
 891         }
 892 
 893         private boolean updateContactsShortcuts(SQLiteDatabase db) {
 894             final String selectWhere = buildOrWhereString(Favorites.ITEM_TYPE,
 895                     new int[] { Favorites.ITEM_TYPE_SHORTCUT });
 896 
 897             Cursor c = null;
 898             final String actionQuickContact = &quot;com.android.contacts.action.QUICK_CONTACT&quot;;
 899             db.beginTransaction();
 900             try {
 901                 // Select and iterate through each matching widget
 902                 c = db.query(TABLE_FAVORITES,
 903                         new String[] { Favorites._ID, Favorites.INTENT },
 904                         selectWhere, null, null, null, null);
 905                 if (c == null) return false;
 906 
 907                 if (LOGD) Log.d(TAG, &quot;found upgrade cursor count=&quot; + c.getCount());
 908 
 909                 final int idIndex = c.getColumnIndex(Favorites._ID);
 910                 final int intentIndex = c.getColumnIndex(Favorites.INTENT);
 911 
 912                 while (c.moveToNext()) {
 913                     long favoriteId = c.getLong(idIndex);
 914                     final String intentUri = c.getString(intentIndex);
 915                     if (intentUri != null) {
 916                         try {
 917                             final Intent intent = Intent.parseUri(intentUri, 0);
 918                             android.util.Log.d(&quot;Home&quot;, intent.toString());
 919                             final Uri uri = intent.getData();
 920                             if (uri != null) {
 921                                 final String data = uri.toString();
 922                                 if ((Intent.ACTION_VIEW.equals(intent.getAction()) ||
 923                                         actionQuickContact.equals(intent.getAction())) &amp;&amp;
 924                                         (data.startsWith(&quot;content://contacts/people/&quot;) ||
 925                                         data.startsWith(&quot;content://com.android.contacts/&quot; +
 926                                                 &quot;contacts/lookup/&quot;))) {
 927 
 928                                     final Intent newIntent = new Intent(actionQuickContact);
 929                                     // When starting from the launcher, start in a new, cleared task
 930                                     // CLEAR_WHEN_TASK_RESET cannot reset the root of a task, so we
 931                                     // clear the whole thing preemptively here since
 932                                     // QuickContactActivity will finish itself when launching other
 933                                     // detail activities.
 934                                     newIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
 935                                             Intent.FLAG_ACTIVITY_CLEAR_TASK);
 936                                     newIntent.putExtra(
 937                                             Launcher.INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION, true);
 938                                     newIntent.setData(uri);
 939                                     // Determine the type and also put that in the shortcut
 940                                     // (that can speed up launch a bit)
 941                                     newIntent.setDataAndType(uri, newIntent.resolveType(mContext));
 942 
 943                                     final ContentValues values = new ContentValues();
 944                                     values.put(LauncherSettings.Favorites.INTENT,
 945                                             newIntent.toUri(0));
 946 
 947                                     String updateWhere = Favorites._ID + &quot;=&quot; + favoriteId;
 948                                     db.update(TABLE_FAVORITES, values, updateWhere, null);
 949                                 }
 950                             }
 951                         } catch (RuntimeException ex) {
 952                             Log.e(TAG, &quot;Problem upgrading shortcut&quot;, ex);
 953                         } catch (URISyntaxException e) {
 954                             Log.e(TAG, &quot;Problem upgrading shortcut&quot;, e);
 955                         }
 956                     }
 957                 }
 958 
 959                 db.setTransactionSuccessful();
 960             } catch (SQLException ex) {
 961                 Log.w(TAG, &quot;Problem while upgrading contacts&quot;, ex);
 962                 return false;
 963             } finally {
 964                 db.endTransaction();
 965                 if (c != null) {
 966                     c.close();
 967                 }
 968             }
 969 
 970             return true;
 971         }
 972 
 973         private void normalizeIcons(SQLiteDatabase db) {
 974             Log.d(TAG, &quot;normalizing icons&quot;);
 975 
 976             db.beginTransaction();
 977             Cursor c = null;
 978             SQLiteStatement update = null;
 979             try {
 980                 boolean logged = false;
 981                 update = db.compileStatement(&quot;UPDATE favorites &quot;
 982                         + &quot;SET icon=? WHERE _id=?&quot;);
 983 
 984                 c = db.rawQuery(&quot;SELECT _id, icon FROM favorites WHERE iconType=&quot; +
 985                         Favorites.ICON_TYPE_BITMAP, null);
 986 
 987                 final int idIndex = c.getColumnIndexOrThrow(Favorites._ID);
 988                 final int iconIndex = c.getColumnIndexOrThrow(Favorites.ICON);
 989 
 990                 while (c.moveToNext()) {
 991                     long id = c.getLong(idIndex);
 992                     byte[] data = c.getBlob(iconIndex);
 993                     try {
 994                         Bitmap bitmap = Utilities.resampleIconBitmap(
 995                                 BitmapFactory.decodeByteArray(data, 0, data.length),
 996                                 mContext);
 997                         if (bitmap != null) {
 998                             update.bindLong(1, id);
 999                             data = ItemInfo.flattenBitmap(bitmap);
1000                             if (data != null) {
1001                                 update.bindBlob(2, data);
1002                                 update.execute();
1003                             }
1004                             bitmap.recycle();
1005                         }
1006                     } catch (Exception e) {
1007                         if (!logged) {
1008                             Log.e(TAG, &quot;Failed normalizing icon &quot; + id, e);
1009                         } else {
1010                             Log.e(TAG, &quot;Also failed normalizing icon &quot; + id);
1011                         }
1012                         logged = true;
1013                     }
1014                 }
1015                 db.setTransactionSuccessful();
1016             } catch (SQLException ex) {
1017                 Log.w(TAG, &quot;Problem while allocating appWidgetIds for existing widgets&quot;, ex);
1018             } finally {
1019                 db.endTransaction();
1020                 if (update != null) {
1021                     update.close();
1022                 }
1023                 if (c != null) {
1024                     c.close();
1025                 }
1026             }
1027         }
1028 
1029         // Generates a new ID to use for an object in your database. This method should be only
1030         // called from the main UI thread. As an exception, we do call it when we call the
1031         // constructor from the worker thread; however, this doesn&#x27;t extend until after the
1032         // constructor is called, and we only pass a reference to LauncherProvider to LauncherApp
1033         // after that point
1034         @Override
1035         public long generateNewItemId() {
1036             if (mMaxItemId &lt; 0) {
1037                 throw new RuntimeException(&quot;Error: max item id was not initialized&quot;);
1038             }
1039             mMaxItemId += 1;
1040             return mMaxItemId;
1041         }
1042 
1043         @Override
1044         public long insertAndCheck(SQLiteDatabase db, ContentValues values) {
1045             return dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values);
1046         }
1047 
1048         public void updateMaxItemId(long id) {
1049             mMaxItemId = id + 1;
1050         }
1051 
1052         public void checkId(String table, ContentValues values) {
1053             long id = values.getAsLong(LauncherSettings.BaseLauncherColumns._ID);
1054             if (table == LauncherProvider.TABLE_WORKSPACE_SCREENS) {
1055                 mMaxScreenId = Math.max(id, mMaxScreenId);
1056             }  else {
1057                 mMaxItemId = Math.max(id, mMaxItemId);
1058             }
1059         }
1060 
1061         private long initializeMaxItemId(SQLiteDatabase db) {
1062             Cursor c = db.rawQuery(&quot;SELECT MAX(_id) FROM favorites&quot;, null);
1063 
1064             // get the result
1065             final int maxIdIndex = 0;
1066             long id = -1;
1067             if (c != null &amp;&amp; c.moveToNext()) {
1068                 id = c.getLong(maxIdIndex);
1069             }
1070             if (c != null) {
1071                 c.close();
1072             }
1073 
1074             if (id == -1) {
1075                 throw new RuntimeException(&quot;Error: could not query max item id&quot;);
1076             }
1077 
1078             return id;
1079         }
1080 
1081         // Generates a new ID to use for an workspace screen in your database. This method
1082         // should be only called from the main UI thread. As an exception, we do call it when we
1083         // call the constructor from the worker thread; however, this doesn&#x27;t extend until after the
1084         // constructor is called, and we only pass a reference to LauncherProvider to LauncherApp
1085         // after that point
1086         public long generateNewScreenId() {
1087             if (mMaxScreenId &lt; 0) {
1088                 throw new RuntimeException(&quot;Error: max screen id was not initialized&quot;);
1089             }
1090             mMaxScreenId += 1;
1091             // Log to disk
1092             Launcher.addDumpLog(TAG, &quot;11683562 - generateNewScreenId(): &quot; + mMaxScreenId, true);
1093             return mMaxScreenId;
1094         }
1095 
1096         public void updateMaxScreenId(long maxScreenId) {
1097             // Log to disk
1098             Launcher.addDumpLog(TAG, &quot;11683562 - updateMaxScreenId(): &quot; + maxScreenId, true);
1099             mMaxScreenId = maxScreenId;
1100         }
1101 
1102         private long initializeMaxScreenId(SQLiteDatabase db) {
<abbr title="1103             Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens._ID + &quot;) FROM &quot; + TABLE_WORKSPACE_SCREENS, null);">1103             Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens._ID + &quot;) FROM &quot; + TA🔵</abbr>
1104 
1105             // get the result
1106             final int maxIdIndex = 0;
1107             long id = -1;
1108             if (c != null &amp;&amp; c.moveToNext()) {
1109                 id = c.getLong(maxIdIndex);
1110             }
1111             if (c != null) {
1112                 c.close();
1113             }
1114 
1115             if (id == -1) {
1116                 throw new RuntimeException(&quot;Error: could not query max screen id&quot;);
1117             }
1118 
1119             // Log to disk
1120             Launcher.addDumpLog(TAG, &quot;11683562 - initializeMaxScreenId(): &quot; + id, true);
1121             return id;
1122         }
1123 
1124         /**
1125          * Upgrade existing clock and photo frame widgets into their new widget
1126          * equivalents.
1127          */
1128         private void convertWidgets(SQLiteDatabase db) {
1129             final AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(mContext);
1130             final int[] bindSources = new int[] {
1131                     Favorites.ITEM_TYPE_WIDGET_CLOCK,
1132                     Favorites.ITEM_TYPE_WIDGET_PHOTO_FRAME,
1133                     Favorites.ITEM_TYPE_WIDGET_SEARCH,
1134             };
1135 
1136             final String selectWhere = buildOrWhereString(Favorites.ITEM_TYPE, bindSources);
1137 
1138             Cursor c = null;
1139 
1140             db.beginTransaction();
1141             try {
1142                 // Select and iterate through each matching widget
1143                 c = db.query(TABLE_FAVORITES, new String[] { Favorites._ID, Favorites.ITEM_TYPE },
1144                         selectWhere, null, null, null, null);
1145 
1146                 if (LOGD) Log.d(TAG, &quot;found upgrade cursor count=&quot; + c.getCount());
1147 
1148                 final ContentValues values = new ContentValues();
1149                 while (c != null &amp;&amp; c.moveToNext()) {
1150                     long favoriteId = c.getLong(0);
1151                     int favoriteType = c.getInt(1);
1152 
1153                     // Allocate and update database with new appWidgetId
1154                     try {
1155                         int appWidgetId = mAppWidgetHost.allocateAppWidgetId();
1156 
1157                         if (LOGD) {
1158                             Log.d(TAG, &quot;allocated appWidgetId=&quot; + appWidgetId
1159                                     + &quot; for favoriteId=&quot; + favoriteId);
1160                         }
1161                         values.clear();
1162                         values.put(Favorites.ITEM_TYPE, Favorites.ITEM_TYPE_APPWIDGET);
1163                         values.put(Favorites.APPWIDGET_ID, appWidgetId);
1164 
1165                         // Original widgets might not have valid spans when upgrading
1166                         if (favoriteType == Favorites.ITEM_TYPE_WIDGET_SEARCH) {
1167                             values.put(LauncherSettings.Favorites.SPANX, 4);
1168                             values.put(LauncherSettings.Favorites.SPANY, 1);
1169                         } else {
1170                             values.put(LauncherSettings.Favorites.SPANX, 2);
1171                             values.put(LauncherSettings.Favorites.SPANY, 2);
1172                         }
1173 
1174                         String updateWhere = Favorites._ID + &quot;=&quot; + favoriteId;
1175                         db.update(TABLE_FAVORITES, values, updateWhere, null);
1176 
1177                         if (favoriteType == Favorites.ITEM_TYPE_WIDGET_CLOCK) {
1178                             // TODO: check return value
1179                             appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId,
1180                                     new ComponentName(&quot;com.android.alarmclock&quot;,
1181                                     &quot;com.android.alarmclock.AnalogAppWidgetProvider&quot;));
1182                         } else if (favoriteType == Favorites.ITEM_TYPE_WIDGET_PHOTO_FRAME) {
1183                             // TODO: check return value
1184                             appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId,
1185                                     new ComponentName(&quot;com.android.camera&quot;,
1186                                     &quot;com.android.camera.PhotoAppWidgetProvider&quot;));
1187                         } else if (favoriteType == Favorites.ITEM_TYPE_WIDGET_SEARCH) {
1188                             // TODO: check return value
1189                             appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId,
1190                                     getSearchWidgetProvider());
1191                         }
1192                     } catch (RuntimeException ex) {
1193                         Log.e(TAG, &quot;Problem allocating appWidgetId&quot;, ex);
1194                     }
1195                 }
1196 
1197                 db.setTransactionSuccessful();
1198             } catch (SQLException ex) {
1199                 Log.w(TAG, &quot;Problem while allocating appWidgetIds for existing widgets&quot;, ex);
1200             } finally {
1201                 db.endTransaction();
1202                 if (c != null) {
1203                     c.close();
1204                 }
1205             }
1206 
1207             // Update max item id
1208             mMaxItemId = initializeMaxItemId(db);
1209             if (LOGD) Log.d(TAG, &quot;mMaxItemId: &quot; + mMaxItemId);
1210         }
1211 
1212         private boolean initializeExternalAdd(ContentValues values) {
1213             // 1. Ensure that externally added items have a valid item id
1214             long id = generateNewItemId();
1215             values.put(LauncherSettings.Favorites._ID, id);
1216             // 2. In the case of an app widget, and if no app widget id is specified, we
1217             // attempt allocate and bind the widget.
1218             Integer itemType = values.getAsInteger(LauncherSettings.Favorites.ITEM_TYPE);
<abbr title="1219             if (((itemType != null) &amp;&amp; (itemType.intValue() == Favorites.ITEM_TYPE_APPWIDGET)) &amp;&amp; (!values.containsKey(LauncherSettings.Favorites.APPWIDGET_ID))) {">1219             if (((itemType != null) &amp;&amp; (itemType.intValue() == Favorites.ITEM_TYPE_APPWIDGET)) &amp;&amp; (!value🔵</abbr>
1220                 final AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(mContext);
<abbr title="1221                 ComponentName cn = ComponentName.unflattenFromString(values.getAsString(Favorites.APPWIDGET_PROVIDER));">1221                 ComponentName cn = ComponentName.unflattenFromString(values.getAsString(Favorites.APPWIDG🔵</abbr>
1222                 if (cn != null) {
1223                     try {
1224                         int appWidgetId = mAppWidgetHost.allocateAppWidgetId();
1225                         values.put(LauncherSettings.Favorites.APPWIDGET_ID, appWidgetId);
1226                         if (!appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId, cn)) {
1227                             return false;
1228                         }
1229                     } catch (java.lang.RuntimeException e) {
1230                         Log.e(TAG, &quot;Failed to initialize external widget&quot;, e);
1231                         return false;
1232                     }
1233                 } else {
1234                     return false;
1235                 }
1236             }
1237             // Add screen id if not present
1238             long screenId = values.getAsLong(LauncherSettings.Favorites.SCREEN);
1239             if (!addScreenIdIfNecessary(screenId)) {
1240                 return false;
1241             }
1242             return true;
1243         }
1244 
1245         // Returns true of screen id exists, or if successfully added
1246         private boolean addScreenIdIfNecessary(long screenId) {
1247             if (!hasScreenId(screenId)) {
1248                 int rank = getMaxScreenRank() + 1;
1249 
1250                 ContentValues v = new ContentValues();
1251                 v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1252                 v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, rank);
1253                 if (dbInsertAndCheck(this, getWritableDatabase(),
1254                         TABLE_WORKSPACE_SCREENS, null, v) &lt; 0) {
1255                     return false;
1256                 }
1257             }
1258             return true;
1259         }
1260 
1261         private boolean hasScreenId(long screenId) {
1262             SQLiteDatabase db = getWritableDatabase();
1263             Cursor c = db.rawQuery(&quot;SELECT * FROM &quot; + TABLE_WORKSPACE_SCREENS + &quot; WHERE &quot;
1264                     + LauncherSettings.WorkspaceScreens._ID + &quot; = &quot; + screenId, null);
1265             if (c != null) {
1266                 int count = c.getCount();
1267                 c.close();
1268                 return count &gt; 0;
1269             } else {
1270                 return false;
1271             }
1272         }
1273 
1274         private int getMaxScreenRank() {
1275             SQLiteDatabase db = getWritableDatabase();
<abbr title="1276             Cursor c = db.rawQuery(((&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens.SCREEN_RANK) + &quot;) FROM &quot;) + TABLE_WORKSPACE_SCREENS, null);">1276             Cursor c = db.rawQuery(((&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens.SCREEN_RANK) + &quot;) 🔵</abbr>
1277             // get the result
1278             final int maxRankIndex = 0;
1279             int rank = -1;
1280             if ((c != null) &amp;&amp; c.moveToNext()) {
1281                 rank = c.getInt(maxRankIndex);
1282             }
1283             if (c != null) {
1284                 c.close();
1285             }
1286             return rank;
1287         }
1288 
1289         private static final void beginDocument(XmlPullParser parser, String firstElementName)
1290                 throws XmlPullParserException, IOException {
1291             int type;
1292             while ((type = parser.next()) != XmlPullParser.START_TAG
1293                     &amp;&amp; type != XmlPullParser.END_DOCUMENT) {
1294                 ;
1295             }
1296 
1297             if (type != XmlPullParser.START_TAG) {
1298                 throw new XmlPullParserException(&quot;No start tag found&quot;);
1299             }
1300 
1301             if (!parser.getName().equals(firstElementName)) {
1302                 throw new XmlPullParserException(&quot;Unexpected start tag: found &quot; + parser.getName() +
1303                         &quot;, expected &quot; + firstElementName);
1304             }
1305         }
1306 
1307         private static Intent buildMainIntent() {
1308             Intent intent = new Intent(Intent.ACTION_MAIN, null);
1309             intent.addCategory(Intent.CATEGORY_LAUNCHER);
1310             return intent;
1311         }
1312 
1313         private int loadFavorites(SQLiteDatabase db, WorkspaceLoader loader) {
1314             ArrayList&lt;Long&gt; screenIds = new ArrayList&lt;Long&gt;();
1315             // TODO: Use multiple loaders with fall-back and transaction.
1316             int count = loader.loadLayout(db, screenIds);
1317             // Add the screens specified by the items above
1318             Collections.sort(screenIds);
1319             int rank = 0;
1320             ContentValues values = new ContentValues();
1321             for (Long id : screenIds) {
1322                 values.clear();
1323                 values.put(LauncherSettings.WorkspaceScreens._ID, id);
1324                 values.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, rank);
1325                 if (dbInsertAndCheck(this, db, TABLE_WORKSPACE_SCREENS, null, values) &lt; 0) {
1326                     throw new RuntimeException(&quot;Failed initialize screen table&quot; + &quot;from default layout&quot;);
1327                 }
1328                 rank++;
1329             }
1330             // Ensure that the max ids are initialized
1331             mMaxItemId = initializeMaxItemId(db);
1332             mMaxScreenId = initializeMaxScreenId(db);
1333             return count;
1334         }
1335 
1336         /**
1337          * Loads the default set of favorite packages from an xml file.
1338          *
1339          * @param db The database to write the values into
1340          * @param filterContainerId The specific container id of items to load
1341          * @param the set of screenIds which are used by the favorites
1342          */
<abbr title="1343         private int loadFavoritesRecursive(SQLiteDatabase db, Resources res, int workspaceResourceId, ArrayList&lt;Long&gt; screenIds) {">1343         private int loadFavoritesRecursive(SQLiteDatabase db, Resources res, int workspaceResourceId, Arr🔵</abbr>
1344             ContentValues values = new ContentValues();
1345             if (LOGD) {
1346                 Log.v(TAG, String.format(&quot;Loading favorites from resid=0x%08x&quot;, workspaceResourceId));
1347             }
1348             int count = 0;
1349             try {
1350                 XmlResourceParser parser = res.getXml(workspaceResourceId);
1351                 beginDocument(parser, TAG_FAVORITES);
1352                 final int depth = parser.getDepth();
1353                 int type;
<abbr title="1354                 while ((((type = parser.next()) != XmlPullParser.END_TAG) || (parser.getDepth() &gt; depth)) &amp;&amp; (type != XmlPullParser.END_DOCUMENT)) {">1354                 while ((((type = parser.next()) != XmlPullParser.END_TAG) || (parser.getDepth() &gt; depth))🔵</abbr>
1355                     if (type != XmlPullParser.START_TAG) {
1356                         continue;
1357                     }
1358                     boolean added = false;
1359                     final String name = parser.getName();
1360                     if (TAG_INCLUDE.equals(name)) {
1361                         final int resId = getAttributeResourceValue(parser, ATTR_WORKSPACE, 0);
1362                         if (LOGD) {
<abbr title="1363                             Log.v(TAG, String.format((&quot;%&quot; + (2 * (depth + 1))) + &quot;s&lt;include workspace=%08x&gt;&quot;, &quot;&quot;, resId));">1363                             Log.v(TAG, String.format((&quot;%&quot; + (2 * (depth + 1))) + &quot;s&lt;include workspace=%08🔵</abbr>
1364                         }
1365                         if ((resId != 0) &amp;&amp; (resId != workspaceResourceId)) {
1366                             // recursively load some more favorites, why not?
1367                             count += loadFavoritesRecursive(db, res, resId, screenIds);
1368                             added = false;
1369                         } else {
1370                             Log.w(TAG, String.format(&quot;Skipping &lt;include workspace=0x%08x&gt;&quot;, resId));
1371                         }
1372                         if (LOGD) {
1373                             Log.v(TAG, String.format((&quot;%&quot; + (2 * (depth + 1))) + &quot;s&lt;/include&gt;&quot;, &quot;&quot;));
1374                         }
1375                         continue;
1376                     }
1377                     // Assuming it&#x27;s a &lt;favorite&gt; at this point
1378                     long container = Favorites.CONTAINER_DESKTOP;
1379                     String strContainer = getAttributeValue(parser, ATTR_CONTAINER);
1380                     if (strContainer != null) {
1381                         container = Long.valueOf(strContainer);
1382                     }
1383                     String screen = getAttributeValue(parser, ATTR_SCREEN);
1384                     String x = getAttributeValue(parser, ATTR_X);
1385                     String y = getAttributeValue(parser, ATTR_Y);
1386                     values.clear();
1387                     values.put(LauncherSettings.Favorites.CONTAINER, container);
1388                     values.put(LauncherSettings.Favorites.SCREEN, screen);
1389                     values.put(LauncherSettings.Favorites.CELLX, x);
1390                     values.put(LauncherSettings.Favorites.CELLY, y);
1391                     if (LOGD) {
1392                         final String title = getAttributeValue(parser, ATTR_TITLE);
1393                         final String pkg = getAttributeValue(parser, ATTR_PACKAGE_NAME);
1394                         final String something = (title != null) ? title : pkg;
<abbr title="1395                         Log.v(TAG, String.format((&quot;%&quot; + (2 * (depth + 1))) + &quot;s&lt;%s%s c=%d s=%s x=%s y=%s&gt;&quot;, &quot;&quot;, name, something == null ? &quot;&quot; : (&quot; \&quot;&quot; + something) + &quot;\&quot;&quot;, container, screen, x, y));">1395                         Log.v(TAG, String.format((&quot;%&quot; + (2 * (depth + 1))) + &quot;s&lt;%s%s c=%d s=%s x=%s y=%s&gt;🔵</abbr>
1396                     }
1397                     if (TAG_FAVORITE.equals(name)) {
1398                         long id = addAppShortcut(db, values, parser);
1399                         added = id &gt;= 0;
1400                     } else if (TAG_APPWIDGET.equals(name)) {
1401                         added = addAppWidget(parser, type, db, values);
1402                     } else if (TAG_SHORTCUT.equals(name)) {
1403                         long id = addUriShortcut(db, values, res, parser);
1404                         added = id &gt;= 0;
1405                     } else if (TAG_RESOLVE.equals(name)) {
1406                         // This looks through the contained favorites (or meta-favorites) and
1407                         // attempts to add them as shortcuts in the fallback group&#x27;s location
1408                         // until one is added successfully.
1409                         added = false;
1410                         final int groupDepth = parser.getDepth();
<abbr title="1411                         while (((type = parser.next()) != XmlPullParser.END_TAG) || (parser.getDepth() &gt; groupDepth)) {">1411                         while (((type = parser.next()) != XmlPullParser.END_TAG) || (parser.getDepth() &gt; 🔵</abbr>
1412                             if (type != XmlPullParser.START_TAG) {
1413                                 continue;
1414                             }
1415                             final String fallback_item_name = parser.getName();
1416                             if (!added) {
1417                                 if (TAG_FAVORITE.equals(fallback_item_name)) {
1418                                     final long id = addAppShortcut(db, values, parser);
1419                                     added = id &gt;= 0;
1420                                 } else {
<abbr title="1421                                     Log.e(TAG, &quot;Fallback groups can contain only favorites, found &quot; + fallback_item_name);">1421                                     Log.e(TAG, &quot;Fallback groups can contain only favorites, found &quot; + fal🔵</abbr>
1422                                 }
1423                             }
1424                         }
1425                     } else if (TAG_FOLDER.equals(name)) {
1426                         // Folder contents are nested in this XML file
1427                         added = loadFolder(db, values, res, parser);
1428                     } else if (TAG_PARTNER_FOLDER.equals(name)) {
1429                         // Folder contents come from an external XML resource
1430                         final Partner partner = Partner.get(mPackageManager);
1431                         if (partner != null) {
1432                             final Resources partnerRes = partner.getResources();
<abbr title="1433                             final int resId = partnerRes.getIdentifier(Partner.RES_FOLDER, &quot;xml&quot;, partner.getPackageName());">1433                             final int resId = partnerRes.getIdentifier(Partner.RES_FOLDER, &quot;xml&quot;, partner🔵</abbr>
1434                             if (resId != 0) {
1435                                 final XmlResourceParser partnerParser = partnerRes.getXml(resId);
1436                                 beginDocument(partnerParser, TAG_FOLDER);
1437                                 added = loadFolder(db, values, partnerRes, partnerParser);
1438                             }
1439                         }
1440                     }
1441                     if (added) {
1442                         long screenId = Long.parseLong(screen);
1443                         // Keep track of the set of screens which need to be added to the db.
<abbr title="1444                         if ((!screenIds.contains(screenId)) &amp;&amp; (container == Favorites.CONTAINER_DESKTOP)) {">1444                         if ((!screenIds.contains(screenId)) &amp;&amp; (container == Favorites.CONTAINER_DESKTOP)🔵</abbr>
1445                             screenIds.add(screenId);
1446                         }
1447                         count++;
1448                     }
1449                 }
1450             } catch (XmlPullParserException e) {
1451                 Log.w(TAG, &quot;Got exception parsing favorites.&quot;, e);
1452             } catch (IOException e) {
1453                 Log.w(TAG, &quot;Got exception parsing favorites.&quot;, e);
1454             } catch (java.lang.RuntimeException e) {
1455                 Log.w(TAG, &quot;Got exception parsing favorites.&quot;, e);
1456             }
1457             return count;
1458         }
1459 
1460         /**
1461          * Parse folder items starting at {@link XmlPullParser} location. Allow recursive
1462          * includes of items.
1463          */
<abbr title="1464         private void addToFolder(SQLiteDatabase db, Resources res, XmlResourceParser parser, ArrayList&lt;Long&gt; folderItems, long folderId) throws IOException, XmlPullParserException {">1464         private void addToFolder(SQLiteDatabase db, Resources res, XmlResourceParser parser, ArrayList&lt;Lo🔵</abbr>
1465             int type;
1466             int folderDepth = parser.getDepth();
<abbr title="1467             while (((type = parser.next()) != XmlPullParser.END_TAG) || (parser.getDepth() &gt; folderDepth)) {">1467             while (((type = parser.next()) != XmlPullParser.END_TAG) || (parser.getDepth() &gt; folderDepth)🔵</abbr>
1468                 if (type != XmlPullParser.START_TAG) {
1469                     continue;
1470                 }
1471                 final String tag = parser.getName();
1472                 final ContentValues childValues = new ContentValues();
1473                 childValues.put(LauncherSettings.Favorites.CONTAINER, folderId);
1474                 if (LOGD) {
1475                     final String pkg = getAttributeValue(parser, ATTR_PACKAGE_NAME);
1476                     final String uri = getAttributeValue(parser, ATTR_URI);
<abbr title="1477                     Log.v(TAG, String.format((&quot;%&quot; + (2 * (folderDepth + 1))) + &quot;s&lt;%s \&quot;%s\&quot;&gt;&quot;, &quot;&quot;, tag, uri != null ? uri : pkg));">1477                     Log.v(TAG, String.format((&quot;%&quot; + (2 * (folderDepth + 1))) + &quot;s&lt;%s \&quot;%s\&quot;&gt;&quot;, &quot;&quot;, tag, u🔵</abbr>
1478                 }
1479                 if (TAG_FAVORITE.equals(tag) &amp;&amp; (folderId &gt;= 0)) {
1480                     final long id = addAppShortcut(db, childValues, parser);
1481                     if (id &gt;= 0) {
1482                         folderItems.add(id);
1483                     }
1484                 } else if (TAG_SHORTCUT.equals(tag) &amp;&amp; (folderId &gt;= 0)) {
1485                     final long id = addUriShortcut(db, childValues, res, parser);
1486                     if (id &gt;= 0) {
1487                         folderItems.add(id);
1488                     }
1489                 } else if (TAG_INCLUDE.equals(tag) &amp;&amp; (folderId &gt;= 0)) {
1490                     addToFolder(db, res, parser, folderItems, folderId);
1491                 } else {
1492                     throw new RuntimeException(&quot;Folders can contain only shortcuts&quot;);
1493                 }
1494             }
1495         }
1496 
1497         /**
1498          * Parse folder starting at current {@link XmlPullParser} location.
1499          */
<abbr title="1500         private boolean loadFolder(SQLiteDatabase db, ContentValues values, Resources res, XmlResourceParser parser) throws IOException, XmlPullParserException {">1500         private boolean loadFolder(SQLiteDatabase db, ContentValues values, Resources res, XmlResourcePar🔵</abbr>
1501             final String title;
1502             final int titleResId = getAttributeResourceValue(parser, ATTR_TITLE, 0);
1503             if (titleResId != 0) {
1504                 title = res.getString(titleResId);
1505             } else {
1506                 title = mContext.getResources().getString(R.string.folder_name);
1507             }
1508             values.put(LauncherSettings.Favorites.TITLE, title);
1509             long folderId = addFolder(db, values);
1510             boolean added = folderId &gt;= 0;
1511             ArrayList&lt;Long&gt; folderItems = new ArrayList&lt;Long&gt;();
1512             addToFolder(db, res, parser, folderItems, folderId);
1513                         // We can only have folders with &gt;= 2 items, so we need to remove the
1514                         // folder and clean up if less than 2 items were included, or some
1515                         // failed to add, and less than 2 were actually added
1516             if ((folderItems.size() &lt; 2) &amp;&amp; (folderId &gt;= 0)) {
1517                 // Delete the folder
1518                 deleteId(db, folderId);
1519                 // If we have a single item, promote it to where the folder
1520                 // would have been.
1521                 if (folderItems.size() == 1) {
1522                     final ContentValues childValues = new ContentValues();
1523                     copyInteger(values, childValues, LauncherSettings.Favorites.CONTAINER);
1524                     copyInteger(values, childValues, LauncherSettings.Favorites.SCREEN);
1525                     copyInteger(values, childValues, LauncherSettings.Favorites.CELLX);
1526                     copyInteger(values, childValues, LauncherSettings.Favorites.CELLY);
1527                     final long id = folderItems.get(0);
1528                     db.update(TABLE_FAVORITES, childValues, (Favorites._ID + &quot;=&quot;) + id, null);
1529                 } else {
1530                     added = false;
1531                 }
1532             }
1533             return added;
1534         }
1535 
1536         // A meta shortcut attempts to resolve an intent specified as a URI in the XML, if a
1537         // logical choice for what shortcut should be used for that intent exists, then it is
1538         // added. Otherwise add nothing.
1539         private long addAppShortcutByUri(SQLiteDatabase db, ContentValues values, String intentUri) {
1540             Intent metaIntent;
1541             try {
1542                 metaIntent = Intent.parseUri(intentUri, 0);
1543             } catch (URISyntaxException e) {
1544                 Log.e(TAG, &quot;Unable to add meta-favorite: &quot; + intentUri, e);
1545                 return -1;
1546             }
<abbr title="1547             ResolveInfo resolved = mPackageManager.resolveActivity(metaIntent, PackageManager.MATCH_DEFAULT_ONLY);">1547             ResolveInfo resolved = mPackageManager.resolveActivity(metaIntent, PackageManager.MATCH_DEFAU🔵</abbr>
<abbr title="1548             final List&lt;ResolveInfo&gt; appList = mPackageManager.queryIntentActivities(metaIntent, PackageManager.MATCH_DEFAULT_ONLY);">1548             final List&lt;ResolveInfo&gt; appList = mPackageManager.queryIntentActivities(metaIntent, PackageMa🔵</abbr>
1549             // Verify that the result is an app and not just the resolver dialog asking which
1550             // app to use.
1551             if (wouldLaunchResolverActivity(resolved, appList)) {
1552                 // If only one of the results is a system app then choose that as the default.
1553                 final ResolveInfo systemApp = getSingleSystemActivity(appList);
1554                 if (systemApp == null) {
1555                     // There is no logical choice for this meta-favorite, so rather than making
1556                     // a bad choice just add nothing.
<abbr title="1557                     Log.w(TAG, &quot;No preference or single system activity found for &quot; + metaIntent.toString());">1557                     Log.w(TAG, &quot;No preference or single system activity found for &quot; + metaIntent.toString🔵</abbr>
1558                     return -1;
1559                 }
1560                 resolved = systemApp;
1561             }
1562             final ActivityInfo info = resolved.activityInfo;
1563             final Intent intent = mPackageManager.getLaunchIntentForPackage(info.packageName);
1564             if (intent == null) {
1565                 return -1;
1566             }
1567             intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
1568             return addAppShortcut(db, values, info.loadLabel(mPackageManager).toString(), intent);
1569         }
1570 
1571         private ResolveInfo getSingleSystemActivity(List&lt;ResolveInfo&gt; appList) {
1572             ResolveInfo systemResolve = null;
1573             final int N = appList.size();
1574             for (int i = 0; i &lt; N; ++i) {
1575                 try {
<abbr title="1576                     ApplicationInfo info = mPackageManager.getApplicationInfo(appList.get(i).activityInfo.packageName, 0);">1576                     ApplicationInfo info = mPackageManager.getApplicationInfo(appList.get(i).activityInfo🔵</abbr>
1577                     if ((info.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) {
1578                         if (systemResolve != null) {
1579                             return null;
1580                         } else {
1581                             systemResolve = appList.get(i);
1582                         }
1583                     }
1584                 } catch (PackageManager e) {
1585                     Log.w(TAG, &quot;Unable to get info about resolve results&quot;, e);
1586                     return null;
1587                 }
1588             }
1589             return systemResolve;
1590         }
1591 
1592         private boolean wouldLaunchResolverActivity(ResolveInfo resolved,
1593                 List&lt;ResolveInfo&gt; appList) {
1594             // If the list contains the above resolved activity, then it can&#x27;t be
1595             // ResolverActivity itself.
1596             for (int i = 0; i &lt; appList.size(); ++i) {
1597                 ResolveInfo tmp = appList.get(i);
1598                 if (tmp.activityInfo.name.equals(resolved.activityInfo.name)
1599                         &amp;&amp; tmp.activityInfo.packageName.equals(resolved.activityInfo.packageName)) {
1600                     return false;
1601                 }
1602             }
1603             return true;
1604         }
1605 
1606         private long addAppShortcut(SQLiteDatabase db, ContentValues values, XmlResourceParser parser) {
1607             final String packageName = getAttributeValue(parser, ATTR_PACKAGE_NAME);
1608             final String className = getAttributeValue(parser, ATTR_CLASS_NAME);
1609             final String uri = getAttributeValue(parser, ATTR_URI);
1610             if ((!TextUtils.isEmpty(packageName)) &amp;&amp; (!TextUtils.isEmpty(className))) {
1611                 ActivityInfo info;
1612                 try {
1613                     ComponentName cn;
1614                     try {
1615                         cn = new ComponentName(packageName, className);
1616                         info = mPackageManager.getActivityInfo(cn, 0);
1617                     } catch (PackageManager nnfe) {
<abbr title="1618                         String[] packages = mPackageManager.currentToCanonicalPackageNames(new String[]{ packageName });">1618                         String[] packages = mPackageManager.currentToCanonicalPackageNames(new String[]{ 🔵</abbr>
1619                         cn = new ComponentName(packages[0], className);
1620                         info = mPackageManager.getActivityInfo(cn, 0);
1621                     }
1622                     final Intent intent = buildMainIntent();
1623                     intent.setComponent(cn);
<abbr title="1624                     intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);">1624                     intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NE🔵</abbr>
<abbr title="1625                     return addAppShortcut(db, values, info.loadLabel(mPackageManager).toString(), intent);">1625                     return addAppShortcut(db, values, info.loadLabel(mPackageManager).toString(), intent)🔵</abbr>
1626                 } catch (PackageManager e) {
1627                     Log.w(TAG, ((&quot;Unable to add favorite: &quot; + packageName) + &quot;/&quot;) + className, e);
1628                 }
1629                 return -1;
1630             } else if (!TextUtils.isEmpty(uri)) {
1631                 // If no component specified try to find a shortcut to add from the URI.
1632                 return addAppShortcutByUri(db, values, uri);
1633             } else {
1634                 Log.e(TAG, &quot;Skipping invalid &lt;favorite&gt; with no component or uri&quot;);
1635                 return -1;
1636             }
1637         }
1638 
<abbr title="1639         private long addAppShortcut(SQLiteDatabase db, ContentValues values, String title, Intent intent) {">1639         private long addAppShortcut(SQLiteDatabase db, ContentValues values, String title, Intent intent)🔵</abbr>
1640             long id = generateNewItemId();
1641             values.put(Favorites.INTENT, intent.toUri(0));
1642             values.put(Favorites.TITLE, title);
1643             values.put(Favorites.ITEM_TYPE, Favorites.ITEM_TYPE_APPLICATION);
1644             values.put(Favorites.SPANX, 1);
1645             values.put(Favorites.SPANY, 1);
1646             values.put(Favorites._ID, id);
1647             if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values) &lt; 0) {
1648                 return -1;
1649             } else {
1650                 return id;
1651             }
1652         }
1653 
1654         private long addFolder(SQLiteDatabase db, ContentValues values) {
1655             values.put(Favorites.ITEM_TYPE, Favorites.ITEM_TYPE_FOLDER);
1656             values.put(Favorites.SPANX, 1);
1657             values.put(Favorites.SPANY, 1);
1658             long id = generateNewItemId();
1659             values.put(Favorites._ID, id);
1660             if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values) &lt;= 0) {
1661                 return -1;
1662             } else {
1663                 return id;
1664             }
1665         }
1666 
1667         private ComponentName getSearchWidgetProvider() {
1668             SearchManager searchManager =
1669                     (SearchManager) mContext.getSystemService(Context.SEARCH_SERVICE);
1670             ComponentName searchComponent = searchManager.getGlobalSearchActivity();
1671             if (searchComponent == null) return null;
1672             return getProviderInPackage(searchComponent.getPackageName());
1673         }
1674 
1675         /**
1676          * Gets an appwidget provider from the given package. If the package contains more than
1677          * one appwidget provider, an arbitrary one is returned.
1678          */
1679         private ComponentName getProviderInPackage(String packageName) {
1680             AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(mContext);
1681             List&lt;AppWidgetProviderInfo&gt; providers = appWidgetManager.getInstalledProviders();
1682             if (providers == null) return null;
1683             final int providerCount = providers.size();
1684             for (int i = 0; i &lt; providerCount; i++) {
1685                 ComponentName provider = providers.get(i).provider;
1686                 if (provider != null &amp;&amp; provider.getPackageName().equals(packageName)) {
1687                     return provider;
1688                 }
1689             }
1690             return null;
1691         }
1692 
<abbr title="1693         private boolean addAppWidget(XmlResourceParser parser, int type, SQLiteDatabase db, ContentValues values) throws XmlPullParserException, IOException {">1693         private boolean addAppWidget(XmlResourceParser parser, int type, SQLiteDatabase db, ContentValues🔵</abbr>
1694             String packageName = getAttributeValue(parser, ATTR_PACKAGE_NAME);
1695             String className = getAttributeValue(parser, ATTR_CLASS_NAME);
1696             if ((packageName == null) || (className == null)) {
1697                 return false;
1698             }
1699             boolean hasPackage = true;
1700             ComponentName cn = new ComponentName(packageName, className);
1701             try {
1702                 mPackageManager.getReceiverInfo(cn, 0);
1703             } catch (java.lang.Exception e) {
<abbr title="1704                 String[] packages = mPackageManager.currentToCanonicalPackageNames(new String[]{ packageName });">1704                 String[] packages = mPackageManager.currentToCanonicalPackageNames(new String[]{ packageN🔵</abbr>
1705                 cn = new ComponentName(packages[0], className);
1706                 try {
1707                     mPackageManager.getReceiverInfo(cn, 0);
1708                 } catch (java.lang.Exception e1) {
1709                     System.out.println(&quot;Can&#x27;t find widget provider: &quot; + className);
1710                     hasPackage = false;
1711                 }
1712             }
1713             if (hasPackage) {
1714                 String spanX = getAttributeValue(parser, ATTR_SPAN_X);
1715                 String spanY = getAttributeValue(parser, ATTR_SPAN_Y);
1716                 values.put(Favorites.SPANX, spanX);
1717                 values.put(Favorites.SPANY, spanY);
1718                 // Read the extras
1719                 Bundle extras = new Bundle();
1720                 int widgetDepth = parser.getDepth();
<abbr title="1721                 while (((type = parser.next()) != XmlPullParser.END_TAG) || (parser.getDepth() &gt; widgetDepth)) {">1721                 while (((type = parser.next()) != XmlPullParser.END_TAG) || (parser.getDepth() &gt; widgetDe🔵</abbr>
1722                     if (type != XmlPullParser.START_TAG) {
1723                         continue;
1724                     }
1725                     if (TAG_EXTRA.equals(parser.getName())) {
1726                         String key = getAttributeValue(parser, ATTR_KEY);
1727                         String value = getAttributeValue(parser, ATTR_VALUE);
1728                         if ((key != null) &amp;&amp; (value != null)) {
1729                             extras.putString(key, value);
1730                         } else {
1731                             throw new RuntimeException(&quot;Widget extras must have a key and value&quot;);
1732                         }
1733                     } else {
1734                         throw new RuntimeException(&quot;Widgets can contain only extras&quot;);
1735                     }
1736                 }
1737                 return addAppWidget(db, values, cn, extras);
1738             }
1739             return false;
1740         }
1741 
<abbr title="1742         private boolean addAppWidget(SQLiteDatabase db, ContentValues values, ComponentName cn, Bundle extras) {">1742         private boolean addAppWidget(SQLiteDatabase db, ContentValues values, ComponentName cn, Bundle ex🔵</abbr>
1743             boolean allocatedAppWidgets = false;
1744             final AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(mContext);
1745             try {
1746                 int appWidgetId = mAppWidgetHost.allocateAppWidgetId();
1747                 values.put(Favorites.ITEM_TYPE, Favorites.ITEM_TYPE_APPWIDGET);
1748                 values.put(Favorites.APPWIDGET_ID, appWidgetId);
1749                 values.put(Favorites.APPWIDGET_PROVIDER, cn.flattenToString());
1750                 values.put(Favorites._ID, generateNewItemId());
1751                 dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values);
1752                 allocatedAppWidgets = true;
1753                 // TODO: need to check return value
1754                 appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId, cn);
1755                 // Send a broadcast to configure the widget
1756                 if ((extras != null) &amp;&amp; (!extras.isEmpty())) {
1757                     Intent intent = new Intent(ACTION_APPWIDGET_DEFAULT_WORKSPACE_CONFIGURE);
1758                     intent.setComponent(cn);
1759                     intent.putExtras(extras);
1760                     intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);
1761                     mContext.sendBroadcast(intent);
1762                 }
1763             } catch (java.lang.RuntimeException ex) {
1764                 Log.e(TAG, &quot;Problem allocating appWidgetId&quot;, ex);
1765             }
1766             return allocatedAppWidgets;
1767         }
1768 
<abbr title="1769         private long addUriShortcut(SQLiteDatabase db, ContentValues values, Resources res, XmlResourceParser parser) {">1769         private long addUriShortcut(SQLiteDatabase db, ContentValues values, Resources res, XmlResourcePa🔵</abbr>
1770             final int iconResId = getAttributeResourceValue(parser, ATTR_ICON, 0);
1771             final int titleResId = getAttributeResourceValue(parser, ATTR_TITLE, 0);
1772             Intent intent;
1773             String uri = null;
1774             try {
1775                 uri = getAttributeValue(parser, ATTR_URI);
1776                 intent = Intent.parseUri(uri, 0);
1777             } catch (URISyntaxException e) {
1778                 Log.w(TAG, &quot;Shortcut has malformed uri: &quot; + uri);
1779                 return -1;// Oh well
1780 
1781             }
1782             if ((iconResId == 0) || (titleResId == 0)) {
1783                 Log.w(TAG, &quot;Shortcut is missing title or icon resource ID&quot;);
1784                 return -1;
1785             }
1786             long id = generateNewItemId();
1787             intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
1788             values.put(Favorites.INTENT, intent.toUri(0));
1789             values.put(Favorites.TITLE, res.getString(titleResId));
1790             values.put(Favorites.ITEM_TYPE, Favorites.ITEM_TYPE_SHORTCUT);
1791             values.put(Favorites.SPANX, 1);
1792             values.put(Favorites.SPANY, 1);
1793             values.put(Favorites.ICON_TYPE, Favorites.ICON_TYPE_RESOURCE);
1794             values.put(Favorites.ICON_PACKAGE, res.getResourcePackageName(iconResId));
1795             values.put(Favorites.ICON_RESOURCE, res.getResourceName(iconResId));
1796             values.put(Favorites._ID, id);
1797             if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values) &lt; 0) {
1798                 return -1;
1799             }
1800             return id;
1801         }
1802 
1803         private void migrateLauncher2Shortcuts(SQLiteDatabase db, Uri uri) {
1804             final ContentResolver resolver = mContext.getContentResolver();
1805             Cursor c = null;
1806             int count = 0;
1807             int curScreen = 0;
1808             try {
1809                 c = resolver.query(uri, null, null, null, &quot;title ASC&quot;);
1810             } catch (java.lang.Exception e) {
1811                 // Ignore
1812             }
1813             // We already have a favorites database in the old provider
1814             if (c != null) {
1815                 try {
1816                     if (c.getCount() &gt; 0) {
1817                         final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
<abbr title="1818                         final int intentIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.INTENT);">1818                         final int intentIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.INTENT🔵</abbr>
1819                         final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
<abbr title="1820                         final int iconTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_TYPE);">1820                         final int iconTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON🔵</abbr>
1821                         final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
<abbr title="1822                         final int iconPackageIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_PACKAGE);">1822                         final int iconPackageIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.I🔵</abbr>
<abbr title="1823                         final int iconResourceIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_RESOURCE);">1823                         final int iconResourceIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.🔵</abbr>
<abbr title="1824                         final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);">1824                         final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CON🔵</abbr>
<abbr title="1825                         final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);">1825                         final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM🔵</abbr>
<abbr title="1826                         final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);">1826                         final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN🔵</abbr>
1827                         final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
1828                         final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
1829                         final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
<abbr title="1830                         final int displayModeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.DISPLAY_MODE);">1830                         final int displayModeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.D🔵</abbr>
1831                         final int profileIndex = c.getColumnIndex(LauncherSettings.Favorites.PROFILE_ID);
1832                         int i = 0;
1833                         int curX = 0;
1834                         int curY = 0;
1835                         final LauncherAppState app = LauncherAppState.getInstance();
1836                         final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1837                         final int width = ((int) (grid.numColumns));
1838                         final int height = ((int) (grid.numRows));
1839                         final int hotseatWidth = ((int) (grid.numHotseatIcons));
1840                         final HashSet&lt;String&gt; seenIntents = new HashSet&lt;String&gt;(c.getCount());
1841                         final ArrayList&lt;ContentValues&gt; shortcuts = new ArrayList&lt;ContentValues&gt;();
1842                         final ArrayList&lt;ContentValues&gt; folders = new ArrayList&lt;ContentValues&gt;();
1843                         final SparseArray&lt;ContentValues&gt; hotseat = new SparseArray&lt;ContentValues&gt;();
1844                         while (c.moveToNext()) {
1845                             final int itemType = c.getInt(itemTypeIndex);
<abbr title="1846                             if (((itemType != Favorites.ITEM_TYPE_APPLICATION) &amp;&amp; (itemType != Favorites.ITEM_TYPE_SHORTCUT)) &amp;&amp; (itemType != Favorites.ITEM_TYPE_FOLDER)) {">1846                             if (((itemType != Favorites.ITEM_TYPE_APPLICATION) &amp;&amp; (itemType != Favorites.🔵</abbr>
1847                                 continue;
1848                             }
1849                             final int cellX = c.getInt(cellXIndex);
1850                             final int cellY = c.getInt(cellYIndex);
1851                             final int screen = c.getInt(screenIndex);
1852                             int container = c.getInt(containerIndex);
1853                             final String intentStr = c.getString(intentIndex);
1854                             UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
1855                             UserHandleCompat userHandle;
1856                             final long userSerialNumber;
1857                             if ((profileIndex != (-1)) &amp;&amp; (!c.isNull(profileIndex))) {
1858                                 userSerialNumber = c.getInt(profileIndex);
1859                                 userHandle = userManager.getUserForSerialNumber(userSerialNumber);
1860                             } else {
1861                                 // Default to the serial number of this user, for older
1862                                 // shortcuts.
1863                                 userHandle = UserHandleCompat.myUserHandle();
1864                                 userSerialNumber = userManager.getSerialNumberForUser(userHandle);
1865                             }
<abbr title="1866                             Launcher.addDumpLog(TAG, ((((((((((&quot;migrating \&quot;&quot; + c.getString(titleIndex)) + &quot;\&quot; (&quot;) + cellX) + &quot;,&quot;) + cellY) + &quot;@&quot;) + LauncherSettings.Favorites.containerToString(container)) + &quot;/&quot;) + screen) + &quot;): &quot;) + intentStr, true);">1866                             Launcher.addDumpLog(TAG, ((((((((((&quot;migrating \&quot;&quot; + c.getString(titleIndex)) 🔵</abbr>
1867                             if (itemType != Favorites.ITEM_TYPE_FOLDER) {
1868                                 final Intent intent;
1869                                 final ComponentName cn;
1870                                 try {
1871                                     intent = Intent.parseUri(intentStr, 0);
1872                                 } catch (URISyntaxException e) {
1873                                     // bogus intent?
1874                                     Launcher.addDumpLog(TAG, &quot;skipping invalid intent uri&quot;, true);
1875                                     continue;
1876                                 }
1877                                 cn = intent.getComponent();
1878                                 if (TextUtils.isEmpty(intentStr)) {
1879                                     // no intent? no icon
1880                                     Launcher.addDumpLog(TAG, &quot;skipping empty intent&quot;, true);
1881                                     continue;
<abbr title="1882                                 } else if ((cn != null) &amp;&amp; (!LauncherModel.isValidPackageActivity(mContext, cn, userHandle))) {">1882                                 } else if ((cn != null) &amp;&amp; (!LauncherModel.isValidPackageActivity(mContex🔵</abbr>
1883                                     // component no longer exists.
<abbr title="1884                                     Launcher.addDumpLog(TAG, &quot;skipping item whose component &quot; + &quot;no longer exists.&quot;, true);">1884                                     Launcher.addDumpLog(TAG, &quot;skipping item whose component &quot; + &quot;no longe🔵</abbr>
1885                                     continue;
1886                                 } else if (container == Favorites.CONTAINER_DESKTOP) {
1887                                     // Dedupe icons directly on the workspace
1888                                     // Canonicalize
1889                                     // the Play Store sets the package parameter, but Launcher
1890                                     // does not, so we clear that out to keep them the same
1891                                     intent.setPackage(null);
1892                                     final String key = intent.toUri(0);
1893                                     if (seenIntents.contains(key)) {
1894                                         Launcher.addDumpLog(TAG, &quot;skipping duplicate&quot;, true);
1895                                         continue;
1896                                     } else {
1897                                         seenIntents.add(key);
1898                                     }
1899                                 }
1900                             }
1901                             ContentValues values = new ContentValues(c.getColumnCount());
1902                             values.put(LauncherSettings.Favorites._ID, c.getInt(idIndex));
1903                             values.put(LauncherSettings.Favorites.INTENT, intentStr);
1904                             values.put(LauncherSettings.Favorites.TITLE, c.getString(titleIndex));
1905                             values.put(LauncherSettings.Favorites.ICON_TYPE, c.getInt(iconTypeIndex));
1906                             values.put(LauncherSettings.Favorites.ICON, c.getBlob(iconIndex));
<abbr title="1907                             values.put(LauncherSettings.Favorites.ICON_PACKAGE, c.getString(iconPackageIndex));">1907                             values.put(LauncherSettings.Favorites.ICON_PACKAGE, c.getString(iconPackageIn🔵</abbr>
<abbr title="1908                             values.put(LauncherSettings.Favorites.ICON_RESOURCE, c.getString(iconResourceIndex));">1908                             values.put(LauncherSettings.Favorites.ICON_RESOURCE, c.getString(iconResource🔵</abbr>
1909                             values.put(LauncherSettings.Favorites.ITEM_TYPE, itemType);
1910                             values.put(LauncherSettings.Favorites.APPWIDGET_ID, -1);
1911                             values.put(LauncherSettings.Favorites.URI, c.getString(uriIndex));
<abbr title="1912                             values.put(LauncherSettings.Favorites.DISPLAY_MODE, c.getInt(displayModeIndex));">1912                             values.put(LauncherSettings.Favorites.DISPLAY_MODE, c.getInt(displayModeIndex🔵</abbr>
1913                             values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
1914                             if (container == Favorites.CONTAINER_HOTSEAT) {
1915                                 hotseat.put(screen, values);
1916                             }
1917                             if (container != Favorites.CONTAINER_DESKTOP) {
1918                                 // In a folder or in the hotseat, preserve position
1919                                 values.put(LauncherSettings.Favorites.SCREEN, screen);
1920                                 values.put(LauncherSettings.Favorites.CELLX, cellX);
1921                                 values.put(LauncherSettings.Favorites.CELLY, cellY);
1922                             } else {
1923                                 // For items contained directly on one of the workspace screen,
1924                                 // we&#x27;ll determine their location (screen, x, y) in a second pass.
1925                             }
1926                             values.put(LauncherSettings.Favorites.CONTAINER, container);
1927                             if (itemType != Favorites.ITEM_TYPE_FOLDER) {
1928                                 shortcuts.add(values);
1929                             } else {
1930                                 folders.add(values);
1931                             }
1932                         }
1933                         // Now that we have all the hotseat icons, let&#x27;s go through them left-right
1934                         // and assign valid locations for them in the new hotseat
1935                         final int N = hotseat.size();
1936                         for (int idx = 0; idx &lt; N; idx++) {
1937                             int hotseatX = hotseat.keyAt(idx);
1938                             ContentValues values = hotseat.valueAt(idx);
1939                             if (hotseatX == grid.hotseatAllAppsRank) {
1940                                 // let&#x27;s drop this in the next available hole in the hotseat
1941                                 while ((++hotseatX) &lt; hotseatWidth) {
1942                                     if (hotseat.get(hotseatX) == null) {
1943                                         // found a spot! move it here
1944                                         values.put(LauncherSettings.Favorites.SCREEN, hotseatX);
1945                                         break;
1946                                     }
1947                                 }
1948                             }
1949                             if (hotseatX &gt;= hotseatWidth) {
1950                                 // no room for you in the hotseat? it&#x27;s off to the desktop with you
<abbr title="1951                                 values.put(LauncherSettings.Favorites.CONTAINER, Favorites.CONTAINER_DESKTOP);">1951                                 values.put(LauncherSettings.Favorites.CONTAINER, Favorites.CONTAINER_DESK🔵</abbr>
1952                             }
1953                         }
1954                         final ArrayList&lt;ContentValues&gt; allItems = new ArrayList&lt;ContentValues&gt;();
1955                         // Folders first
1956                         allItems.addAll(folders);
1957                         // Then shortcuts
1958                         allItems.addAll(shortcuts);
1959                         // Layout all the folders
1960                         for (ContentValues values : allItems) {
<abbr title="1961                             if (values.getAsInteger(LauncherSettings.Favorites.CONTAINER) != Favorites.CONTAINER_DESKTOP) {">1961                             if (values.getAsInteger(LauncherSettings.Favorites.CONTAINER) != Favorites.CO🔵</abbr>
1962                                 // Hotseat items and folder items have already had their
1963                                 // location information set. Nothing to be done here.
1964                                 continue;
1965                             }
1966                             values.put(LauncherSettings.Favorites.SCREEN, curScreen);
1967                             values.put(LauncherSettings.Favorites.CELLX, curX);
1968                             values.put(LauncherSettings.Favorites.CELLY, curY);
1969                             curX = (curX + 1) % width;
1970                             if (curX == 0) {
1971                                 curY = curY + 1;
1972                             }
1973                             // Leave the last row of icons blank on every screen
1974                             if (curY == (height - 1)) {
1975                                 curScreen = ((int) (generateNewScreenId()));
1976                                 curY = 0;
1977                             }
1978                         }
1979                         if (allItems.size() &gt; 0) {
1980                             db.beginTransaction();
1981                             try {
1982                                 for (ContentValues row : allItems) {
1983                                     if (row == null) {
1984                                         continue;
1985                                     }
1986                                     if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, row) &lt; 0) {
1987                                         return;
1988                                     } else {
1989                                         count++;
1990                                     }
1991                                 }
1992                                 db.setTransactionSuccessful();
1993                             } finally {
1994                                 db.endTransaction();
1995                             }
1996                         }
1997                         db.beginTransaction();
1998                         try {
1999                             for (i = 0; i &lt;= curScreen; i++) {
2000                                 final ContentValues values = new ContentValues();
2001                                 values.put(LauncherSettings.WorkspaceScreens._ID, i);
2002                                 values.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
<abbr title="2003                                 if (dbInsertAndCheck(this, db, TABLE_WORKSPACE_SCREENS, null, values) &lt; 0) {">2003                                 if (dbInsertAndCheck(this, db, TABLE_WORKSPACE_SCREENS, null, values) &lt; 0🔵</abbr>
2004                                     return;
2005                                 }
2006                             }
2007                             db.setTransactionSuccessful();
2008                         } finally {
2009                             db.endTransaction();
2010                         }
2011                     }
2012                 } finally {
2013                     c.close();
2014                 }
2015             }
<abbr title="2016             Launcher.addDumpLog(TAG, (((&quot;migrated &quot; + count) + &quot; icons from Launcher2 into &quot;) + (curScreen + 1)) + &quot; screens&quot;, true);">2016             Launcher.addDumpLog(TAG, (((&quot;migrated &quot; + count) + &quot; icons from Launcher2 into &quot;) + (curScree🔵</abbr>
2017             // ensure that new screens are created to hold these icons
2018             setFlagJustLoadedOldDb();
2019             // Update max IDs; very important since we just grabbed IDs from another database
2020             mMaxItemId = initializeMaxItemId(db);
2021             mMaxScreenId = initializeMaxScreenId(db);
2022             if (LOGD) {
2023                 Log.d(TAG, ((&quot;mMaxItemId: &quot; + mMaxItemId) + &quot; mMaxScreenId: &quot;) + mMaxScreenId);
2024             }
2025         }
2026     }
2027 
2028     /**
2029      * Build a query string that will match any row where the column matches
2030      * anything in the values list.
2031      */
2032     private static String buildOrWhereString(String column, int[] values) {
2033         StringBuilder selectWhere = new StringBuilder();
2034         for (int i = values.length - 1; i &gt;= 0; i--) {
2035             selectWhere.append(column).append(&quot;=&quot;).append(values[i]);
2036             if (i &gt; 0) {
2037                 selectWhere.append(&quot; OR &quot;);
2038             }
2039         }
2040         return selectWhere.toString();
2041     }
2042 
2043     /**
2044      * Return attribute value, attempting launcher-specific namespace first
2045      * before falling back to anonymous attribute.
2046      */
2047     private static String getAttributeValue(XmlResourceParser parser, String attribute) {
2048         String value = parser.getAttributeValue(
2049                 &quot;http://schemas.android.com/apk/res-auto/com.android.launcher3&quot;, attribute);
2050         if (value == null) {
2051             value = parser.getAttributeValue(null, attribute);
2052         }
2053         return value;
2054     }
2055 
2056     /**
2057      * Return attribute resource value, attempting launcher-specific namespace
2058      * first before falling back to anonymous attribute.
2059      */
2060     private static int getAttributeResourceValue(XmlResourceParser parser, String attribute,
2061             int defaultValue) {
2062         int value = parser.getAttributeResourceValue(
2063                 &quot;http://schemas.android.com/apk/res-auto/com.android.launcher3&quot;, attribute,
2064                 defaultValue);
2065         if (value == defaultValue) {
2066             value = parser.getAttributeResourceValue(null, attribute, defaultValue);
2067         }
2068         return value;
2069     }
2070 
2071     private static void copyInteger(ContentValues from, ContentValues to, String key) {
2072         to.put(key, from.getAsInteger(key));
2073     }
2074 
2075     static class SqlArguments {
2076         public final String table;
2077 
2078         public final String where;
2079 
2080         public final String[] args;
2081 
2082         SqlArguments(Uri url, String where, String[] args) {
2083             if (url.getPathSegments().size() == 1) {
2084                 this.table = url.getPathSegments().get(0);
2085                 this.where = where;
2086                 this.args = args;
2087             } else if (url.getPathSegments().size() != 2) {
2088                 throw new IllegalArgumentException(&quot;Invalid URI: &quot; + url);
2089             } else if (!TextUtils.isEmpty(where)) {
2090                 throw new UnsupportedOperationException(&quot;WHERE clause not supported: &quot; + url);
2091             } else {
2092                 this.table = url.getPathSegments().get(0);
2093                 this.where = &quot;_id=&quot; + ContentUris.parseId(url);
2094                 this.args = null;
2095             }
2096         }
2097 
2098         SqlArguments(Uri url) {
2099             if (url.getPathSegments().size() == 1) {
2100                 table = url.getPathSegments().get(0);
2101                 where = null;
2102                 args = null;
2103             } else {
2104                 throw new IllegalArgumentException(&quot;Invalid URI: &quot; + url);
2105             }
2106         }
2107     }
2108 
2109     static interface WorkspaceLoader {
2110         /**
2111          *
2112          *
2113          * @param screenIds
2114          * 		A mutable list of screen its
2115          * @return the number of workspace items added.
2116          */
2117         public abstract int loadLayout(SQLiteDatabase db, ArrayList&lt;Long&gt; screenIds);
2118     }
2119 
2120     private static class SimpleWorkspaceLoader implements WorkspaceLoader {
2121         private final Resources mRes;
2122 
2123         private final int mWorkspaceId;
2124 
2125         private final DatabaseHelper mHelper;
2126 
2127         SimpleWorkspaceLoader(DatabaseHelper helper, Resources res, int workspaceId) {
2128             mHelper = helper;
2129             mRes = res;
2130             mWorkspaceId = workspaceId;
2131         }
2132 
2133         @Override
2134         public int loadLayout(SQLiteDatabase db, ArrayList&lt;Long&gt; screenIds) {
2135             return mHelper.loadFavoritesRecursive(db, mRes, mWorkspaceId, screenIds);
2136         }
2137     }
2138 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher3;
  18  
  19  import android.app.SearchManager;
  20  import android.appwidget.AppWidgetHost;
  21  import android.appwidget.AppWidgetManager;
  22  import android.appwidget.AppWidgetProviderInfo;
  23  import android.content.ComponentName;
  24  import android.content.ContentProvider;
  25  import android.content.ContentProviderOperation;
  26  import android.content.ContentProviderResult;
  27  import android.content.ContentResolver;
  28  import android.content.ContentUris;
  29  import android.content.ContentValues;
  30  import android.content.Context;
  31  import android.content.Intent;
  32  import android.content.OperationApplicationException;
  33  import android.content.SharedPreferences;
  34  import android.content.pm.ActivityInfo;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  35 +import android.content.pm.ApplicationInfo;</span>
  36  import android.content.pm.PackageManager;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  37 +import android.content.pm.ResolveInfo;</span>
  38  import android.content.res.Resources;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  39 -import android.content.res.TypedArray;</span>
  40  import android.content.res.XmlResourceParser;
  41  import android.database.Cursor;
  42  import android.database.SQLException;
  43  import android.database.sqlite.SQLiteDatabase;
  44  import android.database.sqlite.SQLiteOpenHelper;
  45  import android.database.sqlite.SQLiteQueryBuilder;
  46  import android.database.sqlite.SQLiteStatement;
  47  import android.graphics.Bitmap;
  48  import android.graphics.BitmapFactory;
  49  import android.net.Uri;
  50  import android.os.Bundle;
  51  import android.provider.Settings;
  52  import android.text.TextUtils;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  53 -import android.util.AttributeSet;</span>
  54  import android.util.Log;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  55 -import android.util.Xml;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  56 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  57 +import android.util.SparseArray;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  58 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  59 +import com.android.launcher3.AutoInstallsLayout.LayoutParserCallback;</span>
  60  import com.android.launcher3.LauncherSettings.Favorites;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  61 +import com.android.launcher3.compat.UserHandleCompat;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  62 +import com.android.launcher3.compat.UserManagerCompat;</span>
  63  import com.android.launcher3.config.ProviderConfig;
  64  
  65  import org.xmlpull.v1.XmlPullParser;
  66  import org.xmlpull.v1.XmlPullParserException;
  67  
  68  import java.io.File;
  69  import java.io.IOException;
  70  import java.net.URISyntaxException;
  71  import java.util.ArrayList;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  72 +import java.util.Collections;</span>
  73  import java.util.HashSet;
  74  import java.util.List;
  75  
  76  public class LauncherProvider extends ContentProvider {
  77      private static final String TAG = &quot;Launcher.LauncherProvider&quot;;
  78      private static final boolean LOGD = false;
  79  
  80      private static final String DATABASE_NAME = &quot;launcher.db&quot;;
  81  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  82 -    private static final int DATABASE_VERSION = 16;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  83 +    private static final int DATABASE_VERSION = 20;</span>
  84  
  85      static final String OLD_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
  86      static final String AUTHORITY = ProviderConfig.AUTHORITY;
  87  
  88      // Should we attempt to load anything from the com.android.launcher2 provider?
  89      static final boolean IMPORT_LAUNCHER2_DATABASE = false;
  90  
  91      static final String TABLE_FAVORITES = &quot;favorites&quot;;
  92      static final String TABLE_WORKSPACE_SCREENS = &quot;workspaceScreens&quot;;
  93      static final String PARAMETER_NOTIFY = &quot;notify&quot;;
  94      static final String UPGRADED_FROM_OLD_DATABASE =
  95              &quot;UPGRADED_FROM_OLD_DATABASE&quot;;
  96      static final String EMPTY_DATABASE_CREATED =
  97              &quot;EMPTY_DATABASE_CREATED&quot;;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  98 -    static final String DEFAULT_WORKSPACE_RESOURCE_ID =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  99 -            &quot;DEFAULT_WORKSPACE_RESOURCE_ID&quot;;</span>
 100  
 101      private static final String ACTION_APPWIDGET_DEFAULT_WORKSPACE_CONFIGURE =
 102              &quot;com.android.launcher.action.APPWIDGET_DEFAULT_WORKSPACE_CONFIGURE&quot;;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 103 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 104 +    private static final String URI_PARAM_IS_EXTERNAL_ADD = &quot;isExternalAdd&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 105 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 106 +    private LauncherProviderChangeListener mListener;</span>
 107  
 108      /**
 109       * {@link Uri} triggered at any registered {@link android.database.ContentObserver} when
 110       * {@link AppWidgetHost#deleteHost()} is called during database creation.
 111       * Use this to recall {@link AppWidgetHost#startListening()} if needed.
 112       */
 113      static final Uri CONTENT_APPWIDGET_RESET_URI =
 114              Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/appWidgetReset&quot;);
 115  
 116      private DatabaseHelper mOpenHelper;
 117      private static boolean sJustLoadedFromOldDb;
 118  
 119      @Override
 120      public boolean onCreate() {
 121          final Context context = getContext();
 122          mOpenHelper = new DatabaseHelper(context);
 123          LauncherAppState.setLauncherProvider(this);
 124          return true;
 125      }
 126  
 127      public boolean wasNewDbCreated() {
 128          return mOpenHelper.wasNewDbCreated();
 129      }
 130  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 131 +    public void setLauncherProviderChangeListener(LauncherProviderChangeListener listener) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 132 +        mListener = listener;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 133 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 134 +</span>
 135      @Override
 136      public String getType(Uri uri) {
 137          SqlArguments args = new SqlArguments(uri, null, null);
 138          if (TextUtils.isEmpty(args.where)) {
 139              return &quot;vnd.android.cursor.dir/&quot; + args.table;
 140          } else {
 141              return &quot;vnd.android.cursor.item/&quot; + args.table;
 142          }
 143      }
 144  
 145      @Override
 146      public Cursor query(Uri uri, String[] projection, String selection,
 147              String[] selectionArgs, String sortOrder) {
 148  
 149          SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 150          SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
 151          qb.setTables(args.table);
 152  
 153          SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 154          Cursor result = qb.query(db, projection, args.where, args.args, null, null, sortOrder);
 155          result.setNotificationUri(getContext().getContentResolver(), uri);
 156  
 157          return result;
 158      }
 159  
 160      private static long dbInsertAndCheck(DatabaseHelper helper,
 161              SQLiteDatabase db, String table, String nullColumnHack, ContentValues values) {
 162          if (values == null) {
 163              throw new RuntimeException(&quot;Error: attempting to insert null values&quot;);
 164          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 165 -        if (!values.containsKey(LauncherSettings.BaseLauncherColumns._ID)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 166 +        if (!values.containsKey(LauncherSettings.ChangeLogColumns._ID)) {</span>
 167              throw new RuntimeException(&quot;Error: attempting to add item without specifying an id&quot;);
 168          }
 169          helper.checkId(table, values);
 170          return db.insert(table, nullColumnHack, values);
 171      }
 172  
 173      private static void deleteId(SQLiteDatabase db, long id) {
 174          Uri uri = LauncherSettings.Favorites.getContentUri(id, false);
 175          SqlArguments args = new SqlArguments(uri, null, null);
 176          db.delete(args.table, args.where, args.args);
 177      }
 178  
 179      @Override
 180      public Uri insert(Uri uri, ContentValues initialValues) {
 181          SqlArguments args = new SqlArguments(uri);
 182  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 183 +        // In very limited cases, we support system|signature permission apps to add to the db</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 184 +        String externalAdd = uri.getQueryParameter(URI_PARAM_IS_EXTERNAL_ADD);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 185 +        if (externalAdd != null &amp;&amp; &quot;true&quot;.equals(externalAdd)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 186 +            if (!mOpenHelper.initializeExternalAdd(initialValues)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 187 +                return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 188 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 189 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 190 +</span>
 191          SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 192          addModifiedTime(initialValues);
 193          final long rowId = dbInsertAndCheck(mOpenHelper, db, args.table, null, initialValues);
 194          if (rowId &lt;= 0) return null;
 195  
 196          uri = ContentUris.withAppendedId(uri, rowId);
 197          sendNotify(uri);
 198  
 199          return uri;
 200      }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 201 +</span>
 202  
 203      @Override
 204      public int bulkInsert(Uri uri, ContentValues[] values) {
 205          SqlArguments args = new SqlArguments(uri);
 206  
 207          SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 208          db.beginTransaction();
 209          try {
 210              int numValues = values.length;
 211              for (int i = 0; i &lt; numValues; i++) {
 212                  addModifiedTime(values[i]);
 213                  if (dbInsertAndCheck(mOpenHelper, db, args.table, null, values[i]) &lt; 0) {
 214                      return 0;
 215                  }
 216              }
 217              db.setTransactionSuccessful();
 218          } finally {
 219              db.endTransaction();
 220          }
 221  
 222          sendNotify(uri);
 223          return values.length;
 224      }
 225  
 226      @Override
 227      public ContentProviderResult[] applyBatch(ArrayList&lt;ContentProviderOperation&gt; operations)
 228              throws OperationApplicationException {
 229          SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 230          db.beginTransaction();
 231          try {
 232              ContentProviderResult[] result =  super.applyBatch(operations);
 233              db.setTransactionSuccessful();
 234              return result;
 235          } finally {
 236              db.endTransaction();
 237          }
 238      }
 239  
 240      @Override
 241      public int delete(Uri uri, String selection, String[] selectionArgs) {
 242          SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 243  
 244          SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 245          int count = db.delete(args.table, args.where, args.args);
 246          if (count &gt; 0) sendNotify(uri);
 247  
 248          return count;
 249      }
 250  
 251      @Override
 252      public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
 253          SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 254  
 255          addModifiedTime(values);
 256          SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 257          int count = db.update(args.table, values, args.where, args.args);
 258          if (count &gt; 0) sendNotify(uri);
 259  
 260          return count;
 261      }
 262  
 263      private void sendNotify(Uri uri) {
 264          String notify = uri.getQueryParameter(PARAMETER_NOTIFY);
 265          if (notify == null || &quot;true&quot;.equals(notify)) {
 266              getContext().getContentResolver().notifyChange(uri, null);
 267          }
 268  
 269          // always notify the backup agent
 270          LauncherBackupAgentHelper.dataChanged(getContext());
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 271 +        if (mListener != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 272 +            mListener.onLauncherProviderChange();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 273 +        }</span>
 274      }
 275  
 276      private void addModifiedTime(ContentValues values) {
 277          values.put(LauncherSettings.ChangeLogColumns.MODIFIED, System.currentTimeMillis());
 278      }
 279  
 280      public long generateNewItemId() {
 281          return mOpenHelper.generateNewItemId();
 282      }
 283  
 284      public void updateMaxItemId(long id) {
 285          mOpenHelper.updateMaxItemId(id);
 286      }
 287  
 288      public long generateNewScreenId() {
 289          return mOpenHelper.generateNewScreenId();
 290      }
 291  
 292      // This is only required one time while loading the workspace during the
 293      // upgrade path, and should never be called from anywhere else.
 294      public void updateMaxScreenId(long maxScreenId) {
 295          mOpenHelper.updateMaxScreenId(maxScreenId);
 296      }
 297  
 298      /**
 299       * @param Should we load the old db for upgrade? first run only.
 300       */
 301      synchronized public boolean justLoadedOldDb() {
 302          String spKey = LauncherAppState.getSharedPreferencesKey();
 303          SharedPreferences sp = getContext().getSharedPreferences(spKey, Context.MODE_PRIVATE);
 304  
 305          boolean loadedOldDb = false || sJustLoadedFromOldDb;
 306  
 307          sJustLoadedFromOldDb = false;
 308          if (sp.getBoolean(UPGRADED_FROM_OLD_DATABASE, false)) {
 309  
 310              SharedPreferences.Editor editor = sp.edit();
 311              editor.remove(UPGRADED_FROM_OLD_DATABASE);
 312              editor.commit();
 313              loadedOldDb = true;
 314          }
 315          return loadedOldDb;
 316      }
 317  
 318      /**
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 319 -     * @param workspaceResId that can be 0 to use default or non-zero for specific resource</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 320 +     * Clears all the data for a fresh start.</span>
 321       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 322 -    synchronized public void loadDefaultFavoritesIfNecessary(int origWorkspaceResId) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 323 +    synchronized public void createEmptyDB() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 324 +        mOpenHelper.createEmptyDB(mOpenHelper.getWritableDatabase());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 325 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 326 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 327 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 328 +     * Loads the default workspace based on the following priority scheme:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 329 +     *   1) From a package provided by play store</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 330 +     *   2) From a partner configuration APK, already in the system image</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 331 +     *   3) The default configuration for the particular device</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 332 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 333 +    synchronized public void loadDefaultFavoritesIfNecessary() {</span>
 334          String spKey = LauncherAppState.getSharedPreferencesKey();
 335          SharedPreferences sp = getContext().getSharedPreferences(spKey, Context.MODE_PRIVATE);
 336  
 337          if (sp.getBoolean(EMPTY_DATABASE_CREATED, false)) {
 338              Log.d(TAG, &quot;loading default workspace&quot;);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 339 -            int workspaceResId = origWorkspaceResId;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 340 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 341 -            // Use default workspace resource if none provided</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 342 -            if (workspaceResId == 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 343 -                workspaceResId =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 344 -                        sp.getInt(DEFAULT_WORKSPACE_RESOURCE_ID, getDefaultWorkspaceResourceId());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 345 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 346 +            WorkspaceLoader loader = AutoInstallsLayout.get(getContext(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 347 +                    mOpenHelper.mAppWidgetHost, mOpenHelper);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 348 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 349 +            if (loader == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 350 +                final Partner partner = Partner.get(getContext().getPackageManager());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 351 +                if (partner != null &amp;&amp; partner.hasDefaultLayout()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 352 +                    final Resources partnerRes = partner.getResources();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 353 +                    int workspaceResId = partnerRes.getIdentifier(Partner.RES_DEFAULT_LAYOUT,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 354 +                            &quot;xml&quot;, partner.getPackageName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 355 +                    if (workspaceResId != 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 356 +                        loader = new SimpleWorkspaceLoader(mOpenHelper, partnerRes, workspaceResId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 357 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 358 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 359 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 360 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 361 +            if (loader == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 362 +                loader = new SimpleWorkspaceLoader(mOpenHelper, getContext().getResources(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 363 +                        getDefaultWorkspaceResourceId());</span>
 364              }
 365  
 366              // Populate favorites table with initial favorites
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 367 -            SharedPreferences.Editor editor = sp.edit();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 368 -            editor.remove(EMPTY_DATABASE_CREATED);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 369 -            if (origWorkspaceResId != 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 370 -                editor.putInt(DEFAULT_WORKSPACE_RESOURCE_ID, origWorkspaceResId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 371 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 372 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 373 -            mOpenHelper.loadFavorites(mOpenHelper.getWritableDatabase(), workspaceResId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 374 -            mOpenHelper.setFlagJustLoadedOldDb();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 375 +            SharedPreferences.Editor editor = sp.edit().remove(EMPTY_DATABASE_CREATED);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 376 +            mOpenHelper.loadFavorites(mOpenHelper.getWritableDatabase(), loader);</span>
 377              editor.commit();
 378          }
 379      }
 380  
 381      public void migrateLauncher2Shortcuts() {
 382          mOpenHelper.migrateLauncher2Shortcuts(mOpenHelper.getWritableDatabase(),
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 383 -                LauncherSettings.Favorites.OLD_CONTENT_URI);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 384 +                Uri.parse(getContext().getString(R.string.old_launcher_provider_uri)));</span>
 385      }
 386  
 387      private static int getDefaultWorkspaceResourceId() {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 388 +        LauncherAppState app = LauncherAppState.getInstance();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 389 +        DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();</span>
 390          if (LauncherAppState.isDisableAllApps()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 391 -            return R.xml.default_workspace_no_all_apps;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 392 +            return grid.defaultNoAllAppsLayoutId;</span>
 393          } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 394 -            return R.xml.default_workspace;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 395 +            return grid.defaultLayoutId;</span>
 396          }
 397      }
 398  
 399      private static interface ContentValuesCallback {
 400          public void onRow(ContentValues values);
 401      }
 402  
 403      private static boolean shouldImportLauncher2Database(Context context) {
 404          boolean isTablet = context.getResources().getBoolean(R.bool.is_tablet);
 405  
 406          // We don&#x27;t import the old databse for tablets, as the grid size has changed.
 407          return !isTablet &amp;&amp; IMPORT_LAUNCHER2_DATABASE;
 408      }
 409  
 410      public void deleteDatabase() {
 411          // Are you sure? (y/n)
 412          final SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 413          final File dbFile = new File(db.getPath());
 414          mOpenHelper.close();
 415          if (dbFile.exists()) {
 416              SQLiteDatabase.deleteDatabase(dbFile);
 417          }
 418          mOpenHelper = new DatabaseHelper(getContext());
 419      }
 420  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 421 -    private static class DatabaseHelper extends SQLiteOpenHelper {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 422 +    private static class DatabaseHelper extends SQLiteOpenHelper implements LayoutParserCallback {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 423 +        private static final String TAG_RESOLVE = &quot;resolve&quot;;</span>
 424          private static final String TAG_FAVORITES = &quot;favorites&quot;;
 425          private static final String TAG_FAVORITE = &quot;favorite&quot;;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 426 -        private static final String TAG_CLOCK = &quot;clock&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 427 -        private static final String TAG_SEARCH = &quot;search&quot;;</span>
 428          private static final String TAG_APPWIDGET = &quot;appwidget&quot;;
 429          private static final String TAG_SHORTCUT = &quot;shortcut&quot;;
 430          private static final String TAG_FOLDER = &quot;folder&quot;;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 431 +        private static final String TAG_PARTNER_FOLDER = &quot;partner-folder&quot;;</span>
 432          private static final String TAG_EXTRA = &quot;extra&quot;;
 433          private static final String TAG_INCLUDE = &quot;include&quot;;
 434  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 435 +        // Style attrs -- &quot;Favorite&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 436 +        private static final String ATTR_CLASS_NAME = &quot;className&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 437 +        private static final String ATTR_PACKAGE_NAME = &quot;packageName&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 438 +        private static final String ATTR_CONTAINER = &quot;container&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 439 +        private static final String ATTR_SCREEN = &quot;screen&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 440 +        private static final String ATTR_X = &quot;x&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 441 +        private static final String ATTR_Y = &quot;y&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 442 +        private static final String ATTR_SPAN_X = &quot;spanX&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 443 +        private static final String ATTR_SPAN_Y = &quot;spanY&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 444 +        private static final String ATTR_ICON = &quot;icon&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 445 +        private static final String ATTR_TITLE = &quot;title&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 446 +        private static final String ATTR_URI = &quot;uri&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 447 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 448 +        // Style attrs -- &quot;Include&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 449 +        private static final String ATTR_WORKSPACE = &quot;workspace&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 450 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 451 +        // Style attrs -- &quot;Extra&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 452 +        private static final String ATTR_KEY = &quot;key&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 453 +        private static final String ATTR_VALUE = &quot;value&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 454 +</span>
 455          private final Context mContext;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 456 +        private final PackageManager mPackageManager;</span>
 457          private final AppWidgetHost mAppWidgetHost;
 458          private long mMaxItemId = -1;
 459          private long mMaxScreenId = -1;
 460  
 461          private boolean mNewDbCreated = false;
 462  
 463          DatabaseHelper(Context context) {
 464              super(context, DATABASE_NAME, null, DATABASE_VERSION);
 465              mContext = context;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 466 +            mPackageManager = context.getPackageManager();</span>
 467              mAppWidgetHost = new AppWidgetHost(context, Launcher.APPWIDGET_HOST_ID);
 468  
 469              // In the case where neither onCreate nor onUpgrade gets called, we read the maxId from
 470              // the DB here
 471              if (mMaxItemId == -1) {
 472                  mMaxItemId = initializeMaxItemId(getWritableDatabase());
 473              }
 474              if (mMaxScreenId == -1) {
 475                  mMaxScreenId = initializeMaxScreenId(getWritableDatabase());
 476              }
 477          }
 478  
 479          public boolean wasNewDbCreated() {
 480              return mNewDbCreated;
 481          }
 482  
 483          /**
 484           * Send notification that we&#x27;ve deleted the {@link AppWidgetHost},
 485           * probably as part of the initial database creation. The receiver may
 486           * want to re-call {@link AppWidgetHost#startListening()} to ensure
 487           * callbacks are correctly set.
 488           */
 489          private void sendAppWidgetResetNotify() {
 490              final ContentResolver resolver = mContext.getContentResolver();
 491              resolver.notifyChange(CONTENT_APPWIDGET_RESET_URI, null);
 492          }
 493  
 494          @Override
 495          public void onCreate(SQLiteDatabase db) {
 496              if (LOGD) Log.d(TAG, &quot;creating new launcher database&quot;);
 497  
 498              mMaxItemId = 1;
 499              mMaxScreenId = 0;
 500              mNewDbCreated = true;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 501 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 502 +            UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 503 +            long userSerialNumber = userManager.getSerialNumberForUser(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 504 +                    UserHandleCompat.myUserHandle());</span>
 505  
 506              db.execSQL(&quot;CREATE TABLE favorites (&quot; +
 507                      &quot;_id INTEGER PRIMARY KEY,&quot; +
 508                      &quot;title TEXT,&quot; +
 509                      &quot;intent TEXT,&quot; +
 510                      &quot;container INTEGER,&quot; +
 511                      &quot;screen INTEGER,&quot; +
 512                      &quot;cellX INTEGER,&quot; +
 513                      &quot;cellY INTEGER,&quot; +
 514                      &quot;spanX INTEGER,&quot; +
 515                      &quot;spanY INTEGER,&quot; +
 516                      &quot;itemType INTEGER,&quot; +
 517                      &quot;appWidgetId INTEGER NOT NULL DEFAULT -1,&quot; +
 518                      &quot;isShortcut INTEGER,&quot; +
 519                      &quot;iconType INTEGER,&quot; +
 520                      &quot;iconPackage TEXT,&quot; +
 521                      &quot;iconResource TEXT,&quot; +
 522                      &quot;icon BLOB,&quot; +
 523                      &quot;uri TEXT,&quot; +
 524                      &quot;displayMode INTEGER,&quot; +
 525                      &quot;appWidgetProvider TEXT,&quot; +
 526                      &quot;modified INTEGER NOT NULL DEFAULT 0,&quot; +
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 527 -                    &quot;restored INTEGER NOT NULL DEFAULT 0&quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 528 +                    &quot;restored INTEGER NOT NULL DEFAULT 0,&quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 529 +                    &quot;profileId INTEGER DEFAULT &quot; + userSerialNumber +</span>
 530                      &quot;);&quot;);
 531              addWorkspacesTable(db);
 532  
 533              // Database was just created, so wipe any previous widgets
 534              if (mAppWidgetHost != null) {
 535                  mAppWidgetHost.deleteHost();
 536                  sendAppWidgetResetNotify();
 537              }
 538  
 539              if (shouldImportLauncher2Database(mContext)) {
 540                  // Try converting the old database
 541                  ContentValuesCallback permuteScreensCb = new ContentValuesCallback() {
 542                      public void onRow(ContentValues values) {
 543                          int container = values.getAsInteger(LauncherSettings.Favorites.CONTAINER);
 544                          if (container == Favorites.CONTAINER_DESKTOP) {
 545                              int screen = values.getAsInteger(LauncherSettings.Favorites.SCREEN);
 546                              screen = (int) upgradeLauncherDb_permuteScreens(screen);
 547                              values.put(LauncherSettings.Favorites.SCREEN, screen);
 548                          }
 549                      }
 550                  };
 551                  Uri uri = Uri.parse(&quot;content://&quot; + Settings.AUTHORITY +
 552                          &quot;/old_favorites?notify=true&quot;);
 553                  if (!convertDatabase(db, uri, permuteScreensCb, true)) {
 554                      // Try and upgrade from the Launcher2 db
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 555 -                    uri = LauncherSettings.Favorites.OLD_CONTENT_URI;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 556 +                    uri = Uri.parse(mContext.getString(R.string.old_launcher_provider_uri));</span>
 557                      if (!convertDatabase(db, uri, permuteScreensCb, false)) {
 558                          // If we fail, then set a flag to load the default workspace
 559                          setFlagEmptyDbCreated();
 560                          return;
 561                      }
 562                  }
 563                  // Right now, in non-default workspace cases, we want to run the final
 564                  // upgrade code (ie. to fix workspace screen indices -&gt; ids, etc.), so
 565                  // set that flag too.
 566                  setFlagJustLoadedOldDb();
 567              } else {
 568                  // Fresh and clean launcher DB.
 569                  mMaxItemId = initializeMaxItemId(db);
 570                  setFlagEmptyDbCreated();
 571              }
 572          }
 573  
 574          private void addWorkspacesTable(SQLiteDatabase db) {
 575              db.execSQL(&quot;CREATE TABLE &quot; + TABLE_WORKSPACE_SCREENS + &quot; (&quot; +
 576                      LauncherSettings.WorkspaceScreens._ID + &quot; INTEGER,&quot; +
 577                      LauncherSettings.WorkspaceScreens.SCREEN_RANK + &quot; INTEGER,&quot; +
 578                      LauncherSettings.ChangeLogColumns.MODIFIED + &quot; INTEGER NOT NULL DEFAULT 0&quot; +
 579                      &quot;);&quot;);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 580 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 581 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 582 +        private void removeOrphanedItems(SQLiteDatabase db) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 583 +            // Delete items directly on the workspace who&#x27;s screen id doesn&#x27;t exist</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 584 +            //  &quot;DELETE FROM favorites WHERE screen NOT IN (SELECT _id FROM workspaceScreens)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 585 +            //   AND container = -100&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 586 +            String removeOrphanedDesktopItems = &quot;DELETE FROM &quot; + TABLE_FAVORITES +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 587 +                    &quot; WHERE &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 588 +                    LauncherSettings.Favorites.SCREEN + &quot; NOT IN (SELECT &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 589 +                    LauncherSettings.WorkspaceScreens._ID + &quot; FROM &quot; + TABLE_WORKSPACE_SCREENS + &quot;)&quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 590 +                    &quot; AND &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 591 +                    LauncherSettings.Favorites.CONTAINER + &quot; = &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 592 +                    LauncherSettings.Favorites.CONTAINER_DESKTOP;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 593 +            db.execSQL(removeOrphanedDesktopItems);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 594 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 595 +            // Delete items contained in folders which no longer exist (after above statement)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 596 +            //  &quot;DELETE FROM favorites  WHERE container &lt;&gt; -100 AND container &lt;&gt; -101 AND container</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 597 +            //   NOT IN (SELECT _id FROM favorites WHERE itemType = 2)&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 598 +            String removeOrphanedFolderItems = &quot;DELETE FROM &quot; + TABLE_FAVORITES +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 599 +                    &quot; WHERE &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 600 +                    LauncherSettings.Favorites.CONTAINER + &quot; &lt;&gt; &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 601 +                    LauncherSettings.Favorites.CONTAINER_DESKTOP +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 602 +                    &quot; AND &quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 603 +                    + LauncherSettings.Favorites.CONTAINER + &quot; &lt;&gt; &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 604 +                    LauncherSettings.Favorites.CONTAINER_HOTSEAT +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 605 +                    &quot; AND &quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 606 +                    + LauncherSettings.Favorites.CONTAINER + &quot; NOT IN (SELECT &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 607 +                    LauncherSettings.Favorites._ID + &quot; FROM &quot; + TABLE_FAVORITES +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 608 +                    &quot; WHERE &quot; + LauncherSettings.Favorites.ITEM_TYPE + &quot; = &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 609 +                    LauncherSettings.Favorites.ITEM_TYPE_FOLDER + &quot;)&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 610 +            db.execSQL(removeOrphanedFolderItems);</span>
 611          }
 612  
 613          private void setFlagJustLoadedOldDb() {
 614              String spKey = LauncherAppState.getSharedPreferencesKey();
 615              SharedPreferences sp = mContext.getSharedPreferences(spKey, Context.MODE_PRIVATE);
 616              SharedPreferences.Editor editor = sp.edit();
 617              editor.putBoolean(UPGRADED_FROM_OLD_DATABASE, true);
 618              editor.putBoolean(EMPTY_DATABASE_CREATED, false);
 619              editor.commit();
 620          }
 621  
 622          private void setFlagEmptyDbCreated() {
 623              String spKey = LauncherAppState.getSharedPreferencesKey();
 624              SharedPreferences sp = mContext.getSharedPreferences(spKey, Context.MODE_PRIVATE);
 625              SharedPreferences.Editor editor = sp.edit();
 626              editor.putBoolean(EMPTY_DATABASE_CREATED, true);
 627              editor.putBoolean(UPGRADED_FROM_OLD_DATABASE, false);
 628              editor.commit();
 629          }
 630  
 631          // We rearrange the screens from the old launcher
 632          // 12345 -&gt; 34512
 633          private long upgradeLauncherDb_permuteScreens(long screen) {
 634              if (screen &gt;= 2) {
 635                  return screen - 2;
 636              } else {
 637                  return screen + 3;
 638              }
 639          }
 640  
 641          private boolean convertDatabase(SQLiteDatabase db, Uri uri,
 642                                          ContentValuesCallback cb, boolean deleteRows) {
 643              if (LOGD) Log.d(TAG, &quot;converting database from an older format, but not onUpgrade&quot;);
 644              boolean converted = false;
 645  
 646              final ContentResolver resolver = mContext.getContentResolver();
 647              Cursor cursor = null;
 648  
 649              try {
 650                  cursor = resolver.query(uri, null, null, null, null);
 651              } catch (Exception e) {
 652                  // Ignore
 653              }
 654  
 655              // We already have a favorites database in the old provider
 656              if (cursor != null) {
 657                  try {
 658                       if (cursor.getCount() &gt; 0) {
 659                          converted = copyFromCursor(db, cursor, cb) &gt; 0;
 660                          if (converted &amp;&amp; deleteRows) {
 661                              resolver.delete(uri, null, null);
 662                          }
 663                      }
 664                  } finally {
 665                      cursor.close();
 666                  }
 667              }
 668  
 669              if (converted) {
 670                  // Convert widgets from this import into widgets
 671                  if (LOGD) Log.d(TAG, &quot;converted and now triggering widget upgrade&quot;);
 672                  convertWidgets(db);
 673  
 674                  // Update max item id
 675                  mMaxItemId = initializeMaxItemId(db);
 676                  if (LOGD) Log.d(TAG, &quot;mMaxItemId: &quot; + mMaxItemId);
 677              }
 678  
 679              return converted;
 680          }
 681  
 682          private int copyFromCursor(SQLiteDatabase db, Cursor c, ContentValuesCallback cb) {
 683              final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
 684              final int intentIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.INTENT);
 685              final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 686              final int iconTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_TYPE);
 687              final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
 688              final int iconPackageIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_PACKAGE);
 689              final int iconResourceIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_RESOURCE);
 690              final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 691              final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 692              final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 693              final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 694              final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 695              final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
 696              final int displayModeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.DISPLAY_MODE);
 697  
 698              ContentValues[] rows = new ContentValues[c.getCount()];
 699              int i = 0;
 700              while (c.moveToNext()) {
 701                  ContentValues values = new ContentValues(c.getColumnCount());
 702                  values.put(LauncherSettings.Favorites._ID, c.getLong(idIndex));
 703                  values.put(LauncherSettings.Favorites.INTENT, c.getString(intentIndex));
 704                  values.put(LauncherSettings.Favorites.TITLE, c.getString(titleIndex));
 705                  values.put(LauncherSettings.Favorites.ICON_TYPE, c.getInt(iconTypeIndex));
 706                  values.put(LauncherSettings.Favorites.ICON, c.getBlob(iconIndex));
 707                  values.put(LauncherSettings.Favorites.ICON_PACKAGE, c.getString(iconPackageIndex));
 708                  values.put(LauncherSettings.Favorites.ICON_RESOURCE, c.getString(iconResourceIndex));
 709                  values.put(LauncherSettings.Favorites.CONTAINER, c.getInt(containerIndex));
 710                  values.put(LauncherSettings.Favorites.ITEM_TYPE, c.getInt(itemTypeIndex));
 711                  values.put(LauncherSettings.Favorites.APPWIDGET_ID, -1);
 712                  values.put(LauncherSettings.Favorites.SCREEN, c.getInt(screenIndex));
 713                  values.put(LauncherSettings.Favorites.CELLX, c.getInt(cellXIndex));
 714                  values.put(LauncherSettings.Favorites.CELLY, c.getInt(cellYIndex));
 715                  values.put(LauncherSettings.Favorites.URI, c.getString(uriIndex));
 716                  values.put(LauncherSettings.Favorites.DISPLAY_MODE, c.getInt(displayModeIndex));
 717                  if (cb != null) {
 718                      cb.onRow(values);
 719                  }
 720                  rows[i++] = values;
 721              }
 722  
 723              int total = 0;
 724              if (i &gt; 0) {
 725                  db.beginTransaction();
 726                  try {
 727                      int numValues = rows.length;
 728                      for (i = 0; i &lt; numValues; i++) {
 729                          if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, rows[i]) &lt; 0) {
 730                              return 0;
 731                          } else {
 732                              total++;
 733                          }
 734                      }
 735                      db.setTransactionSuccessful();
 736                  } finally {
 737                      db.endTransaction();
 738                  }
 739              }
 740  
 741              return total;
 742          }
 743  
 744          @Override
 745          public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 746              if (LOGD) Log.d(TAG, &quot;onUpgrade triggered: &quot; + oldVersion);
 747  
 748              int version = oldVersion;
 749              if (version &lt; 3) {
 750                  // upgrade 1,2 -&gt; 3 added appWidgetId column
 751                  db.beginTransaction();
 752                  try {
 753                      // Insert new column for holding appWidgetIds
 754                      db.execSQL(&quot;ALTER TABLE favorites &quot; +
 755                          &quot;ADD COLUMN appWidgetId INTEGER NOT NULL DEFAULT -1;&quot;);
 756                      db.setTransactionSuccessful();
 757                      version = 3;
 758                  } catch (SQLException ex) {
 759                      // Old version remains, which means we wipe old data
 760                      Log.e(TAG, ex.getMessage(), ex);
 761                  } finally {
 762                      db.endTransaction();
 763                  }
 764  
 765                  // Convert existing widgets only if table upgrade was successful
 766                  if (version == 3) {
 767                      convertWidgets(db);
 768                  }
 769              }
 770  
 771              if (version &lt; 4) {
 772                  version = 4;
 773              }
 774  
 775              // Where&#x27;s version 5?
 776              // - Donut and sholes on 2.0 shipped with version 4 of launcher1.
 777              // - Passion shipped on 2.1 with version 6 of launcher3
 778              // - Sholes shipped on 2.1r1 (aka Mr. 3) with version 5 of launcher 1
 779              //   but version 5 on there was the updateContactsShortcuts change
 780              //   which was version 6 in launcher 2 (first shipped on passion 2.1r1).
 781              // The updateContactsShortcuts change is idempotent, so running it twice
 782              // is okay so we&#x27;ll do that when upgrading the devices that shipped with it.
 783              if (version &lt; 6) {
 784                  // We went from 3 to 5 screens. Move everything 1 to the right
 785                  db.beginTransaction();
 786                  try {
 787                      db.execSQL(&quot;UPDATE favorites SET screen=(screen + 1);&quot;);
 788                      db.setTransactionSuccessful();
 789                  } catch (SQLException ex) {
 790                      // Old version remains, which means we wipe old data
 791                      Log.e(TAG, ex.getMessage(), ex);
 792                  } finally {
 793                      db.endTransaction();
 794                  }
 795  
 796                 // We added the fast track.
 797                  if (updateContactsShortcuts(db)) {
 798                      version = 6;
 799                  }
 800              }
 801  
 802              if (version &lt; 7) {
 803                  // Version 7 gets rid of the special search widget.
 804                  convertWidgets(db);
 805                  version = 7;
 806              }
 807  
 808              if (version &lt; 8) {
 809                  // Version 8 (froyo) has the icons all normalized.  This should
 810                  // already be the case in practice, but we now rely on it and don&#x27;t
 811                  // resample the images each time.
 812                  normalizeIcons(db);
 813                  version = 8;
 814              }
 815  
 816              if (version &lt; 9) {
 817                  // The max id is not yet set at this point (onUpgrade is triggered in the ctor
 818                  // before it gets a change to get set, so we need to read it here when we use it)
 819                  if (mMaxItemId == -1) {
 820                      mMaxItemId = initializeMaxItemId(db);
 821                  }
 822  
 823                  // Add default hotseat icons
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 824 -                loadFavorites(db, R.xml.update_workspace);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 825 +                loadFavorites(db, new SimpleWorkspaceLoader(this, mContext.getResources(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 826 +                        R.xml.update_workspace));</span>
 827                  version = 9;
 828              }
 829  
 830              // We bumped the version three time during JB, once to update the launch flags, once to
 831              // update the override for the default launch animation and once to set the mimetype
 832              // to improve startup performance
 833              if (version &lt; 12) {
 834                  // Contact shortcuts need a different set of flags to be launched now
 835                  // The updateContactsShortcuts change is idempotent, so we can keep using it like
 836                  // back in the Donut days
 837                  updateContactsShortcuts(db);
 838                  version = 12;
 839              }
 840  
 841              if (version &lt; 13) {
 842                  // With the new shrink-wrapped and re-orderable workspaces, it makes sense
 843                  // to persist workspace screens and their relative order.
 844                  mMaxScreenId = 0;
 845  
 846                  // This will never happen in the wild, but when we switch to using workspace
 847                  // screen ids, redo the import from old launcher.
 848                  sJustLoadedFromOldDb = true;
 849  
 850                  addWorkspacesTable(db);
 851                  version = 13;
 852              }
 853  
 854              if (version &lt; 14) {
 855                  db.beginTransaction();
 856                  try {
 857                      // Insert new column for holding widget provider name
 858                      db.execSQL(&quot;ALTER TABLE favorites &quot; +
 859                              &quot;ADD COLUMN appWidgetProvider TEXT;&quot;);
 860                      db.setTransactionSuccessful();
 861                      version = 14;
 862                  } catch (SQLException ex) {
 863                      // Old version remains, which means we wipe old data
 864                      Log.e(TAG, ex.getMessage(), ex);
 865                  } finally {
 866                      db.endTransaction();
 867                  }
 868              }
 869  
 870              if (version &lt; 15) {
 871                  db.beginTransaction();
 872                  try {
 873                      // Insert new column for holding update timestamp
 874                      db.execSQL(&quot;ALTER TABLE favorites &quot; +
 875                              &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;&quot;);
 876                      db.execSQL(&quot;ALTER TABLE workspaceScreens &quot; +
 877                              &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;&quot;);
 878                      db.setTransactionSuccessful();
 879                      version = 15;
 880                  } catch (SQLException ex) {
 881                      // Old version remains, which means we wipe old data
 882                      Log.e(TAG, ex.getMessage(), ex);
 883                  } finally {
 884                      db.endTransaction();
 885                  }
 886              }
 887  
 888  
 889              if (version &lt; 16) {
 890                  db.beginTransaction();
 891                  try {
 892                      // Insert new column for holding restore status
 893                      db.execSQL(&quot;ALTER TABLE favorites &quot; +
 894                              &quot;ADD COLUMN restored INTEGER NOT NULL DEFAULT 0;&quot;);
 895                      db.setTransactionSuccessful();
 896                      version = 16;
 897                  } catch (SQLException ex) {
 898                      // Old version remains, which means we wipe old data
 899                      Log.e(TAG, ex.getMessage(), ex);
 900                  } finally {
 901                      db.endTransaction();
 902                  }
 903              }
 904  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 905 +            if (version &lt; 17) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 906 +                // We use the db version upgrade here to identify users who may not have seen</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 907 +                // clings yet (because they weren&#x27;t available), but for whom the clings are now</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 908 +                // available (tablet users). Because one of the possible cling flows (migration)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 909 +                // is very destructive (wipes out workspaces), we want to prevent this from showing</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 910 +                // until clear data. We do so by marking that the clings have been shown.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 911 +                LauncherClings.synchonouslyMarkFirstRunClingDismissed(mContext);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 912 +                version = 17;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 913 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 914 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 915 +            if (version &lt; 18) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 916 +                // No-op</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 917 +                version = 18;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 918 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 919 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 920 +            if (version &lt; 19) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 921 +                // Due to a data loss bug, some users may have items associated with screen ids</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 922 +                // which no longer exist. Since this can cause other problems, and since the user</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 923 +                // will never see these items anyway, we use database upgrade as an opportunity to</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 924 +                // clean things up.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 925 +                removeOrphanedItems(db);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 926 +                version = 19;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 927 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 928 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 929 +            if (version &lt; 20) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 930 +                // Add userId column</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 931 +                if (addProfileColumn(db)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 932 +                    version = 20;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 933 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 934 +                // else old version remains, which means we wipe old data</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 935 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 936 +</span>
 937              if (version != DATABASE_VERSION) {
 938                  Log.w(TAG, &quot;Destroying all old data.&quot;);
 939                  db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_FAVORITES);
 940                  db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_WORKSPACE_SCREENS);
 941  
 942                  onCreate(db);
 943              }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 944 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 945 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 946 +        @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 947 +        public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 948 +            // This shouldn&#x27;t happen -- throw our hands up in the air and start over.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 949 +            Log.w(TAG, &quot;Database version downgrade from: &quot; + oldVersion + &quot; to &quot; + newVersion +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 950 +                    &quot;. Wiping databse.&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 951 +            createEmptyDB(db);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 952 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 953 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 954 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 955 +        /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 956 +         * Clears all the data for a fresh start.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 957 +         */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 958 +        public void createEmptyDB(SQLiteDatabase db) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 959 +            db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_FAVORITES);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 960 +            db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_WORKSPACE_SCREENS);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 961 +            onCreate(db);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 962 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 963 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 964 +        private boolean addProfileColumn(SQLiteDatabase db) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 965 +            db.beginTransaction();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 966 +            try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 967 +                UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 968 +                // Default to the serial number of this user, for older</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 969 +                // shortcuts.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 970 +                long userSerialNumber = userManager.getSerialNumberForUser(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 971 +                        UserHandleCompat.myUserHandle());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 972 +                // Insert new column for holding user serial number</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 973 +                db.execSQL(&quot;ALTER TABLE favorites &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 974 +                        &quot;ADD COLUMN profileId INTEGER DEFAULT &quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 975 +                                        + userSerialNumber + &quot;;&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 976 +                db.setTransactionSuccessful();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 977 +            } catch (SQLException ex) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 978 +                // Old version remains, which means we wipe old data</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 979 +                Log.e(TAG, ex.getMessage(), ex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 980 +                return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 981 +            } finally {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 982 +                db.endTransaction();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 983 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 984 +            return true;</span>
 985          }
 986  
 987          private boolean updateContactsShortcuts(SQLiteDatabase db) {
 988              final String selectWhere = buildOrWhereString(Favorites.ITEM_TYPE,
 989                      new int[] { Favorites.ITEM_TYPE_SHORTCUT });
 990  
 991              Cursor c = null;
 992              final String actionQuickContact = &quot;com.android.contacts.action.QUICK_CONTACT&quot;;
 993              db.beginTransaction();
 994              try {
 995                  // Select and iterate through each matching widget
 996                  c = db.query(TABLE_FAVORITES,
 997                          new String[] { Favorites._ID, Favorites.INTENT },
 998                          selectWhere, null, null, null, null);
 999                  if (c == null) return false;
1000  
1001                  if (LOGD) Log.d(TAG, &quot;found upgrade cursor count=&quot; + c.getCount());
1002  
1003                  final int idIndex = c.getColumnIndex(Favorites._ID);
1004                  final int intentIndex = c.getColumnIndex(Favorites.INTENT);
1005  
1006                  while (c.moveToNext()) {
1007                      long favoriteId = c.getLong(idIndex);
1008                      final String intentUri = c.getString(intentIndex);
1009                      if (intentUri != null) {
1010                          try {
1011                              final Intent intent = Intent.parseUri(intentUri, 0);
1012                              android.util.Log.d(&quot;Home&quot;, intent.toString());
1013                              final Uri uri = intent.getData();
1014                              if (uri != null) {
1015                                  final String data = uri.toString();
1016                                  if ((Intent.ACTION_VIEW.equals(intent.getAction()) ||
1017                                          actionQuickContact.equals(intent.getAction())) &amp;&amp;
1018                                          (data.startsWith(&quot;content://contacts/people/&quot;) ||
1019                                          data.startsWith(&quot;content://com.android.contacts/&quot; +
1020                                                  &quot;contacts/lookup/&quot;))) {
1021  
1022                                      final Intent newIntent = new Intent(actionQuickContact);
1023                                      // When starting from the launcher, start in a new, cleared task
1024                                      // CLEAR_WHEN_TASK_RESET cannot reset the root of a task, so we
1025                                      // clear the whole thing preemptively here since
1026                                      // QuickContactActivity will finish itself when launching other
1027                                      // detail activities.
1028                                      newIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
1029                                              Intent.FLAG_ACTIVITY_CLEAR_TASK);
1030                                      newIntent.putExtra(
1031                                              Launcher.INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION, true);
1032                                      newIntent.setData(uri);
1033                                      // Determine the type and also put that in the shortcut
1034                                      // (that can speed up launch a bit)
1035                                      newIntent.setDataAndType(uri, newIntent.resolveType(mContext));
1036  
1037                                      final ContentValues values = new ContentValues();
1038                                      values.put(LauncherSettings.Favorites.INTENT,
1039                                              newIntent.toUri(0));
1040  
1041                                      String updateWhere = Favorites._ID + &quot;=&quot; + favoriteId;
1042                                      db.update(TABLE_FAVORITES, values, updateWhere, null);
1043                                  }
1044                              }
1045                          } catch (RuntimeException ex) {
1046                              Log.e(TAG, &quot;Problem upgrading shortcut&quot;, ex);
1047                          } catch (URISyntaxException e) {
1048                              Log.e(TAG, &quot;Problem upgrading shortcut&quot;, e);
1049                          }
1050                      }
1051                  }
1052  
1053                  db.setTransactionSuccessful();
1054              } catch (SQLException ex) {
1055                  Log.w(TAG, &quot;Problem while upgrading contacts&quot;, ex);
1056                  return false;
1057              } finally {
1058                  db.endTransaction();
1059                  if (c != null) {
1060                      c.close();
1061                  }
1062              }
1063  
1064              return true;
1065          }
1066  
1067          private void normalizeIcons(SQLiteDatabase db) {
1068              Log.d(TAG, &quot;normalizing icons&quot;);
1069  
1070              db.beginTransaction();
1071              Cursor c = null;
1072              SQLiteStatement update = null;
1073              try {
1074                  boolean logged = false;
1075                  update = db.compileStatement(&quot;UPDATE favorites &quot;
1076                          + &quot;SET icon=? WHERE _id=?&quot;);
1077  
1078                  c = db.rawQuery(&quot;SELECT _id, icon FROM favorites WHERE iconType=&quot; +
1079                          Favorites.ICON_TYPE_BITMAP, null);
1080  
1081                  final int idIndex = c.getColumnIndexOrThrow(Favorites._ID);
1082                  final int iconIndex = c.getColumnIndexOrThrow(Favorites.ICON);
1083  
1084                  while (c.moveToNext()) {
1085                      long id = c.getLong(idIndex);
1086                      byte[] data = c.getBlob(iconIndex);
1087                      try {
1088                          Bitmap bitmap = Utilities.resampleIconBitmap(
1089                                  BitmapFactory.decodeByteArray(data, 0, data.length),
1090                                  mContext);
1091                          if (bitmap != null) {
1092                              update.bindLong(1, id);
1093                              data = ItemInfo.flattenBitmap(bitmap);
1094                              if (data != null) {
1095                                  update.bindBlob(2, data);
1096                                  update.execute();
1097                              }
1098                              bitmap.recycle();
1099                          }
1100                      } catch (Exception e) {
1101                          if (!logged) {
1102                              Log.e(TAG, &quot;Failed normalizing icon &quot; + id, e);
1103                          } else {
1104                              Log.e(TAG, &quot;Also failed normalizing icon &quot; + id);
1105                          }
1106                          logged = true;
1107                      }
1108                  }
1109                  db.setTransactionSuccessful();
1110              } catch (SQLException ex) {
1111                  Log.w(TAG, &quot;Problem while allocating appWidgetIds for existing widgets&quot;, ex);
1112              } finally {
1113                  db.endTransaction();
1114                  if (update != null) {
1115                      update.close();
1116                  }
1117                  if (c != null) {
1118                      c.close();
1119                  }
1120              }
1121          }
1122  
1123          // Generates a new ID to use for an object in your database. This method should be only
1124          // called from the main UI thread. As an exception, we do call it when we call the
1125          // constructor from the worker thread; however, this doesn&#x27;t extend until after the
1126          // constructor is called, and we only pass a reference to LauncherProvider to LauncherApp
1127          // after that point
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1128 +        @Override</span>
1129          public long generateNewItemId() {
1130              if (mMaxItemId &lt; 0) {
1131                  throw new RuntimeException(&quot;Error: max item id was not initialized&quot;);
1132              }
1133              mMaxItemId += 1;
1134              return mMaxItemId;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1135 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1136 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1137 +        @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1138 +        public long insertAndCheck(SQLiteDatabase db, ContentValues values) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1139 +            return dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values);</span>
1140          }
1141  
1142          public void updateMaxItemId(long id) {
1143              mMaxItemId = id + 1;
1144          }
1145  
1146          public void checkId(String table, ContentValues values) {
1147              long id = values.getAsLong(LauncherSettings.BaseLauncherColumns._ID);
1148              if (table == LauncherProvider.TABLE_WORKSPACE_SCREENS) {
1149                  mMaxScreenId = Math.max(id, mMaxScreenId);
1150              }  else {
1151                  mMaxItemId = Math.max(id, mMaxItemId);
1152              }
1153          }
1154  
1155          private long initializeMaxItemId(SQLiteDatabase db) {
1156              Cursor c = db.rawQuery(&quot;SELECT MAX(_id) FROM favorites&quot;, null);
1157  
1158              // get the result
1159              final int maxIdIndex = 0;
1160              long id = -1;
1161              if (c != null &amp;&amp; c.moveToNext()) {
1162                  id = c.getLong(maxIdIndex);
1163              }
1164              if (c != null) {
1165                  c.close();
1166              }
1167  
1168              if (id == -1) {
1169                  throw new RuntimeException(&quot;Error: could not query max item id&quot;);
1170              }
1171  
1172              return id;
1173          }
1174  
1175          // Generates a new ID to use for an workspace screen in your database. This method
1176          // should be only called from the main UI thread. As an exception, we do call it when we
1177          // call the constructor from the worker thread; however, this doesn&#x27;t extend until after the
1178          // constructor is called, and we only pass a reference to LauncherProvider to LauncherApp
1179          // after that point
1180          public long generateNewScreenId() {
1181              if (mMaxScreenId &lt; 0) {
1182                  throw new RuntimeException(&quot;Error: max screen id was not initialized&quot;);
1183              }
1184              mMaxScreenId += 1;
1185              // Log to disk
1186              Launcher.addDumpLog(TAG, &quot;11683562 - generateNewScreenId(): &quot; + mMaxScreenId, true);
1187              return mMaxScreenId;
1188          }
1189  
1190          public void updateMaxScreenId(long maxScreenId) {
1191              // Log to disk
1192              Launcher.addDumpLog(TAG, &quot;11683562 - updateMaxScreenId(): &quot; + maxScreenId, true);
1193              mMaxScreenId = maxScreenId;
1194          }
1195  
1196          private long initializeMaxScreenId(SQLiteDatabase db) {
<abbr title="1197              Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens._ID + &quot;) FROM &quot; + TABLE_WORKSPACE_SCREENS, null);">1197              Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens._ID + &quot;) FROM &quot; + TABLE_WORKS🔵</abbr>
1198  
1199              // get the result
1200              final int maxIdIndex = 0;
1201              long id = -1;
1202              if (c != null &amp;&amp; c.moveToNext()) {
1203                  id = c.getLong(maxIdIndex);
1204              }
1205              if (c != null) {
1206                  c.close();
1207              }
1208  
1209              if (id == -1) {
1210                  throw new RuntimeException(&quot;Error: could not query max screen id&quot;);
1211              }
1212  
1213              // Log to disk
1214              Launcher.addDumpLog(TAG, &quot;11683562 - initializeMaxScreenId(): &quot; + id, true);
1215              return id;
1216          }
1217  
1218          /**
1219           * Upgrade existing clock and photo frame widgets into their new widget
1220           * equivalents.
1221           */
1222          private void convertWidgets(SQLiteDatabase db) {
1223              final AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(mContext);
1224              final int[] bindSources = new int[] {
1225                      Favorites.ITEM_TYPE_WIDGET_CLOCK,
1226                      Favorites.ITEM_TYPE_WIDGET_PHOTO_FRAME,
1227                      Favorites.ITEM_TYPE_WIDGET_SEARCH,
1228              };
1229  
1230              final String selectWhere = buildOrWhereString(Favorites.ITEM_TYPE, bindSources);
1231  
1232              Cursor c = null;
1233  
1234              db.beginTransaction();
1235              try {
1236                  // Select and iterate through each matching widget
1237                  c = db.query(TABLE_FAVORITES, new String[] { Favorites._ID, Favorites.ITEM_TYPE },
1238                          selectWhere, null, null, null, null);
1239  
1240                  if (LOGD) Log.d(TAG, &quot;found upgrade cursor count=&quot; + c.getCount());
1241  
1242                  final ContentValues values = new ContentValues();
1243                  while (c != null &amp;&amp; c.moveToNext()) {
1244                      long favoriteId = c.getLong(0);
1245                      int favoriteType = c.getInt(1);
1246  
1247                      // Allocate and update database with new appWidgetId
1248                      try {
1249                          int appWidgetId = mAppWidgetHost.allocateAppWidgetId();
1250  
1251                          if (LOGD) {
1252                              Log.d(TAG, &quot;allocated appWidgetId=&quot; + appWidgetId
1253                                      + &quot; for favoriteId=&quot; + favoriteId);
1254                          }
1255                          values.clear();
1256                          values.put(Favorites.ITEM_TYPE, Favorites.ITEM_TYPE_APPWIDGET);
1257                          values.put(Favorites.APPWIDGET_ID, appWidgetId);
1258  
1259                          // Original widgets might not have valid spans when upgrading
1260                          if (favoriteType == Favorites.ITEM_TYPE_WIDGET_SEARCH) {
1261                              values.put(LauncherSettings.Favorites.SPANX, 4);
1262                              values.put(LauncherSettings.Favorites.SPANY, 1);
1263                          } else {
1264                              values.put(LauncherSettings.Favorites.SPANX, 2);
1265                              values.put(LauncherSettings.Favorites.SPANY, 2);
1266                          }
1267  
1268                          String updateWhere = Favorites._ID + &quot;=&quot; + favoriteId;
1269                          db.update(TABLE_FAVORITES, values, updateWhere, null);
1270  
1271                          if (favoriteType == Favorites.ITEM_TYPE_WIDGET_CLOCK) {
1272                              // TODO: check return value
1273                              appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId,
1274                                      new ComponentName(&quot;com.android.alarmclock&quot;,
1275                                      &quot;com.android.alarmclock.AnalogAppWidgetProvider&quot;));
1276                          } else if (favoriteType == Favorites.ITEM_TYPE_WIDGET_PHOTO_FRAME) {
1277                              // TODO: check return value
1278                              appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId,
1279                                      new ComponentName(&quot;com.android.camera&quot;,
1280                                      &quot;com.android.camera.PhotoAppWidgetProvider&quot;));
1281                          } else if (favoriteType == Favorites.ITEM_TYPE_WIDGET_SEARCH) {
1282                              // TODO: check return value
1283                              appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId,
1284                                      getSearchWidgetProvider());
1285                          }
1286                      } catch (RuntimeException ex) {
1287                          Log.e(TAG, &quot;Problem allocating appWidgetId&quot;, ex);
1288                      }
1289                  }
1290  
1291                  db.setTransactionSuccessful();
1292              } catch (SQLException ex) {
1293                  Log.w(TAG, &quot;Problem while allocating appWidgetIds for existing widgets&quot;, ex);
1294              } finally {
1295                  db.endTransaction();
1296                  if (c != null) {
1297                      c.close();
1298                  }
1299              }
1300  
1301              // Update max item id
1302              mMaxItemId = initializeMaxItemId(db);
1303              if (LOGD) Log.d(TAG, &quot;mMaxItemId: &quot; + mMaxItemId);
1304          }
1305  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1306 +        private boolean initializeExternalAdd(ContentValues values) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1307 +            // 1. Ensure that externally added items have a valid item id</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1308 +            long id = generateNewItemId();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1309 +            values.put(LauncherSettings.Favorites._ID, id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1310 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1311 +            // 2. In the case of an app widget, and if no app widget id is specified, we</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1312 +            // attempt allocate and bind the widget.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1313 +            Integer itemType = values.getAsInteger(LauncherSettings.Favorites.ITEM_TYPE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1314 +            if (itemType != null &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1315 +                    itemType.intValue() == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1316 +                    !values.containsKey(LauncherSettings.Favorites.APPWIDGET_ID)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1317 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1318 +                final AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(mContext);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1319 +                ComponentName cn = ComponentName.unflattenFromString(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1320 +                        values.getAsString(Favorites.APPWIDGET_PROVIDER));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1321 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1322 +                if (cn != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1323 +                    try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1324 +                        int appWidgetId = mAppWidgetHost.allocateAppWidgetId();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1325 +                        values.put(LauncherSettings.Favorites.APPWIDGET_ID, appWidgetId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1326 +                        if (!appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId,cn)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1327 +                            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1328 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1329 +                    } catch (RuntimeException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1330 +                        Log.e(TAG, &quot;Failed to initialize external widget&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1331 +                        return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1332 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1333 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1334 +                    return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1335 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1336 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1337 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1338 +            // Add screen id if not present</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1339 +            long screenId = values.getAsLong(LauncherSettings.Favorites.SCREEN);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1340 +            if (!addScreenIdIfNecessary(screenId)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1341 +                return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1342 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1343 +            return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1344 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1345 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1346 +        // Returns true of screen id exists, or if successfully added</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1347 +        private boolean addScreenIdIfNecessary(long screenId) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1348 +            if (!hasScreenId(screenId)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1349 +                int rank = getMaxScreenRank() + 1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1350 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1351 +                ContentValues v = new ContentValues();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1352 +                v.put(LauncherSettings.WorkspaceScreens._ID, screenId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1353 +                v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, rank);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1354 +                if (dbInsertAndCheck(this, getWritableDatabase(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1355 +                        TABLE_WORKSPACE_SCREENS, null, v) &lt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1356 +                    return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1357 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1358 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1359 +            return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1360 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1361 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1362 +        private boolean hasScreenId(long screenId) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1363 +            SQLiteDatabase db = getWritableDatabase();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1364 +            Cursor c = db.rawQuery(&quot;SELECT * FROM &quot; + TABLE_WORKSPACE_SCREENS + &quot; WHERE &quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1365 +                    + LauncherSettings.WorkspaceScreens._ID + &quot; = &quot; + screenId, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1366 +            if (c != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1367 +                int count = c.getCount();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1368 +                c.close();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1369 +                return count &gt; 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1370 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1371 +                return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1372 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1373 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1374 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1375 +        private int getMaxScreenRank() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1376 +            SQLiteDatabase db = getWritableDatabase();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1377 +            Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens.SCREEN_RANK</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1378 +                    + &quot;) FROM &quot; + TABLE_WORKSPACE_SCREENS, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1379 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1380 +            // get the result</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1381 +            final int maxRankIndex = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1382 +            int rank = -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1383 +            if (c != null &amp;&amp; c.moveToNext()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1384 +                rank = c.getInt(maxRankIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1385 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1386 +            if (c != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1387 +                c.close();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1388 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1389 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1390 +            return rank;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1391 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1392 +</span>
1393          private static final void beginDocument(XmlPullParser parser, String firstElementName)
1394                  throws XmlPullParserException, IOException {
1395              int type;
1396              while ((type = parser.next()) != XmlPullParser.START_TAG
1397                      &amp;&amp; type != XmlPullParser.END_DOCUMENT) {
1398                  ;
1399              }
1400  
1401              if (type != XmlPullParser.START_TAG) {
1402                  throw new XmlPullParserException(&quot;No start tag found&quot;);
1403              }
1404  
1405              if (!parser.getName().equals(firstElementName)) {
1406                  throw new XmlPullParserException(&quot;Unexpected start tag: found &quot; + parser.getName() +
1407                          &quot;, expected &quot; + firstElementName);
1408              }
1409          }
1410  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1411 +        private static Intent buildMainIntent() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1412 +            Intent intent = new Intent(Intent.ACTION_MAIN, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1413 +            intent.addCategory(Intent.CATEGORY_LAUNCHER);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1414 +            return intent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1415 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1416 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1417 +        private int loadFavorites(SQLiteDatabase db, WorkspaceLoader loader) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1418 +            ArrayList&lt;Long&gt; screenIds = new ArrayList&lt;Long&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1419 +            // TODO: Use multiple loaders with fall-back and transaction.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1420 +            int count = loader.loadLayout(db, screenIds);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1421 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1422 +            // Add the screens specified by the items above</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1423 +            Collections.sort(screenIds);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1424 +            int rank = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1425 +            ContentValues values = new ContentValues();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1426 +            for (Long id : screenIds) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1427 +                values.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1428 +                values.put(LauncherSettings.WorkspaceScreens._ID, id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1429 +                values.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, rank);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1430 +                if (dbInsertAndCheck(this, db, TABLE_WORKSPACE_SCREENS, null, values) &lt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1431 +                    throw new RuntimeException(&quot;Failed initialize screen table&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1432 +                            + &quot;from default layout&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1433 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1434 +                rank++;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1435 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1436 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1437 +            // Ensure that the max ids are initialized</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1438 +            mMaxItemId = initializeMaxItemId(db);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1439 +            mMaxScreenId = initializeMaxScreenId(db);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1440 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1441 +            return count;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1442 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1443 +</span>
1444          /**
1445           * Loads the default set of favorite packages from an xml file.
1446           *
1447           * @param db The database to write the values into
1448           * @param filterContainerId The specific container id of items to load
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1449 +         * @param the set of screenIds which are used by the favorites</span>
1450           */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1451 -        private int loadFavorites(SQLiteDatabase db, int workspaceResourceId) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1452 -            Intent intent = new Intent(Intent.ACTION_MAIN, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1453 -            intent.addCategory(Intent.CATEGORY_LAUNCHER);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1454 +        private int loadFavoritesRecursive(SQLiteDatabase db, Resources res, int workspaceResourceId,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1455 +                ArrayList&lt;Long&gt; screenIds) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1456 +</span>
1457              ContentValues values = new ContentValues();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1458 -</span>
1459              if (LOGD) Log.v(TAG, String.format(&quot;Loading favorites from resid=0x%08x&quot;, workspaceResourceId));
1460  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1461 -            PackageManager packageManager = mContext.getPackageManager();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1462 -            int i = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1463 +            int count = 0;</span>
1464              try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1465 -                XmlResourceParser parser = mContext.getResources().getXml(workspaceResourceId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1466 -                AttributeSet attrs = Xml.asAttributeSet(parser);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1467 +                XmlResourceParser parser = res.getXml(workspaceResourceId);</span>
1468                  beginDocument(parser, TAG_FAVORITES);
1469  
1470                  final int depth = parser.getDepth();
1471  
1472                  int type;
1473                  while (((type = parser.next()) != XmlPullParser.END_TAG ||
1474                          parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {
1475  
1476                      if (type != XmlPullParser.START_TAG) {
1477                          continue;
1478                      }
1479  
1480                      boolean added = false;
1481                      final String name = parser.getName();
1482  
1483                      if (TAG_INCLUDE.equals(name)) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1484 -                        final TypedArray a = mContext.obtainStyledAttributes(attrs, R.styleable.Include);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1485 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1486 -                        final int resId = a.getResourceId(R.styleable.Include_workspace, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1487 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1488 +                        final int resId = getAttributeResourceValue(parser, ATTR_WORKSPACE, 0);</span>
1489  
1490                          if (LOGD) Log.v(TAG, String.format((&quot;%&quot; + (2*(depth+1)) + &quot;s&lt;include workspace=%08x&gt;&quot;),
1491                                  &quot;&quot;, resId));
1492  
1493                          if (resId != 0 &amp;&amp; resId != workspaceResourceId) {
1494                              // recursively load some more favorites, why not?
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1495 -                            i += loadFavorites(db, resId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1496 +                            count += loadFavoritesRecursive(db, res, resId, screenIds);</span>
1497                              added = false;
1498                          } else {
1499                              Log.w(TAG, String.format(&quot;Skipping &lt;include workspace=0x%08x&gt;&quot;, resId));
1500                          }
1501  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1502 -                        a.recycle();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1503 -</span>
1504                          if (LOGD) Log.v(TAG, String.format((&quot;%&quot; + (2*(depth+1)) + &quot;s&lt;/include&gt;&quot;), &quot;&quot;));
1505                          continue;
1506                      }
1507  
1508                      // Assuming it&#x27;s a &lt;favorite&gt; at this point
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1509 -                    TypedArray a = mContext.obtainStyledAttributes(attrs, R.styleable.Favorite);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1510 -</span>
1511                      long container = LauncherSettings.Favorites.CONTAINER_DESKTOP;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1512 -                    if (a.hasValue(R.styleable.Favorite_container)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1513 -                        container = Long.valueOf(a.getString(R.styleable.Favorite_container));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1514 +                    String strContainer = getAttributeValue(parser, ATTR_CONTAINER);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1515 +                    if (strContainer != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1516 +                        container = Long.valueOf(strContainer);</span>
1517                      }
1518  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1519 -                    String screen = a.getString(R.styleable.Favorite_screen);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1520 -                    String x = a.getString(R.styleable.Favorite_x);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1521 -                    String y = a.getString(R.styleable.Favorite_y);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1522 +                    String screen = getAttributeValue(parser, ATTR_SCREEN);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1523 +                    String x = getAttributeValue(parser, ATTR_X);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1524 +                    String y = getAttributeValue(parser, ATTR_Y);</span>
1525  
1526                      values.clear();
1527                      values.put(LauncherSettings.Favorites.CONTAINER, container);
1528                      values.put(LauncherSettings.Favorites.SCREEN, screen);
1529                      values.put(LauncherSettings.Favorites.CELLX, x);
1530                      values.put(LauncherSettings.Favorites.CELLY, y);
1531  
1532                      if (LOGD) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1533 -                        final String title = a.getString(R.styleable.Favorite_title);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1534 -                        final String pkg = a.getString(R.styleable.Favorite_packageName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1535 +                        final String title = getAttributeValue(parser, ATTR_TITLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1536 +                        final String pkg = getAttributeValue(parser, ATTR_PACKAGE_NAME);</span>
1537                          final String something = title != null ? title : pkg;
1538                          Log.v(TAG, String.format(
1539                                  (&quot;%&quot; + (2*(depth+1)) + &quot;s&lt;%s%s c=%d s=%s x=%s y=%s&gt;&quot;),
1540                                  &quot;&quot;, name,
1541                                  (something == null ? &quot;&quot; : (&quot; \&quot;&quot; + something + &quot;\&quot;&quot;)),
1542                                  container, screen, x, y));
1543                      }
1544  
1545                      if (TAG_FAVORITE.equals(name)) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1546 -                        long id = addAppShortcut(db, values, a, packageManager, intent);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1547 +                        long id = addAppShortcut(db, values, parser);</span>
1548                          added = id &gt;= 0;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1549 -                    } else if (TAG_SEARCH.equals(name)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1550 -                        added = addSearchWidget(db, values);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1551 -                    } else if (TAG_CLOCK.equals(name)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1552 -                        added = addClockWidget(db, values);</span>
1553                      } else if (TAG_APPWIDGET.equals(name)) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1554 -                        added = addAppWidget(parser, attrs, type, db, values, a, packageManager);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1555 +                        added = addAppWidget(parser, type, db, values);</span>
1556                      } else if (TAG_SHORTCUT.equals(name)) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1557 -                        long id = addUriShortcut(db, values, a);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1558 +                        long id = addUriShortcut(db, values, res, parser);</span>
1559                          added = id &gt;= 0;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1560 -                    } else if (TAG_FOLDER.equals(name)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1561 -                        String title;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1562 -                        int titleResId =  a.getResourceId(R.styleable.Favorite_title, -1);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1563 -                        if (titleResId != -1) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1564 -                            title = mContext.getResources().getString(titleResId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1565 -                        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1566 -                            title = mContext.getResources().getString(R.string.folder_name);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1567 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1568 -                        values.put(LauncherSettings.Favorites.TITLE, title);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1569 -                        long folderId = addFolder(db, values);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1570 -                        added = folderId &gt;= 0;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1571 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1572 -                        ArrayList&lt;Long&gt; folderItems = new ArrayList&lt;Long&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1573 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1574 -                        int folderDepth = parser.getDepth();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1575 +                    } else if (TAG_RESOLVE.equals(name)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1576 +                        // This looks through the contained favorites (or meta-favorites) and</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1577 +                        // attempts to add them as shortcuts in the fallback group&#x27;s location</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1578 +                        // until one is added successfully.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1579 +                        added = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1580 +                        final int groupDepth = parser.getDepth();</span>
1581                          while ((type = parser.next()) != XmlPullParser.END_TAG ||
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1582 -                                parser.getDepth() &gt; folderDepth) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1583 +                                parser.getDepth() &gt; groupDepth) {</span>
1584                              if (type != XmlPullParser.START_TAG) {
1585                                  continue;
1586                              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1587 -                            final String folder_item_name = parser.getName();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1588 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1589 -                            TypedArray ar = mContext.obtainStyledAttributes(attrs,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1590 -                                    R.styleable.Favorite);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1591 -                            values.clear();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1592 -                            values.put(LauncherSettings.Favorites.CONTAINER, folderId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1593 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1594 -                            if (LOGD) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1595 -                                final String pkg = ar.getString(R.styleable.Favorite_packageName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1596 -                                final String uri = ar.getString(R.styleable.Favorite_uri);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1597 -                                Log.v(TAG, String.format((&quot;%&quot; + (2*(folderDepth+1)) + &quot;s&lt;%s \&quot;%s\&quot;&gt;&quot;), &quot;&quot;,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1598 -                                        folder_item_name, uri != null ? uri : pkg));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1599 +                            final String fallback_item_name = parser.getName();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1600 +                            if (!added) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1601 +                                if (TAG_FAVORITE.equals(fallback_item_name)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1602 +                                    final long id = addAppShortcut(db, values, parser);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1603 +                                    added = id &gt;= 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1604 +                                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1605 +                                    Log.e(TAG, &quot;Fallback groups can contain only favorites, found &quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1606 +                                            + fallback_item_name);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1607 +                                }</span>
1608                              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1609 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1610 -                            if (TAG_FAVORITE.equals(folder_item_name) &amp;&amp; folderId &gt;= 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1611 -                                long id =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1612 -                                    addAppShortcut(db, values, ar, packageManager, intent);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1613 -                                if (id &gt;= 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1614 -                                    folderItems.add(id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1615 -                                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1616 -                            } else if (TAG_SHORTCUT.equals(folder_item_name) &amp;&amp; folderId &gt;= 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1617 -                                long id = addUriShortcut(db, values, ar);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1618 -                                if (id &gt;= 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1619 -                                    folderItems.add(id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1620 -                                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1621 -                            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1622 -                                throw new RuntimeException(&quot;Folders can &quot; +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1623 -                                        &quot;contain only shortcuts&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1624 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1625 +                    } else if (TAG_FOLDER.equals(name)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1626 +                        // Folder contents are nested in this XML file</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1627 +                        added = loadFolder(db, values, res, parser);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1628 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1629 +                    } else if (TAG_PARTNER_FOLDER.equals(name)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1630 +                        // Folder contents come from an external XML resource</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1631 +                        final Partner partner = Partner.get(mPackageManager);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1632 +                        if (partner != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1633 +                            final Resources partnerRes = partner.getResources();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1634 +                            final int resId = partnerRes.getIdentifier(Partner.RES_FOLDER,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1635 +                                    &quot;xml&quot;, partner.getPackageName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1636 +                            if (resId != 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1637 +                                final XmlResourceParser partnerParser = partnerRes.getXml(resId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1638 +                                beginDocument(partnerParser, TAG_FOLDER);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1639 +                                added = loadFolder(db, values, partnerRes, partnerParser);</span>
1640                              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1641 -                            ar.recycle();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1642 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1643 -                        // We can only have folders with &gt;= 2 items, so we need to remove the</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1644 -                        // folder and clean up if less than 2 items were included, or some</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1645 -                        // failed to add, and less than 2 were actually added</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1646 -                        if (folderItems.size() &lt; 2 &amp;&amp; folderId &gt;= 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1647 -                            // We just delete the folder and any items that made it</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1648 -                            deleteId(db, folderId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1649 -                            if (folderItems.size() &gt; 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1650 -                                deleteId(db, folderItems.get(0));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1651 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1652 -                            added = false;</span>
1653                          }
1654                      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1655 -                    if (added) i++;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1656 -                    a.recycle();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1657 +                    if (added) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1658 +                        long screenId = Long.parseLong(screen);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1659 +                        // Keep track of the set of screens which need to be added to the db.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1660 +                        if (!screenIds.contains(screenId) &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1661 +                                container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1662 +                            screenIds.add(screenId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1663 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1664 +                        count++;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1665 +                    }</span>
1666                  }
1667              } catch (XmlPullParserException e) {
1668                  Log.w(TAG, &quot;Got exception parsing favorites.&quot;, e);
1669              } catch (IOException e) {
1670                  Log.w(TAG, &quot;Got exception parsing favorites.&quot;, e);
1671              } catch (RuntimeException e) {
1672                  Log.w(TAG, &quot;Got exception parsing favorites.&quot;, e);
1673              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1674 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1675 -            // Update the max item id after we have loaded the database</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1676 -            if (mMaxItemId == -1) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1677 -                mMaxItemId = initializeMaxItemId(db);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1678 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1679 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1680 -            return i;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1681 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1682 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1683 -        private long addAppShortcut(SQLiteDatabase db, ContentValues values, TypedArray a,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1684 -                PackageManager packageManager, Intent intent) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1685 -            long id = -1;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1686 -            ActivityInfo info;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1687 -            String packageName = a.getString(R.styleable.Favorite_packageName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1688 -            String className = a.getString(R.styleable.Favorite_className);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1689 +            return count;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1690 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1691 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1692 +        /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1693 +         * Parse folder items starting at {@link XmlPullParser} location. Allow recursive</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1694 +         * includes of items.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1695 +         */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1696 +        private void addToFolder(SQLiteDatabase db, Resources res, XmlResourceParser parser,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1697 +                ArrayList&lt;Long&gt; folderItems, long folderId) throws IOException, XmlPullParserException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1698 +            int type;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1699 +            int folderDepth = parser.getDepth();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1700 +            while ((type = parser.next()) != XmlPullParser.END_TAG ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1701 +                    parser.getDepth() &gt; folderDepth) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1702 +                if (type != XmlPullParser.START_TAG) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1703 +                    continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1704 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1705 +                final String tag = parser.getName();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1706 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1707 +                final ContentValues childValues = new ContentValues();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1708 +                childValues.put(LauncherSettings.Favorites.CONTAINER, folderId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1709 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1710 +                if (LOGD) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1711 +                    final String pkg = getAttributeValue(parser, ATTR_PACKAGE_NAME);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1712 +                    final String uri = getAttributeValue(parser, ATTR_URI);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1713 +                    Log.v(TAG, String.format((&quot;%&quot; + (2*(folderDepth+1)) + &quot;s&lt;%s \&quot;%s\&quot;&gt;&quot;), &quot;&quot;,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1714 +                            tag, uri != null ? uri : pkg));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1715 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1716 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1717 +                if (TAG_FAVORITE.equals(tag) &amp;&amp; folderId &gt;= 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1718 +                    final long id = addAppShortcut(db, childValues, parser);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1719 +                    if (id &gt;= 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1720 +                        folderItems.add(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1721 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1722 +                } else if (TAG_SHORTCUT.equals(tag) &amp;&amp; folderId &gt;= 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1723 +                    final long id = addUriShortcut(db, childValues, res, parser);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1724 +                    if (id &gt;= 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1725 +                        folderItems.add(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1726 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1727 +                } else if (TAG_INCLUDE.equals(tag) &amp;&amp; folderId &gt;= 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1728 +                    addToFolder(db, res, parser, folderItems, folderId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1729 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1730 +                    throw new RuntimeException(&quot;Folders can contain only shortcuts&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1731 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1732 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1733 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1734 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1735 +        /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1736 +         * Parse folder starting at current {@link XmlPullParser} location.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1737 +         */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1738 +        private boolean loadFolder(SQLiteDatabase db, ContentValues values, Resources res,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1739 +                XmlResourceParser parser) throws IOException, XmlPullParserException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1740 +            final String title;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1741 +            final int titleResId = getAttributeResourceValue(parser, ATTR_TITLE, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1742 +            if (titleResId != 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1743 +                title = res.getString(titleResId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1744 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1745 +                title = mContext.getResources().getString(R.string.folder_name);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1746 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1747 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1748 +            values.put(LauncherSettings.Favorites.TITLE, title);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1749 +            long folderId = addFolder(db, values);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1750 +            boolean added = folderId &gt;= 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1751 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1752 +            ArrayList&lt;Long&gt; folderItems = new ArrayList&lt;Long&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1753 +            addToFolder(db, res, parser, folderItems, folderId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1754 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1755 +            // We can only have folders with &gt;= 2 items, so we need to remove the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1756 +            // folder and clean up if less than 2 items were included, or some</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1757 +            // failed to add, and less than 2 were actually added</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1758 +            if (folderItems.size() &lt; 2 &amp;&amp; folderId &gt;= 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1759 +                // Delete the folder</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1760 +                deleteId(db, folderId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1761 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1762 +                // If we have a single item, promote it to where the folder</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1763 +                // would have been.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1764 +                if (folderItems.size() == 1) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1765 +                    final ContentValues childValues = new ContentValues();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1766 +                    copyInteger(values, childValues, LauncherSettings.Favorites.CONTAINER);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1767 +                    copyInteger(values, childValues, LauncherSettings.Favorites.SCREEN);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1768 +                    copyInteger(values, childValues, LauncherSettings.Favorites.CELLX);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1769 +                    copyInteger(values, childValues, LauncherSettings.Favorites.CELLY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1770 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1771 +                    final long id = folderItems.get(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1772 +                    db.update(TABLE_FAVORITES, childValues,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1773 +                            LauncherSettings.Favorites._ID + &quot;=&quot; + id, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1774 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1775 +                    added = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1776 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1777 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1778 +            return added;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1779 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1780 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1781 +        // A meta shortcut attempts to resolve an intent specified as a URI in the XML, if a</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1782 +        // logical choice for what shortcut should be used for that intent exists, then it is</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1783 +        // added. Otherwise add nothing.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1784 +        private long addAppShortcutByUri(SQLiteDatabase db, ContentValues values,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1785 +                String intentUri) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1786 +            Intent metaIntent;</span>
1787              try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1788 -                ComponentName cn;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1789 +                metaIntent = Intent.parseUri(intentUri, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1790 +            } catch (URISyntaxException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1791 +                Log.e(TAG, &quot;Unable to add meta-favorite: &quot; + intentUri, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1792 +                return -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1793 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1794 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1795 +            ResolveInfo resolved = mPackageManager.resolveActivity(metaIntent,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1796 +                    PackageManager.MATCH_DEFAULT_ONLY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1797 +            final List&lt;ResolveInfo&gt; appList = mPackageManager.queryIntentActivities(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1798 +                    metaIntent, PackageManager.MATCH_DEFAULT_ONLY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1799 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1800 +            // Verify that the result is an app and not just the resolver dialog asking which</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1801 +            // app to use.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1802 +            if (wouldLaunchResolverActivity(resolved, appList)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1803 +                // If only one of the results is a system app then choose that as the default.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1804 +                final ResolveInfo systemApp = getSingleSystemActivity(appList);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1805 +                if (systemApp == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1806 +                    // There is no logical choice for this meta-favorite, so rather than making</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1807 +                    // a bad choice just add nothing.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1808 +                    Log.w(TAG, &quot;No preference or single system activity found for &quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1809 +                            + metaIntent.toString());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1810 +                    return -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1811 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1812 +                resolved = systemApp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1813 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1814 +            final ActivityInfo info = resolved.activityInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1815 +            final Intent intent = mPackageManager.getLaunchIntentForPackage(info.packageName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1816 +            if (intent == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1817 +                return -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1818 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1819 +            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1820 +                    Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1821 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1822 +            return addAppShortcut(db, values, info.loadLabel(mPackageManager).toString(), intent);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1823 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1824 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1825 +        private ResolveInfo getSingleSystemActivity(List&lt;ResolveInfo&gt; appList) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1826 +            ResolveInfo systemResolve = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1827 +            final int N = appList.size();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1828 +            for (int i = 0; i &lt; N; ++i) {</span>
1829                  try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1830 -                    cn = new ComponentName(packageName, className);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1831 -                    info = packageManager.getActivityInfo(cn, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1832 -                } catch (PackageManager.NameNotFoundException nnfe) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1833 -                    String[] packages = packageManager.currentToCanonicalPackageNames(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1834 -                        new String[] { packageName });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1835 -                    cn = new ComponentName(packages[0], className);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1836 -                    info = packageManager.getActivityInfo(cn, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1837 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1838 -                id = generateNewItemId();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1839 -                intent.setComponent(cn);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1840 -                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1841 -                        Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1842 -                values.put(Favorites.INTENT, intent.toUri(0));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1843 -                values.put(Favorites.TITLE, info.loadLabel(packageManager).toString());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1844 -                values.put(Favorites.ITEM_TYPE, Favorites.ITEM_TYPE_APPLICATION);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1845 -                values.put(Favorites.SPANX, 1);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1846 -                values.put(Favorites.SPANY, 1);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1847 -                values.put(Favorites._ID, generateNewItemId());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1848 -                if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values) &lt; 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1849 -                    return -1;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1850 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1851 -            } catch (PackageManager.NameNotFoundException e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1852 -                Log.w(TAG, &quot;Unable to add favorite: &quot; + packageName +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1853 -                        &quot;/&quot; + className, e);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1854 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1855 -            return id;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1856 +                    ApplicationInfo info = mPackageManager.getApplicationInfo(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1857 +                            appList.get(i).activityInfo.packageName, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1858 +                    if ((info.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1859 +                        if (systemResolve != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1860 +                            return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1861 +                        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1862 +                            systemResolve = appList.get(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1863 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1864 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1865 +                } catch (PackageManager.NameNotFoundException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1866 +                    Log.w(TAG, &quot;Unable to get info about resolve results&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1867 +                    return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1868 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1869 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1870 +            return systemResolve;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1871 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1872 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1873 +        private boolean wouldLaunchResolverActivity(ResolveInfo resolved,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1874 +                List&lt;ResolveInfo&gt; appList) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1875 +            // If the list contains the above resolved activity, then it can&#x27;t be</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1876 +            // ResolverActivity itself.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1877 +            for (int i = 0; i &lt; appList.size(); ++i) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1878 +                ResolveInfo tmp = appList.get(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1879 +                if (tmp.activityInfo.name.equals(resolved.activityInfo.name)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1880 +                        &amp;&amp; tmp.activityInfo.packageName.equals(resolved.activityInfo.packageName)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1881 +                    return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1882 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1883 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1884 +            return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1885 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1886 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1887 +        private long addAppShortcut(SQLiteDatabase db, ContentValues values,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1888 +                XmlResourceParser parser) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1889 +            final String packageName = getAttributeValue(parser, ATTR_PACKAGE_NAME);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1890 +            final String className = getAttributeValue(parser, ATTR_CLASS_NAME);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1891 +            final String uri = getAttributeValue(parser, ATTR_URI);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1892 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1893 +            if (!TextUtils.isEmpty(packageName) &amp;&amp; !TextUtils.isEmpty(className)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1894 +                ActivityInfo info;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1895 +                try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1896 +                    ComponentName cn;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1897 +                    try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1898 +                        cn = new ComponentName(packageName, className);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1899 +                        info = mPackageManager.getActivityInfo(cn, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1900 +                    } catch (PackageManager.NameNotFoundException nnfe) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1901 +                        String[] packages = mPackageManager.currentToCanonicalPackageNames(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1902 +                                new String[] { packageName });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1903 +                        cn = new ComponentName(packages[0], className);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1904 +                        info = mPackageManager.getActivityInfo(cn, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1905 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1906 +                    final Intent intent = buildMainIntent();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1907 +                    intent.setComponent(cn);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1908 +                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1909 +                            Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1910 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1911 +                    return addAppShortcut(db, values, info.loadLabel(mPackageManager).toString(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1912 +                            intent);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1913 +                } catch (PackageManager.NameNotFoundException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1914 +                    Log.w(TAG, &quot;Unable to add favorite: &quot; + packageName +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1915 +                            &quot;/&quot; + className, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1916 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1917 +                return -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1918 +            } else if (!TextUtils.isEmpty(uri)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1919 +                // If no component specified try to find a shortcut to add from the URI.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1920 +                return addAppShortcutByUri(db, values, uri);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1921 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1922 +                Log.e(TAG, &quot;Skipping invalid &lt;favorite&gt; with no component or uri&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1923 +                return -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1924 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1925 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1926 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1927 +        private long addAppShortcut(SQLiteDatabase db, ContentValues values, String title,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1928 +                Intent intent) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1929 +            long id = generateNewItemId();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1930 +            values.put(Favorites.INTENT, intent.toUri(0));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1931 +            values.put(Favorites.TITLE, title);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1932 +            values.put(Favorites.ITEM_TYPE, Favorites.ITEM_TYPE_APPLICATION);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1933 +            values.put(Favorites.SPANX, 1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1934 +            values.put(Favorites.SPANY, 1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1935 +            values.put(Favorites._ID, id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1936 +            if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values) &lt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1937 +                return -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1938 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1939 +                return id;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1940 +            }</span>
1941          }
1942  
1943          private long addFolder(SQLiteDatabase db, ContentValues values) {
1944              values.put(Favorites.ITEM_TYPE, Favorites.ITEM_TYPE_FOLDER);
1945              values.put(Favorites.SPANX, 1);
1946              values.put(Favorites.SPANY, 1);
1947              long id = generateNewItemId();
1948              values.put(Favorites._ID, id);
1949              if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values) &lt;= 0) {
1950                  return -1;
1951              } else {
1952                  return id;
1953              }
1954          }
1955  
1956          private ComponentName getSearchWidgetProvider() {
1957              SearchManager searchManager =
1958                      (SearchManager) mContext.getSystemService(Context.SEARCH_SERVICE);
1959              ComponentName searchComponent = searchManager.getGlobalSearchActivity();
1960              if (searchComponent == null) return null;
1961              return getProviderInPackage(searchComponent.getPackageName());
1962          }
1963  
1964          /**
1965           * Gets an appwidget provider from the given package. If the package contains more than
1966           * one appwidget provider, an arbitrary one is returned.
1967           */
1968          private ComponentName getProviderInPackage(String packageName) {
1969              AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(mContext);
1970              List&lt;AppWidgetProviderInfo&gt; providers = appWidgetManager.getInstalledProviders();
1971              if (providers == null) return null;
1972              final int providerCount = providers.size();
1973              for (int i = 0; i &lt; providerCount; i++) {
1974                  ComponentName provider = providers.get(i).provider;
1975                  if (provider != null &amp;&amp; provider.getPackageName().equals(packageName)) {
1976                      return provider;
1977                  }
1978              }
1979              return null;
1980          }
1981  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1982 -        private boolean addSearchWidget(SQLiteDatabase db, ContentValues values) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1983 -            ComponentName cn = getSearchWidgetProvider();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1984 -            return addAppWidget(db, values, cn, 4, 1, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1985 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1986 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1987 -        private boolean addClockWidget(SQLiteDatabase db, ContentValues values) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1988 -            ComponentName cn = new ComponentName(&quot;com.android.alarmclock&quot;,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1989 -                    &quot;com.android.alarmclock.AnalogAppWidgetProvider&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1990 -            return addAppWidget(db, values, cn, 2, 2, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1991 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1992 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1993 -        private boolean addAppWidget(XmlResourceParser parser, AttributeSet attrs, int type,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1994 -                SQLiteDatabase db, ContentValues values, TypedArray a,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1995 -                PackageManager packageManager) throws XmlPullParserException, IOException {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1996 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1997 -            String packageName = a.getString(R.styleable.Favorite_packageName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1998 -            String className = a.getString(R.styleable.Favorite_className);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1999 +        private boolean addAppWidget(XmlResourceParser parser, int type,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2000 +                SQLiteDatabase db, ContentValues values)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2001 +                throws XmlPullParserException, IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2002 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2003 +            String packageName = getAttributeValue(parser, ATTR_PACKAGE_NAME);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2004 +            String className = getAttributeValue(parser, ATTR_CLASS_NAME);</span>
2005  
2006              if (packageName == null || className == null) {
2007                  return false;
2008              }
2009  
2010              boolean hasPackage = true;
2011              ComponentName cn = new ComponentName(packageName, className);
2012              try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2013 -                packageManager.getReceiverInfo(cn, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2014 +                mPackageManager.getReceiverInfo(cn, 0);</span>
2015              } catch (Exception e) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2016 -                String[] packages = packageManager.currentToCanonicalPackageNames(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2017 +                String[] packages = mPackageManager.currentToCanonicalPackageNames(</span>
2018                          new String[] { packageName });
2019                  cn = new ComponentName(packages[0], className);
2020                  try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2021 -                    packageManager.getReceiverInfo(cn, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2022 +                    mPackageManager.getReceiverInfo(cn, 0);</span>
2023                  } catch (Exception e1) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2024 +                    System.out.println(&quot;Can&#x27;t find widget provider: &quot; + className);</span>
2025                      hasPackage = false;
2026                  }
2027              }
2028  
2029              if (hasPackage) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2030 -                int spanX = a.getInt(R.styleable.Favorite_spanX, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2031 -                int spanY = a.getInt(R.styleable.Favorite_spanY, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2032 +                String spanX = getAttributeValue(parser, ATTR_SPAN_X);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2033 +                String spanY = getAttributeValue(parser, ATTR_SPAN_Y);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2034 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2035 +                values.put(Favorites.SPANX, spanX);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2036 +                values.put(Favorites.SPANY, spanY);</span>
2037  
2038                  // Read the extras
2039                  Bundle extras = new Bundle();
2040                  int widgetDepth = parser.getDepth();
2041                  while ((type = parser.next()) != XmlPullParser.END_TAG ||
2042                          parser.getDepth() &gt; widgetDepth) {
2043                      if (type != XmlPullParser.START_TAG) {
2044                          continue;
2045                      }
2046  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2047 -                    TypedArray ar = mContext.obtainStyledAttributes(attrs, R.styleable.Extra);</span>
2048                      if (TAG_EXTRA.equals(parser.getName())) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2049 -                        String key = ar.getString(R.styleable.Extra_key);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2050 -                        String value = ar.getString(R.styleable.Extra_value);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2051 +                        String key = getAttributeValue(parser, ATTR_KEY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2052 +                        String value = getAttributeValue(parser, ATTR_VALUE);</span>
2053                          if (key != null &amp;&amp; value != null) {
2054                              extras.putString(key, value);
2055                          } else {
2056                              throw new RuntimeException(&quot;Widget extras must have a key and value&quot;);
2057                          }
2058                      } else {
2059                          throw new RuntimeException(&quot;Widgets can contain only extras&quot;);
2060                      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2061 -                    ar.recycle();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2062 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2063 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2064 -                return addAppWidget(db, values, cn, spanX, spanY, extras);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2065 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2066 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2067 +                return addAppWidget(db, values, cn, extras);</span>
2068              }
2069  
2070              return false;
2071          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2072 +</span>
2073          private boolean addAppWidget(SQLiteDatabase db, ContentValues values, ComponentName cn,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2074 -                int spanX, int spanY, Bundle extras) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2075 +               Bundle extras) {</span>
2076              boolean allocatedAppWidgets = false;
2077              final AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(mContext);
2078  
2079              try {
2080                  int appWidgetId = mAppWidgetHost.allocateAppWidgetId();
2081  
2082                  values.put(Favorites.ITEM_TYPE, Favorites.ITEM_TYPE_APPWIDGET);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2083 -                values.put(Favorites.SPANX, spanX);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2084 -                values.put(Favorites.SPANY, spanY);</span>
2085                  values.put(Favorites.APPWIDGET_ID, appWidgetId);
2086                  values.put(Favorites.APPWIDGET_PROVIDER, cn.flattenToString());
2087                  values.put(Favorites._ID, generateNewItemId());
2088                  dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values);
2089  
2090                  allocatedAppWidgets = true;
2091  
2092                  // TODO: need to check return value
2093                  appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId, cn);
2094  
2095                  // Send a broadcast to configure the widget
2096                  if (extras != null &amp;&amp; !extras.isEmpty()) {
2097                      Intent intent = new Intent(ACTION_APPWIDGET_DEFAULT_WORKSPACE_CONFIGURE);
2098                      intent.setComponent(cn);
2099                      intent.putExtras(extras);
2100                      intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);
2101                      mContext.sendBroadcast(intent);
2102                  }
2103              } catch (RuntimeException ex) {
2104                  Log.e(TAG, &quot;Problem allocating appWidgetId&quot;, ex);
2105              }
2106  
2107              return allocatedAppWidgets;
2108          }
2109  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2110 -        private long addUriShortcut(SQLiteDatabase db, ContentValues values,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2111 -                TypedArray a) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2112 -            Resources r = mContext.getResources();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2113 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2114 -            final int iconResId = a.getResourceId(R.styleable.Favorite_icon, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2115 -            final int titleResId = a.getResourceId(R.styleable.Favorite_title, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2116 +        private long addUriShortcut(SQLiteDatabase db, ContentValues values, Resources res,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2117 +                XmlResourceParser parser) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2118 +            final int iconResId = getAttributeResourceValue(parser, ATTR_ICON, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2119 +            final int titleResId = getAttributeResourceValue(parser, ATTR_TITLE, 0);</span>
2120  
2121              Intent intent;
2122              String uri = null;
2123              try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2124 -                uri = a.getString(R.styleable.Favorite_uri);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2125 +                uri = getAttributeValue(parser, ATTR_URI);</span>
2126                  intent = Intent.parseUri(uri, 0);
2127              } catch (URISyntaxException e) {
2128                  Log.w(TAG, &quot;Shortcut has malformed uri: &quot; + uri);
2129                  return -1; // Oh well
2130              }
2131  
2132              if (iconResId == 0 || titleResId == 0) {
2133                  Log.w(TAG, &quot;Shortcut is missing title or icon resource ID&quot;);
2134                  return -1;
2135              }
2136  
2137              long id = generateNewItemId();
2138              intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
2139              values.put(Favorites.INTENT, intent.toUri(0));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2140 -            values.put(Favorites.TITLE, r.getString(titleResId));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2141 +            values.put(Favorites.TITLE, res.getString(titleResId));</span>
2142              values.put(Favorites.ITEM_TYPE, Favorites.ITEM_TYPE_SHORTCUT);
2143              values.put(Favorites.SPANX, 1);
2144              values.put(Favorites.SPANY, 1);
2145              values.put(Favorites.ICON_TYPE, Favorites.ICON_TYPE_RESOURCE);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2146 -            values.put(Favorites.ICON_PACKAGE, mContext.getPackageName());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2147 -            values.put(Favorites.ICON_RESOURCE, r.getResourceName(iconResId));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2148 +            values.put(Favorites.ICON_PACKAGE, res.getResourcePackageName(iconResId));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2149 +            values.put(Favorites.ICON_RESOURCE, res.getResourceName(iconResId));</span>
2150              values.put(Favorites._ID, id);
2151  
2152              if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values) &lt; 0) {
2153                  return -1;
2154              }
2155              return id;
2156          }
2157  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2158 -        public void migrateLauncher2Shortcuts(SQLiteDatabase db, Uri uri) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2159 +        private void migrateLauncher2Shortcuts(SQLiteDatabase db, Uri uri) {</span>
2160              final ContentResolver resolver = mContext.getContentResolver();
2161              Cursor c = null;
2162              int count = 0;
2163              int curScreen = 0;
2164  
2165              try {
2166                  c = resolver.query(uri, null, null, null, &quot;title ASC&quot;);
2167              } catch (Exception e) {
2168                  // Ignore
2169              }
2170  
2171              // We already have a favorites database in the old provider
2172              if (c != null) {
2173                  try {
2174                      if (c.getCount() &gt; 0) {
2175                          final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
2176                          final int intentIndex
2177                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.INTENT);
2178                          final int titleIndex
2179                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
2180                          final int iconTypeIndex
2181                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_TYPE);
2182                          final int iconIndex
2183                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
2184                          final int iconPackageIndex
2185                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_PACKAGE);
2186                          final int iconResourceIndex
2187                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_RESOURCE);
2188                          final int containerIndex
2189                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
2190                          final int itemTypeIndex
2191                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
2192                          final int screenIndex
2193                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
2194                          final int cellXIndex
2195                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
2196                          final int cellYIndex
2197                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
2198                          final int uriIndex
2199                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
2200                          final int displayModeIndex
2201                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.DISPLAY_MODE);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2202 +                        final int profileIndex</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2203 +                                = c.getColumnIndex(LauncherSettings.Favorites.PROFILE_ID);</span>
2204  
2205                          int i = 0;
2206                          int curX = 0;
2207                          int curY = 0;
2208  
2209                          final LauncherAppState app = LauncherAppState.getInstance();
2210                          final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2211                          final int width = (int) grid.numColumns;
2212                          final int height = (int) grid.numRows;
2213                          final int hotseatWidth = (int) grid.numHotseatIcons;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2214 -                        PackageManager pm = mContext.getPackageManager();</span>
2215  
2216                          final HashSet&lt;String&gt; seenIntents = new HashSet&lt;String&gt;(c.getCount());
2217  
2218                          final ArrayList&lt;ContentValues&gt; shortcuts = new ArrayList&lt;ContentValues&gt;();
2219                          final ArrayList&lt;ContentValues&gt; folders = new ArrayList&lt;ContentValues&gt;();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2220 +                        final SparseArray&lt;ContentValues&gt; hotseat = new SparseArray&lt;ContentValues&gt;();</span>
2221  
2222                          while (c.moveToNext()) {
2223                              final int itemType = c.getInt(itemTypeIndex);
2224                              if (itemType != Favorites.ITEM_TYPE_APPLICATION
2225                                      &amp;&amp; itemType != Favorites.ITEM_TYPE_SHORTCUT
2226                                      &amp;&amp; itemType != Favorites.ITEM_TYPE_FOLDER) {
2227                                  continue;
2228                              }
2229  
2230                              final int cellX = c.getInt(cellXIndex);
2231                              final int cellY = c.getInt(cellYIndex);
2232                              final int screen = c.getInt(screenIndex);
2233                              int container = c.getInt(containerIndex);
2234                              final String intentStr = c.getString(intentIndex);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2235 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2236 +                            UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2237 +                            UserHandleCompat userHandle;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2238 +                            final long userSerialNumber;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2239 +                            if (profileIndex != -1 &amp;&amp; !c.isNull(profileIndex)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2240 +                                userSerialNumber = c.getInt(profileIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2241 +                                userHandle = userManager.getUserForSerialNumber(userSerialNumber);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2242 +                            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2243 +                                // Default to the serial number of this user, for older</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2244 +                                // shortcuts.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2245 +                                userHandle = UserHandleCompat.myUserHandle();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2246 +                                userSerialNumber = userManager.getSerialNumberForUser(userHandle);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2247 +                            }</span>
2248                              Launcher.addDumpLog(TAG, &quot;migrating \&quot;&quot;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2249 -                                + c.getString(titleIndex) + &quot;\&quot;: &quot; + intentStr, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2250 +                                + c.getString(titleIndex) + &quot;\&quot; (&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2251 +                                + cellX + &quot;,&quot; + cellY + &quot;@&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2252 +                                + LauncherSettings.Favorites.containerToString(container)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2253 +                                + &quot;/&quot; + screen</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2254 +                                + &quot;): &quot; + intentStr, true);</span>
2255  
2256                              if (itemType != Favorites.ITEM_TYPE_FOLDER) {
2257  
2258                                  final Intent intent;
2259                                  final ComponentName cn;
2260                                  try {
2261                                      intent = Intent.parseUri(intentStr, 0);
2262                                  } catch (URISyntaxException e) {
2263                                      // bogus intent?
2264                                      Launcher.addDumpLog(TAG,
2265                                              &quot;skipping invalid intent uri&quot;, true);
2266                                      continue;
2267                                  }
2268  
2269                                  cn = intent.getComponent();
2270                                  if (TextUtils.isEmpty(intentStr)) {
2271                                      // no intent? no icon
2272                                      Launcher.addDumpLog(TAG, &quot;skipping empty intent&quot;, true);
2273                                      continue;
2274                                  } else if (cn != null &amp;&amp;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2275 -                                        !LauncherModel.isValidPackageComponent(pm, cn)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2276 +                                        !LauncherModel.isValidPackageActivity(mContext, cn,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2277 +                                                userHandle)) {</span>
2278                                      // component no longer exists.
2279                                      Launcher.addDumpLog(TAG, &quot;skipping item whose component &quot; +
2280                                              &quot;no longer exists.&quot;, true);
2281                                      continue;
2282                                  } else if (container ==
2283                                          LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2284                                      // Dedupe icons directly on the workspace
2285  
2286                                      // Canonicalize
2287                                      // the Play Store sets the package parameter, but Launcher
2288                                      // does not, so we clear that out to keep them the same
2289                                      intent.setPackage(null);
2290                                      final String key = intent.toUri(0);
2291                                      if (seenIntents.contains(key)) {
2292                                          Launcher.addDumpLog(TAG, &quot;skipping duplicate&quot;, true);
2293                                          continue;
2294                                      } else {
2295                                          seenIntents.add(key);
2296                                      }
2297                                  }
2298                              }
2299  
2300                              ContentValues values = new ContentValues(c.getColumnCount());
2301                              values.put(LauncherSettings.Favorites._ID, c.getInt(idIndex));
2302                              values.put(LauncherSettings.Favorites.INTENT, intentStr);
2303                              values.put(LauncherSettings.Favorites.TITLE, c.getString(titleIndex));
2304                              values.put(LauncherSettings.Favorites.ICON_TYPE,
2305                                      c.getInt(iconTypeIndex));
2306                              values.put(LauncherSettings.Favorites.ICON, c.getBlob(iconIndex));
2307                              values.put(LauncherSettings.Favorites.ICON_PACKAGE,
2308                                      c.getString(iconPackageIndex));
2309                              values.put(LauncherSettings.Favorites.ICON_RESOURCE,
2310                                      c.getString(iconResourceIndex));
2311                              values.put(LauncherSettings.Favorites.ITEM_TYPE, itemType);
2312                              values.put(LauncherSettings.Favorites.APPWIDGET_ID, -1);
2313                              values.put(LauncherSettings.Favorites.URI, c.getString(uriIndex));
2314                              values.put(LauncherSettings.Favorites.DISPLAY_MODE,
2315                                      c.getInt(displayModeIndex));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2316 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2317 -                            if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2318 -                                    &amp;&amp; (screen &gt;= hotseatWidth ||</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2319 -                                        screen == grid.hotseatAllAppsRank)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2320 -                                // no room for you in the hotseat? it&#x27;s off to the desktop with you</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2321 -                                container = Favorites.CONTAINER_DESKTOP;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2322 +                            values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2323 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2324 +                            if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2325 +                                hotseat.put(screen, values);</span>
2326                              }
2327  
2328                              if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2329                                  // In a folder or in the hotseat, preserve position
2330                                  values.put(LauncherSettings.Favorites.SCREEN, screen);
2331                                  values.put(LauncherSettings.Favorites.CELLX, cellX);
2332                                  values.put(LauncherSettings.Favorites.CELLY, cellY);
2333                              } else {
2334                                  // For items contained directly on one of the workspace screen,
2335                                  // we&#x27;ll determine their location (screen, x, y) in a second pass.
2336                              }
2337  
2338                              values.put(LauncherSettings.Favorites.CONTAINER, container);
2339  
2340                              if (itemType != Favorites.ITEM_TYPE_FOLDER) {
2341                                  shortcuts.add(values);
2342                              } else {
2343                                  folders.add(values);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2344 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2345 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2346 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2347 +                        // Now that we have all the hotseat icons, let&#x27;s go through them left-right</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2348 +                        // and assign valid locations for them in the new hotseat</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2349 +                        final int N = hotseat.size();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2350 +                        for (int idx=0; idx&lt;N; idx++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2351 +                            int hotseatX = hotseat.keyAt(idx);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2352 +                            ContentValues values = hotseat.valueAt(idx);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2353 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2354 +                            if (hotseatX == grid.hotseatAllAppsRank) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2355 +                                // let&#x27;s drop this in the next available hole in the hotseat</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2356 +                                while (++hotseatX &lt; hotseatWidth) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2357 +                                    if (hotseat.get(hotseatX) == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2358 +                                        // found a spot! move it here</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2359 +                                        values.put(LauncherSettings.Favorites.SCREEN,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2360 +                                                hotseatX);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2361 +                                        break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2362 +                                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2363 +                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2364 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2365 +                            if (hotseatX &gt;= hotseatWidth) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2366 +                                // no room for you in the hotseat? it&#x27;s off to the desktop with you</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2367 +                                values.put(LauncherSettings.Favorites.CONTAINER,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2368 +                                           Favorites.CONTAINER_DESKTOP);</span>
2369                              }
2370                          }
2371  
2372                          final ArrayList&lt;ContentValues&gt; allItems = new ArrayList&lt;ContentValues&gt;();
2373                          // Folders first
2374                          allItems.addAll(folders);
2375                          // Then shortcuts
2376                          allItems.addAll(shortcuts);
2377  
2378                          // Layout all the folders
2379                          for (ContentValues values: allItems) {
2380                              if (values.getAsInteger(LauncherSettings.Favorites.CONTAINER) !=
2381                                      LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2382                                  // Hotseat items and folder items have already had their
2383                                  // location information set. Nothing to be done here.
2384                                  continue;
2385                              }
2386                              values.put(LauncherSettings.Favorites.SCREEN, curScreen);
2387                              values.put(LauncherSettings.Favorites.CELLX, curX);
2388                              values.put(LauncherSettings.Favorites.CELLY, curY);
2389                              curX = (curX + 1) % width;
2390                              if (curX == 0) {
2391                                  curY = (curY + 1);
2392                              }
2393                              // Leave the last row of icons blank on every screen
2394                              if (curY == height - 1) {
2395                                  curScreen = (int) generateNewScreenId();
2396                                  curY = 0;
2397                              }
2398                          }
2399  
2400                          if (allItems.size() &gt; 0) {
2401                              db.beginTransaction();
2402                              try {
2403                                  for (ContentValues row: allItems) {
2404                                      if (row == null) continue;
2405                                      if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, row)
2406                                              &lt; 0) {
2407                                          return;
2408                                      } else {
2409                                          count++;
2410                                      }
2411                                  }
2412                                  db.setTransactionSuccessful();
2413                              } finally {
2414                                  db.endTransaction();
2415                              }
2416                          }
2417  
2418                          db.beginTransaction();
2419                          try {
2420                              for (i=0; i&lt;=curScreen; i++) {
2421                                  final ContentValues values = new ContentValues();
2422                                  values.put(LauncherSettings.WorkspaceScreens._ID, i);
2423                                  values.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
2424                                  if (dbInsertAndCheck(this, db, TABLE_WORKSPACE_SCREENS, null, values)
2425                                          &lt; 0) {
2426                                      return;
2427                                  }
2428                              }
2429                              db.setTransactionSuccessful();
2430                          } finally {
2431                              db.endTransaction();
2432                          }
2433                      }
2434                  } finally {
2435                      c.close();
2436                  }
2437              }
2438  
2439              Launcher.addDumpLog(TAG, &quot;migrated &quot; + count + &quot; icons from Launcher2 into &quot;
2440                      + (curScreen+1) + &quot; screens&quot;, true);
2441  
2442              // ensure that new screens are created to hold these icons
2443              setFlagJustLoadedOldDb();
2444  
2445              // Update max IDs; very important since we just grabbed IDs from another database
2446              mMaxItemId = initializeMaxItemId(db);
2447              mMaxScreenId = initializeMaxScreenId(db);
2448              if (LOGD) Log.d(TAG, &quot;mMaxItemId: &quot; + mMaxItemId + &quot; mMaxScreenId: &quot; + mMaxScreenId);
2449          }
2450      }
2451  
2452      /**
2453       * Build a query string that will match any row where the column matches
2454       * anything in the values list.
2455       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2456 -    static String buildOrWhereString(String column, int[] values) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2457 +    private static String buildOrWhereString(String column, int[] values) {</span>
2458          StringBuilder selectWhere = new StringBuilder();
2459          for (int i = values.length - 1; i &gt;= 0; i--) {
2460              selectWhere.append(column).append(&quot;=&quot;).append(values[i]);
2461              if (i &gt; 0) {
2462                  selectWhere.append(&quot; OR &quot;);
2463              }
2464          }
2465          return selectWhere.toString();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2466 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2467 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2468 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2469 +     * Return attribute value, attempting launcher-specific namespace first</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2470 +     * before falling back to anonymous attribute.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2471 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2472 +    private static String getAttributeValue(XmlResourceParser parser, String attribute) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2473 +        String value = parser.getAttributeValue(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2474 +                &quot;http://schemas.android.com/apk/res-auto/com.android.launcher3&quot;, attribute);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2475 +        if (value == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2476 +            value = parser.getAttributeValue(null, attribute);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2477 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2478 +        return value;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2479 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2480 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2481 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2482 +     * Return attribute resource value, attempting launcher-specific namespace</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2483 +     * first before falling back to anonymous attribute.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2484 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2485 +    private static int getAttributeResourceValue(XmlResourceParser parser, String attribute,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2486 +            int defaultValue) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2487 +        int value = parser.getAttributeResourceValue(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2488 +                &quot;http://schemas.android.com/apk/res-auto/com.android.launcher3&quot;, attribute,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2489 +                defaultValue);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2490 +        if (value == defaultValue) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2491 +            value = parser.getAttributeResourceValue(null, attribute, defaultValue);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2492 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2493 +        return value;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2494 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2495 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2496 +    private static void copyInteger(ContentValues from, ContentValues to, String key) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2497 +        to.put(key, from.getAsInteger(key));</span>
2498      }
2499  
2500      static class SqlArguments {
2501          public final String table;
2502          public final String where;
2503          public final String[] args;
2504  
2505          SqlArguments(Uri url, String where, String[] args) {
2506              if (url.getPathSegments().size() == 1) {
2507                  this.table = url.getPathSegments().get(0);
2508                  this.where = where;
2509                  this.args = args;
2510              } else if (url.getPathSegments().size() != 2) {
2511                  throw new IllegalArgumentException(&quot;Invalid URI: &quot; + url);
2512              } else if (!TextUtils.isEmpty(where)) {
2513                  throw new UnsupportedOperationException(&quot;WHERE clause not supported: &quot; + url);
2514              } else {
2515                  this.table = url.getPathSegments().get(0);
2516                  this.where = &quot;_id=&quot; + ContentUris.parseId(url);
2517                  this.args = null;
2518              }
2519          }
2520  
2521          SqlArguments(Uri url) {
2522              if (url.getPathSegments().size() == 1) {
2523                  table = url.getPathSegments().get(0);
2524                  where = null;
2525                  args = null;
2526              } else {
2527                  throw new IllegalArgumentException(&quot;Invalid URI: &quot; + url);
2528              }
2529          }
2530      }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2531 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2532 +    static interface WorkspaceLoader {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2533 +        /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2534 +         * @param screenIds A mutable list of screen its</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2535 +         * @return the number of workspace items added.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2536 +         */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2537 +        int loadLayout(SQLiteDatabase db, ArrayList&lt;Long&gt; screenIds);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2538 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2539 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2540 +    private static class SimpleWorkspaceLoader implements WorkspaceLoader {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2541 +        private final Resources mRes;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2542 +        private final int mWorkspaceId;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2543 +        private final DatabaseHelper mHelper;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2544 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2545 +        SimpleWorkspaceLoader(DatabaseHelper helper, Resources res, int workspaceId) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2546 +            mHelper = helper;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2547 +            mRes = res;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2548 +            mWorkspaceId = workspaceId;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2549 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2550 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2551 +        @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2552 +        public int loadLayout(SQLiteDatabase db, ArrayList&lt;Long&gt; screenIds) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2553 +            return mHelper.loadFavoritesRecursive(db, mRes, mWorkspaceId, screenIds);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2554 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2555 +    }</span>
2556  }</pre></td>
                            <td><pre></pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            