<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>140 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        if ((currentProfile.allappsRank &gt;= &#x27;
                         &#x27;oldProfile.allappsRank)\n&#x27;
                         &#x27;                &amp;&amp; ((currentProfile.hotseatCount - &#x27;
                         &#x27;currentProfile.allappsRank) &gt;=\n&#x27;
                         &#x27;                        (oldProfile.hotseatCount - &#x27;
                         &#x27;oldProfile.allappsRank))) {\n&#x27;
                         &#x27;            // There is enough space on both sides &#x27;
                         &#x27;of the hotseat.\n&#x27;
                         &#x27;            isHotseatCompatible = true;\n&#x27;
                         &#x27;            mHotseatShift = &#x27;
                         &#x27;currentProfile.allappsRank - &#x27;
                         &#x27;oldProfile.allappsRank;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if (!isHotseatCompatible) {\n&#x27;
                         &#x27;            return false;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if ((currentProfile.desktopCols &gt;= &#x27;
                         &#x27;oldProfile.desktopCols)\n&#x27;
                         &#x27;                &amp;&amp; (currentProfile.desktopRows &gt;= &#x27;
                         &#x27;oldProfile.desktopRows)) {\n&#x27;
                         &#x27;            return true;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if (MigrateFromRestoreTask.ENABLED &amp;&amp;\n&#x27;
                         &#x27;                (oldProfile.desktopCols - &#x27;
                         &#x27;currentProfile.desktopCols &lt;= 1) &amp;&amp;\n&#x27;
                         &#x27;                (oldProfile.desktopRows - &#x27;
                         &#x27;currentProfile.desktopRows &lt;= 1)) {\n&#x27;
                         &#x27;            // Allow desktop migration when row &#x27;
                         &#x27;and/or column count contracts by 1.\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            migrationCompatibleProfileData = &#x27;
                         &#x27;initDeviceProfileData(mIdp);\n&#x27;
                         &#x27;            &#x27;
                         &#x27;migrationCompatibleProfileData.desktopCols = &#x27;
                         &#x27;oldProfile.desktopCols;\n&#x27;
                         &#x27;            &#x27;
                         &#x27;migrationCompatibleProfileData.desktopRows = &#x27;
                         &#x27;oldProfile.desktopRows;\n&#x27;
                         &#x27;            return true;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return false;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        out.key = &#x27;
                           &#x27;keys.toArray(BackupProtos.Key.emptyArray());\n&#x27;
                           &#x27;        writeJournal(newState, out);\n&#x27;
                           &#x27;        Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes &#x27;
                           &#x27;+ &quot;b in &quot; + out.rows + &quot; rows.&quot;);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    private DeviceProfieData &#x27;
                         &#x27;initDeviceProfileData(InvariantDeviceProfile &#x27;
                         &#x27;profile) {\n&#x27;
                         &#x27;        DeviceProfieData data = new &#x27;
                         &#x27;DeviceProfieData();\n&#x27;
                         &#x27;        data.desktopRows = profile.numRows;\n&#x27;
                         &#x27;        data.desktopCols = profile.numColumns;\n&#x27;
                         &#x27;        data.hotseatCount = &#x27;
                         &#x27;profile.numHotseatIcons;\n&#x27;
                         &#x27;        data.allappsRank = &#x27;
                         &#x27;profile.hotseatAllAppsRank;\n&#x27;
                         &#x27;        return data;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        // clear the output journal time, to force &#x27;
                           &#x27;a full backup to\n&#x27;
                           &#x27;        // will catch any changes the restore &#x27;
                           &#x27;process might have made\n&#x27;
                           &#x27;        Journal out = new Journal();\n&#x27;
                           &#x27;        out.t = 0;\n&#x27;
                           &#x27;        out.key = &#x27;
                           &#x27;mKeys.toArray(BackupProtos.Key.emptyArray());\n&#x27;
                           &#x27;        writeJournal(newState, out);\n&#x27;
                           &#x27;        Log.v(TAG, &quot;onRestore: read &quot; + &#x27;
                           &#x27;mKeys.size() + &quot; rows&quot;);\n&#x27;
                           &#x27;        mKeys.clear();\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        if ((currentProfile.allappsRank &gt;= &#x27;
                         &#x27;oldProfile.allappsRank)\n&#x27;
                         &#x27;                &amp;&amp; ((currentProfile.hotseatCount - &#x27;
                         &#x27;currentProfile.allappsRank) &gt;=\n&#x27;
                         &#x27;                        (oldProfile.hotseatCount - &#x27;
                         &#x27;oldProfile.allappsRank))) {\n&#x27;
                         &#x27;            // There is enough space on both sides &#x27;
                         &#x27;of the hotseat.\n&#x27;
                         &#x27;            isHotseatCompatible = true;\n&#x27;
                         &#x27;            mHotseatShift = &#x27;
                         &#x27;currentProfile.allappsRank - &#x27;
                         &#x27;oldProfile.allappsRank;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if (!isHotseatCompatible) {\n&#x27;
                         &#x27;            return false;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if ((currentProfile.desktopCols &gt;= &#x27;
                         &#x27;oldProfile.desktopCols)\n&#x27;
                         &#x27;                &amp;&amp; (currentProfile.desktopRows &gt;= &#x27;
                         &#x27;oldProfile.desktopRows)) {\n&#x27;
                         &#x27;            return true;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if (MigrateFromRestoreTask.ENABLED &amp;&amp;\n&#x27;
                         &#x27;                (oldProfile.desktopCols - &#x27;
                         &#x27;currentProfile.desktopCols &lt;= 1) &amp;&amp;\n&#x27;
                         &#x27;                (oldProfile.desktopRows - &#x27;
                         &#x27;currentProfile.desktopRows &lt;= 1)) {\n&#x27;
                         &#x27;            // Allow desktop migration when row &#x27;
                         &#x27;and/or column count contracts by 1.\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            migrationCompatibleProfileData = &#x27;
                         &#x27;initDeviceProfileData(mIdp);\n&#x27;
                         &#x27;            &#x27;
                         &#x27;migrationCompatibleProfileData.desktopCols = &#x27;
                         &#x27;oldProfile.desktopCols;\n&#x27;
                         &#x27;            &#x27;
                         &#x27;migrationCompatibleProfileData.desktopRows = &#x27;
                         &#x27;oldProfile.desktopRows;\n&#x27;
                         &#x27;            return true;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return false;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        out.key = &#x27;
                           &#x27;keys.toArray(BackupProtos.Key.emptyArray());\n&#x27;
                           &#x27;        writeJournal(newState, out);\n&#x27;
                           &#x27;        Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes &#x27;
                           &#x27;+ &quot;b in &quot; + out.rows + &quot; rows.&quot;);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    private DeviceProfieData &#x27;
                         &#x27;initDeviceProfileData(InvariantDeviceProfile &#x27;
                         &#x27;profile) {\n&#x27;
                         &#x27;        DeviceProfieData data = new &#x27;
                         &#x27;DeviceProfieData();\n&#x27;
                         &#x27;        data.desktopRows = profile.numRows;\n&#x27;
                         &#x27;        data.desktopCols = profile.numColumns;\n&#x27;
                         &#x27;        data.hotseatCount = &#x27;
                         &#x27;profile.numHotseatIcons;\n&#x27;
                         &#x27;        data.allappsRank = &#x27;
                         &#x27;profile.hotseatAllAppsRank;\n&#x27;
                         &#x27;        return data;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        // clear the output journal time, to force &#x27;
                           &#x27;a full backup to\n&#x27;
                           &#x27;        // will catch any changes the restore &#x27;
                           &#x27;process might have made\n&#x27;
                           &#x27;        Journal out = new Journal();\n&#x27;
                           &#x27;        out.t = 0;\n&#x27;
                           &#x27;        out.key = &#x27;
                           &#x27;mKeys.toArray(BackupProtos.Key.emptyArray());\n&#x27;
                           &#x27;        writeJournal(newState, out);\n&#x27;
                           &#x27;        Log.v(TAG, &quot;onRestore: read &quot; + &#x27;
                           &#x27;mKeys.size() + &quot; rows&quot;);\n&#x27;
                           &#x27;        mKeys.clear();\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}}]]</pre>
          </body>
        </html>
        