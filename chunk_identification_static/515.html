<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>515</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    515
                    <a href="514.html">prev</a>
                    <a href="516.html">next</a>
                    <a href="515_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_e83f8c3a3cbab21ecd8ceab223b0f3539be4b5fd_mongo/mongo-side/mongo-all-side/src/main/java/com/dtstack/flink/sql/side/mongo/MongoAllReqRow.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e83f8c3a3cbab21ecd8ceab223b0f3539be4b5fd:mongo/mongo-side/mongo-all-side/src/main/java/com/dtstack/flink/sql/side/mongo/MongoAllReqRow.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e83f8c3a3cbab21ecd8ceab223b0f3539be4b5fd^1:mongo/mongo-side/mongo-all-side/src/main/java/com/dtstack/flink/sql/side/mongo/MongoAllReqRow.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e83f8c3a3cbab21ecd8ceab223b0f3539be4b5fd^2:mongo/mongo-side/mongo-all-side/src/main/java/com/dtstack/flink/sql/side/mongo/MongoAllReqRow.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;55715c184d537500eff25ccea853833950100929:mongo/mongo-side/mongo-all-side/src/main/java/com/dtstack/flink/sql/side/mongo/MongoAllReqRow.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.side.mongo;
  20 
  21 import com.dtstack.flink.sql.side.BaseAllReqRow;
  22 import com.dtstack.flink.sql.side.FieldInfo;
  23 import com.dtstack.flink.sql.side.JoinInfo;
  24 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  25 import com.dtstack.flink.sql.side.mongo.table.MongoSideTableInfo;
  26 import com.dtstack.flink.sql.side.mongo.utils.MongoUtil;
  27 import com.google.common.collect.Lists;
  28 import com.google.common.collect.Maps;
  29 import com.mongodb.BasicDBObject;
  30 import com.mongodb.MongoClient;
  31 import com.mongodb.MongoClientURI;
  32 import com.mongodb.client.FindIterable;
  33 import com.mongodb.client.MongoCollection;
  34 import com.mongodb.client.MongoCursor;
  35 import com.mongodb.client.MongoDatabase;
  36 import org.apache.calcite.sql.JoinType;
  37 import org.apache.commons.collections.CollectionUtils;
  38 import org.apache.commons.lang3.StringUtils;
  39 import org.apache.flink.api.java.tuple.Tuple2;
  40 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  41 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
  42 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  43 import com.google.common.collect.Lists;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  44 import com.google.common.collect.Maps;</span>
  45 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  46 import org.apache.flink.table.runtime.types.CRow;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  47 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;</span>
  48 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  49 import org.apache.flink.types.Row;
  50 import org.apache.flink.util.Collector;
  51 import org.bson.Document;
  52 import org.slf4j.Logger;
  53 import org.slf4j.LoggerFactory;
  54 
  55 import java.sql.SQLException;
  56 import java.util.Calendar;
  57 import java.util.List;
  58 import java.util.Map;
  59 import java.util.concurrent.atomic.AtomicReference;
  60 
  61 /**
  62  * Reason:
  63  * Date: 2018/11/6
  64  *
  65  * @author xuqianjin
  66  */
  67 public class MongoAllReqRow extends BaseAllReqRow {
  68 
  69     private static final long serialVersionUID = -675332795591842778L;
  70 
  71     private static final Logger LOG = LoggerFactory.getLogger(MongoAllReqRow.class);
  72 
  73     private static final int CONN_RETRY_NUM = 3;
  74 
  75     private static final int FETCH_SIZE = 1000;
  76 
  77     private MongoClient mongoClient;
  78 
  79     private MongoDatabase db;
  80 
  81     private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  82 
<abbr title="  83     public MongoAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  83     public MongoAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, A🔵</abbr>
  84         super(new MongoAllSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  85     }
  86 
  87     @Override
  88     public Row fillData(Row input, Object sideInput) {
  89         Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;
  90         Row row = new Row(sideInfo.getOutFieldInfoList().size());
  91         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
  92             Object obj = input.getField(entry.getValue());
  93             obj = convertTimeIndictorTypeInfo(entry.getValue(), obj);
  94             row.setField(entry.getKey(), obj);
  95         }
  96 
  97         for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {
  98             if (cacheInfo == null) {
  99                 row.setField(entry.getKey(), null);
 100             } else {
 101                 row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));
 102             }
 103         }
 104 
 105         return row;
 106     }
 107 
 108     @Override
 109     protected void initCache() throws SQLException {
 110         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 111         cacheRef.set(newCache);
 112         loadData(newCache);
 113     }
 114 
 115     @Override
 116     protected void reloadCache() {
 117         //reload cacheRef and replace to old cacheRef
 118         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 119         try {
 120             loadData(newCache);
 121         } catch (SQLException e) {
 122             LOG.error(&quot;&quot;, e);
 123         }
 124 
 125         cacheRef.set(newCache);
 126         LOG.info(&quot;----- Mongo all cacheRef reload end:{}&quot;, Calendar.getInstance());
 127     }
 128 
 129     @Override
 130     public void flatMap(Tuple2&lt;Boolean,Row&gt; input, Collector&lt;Tuple2&lt;Boolean,Row&gt;&gt; out) throws Exception {
 131         List&lt;Object&gt; inputParams = Lists.newArrayList();
 132         for (Integer conValIndex : sideInfo.getEqualValIndex()) {
 133             Object equalObj = input.f1.getField(conValIndex);
 134             if (equalObj == null) {
 135                 if (sideInfo.getJoinType() == JoinType.LEFT) {
 136                     Row data = fillData(input.f1, null);
 137                     out.collect(Tuple2.of(input.f0, data));
 138                 }
 139                 return;
 140             }
 141             inputParams.add(equalObj);
 142         }
 143 
 144         String key = buildKey(inputParams);
 145         List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(key);
 146         if (CollectionUtils.isEmpty(cacheList)) {
 147             if (sideInfo.getJoinType() == JoinType.LEFT) {
 148                 Row row = fillData(input.f1, null);
 149                 out.collect(Tuple2.of(input.f0, row));
 150             } else {
 151                 return;
 152             }
 153 
 154             return;
 155         }
 156 
 157         for (Map&lt;String, Object&gt; one : cacheList) {
 158             out.collect(Tuple2.of(input.f0, fillData(input.f1, one)));
 159         }
 160     }
 161 
 162     private String buildKey(List&lt;Object&gt; equalValList) {
 163         StringBuilder sb = new StringBuilder(&quot;&quot;);
 164         for (Object equalVal : equalValList) {
 165             sb.append(equalVal).append(&quot;_&quot;);
 166         }
 167 
 168         return sb.toString();
 169     }
 170 
 171     private String buildKey(Map&lt;String, Object&gt; val, List&lt;String&gt; equalFieldList) {
 172         StringBuilder sb = new StringBuilder(&quot;&quot;);
 173         for (String equalField : equalFieldList) {
 174             sb.append(val.get(equalField)).append(&quot;_&quot;);
 175         }
 176 
 177         return sb.toString();
 178     }
 179 
 180     private MongoCollection getConn(String address, String database, String tableName) {
 181         MongoCollection dbCollection;
 182         mongoClient = new MongoClient(new MongoClientURI(address));
 183         db = mongoClient.getDatabase(database);
 184         dbCollection = db.getCollection(tableName, Document.class);
 185         return dbCollection;
 186 
 187     }
 188 
 189     private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 190         MongoSideTableInfo tableInfo = (MongoSideTableInfo) sideInfo.getSideTableInfo();
 191         MongoCollection dbCollection = null;
 192 
 193         try {
 194             for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 195                 try {
<abbr title=" 196                     dbCollection = getConn(tableInfo.getAddress(), tableInfo.getDatabase(), tableInfo.getTableName());"> 196                     dbCollection = getConn(tableInfo.getAddress(), tableInfo.getDatabase(), tableInfo.get🔵</abbr>
 197                     break;
 198                 } catch (Exception e) {
 199                     if (i == CONN_RETRY_NUM - 1) {
 200                         throw new RuntimeException(&quot;&quot;, e);
 201                     }
 202 
 203                     try {
<abbr title=" 204                         String connInfo = &quot;url:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.getUserName() + &quot;,pwd:&quot; + tableInfo.getPassword();"> 204                         String connInfo = &quot;url:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.getU🔵</abbr>
 205                         LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 206                         Thread.sleep(LOAD_DATA_ERROR_SLEEP_TIME);
 207                     } catch (InterruptedException e1) {
 208                         LOG.error(&quot;&quot;, e1);
 209                     }
 210                 }
 211             }
 212 
 213             //load data from table
 214             String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 215             BasicDBObject basicDBObject = new BasicDBObject();
 216             for (String selectField : sideFieldNames) {
 217                 basicDBObject.append(selectField, 1);
 218             }
 219             BasicDBObject filterObject = new BasicDBObject();
 220             try {
 221                 // 填充谓词
 222                 sideInfo.getSideTableInfo().getPredicateInfoes().stream().map(info -&gt; {
 223                     BasicDBObject filterCondition = MongoUtil.buildFilterObject(info);
 224                     if (null != filterCondition) {
 225                         filterObject.append(info.getFieldName(), filterCondition);
 226                     }
 227                     return info;
 228                 }).count();
 229             } catch (Exception e) {
 230                 LOG.info(&quot;add predicate infoes error &quot;, e);
 231             }
 232 
 233 
<abbr title=" 234             FindIterable&lt;Document&gt; findIterable = dbCollection.find(filterObject).projection(basicDBObject).limit(FETCH_SIZE);"> 234             FindIterable&lt;Document&gt; findIterable = dbCollection.find(filterObject).projection(basicDBObjec🔵</abbr>
 235             MongoCursor&lt;Document&gt; mongoCursor = findIterable.iterator();
 236             while (mongoCursor.hasNext()) {
 237                 Document doc = mongoCursor.next();
 238                 Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 239                 for (String fieldName : sideFieldNames) {
 240                     oneRow.put(fieldName.trim(), doc.get(fieldName.trim()));
 241                 }
 242                 String cacheKey = buildKey(oneRow, sideInfo.getEqualFieldList());
<abbr title=" 243                 List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList());"> 243                 List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArray🔵</abbr>
 244                 list.add(oneRow);
 245             }
 246         } catch (Exception e) {
 247             LOG.error(&quot;&quot;, e);
 248         } finally {
 249             if (mongoClient != null) {
 250                 mongoClient.close();
 251             }
 252         }
 253     }
 254 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.side.mongo;
  20 
  21 import com.dtstack.flink.sql.side.BaseAllReqRow;
  22 import com.dtstack.flink.sql.side.FieldInfo;
  23 import com.dtstack.flink.sql.side.JoinInfo;
  24 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  25 import com.dtstack.flink.sql.side.mongo.table.MongoSideTableInfo;
  26 import com.dtstack.flink.sql.side.mongo.utils.MongoUtil;
  27 import com.google.common.collect.Lists;
  28 import com.google.common.collect.Maps;
  29 import com.mongodb.BasicDBObject;
  30 import com.mongodb.MongoClient;
  31 import com.mongodb.MongoClientURI;
  32 import com.mongodb.client.FindIterable;
  33 import com.mongodb.client.MongoCollection;
  34 import com.mongodb.client.MongoCursor;
  35 import com.mongodb.client.MongoDatabase;
  36 import org.apache.calcite.sql.JoinType;
  37 import org.apache.commons.collections.CollectionUtils;
  38 import org.apache.commons.lang3.StringUtils;
  39 import org.apache.flink.api.java.tuple.Tuple2;
  40 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  41 import org.apache.flink.types.Row;
  42 import org.apache.flink.util.Collector;
  43 import org.bson.Document;
  44 import org.slf4j.Logger;
  45 import org.slf4j.LoggerFactory;
  46 
  47 import java.sql.SQLException;
  48 import java.util.Calendar;
  49 import java.util.List;
  50 import java.util.Map;
  51 import java.util.concurrent.atomic.AtomicReference;
  52 
  53 /**
  54  * Reason:
  55  * Date: 2018/11/6
  56  *
  57  * @author xuqianjin
  58  */
  59 public class MongoAllReqRow extends BaseAllReqRow {
  60 
  61     private static final long serialVersionUID = -675332795591842778L;
  62 
  63     private static final Logger LOG = LoggerFactory.getLogger(MongoAllReqRow.class);
  64 
  65     private static final int CONN_RETRY_NUM = 3;
  66 
  67     private static final int FETCH_SIZE = 1000;
  68 
  69     private MongoClient mongoClient;
  70 
  71     private MongoDatabase db;
  72 
  73     private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  74 
<abbr title="  75     public MongoAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  75     public MongoAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, A🔵</abbr>
  76         super(new MongoAllSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  77     }
  78 
  79     @Override
  80     public Row fillData(Row input, Object sideInput) {
  81         Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;
  82         Row row = new Row(sideInfo.getOutFieldInfoList().size());
  83         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
  84             Object obj = input.getField(entry.getValue());
  85             obj = convertTimeIndictorTypeInfo(entry.getValue(), obj);
  86             row.setField(entry.getKey(), obj);
  87         }
  88 
  89         for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {
  90             if (cacheInfo == null) {
  91                 row.setField(entry.getKey(), null);
  92             } else {
  93                 row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));
  94             }
  95         }
  96 
  97         return row;
  98     }
  99 
 100     @Override
 101     protected void initCache() throws SQLException {
 102         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 103         cacheRef.set(newCache);
 104         loadData(newCache);
 105     }
 106 
 107     @Override
 108     protected void reloadCache() {
 109         //reload cacheRef and replace to old cacheRef
 110         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 111         try {
 112             loadData(newCache);
 113         } catch (SQLException e) {
 114             LOG.error(&quot;&quot;, e);
 115         }
 116 
 117         cacheRef.set(newCache);
 118         LOG.info(&quot;----- Mongo all cacheRef reload end:{}&quot;, Calendar.getInstance());
 119     }
 120 
 121     @Override
 122     public void flatMap(Tuple2&lt;Boolean,Row&gt; input, Collector&lt;Tuple2&lt;Boolean,Row&gt;&gt; out) throws Exception {
 123         List&lt;Object&gt; inputParams = Lists.newArrayList();
 124         for (Integer conValIndex : sideInfo.getEqualValIndex()) {
 125             Object equalObj = input.f1.getField(conValIndex);
 126             if (equalObj == null) {
 127                 if(sideInfo.getJoinType() == JoinType.LEFT){
 128                     Row data = fillData(input.f1, null);
 129                     out.collect(Tuple2.of(input.f0, data));
 130                 }
 131                 return;
 132             }
 133             inputParams.add(equalObj);
 134         }
 135 
 136         String key = buildKey(inputParams);
 137         List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(key);
 138         if (CollectionUtils.isEmpty(cacheList)) {
 139             if (sideInfo.getJoinType() == JoinType.LEFT) {
 140                 Row row = fillData(input.f1, null);
 141                 out.collect(Tuple2.of(input.f0, row));
 142             } else {
 143                 return;
 144             }
 145 
 146             return;
 147         }
 148 
 149         for (Map&lt;String, Object&gt; one : cacheList) {
 150             out.collect(Tuple2.of(input.f0, fillData(input.f1, one)));
 151         }
 152     }
 153 
 154     private String buildKey(List&lt;Object&gt; equalValList) {
 155         StringBuilder sb = new StringBuilder(&quot;&quot;);
 156         for (Object equalVal : equalValList) {
 157             sb.append(equalVal).append(&quot;_&quot;);
 158         }
 159 
 160         return sb.toString();
 161     }
 162 
 163     private String buildKey(Map&lt;String, Object&gt; val, List&lt;String&gt; equalFieldList) {
 164         StringBuilder sb = new StringBuilder(&quot;&quot;);
 165         for (String equalField : equalFieldList) {
 166             sb.append(val.get(equalField)).append(&quot;_&quot;);
 167         }
 168 
 169         return sb.toString();
 170     }
 171 
 172     private MongoCollection getConn(String address, String database, String tableName) {
 173         MongoCollection dbCollection;
 174         mongoClient = new MongoClient(new MongoClientURI(address));
 175         db = mongoClient.getDatabase(database);
 176         dbCollection = db.getCollection(tableName, Document.class);
 177         return dbCollection;
 178 
 179     }
 180 
 181     private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 182         MongoSideTableInfo tableInfo = (MongoSideTableInfo) sideInfo.getSideTableInfo();
 183         MongoCollection dbCollection = null;
 184 
 185         try {
 186             for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 187                 try {
<abbr title=" 188                     dbCollection = getConn(tableInfo.getAddress(), tableInfo.getDatabase(), tableInfo.getTableName());"> 188                     dbCollection = getConn(tableInfo.getAddress(), tableInfo.getDatabase(), tableInfo.get🔵</abbr>
 189                     break;
 190                 } catch (Exception e) {
 191                     if (i == CONN_RETRY_NUM - 1) {
 192                         throw new RuntimeException(&quot;&quot;, e);
 193                     }
 194 
 195                     try {
<abbr title=" 196                         String connInfo = &quot;url:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.getUserName() + &quot;,pwd:&quot; + tableInfo.getPassword();"> 196                         String connInfo = &quot;url:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.getU🔵</abbr>
 197                         LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 198                         Thread.sleep(LOAD_DATA_ERROR_SLEEP_TIME);
 199                     } catch (InterruptedException e1) {
 200                         LOG.error(&quot;&quot;, e1);
 201                     }
 202                 }
 203             }
 204 
 205             //load data from table
 206             String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 207             BasicDBObject basicDBObject = new BasicDBObject();
 208             for (String selectField : sideFieldNames) {
 209                 basicDBObject.append(selectField, 1);
 210             }
 211             BasicDBObject filterObject = new BasicDBObject();
 212             try {
 213                 // 填充谓词
 214                 sideInfo.getSideTableInfo().getPredicateInfoes().stream().map(info -&gt; {
 215                     BasicDBObject filterCondition = MongoUtil.buildFilterObject(info);
 216                     if (null != filterCondition) {
 217                         filterObject.append(info.getFieldName(), filterCondition);
 218                     }
 219                     return info;
 220                 }).count();
 221             } catch (Exception e) {
 222                 LOG.info(&quot;add predicate infoes error &quot;, e);
 223             }
 224 
 225 
<abbr title=" 226             FindIterable&lt;Document&gt; findIterable = dbCollection.find(filterObject).projection(basicDBObject).limit(FETCH_SIZE);"> 226             FindIterable&lt;Document&gt; findIterable = dbCollection.find(filterObject).projection(basicDBObjec🔵</abbr>
 227             MongoCursor&lt;Document&gt; mongoCursor = findIterable.iterator();
 228             while (mongoCursor.hasNext()) {
 229                 Document doc = mongoCursor.next();
 230                 Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 231                 for (String fieldName : sideFieldNames) {
 232                     oneRow.put(fieldName.trim(), doc.get(fieldName.trim()));
 233                 }
 234                 String cacheKey = buildKey(oneRow, sideInfo.getEqualFieldList());
<abbr title=" 235                 List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList());"> 235                 List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArray🔵</abbr>
 236                 list.add(oneRow);
 237             }
 238         } catch (Exception e) {
 239             LOG.error(&quot;&quot;, e);
 240         } finally {
 241                 if (mongoClient != null) {
 242                     mongoClient.close();
 243                 }
 244         }
 245     }
 246 }
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side.mongo;
  19 
  20 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  21 import com.dtstack.flink.sql.side.BaseAllReqRow;
  22 import com.dtstack.flink.sql.side.FieldInfo;
  23 import com.dtstack.flink.sql.side.JoinInfo;
  24 import com.dtstack.flink.sql.side.mongo.table.MongoSideTableInfo;
  25 import com.dtstack.flink.sql.side.mongo.utils.MongoUtil;
  26 import com.google.common.collect.Lists;
  27 import com.google.common.collect.Maps;
  28 import com.mongodb.BasicDBObject;
  29 import com.mongodb.MongoClient;
  30 import com.mongodb.MongoClientURI;
  31 import com.mongodb.client.FindIterable;
  32 import com.mongodb.client.MongoCollection;
  33 import com.mongodb.client.MongoCursor;
  34 import com.mongodb.client.MongoDatabase;
  35 import java.sql.SQLException;
  36 import java.util.Calendar;
  37 import java.util.List;
  38 import java.util.Map;
  39 import java.util.concurrent.atomic.AtomicReference;
  40 import org.apache.calcite.sql.JoinType;
  41 import org.apache.commons.collections.CollectionUtils;
  42 import org.apache.commons.lang3.StringUtils;
  43 import org.apache.flink.api.java.tuple.Tuple2;
  44 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  45 import org.apache.flink.types.Row;
  46 import org.apache.flink.util.Collector;
  47 import org.bson.Document;
  48 import org.slf4j.Logger;
  49 import org.slf4j.LoggerFactory;
  50 
  51 
  52 /**
  53  * Reason:
  54  * Date: 2018/11/6
  55  *
  56  * @author xuqianjin
  57  */
  58 public class MongoAllReqRow extends BaseAllReqRow {
  59     private static final long serialVersionUID = -675332795591842778L;
  60 
  61     private static final Logger LOG = LoggerFactory.getLogger(MongoAllReqRow.class);
  62 
  63     private static final int CONN_RETRY_NUM = 3;
  64 
  65     private static final int FETCH_SIZE = 1000;
  66 
  67     private MongoClient mongoClient;
  68 
  69     private MongoDatabase db;
  70 
  71     private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  72 
<abbr title="  73     public MongoAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  73     public MongoAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, A🔵</abbr>
  74         super(new MongoAllSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  75     }
  76 
  77     @Override
  78     public Row fillData(Row input, Object sideInput) {
  79         Map&lt;String, Object&gt; cacheInfo = ((Map&lt;String, Object&gt;) (sideInput));
  80         Row row = new Row(sideInfo.getOutFieldInfoList().size());
  81         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
  82             Object obj = input.getField(entry.getValue());
  83             obj = convertTimeIndictorTypeInfo(entry.getValue(), obj);
  84             row.setField(entry.getKey(), obj);
  85         }
  86         for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {
  87             if (cacheInfo == null) {
  88                 row.setField(entry.getKey(), null);
  89             } else {
  90                 row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));
  91             }
  92         }
  93         return row;
  94     }
  95 
  96     @Override
  97     protected void initCache() throws SQLException {
  98         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
  99         cacheRef.set(newCache);
 100         loadData(newCache);
 101     }
 102 
 103     @Override
 104     protected void reloadCache() {
 105         //reload cacheRef and replace to old cacheRef
 106         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 107         try {
 108             loadData(newCache);
 109         } catch (SQLException e) {
 110             LOG.error(&quot;&quot;, e);
 111         }
 112 
 113         cacheRef.set(newCache);
 114         LOG.info(&quot;----- Mongo all cacheRef reload end:{}&quot;, Calendar.getInstance());
 115     }
 116 
 117     @Override
<abbr title=" 118     public void flatMap(Tuple2&lt;Boolean, Row&gt; input, Collector&lt;Tuple2&lt;Boolean, Row&gt;&gt; out) throws Exception {"> 118     public void flatMap(Tuple2&lt;Boolean, Row&gt; input, Collector&lt;Tuple2&lt;Boolean, Row&gt;&gt; out) throws Exception🔵</abbr>
 119         List&lt;Object&gt; inputParams = Lists.newArrayList();
 120         for (Integer conValIndex : sideInfo.getEqualValIndex()) {
 121             Object equalObj = input.f1.getField(conValIndex);
 122             if (equalObj == null) {
 123                 if (sideInfo.getJoinType() == JoinType.LEFT) {
 124                     Row data = fillData(input.f1, null);
 125                     out.collect(Tuple2.of(input.f0, data));
 126                 }
 127                 return;
 128             }
 129             inputParams.add(equalObj);
 130         }
 131         String key = buildKey(inputParams);
 132         List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(key);
 133         if (CollectionUtils.isEmpty(cacheList)) {
 134             if (sideInfo.getJoinType() == JoinType.LEFT) {
 135                 Row row = fillData(input.f1, null);
 136                 out.collect(Tuple2.of(input.f0, row));
 137             } else {
 138                 return;
 139             }
 140             return;
 141         }
 142         for (Map&lt;String, Object&gt; one : cacheList) {
 143             out.collect(Tuple2.of(input.f0, fillData(input.f1, one)));
 144         }
 145     }
 146 
 147     private String buildKey(List&lt;Object&gt; equalValList) {
 148         StringBuilder sb = new StringBuilder(&quot;&quot;);
 149         for (Object equalVal : equalValList) {
 150             sb.append(equalVal).append(&quot;_&quot;);
 151         }
 152 
 153         return sb.toString();
 154     }
 155 
 156     private String buildKey(Map&lt;String, Object&gt; val, List&lt;String&gt; equalFieldList) {
 157         StringBuilder sb = new StringBuilder(&quot;&quot;);
 158         for (String equalField : equalFieldList) {
 159             sb.append(val.get(equalField)).append(&quot;_&quot;);
 160         }
 161 
 162         return sb.toString();
 163     }
 164 
 165     private MongoCollection getConn(String address, String database, String tableName) {
 166         MongoCollection dbCollection;
 167         mongoClient = new MongoClient(new MongoClientURI(address));
 168         db = mongoClient.getDatabase(database);
 169         dbCollection = db.getCollection(tableName, Document.class);
 170         return dbCollection;
 171 
 172     }
 173 
 174     private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 175         MongoSideTableInfo tableInfo = ((MongoSideTableInfo) (sideInfo.getSideTableInfo()));
 176         MongoCollection dbCollection = null;
 177         try {
 178             for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 179                 try {
<abbr title=" 180                     dbCollection = getConn(tableInfo.getAddress(), tableInfo.getDatabase(), tableInfo.getTableName());"> 180                     dbCollection = getConn(tableInfo.getAddress(), tableInfo.getDatabase(), tableInfo.get🔵</abbr>
 181                     break;
 182                 } catch (java.lang.Exception e) {
 183                     if (i == (CONN_RETRY_NUM - 1)) {
 184                         throw new RuntimeException(&quot;&quot;, e);
 185                     }
 186                     try {
<abbr title=" 187                         String connInfo = ((((&quot;url:&quot; + tableInfo.getAddress()) + &quot;;userName:&quot;) + tableInfo.getUserName()) + &quot;,pwd:&quot;) + tableInfo.getPassword();"> 187                         String connInfo = ((((&quot;url:&quot; + tableInfo.getAddress()) + &quot;;userName:&quot;) + tableInf🔵</abbr>
 188                         LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 189                         Thread.sleep(LOAD_DATA_ERROR_SLEEP_TIME);
 190                     } catch (java.lang.InterruptedException e1) {
 191                         LOG.error(&quot;&quot;, e1);
 192                     }
 193                 }
 194             }
 195             // load data from table
 196             String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 197             BasicDBObject basicDBObject = new BasicDBObject();
 198             for (String selectField : sideFieldNames) {
 199                 basicDBObject.append(selectField, 1);
 200             }
 201             BasicDBObject filterObject = new BasicDBObject();
 202             try {
 203                 // 填充谓词
 204                 sideInfo.getSideTableInfo().getPredicateInfoes().stream().map(( info) -&gt; {
 205                     BasicDBObject filterCondition = MongoUtil.buildFilterObject(info);
 206                     if (null != filterCondition) {
 207                         filterObject.append(info.getFieldName(), filterCondition);
 208                     }
 209                     return info;
 210                 }).count();
 211             } catch (java.lang.Exception e) {
 212                 LOG.info(&quot;add predicate infoes error &quot;, e);
 213             }
<abbr title=" 214             FindIterable&lt;Document&gt; findIterable = dbCollection.find(filterObject).projection(basicDBObject).limit(FETCH_SIZE);"> 214             FindIterable&lt;Document&gt; findIterable = dbCollection.find(filterObject).projection(basicDBObjec🔵</abbr>
 215             MongoCursor&lt;Document&gt; mongoCursor = findIterable.iterator();
 216             while (mongoCursor.hasNext()) {
 217                 Document doc = mongoCursor.next();
 218                 Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 219                 for (String fieldName : sideFieldNames) {
 220                     oneRow.put(fieldName.trim(), doc.get(fieldName.trim()));
 221                 }
 222                 String cacheKey = buildKey(oneRow, sideInfo.getEqualFieldList());
<abbr title=" 223                 List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, ( key) -&gt; Lists.newArrayList());"> 223                 List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, ( key) -&gt; Lists.newAr🔵</abbr>
 224                 list.add(oneRow);
 225             }
 226         } catch (java.lang.Exception e) {
 227             LOG.error(&quot;&quot;, e);
 228         } finally {
 229             if (mongoClient != null) {
 230                 mongoClient.close();
 231             }
 232         }
 233     }
 234 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.side.mongo;
  20  
  21  import com.dtstack.flink.sql.side.BaseAllReqRow;
  22  import com.dtstack.flink.sql.side.FieldInfo;
  23  import com.dtstack.flink.sql.side.JoinInfo;
  24  import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  25  import com.dtstack.flink.sql.side.mongo.table.MongoSideTableInfo;
  26  import com.dtstack.flink.sql.side.mongo.utils.MongoUtil;
  27  import com.google.common.collect.Lists;
  28  import com.google.common.collect.Maps;
  29  import com.mongodb.BasicDBObject;
  30  import com.mongodb.MongoClient;
  31  import com.mongodb.MongoClientURI;
  32  import com.mongodb.client.FindIterable;
  33  import com.mongodb.client.MongoCollection;
  34  import com.mongodb.client.MongoCursor;
  35  import com.mongodb.client.MongoDatabase;
  36  import org.apache.calcite.sql.JoinType;
  37  import org.apache.commons.collections.CollectionUtils;
  38  import org.apache.commons.lang3.StringUtils;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  39 +import org.apache.flink.api.java.tuple.Tuple2;</span>
  40  import org.apache.flink.api.java.typeutils.RowTypeInfo;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  41 -import com.google.common.collect.Lists;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  42 -import com.google.common.collect.Maps;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  43 -import org.apache.flink.table.runtime.types.CRow;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  44 -import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;</span>
  45  import org.apache.flink.types.Row;
  46  import org.apache.flink.util.Collector;
  47  import org.bson.Document;
  48  import org.slf4j.Logger;
  49  import org.slf4j.LoggerFactory;
  50  
  51  import java.sql.SQLException;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  52 -import java.sql.Timestamp;</span>
  53  import java.util.Calendar;
  54  import java.util.List;
  55  import java.util.Map;
  56  import java.util.concurrent.atomic.AtomicReference;
  57  
  58  /**
  59   * Reason:
  60   * Date: 2018/11/6
  61   *
  62   * @author xuqianjin
  63   */
  64  public class MongoAllReqRow extends BaseAllReqRow {
  65  
  66      private static final long serialVersionUID = -675332795591842778L;
  67  
  68      private static final Logger LOG = LoggerFactory.getLogger(MongoAllReqRow.class);
  69  
  70      private static final int CONN_RETRY_NUM = 3;
  71  
  72      private static final int FETCH_SIZE = 1000;
  73  
  74      private MongoClient mongoClient;
  75  
  76      private MongoDatabase db;
  77  
  78      private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  79  
<abbr title="  80      public MongoAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  80      public MongoAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSi🔵</abbr>
  81          super(new MongoAllSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  82      }
  83  
  84      @Override
  85      public Row fillData(Row input, Object sideInput) {
  86          Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;
  87          Row row = new Row(sideInfo.getOutFieldInfoList().size());
  88          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
  89              Object obj = input.getField(entry.getValue());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  90 -            boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());">  90 -            boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  91 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  92 -            //Type information for indicating event or processing time. However, it behaves like a regular SQL timestamp but is serialized as Long.">  92 -            //Type information for indicating event or processing time. However, it behaves like a regular SQL tim🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  93 -            if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  94 -                obj = ((Timestamp) obj).getTime();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  95 -            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  96 +            obj = convertTimeIndictorTypeInfo(entry.getValue(), obj);</span>
  97              row.setField(entry.getKey(), obj);
  98          }
  99  
 100          for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {
 101              if (cacheInfo == null) {
 102                  row.setField(entry.getKey(), null);
 103              } else {
 104                  row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));
 105              }
 106          }
 107  
 108          return row;
 109      }
 110  
 111      @Override
 112      protected void initCache() throws SQLException {
 113          Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 114          cacheRef.set(newCache);
 115          loadData(newCache);
 116      }
 117  
 118      @Override
 119      protected void reloadCache() {
 120          //reload cacheRef and replace to old cacheRef
 121          Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 122          try {
 123              loadData(newCache);
 124          } catch (SQLException e) {
 125              LOG.error(&quot;&quot;, e);
 126          }
 127  
 128          cacheRef.set(newCache);
 129          LOG.info(&quot;----- Mongo all cacheRef reload end:{}&quot;, Calendar.getInstance());
 130      }
 131  
 132      @Override
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 133 -    public void flatMap(CRow input, Collector&lt;CRow&gt; out) throws Exception {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 134 +    public void flatMap(Tuple2&lt;Boolean,Row&gt; input, Collector&lt;Tuple2&lt;Boolean,Row&gt;&gt; out) throws Exception {</span>
 135          List&lt;Object&gt; inputParams = Lists.newArrayList();
 136          for (Integer conValIndex : sideInfo.getEqualValIndex()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 137 -            Object equalObj = input.row().getField(conValIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 138 +            Object equalObj = input.f1.getField(conValIndex);</span>
 139              if (equalObj == null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 140 -                if(sideInfo.getJoinType() == JoinType.LEFT){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 141 -                    Row data = fillData(input.row(), null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 142 -                    out.collect(new CRow(data, input.change()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 143 +                if (sideInfo.getJoinType() == JoinType.LEFT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 144 +                    Row data = fillData(input.f1, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 145 +                    out.collect(Tuple2.of(input.f0, data));</span>
 146                  }
 147                  return;
 148              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 149 -</span>
 150              inputParams.add(equalObj);
 151          }
 152  
 153          String key = buildKey(inputParams);
 154          List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(key);
 155          if (CollectionUtils.isEmpty(cacheList)) {
 156              if (sideInfo.getJoinType() == JoinType.LEFT) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 157 -                Row row = fillData(input.row(), null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 158 -                out.collect(new CRow(row, input.change()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 159 +                Row row = fillData(input.f1, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 160 +                out.collect(Tuple2.of(input.f0, row));</span>
 161              } else {
 162                  return;
 163              }
 164  
 165              return;
 166          }
 167  
 168          for (Map&lt;String, Object&gt; one : cacheList) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 169 -            out.collect(new CRow(fillData(input.row(), one), input.change()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 170 +            out.collect(Tuple2.of(input.f0, fillData(input.f1, one)));</span>
 171          }
 172      }
 173  
 174      private String buildKey(List&lt;Object&gt; equalValList) {
 175          StringBuilder sb = new StringBuilder(&quot;&quot;);
 176          for (Object equalVal : equalValList) {
 177              sb.append(equalVal).append(&quot;_&quot;);
 178          }
 179  
 180          return sb.toString();
 181      }
 182  
 183      private String buildKey(Map&lt;String, Object&gt; val, List&lt;String&gt; equalFieldList) {
 184          StringBuilder sb = new StringBuilder(&quot;&quot;);
 185          for (String equalField : equalFieldList) {
 186              sb.append(val.get(equalField)).append(&quot;_&quot;);
 187          }
 188  
 189          return sb.toString();
 190      }
 191  
 192      private MongoCollection getConn(String address, String database, String tableName) {
 193          MongoCollection dbCollection;
 194          mongoClient = new MongoClient(new MongoClientURI(address));
 195          db = mongoClient.getDatabase(database);
 196          dbCollection = db.getCollection(tableName, Document.class);
 197          return dbCollection;
 198  
 199      }
 200  
 201      private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 202          MongoSideTableInfo tableInfo = (MongoSideTableInfo) sideInfo.getSideTableInfo();
 203          MongoCollection dbCollection = null;
 204  
 205          try {
 206              for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 207                  try {
<abbr title=" 208                      dbCollection = getConn(tableInfo.getAddress(), tableInfo.getDatabase(), tableInfo.getTableName());"> 208                      dbCollection = getConn(tableInfo.getAddress(), tableInfo.getDatabase(), tableInfo.getTableName🔵</abbr>
 209                      break;
 210                  } catch (Exception e) {
 211                      if (i == CONN_RETRY_NUM - 1) {
 212                          throw new RuntimeException(&quot;&quot;, e);
 213                      }
 214  
 215                      try {
<abbr title=" 216                          String connInfo = &quot;url:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.getUserName() + &quot;,pwd:&quot; + tableInfo.getPassword();"> 216                          String connInfo = &quot;url:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.getUserName()🔵</abbr>
 217                          LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 218                          Thread.sleep(5 * 1000);

 219                      } catch (InterruptedException e1) {
 220                          LOG.error(&quot;&quot;, e1);
 221                      }
 222                  }
 223              }
 224  
 225              //load data from table
 226              String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 227              BasicDBObject basicDBObject = new BasicDBObject();
 228              for (String selectField : sideFieldNames) {
 229                  basicDBObject.append(selectField, 1);
 230              }
 231              BasicDBObject filterObject = new BasicDBObject();
 232              try {
 233                  // 填充谓词
 234                  sideInfo.getSideTableInfo().getPredicateInfoes().stream().map(info -&gt; {
 235                      BasicDBObject filterCondition = MongoUtil.buildFilterObject(info);
 236                      if (null != filterCondition) {
 237                          filterObject.append(info.getFieldName(), filterCondition);
 238                      }
 239                      return info;
 240                  }).count();
 241              } catch (Exception e) {
 242                  LOG.info(&quot;add predicate infoes error &quot;, e);
 243              }
 244  
 245  
<abbr title=" 246              FindIterable&lt;Document&gt; findIterable = dbCollection.find(filterObject).projection(basicDBObject).limit(FETCH_SIZE);"> 246              FindIterable&lt;Document&gt; findIterable = dbCollection.find(filterObject).projection(basicDBObject).limit(🔵</abbr>
 247              MongoCursor&lt;Document&gt; mongoCursor = findIterable.iterator();
 248              while (mongoCursor.hasNext()) {
 249                  Document doc = mongoCursor.next();
 250                  Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 251                  for (String fieldName : sideFieldNames) {
 252                      oneRow.put(fieldName.trim(), doc.get(fieldName.trim()));
 253                  }
 254                  String cacheKey = buildKey(oneRow, sideInfo.getEqualFieldList());
 255                  List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList());
 256                  list.add(oneRow);
 257              }
 258          } catch (Exception e) {
 259              LOG.error(&quot;&quot;, e);
 260          } finally {
 261              try {
 262                  if (mongoClient != null) {
 263                      mongoClient.close();
 264                  }
 265              } catch (Exception e) {
 266                  throw new RuntimeException(&quot;[closeMongoDB]:&quot; + e.getMessage());


 267              }
 268          }
 269      }
 270  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.side.mongo;
  20  
  21  import com.dtstack.flink.sql.side.BaseAllReqRow;
  22  import com.dtstack.flink.sql.side.FieldInfo;
  23  import com.dtstack.flink.sql.side.JoinInfo;
  24  import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  25  import com.dtstack.flink.sql.side.mongo.table.MongoSideTableInfo;
  26  import com.dtstack.flink.sql.side.mongo.utils.MongoUtil;
  27  import com.google.common.collect.Lists;
  28  import com.google.common.collect.Maps;
  29  import com.mongodb.BasicDBObject;
  30  import com.mongodb.MongoClient;
  31  import com.mongodb.MongoClientURI;
  32  import com.mongodb.client.FindIterable;
  33  import com.mongodb.client.MongoCollection;
  34  import com.mongodb.client.MongoCursor;
  35  import com.mongodb.client.MongoDatabase;
  36  import org.apache.calcite.sql.JoinType;
  37  import org.apache.commons.collections.CollectionUtils;
  38  import org.apache.commons.lang3.StringUtils;

  39  import org.apache.flink.api.java.typeutils.RowTypeInfo;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  40 -import com.google.common.collect.Lists;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  41 -import com.google.common.collect.Maps;</span>
  42  import org.apache.flink.table.runtime.types.CRow;
  43  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  44  import org.apache.flink.types.Row;
  45  import org.apache.flink.util.Collector;
  46  import org.bson.Document;
  47  import org.slf4j.Logger;
  48  import org.slf4j.LoggerFactory;
  49  
  50  import java.sql.SQLException;
  51  import java.sql.Timestamp;
  52  import java.util.Calendar;
  53  import java.util.List;
  54  import java.util.Map;
  55  import java.util.concurrent.atomic.AtomicReference;
  56  
  57  /**
  58   * Reason:
  59   * Date: 2018/11/6
  60   *
  61   * @author xuqianjin
  62   */
  63  public class MongoAllReqRow extends BaseAllReqRow {
  64  
  65      private static final long serialVersionUID = -675332795591842778L;
  66  
  67      private static final Logger LOG = LoggerFactory.getLogger(MongoAllReqRow.class);
  68  
  69      private static final int CONN_RETRY_NUM = 3;
  70  
  71      private static final int FETCH_SIZE = 1000;
  72  
  73      private MongoClient mongoClient;
  74  
  75      private MongoDatabase db;
  76  
  77      private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  78  
<abbr title="  79      public MongoAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  79      public MongoAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSi🔵</abbr>
  80          super(new MongoAllSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  81      }
  82  
  83      @Override
  84      public Row fillData(Row input, Object sideInput) {
  85          Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;
  86          Row row = new Row(sideInfo.getOutFieldInfoList().size());
  87          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
  88              Object obj = input.getField(entry.getValue());
<abbr title="  89              boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());">  89              boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo🔵</abbr>
  90  
<abbr title="  91              //Type information for indicating event or processing time. However, it behaves like a regular SQL timestamp but is serialized as Long.">  91              //Type information for indicating event or processing time. However, it behaves like a regular SQL tim🔵</abbr>
  92              if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {
  93                  obj = ((Timestamp) obj).getTime();
  94              }

  95              row.setField(entry.getKey(), obj);
  96          }
  97  
  98          for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {
  99              if (cacheInfo == null) {
 100                  row.setField(entry.getKey(), null);
 101              } else {
 102                  row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));
 103              }
 104          }
 105  
 106          return row;
 107      }
 108  
 109      @Override
 110      protected void initCache() throws SQLException {
 111          Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 112          cacheRef.set(newCache);
 113          loadData(newCache);
 114      }
 115  
 116      @Override
 117      protected void reloadCache() {
 118          //reload cacheRef and replace to old cacheRef
 119          Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 120          try {
 121              loadData(newCache);
 122          } catch (SQLException e) {
 123              LOG.error(&quot;&quot;, e);
 124          }
 125  
 126          cacheRef.set(newCache);
 127          LOG.info(&quot;----- Mongo all cacheRef reload end:{}&quot;, Calendar.getInstance());
 128      }
 129  
 130      @Override
 131      public void flatMap(CRow input, Collector&lt;CRow&gt; out) throws Exception {

 132          List&lt;Object&gt; inputParams = Lists.newArrayList();
 133          for (Integer conValIndex : sideInfo.getEqualValIndex()) {
 134              Object equalObj = input.row().getField(conValIndex);

 135              if (equalObj == null) {
 136                  if(sideInfo.getJoinType() == JoinType.LEFT){
 137                      Row data = fillData(input.row(), null);
 138                      out.collect(new CRow(data, input.change()));



 139                  }
 140                  return;
 141              }
 142  
 143              inputParams.add(equalObj);
 144          }
 145  
 146          String key = buildKey(inputParams);
 147          List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(key);
 148          if (CollectionUtils.isEmpty(cacheList)) {
 149              if (sideInfo.getJoinType() == JoinType.LEFT) {
 150                  Row row = fillData(input.row(), null);
 151                  out.collect(new CRow(row, input.change()));


 152              } else {
 153                  return;
 154              }
 155  
 156              return;
 157          }
 158  
 159          for (Map&lt;String, Object&gt; one : cacheList) {
 160              out.collect(new CRow(fillData(input.row(), one), input.change()));

 161          }
 162      }
 163  
 164      private String buildKey(List&lt;Object&gt; equalValList) {
 165          StringBuilder sb = new StringBuilder(&quot;&quot;);
 166          for (Object equalVal : equalValList) {
 167              sb.append(equalVal).append(&quot;_&quot;);
 168          }
 169  
 170          return sb.toString();
 171      }
 172  
 173      private String buildKey(Map&lt;String, Object&gt; val, List&lt;String&gt; equalFieldList) {
 174          StringBuilder sb = new StringBuilder(&quot;&quot;);
 175          for (String equalField : equalFieldList) {
 176              sb.append(val.get(equalField)).append(&quot;_&quot;);
 177          }
 178  
 179          return sb.toString();
 180      }
 181  
 182      private MongoCollection getConn(String address, String database, String tableName) {
 183          MongoCollection dbCollection;
 184          mongoClient = new MongoClient(new MongoClientURI(address));
 185          db = mongoClient.getDatabase(database);
 186          dbCollection = db.getCollection(tableName, Document.class);
 187          return dbCollection;
 188  
 189      }
 190  
 191      private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 192          MongoSideTableInfo tableInfo = (MongoSideTableInfo) sideInfo.getSideTableInfo();
 193          MongoCollection dbCollection = null;
 194  
 195          try {
 196              for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 197                  try {
<abbr title=" 198                      dbCollection = getConn(tableInfo.getAddress(), tableInfo.getDatabase(), tableInfo.getTableName());"> 198                      dbCollection = getConn(tableInfo.getAddress(), tableInfo.getDatabase(), tableInfo.getTableName🔵</abbr>
 199                      break;
 200                  } catch (Exception e) {
 201                      if (i == CONN_RETRY_NUM - 1) {
 202                          throw new RuntimeException(&quot;&quot;, e);
 203                      }
 204  
 205                      try {
<abbr title=" 206                          String connInfo = &quot;url:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.getUserName() + &quot;,pwd:&quot; + tableInfo.getPassword();"> 206                          String connInfo = &quot;url:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.getUserName()🔵</abbr>
 207                          LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 208 -                        Thread.sleep(5 * 1000);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 209 +                        Thread.sleep(LOAD_DATA_ERROR_SLEEP_TIME);</span>
 210                      } catch (InterruptedException e1) {
 211                          LOG.error(&quot;&quot;, e1);
 212                      }
 213                  }
 214              }
 215  
 216              //load data from table
 217              String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 218              BasicDBObject basicDBObject = new BasicDBObject();
 219              for (String selectField : sideFieldNames) {
 220                  basicDBObject.append(selectField, 1);
 221              }
 222              BasicDBObject filterObject = new BasicDBObject();
 223              try {
 224                  // 填充谓词
 225                  sideInfo.getSideTableInfo().getPredicateInfoes().stream().map(info -&gt; {
 226                      BasicDBObject filterCondition = MongoUtil.buildFilterObject(info);
 227                      if (null != filterCondition) {
 228                          filterObject.append(info.getFieldName(), filterCondition);
 229                      }
 230                      return info;
 231                  }).count();
 232              } catch (Exception e) {
 233                  LOG.info(&quot;add predicate infoes error &quot;, e);
 234              }
 235  
 236  
<abbr title=" 237              FindIterable&lt;Document&gt; findIterable = dbCollection.find(filterObject).projection(basicDBObject).limit(FETCH_SIZE);"> 237              FindIterable&lt;Document&gt; findIterable = dbCollection.find(filterObject).projection(basicDBObject).limit(🔵</abbr>
 238              MongoCursor&lt;Document&gt; mongoCursor = findIterable.iterator();
 239              while (mongoCursor.hasNext()) {
 240                  Document doc = mongoCursor.next();
 241                  Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 242                  for (String fieldName : sideFieldNames) {
 243                      oneRow.put(fieldName.trim(), doc.get(fieldName.trim()));
 244                  }
 245                  String cacheKey = buildKey(oneRow, sideInfo.getEqualFieldList());
 246                  List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList());
 247                  list.add(oneRow);
 248              }
 249          } catch (Exception e) {
 250              LOG.error(&quot;&quot;, e);
 251          } finally {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 252 -            try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 253 -                if (mongoClient != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 254 -                    mongoClient.close();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 255 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 256 -            } catch (Exception e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 257 -                throw new RuntimeException(&quot;[closeMongoDB]:&quot; + e.getMessage());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 258 +            if (mongoClient != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 259 +                mongoClient.close();</span>
 260              }
 261          }
 262      }
 263  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            