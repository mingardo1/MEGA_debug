<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>267</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    267
                    <a href="266.html">prev</a>
                    <a href="268.html">next</a>
                    <a href="267_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    BroadleafCommerce/BroadleafCommerce_7372a30b9f3190df28e61f8437f110c95d36b4fa_admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/security/service/AdminSecurityServiceImpl.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;7372a30b9f3190df28e61f8437f110c95d36b4fa:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/security/service/AdminSecurityServiceImpl.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;7372a30b9f3190df28e61f8437f110c95d36b4fa^1:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/security/service/AdminSecurityServiceImpl.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;7372a30b9f3190df28e61f8437f110c95d36b4fa^2:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/security/service/AdminSecurityServiceImpl.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;65989a8b6469e6f21626a6b7292822865b1618ba:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/security/service/AdminSecurityServiceImpl.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b]], subset: [[b], [b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Open Admin Platform
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  * 
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.openadmin.server.security.service;
  19 
  20 import org.apache.commons.collections4.CollectionUtils;
  21 import org.apache.commons.lang3.BooleanUtils;
  22 import org.apache.commons.lang3.StringUtils;
  23 import org.apache.commons.logging.Log;
  24 import org.apache.commons.logging.LogFactory;
  25 import org.broadleafcommerce.common.email.service.EmailService;
  26 import org.broadleafcommerce.common.email.service.info.EmailInfo;
  27 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  28 import org.broadleafcommerce.common.event.BroadleafApplicationEventPublisher;</span>
  29 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  30 import org.broadleafcommerce.common.security.util.PasswordChange;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  31 import org.broadleafcommerce.common.security.util.PasswordUtils;</span>
  32 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  33 import org.broadleafcommerce.common.extension.ExtensionResultHolder;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  34 import org.broadleafcommerce.common.extension.ExtensionResultStatusType;</span>
  35 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  36 import org.broadleafcommerce.common.security.util.PasswordChange;
  37 import org.broadleafcommerce.common.security.util.PasswordUtils;
  38 import org.broadleafcommerce.common.service.GenericResponse;
  39 import org.broadleafcommerce.common.time.SystemTime;
  40 import org.broadleafcommerce.common.util.BLCSystemProperty;
  41 import org.broadleafcommerce.common.util.StringUtil;
  42 import org.broadleafcommerce.openadmin.server.security.dao.AdminPermissionDao;
  43 import org.broadleafcommerce.openadmin.server.security.dao.AdminRoleDao;
  44 import org.broadleafcommerce.openadmin.server.security.dao.AdminUserDao;
  45 import org.broadleafcommerce.openadmin.server.security.dao.ForgotPasswordSecurityTokenDao;
  46 import org.broadleafcommerce.openadmin.server.security.domain.AdminPermission;
  47 import org.broadleafcommerce.openadmin.server.security.domain.AdminRole;
  48 import org.broadleafcommerce.openadmin.server.security.domain.AdminUser;
  49 import org.broadleafcommerce.openadmin.server.security.domain.ForgotPasswordSecurityToken;
  50 import org.broadleafcommerce.openadmin.server.security.domain.ForgotPasswordSecurityTokenImpl;
  51 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  52 import org.broadleafcommerce.openadmin.server.security.event.AdminForgotPasswordEvent;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  53 import org.broadleafcommerce.openadmin.server.security.event.AdminForgotUsernameEvent;</span>
  54 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  55 import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  56 import org.springframework.security.core.Authentication;</span>
  57 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  58 import org.broadleafcommerce.openadmin.server.security.extension.AdminSecurityServiceExtensionManager;</span>
  59 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  60 import org.broadleafcommerce.openadmin.server.security.service.type.PermissionType;
  61 import org.broadleafcommerce.openadmin.server.security.service.user.AdminUserDetails;
  62 import org.springframework.beans.factory.NoSuchBeanDefinitionException;
  63 import org.springframework.beans.factory.annotation.Autowired;
  64 import org.springframework.beans.factory.annotation.Qualifier;
  65 import org.springframework.context.ApplicationContext;
  66 import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
  67 import org.springframework.security.core.Authentication;
  68 import org.springframework.security.core.context.SecurityContextHolder;
  69 import org.springframework.security.crypto.password.PasswordEncoder;
  70 import org.springframework.stereotype.Service;
  71 import org.springframework.transaction.annotation.Transactional;
  72 
  73 import java.net.URI;
  74 import java.util.ArrayList;
  75 import java.util.Date;
  76 import java.util.List;
  77 
  78 import javax.annotation.Resource;
  79 import javax.cache.Cache;
  80 import javax.cache.Caching;
  81 
  82 
  83 /**
  84  *
  85  * @author jfischer
  86  *
  87  */
  88 @Service(&quot;blAdminSecurityService&quot;)
  89 public class AdminSecurityServiceImpl implements AdminSecurityService {
  90 
  91     private static final Log LOG = LogFactory.getLog(AdminSecurityServiceImpl.class);
  92 
  93     private static int TEMP_PASSWORD_LENGTH = 12;
  94     private static final int FULL_PASSWORD_LENGTH = 16;
  95 
  96     @Autowired
  97     @Qualifier(&quot;blApplicationEventPublisher&quot;)
  98     protected BroadleafApplicationEventPublisher eventPublisher;
  99 
 100     @Resource(name = &quot;blAdminRoleDao&quot;)
 101     protected AdminRoleDao adminRoleDao;
 102 
 103     @Resource(name = &quot;blAdminUserDao&quot;)
 104     protected AdminUserDao adminUserDao;
 105 
 106     @Resource(name = &quot;blForgotPasswordSecurityTokenDao&quot;)
 107     protected ForgotPasswordSecurityTokenDao forgotPasswordSecurityTokenDao;
 108 
 109     @Resource(name = &quot;blAdminPermissionDao&quot;)
 110     protected AdminPermissionDao adminPermissionDao;
 111 
 112     protected static String CACHE_NAME = &quot;blSecurityElements&quot;;
 113     protected static String CACHE_KEY_PREFIX = &quot;security:&quot;;
 114 
<abbr title=" 115     protected Cache&lt;Object, Object&gt; cache = Caching.getCachingProvider().getCacheManager(URI.create(&quot;ehcache:fakeuri&quot;), getClass().getClassLoader()).getCache(CACHE_NAME);"> 115     protected Cache&lt;Object, Object&gt; cache = Caching.getCachingProvider().getCacheManager(URI.create(&quot;ehcaðŸ”µ</abbr>
 116 
 117     /**
<abbr title=" 118      * &lt;p&gt;This is simply a placeholder to be used by {@link #setupPasswordEncoder()} to determine if we&#x27;re using the"> 118      * &lt;p&gt;This is simply a placeholder to be used by {@link #setupPasswordEncoder()} to determine if we&#x27;rðŸ”µ</abbr>
<abbr title=" 119      * new {@link PasswordEncoder} or the deprecated {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder}"> 119      * new {@link PasswordEncoder} or the deprecated {@link org.springframework.security.authentication.eðŸ”µ</abbr>
 120      */
 121     @Resource(name=&quot;blAdminPasswordEncoder&quot;)
 122     protected PasswordEncoder passwordEncoderBean;
 123 
 124     @Resource(name=&quot;blEmailService&quot;)
 125     protected EmailService emailService;
 126 
 127     @Resource(name=&quot;blSendAdminResetPasswordEmail&quot;)
 128     protected EmailInfo resetPasswordEmailInfo;
 129 
 130     @Resource(name=&quot;blSendAdminUsernameEmailInfo&quot;)
 131     protected EmailInfo sendUsernameEmailInfo;
 132 
 133     @Resource(name = &quot;blAdminSecurityServiceExtensionManager&quot;)
 134     protected AdminSecurityServiceExtensionManager extensionManager;
 135 
 136     protected int getTokenExpiredMinutes() {
 137         return BLCSystemProperty.resolveIntSystemProperty(&quot;tokenExpiredMinutes&quot;);
 138     }
 139 
 140     protected String getResetPasswordURL() {
 141         return BLCSystemProperty.resolveSystemProperty(&quot;resetPasswordURL&quot;);
 142     }
 143 
 144     @Override
 145     @Transactional(&quot;blTransactionManager&quot;)
 146     public void deleteAdminPermission(AdminPermission permission) {
 147 
 148         adminPermissionDao.deleteAdminPermission(permission);
 149         clearAdminSecurityCache();
 150     }
 151 
 152     @Override
 153     @Transactional(&quot;blTransactionManager&quot;)
 154     public void deleteAdminRole(AdminRole role) {
 155         adminRoleDao.deleteAdminRole(role);
 156         clearAdminSecurityCache();
 157     }
 158 
 159     @Override
 160     @Transactional(&quot;blTransactionManager&quot;)
 161     public void deleteAdminUser(AdminUser user) {
 162         adminUserDao.deleteAdminUser(user);
 163         clearAdminSecurityCache();
 164     }
 165 
 166     @Override
 167     public AdminPermission readAdminPermissionById(Long id) {
 168         return adminPermissionDao.readAdminPermissionById(id);
 169     }
 170 
 171     @Override
 172     public AdminRole readAdminRoleById(Long id) {
 173         return adminRoleDao.readAdminRoleById(id);
 174     }
 175 
 176     @Override
 177     public AdminUser readAdminUserById(Long id) {
 178         return adminUserDao.readAdminUserById(id);
 179     }
 180 
 181     @Override
 182     @Transactional(&quot;blTransactionManager&quot;)
 183     public AdminPermission saveAdminPermission(AdminPermission permission) {
 184         permission = adminPermissionDao.saveAdminPermission(permission);
 185         clearAdminSecurityCache();
 186         return permission;
 187     }
 188 
 189     @Override
 190     @Transactional(&quot;blTransactionManager&quot;)
 191     public AdminRole saveAdminRole(AdminRole role) {
 192         role = adminRoleDao.saveAdminRole(role);
 193         clearAdminSecurityCache();
 194         return role;
 195     }
 196 
 197     @Override
 198     @Transactional(&quot;blTransactionManager&quot;)
 199     public AdminUser saveAdminUser(AdminUser user) {
 200         boolean encodePasswordNeeded = false;
 201         String unencodedPassword = user.getUnencodedPassword();
 202 
 203         if (user.getUnencodedPassword() != null) {
 204             encodePasswordNeeded = true;
 205             user.setPassword(unencodedPassword);
 206         }
 207 
 208         // If no password is set, default to a secure password.
 209         if (user.getPassword() == null) {
 210             user.setPassword(generateSecurePassword());
 211         }
 212 
 213         AdminUser returnUser = adminUserDao.saveAdminUser(user);
 214 
 215         if (encodePasswordNeeded) {
 216             returnUser.setPassword(encodePassword(unencodedPassword));
 217         }
 218 
 219         returnUser = adminUserDao.saveAdminUser(returnUser);
 220         clearAdminSecurityCache();
 221         return returnUser;
 222     }
 223 
 224     @Override
 225     public void clearAdminSecurityCache() {
 226         if (LOG.isTraceEnabled()) {
 227             LOG.trace(&quot;Admin Security Cache DELETE&quot;);
 228         }
 229         cache.removeAll();
 230     }
 231 
 232     protected String generateSecurePassword() {
 233         return PasswordUtils.generateSecurePassword(FULL_PASSWORD_LENGTH);
 234     }
 235 
 236     @Override
 237     @Transactional(&quot;blTransactionManager&quot;)
 238     public AdminUser changePassword(PasswordChange passwordChange) {
 239         AdminUser user = readAdminUserByUserName(passwordChange.getUsername());
 240         user.setUnencodedPassword(passwordChange.getNewPassword());
 241         user = saveAdminUser(user);
 242         Authentication auth = SecurityContextHolder.getContext().getAuthentication();
<abbr title=" 243         UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(passwordChange.getUsername(), passwordChange.getNewPassword(), auth.getAuthorities());"> 243         UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(passworðŸ”µ</abbr>
 244         SecurityContextHolder.getContext().setAuthentication(authRequest);
 245         auth.setAuthenticated(false);
 246         return user;
 247     }
 248 
 249     @Override
<abbr title=" 250     public boolean isUserQualifiedForOperationOnCeilingEntity(AdminUser adminUser, PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 250     public boolean isUserQualifiedForOperationOnCeilingEntity(AdminUser adminUser, PermissionType permissðŸ”µ</abbr>
 251         Boolean response = null;
 252         String cacheKey = buildCacheKey(adminUser, permissionType, ceilingEntityFullyQualifiedName);
 253         Object objectValue = cache.get(cacheKey);
 254 
 255         if (objectValue != null) {
 256             response = (Boolean) objectValue;
 257 
 258             if (LOG.isTraceEnabled()) {
 259                 LOG.trace(&quot;Admin Security Cache GET For: \&quot;&quot; + cacheKey + &quot;\&quot; = &quot; + response);
 260             }
 261         }
 262 
 263         if (response == null) {
 264             if (extensionManager != null) {
 265                 ExtensionResultHolder&lt;Boolean&gt; result = new ExtensionResultHolder&lt;Boolean&gt;();
<abbr title=" 266                 ExtensionResultStatusType resultStatusType = extensionManager.getProxy().hasPrivilegesForOperation(adminUser, permissionType, result);"> 266                 ExtensionResultStatusType resultStatusType = extensionManager.getProxy().hasPrivilegesForðŸ”µ</abbr>
 267                 if (ExtensionResultStatusType.HANDLED == resultStatusType) {
 268                     response = result.getResult();
 269                 }
 270             }
 271 
 272             if (response == null || !response) {
<abbr title=" 273                 response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntity(adminUser, permissionType, ceilingEntityFullyQualifiedName);"> 273                 response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntity(adminUser, permiðŸ”µ</abbr>
 274 
 275                 if (!response) {
<abbr title=" 276                     response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntityViaDefaultPermissions(ceilingEntityFullyQualifiedName);"> 276                     response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntityViaDefaultPerðŸ”µ</abbr>
 277                 }
 278             }
 279 
 280             cache.put(cacheKey, response);
 281 
 282             if (LOG.isTraceEnabled()) {
 283                 LOG.trace(&quot;Admin Security Cache PUT For: \&quot;&quot; + cacheKey + &quot;\&quot; = &quot; + response);
 284             }
 285         }
 286 
 287         return response;
 288     }
 289 
<abbr title=" 290     protected String buildCacheKey(AdminUser adminUser, PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 290     protected String buildCacheKey(AdminUser adminUser, PermissionType permissionType, String ceilingEntiðŸ”µ</abbr>
 291         return CACHE_KEY_PREFIX
 292                + &quot;user:&quot; + adminUser.getId() + &quot;,&quot;
 293                + &quot;permType:&quot; + permissionType.getFriendlyType() + &quot;,&quot;
 294                + &quot;ceiling:&quot; + ceilingEntityFullyQualifiedName;
 295     }
 296 
 297     @Override
<abbr title=" 298     public boolean doesOperationExistForCeilingEntity(PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 298     public boolean doesOperationExistForCeilingEntity(PermissionType permissionType, String ceilingEntityðŸ”µ</abbr>
<abbr title=" 299         return adminPermissionDao.doesOperationExistForCeilingEntity(permissionType, ceilingEntityFullyQualifiedName);"> 299         return adminPermissionDao.doesOperationExistForCeilingEntity(permissionType, ceilingEntityFullyQuðŸ”µ</abbr>
 300     }
 301 
 302     @Override
 303     public AdminUser readAdminUserByUserName(String userName) {
 304         return adminUserDao.readAdminUserByUserName(userName);
 305     }
 306 
 307     @Override
 308     public List&lt;AdminUser&gt; readAdminUsersByEmail(String email) {
 309         return adminUserDao.readAdminUserByEmail(email);
 310     }
 311 
 312     @Override
 313     public List&lt;AdminUser&gt; readAllAdminUsers() {
 314         return adminUserDao.readAllAdminUsers();
 315     }
 316 
 317     @Override
 318     public List&lt;AdminRole&gt; readAllAdminRoles() {
 319         return adminRoleDao.readAllAdminRoles();
 320     }
 321 
 322     @Override
 323     public List&lt;AdminPermission&gt; readAllAdminPermissions() {
 324         return adminPermissionDao.readAllAdminPermissions();
 325     }
 326 
 327     @Override
 328     @Transactional(&quot;blTransactionManager&quot;)
 329     public GenericResponse sendForgotUsernameNotification(String emailAddress) {
 330         GenericResponse response = new GenericResponse();
 331         List&lt;AdminUser&gt; users = null;
 332         if (emailAddress != null) {
 333             users = adminUserDao.readAdminUserByEmail(emailAddress);
 334         }
 335         if (CollectionUtils.isEmpty(users)) {
 336             response.addErrorCode(&quot;notFound&quot;);
 337         } else {
 338             List&lt;String&gt; activeUsernames = new ArrayList&lt;String&gt;();
 339             for (AdminUser user : users) {
 340                 if (user.getActiveStatusFlag()) {
 341                     activeUsernames.add(user.getLogin());
 342                 }
 343             }
 344 
 345             if (activeUsernames.size() &gt; 0) {
<abbr title=" 346                 eventPublisher.publishEvent(new AdminForgotUsernameEvent(this, emailAddress, null, activeUsernames));"> 346                 eventPublisher.publishEvent(new AdminForgotUsernameEvent(this, emailAddress, null, activeðŸ”µ</abbr>
 347             } else {
 348                 // send inactive username found email.
 349                 response.addErrorCode(&quot;inactiveUser&quot;);
 350             }
 351         }
 352         return response;
 353     }
 354 
 355     @Override
 356     @Transactional(&quot;blTransactionManager&quot;)
 357     public GenericResponse sendResetPasswordNotification(String username) {
 358         GenericResponse response = new GenericResponse();
 359         AdminUser user = null;
 360 
 361         if (username != null) {
 362             user = adminUserDao.readAdminUserByUserName(username);
 363         }
 364 
 365         checkUser(user,response);
 366 
 367         if (! response.getHasErrors()) {
 368             String token = PasswordUtils.generateSecurePassword(TEMP_PASSWORD_LENGTH);
 369             token = token.toLowerCase();
 370 
 371             ForgotPasswordSecurityToken fpst = new ForgotPasswordSecurityTokenImpl();
 372             fpst.setAdminUserId(user.getId());
 373             fpst.setToken(encodePassword(token));
 374             fpst.setCreateDate(SystemTime.asDate());
 375             forgotPasswordSecurityTokenDao.saveToken(fpst);
 376 
 377             String resetPasswordUrl = getResetPasswordURL();
 378             if (!StringUtils.isEmpty(resetPasswordUrl)) {
 379                 if (resetPasswordUrl.contains(&quot;?&quot;)) {
 380                     resetPasswordUrl=resetPasswordUrl+&quot;&amp;token=&quot;+token;
 381                 } else {
 382                     resetPasswordUrl=resetPasswordUrl+&quot;?token=&quot;+token;
 383                 }
 384             }
 385 
<abbr title=" 386             eventPublisher.publishEvent(new AdminForgotPasswordEvent(this, user.getId(), token, resetPasswordUrl));"> 386             eventPublisher.publishEvent(new AdminForgotPasswordEvent(this, user.getId(), token, resetPassðŸ”µ</abbr>
 387         }
 388         return response;
 389     }
 390 
 391     @Override
 392     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 393     public GenericResponse resetPasswordUsingToken(String username, String token, String password, String confirmPassword) {"> 393     public GenericResponse resetPasswordUsingToken(String username, String token, String password, StringðŸ”µ</abbr>
 394         GenericResponse response = new GenericResponse();
 395         AdminUser user = null;
 396         if (username != null) {
 397             user = adminUserDao.readAdminUserByUserName(username);
 398         }
 399         checkUser(user, response);
 400         checkPassword(password, confirmPassword, response);
 401         if (StringUtils.isBlank(token)) {
 402             response.addErrorCode(&quot;invalidToken&quot;);
 403         }
 404 
 405         ForgotPasswordSecurityToken fpst = null;
 406         if (! response.getHasErrors()) {
 407             token = token.toLowerCase();
<abbr title=" 408             List&lt;ForgotPasswordSecurityToken&gt; fpstoks = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserId(user.getId());"> 408             List&lt;ForgotPasswordSecurityToken&gt; fpstoks = forgotPasswordSecurityTokenDao.readUnusedTokensByðŸ”µ</abbr>
 409             for (ForgotPasswordSecurityToken fpstok : fpstoks) {
 410                 if (isPasswordValid(fpstok.getToken(), token)) {
 411                     fpst = fpstok;
 412                     break;
 413                 }
 414             }
 415             if (fpst == null) {
 416                 response.addErrorCode(&quot;invalidToken&quot;);
 417             } else if (fpst.isTokenUsedFlag()) {
 418                 response.addErrorCode(&quot;tokenUsed&quot;);
 419             } else if (isTokenExpired(fpst)) {
 420                 response.addErrorCode(&quot;tokenExpired&quot;);
 421             }
 422         }
 423 
 424         if (! response.getHasErrors()) {
 425             if (! user.getId().equals(fpst.getAdminUserId())) {
 426                 if (LOG.isWarnEnabled()) {
<abbr title=" 427                     LOG.warn(&quot;Password reset attempt tried with mismatched user and token &quot; + user.getId() + &quot;, &quot; + StringUtil.sanitize(token));"> 427                     LOG.warn(&quot;Password reset attempt tried with mismatched user and token &quot; + user.getId(ðŸ”µ</abbr>
 428                 }
 429                 response.addErrorCode(&quot;invalidToken&quot;);
 430             }
 431         }
 432 
 433         if (! response.getHasErrors()) {
 434             user.setUnencodedPassword(password);
 435             saveAdminUser(user);
 436             invalidateAllTokensForAdminUser(user);
 437         }
 438 
 439         return response;
 440     }
 441 
 442     protected void invalidateAllTokensForAdminUser(AdminUser user) {
<abbr title=" 443         List&lt;ForgotPasswordSecurityToken&gt; tokens = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserId(user.getId());"> 443         List&lt;ForgotPasswordSecurityToken&gt; tokens = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminðŸ”µ</abbr>
 444         for (ForgotPasswordSecurityToken token : tokens) {
 445             token.setTokenUsedFlag(true);
 446             forgotPasswordSecurityTokenDao.saveToken(token);
 447         }
 448     }
 449 
 450     protected void checkUser(AdminUser user, GenericResponse response) {
 451         if (user == null) {
 452             response.addErrorCode(&quot;invalidUser&quot;);
 453         } else if (StringUtils.isBlank(user.getEmail())) {
 454             response.addErrorCode(&quot;emailNotFound&quot;);
 455         } else if (BooleanUtils.isNotTrue(user.getActiveStatusFlag())) {
 456             response.addErrorCode(&quot;inactiveUser&quot;);
 457         }
 458     }
 459 
 460     protected void checkPassword(String password, String confirmPassword, GenericResponse response) {
 461         if (StringUtils.isBlank(password) || StringUtils.isBlank(confirmPassword)) {
 462             response.addErrorCode(&quot;invalidPassword&quot;);
 463         } else if (! password.equals(confirmPassword)) {
 464             response.addErrorCode(&quot;passwordMismatch&quot;);
 465         }
 466     }
 467 
<abbr title=" 468     protected void checkExistingPassword(String unencodedPassword, AdminUser user, GenericResponse response) {"> 468     protected void checkExistingPassword(String unencodedPassword, AdminUser user, GenericResponse responðŸ”µ</abbr>
 469         if (!isPasswordValid(user.getPassword(), unencodedPassword)) {
 470             response.addErrorCode(&quot;invalidPassword&quot;);
 471         }
 472     }
 473 
 474     protected boolean isTokenExpired(ForgotPasswordSecurityToken fpst) {
 475         Date now = SystemTime.asDate();
 476         long currentTimeInMillis = now.getTime();
 477         long tokenSaveTimeInMillis = fpst.getCreateDate().getTime();
 478         long minutesSinceSave = (currentTimeInMillis - tokenSaveTimeInMillis)/60000;
 479         return minutesSinceSave &gt; getTokenExpiredMinutes();
 480     }
 481 
 482     public static int getPASSWORD_TOKEN_LENGTH() {
 483         return TEMP_PASSWORD_LENGTH;
 484     }
 485 
 486     public static void setPASSWORD_TOKEN_LENGTH(int PASSWORD_TOKEN_LENGTH) {
 487         AdminSecurityServiceImpl.TEMP_PASSWORD_LENGTH = PASSWORD_TOKEN_LENGTH;
 488     }
 489 
 490     public EmailInfo getSendUsernameEmailInfo() {
 491         return sendUsernameEmailInfo;
 492     }
 493 
 494     public void setSendUsernameEmailInfo(EmailInfo sendUsernameEmailInfo) {
 495         this.sendUsernameEmailInfo = sendUsernameEmailInfo;
 496     }
 497 
 498     public EmailInfo getResetPasswordEmailInfo() {
 499         return resetPasswordEmailInfo;
 500     }
 501 
 502     public void setResetPasswordEmailInfo(EmailInfo resetPasswordEmailInfo) {
 503         this.resetPasswordEmailInfo = resetPasswordEmailInfo;
 504     }
 505 
 506     @Override
 507     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 508     public GenericResponse changePassword(String username, String oldPassword, String password, String confirmPassword) {"> 508     public GenericResponse changePassword(String username, String oldPassword, String password, String coðŸ”µ</abbr>
 509         GenericResponse response = new GenericResponse();
 510         AdminUser user = null;
 511         if (username != null) {
 512             user = adminUserDao.readAdminUserByUserName(username);
 513         }
 514         checkUser(user, response);
 515         checkPassword(password, confirmPassword, response);
 516 
 517         if (!response.getHasErrors()) {
 518             checkExistingPassword(oldPassword, user, response);
 519         }
 520 
 521         if (!response.getHasErrors()) {
 522             user.setUnencodedPassword(password);
 523             saveAdminUser(user);
 524 
 525         }
 526 
 527         return response;
 528 
 529     }
 530 
 531     /**
<abbr title=" 532      * Determines if a password is valid by comparing it to the encoded string, salting is handled internally to the {@link PasswordEncoder}."> 532      * Determines if a password is valid by comparing it to the encoded string, salting is handled internðŸ”µ</abbr>
 533      * &lt;p&gt;
<abbr title=" 534      * This method must always be called to verify if a password is valid after the original encoded password is generated"> 534      * This method must always be called to verify if a password is valid after the original encoded passðŸ”µ</abbr>
<abbr title=" 535      * due to {@link PasswordEncoder} randomly generating salts internally and appending them to the resulting hash."> 535      * due to {@link PasswordEncoder} randomly generating salts internally and appending them to the resuðŸ”µ</abbr>
 536      *
 537      * @param encodedPassword the encoded password
 538      * @param rawPassword the raw password to check against the encoded password
 539      * @return true if rawPassword matches the encodedPassword, false otherwise
 540      */
 541     protected boolean isPasswordValid(String encodedPassword, String rawPassword) {
 542         return passwordEncoderBean.matches(rawPassword, encodedPassword);
 543     }
 544 
 545     /**
 546      * Generate an encoded password from a raw password
 547      * &lt;p&gt;
<abbr title=" 548      * This method can only be called once per password. The salt is randomly generated internally in the {@link PasswordEncoder}"> 548      * This method can only be called once per password. The salt is randomly generated internally in theðŸ”µ</abbr>
<abbr title=" 549      * and appended to the hash to provide the resulting encoded password. Once this has been called on a password,"> 549      * and appended to the hash to provide the resulting encoded password. Once this has been called on aðŸ”µ</abbr>
<abbr title=" 550      * going forward all checks for authenticity must be done by {@link #isPasswordValid(String, String)} as encoding the"> 550      * going forward all checks for authenticity must be done by {@link #isPasswordValid(String, String)}ðŸ”µ</abbr>
 551      * same password twice will result in different encoded passwords.
 552      *
 553      * @param rawPassword the unencoded password to encode
 554      * @return the encoded password
 555      */
 556     protected String encodePassword(String rawPassword) {
 557         return passwordEncoderBean.encode(rawPassword);
 558     }
 559 }</pre></td>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Open Admin Platform
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.openadmin.server.security.service;
  19 
  20 import org.apache.commons.collections4.CollectionUtils;
  21 import org.apache.commons.lang3.BooleanUtils;
  22 import org.apache.commons.lang3.StringUtils;
  23 import org.apache.commons.logging.Log;
  24 import org.apache.commons.logging.LogFactory;
  25 import org.broadleafcommerce.common.email.service.EmailService;
  26 import org.broadleafcommerce.common.email.service.info.EmailInfo;
  27 import org.broadleafcommerce.common.event.BroadleafApplicationEventPublisher;
  28 import org.broadleafcommerce.common.extension.ExtensionResultHolder;
  29 import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  30 import org.broadleafcommerce.common.security.util.PasswordChange;
  31 import org.broadleafcommerce.common.security.util.PasswordUtils;
  32 import org.broadleafcommerce.common.service.GenericResponse;
  33 import org.broadleafcommerce.common.time.SystemTime;
  34 import org.broadleafcommerce.common.util.BLCSystemProperty;
  35 import org.broadleafcommerce.common.util.StringUtil;
  36 import org.broadleafcommerce.openadmin.server.security.dao.AdminPermissionDao;
  37 import org.broadleafcommerce.openadmin.server.security.dao.AdminRoleDao;
  38 import org.broadleafcommerce.openadmin.server.security.dao.AdminUserDao;
  39 import org.broadleafcommerce.openadmin.server.security.dao.ForgotPasswordSecurityTokenDao;
  40 import org.broadleafcommerce.openadmin.server.security.domain.AdminPermission;
  41 import org.broadleafcommerce.openadmin.server.security.domain.AdminRole;
  42 import org.broadleafcommerce.openadmin.server.security.domain.AdminUser;
  43 import org.broadleafcommerce.openadmin.server.security.domain.ForgotPasswordSecurityToken;
  44 import org.broadleafcommerce.openadmin.server.security.domain.ForgotPasswordSecurityTokenImpl;
  45 import org.broadleafcommerce.openadmin.server.security.event.AdminForgotPasswordEvent;
  46 import org.broadleafcommerce.openadmin.server.security.event.AdminForgotUsernameEvent;
  47 import org.broadleafcommerce.openadmin.server.security.extension.AdminSecurityServiceExtensionManager;
  48 import org.broadleafcommerce.openadmin.server.security.service.type.PermissionType;
  49 import org.springframework.context.ApplicationContext;
  50 import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
  51 import org.springframework.security.core.Authentication;
  52 import org.springframework.security.core.context.SecurityContextHolder;
  53 import org.springframework.security.crypto.password.PasswordEncoder;
  54 import org.springframework.stereotype.Service;
  55 import org.springframework.transaction.annotation.Transactional;
  56 
  57 import java.net.URI;
  58 import java.util.ArrayList;
  59 import java.util.Date;
  60 import java.util.List;
  61 
  62 import javax.annotation.Resource;
  63 import javax.cache.Cache;
  64 import javax.cache.Caching;
  65 
  66 
  67 /**
  68  *
  69  * @author jfischer
  70  *
  71  */
  72 @Service(&quot;blAdminSecurityService&quot;)
  73 public class AdminSecurityServiceImpl implements AdminSecurityService {
  74 
  75     private static final Log LOG = LogFactory.getLog(AdminSecurityServiceImpl.class);
  76 
  77     private static int TEMP_PASSWORD_LENGTH = 12;
  78     private static final int FULL_PASSWORD_LENGTH = 16;
  79 
  80     @Autowired
  81     @Qualifier(&quot;blApplicationEventPublisher&quot;)
  82     protected BroadleafApplicationEventPublisher eventPublisher;
  83 
  84     @Resource(name = &quot;blAdminRoleDao&quot;)
  85     protected AdminRoleDao adminRoleDao;
  86 
  87     @Resource(name = &quot;blAdminUserDao&quot;)
  88     protected AdminUserDao adminUserDao;
  89 
  90     @Resource(name = &quot;blForgotPasswordSecurityTokenDao&quot;)
  91     protected ForgotPasswordSecurityTokenDao forgotPasswordSecurityTokenDao;
  92 
  93     @Resource(name = &quot;blAdminPermissionDao&quot;)
  94     protected AdminPermissionDao adminPermissionDao;
  95 
  96     protected static String CACHE_NAME = &quot;blSecurityElements&quot;;
  97     protected static String CACHE_KEY_PREFIX = &quot;security:&quot;;
  98 
<abbr title="  99     protected Cache&lt;Object, Object&gt; cache = Caching.getCachingProvider().getCacheManager(URI.create(&quot;ehcache:fakeuri&quot;), getClass().getClassLoader()).getCache(CACHE_NAME);">  99     protected Cache&lt;Object, Object&gt; cache = Caching.getCachingProvider().getCacheManager(URI.create(&quot;ehcaðŸ”µ</abbr>
 100 
 101     /**
<abbr title=" 102      * &lt;p&gt;This is simply a placeholder to be used by {@link #setupPasswordEncoder()} to determine if we&#x27;re using the"> 102      * &lt;p&gt;This is simply a placeholder to be used by {@link #setupPasswordEncoder()} to determine if we&#x27;rðŸ”µ</abbr>
<abbr title=" 103      * new {@link PasswordEncoder} or the deprecated {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder}"> 103      * new {@link PasswordEncoder} or the deprecated {@link org.springframework.security.authentication.eðŸ”µ</abbr>
 104      */
 105     @Resource(name=&quot;blAdminPasswordEncoder&quot;)
 106     protected PasswordEncoder passwordEncoderBean;
 107 
 108     @Resource(name=&quot;blEmailService&quot;)
 109     protected EmailService emailService;
 110 
 111     @Resource(name=&quot;blSendAdminResetPasswordEmail&quot;)
 112     protected EmailInfo resetPasswordEmailInfo;
 113 
 114     @Resource(name=&quot;blSendAdminUsernameEmailInfo&quot;)
 115     protected EmailInfo sendUsernameEmailInfo;
 116 
 117     @Resource(name = &quot;blAdminSecurityServiceExtensionManager&quot;)
 118     protected AdminSecurityServiceExtensionManager extensionManager;
 119 
 120     protected int getTokenExpiredMinutes() {
 121         return BLCSystemProperty.resolveIntSystemProperty(&quot;tokenExpiredMinutes&quot;);
 122     }
 123 
 124     protected String getResetPasswordURL() {
 125         return BLCSystemProperty.resolveSystemProperty(&quot;resetPasswordURL&quot;);
 126     }
 127 
 128     @Override
 129     @Transactional(&quot;blTransactionManager&quot;)
 130     public void deleteAdminPermission(AdminPermission permission) {
 131 
 132         adminPermissionDao.deleteAdminPermission(permission);
 133         clearAdminSecurityCache();
 134     }
 135 
 136     @Override
 137     @Transactional(&quot;blTransactionManager&quot;)
 138     public void deleteAdminRole(AdminRole role) {
 139         adminRoleDao.deleteAdminRole(role);
 140         clearAdminSecurityCache();
 141     }
 142 
 143     @Override
 144     @Transactional(&quot;blTransactionManager&quot;)
 145     public void deleteAdminUser(AdminUser user) {
 146         adminUserDao.deleteAdminUser(user);
 147         clearAdminSecurityCache();
 148     }
 149 
 150     @Override
 151     public AdminPermission readAdminPermissionById(Long id) {
 152         return adminPermissionDao.readAdminPermissionById(id);
 153     }
 154 
 155     @Override
 156     public AdminRole readAdminRoleById(Long id) {
 157         return adminRoleDao.readAdminRoleById(id);
 158     }
 159 
 160     @Override
 161     public AdminUser readAdminUserById(Long id) {
 162         return adminUserDao.readAdminUserById(id);
 163     }
 164 
 165     @Override
 166     @Transactional(&quot;blTransactionManager&quot;)
 167     public AdminPermission saveAdminPermission(AdminPermission permission) {
 168         permission = adminPermissionDao.saveAdminPermission(permission);
 169         clearAdminSecurityCache();
 170         return permission;
 171     }
 172 
 173     @Override
 174     @Transactional(&quot;blTransactionManager&quot;)
 175     public AdminRole saveAdminRole(AdminRole role) {
 176         role = adminRoleDao.saveAdminRole(role);
 177         clearAdminSecurityCache();
 178         return role;
 179     }
 180 
 181     @Override
 182     @Transactional(&quot;blTransactionManager&quot;)
 183     public AdminUser saveAdminUser(AdminUser user) {
 184         boolean encodePasswordNeeded = false;
 185         String unencodedPassword = user.getUnencodedPassword();
 186 
 187         if (user.getUnencodedPassword() != null) {
 188             encodePasswordNeeded = true;
 189             user.setPassword(unencodedPassword);
 190         }
 191 
 192         // If no password is set, default to a secure password.
 193         if (user.getPassword() == null) {
 194             user.setPassword(generateSecurePassword());
 195         }
 196 
 197         AdminUser returnUser = adminUserDao.saveAdminUser(user);
 198 
 199         if (encodePasswordNeeded) {
 200             returnUser.setPassword(encodePassword(unencodedPassword));
 201         }
 202 
 203         returnUser = adminUserDao.saveAdminUser(returnUser);
 204         clearAdminSecurityCache();
 205         return returnUser;
 206     }
 207 
 208     @Override
 209     public void clearAdminSecurityCache() {
 210         if (LOG.isTraceEnabled()) {
 211             LOG.trace(&quot;Admin Security Cache DELETE&quot;);
 212         }
 213         cache.removeAll();
 214     }
 215 
 216     protected String generateSecurePassword() {
 217         return PasswordUtils.generateSecurePassword(FULL_PASSWORD_LENGTH);
 218     }
 219 
 220     @Override
 221     @Transactional(&quot;blTransactionManager&quot;)
 222     public AdminUser changePassword(PasswordChange passwordChange) {
 223         AdminUser user = readAdminUserByUserName(passwordChange.getUsername());
 224         user.setUnencodedPassword(passwordChange.getNewPassword());
 225         user = saveAdminUser(user);
 226         Authentication auth = SecurityContextHolder.getContext().getAuthentication();
<abbr title=" 227         UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(passwordChange.getUsername(), passwordChange.getNewPassword(), auth.getAuthorities());"> 227         UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(passworðŸ”µ</abbr>
 228         SecurityContextHolder.getContext().setAuthentication(authRequest);
 229         auth.setAuthenticated(false);
 230         return user;
 231     }
 232 
 233     @Override
<abbr title=" 234     public boolean isUserQualifiedForOperationOnCeilingEntity(AdminUser adminUser, PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 234     public boolean isUserQualifiedForOperationOnCeilingEntity(AdminUser adminUser, PermissionType permissðŸ”µ</abbr>
 235         Boolean response = null;
 236         String cacheKey = buildCacheKey(adminUser, permissionType, ceilingEntityFullyQualifiedName);
 237         Object objectValue = cache.get(cacheKey);
 238 
 239         if (objectValue != null) {
 240             response = (Boolean) objectValue;
 241 
 242             if (LOG.isTraceEnabled()) {
 243                 LOG.trace(&quot;Admin Security Cache GET For: \&quot;&quot; + cacheKey + &quot;\&quot; = &quot; + response);
 244             }
 245         }
 246 
 247         if (response == null) {
 248             if (extensionManager != null) {
 249                 ExtensionResultHolder&lt;Boolean&gt; result = new ExtensionResultHolder&lt;Boolean&gt;();
<abbr title=" 250                 ExtensionResultStatusType resultStatusType = extensionManager.getProxy().hasPrivilegesForOperation(adminUser, permissionType, result);"> 250                 ExtensionResultStatusType resultStatusType = extensionManager.getProxy().hasPrivilegesForðŸ”µ</abbr>
 251                 if (ExtensionResultStatusType.HANDLED == resultStatusType) {
 252                     response = result.getResult();
 253                 }
 254             }
 255 
 256             if (response == null || !response) {
<abbr title=" 257             response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntity(adminUser, permissionType, ceilingEntityFullyQualifiedName);"> 257             response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntity(adminUser, permissioðŸ”µ</abbr>
 258 
 259             if (!response) {
<abbr title=" 260                 response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntityViaDefaultPermissions(ceilingEntityFullyQualifiedName);"> 260                 response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntityViaDefaultPermissðŸ”µ</abbr>
 261             }
 262             }
 263 
 264             cache.put(cacheKey, response);
 265 
 266             if (LOG.isTraceEnabled()) {
 267                 LOG.trace(&quot;Admin Security Cache PUT For: \&quot;&quot; + cacheKey + &quot;\&quot; = &quot; + response);
 268             }
 269         }
 270 
 271         return response;
 272     }
 273 
<abbr title=" 274     protected String buildCacheKey(AdminUser adminUser, PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 274     protected String buildCacheKey(AdminUser adminUser, PermissionType permissionType, String ceilingEntiðŸ”µ</abbr>
 275         return CACHE_KEY_PREFIX
 276                + &quot;user:&quot; + adminUser.getId() + &quot;,&quot;
 277                + &quot;permType:&quot; + permissionType.getFriendlyType() + &quot;,&quot;
 278                + &quot;ceiling:&quot; + ceilingEntityFullyQualifiedName;
 279     }
 280 
 281     @Override
<abbr title=" 282     public boolean doesOperationExistForCeilingEntity(PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 282     public boolean doesOperationExistForCeilingEntity(PermissionType permissionType, String ceilingEntityðŸ”µ</abbr>
<abbr title=" 283         return adminPermissionDao.doesOperationExistForCeilingEntity(permissionType, ceilingEntityFullyQualifiedName);"> 283         return adminPermissionDao.doesOperationExistForCeilingEntity(permissionType, ceilingEntityFullyQuðŸ”µ</abbr>
 284     }
 285 
 286     @Override
 287     public AdminUser readAdminUserByUserName(String userName) {
 288         return adminUserDao.readAdminUserByUserName(userName);
 289     }
 290 
 291     @Override
 292     public List&lt;AdminUser&gt; readAdminUsersByEmail(String email) {
 293         return adminUserDao.readAdminUserByEmail(email);
 294     }
 295 
 296     @Override
 297     public List&lt;AdminUser&gt; readAllAdminUsers() {
 298         return adminUserDao.readAllAdminUsers();
 299     }
 300 
 301     @Override
 302     public List&lt;AdminRole&gt; readAllAdminRoles() {
 303         return adminRoleDao.readAllAdminRoles();
 304     }
 305 
 306     @Override
 307     public List&lt;AdminPermission&gt; readAllAdminPermissions() {
 308         return adminPermissionDao.readAllAdminPermissions();
 309     }
 310 
 311     @Override
 312     @Transactional(&quot;blTransactionManager&quot;)
 313     public GenericResponse sendForgotUsernameNotification(String emailAddress) {
 314         GenericResponse response = new GenericResponse();
 315         List&lt;AdminUser&gt; users = null;
 316         if (emailAddress != null) {
 317             users = adminUserDao.readAdminUserByEmail(emailAddress);
 318         }
 319         if (CollectionUtils.isEmpty(users)) {
 320             response.addErrorCode(&quot;notFound&quot;);
 321         } else {
 322             List&lt;String&gt; activeUsernames = new ArrayList&lt;String&gt;();
 323             for (AdminUser user : users) {
 324                 if (user.getActiveStatusFlag()) {
 325                     activeUsernames.add(user.getLogin());
 326                 }
 327             }
 328 
 329             if (activeUsernames.size() &gt; 0) {
<abbr title=" 330                 eventPublisher.publishEvent(new AdminForgotUsernameEvent(this, emailAddress, null, activeUsernames));"> 330                 eventPublisher.publishEvent(new AdminForgotUsernameEvent(this, emailAddress, null, activeðŸ”µ</abbr>
 331             } else {
 332                 // send inactive username found email.
 333                 response.addErrorCode(&quot;inactiveUser&quot;);
 334             }
 335         }
 336         return response;
 337     }
 338 
 339     @Override
 340     @Transactional(&quot;blTransactionManager&quot;)
 341     public GenericResponse sendResetPasswordNotification(String username) {
 342         GenericResponse response = new GenericResponse();
 343         AdminUser user = null;
 344 
 345         if (username != null) {
 346             user = adminUserDao.readAdminUserByUserName(username);
 347         }
 348 
 349         checkUser(user,response);
 350 
 351         if (! response.getHasErrors()) {
 352             String token = PasswordUtils.generateSecurePassword(TEMP_PASSWORD_LENGTH);
 353             token = token.toLowerCase();
 354 
 355             ForgotPasswordSecurityToken fpst = new ForgotPasswordSecurityTokenImpl();
 356             fpst.setAdminUserId(user.getId());
 357             fpst.setToken(encodePassword(token));
 358             fpst.setCreateDate(SystemTime.asDate());
 359             forgotPasswordSecurityTokenDao.saveToken(fpst);
 360 
 361             String resetPasswordUrl = getResetPasswordURL();
 362             if (!StringUtils.isEmpty(resetPasswordUrl)) {
 363                 if (resetPasswordUrl.contains(&quot;?&quot;)) {
 364                     resetPasswordUrl=resetPasswordUrl+&quot;&amp;token=&quot;+token;
 365                 } else {
 366                     resetPasswordUrl=resetPasswordUrl+&quot;?token=&quot;+token;
 367                 }
 368             }
 369 
<abbr title=" 370             eventPublisher.publishEvent(new AdminForgotPasswordEvent(this, user.getId(), token, resetPasswordUrl));"> 370             eventPublisher.publishEvent(new AdminForgotPasswordEvent(this, user.getId(), token, resetPassðŸ”µ</abbr>
 371         }
 372         return response;
 373     }
 374 
 375     @Override
 376     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 377     public GenericResponse resetPasswordUsingToken(String username, String token, String password, String confirmPassword) {"> 377     public GenericResponse resetPasswordUsingToken(String username, String token, String password, StringðŸ”µ</abbr>
 378         GenericResponse response = new GenericResponse();
 379         AdminUser user = null;
 380         if (username != null) {
 381             user = adminUserDao.readAdminUserByUserName(username);
 382         }
 383         checkUser(user, response);
 384         checkPassword(password, confirmPassword, response);
 385         if (StringUtils.isBlank(token)) {
 386             response.addErrorCode(&quot;invalidToken&quot;);
 387         }
 388 
 389         ForgotPasswordSecurityToken fpst = null;
 390         if (! response.getHasErrors()) {
 391             token = token.toLowerCase();
<abbr title=" 392             List&lt;ForgotPasswordSecurityToken&gt; fpstoks = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserId(user.getId());"> 392             List&lt;ForgotPasswordSecurityToken&gt; fpstoks = forgotPasswordSecurityTokenDao.readUnusedTokensByðŸ”µ</abbr>
 393             for (ForgotPasswordSecurityToken fpstok : fpstoks) {
 394                 if (isPasswordValid(fpstok.getToken(), token)) {
 395                     fpst = fpstok;
 396                     break;
 397                 }
 398             }
 399             if (fpst == null) {
 400                 response.addErrorCode(&quot;invalidToken&quot;);
 401             } else if (fpst.isTokenUsedFlag()) {
 402                 response.addErrorCode(&quot;tokenUsed&quot;);
 403             } else if (isTokenExpired(fpst)) {
 404                 response.addErrorCode(&quot;tokenExpired&quot;);
 405             }
 406         }
 407 
 408         if (! response.getHasErrors()) {
 409             if (! user.getId().equals(fpst.getAdminUserId())) {
 410                 if (LOG.isWarnEnabled()) {
<abbr title=" 411                     LOG.warn(&quot;Password reset attempt tried with mismatched user and token &quot; + user.getId() + &quot;, &quot; + StringUtil.sanitize(token));"> 411                     LOG.warn(&quot;Password reset attempt tried with mismatched user and token &quot; + user.getId(ðŸ”µ</abbr>
 412                 }
 413                 response.addErrorCode(&quot;invalidToken&quot;);
 414             }
 415         }
 416 
 417         if (! response.getHasErrors()) {
 418             user.setUnencodedPassword(password);
 419             saveAdminUser(user);
 420             invalidateAllTokensForAdminUser(user);
 421         }
 422 
 423         return response;
 424     }
 425 
 426     protected void invalidateAllTokensForAdminUser(AdminUser user) {
<abbr title=" 427         List&lt;ForgotPasswordSecurityToken&gt; tokens = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserId(user.getId());"> 427         List&lt;ForgotPasswordSecurityToken&gt; tokens = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminðŸ”µ</abbr>
 428         for (ForgotPasswordSecurityToken token : tokens) {
 429             token.setTokenUsedFlag(true);
 430             forgotPasswordSecurityTokenDao.saveToken(token);
 431         }
 432     }
 433 
 434     protected void checkUser(AdminUser user, GenericResponse response) {
 435         if (user == null) {
 436             response.addErrorCode(&quot;invalidUser&quot;);
 437         } else if (StringUtils.isBlank(user.getEmail())) {
 438             response.addErrorCode(&quot;emailNotFound&quot;);
 439         } else if (BooleanUtils.isNotTrue(user.getActiveStatusFlag())) {
 440             response.addErrorCode(&quot;inactiveUser&quot;);
 441         }
 442     }
 443 
 444     protected void checkPassword(String password, String confirmPassword, GenericResponse response) {
 445         if (StringUtils.isBlank(password) || StringUtils.isBlank(confirmPassword)) {
 446             response.addErrorCode(&quot;invalidPassword&quot;);
 447         } else if (! password.equals(confirmPassword)) {
 448             response.addErrorCode(&quot;passwordMismatch&quot;);
 449         }
 450     }
 451 
<abbr title=" 452     protected void checkExistingPassword(String unencodedPassword, AdminUser user, GenericResponse response) {"> 452     protected void checkExistingPassword(String unencodedPassword, AdminUser user, GenericResponse responðŸ”µ</abbr>
 453         if (!isPasswordValid(user.getPassword(), unencodedPassword)) {
 454             response.addErrorCode(&quot;invalidPassword&quot;);
 455         }
 456     }
 457 
 458     protected boolean isTokenExpired(ForgotPasswordSecurityToken fpst) {
 459         Date now = SystemTime.asDate();
 460         long currentTimeInMillis = now.getTime();
 461         long tokenSaveTimeInMillis = fpst.getCreateDate().getTime();
 462         long minutesSinceSave = (currentTimeInMillis - tokenSaveTimeInMillis)/60000;
 463         return minutesSinceSave &gt; getTokenExpiredMinutes();
 464     }
 465 
 466     public static int getPASSWORD_TOKEN_LENGTH() {
 467         return TEMP_PASSWORD_LENGTH;
 468     }
 469 
 470     public static void setPASSWORD_TOKEN_LENGTH(int PASSWORD_TOKEN_LENGTH) {
 471         AdminSecurityServiceImpl.TEMP_PASSWORD_LENGTH = PASSWORD_TOKEN_LENGTH;
 472     }
 473 
 474     public EmailInfo getSendUsernameEmailInfo() {
 475         return sendUsernameEmailInfo;
 476     }
 477 
 478     public void setSendUsernameEmailInfo(EmailInfo sendUsernameEmailInfo) {
 479         this.sendUsernameEmailInfo = sendUsernameEmailInfo;
 480     }
 481 
 482     public EmailInfo getResetPasswordEmailInfo() {
 483         return resetPasswordEmailInfo;
 484     }
 485 
 486     public void setResetPasswordEmailInfo(EmailInfo resetPasswordEmailInfo) {
 487         this.resetPasswordEmailInfo = resetPasswordEmailInfo;
 488     }
 489 
 490     @Override
 491     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 492     public GenericResponse changePassword(String username, String oldPassword, String password, String confirmPassword) {"> 492     public GenericResponse changePassword(String username, String oldPassword, String password, String coðŸ”µ</abbr>
 493         GenericResponse response = new GenericResponse();
 494         AdminUser user = null;
 495         if (username != null) {
 496             user = adminUserDao.readAdminUserByUserName(username);
 497         }
 498         checkUser(user, response);
 499         checkPassword(password, confirmPassword, response);
 500 
 501         if (!response.getHasErrors()) {
 502             checkExistingPassword(oldPassword, user, response);
 503         }
 504 
 505         if (!response.getHasErrors()) {
 506             user.setUnencodedPassword(password);
 507             saveAdminUser(user);
 508 
 509         }
 510 
 511         return response;
 512 
 513     }
 514 
 515     /**
<abbr title=" 516      * Determines if a password is valid by comparing it to the encoded string, salting is handled internally to the {@link PasswordEncoder}."> 516      * Determines if a password is valid by comparing it to the encoded string, salting is handled internðŸ”µ</abbr>
 517      * &lt;p&gt;
<abbr title=" 518      * This method must always be called to verify if a password is valid after the original encoded password is generated"> 518      * This method must always be called to verify if a password is valid after the original encoded passðŸ”µ</abbr>
<abbr title=" 519      * due to {@link PasswordEncoder} randomly generating salts internally and appending them to the resulting hash."> 519      * due to {@link PasswordEncoder} randomly generating salts internally and appending them to the resuðŸ”µ</abbr>
 520      *
 521      * @param encodedPassword the encoded password
 522      * @param rawPassword the raw password to check against the encoded password
 523      * @return true if rawPassword matches the encodedPassword, false otherwise
 524      */
 525     protected boolean isPasswordValid(String encodedPassword, String rawPassword) {
 526         return passwordEncoderBean.matches(rawPassword, encodedPassword);
 527     }
 528 
 529     /**
 530      * Generate an encoded password from a raw password
 531      * &lt;p&gt;
<abbr title=" 532      * This method can only be called once per password. The salt is randomly generated internally in the {@link PasswordEncoder}"> 532      * This method can only be called once per password. The salt is randomly generated internally in theðŸ”µ</abbr>
<abbr title=" 533      * and appended to the hash to provide the resulting encoded password. Once this has been called on a password,"> 533      * and appended to the hash to provide the resulting encoded password. Once this has been called on aðŸ”µ</abbr>
<abbr title=" 534      * going forward all checks for authenticity must be done by {@link #isPasswordValid(String, String)} as encoding the"> 534      * going forward all checks for authenticity must be done by {@link #isPasswordValid(String, String)}ðŸ”µ</abbr>
 535      * same password twice will result in different encoded passwords.
 536      *
 537      * @param rawPassword the unencoded password to encode
 538      * @return the encoded password
 539      */
 540     protected String encodePassword(String rawPassword) {
 541         return passwordEncoderBean.encode(rawPassword);
 542     }
 543 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Open Admin Platform
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.openadmin.server.security.service;
  19 
  20 import java.net.URI;
  21 import java.util.ArrayList;
  22 import java.util.Date;
  23 import java.util.List;
  24 import javax.annotation.Resource;
  25 import javax.cache.Cache;
  26 import javax.cache.Caching;
  27 import org.apache.commons.collections4.CollectionUtils;
  28 import org.apache.commons.lang3.BooleanUtils;
  29 import org.apache.commons.lang3.StringUtils;
  30 import org.apache.commons.logging.Log;
  31 import org.apache.commons.logging.LogFactory;
  32 import org.broadleafcommerce.common.email.service.EmailService;
  33 import org.broadleafcommerce.common.email.service.info.EmailInfo;
  34 import org.broadleafcommerce.common.event.BroadleafApplicationEventPublisher;
  35 import org.broadleafcommerce.common.extension.ExtensionResultHolder;
  36 import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  37 import org.broadleafcommerce.common.security.util.PasswordChange;
  38 import org.broadleafcommerce.common.security.util.PasswordUtils;
  39 import org.broadleafcommerce.common.service.GenericResponse;
  40 import org.broadleafcommerce.common.time.SystemTime;
  41 import org.broadleafcommerce.common.util.BLCSystemProperty;
  42 import org.broadleafcommerce.common.util.StringUtil;
  43 import org.broadleafcommerce.openadmin.server.security.dao.AdminPermissionDao;
  44 import org.broadleafcommerce.openadmin.server.security.dao.AdminRoleDao;
  45 import org.broadleafcommerce.openadmin.server.security.dao.AdminUserDao;
  46 import org.broadleafcommerce.openadmin.server.security.dao.ForgotPasswordSecurityTokenDao;
  47 import org.broadleafcommerce.openadmin.server.security.domain.AdminPermission;
  48 import org.broadleafcommerce.openadmin.server.security.domain.AdminRole;
  49 import org.broadleafcommerce.openadmin.server.security.domain.AdminUser;
  50 import org.broadleafcommerce.openadmin.server.security.domain.ForgotPasswordSecurityToken;
  51 import org.broadleafcommerce.openadmin.server.security.domain.ForgotPasswordSecurityTokenImpl;
  52 import org.broadleafcommerce.openadmin.server.security.event.AdminForgotPasswordEvent;
  53 import org.broadleafcommerce.openadmin.server.security.event.AdminForgotUsernameEvent;
  54 import org.broadleafcommerce.openadmin.server.security.extension.AdminSecurityServiceExtensionManager;
  55 import org.broadleafcommerce.openadmin.server.security.service.type.PermissionType;
  56 import org.springframework.context.ApplicationContext;
  57 import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
  58 import org.springframework.security.core.Authentication;
  59 import org.springframework.security.core.context.SecurityContextHolder;
  60 import org.springframework.security.crypto.password.PasswordEncoder;
  61 import org.springframework.stereotype.Service;
  62 import org.springframework.transaction.annotation.Transactional;
  63 
  64 
  65 /**
  66  *
  67  * @author jfischer
  68  *
  69  */
  70 @Service(&quot;blAdminSecurityService&quot;)
  71 public class AdminSecurityServiceImpl implements AdminSecurityService {
  72     private static final Log LOG = LogFactory.getLog(AdminSecurityServiceImpl.class);
  73 
  74     private static int TEMP_PASSWORD_LENGTH = 12;
  75 
  76     private static final int FULL_PASSWORD_LENGTH = 16;
  77 
  78     @Autowired
  79     @Qualifier(&quot;blApplicationEventPublisher&quot;)
  80     protected BroadleafApplicationEventPublisher eventPublisher;
  81 
  82     @Resource(name = &quot;blAdminRoleDao&quot;)
  83     protected AdminRoleDao adminRoleDao;
  84 
  85     @Resource(name = &quot;blAdminUserDao&quot;)
  86     protected AdminUserDao adminUserDao;
  87 
  88     @Resource(name = &quot;blForgotPasswordSecurityTokenDao&quot;)
  89     protected ForgotPasswordSecurityTokenDao forgotPasswordSecurityTokenDao;
  90 
  91     @Resource(name = &quot;blAdminPermissionDao&quot;)
  92     protected AdminPermissionDao adminPermissionDao;
  93 
  94     protected static String CACHE_NAME = &quot;blSecurityElements&quot;;
  95 
  96     protected static String CACHE_KEY_PREFIX = &quot;security:&quot;;
  97 
<abbr title="  98     protected Cache&lt;Object, Object&gt; cache = Caching.getCachingProvider().getCacheManager(URI.create(&quot;ehcache:fakeuri&quot;), getClass().getClassLoader()).getCache(CACHE_NAME);">  98     protected Cache&lt;Object, Object&gt; cache = Caching.getCachingProvider().getCacheManager(URI.create(&quot;ehcaðŸ”µ</abbr>
  99 
 100     /**
<abbr title=" 101      * &lt;p&gt;This is simply a placeholder to be used by {@link #setupPasswordEncoder()} to determine if we&#x27;re using the"> 101      * &lt;p&gt;This is simply a placeholder to be used by {@link #setupPasswordEncoder()} to determine if we&#x27;rðŸ”µ</abbr>
<abbr title=" 102      * new {@link PasswordEncoder} or the deprecated {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder}"> 102      * new {@link PasswordEncoder} or the deprecated {@link org.springframework.security.authentication.eðŸ”µ</abbr>
 103      */
 104     @Resource(name = &quot;blAdminPasswordEncoder&quot;)
 105     protected PasswordEncoder passwordEncoderBean;
 106 
 107     @Resource(name=&quot;blEmailService&quot;)
 108     protected EmailService emailService;
 109 
 110     @Resource(name=&quot;blSendAdminResetPasswordEmail&quot;)
 111     protected EmailInfo resetPasswordEmailInfo;
 112 
 113     @Resource(name=&quot;blSendAdminUsernameEmailInfo&quot;)
 114     protected EmailInfo sendUsernameEmailInfo;
 115 
 116     @Resource(&quot;blAdminSecurityServiceExtensionManager&quot;)
 117     protected AdminSecurityServiceExtensionManager extensionManager;
 118 
 119     protected int getTokenExpiredMinutes() {
 120         return BLCSystemProperty.resolveIntSystemProperty(&quot;tokenExpiredMinutes&quot;);
 121     }
 122 
 123     protected String getResetPasswordURL() {
 124         return BLCSystemProperty.resolveSystemProperty(&quot;resetPasswordURL&quot;);
 125     }
 126 
 127     @Override
 128     @Transactional(&quot;blTransactionManager&quot;)
 129     public void deleteAdminPermission(AdminPermission permission) {
 130         adminPermissionDao.deleteAdminPermission(permission);
 131         clearAdminSecurityCache();
 132     }
 133 
 134     @Override
 135     @Transactional(&quot;blTransactionManager&quot;)
 136     public void deleteAdminRole(AdminRole role) {
 137         adminRoleDao.deleteAdminRole(role);
 138         clearAdminSecurityCache();
 139     }
 140 
 141     @Override
 142     @Transactional(&quot;blTransactionManager&quot;)
 143     public void deleteAdminUser(AdminUser user) {
 144         adminUserDao.deleteAdminUser(user);
 145         clearAdminSecurityCache();
 146     }
 147 
 148     @Override
 149     public AdminPermission readAdminPermissionById(Long id) {
 150         return adminPermissionDao.readAdminPermissionById(id);
 151     }
 152 
 153     @Override
 154     public AdminRole readAdminRoleById(Long id) {
 155         return adminRoleDao.readAdminRoleById(id);
 156     }
 157 
 158     @Override
 159     public AdminUser readAdminUserById(Long id) {
 160         return adminUserDao.readAdminUserById(id);
 161     }
 162 
 163     @Override
 164     @Transactional(&quot;blTransactionManager&quot;)
 165     public AdminPermission saveAdminPermission(AdminPermission permission) {
 166         permission = adminPermissionDao.saveAdminPermission(permission);
 167         clearAdminSecurityCache();
 168         return permission;
 169     }
 170 
 171     @Override
 172     @Transactional(&quot;blTransactionManager&quot;)
 173     public AdminRole saveAdminRole(AdminRole role) {
 174         role = adminRoleDao.saveAdminRole(role);
 175         clearAdminSecurityCache();
 176         return role;
 177     }
 178 
 179     @Override
 180     @Transactional(&quot;blTransactionManager&quot;)
 181     public AdminUser saveAdminUser(AdminUser user) {
 182         boolean encodePasswordNeeded = false;
 183         String unencodedPassword = user.getUnencodedPassword();
 184         if (user.getUnencodedPassword() != null) {
 185             encodePasswordNeeded = true;
 186             user.setPassword(unencodedPassword);
 187         }
 188         // If no password is set, default to a secure password.
 189         if (user.getPassword() == null) {
 190             user.setPassword(generateSecurePassword());
 191         }
 192         AdminUser returnUser = adminUserDao.saveAdminUser(user);
 193         if (encodePasswordNeeded) {
 194             returnUser.setPassword(encodePassword(unencodedPassword));
 195         }
 196         returnUser = adminUserDao.saveAdminUser(returnUser);
 197         clearAdminSecurityCache();
 198         return returnUser;
 199     }
 200 
 201     @Override
 202     public void clearAdminSecurityCache() {
 203         if (LOG.isTraceEnabled()) {
 204             LOG.trace(&quot;Admin Security Cache DELETE&quot;);
 205         }
 206         cache.removeAll();
 207     }
 208 
 209     protected String generateSecurePassword() {
 210         return PasswordUtils.generateSecurePassword(FULL_PASSWORD_LENGTH);
 211     }
 212 
 213     @Override
 214     @Transactional(&quot;blTransactionManager&quot;)
 215     public AdminUser changePassword(PasswordChange passwordChange) {
 216         AdminUser user = readAdminUserByUserName(passwordChange.getUsername());
 217         user.setUnencodedPassword(passwordChange.getNewPassword());
 218         user = saveAdminUser(user);
 219         Authentication auth = SecurityContextHolder.getContext().getAuthentication();
<abbr title=" 220         UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(passwordChange.getUsername(), passwordChange.getNewPassword(), auth.getAuthorities());"> 220         UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(passworðŸ”µ</abbr>
 221         SecurityContextHolder.getContext().setAuthentication(authRequest);
 222         auth.setAuthenticated(false);
 223         return user;
 224     }
 225 
 226     @Override
<abbr title=" 227     public boolean isUserQualifiedForOperationOnCeilingEntity(AdminUser adminUser, PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 227     public boolean isUserQualifiedForOperationOnCeilingEntity(AdminUser adminUser, PermissionType permissðŸ”µ</abbr>
 228         Boolean response = null;
 229         String cacheKey = buildCacheKey(adminUser, permissionType, ceilingEntityFullyQualifiedName);
 230         Object objectValue = cache.get(cacheKey);
 231         if (objectValue != null) {
 232             response = ((Boolean) (objectValue));
 233             if (LOG.isTraceEnabled()) {
 234                 LOG.trace(((&quot;Admin Security Cache GET For: \&quot;&quot; + cacheKey) + &quot;\&quot; = &quot;) + response);
 235             }
 236         }
 237         if (response == null) {
 238             if (extensionManager != null) {
 239                 ExtensionResultHolder&lt;Boolean&gt; result = new ExtensionResultHolder&lt;Boolean&gt;();
<abbr title=" 240                 ExtensionResultStatusType resultStatusType = extensionManager.getProxy().hasPrivilegesForOperation(adminUser, permissionType, result);"> 240                 ExtensionResultStatusType resultStatusType = extensionManager.getProxy().hasPrivilegesForðŸ”µ</abbr>
 241                 if (ExtensionResultStatusType.HANDLED == resultStatusType) {
 242                     response = result.getResult();
 243                 }
 244             }
 245 
 246             if (response == null || !response) {
<abbr title=" 247                 response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntity(adminUser, permissionType, ceilingEntityFullyQualifiedName);"> 247                 response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntity(adminUser, permiðŸ”µ</abbr>
 248 
 249                 if (!response) {
<abbr title=" 250                     response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntityViaDefaultPermissions(ceilingEntityFullyQualifiedName);"> 250                     response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntityViaDefaultPerðŸ”µ</abbr>
 251                 }
 252             }
 253 
 254             cache.put(cacheKey, response);
 255 
 256             if (LOG.isTraceEnabled()) {
 257                 LOG.trace(&quot;Admin Security Cache PUT For: \&quot;&quot; + cacheKey + &quot;\&quot; = &quot; + response);
 258             }
 259         }
 260         return response;
 261     }
 262 
<abbr title=" 263     protected String buildCacheKey(AdminUser adminUser, PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 263     protected String buildCacheKey(AdminUser adminUser, PermissionType permissionType, String ceilingEntiðŸ”µ</abbr>
 264         return CACHE_KEY_PREFIX
 265                + &quot;user:&quot; + adminUser.getId() + &quot;,&quot;
 266                + &quot;permType:&quot; + permissionType.getFriendlyType() + &quot;,&quot;
 267                + &quot;ceiling:&quot; + ceilingEntityFullyQualifiedName;
 268     }
 269 
 270     @Override
<abbr title=" 271     public boolean doesOperationExistForCeilingEntity(PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 271     public boolean doesOperationExistForCeilingEntity(PermissionType permissionType, String ceilingEntityðŸ”µ</abbr>
<abbr title=" 272         return adminPermissionDao.doesOperationExistForCeilingEntity(permissionType, ceilingEntityFullyQualifiedName);"> 272         return adminPermissionDao.doesOperationExistForCeilingEntity(permissionType, ceilingEntityFullyQuðŸ”µ</abbr>
 273     }
 274 
 275     @Override
 276     public AdminUser readAdminUserByUserName(String userName) {
 277         return adminUserDao.readAdminUserByUserName(userName);
 278     }
 279 
 280     @Override
 281     public List&lt;AdminUser&gt; readAdminUsersByEmail(String email) {
 282         return adminUserDao.readAdminUserByEmail(email);
 283     }
 284 
 285     @Override
 286     public List&lt;AdminUser&gt; readAllAdminUsers() {
 287         return adminUserDao.readAllAdminUsers();
 288     }
 289 
 290     @Override
 291     public List&lt;AdminRole&gt; readAllAdminRoles() {
 292         return adminRoleDao.readAllAdminRoles();
 293     }
 294 
 295     @Override
 296     public List&lt;AdminPermission&gt; readAllAdminPermissions() {
 297         return adminPermissionDao.readAllAdminPermissions();
 298     }
 299 
 300     @Override
 301     @Transactional(&quot;blTransactionManager&quot;)
 302     public GenericResponse sendForgotUsernameNotification(String emailAddress) {
 303         GenericResponse response = new GenericResponse();
 304         List&lt;AdminUser&gt; users = null;
 305         if (emailAddress != null) {
 306             users = adminUserDao.readAdminUserByEmail(emailAddress);
 307         }
 308         if (CollectionUtils.isEmpty(users)) {
 309             response.addErrorCode(&quot;notFound&quot;);
 310         } else {
 311             List&lt;String&gt; activeUsernames = new ArrayList&lt;String&gt;();
 312             for (AdminUser user : users) {
 313                 if (user.getActiveStatusFlag()) {
 314                     activeUsernames.add(user.getLogin());
 315                 }
 316             }
 317             if (activeUsernames.size() &gt; 0) {
<abbr title=" 318                 eventPublisher.publishEvent(new AdminForgotUsernameEvent(this, emailAddress, null, activeUsernames));"> 318                 eventPublisher.publishEvent(new AdminForgotUsernameEvent(this, emailAddress, null, activeðŸ”µ</abbr>
 319             } else {
 320                 // send inactive username found email.
 321                 response.addErrorCode(&quot;inactiveUser&quot;);
 322             }
 323         }
 324         return response;
 325     }
 326 
 327     @Override
 328     @Transactional(&quot;blTransactionManager&quot;)
 329     public GenericResponse sendResetPasswordNotification(String username) {
 330         GenericResponse response = new GenericResponse();
 331         AdminUser user = null;
 332         if (username != null) {
 333             user = adminUserDao.readAdminUserByUserName(username);
 334         }
 335         checkUser(user, response);
 336         if (!response.getHasErrors()) {
 337             String token = PasswordUtils.generateSecurePassword(TEMP_PASSWORD_LENGTH);
 338             token = token.toLowerCase();
 339             ForgotPasswordSecurityToken fpst = new ForgotPasswordSecurityTokenImpl();
 340             fpst.setAdminUserId(user.getId());
 341             fpst.setToken(encodePassword(token));
 342             fpst.setCreateDate(SystemTime.asDate());
 343             forgotPasswordSecurityTokenDao.saveToken(fpst);
 344             String resetPasswordUrl = getResetPasswordURL();
 345             if (!StringUtils.isEmpty(resetPasswordUrl)) {
 346                 if (resetPasswordUrl.contains(&quot;?&quot;)) {
 347                     resetPasswordUrl = (resetPasswordUrl + &quot;&amp;token=&quot;) + token;
 348                 } else {
 349                     resetPasswordUrl = (resetPasswordUrl + &quot;?token=&quot;) + token;
 350                 }
 351             }
<abbr title=" 352             eventPublisher.publishEvent(new AdminForgotPasswordEvent(this, user.getId(), token, resetPasswordUrl));"> 352             eventPublisher.publishEvent(new AdminForgotPasswordEvent(this, user.getId(), token, resetPassðŸ”µ</abbr>
 353         }
 354         return response;
 355     }
 356 
 357     @Override
 358     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 359     public GenericResponse resetPasswordUsingToken(String username, String token, String password, String confirmPassword) {"> 359     public GenericResponse resetPasswordUsingToken(String username, String token, String password, StringðŸ”µ</abbr>
 360         GenericResponse response = new GenericResponse();
 361         AdminUser user = null;
 362         if (username != null) {
 363             user = adminUserDao.readAdminUserByUserName(username);
 364         }
 365         checkUser(user, response);
 366         checkPassword(password, confirmPassword, response);
 367         if (StringUtils.isBlank(token)) {
 368             response.addErrorCode(&quot;invalidToken&quot;);
 369         }
 370         ForgotPasswordSecurityToken fpst = null;
 371         if (!response.getHasErrors()) {
 372             token = token.toLowerCase();
<abbr title=" 373             List&lt;ForgotPasswordSecurityToken&gt; fpstoks = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserId(user.getId());"> 373             List&lt;ForgotPasswordSecurityToken&gt; fpstoks = forgotPasswordSecurityTokenDao.readUnusedTokensByðŸ”µ</abbr>
 374             for (ForgotPasswordSecurityToken fpstok : fpstoks) {
 375                 if (isPasswordValid(fpstok.getToken(), token)) {
 376                     fpst = fpstok;
 377                     break;
 378                 }
 379             }
 380             if (fpst == null) {
 381                 response.addErrorCode(&quot;invalidToken&quot;);
 382             } else if (fpst.isTokenUsedFlag()) {
 383                 response.addErrorCode(&quot;tokenUsed&quot;);
 384             } else if (isTokenExpired(fpst)) {
 385                 response.addErrorCode(&quot;tokenExpired&quot;);
 386             }
 387         }
 388         if (!response.getHasErrors()) {
 389             if (!user.getId().equals(fpst.getAdminUserId())) {
 390                 if (LOG.isWarnEnabled()) {
<abbr title=" 391                     LOG.warn(((&quot;Password reset attempt tried with mismatched user and token &quot; + user.getId()) + &quot;, &quot;) + StringUtil.sanitize(token));"> 391                     LOG.warn(((&quot;Password reset attempt tried with mismatched user and token &quot; + user.getIðŸ”µ</abbr>
 392                 }
 393                 response.addErrorCode(&quot;invalidToken&quot;);
 394             }
 395         }
 396         if (!response.getHasErrors()) {
 397             user.setUnencodedPassword(password);
 398             saveAdminUser(user);
 399             invalidateAllTokensForAdminUser(user);
 400         }
 401         return response;
 402     }
 403 
 404     protected void invalidateAllTokensForAdminUser(AdminUser user) {
<abbr title=" 405         List&lt;ForgotPasswordSecurityToken&gt; tokens = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserId(user.getId());"> 405         List&lt;ForgotPasswordSecurityToken&gt; tokens = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminðŸ”µ</abbr>
 406         for (ForgotPasswordSecurityToken token : tokens) {
 407             token.setTokenUsedFlag(true);
 408             forgotPasswordSecurityTokenDao.saveToken(token);
 409         }
 410     }
 411 
 412     protected void checkUser(AdminUser user, GenericResponse response) {
 413         if (user == null) {
 414             response.addErrorCode(&quot;invalidUser&quot;);
 415         } else if (StringUtils.isBlank(user.getEmail())) {
 416             response.addErrorCode(&quot;emailNotFound&quot;);
 417         } else if (BooleanUtils.isNotTrue(user.getActiveStatusFlag())) {
 418             response.addErrorCode(&quot;inactiveUser&quot;);
 419         }
 420     }
 421 
 422     protected void checkPassword(String password, String confirmPassword, GenericResponse response) {
 423         if (StringUtils.isBlank(password) || StringUtils.isBlank(confirmPassword)) {
 424             response.addErrorCode(&quot;invalidPassword&quot;);
 425         } else if (! password.equals(confirmPassword)) {
 426             response.addErrorCode(&quot;passwordMismatch&quot;);
 427         }
 428     }
 429 
<abbr title=" 430     protected void checkExistingPassword(String unencodedPassword, AdminUser user, GenericResponse response) {"> 430     protected void checkExistingPassword(String unencodedPassword, AdminUser user, GenericResponse responðŸ”µ</abbr>
 431         if (!isPasswordValid(user.getPassword(), unencodedPassword)) {
 432             response.addErrorCode(&quot;invalidPassword&quot;);
 433         }
 434     }
 435 
 436     protected boolean isTokenExpired(ForgotPasswordSecurityToken fpst) {
 437         Date now = SystemTime.asDate();
 438         long currentTimeInMillis = now.getTime();
 439         long tokenSaveTimeInMillis = fpst.getCreateDate().getTime();
 440         long minutesSinceSave = (currentTimeInMillis - tokenSaveTimeInMillis)/60000;
 441         return minutesSinceSave &gt; getTokenExpiredMinutes();
 442     }
 443 
 444     public static int getPASSWORD_TOKEN_LENGTH() {
 445         return TEMP_PASSWORD_LENGTH;
 446     }
 447 
 448     public static void setPASSWORD_TOKEN_LENGTH(int PASSWORD_TOKEN_LENGTH) {
 449         AdminSecurityServiceImpl.TEMP_PASSWORD_LENGTH = PASSWORD_TOKEN_LENGTH;
 450     }
 451 
 452     public EmailInfo getSendUsernameEmailInfo() {
 453         return sendUsernameEmailInfo;
 454     }
 455 
 456     public void setSendUsernameEmailInfo(EmailInfo sendUsernameEmailInfo) {
 457         this.sendUsernameEmailInfo = sendUsernameEmailInfo;
 458     }
 459 
 460     public EmailInfo getResetPasswordEmailInfo() {
 461         return resetPasswordEmailInfo;
 462     }
 463 
 464     public void setResetPasswordEmailInfo(EmailInfo resetPasswordEmailInfo) {
 465         this.resetPasswordEmailInfo = resetPasswordEmailInfo;
 466     }
 467 
 468     @Override
 469     @Transactional(&quot;blTransactionManager&quot;)
 470     public GenericResponse changePassword(String username,
 471             String oldPassword, String password, String confirmPassword) {
 472         GenericResponse response = new GenericResponse();
 473         AdminUser user = null;
 474         if (username != null) {
 475             user = adminUserDao.readAdminUserByUserName(username);
 476         }
 477         checkUser(user, response);
 478         checkPassword(password, confirmPassword, response);
 479 
 480         if (!response.getHasErrors()) {
 481             checkExistingPassword(oldPassword, user, response);
 482         }
 483 
 484         if (!response.getHasErrors()) {
 485             user.setUnencodedPassword(password);
 486             saveAdminUser(user);
 487 
 488         }
 489 
 490         return response;
 491 
 492     }
 493 
 494     /**
<abbr title=" 495      * Determines if a password is valid by comparing it to the encoded string, salting is handled internally to the {@link PasswordEncoder}."> 495      * Determines if a password is valid by comparing it to the encoded string, salting is handled internðŸ”µ</abbr>
 496      * &lt;p&gt;
<abbr title=" 497      * This method must always be called to verify if a password is valid after the original encoded password is generated"> 497      * This method must always be called to verify if a password is valid after the original encoded passðŸ”µ</abbr>
<abbr title=" 498      * due to {@link PasswordEncoder} randomly generating salts internally and appending them to the resulting hash."> 498      * due to {@link PasswordEncoder} randomly generating salts internally and appending them to the resuðŸ”µ</abbr>
 499      *
 500      * @param encodedPassword the encoded password
 501      * @param rawPassword the raw password to check against the encoded password
 502      * @return true if rawPassword matches the encodedPassword, false otherwise
 503      */
 504     protected boolean isPasswordValid(String encodedPassword, String rawPassword) {
 505         return passwordEncoderBean.matches(rawPassword, encodedPassword);
 506     }
 507 
 508     /**
 509      * Generate an encoded password from a raw password
 510      * &lt;p&gt;
<abbr title=" 511      * This method can only be called once per password. The salt is randomly generated internally in the {@link PasswordEncoder}"> 511      * This method can only be called once per password. The salt is randomly generated internally in theðŸ”µ</abbr>
<abbr title=" 512      * and appended to the hash to provide the resulting encoded password. Once this has been called on a password,"> 512      * and appended to the hash to provide the resulting encoded password. Once this has been called on aðŸ”µ</abbr>
<abbr title=" 513      * going forward all checks for authenticity must be done by {@link #isPasswordValid(String, String)} as encoding the"> 513      * going forward all checks for authenticity must be done by {@link #isPasswordValid(String, String)}ðŸ”µ</abbr>
 514      * same password twice will result in different encoded passwords.
 515      *
 516      * @param rawPassword
 517      * 		the unencoded password to encode
 518      * @return the encoded password
 519      */
 520     protected String encodePassword(String rawPassword) {
 521         return passwordEncoderBean.encode(rawPassword);
 522     }
 523 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * #%L
   3   * BroadleafCommerce Open Admin Platform
   4   * %%
   5   * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6   * %%
   7   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10   * the Broadleaf End User License Agreement (EULA), Version 1.1
  11   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12   * shall apply.
  13   *
<abbr title="  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  15   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  16   * #L%
  17   */
  18  package org.broadleafcommerce.openadmin.server.security.service;
  19  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  20 -import net.sf.ehcache.Cache;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  21 -import net.sf.ehcache.CacheManager;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  22 -import net.sf.ehcache.Element;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  23 -</span>
  24  import org.apache.commons.collections4.CollectionUtils;
  25  import org.apache.commons.lang3.BooleanUtils;
  26  import org.apache.commons.lang3.StringUtils;
  27  import org.apache.commons.logging.Log;
  28  import org.apache.commons.logging.LogFactory;
  29  import org.broadleafcommerce.common.email.service.EmailService;
  30  import org.broadleafcommerce.common.email.service.info.EmailInfo;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  31 +import org.broadleafcommerce.common.event.BroadleafApplicationEventPublisher;</span>

  32  import org.broadleafcommerce.common.security.util.PasswordChange;
  33  import org.broadleafcommerce.common.security.util.PasswordUtils;
  34  import org.broadleafcommerce.common.service.GenericResponse;
  35  import org.broadleafcommerce.common.time.SystemTime;
  36  import org.broadleafcommerce.common.util.BLCSystemProperty;
  37  import org.broadleafcommerce.common.util.StringUtil;
  38  import org.broadleafcommerce.openadmin.server.security.dao.AdminPermissionDao;
  39  import org.broadleafcommerce.openadmin.server.security.dao.AdminRoleDao;
  40  import org.broadleafcommerce.openadmin.server.security.dao.AdminUserDao;
  41  import org.broadleafcommerce.openadmin.server.security.dao.ForgotPasswordSecurityTokenDao;
  42  import org.broadleafcommerce.openadmin.server.security.domain.AdminPermission;
  43  import org.broadleafcommerce.openadmin.server.security.domain.AdminRole;
  44  import org.broadleafcommerce.openadmin.server.security.domain.AdminUser;
  45  import org.broadleafcommerce.openadmin.server.security.domain.ForgotPasswordSecurityToken;
  46  import org.broadleafcommerce.openadmin.server.security.domain.ForgotPasswordSecurityTokenImpl;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  47 +import org.broadleafcommerce.openadmin.server.security.event.AdminForgotPasswordEvent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  48 +import org.broadleafcommerce.openadmin.server.security.event.AdminForgotUsernameEvent;</span>
  49  import org.broadleafcommerce.openadmin.server.security.service.type.PermissionType;
  50  import org.broadleafcommerce.openadmin.server.security.service.user.AdminUserDetails;
  51  import org.springframework.beans.factory.NoSuchBeanDefinitionException;
  52  import org.springframework.beans.factory.annotation.Autowired;
  53  import org.springframework.beans.factory.annotation.Qualifier;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  54 +import org.springframework.context.ApplicationContext;</span>
  55  import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  56 -import org.springframework.security.authentication.dao.SaltSource;</span>
  57  import org.springframework.security.core.Authentication;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  58 -import org.springframework.security.core.GrantedAuthority;</span>
  59  import org.springframework.security.core.context.SecurityContextHolder;
  60  import org.springframework.security.crypto.password.PasswordEncoder;
  61  import org.springframework.stereotype.Service;
  62  import org.springframework.transaction.annotation.Transactional;
  63  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  64 +import java.net.URI;</span>
  65  import java.util.ArrayList;
  66  import java.util.Date;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  67 -import java.util.HashMap;</span>
  68  import java.util.List;
  69  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  70 -import javax.annotation.PostConstruct;</span>
  71  import javax.annotation.Resource;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  72 +import javax.cache.Cache;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  73 +import javax.cache.Caching;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  74 +</span>

  75  
  76  /**
  77   *
  78   * @author jfischer
  79   *
  80   */
  81  @Service(&quot;blAdminSecurityService&quot;)
  82  public class AdminSecurityServiceImpl implements AdminSecurityService {
  83  
  84      private static final Log LOG = LogFactory.getLog(AdminSecurityServiceImpl.class);
  85  
  86      private static int TEMP_PASSWORD_LENGTH = 12;
  87      private static final int FULL_PASSWORD_LENGTH = 16;
  88  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  89 +    @Autowired</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  90 +    @Qualifier(&quot;blApplicationEventPublisher&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  91 +    protected BroadleafApplicationEventPublisher eventPublisher;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  92 +</span>
  93      @Resource(name = &quot;blAdminRoleDao&quot;)
  94      protected AdminRoleDao adminRoleDao;
  95  
  96      @Resource(name = &quot;blAdminUserDao&quot;)
  97      protected AdminUserDao adminUserDao;
  98  
  99      @Resource(name = &quot;blForgotPasswordSecurityTokenDao&quot;)
 100      protected ForgotPasswordSecurityTokenDao forgotPasswordSecurityTokenDao;
 101  
 102      @Resource(name = &quot;blAdminPermissionDao&quot;)
 103      protected AdminPermissionDao adminPermissionDao;
 104  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 105 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 106 -     * &lt;p&gt;Set by {@link #setupPasswordEncoder()} if the blPasswordEncoder bean provided is the deprecated version.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 107 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 108 -     * @deprecated Spring Security has deprecated this encoder interface, this will be removed in 4.2</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 109 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 110 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 111 -    protected org.springframework.security.authentication.encoding.PasswordEncoder passwordEncoder;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 112 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 113 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 114 -     * &lt;p&gt;Set by {@link #setupPasswordEncoder()} if the blPasswordEncoder bean provided is the new version.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 115 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 116 -    protected PasswordEncoder passwordEncoderNew;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 117 -</span>
 118      protected static String CACHE_NAME = &quot;blSecurityElements&quot;;
 119      protected static String CACHE_KEY_PREFIX = &quot;security:&quot;;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 120 -    protected Cache cache = CacheManager.getInstance().getCache(CACHE_NAME);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 121 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 122 +    protected Cache&lt;Object, Object&gt; cache = Caching.getCachingProvider().getCacheManager(URI.create(&quot;ehcache:fakeuri&quot;), getClass().getClassLoader()).getCache(CACHE_NAME);"> 122 +    protected Cache&lt;Object, Object&gt; cache = Caching.getCachingProvider().getCacheManager(URI.create(&quot;ehcache:fakeuðŸ”µ</abbr></span>
 123  
 124      /**
<abbr title=" 125       * &lt;p&gt;This is simply a placeholder to be used by {@link #setupPasswordEncoder()} to determine if we&#x27;re using the"> 125       * &lt;p&gt;This is simply a placeholder to be used by {@link #setupPasswordEncoder()} to determine if we&#x27;re using tðŸ”µ</abbr>
<abbr title=" 126       * new {@link PasswordEncoder} or the deprecated {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder}"> 126       * new {@link PasswordEncoder} or the deprecated {@link org.springframework.security.authentication.encoding.PðŸ”µ</abbr>
 127       */
 128      @Resource(name=&quot;blAdminPasswordEncoder&quot;)
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 129 -    protected Object passwordEncoderBean;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 130 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 131 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 132 -     * Optional password salt to be used with the passwordEncoder</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 133 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 134 -     * @deprecated use {@link #saltSource} instead, this will be removed in 4.2</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 135 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 136 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 137 -    protected String salt;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 138 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 139 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 140 -     * Use a Salt Source ONLY if there&#x27;s one configured</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 141 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 142 -     * @deprecated the new {@link PasswordEncoder} handles salting internally, this will be removed in 4.2</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 143 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 144 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 145 -    @Autowired(required=false)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 146 -    @Qualifier(&quot;blAdminSaltSource&quot;)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 147 -    protected SaltSource saltSource;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 148 +    protected PasswordEncoder passwordEncoderBean;</span>
 149  
 150      @Resource(name=&quot;blEmailService&quot;)
 151      protected EmailService emailService;
 152  
 153      @Resource(name=&quot;blSendAdminResetPasswordEmail&quot;)
 154      protected EmailInfo resetPasswordEmailInfo;
 155  
 156      @Resource(name=&quot;blSendAdminUsernameEmailInfo&quot;)
 157      protected EmailInfo sendUsernameEmailInfo;
 158  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 159 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 160 -     * &lt;p&gt;Sets either {@link #passwordEncoder} or {@link #passwordEncoderNew} based on the type of {@link #passwordEncoderBean}"> 160 -     * &lt;p&gt;Sets either {@link #passwordEncoder} or {@link #passwordEncoderNew} based on the type of {@link #passworðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 161 -     * in order to provide bean configuration backwards compatibility with the deprecated {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder} bean."> 161 -     * in order to provide bean configuration backwards compatibility with the deprecated {@link org.springframewoðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 162 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 163 -     * &lt;p&gt;{@link #passwordEncoderBean} is set by the bean defined as &quot;blPasswordEncoder&quot;.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 164 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 165 -     * &lt;p&gt;This class will utilize either the new or deprecated PasswordEncoder type depending on which is not null."> 165 -     * &lt;p&gt;This class will utilize either the new or deprecated PasswordEncoder type depending on which is not nullðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 166 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 167 -     * @throws NoSuchBeanDefinitionException if {@link #passwordEncoderBean} is null or not an instance of either PasswordEncoder"> 167 -     * @throws NoSuchBeanDefinitionException if {@link #passwordEncoderBean} is null or not an instance of either ðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 168 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 169 -    @PostConstruct</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 170 -    protected void setupPasswordEncoder() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 171 -        passwordEncoderNew = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 172 -        passwordEncoder = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 173 -        if (passwordEncoderBean instanceof PasswordEncoder) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 174 -            passwordEncoderNew = (PasswordEncoder) passwordEncoderBean;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 175 -        } else if (passwordEncoderBean instanceof org.springframework.security.authentication.encoding.PasswordEncoder) {"> 175 -        } else if (passwordEncoderBean instanceof org.springframework.security.authentication.encoding.PasswordEncðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 176 -            passwordEncoder = (org.springframework.security.authentication.encoding.PasswordEncoder) passwordEncoderBean;"> 176 -            passwordEncoder = (org.springframework.security.authentication.encoding.PasswordEncoder) passwordEncodðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 177 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 178 -            throw new NoSuchBeanDefinitionException(&quot;No PasswordEncoder bean is defined&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 179 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 180 -    }</span>


<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 181 -</span>
 182      protected int getTokenExpiredMinutes() {
 183          return BLCSystemProperty.resolveIntSystemProperty(&quot;tokenExpiredMinutes&quot;);
 184      }
 185  
 186      protected String getResetPasswordURL() {
 187          return BLCSystemProperty.resolveSystemProperty(&quot;resetPasswordURL&quot;);
 188      }
 189  
 190      @Override
 191      @Transactional(&quot;blTransactionManager&quot;)
 192      public void deleteAdminPermission(AdminPermission permission) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 193 +</span>
 194          adminPermissionDao.deleteAdminPermission(permission);
 195          clearAdminSecurityCache();
 196      }
 197  
 198      @Override
 199      @Transactional(&quot;blTransactionManager&quot;)
 200      public void deleteAdminRole(AdminRole role) {
 201          adminRoleDao.deleteAdminRole(role);
 202          clearAdminSecurityCache();
 203      }
 204  
 205      @Override
 206      @Transactional(&quot;blTransactionManager&quot;)
 207      public void deleteAdminUser(AdminUser user) {
 208          adminUserDao.deleteAdminUser(user);
 209          clearAdminSecurityCache();
 210      }
 211  
 212      @Override
 213      public AdminPermission readAdminPermissionById(Long id) {
 214          return adminPermissionDao.readAdminPermissionById(id);
 215      }
 216  
 217      @Override
 218      public AdminRole readAdminRoleById(Long id) {
 219          return adminRoleDao.readAdminRoleById(id);
 220      }
 221  
 222      @Override
 223      public AdminUser readAdminUserById(Long id) {
 224          return adminUserDao.readAdminUserById(id);
 225      }
 226  
 227      @Override
 228      @Transactional(&quot;blTransactionManager&quot;)
 229      public AdminPermission saveAdminPermission(AdminPermission permission) {
 230          permission = adminPermissionDao.saveAdminPermission(permission);
 231          clearAdminSecurityCache();
 232          return permission;
 233      }
 234  
 235      @Override
 236      @Transactional(&quot;blTransactionManager&quot;)
 237      public AdminRole saveAdminRole(AdminRole role) {
 238          role = adminRoleDao.saveAdminRole(role);
 239          clearAdminSecurityCache();
 240          return role;
 241      }
 242  
 243      @Override
 244      @Transactional(&quot;blTransactionManager&quot;)
 245      public AdminUser saveAdminUser(AdminUser user) {
 246          boolean encodePasswordNeeded = false;
 247          String unencodedPassword = user.getUnencodedPassword();
 248  
 249          if (user.getUnencodedPassword() != null) {
 250              encodePasswordNeeded = true;
 251              user.setPassword(unencodedPassword);
 252          }
 253  
 254          // If no password is set, default to a secure password.
 255          if (user.getPassword() == null) {
 256              user.setPassword(generateSecurePassword());
 257          }
 258  
 259          AdminUser returnUser = adminUserDao.saveAdminUser(user);
 260  
 261          if (encodePasswordNeeded) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 262 -            returnUser.setPassword(encodePassword(unencodedPassword, getSalt(returnUser, unencodedPassword)));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 263 +            returnUser.setPassword(encodePassword(unencodedPassword));</span>
 264          }
 265  
 266          returnUser = adminUserDao.saveAdminUser(returnUser);
 267          clearAdminSecurityCache();
 268          return returnUser;
 269      }
 270  
 271      @Override
 272      public void clearAdminSecurityCache() {
 273          if (LOG.isTraceEnabled()) {
 274              LOG.trace(&quot;Admin Security Cache DELETE&quot;);
 275          }
 276          cache.removeAll();
 277      }
 278  
 279      protected String generateSecurePassword() {
 280          return PasswordUtils.generateSecurePassword(FULL_PASSWORD_LENGTH);
 281      }
 282  
 283      @Override
 284      @Transactional(&quot;blTransactionManager&quot;)
 285      public AdminUser changePassword(PasswordChange passwordChange) {
 286          AdminUser user = readAdminUserByUserName(passwordChange.getUsername());
 287          user.setUnencodedPassword(passwordChange.getNewPassword());
 288          user = saveAdminUser(user);
 289          Authentication auth = SecurityContextHolder.getContext().getAuthentication();
<abbr title=" 290          UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(passwordChange.getUsername(), passwordChange.getNewPassword(), auth.getAuthorities());"> 290          UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(passwordChange.gðŸ”µ</abbr>
 291          SecurityContextHolder.getContext().setAuthentication(authRequest);
 292          auth.setAuthenticated(false);
 293          return user;
 294      }
 295  
 296      @Override
<abbr title=" 297      public boolean isUserQualifiedForOperationOnCeilingEntity(AdminUser adminUser, PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 297      public boolean isUserQualifiedForOperationOnCeilingEntity(AdminUser adminUser, PermissionType permissionType, ðŸ”µ</abbr>
 298          Boolean response = null;
 299          String cacheKey = buildCacheKey(adminUser, permissionType, ceilingEntityFullyQualifiedName);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 300 -        Element cacheElement = cache.get(cacheKey);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 301 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 302 -        if (cacheElement != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 303 -            response = (Boolean) cacheElement.getObjectValue();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 304 +        Object objectValue = cache.get(cacheKey);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 305 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 306 +        if (objectValue != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 307 +            response = (Boolean) objectValue;</span>
 308  
 309              if (LOG.isTraceEnabled()) {
 310                  LOG.trace(&quot;Admin Security Cache GET For: \&quot;&quot; + cacheKey + &quot;\&quot; = &quot; + response);
 311              }
 312          }
 313  
 314          if (response == null) {
<abbr title=" 315              response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntity(adminUser, permissionType, ceilingEntityFullyQualifiedName);"> 315              response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntity(adminUser, permissionType, ceðŸ”µ</abbr>
 316  
 317              if (!response) {
<abbr title=" 318                  response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntityViaDefaultPermissions(ceilingEntityFullyQualifiedName);"> 318                  response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntityViaDefaultPermissions(ceilðŸ”µ</abbr>














 319              }
 320  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 321 -            cacheElement = new Element(cacheKey, response);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 322 -            cache.put(cacheElement);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 323 +            cache.put(cacheKey, response);</span>
 324  
 325              if (LOG.isTraceEnabled()) {
 326                  LOG.trace(&quot;Admin Security Cache PUT For: \&quot;&quot; + cacheKey + &quot;\&quot; = &quot; + response);
 327              }
 328          }
 329  
 330          return response;
 331      }
 332  
<abbr title=" 333      protected String buildCacheKey(AdminUser adminUser, PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 333      protected String buildCacheKey(AdminUser adminUser, PermissionType permissionType, String ceilingEntityFullyQuðŸ”µ</abbr>
 334          return CACHE_KEY_PREFIX
 335                 + &quot;user:&quot; + adminUser.getId() + &quot;,&quot;
 336                 + &quot;permType:&quot; + permissionType.getFriendlyType() + &quot;,&quot;
 337                 + &quot;ceiling:&quot; + ceilingEntityFullyQualifiedName;
 338      }
 339  
 340      @Override
<abbr title=" 341      public boolean doesOperationExistForCeilingEntity(PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 341      public boolean doesOperationExistForCeilingEntity(PermissionType permissionType, String ceilingEntityFullyQualðŸ”µ</abbr>
<abbr title=" 342          return adminPermissionDao.doesOperationExistForCeilingEntity(permissionType, ceilingEntityFullyQualifiedName);"> 342          return adminPermissionDao.doesOperationExistForCeilingEntity(permissionType, ceilingEntityFullyQualifiedNaðŸ”µ</abbr>
 343      }
 344  
 345      @Override
 346      public AdminUser readAdminUserByUserName(String userName) {
 347          return adminUserDao.readAdminUserByUserName(userName);
 348      }
 349  
 350      @Override
 351      public List&lt;AdminUser&gt; readAdminUsersByEmail(String email) {
 352          return adminUserDao.readAdminUserByEmail(email);
 353      }
 354  
 355      @Override
 356      public List&lt;AdminUser&gt; readAllAdminUsers() {
 357          return adminUserDao.readAllAdminUsers();
 358      }
 359  
 360      @Override
 361      public List&lt;AdminRole&gt; readAllAdminRoles() {
 362          return adminRoleDao.readAllAdminRoles();
 363      }
 364  
 365      @Override
 366      public List&lt;AdminPermission&gt; readAllAdminPermissions() {
 367          return adminPermissionDao.readAllAdminPermissions();
 368      }
 369  
 370      @Override
 371      @Transactional(&quot;blTransactionManager&quot;)
 372      public GenericResponse sendForgotUsernameNotification(String emailAddress) {
 373          GenericResponse response = new GenericResponse();
 374          List&lt;AdminUser&gt; users = null;
 375          if (emailAddress != null) {
 376              users = adminUserDao.readAdminUserByEmail(emailAddress);
 377          }
 378          if (CollectionUtils.isEmpty(users)) {
 379              response.addErrorCode(&quot;notFound&quot;);
 380          } else {
 381              List&lt;String&gt; activeUsernames = new ArrayList&lt;String&gt;();
 382              for (AdminUser user : users) {
 383                  if (user.getActiveStatusFlag()) {
 384                      activeUsernames.add(user.getLogin());
 385                  }
 386              }
 387  
 388              if (activeUsernames.size() &gt; 0) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 389 -                HashMap&lt;String, Object&gt; vars = new HashMap&lt;String, Object&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 390 -                vars.put(&quot;accountNames&quot;, activeUsernames);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 391 -                emailService.sendTemplateEmail(emailAddress, getSendUsernameEmailInfo(), vars);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 392 +                eventPublisher.publishEvent(new AdminForgotUsernameEvent(this, emailAddress, null, activeUsernames));"> 392 +                eventPublisher.publishEvent(new AdminForgotUsernameEvent(this, emailAddress, null, activeUsernamesðŸ”µ</abbr></span>
 393              } else {
 394                  // send inactive username found email.
 395                  response.addErrorCode(&quot;inactiveUser&quot;);
 396              }
 397          }
 398          return response;
 399      }
 400  
 401      @Override
 402      @Transactional(&quot;blTransactionManager&quot;)
 403      public GenericResponse sendResetPasswordNotification(String username) {
 404          GenericResponse response = new GenericResponse();
 405          AdminUser user = null;
 406  
 407          if (username != null) {
 408              user = adminUserDao.readAdminUserByUserName(username);
 409          }
 410  
 411          checkUser(user,response);
 412  
 413          if (! response.getHasErrors()) {
 414              String token = PasswordUtils.generateSecurePassword(TEMP_PASSWORD_LENGTH);
 415              token = token.toLowerCase();
 416  
 417              ForgotPasswordSecurityToken fpst = new ForgotPasswordSecurityTokenImpl();
 418              fpst.setAdminUserId(user.getId());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 419 -            fpst.setToken(encodePassword(token, null));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 420 +            fpst.setToken(encodePassword(token));</span>
 421              fpst.setCreateDate(SystemTime.asDate());
 422              forgotPasswordSecurityTokenDao.saveToken(fpst);
 423  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 424 -            HashMap&lt;String, Object&gt; vars = new HashMap&lt;String, Object&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 425 -            vars.put(&quot;token&quot;, token);</span>
 426              String resetPasswordUrl = getResetPasswordURL();
 427              if (!StringUtils.isEmpty(resetPasswordUrl)) {
 428                  if (resetPasswordUrl.contains(&quot;?&quot;)) {
 429                      resetPasswordUrl=resetPasswordUrl+&quot;&amp;token=&quot;+token;
 430                  } else {
 431                      resetPasswordUrl=resetPasswordUrl+&quot;?token=&quot;+token;
 432                  }
 433              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 434 -            vars.put(&quot;resetPasswordUrl&quot;, resetPasswordUrl);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 435 -            emailService.sendTemplateEmail(user.getEmail(), getResetPasswordEmailInfo(), vars);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 436 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 437 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 438 +            eventPublisher.publishEvent(new AdminForgotPasswordEvent(this, user.getId(), token, resetPasswordUrl));"> 438 +            eventPublisher.publishEvent(new AdminForgotPasswordEvent(this, user.getId(), token, resetPasswordUrl))ðŸ”µ</abbr></span>
 439          }
 440          return response;
 441      }
 442  
 443      @Override
 444      @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 445      public GenericResponse resetPasswordUsingToken(String username, String token, String password, String confirmPassword) {"> 445      public GenericResponse resetPasswordUsingToken(String username, String token, String password, String confirmPðŸ”µ</abbr>
 446          GenericResponse response = new GenericResponse();
 447          AdminUser user = null;
 448          if (username != null) {
 449              user = adminUserDao.readAdminUserByUserName(username);
 450          }
 451          checkUser(user, response);
 452          checkPassword(password, confirmPassword, response);
 453          if (StringUtils.isBlank(token)) {
 454              response.addErrorCode(&quot;invalidToken&quot;);
 455          }
 456  
 457          ForgotPasswordSecurityToken fpst = null;
 458          if (! response.getHasErrors()) {
 459              token = token.toLowerCase();
<abbr title=" 460              List&lt;ForgotPasswordSecurityToken&gt; fpstoks = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserId(user.getId());"> 460              List&lt;ForgotPasswordSecurityToken&gt; fpstoks = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserðŸ”µ</abbr>
 461              for (ForgotPasswordSecurityToken fpstok : fpstoks) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 462 -                if (isPasswordValid(fpstok.getToken(), token, null)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 463 +                if (isPasswordValid(fpstok.getToken(), token)) {</span>
 464                      fpst = fpstok;
 465                      break;
 466                  }
 467              }
 468              if (fpst == null) {
 469                  response.addErrorCode(&quot;invalidToken&quot;);
 470              } else if (fpst.isTokenUsedFlag()) {
 471                  response.addErrorCode(&quot;tokenUsed&quot;);
 472              } else if (isTokenExpired(fpst)) {
 473                  response.addErrorCode(&quot;tokenExpired&quot;);
 474              }
 475          }
 476  
 477          if (! response.getHasErrors()) {
 478              if (! user.getId().equals(fpst.getAdminUserId())) {
 479                  if (LOG.isWarnEnabled()) {
<abbr title=" 480                      LOG.warn(&quot;Password reset attempt tried with mismatched user and token &quot; + user.getId() + &quot;, &quot; + StringUtil.sanitize(token));"> 480                      LOG.warn(&quot;Password reset attempt tried with mismatched user and token &quot; + user.getId() + &quot;, &quot; ðŸ”µ</abbr>
 481                  }
 482                  response.addErrorCode(&quot;invalidToken&quot;);
 483              }
 484          }
 485  
 486          if (! response.getHasErrors()) {
 487              user.setUnencodedPassword(password);
 488              saveAdminUser(user);
 489              invalidateAllTokensForAdminUser(user);
 490          }
 491  
 492          return response;
 493      }
 494  
 495      protected void invalidateAllTokensForAdminUser(AdminUser user) {
<abbr title=" 496          List&lt;ForgotPasswordSecurityToken&gt; tokens = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserId(user.getId());"> 496          List&lt;ForgotPasswordSecurityToken&gt; tokens = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserId(usðŸ”µ</abbr>
 497          for (ForgotPasswordSecurityToken token : tokens) {
 498              token.setTokenUsedFlag(true);
 499              forgotPasswordSecurityTokenDao.saveToken(token);
 500          }
 501      }
 502  
 503      protected void checkUser(AdminUser user, GenericResponse response) {
 504          if (user == null) {
 505              response.addErrorCode(&quot;invalidUser&quot;);
 506          } else if (StringUtils.isBlank(user.getEmail())) {
 507              response.addErrorCode(&quot;emailNotFound&quot;);
 508          } else if (BooleanUtils.isNotTrue(user.getActiveStatusFlag())) {
 509              response.addErrorCode(&quot;inactiveUser&quot;);
 510          }
 511      }
 512  
 513      protected void checkPassword(String password, String confirmPassword, GenericResponse response) {
 514          if (StringUtils.isBlank(password) || StringUtils.isBlank(confirmPassword)) {
 515              response.addErrorCode(&quot;invalidPassword&quot;);
 516          } else if (! password.equals(confirmPassword)) {
 517              response.addErrorCode(&quot;passwordMismatch&quot;);
 518          }
 519      }
 520  
 521      protected void checkExistingPassword(String unencodedPassword, AdminUser user, GenericResponse response) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 522 -        if (!isPasswordValid(user.getPassword(), unencodedPassword, getSalt(user, unencodedPassword))) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 523 +        if (!isPasswordValid(user.getPassword(), unencodedPassword)) {</span>
 524              response.addErrorCode(&quot;invalidPassword&quot;);
 525          }
 526      }
 527  
 528      protected boolean isTokenExpired(ForgotPasswordSecurityToken fpst) {
 529          Date now = SystemTime.asDate();
 530          long currentTimeInMillis = now.getTime();
 531          long tokenSaveTimeInMillis = fpst.getCreateDate().getTime();
 532          long minutesSinceSave = (currentTimeInMillis - tokenSaveTimeInMillis)/60000;
 533          return minutesSinceSave &gt; getTokenExpiredMinutes();
 534      }
 535  
 536      public static int getPASSWORD_TOKEN_LENGTH() {
 537          return TEMP_PASSWORD_LENGTH;
 538      }
 539  
 540      public static void setPASSWORD_TOKEN_LENGTH(int PASSWORD_TOKEN_LENGTH) {
 541          AdminSecurityServiceImpl.TEMP_PASSWORD_LENGTH = PASSWORD_TOKEN_LENGTH;
 542      }
 543  
 544      public EmailInfo getSendUsernameEmailInfo() {
 545          return sendUsernameEmailInfo;
 546      }
 547  
 548      public void setSendUsernameEmailInfo(EmailInfo sendUsernameEmailInfo) {
 549          this.sendUsernameEmailInfo = sendUsernameEmailInfo;
 550      }
 551  
 552      public EmailInfo getResetPasswordEmailInfo() {
 553          return resetPasswordEmailInfo;
 554      }
 555  
 556      public void setResetPasswordEmailInfo(EmailInfo resetPasswordEmailInfo) {
 557          this.resetPasswordEmailInfo = resetPasswordEmailInfo;
 558      }
 559  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 560 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 561 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 562 -    public Object getSalt(AdminUser user, String unencodedPassword) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 563 -        Object salt = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 564 -        if (saltSource != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 565 -            salt = saltSource.getSalt(new AdminUserDetails(user.getId(), user.getLogin(), unencodedPassword, new ArrayList&lt;GrantedAuthority&gt;()));"> 565 -            salt = saltSource.getSalt(new AdminUserDetails(user.getId(), user.getLogin(), unencodedPassword, new AðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 566 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 567 -        return salt;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 568 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 569 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 570 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 571 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 572 -    public String getSalt() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 573 -        return salt;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 574 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 575 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 576 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 577 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 578 -    public void setSalt(String salt) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 579 -        this.salt = salt;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 580 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 581 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 582 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 583 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 584 -    public SaltSource getSaltSource() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 585 -        return saltSource;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 586 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 587 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 588 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 589 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 590 -    public void setSaltSource(SaltSource saltSource) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 591 -        this.saltSource = saltSource;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 592 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 593 -</span>
 594      @Override
 595      @Transactional(&quot;blTransactionManager&quot;)
 596      public GenericResponse changePassword(String username,
 597              String oldPassword, String password, String confirmPassword) {



 598          GenericResponse response = new GenericResponse();
 599          AdminUser user = null;
 600          if (username != null) {
 601              user = adminUserDao.readAdminUserByUserName(username);
 602          }
 603          checkUser(user, response);
 604          checkPassword(password, confirmPassword, response);
 605  
 606          if (!response.getHasErrors()) {
 607              checkExistingPassword(oldPassword, user, response);
 608          }
 609  
 610          if (!response.getHasErrors()) {
 611              user.setUnencodedPassword(password);
 612              saveAdminUser(user);
 613  
 614          }
 615  
 616          return response;
 617  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 618 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 619 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 620 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 621 -     * Determines if a password is valid by comparing it to the encoded string, optionally using a salt.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 622 -     * &lt;p&gt;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 623 -     * The externally salted {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder} support is"> 623 -     * The externally salted {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 624 -     * being deprecated, following in Spring Security&#x27;s footsteps, in order to move towards self salting hashing algorithms such as bcrypt."> 624 -     * being deprecated, following in Spring Security&#x27;s footsteps, in order to move towards self salting hashing aðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 625 -     * Bcrypt is a superior hashing algorithm that randomly generates a salt per password in order to protect against rainbow table attacks"> 625 -     * Bcrypt is a superior hashing algorithm that randomly generates a salt per password in order to protect agaiðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 626 -     * and is an intentionally expensive algorithm to further guard against brute force attempts to crack hashed passwords."> 626 -     * and is an intentionally expensive algorithm to further guard against brute force attempts to crack hashed pðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 627 -     * Additionally, having the encoding algorithm handle the salt internally reduces code complexity and dependencies such as {@link SaltSource}."> 627 -     * Additionally, having the encoding algorithm handle the salt internally reduces code complexity and dependenðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 628 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 629 -     * @deprecated the new {@link PasswordEncoder} handles salting internally, this will be removed in 4.2</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 630 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 631 -     * @param encodedPassword the encoded password</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 632 -     * @param rawPassword the unencoded password</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 633 -     * @param salt the optional salt</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 634 -     * @return true if rawPassword matches the encodedPassword, false otherwise</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 635 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 636 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 637 -    protected boolean isPasswordValid(String encodedPassword, String rawPassword, Object salt) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 638 -        if (usingDeprecatedPasswordEncoder()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 639 -            return passwordEncoder.isPasswordValid(encodedPassword, rawPassword, salt);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 640 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 641 -            return isPasswordValid(encodedPassword, rawPassword);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 642 -        }</span>
 643      }
 644  
 645      /**
<abbr title=" 646       * Determines if a password is valid by comparing it to the encoded string, salting is handled internally to the {@link PasswordEncoder}."> 646       * Determines if a password is valid by comparing it to the encoded string, salting is handled internally to tðŸ”µ</abbr>
 647       * &lt;p&gt;
<abbr title=" 648       * This method must always be called to verify if a password is valid after the original encoded password is generated"> 648       * This method must always be called to verify if a password is valid after the original encoded password is gðŸ”µ</abbr>
<abbr title=" 649       * due to {@link PasswordEncoder} randomly generating salts internally and appending them to the resulting hash."> 649       * due to {@link PasswordEncoder} randomly generating salts internally and appending them to the resulting hasðŸ”µ</abbr>
 650       *
 651       * @param encodedPassword the encoded password
 652       * @param rawPassword the raw password to check against the encoded password
 653       * @return true if rawPassword matches the encodedPassword, false otherwise
 654       */
 655      protected boolean isPasswordValid(String encodedPassword, String rawPassword) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 656 -        return passwordEncoderNew.matches(rawPassword, encodedPassword);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 657 +        return passwordEncoderBean.matches(rawPassword, encodedPassword);</span>
 658      }
 659  
 660      /**
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 661 -     * Generate an encoded password from a raw password, optionally using a salt.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 662 -     * &lt;p&gt;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 663 -     * The externally salted {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder} support is"> 663 -     * The externally salted {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 664 -     * being deprecated, following in Spring Security&#x27;s footsteps, in order to move towards self salting hashing algorithms such as bcrypt."> 664 -     * being deprecated, following in Spring Security&#x27;s footsteps, in order to move towards self salting hashing aðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 665 -     * Bcrypt is a superior hashing algorithm that randomly generates a salt per password in order to protect against rainbow table attacks"> 665 -     * Bcrypt is a superior hashing algorithm that randomly generates a salt per password in order to protect agaiðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 666 -     * and is an intentionally expensive algorithm to further guard against brute force attempts to crack hashed passwords."> 666 -     * and is an intentionally expensive algorithm to further guard against brute force attempts to crack hashed pðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 667 -     * Additionally, having the encoding algorithm handle the salt internally reduces code complexity and dependencies such as {@link SaltSource}."> 667 -     * Additionally, having the encoding algorithm handle the salt internally reduces code complexity and dependenðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 668 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 669 -     * @deprecated the new {@link PasswordEncoder} handles salting internally, this will be removed in 4.2</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 670 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 671 -     * @param rawPassword</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 672 -     * @param salt</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 673 -     * @return</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 674 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 675 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 676 -    protected String encodePassword(String rawPassword, Object salt) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 677 -        if (usingDeprecatedPasswordEncoder()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 678 -            return passwordEncoder.encodePassword(rawPassword, salt);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 679 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 680 -            return encodePassword(rawPassword);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 681 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 682 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 683 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 684 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 685 -     * Generate an encoded password from a raw password, salting is handled internally to the {@link PasswordEncoder}."> 685 -     * Generate an encoded password from a raw password, salting is handled internally to the {@link PasswordEncodðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 686 +     * Generate an encoded password from a raw password</span>
 687       * &lt;p&gt;
<abbr title=" 688       * This method can only be called once per password. The salt is randomly generated internally in the {@link PasswordEncoder}"> 688       * This method can only be called once per password. The salt is randomly generated internally in the {@link PðŸ”µ</abbr>
<abbr title=" 689       * and appended to the hash to provide the resulting encoded password. Once this has been called on a password,"> 689       * and appended to the hash to provide the resulting encoded password. Once this has been called on a passwordðŸ”µ</abbr>
<abbr title=" 690       * going forward all checks for authenticity must be done by {@link #isPasswordValid(String, String)} as encoding the"> 690       * going forward all checks for authenticity must be done by {@link #isPasswordValid(String, String)} as encodðŸ”µ</abbr>
 691       * same password twice will result in different encoded passwords.
 692       *
 693       * @param rawPassword the unencoded password to encode
 694       * @return the encoded password
 695       */
 696      protected String encodePassword(String rawPassword) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 697 -        return passwordEncoderNew.encode(rawPassword);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 698 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 699 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 700 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 701 -    protected boolean usingDeprecatedPasswordEncoder() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 702 -        return passwordEncoder != null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 703 +        return passwordEncoderBean.encode(rawPassword);</span>
 704      }
 705  }</pre></td>
                            <td><pre>   1  /*
   2   * #%L
   3   * BroadleafCommerce Open Admin Platform
   4   * %%
   5   * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6   * %%
   7   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10   * the Broadleaf End User License Agreement (EULA), Version 1.1
  11   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12   * shall apply.
  13   *
<abbr title="  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  15   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  16   * #L%
  17   */
  18  package org.broadleafcommerce.openadmin.server.security.service;
  19  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  20 -import net.sf.ehcache.Cache;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  21 -import net.sf.ehcache.CacheManager;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  22 -import net.sf.ehcache.Element;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  23 -</span>
  24  import org.apache.commons.collections4.CollectionUtils;
  25  import org.apache.commons.lang3.BooleanUtils;
  26  import org.apache.commons.lang3.StringUtils;
  27  import org.apache.commons.logging.Log;
  28  import org.apache.commons.logging.LogFactory;
  29  import org.broadleafcommerce.common.email.service.EmailService;
  30  import org.broadleafcommerce.common.email.service.info.EmailInfo;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  31 +import org.broadleafcommerce.common.extension.ExtensionResultHolder;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  32 +import org.broadleafcommerce.common.extension.ExtensionResultStatusType;</span>
  33  import org.broadleafcommerce.common.security.util.PasswordChange;
  34  import org.broadleafcommerce.common.security.util.PasswordUtils;
  35  import org.broadleafcommerce.common.service.GenericResponse;
  36  import org.broadleafcommerce.common.time.SystemTime;
  37  import org.broadleafcommerce.common.util.BLCSystemProperty;
  38  import org.broadleafcommerce.common.util.StringUtil;
  39  import org.broadleafcommerce.openadmin.server.security.dao.AdminPermissionDao;
  40  import org.broadleafcommerce.openadmin.server.security.dao.AdminRoleDao;
  41  import org.broadleafcommerce.openadmin.server.security.dao.AdminUserDao;
  42  import org.broadleafcommerce.openadmin.server.security.dao.ForgotPasswordSecurityTokenDao;
  43  import org.broadleafcommerce.openadmin.server.security.domain.AdminPermission;
  44  import org.broadleafcommerce.openadmin.server.security.domain.AdminRole;
  45  import org.broadleafcommerce.openadmin.server.security.domain.AdminUser;
  46  import org.broadleafcommerce.openadmin.server.security.domain.ForgotPasswordSecurityToken;
  47  import org.broadleafcommerce.openadmin.server.security.domain.ForgotPasswordSecurityTokenImpl;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  48 +import org.broadleafcommerce.openadmin.server.security.extension.AdminSecurityServiceExtensionManager;</span>

  49  import org.broadleafcommerce.openadmin.server.security.service.type.PermissionType;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  50 -import org.broadleafcommerce.openadmin.server.security.service.user.AdminUserDetails;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  51 -import org.springframework.beans.factory.NoSuchBeanDefinitionException;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  52 -import org.springframework.beans.factory.annotation.Autowired;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  53 -import org.springframework.beans.factory.annotation.Qualifier;</span>

  54  import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  55 -import org.springframework.security.authentication.dao.SaltSource;</span>
  56  import org.springframework.security.core.Authentication;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  57 -import org.springframework.security.core.GrantedAuthority;</span>
  58  import org.springframework.security.core.context.SecurityContextHolder;
  59  import org.springframework.security.crypto.password.PasswordEncoder;
  60  import org.springframework.stereotype.Service;
  61  import org.springframework.transaction.annotation.Transactional;
  62  

  63  import java.util.ArrayList;
  64  import java.util.Date;
  65  import java.util.HashMap;
  66  import java.util.List;
  67  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  68 -import javax.annotation.PostConstruct;</span>
  69  import javax.annotation.Resource;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  70 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  71 +import net.sf.ehcache.Cache;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  72 +import net.sf.ehcache.CacheManager;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  73 +import net.sf.ehcache.Element;</span>
  74  
  75  /**
  76   *
  77   * @author jfischer
  78   *
  79   */
  80  @Service(&quot;blAdminSecurityService&quot;)
  81  public class AdminSecurityServiceImpl implements AdminSecurityService {
  82  
  83      private static final Log LOG = LogFactory.getLog(AdminSecurityServiceImpl.class);
  84  
  85      private static int TEMP_PASSWORD_LENGTH = 12;
  86      private static final int FULL_PASSWORD_LENGTH = 16;
  87  




  88      @Resource(name = &quot;blAdminRoleDao&quot;)
  89      protected AdminRoleDao adminRoleDao;
  90  
  91      @Resource(name = &quot;blAdminUserDao&quot;)
  92      protected AdminUserDao adminUserDao;
  93  
  94      @Resource(name = &quot;blForgotPasswordSecurityTokenDao&quot;)
  95      protected ForgotPasswordSecurityTokenDao forgotPasswordSecurityTokenDao;
  96  
  97      @Resource(name = &quot;blAdminPermissionDao&quot;)
  98      protected AdminPermissionDao adminPermissionDao;
  99  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 100 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 101 -     * &lt;p&gt;Set by {@link #setupPasswordEncoder()} if the blPasswordEncoder bean provided is the deprecated version.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 102 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 103 -     * @deprecated Spring Security has deprecated this encoder interface, this will be removed in 4.2</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 104 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 105 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 106 -    protected org.springframework.security.authentication.encoding.PasswordEncoder passwordEncoder;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 107 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 108 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 109 -     * &lt;p&gt;Set by {@link #setupPasswordEncoder()} if the blPasswordEncoder bean provided is the new version.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 110 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 111 -    protected PasswordEncoder passwordEncoderNew;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 112 -</span>
 113      protected static String CACHE_NAME = &quot;blSecurityElements&quot;;
 114      protected static String CACHE_KEY_PREFIX = &quot;security:&quot;;
 115      protected Cache cache = CacheManager.getInstance().getCache(CACHE_NAME);


 116  
 117      /**
<abbr title=" 118       * &lt;p&gt;This is simply a placeholder to be used by {@link #setupPasswordEncoder()} to determine if we&#x27;re using the"> 118       * &lt;p&gt;This is simply a placeholder to be used by {@link #setupPasswordEncoder()} to determine if we&#x27;re using tðŸ”µ</abbr>
<abbr title=" 119       * new {@link PasswordEncoder} or the deprecated {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder}"> 119       * new {@link PasswordEncoder} or the deprecated {@link org.springframework.security.authentication.encoding.PðŸ”µ</abbr>
 120       */
 121      @Resource(name=&quot;blAdminPasswordEncoder&quot;)
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 122 -    protected Object passwordEncoderBean;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 123 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 124 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 125 -     * Optional password salt to be used with the passwordEncoder</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 126 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 127 -     * @deprecated use {@link #saltSource} instead, this will be removed in 4.2</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 128 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 129 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 130 -    protected String salt;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 131 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 132 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 133 -     * Use a Salt Source ONLY if there&#x27;s one configured</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 134 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 135 -     * @deprecated the new {@link PasswordEncoder} handles salting internally, this will be removed in 4.2</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 136 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 137 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 138 -    @Autowired(required=false)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 139 -    @Qualifier(&quot;blAdminSaltSource&quot;)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 140 -    protected SaltSource saltSource;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 141 +    protected PasswordEncoder passwordEncoderBean;</span>
 142  
 143      @Resource(name=&quot;blEmailService&quot;)
 144      protected EmailService emailService;
 145  
 146      @Resource(name=&quot;blSendAdminResetPasswordEmail&quot;)
 147      protected EmailInfo resetPasswordEmailInfo;
 148  
 149      @Resource(name=&quot;blSendAdminUsernameEmailInfo&quot;)
 150      protected EmailInfo sendUsernameEmailInfo;
 151  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 152 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 153 -     * &lt;p&gt;Sets either {@link #passwordEncoder} or {@link #passwordEncoderNew} based on the type of {@link #passwordEncoderBean}"> 153 -     * &lt;p&gt;Sets either {@link #passwordEncoder} or {@link #passwordEncoderNew} based on the type of {@link #passworðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 154 -     * in order to provide bean configuration backwards compatibility with the deprecated {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder} bean."> 154 -     * in order to provide bean configuration backwards compatibility with the deprecated {@link org.springframewoðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 155 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 156 -     * &lt;p&gt;{@link #passwordEncoderBean} is set by the bean defined as &quot;blPasswordEncoder&quot;.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 157 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 158 -     * &lt;p&gt;This class will utilize either the new or deprecated PasswordEncoder type depending on which is not null."> 158 -     * &lt;p&gt;This class will utilize either the new or deprecated PasswordEncoder type depending on which is not nullðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 159 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 160 -     * @throws NoSuchBeanDefinitionException if {@link #passwordEncoderBean} is null or not an instance of either PasswordEncoder"> 160 -     * @throws NoSuchBeanDefinitionException if {@link #passwordEncoderBean} is null or not an instance of either ðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 161 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 162 -    @PostConstruct</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 163 -    protected void setupPasswordEncoder() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 164 -        passwordEncoderNew = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 165 -        passwordEncoder = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 166 -        if (passwordEncoderBean instanceof PasswordEncoder) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 167 -            passwordEncoderNew = (PasswordEncoder) passwordEncoderBean;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 168 -        } else if (passwordEncoderBean instanceof org.springframework.security.authentication.encoding.PasswordEncoder) {"> 168 -        } else if (passwordEncoderBean instanceof org.springframework.security.authentication.encoding.PasswordEncðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 169 -            passwordEncoder = (org.springframework.security.authentication.encoding.PasswordEncoder) passwordEncoderBean;"> 169 -            passwordEncoder = (org.springframework.security.authentication.encoding.PasswordEncoder) passwordEncodðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 170 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 171 -            throw new NoSuchBeanDefinitionException(&quot;No PasswordEncoder bean is defined&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 172 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 173 -    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 174 +    @Resource(name = &quot;blAdminSecurityServiceExtensionManager&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 175 +    protected AdminSecurityServiceExtensionManager extensionManager;</span>
 176  
 177      protected int getTokenExpiredMinutes() {
 178          return BLCSystemProperty.resolveIntSystemProperty(&quot;tokenExpiredMinutes&quot;);
 179      }
 180  
 181      protected String getResetPasswordURL() {
 182          return BLCSystemProperty.resolveSystemProperty(&quot;resetPasswordURL&quot;);
 183      }
 184  
 185      @Override
 186      @Transactional(&quot;blTransactionManager&quot;)
 187      public void deleteAdminPermission(AdminPermission permission) {

 188          adminPermissionDao.deleteAdminPermission(permission);
 189          clearAdminSecurityCache();
 190      }
 191  
 192      @Override
 193      @Transactional(&quot;blTransactionManager&quot;)
 194      public void deleteAdminRole(AdminRole role) {
 195          adminRoleDao.deleteAdminRole(role);
 196          clearAdminSecurityCache();
 197      }
 198  
 199      @Override
 200      @Transactional(&quot;blTransactionManager&quot;)
 201      public void deleteAdminUser(AdminUser user) {
 202          adminUserDao.deleteAdminUser(user);
 203          clearAdminSecurityCache();
 204      }
 205  
 206      @Override
 207      public AdminPermission readAdminPermissionById(Long id) {
 208          return adminPermissionDao.readAdminPermissionById(id);
 209      }
 210  
 211      @Override
 212      public AdminRole readAdminRoleById(Long id) {
 213          return adminRoleDao.readAdminRoleById(id);
 214      }
 215  
 216      @Override
 217      public AdminUser readAdminUserById(Long id) {
 218          return adminUserDao.readAdminUserById(id);
 219      }
 220  
 221      @Override
 222      @Transactional(&quot;blTransactionManager&quot;)
 223      public AdminPermission saveAdminPermission(AdminPermission permission) {
 224          permission = adminPermissionDao.saveAdminPermission(permission);
 225          clearAdminSecurityCache();
 226          return permission;
 227      }
 228  
 229      @Override
 230      @Transactional(&quot;blTransactionManager&quot;)
 231      public AdminRole saveAdminRole(AdminRole role) {
 232          role = adminRoleDao.saveAdminRole(role);
 233          clearAdminSecurityCache();
 234          return role;
 235      }
 236  
 237      @Override
 238      @Transactional(&quot;blTransactionManager&quot;)
 239      public AdminUser saveAdminUser(AdminUser user) {
 240          boolean encodePasswordNeeded = false;
 241          String unencodedPassword = user.getUnencodedPassword();
 242  
 243          if (user.getUnencodedPassword() != null) {
 244              encodePasswordNeeded = true;
 245              user.setPassword(unencodedPassword);
 246          }
 247  
 248          // If no password is set, default to a secure password.
 249          if (user.getPassword() == null) {
 250              user.setPassword(generateSecurePassword());
 251          }
 252  
 253          AdminUser returnUser = adminUserDao.saveAdminUser(user);
 254  
 255          if (encodePasswordNeeded) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 256 -            returnUser.setPassword(encodePassword(unencodedPassword, getSalt(returnUser, unencodedPassword)));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 257 +            returnUser.setPassword(encodePassword(unencodedPassword));</span>
 258          }
 259  
 260          returnUser = adminUserDao.saveAdminUser(returnUser);
 261          clearAdminSecurityCache();
 262          return returnUser;
 263      }
 264  
 265      @Override
 266      public void clearAdminSecurityCache() {
 267          if (LOG.isTraceEnabled()) {
 268              LOG.trace(&quot;Admin Security Cache DELETE&quot;);
 269          }
 270          cache.removeAll();
 271      }
 272  
 273      protected String generateSecurePassword() {
 274          return PasswordUtils.generateSecurePassword(FULL_PASSWORD_LENGTH);
 275      }
 276  
 277      @Override
 278      @Transactional(&quot;blTransactionManager&quot;)
 279      public AdminUser changePassword(PasswordChange passwordChange) {
 280          AdminUser user = readAdminUserByUserName(passwordChange.getUsername());
 281          user.setUnencodedPassword(passwordChange.getNewPassword());
 282          user = saveAdminUser(user);
 283          Authentication auth = SecurityContextHolder.getContext().getAuthentication();
<abbr title=" 284          UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(passwordChange.getUsername(), passwordChange.getNewPassword(), auth.getAuthorities());"> 284          UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(passwordChange.gðŸ”µ</abbr>
 285          SecurityContextHolder.getContext().setAuthentication(authRequest);
 286          auth.setAuthenticated(false);
 287          return user;
 288      }
 289  
 290      @Override
<abbr title=" 291      public boolean isUserQualifiedForOperationOnCeilingEntity(AdminUser adminUser, PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 291      public boolean isUserQualifiedForOperationOnCeilingEntity(AdminUser adminUser, PermissionType permissionType, ðŸ”µ</abbr>
 292          Boolean response = null;
 293          String cacheKey = buildCacheKey(adminUser, permissionType, ceilingEntityFullyQualifiedName);
 294          Element cacheElement = cache.get(cacheKey);
 295  
 296          if (cacheElement != null) {
 297              response = (Boolean) cacheElement.getObjectValue();




 298  
 299              if (LOG.isTraceEnabled()) {
 300                  LOG.trace(&quot;Admin Security Cache GET For: \&quot;&quot; + cacheKey + &quot;\&quot; = &quot; + response);
 301              }
 302          }
 303  
 304          if (response == null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 305 -            response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntity(adminUser, permissionType, ceilingEntityFullyQualifiedName);"> 305 -            response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntity(adminUser, permissionType, ceðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 306 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 307 -            if (!response) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 308 -                response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntityViaDefaultPermissions(ceilingEntityFullyQualifiedName);"> 308 -                response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntityViaDefaultPermissions(ceilðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 309 +            if (extensionManager != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 310 +                ExtensionResultHolder&lt;Boolean&gt; result = new ExtensionResultHolder&lt;Boolean&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 311 +                ExtensionResultStatusType resultStatusType = extensionManager.getProxy().hasPrivilegesForOperation(adminUser, permissionType, result);"> 311 +                ExtensionResultStatusType resultStatusType = extensionManager.getProxy().hasPrivilegesForOperationðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 312 +                if (ExtensionResultStatusType.HANDLED == resultStatusType) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 313 +                    response = result.getResult();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 314 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 315 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 316 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 317 +            if (response == null || !response) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 318 +                response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntity(adminUser, permissionType, ceilingEntityFullyQualifiedName);"> 318 +                response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntity(adminUser, permissionTypeðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 319 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 320 +                if (!response) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 321 +                    response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntityViaDefaultPermissions(ceilingEntityFullyQualifiedName);"> 321 +                    response = adminPermissionDao.isUserQualifiedForOperationOnCeilingEntityViaDefaultPermissions(ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 322 +                }</span>
 323              }
 324  
 325              cacheElement = new Element(cacheKey, response);
 326              cache.put(cacheElement);

 327  
 328              if (LOG.isTraceEnabled()) {
 329                  LOG.trace(&quot;Admin Security Cache PUT For: \&quot;&quot; + cacheKey + &quot;\&quot; = &quot; + response);
 330              }
 331          }
 332  
 333          return response;
 334      }
 335  
<abbr title=" 336      protected String buildCacheKey(AdminUser adminUser, PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 336      protected String buildCacheKey(AdminUser adminUser, PermissionType permissionType, String ceilingEntityFullyQuðŸ”µ</abbr>
 337          return CACHE_KEY_PREFIX
 338                 + &quot;user:&quot; + adminUser.getId() + &quot;,&quot;
 339                 + &quot;permType:&quot; + permissionType.getFriendlyType() + &quot;,&quot;
 340                 + &quot;ceiling:&quot; + ceilingEntityFullyQualifiedName;
 341      }
 342  
 343      @Override
<abbr title=" 344      public boolean doesOperationExistForCeilingEntity(PermissionType permissionType, String ceilingEntityFullyQualifiedName) {"> 344      public boolean doesOperationExistForCeilingEntity(PermissionType permissionType, String ceilingEntityFullyQualðŸ”µ</abbr>
<abbr title=" 345          return adminPermissionDao.doesOperationExistForCeilingEntity(permissionType, ceilingEntityFullyQualifiedName);"> 345          return adminPermissionDao.doesOperationExistForCeilingEntity(permissionType, ceilingEntityFullyQualifiedNaðŸ”µ</abbr>
 346      }
 347  
 348      @Override
 349      public AdminUser readAdminUserByUserName(String userName) {
 350          return adminUserDao.readAdminUserByUserName(userName);
 351      }
 352  
 353      @Override
 354      public List&lt;AdminUser&gt; readAdminUsersByEmail(String email) {
 355          return adminUserDao.readAdminUserByEmail(email);
 356      }
 357  
 358      @Override
 359      public List&lt;AdminUser&gt; readAllAdminUsers() {
 360          return adminUserDao.readAllAdminUsers();
 361      }
 362  
 363      @Override
 364      public List&lt;AdminRole&gt; readAllAdminRoles() {
 365          return adminRoleDao.readAllAdminRoles();
 366      }
 367  
 368      @Override
 369      public List&lt;AdminPermission&gt; readAllAdminPermissions() {
 370          return adminPermissionDao.readAllAdminPermissions();
 371      }
 372  
 373      @Override
 374      @Transactional(&quot;blTransactionManager&quot;)
 375      public GenericResponse sendForgotUsernameNotification(String emailAddress) {
 376          GenericResponse response = new GenericResponse();
 377          List&lt;AdminUser&gt; users = null;
 378          if (emailAddress != null) {
 379              users = adminUserDao.readAdminUserByEmail(emailAddress);
 380          }
 381          if (CollectionUtils.isEmpty(users)) {
 382              response.addErrorCode(&quot;notFound&quot;);
 383          } else {
 384              List&lt;String&gt; activeUsernames = new ArrayList&lt;String&gt;();
 385              for (AdminUser user : users) {
 386                  if (user.getActiveStatusFlag()) {
 387                      activeUsernames.add(user.getLogin());
 388                  }
 389              }
 390  
 391              if (activeUsernames.size() &gt; 0) {
 392                  HashMap&lt;String, Object&gt; vars = new HashMap&lt;String, Object&gt;();
 393                  vars.put(&quot;accountNames&quot;, activeUsernames);
 394                  emailService.sendTemplateEmail(emailAddress, getSendUsernameEmailInfo(), vars);

 395              } else {
 396                  // send inactive username found email.
 397                  response.addErrorCode(&quot;inactiveUser&quot;);
 398              }
 399          }
 400          return response;
 401      }
 402  
 403      @Override
 404      @Transactional(&quot;blTransactionManager&quot;)
 405      public GenericResponse sendResetPasswordNotification(String username) {
 406          GenericResponse response = new GenericResponse();
 407          AdminUser user = null;
 408  
 409          if (username != null) {
 410              user = adminUserDao.readAdminUserByUserName(username);
 411          }
 412  
 413          checkUser(user,response);
 414  
 415          if (! response.getHasErrors()) {
 416              String token = PasswordUtils.generateSecurePassword(TEMP_PASSWORD_LENGTH);
 417              token = token.toLowerCase();
 418  
 419              ForgotPasswordSecurityToken fpst = new ForgotPasswordSecurityTokenImpl();
 420              fpst.setAdminUserId(user.getId());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 421 -            fpst.setToken(encodePassword(token, null));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 422 +            fpst.setToken(encodePassword(token));</span>
 423              fpst.setCreateDate(SystemTime.asDate());
 424              forgotPasswordSecurityTokenDao.saveToken(fpst);
 425  
 426              HashMap&lt;String, Object&gt; vars = new HashMap&lt;String, Object&gt;();
 427              vars.put(&quot;token&quot;, token);
 428              String resetPasswordUrl = getResetPasswordURL();
 429              if (!StringUtils.isEmpty(resetPasswordUrl)) {
 430                  if (resetPasswordUrl.contains(&quot;?&quot;)) {
 431                      resetPasswordUrl=resetPasswordUrl+&quot;&amp;token=&quot;+token;
 432                  } else {
 433                      resetPasswordUrl=resetPasswordUrl+&quot;?token=&quot;+token;
 434                  }
 435              }
 436              vars.put(&quot;resetPasswordUrl&quot;, resetPasswordUrl);
 437              emailService.sendTemplateEmail(user.getEmail(), getResetPasswordEmailInfo(), vars);
 438  


 439          }
 440          return response;
 441      }
 442  
 443      @Override
 444      @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 445      public GenericResponse resetPasswordUsingToken(String username, String token, String password, String confirmPassword) {"> 445      public GenericResponse resetPasswordUsingToken(String username, String token, String password, String confirmPðŸ”µ</abbr>
 446          GenericResponse response = new GenericResponse();
 447          AdminUser user = null;
 448          if (username != null) {
 449              user = adminUserDao.readAdminUserByUserName(username);
 450          }
 451          checkUser(user, response);
 452          checkPassword(password, confirmPassword, response);
 453          if (StringUtils.isBlank(token)) {
 454              response.addErrorCode(&quot;invalidToken&quot;);
 455          }
 456  
 457          ForgotPasswordSecurityToken fpst = null;
 458          if (! response.getHasErrors()) {
 459              token = token.toLowerCase();
<abbr title=" 460              List&lt;ForgotPasswordSecurityToken&gt; fpstoks = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserId(user.getId());"> 460              List&lt;ForgotPasswordSecurityToken&gt; fpstoks = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserðŸ”µ</abbr>
 461              for (ForgotPasswordSecurityToken fpstok : fpstoks) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 462 -                if (isPasswordValid(fpstok.getToken(), token, null)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 463 +                if (isPasswordValid(fpstok.getToken(), token)) {</span>
 464                      fpst = fpstok;
 465                      break;
 466                  }
 467              }
 468              if (fpst == null) {
 469                  response.addErrorCode(&quot;invalidToken&quot;);
 470              } else if (fpst.isTokenUsedFlag()) {
 471                  response.addErrorCode(&quot;tokenUsed&quot;);
 472              } else if (isTokenExpired(fpst)) {
 473                  response.addErrorCode(&quot;tokenExpired&quot;);
 474              }
 475          }
 476  
 477          if (! response.getHasErrors()) {
 478              if (! user.getId().equals(fpst.getAdminUserId())) {
 479                  if (LOG.isWarnEnabled()) {
<abbr title=" 480                      LOG.warn(&quot;Password reset attempt tried with mismatched user and token &quot; + user.getId() + &quot;, &quot; + StringUtil.sanitize(token));"> 480                      LOG.warn(&quot;Password reset attempt tried with mismatched user and token &quot; + user.getId() + &quot;, &quot; ðŸ”µ</abbr>
 481                  }
 482                  response.addErrorCode(&quot;invalidToken&quot;);
 483              }
 484          }
 485  
 486          if (! response.getHasErrors()) {
 487              user.setUnencodedPassword(password);
 488              saveAdminUser(user);
 489              invalidateAllTokensForAdminUser(user);
 490          }
 491  
 492          return response;
 493      }
 494  
 495      protected void invalidateAllTokensForAdminUser(AdminUser user) {
<abbr title=" 496          List&lt;ForgotPasswordSecurityToken&gt; tokens = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserId(user.getId());"> 496          List&lt;ForgotPasswordSecurityToken&gt; tokens = forgotPasswordSecurityTokenDao.readUnusedTokensByAdminUserId(usðŸ”µ</abbr>
 497          for (ForgotPasswordSecurityToken token : tokens) {
 498              token.setTokenUsedFlag(true);
 499              forgotPasswordSecurityTokenDao.saveToken(token);
 500          }
 501      }
 502  
 503      protected void checkUser(AdminUser user, GenericResponse response) {
 504          if (user == null) {
 505              response.addErrorCode(&quot;invalidUser&quot;);
 506          } else if (StringUtils.isBlank(user.getEmail())) {
 507              response.addErrorCode(&quot;emailNotFound&quot;);
 508          } else if (BooleanUtils.isNotTrue(user.getActiveStatusFlag())) {
 509              response.addErrorCode(&quot;inactiveUser&quot;);
 510          }
 511      }
 512  
 513      protected void checkPassword(String password, String confirmPassword, GenericResponse response) {
 514          if (StringUtils.isBlank(password) || StringUtils.isBlank(confirmPassword)) {
 515              response.addErrorCode(&quot;invalidPassword&quot;);
 516          } else if (! password.equals(confirmPassword)) {
 517              response.addErrorCode(&quot;passwordMismatch&quot;);
 518          }
 519      }
 520  
 521      protected void checkExistingPassword(String unencodedPassword, AdminUser user, GenericResponse response) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 522 -        if (!isPasswordValid(user.getPassword(), unencodedPassword, getSalt(user, unencodedPassword))) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 523 +        if (!isPasswordValid(user.getPassword(), unencodedPassword)) {</span>
 524              response.addErrorCode(&quot;invalidPassword&quot;);
 525          }
 526      }
 527  
 528      protected boolean isTokenExpired(ForgotPasswordSecurityToken fpst) {
 529          Date now = SystemTime.asDate();
 530          long currentTimeInMillis = now.getTime();
 531          long tokenSaveTimeInMillis = fpst.getCreateDate().getTime();
 532          long minutesSinceSave = (currentTimeInMillis - tokenSaveTimeInMillis)/60000;
 533          return minutesSinceSave &gt; getTokenExpiredMinutes();
 534      }
 535  
 536      public static int getPASSWORD_TOKEN_LENGTH() {
 537          return TEMP_PASSWORD_LENGTH;
 538      }
 539  
 540      public static void setPASSWORD_TOKEN_LENGTH(int PASSWORD_TOKEN_LENGTH) {
 541          AdminSecurityServiceImpl.TEMP_PASSWORD_LENGTH = PASSWORD_TOKEN_LENGTH;
 542      }
 543  
 544      public EmailInfo getSendUsernameEmailInfo() {
 545          return sendUsernameEmailInfo;
 546      }
 547  
 548      public void setSendUsernameEmailInfo(EmailInfo sendUsernameEmailInfo) {
 549          this.sendUsernameEmailInfo = sendUsernameEmailInfo;
 550      }
 551  
 552      public EmailInfo getResetPasswordEmailInfo() {
 553          return resetPasswordEmailInfo;
 554      }
 555  
 556      public void setResetPasswordEmailInfo(EmailInfo resetPasswordEmailInfo) {
 557          this.resetPasswordEmailInfo = resetPasswordEmailInfo;
 558      }
 559  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 560 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 561 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 562 -    public Object getSalt(AdminUser user, String unencodedPassword) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 563 -        Object salt = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 564 -        if (saltSource != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 565 -            salt = saltSource.getSalt(new AdminUserDetails(user.getId(), user.getLogin(), unencodedPassword, new ArrayList&lt;GrantedAuthority&gt;()));"> 565 -            salt = saltSource.getSalt(new AdminUserDetails(user.getId(), user.getLogin(), unencodedPassword, new AðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 566 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 567 -        return salt;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 568 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 569 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 570 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 571 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 572 -    public String getSalt() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 573 -        return salt;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 574 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 575 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 576 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 577 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 578 -    public void setSalt(String salt) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 579 -        this.salt = salt;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 580 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 581 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 582 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 583 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 584 -    public SaltSource getSaltSource() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 585 -        return saltSource;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 586 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 587 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 588 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 589 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 590 -    public void setSaltSource(SaltSource saltSource) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 591 -        this.saltSource = saltSource;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 592 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 593 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 594 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 595 -    @Transactional(&quot;blTransactionManager&quot;)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 596 -    public GenericResponse changePassword(String username,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 597 -            String oldPassword, String password, String confirmPassword) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 598 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 599 +    @Transactional(&quot;blTransactionManager&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 600 +    public GenericResponse changePassword(String username, String oldPassword, String password, String confirmPassword) {"> 600 +    public GenericResponse changePassword(String username, String oldPassword, String password, String confirmPassðŸ”µ</abbr></span>
 601          GenericResponse response = new GenericResponse();
 602          AdminUser user = null;
 603          if (username != null) {
 604              user = adminUserDao.readAdminUserByUserName(username);
 605          }
 606          checkUser(user, response);
 607          checkPassword(password, confirmPassword, response);
 608  
 609          if (!response.getHasErrors()) {
 610              checkExistingPassword(oldPassword, user, response);
 611          }
 612  
 613          if (!response.getHasErrors()) {
 614              user.setUnencodedPassword(password);
 615              saveAdminUser(user);
 616  
 617          }
 618  
 619          return response;
 620  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 621 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 622 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 623 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 624 -     * Determines if a password is valid by comparing it to the encoded string, optionally using a salt.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 625 -     * &lt;p&gt;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 626 -     * The externally salted {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder} support is"> 626 -     * The externally salted {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 627 -     * being deprecated, following in Spring Security&#x27;s footsteps, in order to move towards self salting hashing algorithms such as bcrypt."> 627 -     * being deprecated, following in Spring Security&#x27;s footsteps, in order to move towards self salting hashing aðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 628 -     * Bcrypt is a superior hashing algorithm that randomly generates a salt per password in order to protect against rainbow table attacks"> 628 -     * Bcrypt is a superior hashing algorithm that randomly generates a salt per password in order to protect agaiðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 629 -     * and is an intentionally expensive algorithm to further guard against brute force attempts to crack hashed passwords."> 629 -     * and is an intentionally expensive algorithm to further guard against brute force attempts to crack hashed pðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 630 -     * Additionally, having the encoding algorithm handle the salt internally reduces code complexity and dependencies such as {@link SaltSource}."> 630 -     * Additionally, having the encoding algorithm handle the salt internally reduces code complexity and dependenðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 631 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 632 -     * @deprecated the new {@link PasswordEncoder} handles salting internally, this will be removed in 4.2</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 633 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 634 -     * @param encodedPassword the encoded password</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 635 -     * @param rawPassword the unencoded password</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 636 -     * @param salt the optional salt</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 637 -     * @return true if rawPassword matches the encodedPassword, false otherwise</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 638 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 639 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 640 -    protected boolean isPasswordValid(String encodedPassword, String rawPassword, Object salt) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 641 -        if (usingDeprecatedPasswordEncoder()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 642 -            return passwordEncoder.isPasswordValid(encodedPassword, rawPassword, salt);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 643 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 644 -            return isPasswordValid(encodedPassword, rawPassword);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 645 -        }</span>
 646      }
 647  
 648      /**
<abbr title=" 649       * Determines if a password is valid by comparing it to the encoded string, salting is handled internally to the {@link PasswordEncoder}."> 649       * Determines if a password is valid by comparing it to the encoded string, salting is handled internally to tðŸ”µ</abbr>
 650       * &lt;p&gt;
<abbr title=" 651       * This method must always be called to verify if a password is valid after the original encoded password is generated"> 651       * This method must always be called to verify if a password is valid after the original encoded password is gðŸ”µ</abbr>
<abbr title=" 652       * due to {@link PasswordEncoder} randomly generating salts internally and appending them to the resulting hash."> 652       * due to {@link PasswordEncoder} randomly generating salts internally and appending them to the resulting hasðŸ”µ</abbr>
 653       *
 654       * @param encodedPassword the encoded password
 655       * @param rawPassword the raw password to check against the encoded password
 656       * @return true if rawPassword matches the encodedPassword, false otherwise
 657       */
 658      protected boolean isPasswordValid(String encodedPassword, String rawPassword) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 659 -        return passwordEncoderNew.matches(rawPassword, encodedPassword);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 660 +        return passwordEncoderBean.matches(rawPassword, encodedPassword);</span>
 661      }
 662  
 663      /**
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 664 -     * Generate an encoded password from a raw password, optionally using a salt.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 665 -     * &lt;p&gt;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 666 -     * The externally salted {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEncoder} support is"> 666 -     * The externally salted {@link org.springframework.security.authentication.encoding.PasswordEncoder PasswordEðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 667 -     * being deprecated, following in Spring Security&#x27;s footsteps, in order to move towards self salting hashing algorithms such as bcrypt."> 667 -     * being deprecated, following in Spring Security&#x27;s footsteps, in order to move towards self salting hashing aðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 668 -     * Bcrypt is a superior hashing algorithm that randomly generates a salt per password in order to protect against rainbow table attacks"> 668 -     * Bcrypt is a superior hashing algorithm that randomly generates a salt per password in order to protect agaiðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 669 -     * and is an intentionally expensive algorithm to further guard against brute force attempts to crack hashed passwords."> 669 -     * and is an intentionally expensive algorithm to further guard against brute force attempts to crack hashed pðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 670 -     * Additionally, having the encoding algorithm handle the salt internally reduces code complexity and dependencies such as {@link SaltSource}."> 670 -     * Additionally, having the encoding algorithm handle the salt internally reduces code complexity and dependenðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 671 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 672 -     * @deprecated the new {@link PasswordEncoder} handles salting internally, this will be removed in 4.2</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 673 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 674 -     * @param rawPassword</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 675 -     * @param salt</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 676 -     * @return</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 677 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 678 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 679 -    protected String encodePassword(String rawPassword, Object salt) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 680 -        if (usingDeprecatedPasswordEncoder()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 681 -            return passwordEncoder.encodePassword(rawPassword, salt);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 682 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 683 -            return encodePassword(rawPassword);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 684 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 685 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 686 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 687 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 688 -     * Generate an encoded password from a raw password, salting is handled internally to the {@link PasswordEncoder}."> 688 -     * Generate an encoded password from a raw password, salting is handled internally to the {@link PasswordEncodðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 689 +     * Generate an encoded password from a raw password</span>
 690       * &lt;p&gt;
<abbr title=" 691       * This method can only be called once per password. The salt is randomly generated internally in the {@link PasswordEncoder}"> 691       * This method can only be called once per password. The salt is randomly generated internally in the {@link PðŸ”µ</abbr>
<abbr title=" 692       * and appended to the hash to provide the resulting encoded password. Once this has been called on a password,"> 692       * and appended to the hash to provide the resulting encoded password. Once this has been called on a passwordðŸ”µ</abbr>
<abbr title=" 693       * going forward all checks for authenticity must be done by {@link #isPasswordValid(String, String)} as encoding the"> 693       * going forward all checks for authenticity must be done by {@link #isPasswordValid(String, String)} as encodðŸ”µ</abbr>
 694       * same password twice will result in different encoded passwords.
 695       *
 696       * @param rawPassword the unencoded password to encode
 697       * @return the encoded password
 698       */
 699      protected String encodePassword(String rawPassword) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 700 -        return passwordEncoderNew.encode(rawPassword);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 701 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 702 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 703 -    @Deprecated</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 704 -    protected boolean usingDeprecatedPasswordEncoder() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 705 -        return passwordEncoder != null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 706 +        return passwordEncoderBean.encode(rawPassword);</span>
 707      }
 708  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            