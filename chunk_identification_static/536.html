<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>536</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    536
                    <a href="535.html">prev</a>
                    <a href="537.html">next</a>
                    <a href="536_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_b43aec0679d705647015fd4416ad6dc326ea7890_core/src/main/java/com/dtstack/flink/sql/side/SideSQLParser.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;b43aec0679d705647015fd4416ad6dc326ea7890:core/src/main/java/com/dtstack/flink/sql/side/SideSQLParser.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;b43aec0679d705647015fd4416ad6dc326ea7890^1:core/src/main/java/com/dtstack/flink/sql/side/SideSQLParser.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;b43aec0679d705647015fd4416ad6dc326ea7890^2:core/src/main/java/com/dtstack/flink/sql/side/SideSQLParser.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;6159bb9bb9904f950c489b50fb7dcbe399c3d327:core/src/main/java/com/dtstack/flink/sql/side/SideSQLParser.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [bj], [bj], [s]], subset: [[b], [bj], [sbj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19  
  20 
  21 package com.dtstack.flink.sql.side;
  22 
  23 import com.dtstack.flink.sql.parser.FlinkPlanner;
  24 import com.dtstack.flink.sql.util.TableUtils;
  25 import com.google.common.collect.Maps;
  26 import com.google.common.collect.Queues;
  27 import com.google.common.collect.Sets;
  28 import org.apache.calcite.sql.SqlBasicCall;
  29 import org.apache.calcite.sql.SqlIdentifier;
  30 import org.apache.calcite.sql.SqlInsert;
  31 import org.apache.calcite.sql.SqlJoin;
  32 import org.apache.calcite.sql.SqlKind;
  33 import org.apache.calcite.sql.SqlNode;
  34 import org.apache.calcite.sql.SqlNodeList;
  35 import org.apache.calcite.sql.SqlOrderBy;
  36 import org.apache.calcite.sql.SqlSelect;
  37 import org.apache.calcite.sql.SqlWith;
  38 import org.apache.calcite.sql.SqlWithItem;
  39 import org.apache.calcite.sql.parser.SqlParseException;
  40 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
  41 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  42 import org.apache.calcite.sql.SqlNode;</span>
  43 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  44 import org.apache.calcite.sql.parser.SqlParser;</span>
  45 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  46 import org.apache.flink.api.java.tuple.Tuple2;
  47 import org.apache.flink.table.api.Table;
  48 import org.apache.flink.table.calcite.FlinkPlannerImpl;
  49 import org.slf4j.Logger;
  50 import org.slf4j.LoggerFactory;
  51 
  52 import java.util.Map;
  53 import java.util.Queue;
  54 import java.util.Set;
  55 
  56 import static org.apache.calcite.sql.SqlKind.IDENTIFIER;
  57 
  58 /**
  59  * Parsing sql, obtain execution information dimension table
  60  * Date: 2018/7/24
  61  * Company: www.dtstack.com
  62  * @author xuchao
  63  */
  64 
  65 public class SideSQLParser {
  66     private static final Logger LOG = LoggerFactory.getLogger(SideSQLParser.class);
  67 
  68     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  69 
  70     public Queue&lt;Object&gt; getExeQueue(String exeSql, Set&lt;String&gt; sideTableSet) throws SqlParseException {
  71         LOG.info(&quot;----------exec original Sql----------&quot;);
  72         LOG.info(exeSql);
  73 
  74         Queue&lt;Object&gt; queueInfo = Queues.newLinkedBlockingQueue();
  75         FlinkPlannerImpl flinkPlanner = FlinkPlanner.getFlinkPlanner();
  76         SqlNode sqlNode = flinkPlanner.parse(exeSql);
  77 
  78         parseSql(sqlNode, sideTableSet, queueInfo, null, null, null);
  79         queueInfo.offer(sqlNode);
  80         return queueInfo;
  81     }
  82 
  83 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
  84 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  85 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  86     public Queue&lt;Object&gt; getExeQueue(String exeSql, Set&lt;String&gt; sideTableSet) throws SqlParseException {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  87         System.out.println(&quot;----------exec original Sql----------&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  88         System.out.println(exeSql);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  89         LOG.info(&quot;----------exec original Sql----------&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  90         LOG.info(exeSql);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  91 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  92         Queue&lt;Object&gt; queueInfo = Queues.newLinkedBlockingQueue();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  93         SqlParser sqlParser = SqlParser.create(exeSql, CalciteConfig.MYSQL_LEX_CONFIG);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  94         SqlNode sqlNode = sqlParser.parseStmt();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  95 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  96         parseSql(sqlNode, sideTableSet, queueInfo, null, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  97         queueInfo.offer(sqlNode);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  98         return queueInfo;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  99     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 100 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 101     private void checkAndReplaceMultiJoin(SqlNode sqlNode, Set&lt;String&gt; sideTableSet) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 102         SqlKind sqlKind = sqlNode.getKind();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 103         switch (sqlKind) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 104             case WITH: {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 105                 SqlWith sqlWith = (SqlWith) sqlNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 106                 SqlNodeList sqlNodeList = sqlWith.withList;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 107                 for (SqlNode withAsTable : sqlNodeList) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 108                     SqlWithItem sqlWithItem = (SqlWithItem) withAsTable;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 109                     checkAndReplaceMultiJoin(sqlWithItem.query, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 110                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 111                 checkAndReplaceMultiJoin(sqlWith.body, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 112                 break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 113             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 114             case INSERT:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 115                 SqlNode sqlSource = ((SqlInsert) sqlNode).getSource();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 116                 checkAndReplaceMultiJoin(sqlSource, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 117                 break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 118             case SELECT:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 119                 SqlNode sqlFrom = ((SqlSelect) sqlNode).getFrom();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 120                 if (sqlFrom.getKind() != IDENTIFIER) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 121                     checkAndReplaceMultiJoin(sqlFrom, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 122                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 123                 break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 124             case JOIN:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 125                 convertSideJoinToNewQuery((SqlJoin) sqlNode, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 126                 break;</span>
 127 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 128     private void checkAndReplaceMultiJoin(SqlNode sqlNode, Set&lt;String&gt; sideTableSet) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 129         SqlKind sqlKind = sqlNode.getKind();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 130         switch (sqlKind) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 131             case WITH: {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 132                 SqlWith sqlWith = (SqlWith) sqlNode;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 133                 SqlNodeList sqlNodeList = sqlWith.withList;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 134                 for (SqlNode withAsTable : sqlNodeList) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 135                     SqlWithItem sqlWithItem = (SqlWithItem) withAsTable;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 136                     checkAndReplaceMultiJoin(sqlWithItem.query, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 137                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 138                 checkAndReplaceMultiJoin(sqlWith.body, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 139                 break;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 140             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 141             case INSERT:</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 142                 SqlNode sqlSource = ((SqlInsert) sqlNode).getSource();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 143                 checkAndReplaceMultiJoin(sqlSource, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 144                 break;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 145             case SELECT:</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 146                 SqlNode sqlFrom = ((SqlSelect) sqlNode).getFrom();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 147                 if (sqlFrom.getKind() != IDENTIFIER) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 148                     checkAndReplaceMultiJoin(sqlFrom, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 149                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 150                 break;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 151             case JOIN:</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 152                 convertSideJoinToNewQuery((SqlJoin) sqlNode, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 153                 break;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 154             case AS:</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 155                 SqlNode info = ((SqlBasicCall) sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 156                 if (info.getKind() != IDENTIFIER) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 157                     checkAndReplaceMultiJoin(info, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 158                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 159                 break;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 160             case UNION:</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 161                 SqlNode unionLeft = ((SqlBasicCall) sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 162                 SqlNode unionRight = ((SqlBasicCall) sqlNode).getOperands()[1];</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 163                 checkAndReplaceMultiJoin(unionLeft, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 164                 checkAndReplaceMultiJoin(unionRight, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 165                 break;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 166             default:</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 167                 break;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 168         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 169     }</span>
 170 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 171 
 172     /**
 173      *  解析 sql 根据维表 join关系重新组装新的sql
 174      * @param sqlNode
 175      * @param sideTableSet
 176      * @param queueInfo
 177      * @param parentWhere
 178      * @param parentSelectList
 179      * @return
 180      */
 181     public Object parseSql(SqlNode sqlNode,
 182                            Set&lt;String&gt; sideTableSet,
 183                            Queue&lt;Object&gt; queueInfo,
 184                            SqlNode parentWhere,
 185                            SqlNodeList parentSelectList,
 186                            SqlNodeList parentGroupByList){
 187         SqlKind sqlKind = sqlNode.getKind();
 188         switch (sqlKind){
 189             case WITH: {
 190                 SqlWith sqlWith = (SqlWith) sqlNode;
 191                 SqlNodeList sqlNodeList = sqlWith.withList;
 192                 for (SqlNode withAsTable : sqlNodeList) {
 193                     SqlWithItem sqlWithItem = (SqlWithItem) withAsTable;
<abbr title=" 194                     parseSql(sqlWithItem.query, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 194                     parseSql(sqlWithItem.query, sideTableSet, queueInfo, parentWhere, parentSelectList, p🔵</abbr>
 195                     queueInfo.add(sqlWithItem);
 196                 }
<abbr title=" 197                 parseSql(sqlWith.body, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 197                 parseSql(sqlWith.body, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGrou🔵</abbr>
 198                 break;
 199             }
 200             case INSERT:
 201                 SqlNode sqlSource = ((SqlInsert)sqlNode).getSource();
<abbr title=" 202                 return parseSql(sqlSource, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 202                 return parseSql(sqlSource, sideTableSet, queueInfo, parentWhere, parentSelectList, parent🔵</abbr>
 203             case SELECT:
 204                 SqlNode sqlFrom = ((SqlSelect)sqlNode).getFrom();
 205                 SqlNode sqlWhere = ((SqlSelect)sqlNode).getWhere();
 206                 SqlNodeList selectList = ((SqlSelect)sqlNode).getSelectList();
 207                 SqlNodeList groupByList = ((SqlSelect) sqlNode).getGroup();
 208 
 209                 if(sqlFrom.getKind() != IDENTIFIER){
<abbr title=" 210                     Object result = parseSql(sqlFrom, sideTableSet, queueInfo, sqlWhere, selectList, groupByList);"> 210                     Object result = parseSql(sqlFrom, sideTableSet, queueInfo, sqlWhere, selectList, grou🔵</abbr>
 211                     if(result instanceof JoinInfo){
<abbr title=" 212                         return TableUtils.dealSelectResultWithJoinInfo((JoinInfo) result, (SqlSelect) sqlNode, queueInfo);"> 212                         return TableUtils.dealSelectResultWithJoinInfo((JoinInfo) result, (SqlSelect) sql🔵</abbr>
 213                     }else if(result instanceof AliasInfo){
 214                         String tableName = ((AliasInfo) result).getName();
 215                         if(sideTableSet.contains(tableName)){
 216                             throw new RuntimeException(&quot;side-table must be used in join operator&quot;);
 217                         }
 218                     }
 219                 }else{
 220                     String tableName = ((SqlIdentifier)sqlFrom).getSimple();
 221                     if(sideTableSet.contains(tableName)){
 222                         throw new RuntimeException(&quot;side-table must be used in join operator&quot;);
 223                     }
 224                 }
 225                 break;
 226             case JOIN:
 227                 JoinNodeDealer joinNodeDealer = new JoinNodeDealer(this);
 228                 Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet = Sets.newHashSet();
 229                 Map&lt;String, String&gt; tableRef = Maps.newHashMap();
 230                 Map&lt;String, String&gt; fieldRef = Maps.newHashMap();
 231                 return joinNodeDealer.dealJoinNode((SqlJoin) sqlNode, sideTableSet, queueInfo,
<abbr title=" 232                         parentWhere, parentSelectList, parentGroupByList, joinFieldSet, tableRef, fieldRef);"> 232                         parentWhere, parentSelectList, parentGroupByList, joinFieldSet, tableRef, fieldRe🔵</abbr>
 233             case AS:
 234                 SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 235                 SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 236                 String infoStr = &quot;&quot;;
 237 
 238                 if(info.getKind() == IDENTIFIER){
 239                     infoStr = info.toString();
 240                 } else {
<abbr title=" 241                     infoStr = parseSql(info, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList).toString();"> 241                     infoStr = parseSql(info, sideTableSet, queueInfo, parentWhere, parentSelectList, pare🔵</abbr>
 242                 }
 243 
 244                 AliasInfo aliasInfo = new AliasInfo();
 245                 aliasInfo.setName(infoStr);
 246                 aliasInfo.setAlias(alias.toString());
 247 
 248                 return aliasInfo;
 249 
 250             case UNION:
 251                 SqlNode unionLeft = ((SqlBasicCall)sqlNode).getOperands()[0];
 252                 SqlNode unionRight = ((SqlBasicCall)sqlNode).getOperands()[1];
 253 
<abbr title=" 254                 parseSql(unionLeft, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 254                 parseSql(unionLeft, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupBy🔵</abbr>
<abbr title=" 255                 parseSql(unionRight, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 255                 parseSql(unionRight, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupB🔵</abbr>
 256                 break;
 257             case ORDER_BY:
 258                 SqlOrderBy sqlOrderBy  = (SqlOrderBy) sqlNode;
 259 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 260                 parseSql(sqlOrderBy.query, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 260                 parseSql(sqlOrderBy.query, sideTableSet, queueInfo, parentWhere, parentSelectList, parent🔵</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 261 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 262             case LITERAL:</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 263                 return LITERAL.toString();</span>
 264 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 265                 }else{</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 266                     String tableName = ((SqlIdentifier)sqlFrom).getSimple();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 267                     if(sideTableSet.contains(tableName)){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 268                         throw new RuntimeException(&quot;side-table must be used in join operator&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 269                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 270                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 271                 break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 272             case JOIN:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 273                 JoinNodeDealer joinNodeDealer = new JoinNodeDealer(this);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 274                 Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet = Sets.newHashSet();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 275                 Map&lt;String, String&gt; tableRef = Maps.newHashMap();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 276                 return joinNodeDealer.dealJoinNode((SqlJoin) sqlNode, sideTableSet, queueInfo, parentWhere, parentSelectList, joinFieldSet, tableRef);"> 276                 return joinNodeDealer.dealJoinNode((SqlJoin) sqlNode, sideTableSet, queueInfo, parentWher🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 277             case AS:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 278                 SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 279                 SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 280                 String infoStr = &quot;&quot;;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 281 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 282                 if(info.getKind() == IDENTIFIER){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 283                     infoStr = info.toString();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 284                 } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 285                     infoStr = parseSql(info, sideTableSet, queueInfo, parentWhere, parentSelectList).toString();"> 285                     infoStr = parseSql(info, sideTableSet, queueInfo, parentWhere, parentSelectList).toSt🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 286                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 287 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 288                 AliasInfo aliasInfo = new AliasInfo();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 289                 aliasInfo.setName(infoStr);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 290                 aliasInfo.setAlias(alias.toString());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 291 </span>
 292 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 293                 parseSql(sqlOrderBy.query, sideTableSet, queueInfo, parentWhere, parentSelectList);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 294             default:</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 295                 break;</span>
 296 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 297         }
 298         return &quot;&quot;;
 299     }
 300 
 301 
 302 
 303 
 304     public void setLocalTableCache(Map&lt;String, Table&gt; localTableCache) {
 305         this.localTableCache = localTableCache;
 306     }
 307 
 308 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.side;
  22 
  23 import com.dtstack.flink.sql.parser.FlinkPlanner;
  24 import com.dtstack.flink.sql.util.TableUtils;
  25 import com.google.common.collect.Maps;
  26 import com.google.common.collect.Queues;
  27 import com.google.common.collect.Sets;
  28 import org.apache.calcite.sql.SqlBasicCall;
  29 import org.apache.calcite.sql.SqlIdentifier;
  30 import org.apache.calcite.sql.SqlInsert;
  31 import org.apache.calcite.sql.SqlJoin;
  32 import org.apache.calcite.sql.SqlKind;
  33 import org.apache.calcite.sql.SqlNode;
  34 import org.apache.calcite.sql.SqlNodeList;
  35 import org.apache.calcite.sql.SqlOrderBy;
  36 import org.apache.calcite.sql.SqlSelect;
  37 import org.apache.calcite.sql.SqlWith;
  38 import org.apache.calcite.sql.SqlWithItem;
  39 import org.apache.calcite.sql.parser.SqlParseException;
  40 import org.apache.flink.api.java.tuple.Tuple2;
  41 import org.apache.flink.table.api.Table;
  42 import org.apache.flink.table.calcite.FlinkPlannerImpl;
  43 import org.slf4j.Logger;
  44 import org.slf4j.LoggerFactory;
  45 
  46 import java.util.Map;
  47 import java.util.Queue;
  48 import java.util.Set;
  49 
  50 import static org.apache.calcite.sql.SqlKind.IDENTIFIER;
  51 
  52 /**
  53  * Parsing sql, obtain execution information dimension table
  54  * Date: 2018/7/24
  55  * Company: www.dtstack.com
  56  * @author xuchao
  57  */
  58 
  59 public class SideSQLParser {
  60     private static final Logger LOG = LoggerFactory.getLogger(SideSQLParser.class);
  61 
  62     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  63 
  64     public Queue&lt;Object&gt; getExeQueue(String exeSql, Set&lt;String&gt; sideTableSet) throws SqlParseException {
  65         LOG.info(&quot;----------exec original Sql----------&quot;);
  66         LOG.info(exeSql);
  67 
  68         Queue&lt;Object&gt; queueInfo = Queues.newLinkedBlockingQueue();
  69         FlinkPlannerImpl flinkPlanner = FlinkPlanner.getFlinkPlanner();
  70         SqlNode sqlNode = flinkPlanner.parse(exeSql);
  71 
  72         parseSql(sqlNode, sideTableSet, queueInfo, null, null, null);
  73         queueInfo.offer(sqlNode);
  74         return queueInfo;
  75     }
  76 
  77 
  78     /**
  79      *  解析 sql 根据维表 join关系重新组装新的sql
  80      * @param sqlNode
  81      * @param sideTableSet
  82      * @param queueInfo
  83      * @param parentWhere
  84      * @param parentSelectList
  85      * @return
  86      */
  87     public Object parseSql(SqlNode sqlNode,
  88                            Set&lt;String&gt; sideTableSet,
  89                            Queue&lt;Object&gt; queueInfo,
  90                            SqlNode parentWhere,
  91                            SqlNodeList parentSelectList,
  92                            SqlNodeList parentGroupByList){
  93         SqlKind sqlKind = sqlNode.getKind();
  94         switch (sqlKind){
  95             case WITH: {
  96                 SqlWith sqlWith = (SqlWith) sqlNode;
  97                 SqlNodeList sqlNodeList = sqlWith.withList;
  98                 for (SqlNode withAsTable : sqlNodeList) {
  99                     SqlWithItem sqlWithItem = (SqlWithItem) withAsTable;
<abbr title=" 100                     parseSql(sqlWithItem.query, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 100                     parseSql(sqlWithItem.query, sideTableSet, queueInfo, parentWhere, parentSelectList, p🔵</abbr>
 101                     queueInfo.add(sqlWithItem);
 102                 }
<abbr title=" 103                 parseSql(sqlWith.body, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 103                 parseSql(sqlWith.body, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGrou🔵</abbr>
 104                 break;
 105             }
 106             case INSERT:
 107                 SqlNode sqlSource = ((SqlInsert)sqlNode).getSource();
<abbr title=" 108                 return parseSql(sqlSource, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 108                 return parseSql(sqlSource, sideTableSet, queueInfo, parentWhere, parentSelectList, parent🔵</abbr>
 109             case SELECT:
 110                 SqlNode sqlFrom = ((SqlSelect)sqlNode).getFrom();
 111                 SqlNode sqlWhere = ((SqlSelect)sqlNode).getWhere();
 112                 SqlNodeList selectList = ((SqlSelect)sqlNode).getSelectList();
 113                 SqlNodeList groupByList = ((SqlSelect) sqlNode).getGroup();
 114 
 115                 if(sqlFrom.getKind() != IDENTIFIER){
<abbr title=" 116                     Object result = parseSql(sqlFrom, sideTableSet, queueInfo, sqlWhere, selectList, groupByList);"> 116                     Object result = parseSql(sqlFrom, sideTableSet, queueInfo, sqlWhere, selectList, grou🔵</abbr>
 117                     if(result instanceof JoinInfo){
<abbr title=" 118                         return TableUtils.dealSelectResultWithJoinInfo((JoinInfo) result, (SqlSelect) sqlNode, queueInfo);"> 118                         return TableUtils.dealSelectResultWithJoinInfo((JoinInfo) result, (SqlSelect) sql🔵</abbr>
 119                     }else if(result instanceof AliasInfo){
 120                         String tableName = ((AliasInfo) result).getName();
 121                         if(sideTableSet.contains(tableName)){
 122                             throw new RuntimeException(&quot;side-table must be used in join operator&quot;);
 123                         }
 124                     }
 125                 }else{
 126                     String tableName = ((SqlIdentifier)sqlFrom).getSimple();
 127                     if(sideTableSet.contains(tableName)){
 128                         throw new RuntimeException(&quot;side-table must be used in join operator&quot;);
 129                     }
 130                 }
 131                 break;
 132             case JOIN:
 133                 JoinNodeDealer joinNodeDealer = new JoinNodeDealer(this);
 134                 Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet = Sets.newHashSet();
 135                 Map&lt;String, String&gt; tableRef = Maps.newHashMap();
 136                 Map&lt;String, String&gt; fieldRef = Maps.newHashMap();
 137                 return joinNodeDealer.dealJoinNode((SqlJoin) sqlNode, sideTableSet, queueInfo,
<abbr title=" 138                         parentWhere, parentSelectList, parentGroupByList, joinFieldSet, tableRef, fieldRef);"> 138                         parentWhere, parentSelectList, parentGroupByList, joinFieldSet, tableRef, fieldRe🔵</abbr>
 139             case AS:
 140                 SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 141                 SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 142                 String infoStr = &quot;&quot;;
 143 
 144                 if(info.getKind() == IDENTIFIER){
 145                     infoStr = info.toString();
 146                 } else {
<abbr title=" 147                     infoStr = parseSql(info, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList).toString();"> 147                     infoStr = parseSql(info, sideTableSet, queueInfo, parentWhere, parentSelectList, pare🔵</abbr>
 148                 }
 149 
 150                 AliasInfo aliasInfo = new AliasInfo();
 151                 aliasInfo.setName(infoStr);
 152                 aliasInfo.setAlias(alias.toString());
 153 
 154                 return aliasInfo;
 155 
 156             case UNION:
 157                 SqlNode unionLeft = ((SqlBasicCall)sqlNode).getOperands()[0];
 158                 SqlNode unionRight = ((SqlBasicCall)sqlNode).getOperands()[1];
 159 
<abbr title=" 160                 parseSql(unionLeft, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 160                 parseSql(unionLeft, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupBy🔵</abbr>
<abbr title=" 161                 parseSql(unionRight, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 161                 parseSql(unionRight, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupB🔵</abbr>
 162                 break;
 163             case ORDER_BY:
 164                 SqlOrderBy sqlOrderBy  = (SqlOrderBy) sqlNode;
 165 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 166                 parseSql(sqlOrderBy.query, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 166                 parseSql(sqlOrderBy.query, sideTableSet, queueInfo, parentWhere, parentSelectList, parent🔵</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 167 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 168             case LITERAL:</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 169                 return LITERAL.toString();</span>
 170 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 171                 parseSql(sqlOrderBy.query, sideTableSet, queueInfo, parentWhere, parentSelectList);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 172         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 173         return &quot;&quot;;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 174     }</span>
 175 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 176                 parseSql(sqlOrderBy.query, sideTableSet, queueInfo, parentWhere, parentSelectList);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 177             default:</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 178                 break;</span>
 179 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 180         }
 181         return &quot;&quot;;
 182     }
 183 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
 184 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 185 private void checkAndReplaceMultiJoin(SqlNode sqlNode, Set&lt;String&gt; sideTableSet) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 186         SqlKind sqlKind = sqlNode.getKind();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 187         switch (sqlKind) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 188             case WITH: {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 189                 SqlWith sqlWith = (SqlWith) sqlNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 190                 SqlNodeList sqlNodeList = sqlWith.withList;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 191                 for (SqlNode withAsTable : sqlNodeList) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 192                     SqlWithItem sqlWithItem = (SqlWithItem) withAsTable;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 193                     checkAndReplaceMultiJoin(sqlWithItem.query, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 194                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 195                 checkAndReplaceMultiJoin(sqlWith.body, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 196                 break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 197             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 198             case INSERT:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 199                 SqlNode sqlSource = ((SqlInsert) sqlNode).getSource();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 200                 checkAndReplaceMultiJoin(sqlSource, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 201                 break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 202             case SELECT:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 203                 SqlNode sqlFrom = ((SqlSelect) sqlNode).getFrom();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 204                 if (sqlFrom.getKind() != IDENTIFIER) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 205                     checkAndReplaceMultiJoin(sqlFrom, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 206                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 207                 break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 208             case JOIN:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 209                 convertSideJoinToNewQuery((SqlJoin) sqlNode, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 210                 break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 211             case AS:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 212                 SqlNode info = ((SqlBasicCall) sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 213                 if (info.getKind() != IDENTIFIER) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 214                     checkAndReplaceMultiJoin(info, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 215                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 216                 break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 217             case UNION:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 218                 SqlNode unionLeft = ((SqlBasicCall) sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 219                 SqlNode unionRight = ((SqlBasicCall) sqlNode).getOperands()[1];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 220                 checkAndReplaceMultiJoin(unionLeft, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 221                 checkAndReplaceMultiJoin(unionRight, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 222                 break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 223         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 224     }</span>
 225 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 226 private void checkAndReplaceMultiJoin(SqlNode sqlNode, Set&lt;String&gt; sideTableSet) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 227         SqlKind sqlKind = sqlNode.getKind();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 228         switch (sqlKind) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 229             case WITH: {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 230                 SqlWith sqlWith = (SqlWith) sqlNode;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 231                 SqlNodeList sqlNodeList = sqlWith.withList;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 232                 for (SqlNode withAsTable : sqlNodeList) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 233                     SqlWithItem sqlWithItem = (SqlWithItem) withAsTable;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 234                     checkAndReplaceMultiJoin(sqlWithItem.query, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 235                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 236                 checkAndReplaceMultiJoin(sqlWith.body, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 237                 break;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 238             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 239             case INSERT:</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 240                 SqlNode sqlSource = ((SqlInsert) sqlNode).getSource();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 241                 checkAndReplaceMultiJoin(sqlSource, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 242                 break;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 243             case SELECT:</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 244                 SqlNode sqlFrom = ((SqlSelect) sqlNode).getFrom();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 245                 if (sqlFrom.getKind() != IDENTIFIER) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 246                     checkAndReplaceMultiJoin(sqlFrom, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 247                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 248                 break;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 249             case JOIN:</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 250                 convertSideJoinToNewQuery((SqlJoin) sqlNode, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 251                 break;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 252             case AS:</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 253                 SqlNode info = ((SqlBasicCall) sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 254                 if (info.getKind() != IDENTIFIER) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 255                     checkAndReplaceMultiJoin(info, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 256                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 257                 break;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 258             case UNION:</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 259                 SqlNode unionLeft = ((SqlBasicCall) sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 260                 SqlNode unionRight = ((SqlBasicCall) sqlNode).getOperands()[1];</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 261                 checkAndReplaceMultiJoin(unionLeft, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 262                 checkAndReplaceMultiJoin(unionRight, sideTableSet);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 263                 break;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 264             default:</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 265                 break;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 266         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 267     }</span>
 268 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 269 
 270 
 271 
 272 
 273 
 274     public void setLocalTableCache(Map&lt;String, Table&gt; localTableCache) {
 275         this.localTableCache = localTableCache;
 276     }
 277 
 278 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side;
  19 
  20 import com.dtstack.flink.sql.parser.FlinkPlanner;
  21 import com.dtstack.flink.sql.util.TableUtils;
  22 import com.google.common.collect.Maps;
  23 import com.google.common.collect.Queues;
  24 import com.google.common.collect.Sets;
  25 import java.util.Map;
  26 import java.util.Queue;
  27 import java.util.Set;
  28 import org.apache.calcite.sql.SqlBasicCall;
  29 import org.apache.calcite.sql.SqlIdentifier;
  30 import org.apache.calcite.sql.SqlInsert;
  31 import org.apache.calcite.sql.SqlJoin;
  32 import org.apache.calcite.sql.SqlKind;
  33 import org.apache.calcite.sql.SqlNode;
  34 import org.apache.calcite.sql.SqlNodeList;
  35 import org.apache.calcite.sql.SqlOrderBy;
  36 import org.apache.calcite.sql.SqlSelect;
  37 import org.apache.calcite.sql.SqlWith;
  38 import org.apache.calcite.sql.SqlWithItem;
  39 import org.apache.calcite.sql.parser.SqlParseException;
  40 import org.apache.flink.api.java.tuple.Tuple2;
  41 import org.apache.flink.table.api.Table;
  42 import org.apache.flink.table.calcite.FlinkPlannerImpl;
  43 import org.slf4j.Logger;
  44 import org.slf4j.LoggerFactory;
  45 import static org.apache.calcite.sql.SqlKind.IDENTIFIER;
  46 
  47 
  48 /**
  49  * Parsing sql, obtain execution information dimension table
  50  * Date: 2018/7/24
  51  * Company: www.dtstack.com
  52  * @author xuchao
  53  */
  54 public class SideSQLParser {
  55     private static final Logger LOG = LoggerFactory.getLogger(SideSQLParser.class);
  56 
  57     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  58 
  59     public Queue&lt;Object&gt; getExeQueue(String exeSql, Set&lt;String&gt; sideTableSet) throws SqlParseException {
  60         LOG.info(&quot;----------exec original Sql----------&quot;);
  61         LOG.info(exeSql);
  62         Queue&lt;Object&gt; queueInfo = Queues.newLinkedBlockingQueue();
  63         FlinkPlannerImpl flinkPlanner = FlinkPlanner.getFlinkPlanner();
  64         SqlNode sqlNode = flinkPlanner.parse(exeSql);
  65         parseSql(sqlNode, sideTableSet, queueInfo, null, null, null);
  66         queueInfo.offer(sqlNode);
  67         return queueInfo;
  68     }
  69 
  70     /**
  71      *  解析 sql 根据维表 join关系重新组装新的sql
  72      * @param sqlNode
  73      * @param sideTableSet
  74      * @param queueInfo
  75      * @param parentWhere
  76      * @param parentSelectList
  77      * @return
  78      */
<abbr title="  79     public Object parseSql(SqlNode sqlNode, Set&lt;String&gt; sideTableSet, Queue&lt;Object&gt; queueInfo, SqlNode parentWhere, SqlNodeList parentSelectList, SqlNodeList parentGroupByList) {">  79     public Object parseSql(SqlNode sqlNode, Set&lt;String&gt; sideTableSet, Queue&lt;Object&gt; queueInfo, SqlNode pa🔵</abbr>
  80         SqlKind sqlKind = sqlNode.getKind();
  81         switch (sqlKind) {
  82             case WITH :
  83                 {
  84                     SqlWith sqlWith = ((SqlWith) (sqlNode));
  85                     SqlNodeList sqlNodeList = sqlWith.withList;
  86                     for (SqlNode withAsTable : sqlNodeList) {
  87                         SqlWithItem sqlWithItem = ((SqlWithItem) (withAsTable));
<abbr title="  88                         parseSql(sqlWithItem.query, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);">  88                         parseSql(sqlWithItem.query, sideTableSet, queueInfo, parentWhere, parentSelectLis🔵</abbr>
  89                         queueInfo.add(sqlWithItem);
  90                     }
<abbr title="  91                     parseSql(sqlWith.body, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);">  91                     parseSql(sqlWith.body, sideTableSet, queueInfo, parentWhere, parentSelectList, parent🔵</abbr>
  92                     break;
  93                 }
  94             case INSERT :
  95                 SqlNode sqlSource = ((SqlInsert) (sqlNode)).getSource();
<abbr title="  96                 return parseSql(sqlSource, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);">  96                 return parseSql(sqlSource, sideTableSet, queueInfo, parentWhere, parentSelectList, parent🔵</abbr>
  97             case SELECT :
  98                 SqlNode sqlFrom = ((SqlSelect) (sqlNode)).getFrom();
  99                 SqlNode sqlWhere = ((SqlSelect) (sqlNode)).getWhere();
 100                 SqlNodeList selectList = ((SqlSelect) (sqlNode)).getSelectList();
 101                 SqlNodeList groupByList = ((SqlSelect) (sqlNode)).getGroup();
 102                 if (sqlFrom.getKind() != IDENTIFIER) {
<abbr title=" 103                     Object result = parseSql(sqlFrom, sideTableSet, queueInfo, sqlWhere, selectList, groupByList);"> 103                     Object result = parseSql(sqlFrom, sideTableSet, queueInfo, sqlWhere, selectList, grou🔵</abbr>
 104                     if (result instanceof JoinInfo) {
<abbr title=" 105                         return TableUtils.dealSelectResultWithJoinInfo(((JoinInfo) (result)), ((SqlSelect) (sqlNode)), queueInfo);"> 105                         return TableUtils.dealSelectResultWithJoinInfo(((JoinInfo) (result)), ((SqlSelect🔵</abbr>
 106                     } else if (result instanceof AliasInfo) {
 107                         String tableName = ((AliasInfo) (result)).getName();
 108                         if (sideTableSet.contains(tableName)) {
 109                             throw new RuntimeException(&quot;side-table must be used in join operator&quot;);
 110                         }
 111                     }
 112                 } else {
 113                     String tableName = ((SqlIdentifier) (sqlFrom)).getSimple();
 114                     if (sideTableSet.contains(tableName)) {
 115                         throw new RuntimeException(&quot;side-table must be used in join operator&quot;);
 116                     }
 117                 }
 118                 break;
 119             case JOIN :
 120                 JoinNodeDealer joinNodeDealer = new JoinNodeDealer(this);
 121                 Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet = Sets.newHashSet();
 122                 Map&lt;String, String&gt; tableRef = Maps.newHashMap();
 123                 Map&lt;String, String&gt; fieldRef = Maps.newHashMap();
<abbr title=" 124                 return joinNodeDealer.dealJoinNode(((SqlJoin) (sqlNode)), sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList, joinFieldSet, tableRef, fieldRef);"> 124                 return joinNodeDealer.dealJoinNode(((SqlJoin) (sqlNode)), sideTableSet, queueInfo, parent🔵</abbr>
 125             case AS :
 126                 SqlNode info = ((SqlBasicCall) (sqlNode)).getOperands()[0];
 127                 SqlNode alias = ((SqlBasicCall) (sqlNode)).getOperands()[1];
 128                 String infoStr = &quot;&quot;;
 129                 if (info.getKind() == IDENTIFIER) {
 130                     infoStr = info.toString();
 131                 } else {
<abbr title=" 132                     infoStr = parseSql(info, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList).toString();"> 132                     infoStr = parseSql(info, sideTableSet, queueInfo, parentWhere, parentSelectList, pare🔵</abbr>
 133                 }
 134                 AliasInfo aliasInfo = new AliasInfo();
 135                 aliasInfo.setName(infoStr);
 136                 aliasInfo.setAlias(alias.toString());
 137                 return aliasInfo;
 138             case UNION :
 139                 SqlNode unionLeft = ((SqlBasicCall) (sqlNode)).getOperands()[0];
 140                 SqlNode unionRight = ((SqlBasicCall) (sqlNode)).getOperands()[1];
<abbr title=" 141                 parseSql(unionLeft, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 141                 parseSql(unionLeft, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupBy🔵</abbr>
<abbr title=" 142                 parseSql(unionRight, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 142                 parseSql(unionRight, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupB🔵</abbr>
 143                 break;
 144             case ORDER_BY :
 145                 SqlOrderBy sqlOrderBy = ((SqlOrderBy) (sqlNode));
<abbr title=" 146                 parseSql(sqlOrderBy.query, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 146                 parseSql(sqlOrderBy.query, sideTableSet, queueInfo, parentWhere, parentSelectList, parent🔵</abbr>
 147 
 148 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 149             case LITERAL:</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 150                 return LITERAL.toString();</span>
 151 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 152 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 152 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
 153 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 154 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 155             default:</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 156                 break;</span>
 157 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 158 
 159         }
 160         return &quot;&quot;;
 161     }
 162 
 163     public void setLocalTableCache(Map&lt;String, Table&gt; localTableCache) {
 164         this.localTableCache = localTableCache;
 165     }
 166 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.side;
  22  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  23 -import com.dtstack.flink.sql.config.CalciteConfig;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  24 +import com.dtstack.flink.sql.parser.FlinkPlanner;</span>
  25  import com.dtstack.flink.sql.util.TableUtils;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  26 -import com.google.common.base.Preconditions;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  27 -import com.google.common.collect.Lists;</span>
  28  import com.google.common.collect.Maps;
  29  import com.google.common.collect.Queues;
  30  import com.google.common.collect.Sets;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  31 -import org.apache.calcite.sql.JoinType;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  32 -import org.apache.calcite.sql.SqlAsOperator;</span>
  33  import org.apache.calcite.sql.SqlBasicCall;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  34 -import org.apache.calcite.sql.SqlBinaryOperator;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  35 -import org.apache.calcite.sql.SqlDataTypeSpec;</span>
  36  import org.apache.calcite.sql.SqlIdentifier;
  37  import org.apache.calcite.sql.SqlInsert;
  38  import org.apache.calcite.sql.SqlJoin;
  39  import org.apache.calcite.sql.SqlKind;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  40 -import org.apache.calcite.sql.SqlLiteral;</span>
  41  import org.apache.calcite.sql.SqlNode;
  42  import org.apache.calcite.sql.SqlNodeList;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  43 -import org.apache.calcite.sql.SqlOperator;</span>
  44  import org.apache.calcite.sql.SqlOrderBy;
  45  import org.apache.calcite.sql.SqlSelect;
  46  import org.apache.calcite.sql.SqlWith;
  47  import org.apache.calcite.sql.SqlWithItem;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  48 -import org.apache.calcite.sql.fun.SqlCase;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  49 -import org.apache.calcite.sql.fun.SqlStdOperatorTable;</span>
  50  import org.apache.calcite.sql.parser.SqlParseException;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  51 -import org.apache.calcite.sql.parser.SqlParser;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  52 -import org.apache.calcite.sql.parser.SqlParserPos;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  53 -import org.apache.commons.collections.CollectionUtils;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  54 -import org.apache.commons.lang3.StringUtils;</span>
  55  import org.apache.flink.api.java.tuple.Tuple2;
  56  import org.apache.flink.table.api.Table;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  57 +import org.apache.flink.table.calcite.FlinkPlannerImpl;</span>
  58  import org.slf4j.Logger;
  59  import org.slf4j.LoggerFactory;
  60  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  61 -import java.util.List;</span>
  62  import java.util.Map;
  63  import java.util.Queue;
  64  import java.util.Set;
  65  
  66  import static org.apache.calcite.sql.SqlKind.*;

  67  
  68  /**
  69   * Parsing sql, obtain execution information dimension table
  70   * Date: 2018/7/24
  71   * Company: www.dtstack.com
  72   * @author xuchao
  73   */
  74  
  75  public class SideSQLParser {
  76      private static final Logger LOG = LoggerFactory.getLogger(SideSQLParser.class);
  77  
  78      private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  79  
  80      public Queue&lt;Object&gt; getExeQueue(String exeSql, Set&lt;String&gt; sideTableSet) throws SqlParseException {
  81          System.out.println(&quot;----------exec original Sql----------&quot;);
  82          System.out.println(exeSql);
  83          LOG.info(&quot;----------exec original Sql----------&quot;);
  84          LOG.info(exeSql);
  85  
  86          Queue&lt;Object&gt; queueInfo = Queues.newLinkedBlockingQueue();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  87 -        SqlParser sqlParser = SqlParser.create(exeSql, CalciteConfig.MYSQL_LEX_CONFIG);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  88 -        SqlNode sqlNode = sqlParser.parseStmt();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  89 +        FlinkPlannerImpl flinkPlanner = FlinkPlanner.getFlinkPlanner();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  90 +        SqlNode sqlNode = flinkPlanner.parse(exeSql);</span>
  91  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  92 -        parseSql(sqlNode, sideTableSet, queueInfo, null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  93 +        parseSql(sqlNode, sideTableSet, queueInfo, null, null, null);</span>
  94          queueInfo.offer(sqlNode);
  95          return queueInfo;
  96      }
  97  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  98 -    private void checkAndReplaceMultiJoin(SqlNode sqlNode, Set&lt;String&gt; sideTableSet) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  99 -        SqlKind sqlKind = sqlNode.getKind();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 100 -        switch (sqlKind) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 101 -            case WITH: {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 102 -                SqlWith sqlWith = (SqlWith) sqlNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 103 -                SqlNodeList sqlNodeList = sqlWith.withList;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 104 -                for (SqlNode withAsTable : sqlNodeList) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 105 -                    SqlWithItem sqlWithItem = (SqlWithItem) withAsTable;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 106 -                    checkAndReplaceMultiJoin(sqlWithItem.query, sideTableSet);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 107 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 108 -                checkAndReplaceMultiJoin(sqlWith.body, sideTableSet);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 109 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 110 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 111 -            case INSERT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 112 -                SqlNode sqlSource = ((SqlInsert) sqlNode).getSource();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 113 -                checkAndReplaceMultiJoin(sqlSource, sideTableSet);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 114 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 115 -            case SELECT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 116 -                SqlNode sqlFrom = ((SqlSelect) sqlNode).getFrom();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 117 -                if (sqlFrom.getKind() != IDENTIFIER) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 118 -                    checkAndReplaceMultiJoin(sqlFrom, sideTableSet);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 119 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 120 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 121 -            case JOIN:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 122 -                convertSideJoinToNewQuery((SqlJoin) sqlNode, sideTableSet);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 123 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 124 -            case AS:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 125 -                SqlNode info = ((SqlBasicCall) sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 126 -                if (info.getKind() != IDENTIFIER) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 127 -                    checkAndReplaceMultiJoin(info, sideTableSet);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 128 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 129 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 130 -            case UNION:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 131 -                SqlNode unionLeft = ((SqlBasicCall) sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 132 -                SqlNode unionRight = ((SqlBasicCall) sqlNode).getOperands()[1];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 133 -                checkAndReplaceMultiJoin(unionLeft, sideTableSet);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 134 -                checkAndReplaceMultiJoin(unionRight, sideTableSet);</span>


<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 135 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 136 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 137 -    }</span>
 138  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 139 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 140 -    public Object parseSql(SqlNode sqlNode, Set&lt;String&gt; sideTableSet, Queue&lt;Object&gt; queueInfo, SqlNode parentWhere, SqlNodeList parentSelectList){"> 140 -    public Object parseSql(SqlNode sqlNode, Set&lt;String&gt; sideTableSet, Queue&lt;Object&gt; queueInfo, SqlNode parentWhere🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 141 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 142 +     *  解析 sql 根据维表 join关系重新组装新的sql</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 143 +     * @param sqlNode</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 144 +     * @param sideTableSet</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 145 +     * @param queueInfo</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 146 +     * @param parentWhere</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 147 +     * @param parentSelectList</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 148 +     * @return</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 149 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 150 +    public Object parseSql(SqlNode sqlNode,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 151 +                           Set&lt;String&gt; sideTableSet,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 152 +                           Queue&lt;Object&gt; queueInfo,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 153 +                           SqlNode parentWhere,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 154 +                           SqlNodeList parentSelectList,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 155 +                           SqlNodeList parentGroupByList){</span>
 156          SqlKind sqlKind = sqlNode.getKind();
 157          switch (sqlKind){
 158              case WITH: {
 159                  SqlWith sqlWith = (SqlWith) sqlNode;
 160                  SqlNodeList sqlNodeList = sqlWith.withList;
 161                  for (SqlNode withAsTable : sqlNodeList) {
 162                      SqlWithItem sqlWithItem = (SqlWithItem) withAsTable;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 163 -                    parseSql(sqlWithItem.query, sideTableSet, queueInfo, parentWhere, parentSelectList);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 164 +                    parseSql(sqlWithItem.query, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 164 +                    parseSql(sqlWithItem.query, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGrou🔵</abbr></span>
 165                      queueInfo.add(sqlWithItem);
 166                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 167 -                parseSql(sqlWith.body, sideTableSet, queueInfo, parentWhere, parentSelectList);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 168 +                parseSql(sqlWith.body, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);</span>
 169                  break;
 170              }
 171              case INSERT:
 172                  SqlNode sqlSource = ((SqlInsert)sqlNode).getSource();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 173 -                return parseSql(sqlSource, sideTableSet, queueInfo, parentWhere, parentSelectList);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 174 +                return parseSql(sqlSource, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 174 +                return parseSql(sqlSource, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByLi🔵</abbr></span>
 175              case SELECT:
 176                  SqlNode sqlFrom = ((SqlSelect)sqlNode).getFrom();
 177                  SqlNode sqlWhere = ((SqlSelect)sqlNode).getWhere();
 178                  SqlNodeList selectList = ((SqlSelect)sqlNode).getSelectList();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 179 +                SqlNodeList groupByList = ((SqlSelect) sqlNode).getGroup();</span>
 180  
 181                  if(sqlFrom.getKind() != IDENTIFIER){
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 182 -                    Object result = parseSql(sqlFrom, sideTableSet, queueInfo, sqlWhere, selectList);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 183 +                    Object result = parseSql(sqlFrom, sideTableSet, queueInfo, sqlWhere, selectList, groupByList);</span>
 184                      if(result instanceof JoinInfo){
<abbr title=" 185                          return TableUtils.dealSelectResultWithJoinInfo((JoinInfo) result, (SqlSelect) sqlNode, queueInfo);"> 185                          return TableUtils.dealSelectResultWithJoinInfo((JoinInfo) result, (SqlSelect) sqlNode, que🔵</abbr>
 186                      }else if(result instanceof AliasInfo){
 187                          String tableName = ((AliasInfo) result).getName();
 188                          if(sideTableSet.contains(tableName)){
 189                              throw new RuntimeException(&quot;side-table must be used in join operator&quot;);
 190                          }
 191                      }
 192                  }else{
 193                      String tableName = ((SqlIdentifier)sqlFrom).getSimple();
 194                      if(sideTableSet.contains(tableName)){
 195                          throw new RuntimeException(&quot;side-table must be used in join operator&quot;);
 196                      }
 197                  }
 198                  break;
 199              case JOIN:
 200                  JoinNodeDealer joinNodeDealer = new JoinNodeDealer(this);
 201                  Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet = Sets.newHashSet();
 202                  Map&lt;String, String&gt; tableRef = Maps.newHashMap();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 203 -                return joinNodeDealer.dealJoinNode((SqlJoin) sqlNode, sideTableSet, queueInfo, parentWhere, parentSelectList, joinFieldSet, tableRef);"> 203 -                return joinNodeDealer.dealJoinNode((SqlJoin) sqlNode, sideTableSet, queueInfo, parentWhere, parent🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 204 +                Map&lt;String, String&gt; fieldRef = Maps.newHashMap();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 205 +                return joinNodeDealer.dealJoinNode((SqlJoin) sqlNode, sideTableSet, queueInfo,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 206 +                        parentWhere, parentSelectList, parentGroupByList, joinFieldSet, tableRef, fieldRef);</span>
 207              case AS:
 208                  SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 209                  SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 210                  String infoStr = &quot;&quot;;
 211  
 212                  if(info.getKind() == IDENTIFIER){
 213                      infoStr = info.toString();
 214                  } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 215 -                    infoStr = parseSql(info, sideTableSet, queueInfo, parentWhere, parentSelectList).toString();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 216 +                    infoStr = parseSql(info, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList).toString();"> 216 +                    infoStr = parseSql(info, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupBy🔵</abbr></span>
 217                  }
 218  
 219                  AliasInfo aliasInfo = new AliasInfo();
 220                  aliasInfo.setName(infoStr);
 221                  aliasInfo.setAlias(alias.toString());
 222  
 223                  return aliasInfo;
 224  
 225              case UNION:
 226                  SqlNode unionLeft = ((SqlBasicCall)sqlNode).getOperands()[0];
 227                  SqlNode unionRight = ((SqlBasicCall)sqlNode).getOperands()[1];
 228  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 229 -                parseSql(unionLeft, sideTableSet, queueInfo, parentWhere, parentSelectList);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 230 -                parseSql(unionRight, sideTableSet, queueInfo, parentWhere, parentSelectList);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 231 +                parseSql(unionLeft, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 232 +                parseSql(unionRight, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);</span>
 233                  break;
 234              case ORDER_BY:
 235                  SqlOrderBy sqlOrderBy  = (SqlOrderBy) sqlNode;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 236 -                parseSql(sqlOrderBy.query, sideTableSet, queueInfo, parentWhere, parentSelectList);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 237 +                parseSql(sqlOrderBy.query, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 237 +                parseSql(sqlOrderBy.query, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByLi🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 238 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 239 +            case LITERAL:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 240 +                return LITERAL.toString();</span>
 241          }
 242          return &quot;&quot;;
 243      }
 244  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 245 -    private AliasInfo getSqlNodeAliasInfo(SqlNode sqlNode) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 246 -        SqlNode info = ((SqlBasicCall) sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 247 -        SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 248 -        String infoStr = info.getKind() == IDENTIFIER ? info.toString() : null;</span>
 249  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 250 -        AliasInfo aliasInfo = new AliasInfo();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 251 -        aliasInfo.setName(infoStr);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 252 -        aliasInfo.setAlias(alias.toString());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 253 -        return aliasInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 254 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 255 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 256 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 257 -     * 将和维表关联的join 替换为一个新的查询</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 258 -     * @param sqlNode</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 259 -     * @param sideTableSet</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 260 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 261 -    private void convertSideJoinToNewQuery(SqlJoin sqlNode, Set&lt;String&gt; sideTableSet) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 262 -        checkAndReplaceMultiJoin(sqlNode.getLeft(), sideTableSet);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 263 -        checkAndReplaceMultiJoin(sqlNode.getRight(), sideTableSet);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 264 -    }</span>
 265  
 266  
 267      public void setLocalTableCache(Map&lt;String, Table&gt; localTableCache) {
 268          this.localTableCache = localTableCache;
 269      }
 270  
 271  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.side;
  22  
  23  import com.dtstack.flink.sql.config.CalciteConfig;

  24  import com.dtstack.flink.sql.util.TableUtils;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  25 -import com.google.common.base.Preconditions;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  26 -import com.google.common.collect.Lists;</span>
  27  import com.google.common.collect.Maps;
  28  import com.google.common.collect.Queues;
  29  import com.google.common.collect.Sets;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  30 -import org.apache.calcite.sql.JoinType;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  31 -import org.apache.calcite.sql.SqlAsOperator;</span>
  32  import org.apache.calcite.sql.SqlBasicCall;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  33 -import org.apache.calcite.sql.SqlBinaryOperator;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  34 -import org.apache.calcite.sql.SqlDataTypeSpec;</span>
  35  import org.apache.calcite.sql.SqlIdentifier;
  36  import org.apache.calcite.sql.SqlInsert;
  37  import org.apache.calcite.sql.SqlJoin;
  38  import org.apache.calcite.sql.SqlKind;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  39 -import org.apache.calcite.sql.SqlLiteral;</span>
  40  import org.apache.calcite.sql.SqlNode;
  41  import org.apache.calcite.sql.SqlNodeList;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  42 -import org.apache.calcite.sql.SqlOperator;</span>
  43  import org.apache.calcite.sql.SqlOrderBy;
  44  import org.apache.calcite.sql.SqlSelect;
  45  import org.apache.calcite.sql.SqlWith;
  46  import org.apache.calcite.sql.SqlWithItem;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  47 -import org.apache.calcite.sql.fun.SqlCase;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  48 -import org.apache.calcite.sql.fun.SqlStdOperatorTable;</span>
  49  import org.apache.calcite.sql.parser.SqlParseException;
  50  import org.apache.calcite.sql.parser.SqlParser;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  51 -import org.apache.calcite.sql.parser.SqlParserPos;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  52 -import org.apache.commons.collections.CollectionUtils;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  53 -import org.apache.commons.lang3.StringUtils;</span>
  54  import org.apache.flink.api.java.tuple.Tuple2;
  55  import org.apache.flink.table.api.Table;

  56  import org.slf4j.Logger;
  57  import org.slf4j.LoggerFactory;
  58  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  59 -import java.util.List;</span>
  60  import java.util.Map;
  61  import java.util.Queue;
  62  import java.util.Set;
  63  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  64 -import static org.apache.calcite.sql.SqlKind.*;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  65 +import static org.apache.calcite.sql.SqlKind.IDENTIFIER;</span>
  66  
  67  /**
  68   * Parsing sql, obtain execution information dimension table
  69   * Date: 2018/7/24
  70   * Company: www.dtstack.com
  71   * @author xuchao
  72   */
  73  
  74  public class SideSQLParser {
  75      private static final Logger LOG = LoggerFactory.getLogger(SideSQLParser.class);
  76  
  77      private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  78  
  79      public Queue&lt;Object&gt; getExeQueue(String exeSql, Set&lt;String&gt; sideTableSet) throws SqlParseException {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  80 -        System.out.println(&quot;----------exec original Sql----------&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  81 -        System.out.println(exeSql);</span>
  82          LOG.info(&quot;----------exec original Sql----------&quot;);
  83          LOG.info(exeSql);
  84  
  85          Queue&lt;Object&gt; queueInfo = Queues.newLinkedBlockingQueue();
  86          SqlParser sqlParser = SqlParser.create(exeSql, CalciteConfig.MYSQL_LEX_CONFIG);
  87          SqlNode sqlNode = sqlParser.parseStmt();


  88  
  89          parseSql(sqlNode, sideTableSet, queueInfo, null, null);

  90          queueInfo.offer(sqlNode);
  91          return queueInfo;
  92      }
  93  
  94      private void checkAndReplaceMultiJoin(SqlNode sqlNode, Set&lt;String&gt; sideTableSet) {
  95          SqlKind sqlKind = sqlNode.getKind();
  96          switch (sqlKind) {
  97              case WITH: {
  98                  SqlWith sqlWith = (SqlWith) sqlNode;
  99                  SqlNodeList sqlNodeList = sqlWith.withList;
 100                  for (SqlNode withAsTable : sqlNodeList) {
 101                      SqlWithItem sqlWithItem = (SqlWithItem) withAsTable;
 102                      checkAndReplaceMultiJoin(sqlWithItem.query, sideTableSet);
 103                  }
 104                  checkAndReplaceMultiJoin(sqlWith.body, sideTableSet);
 105                  break;
 106              }
 107              case INSERT:
 108                  SqlNode sqlSource = ((SqlInsert) sqlNode).getSource();
 109                  checkAndReplaceMultiJoin(sqlSource, sideTableSet);
 110                  break;
 111              case SELECT:
 112                  SqlNode sqlFrom = ((SqlSelect) sqlNode).getFrom();
 113                  if (sqlFrom.getKind() != IDENTIFIER) {
 114                      checkAndReplaceMultiJoin(sqlFrom, sideTableSet);
 115                  }
 116                  break;
 117              case JOIN:
 118                  convertSideJoinToNewQuery((SqlJoin) sqlNode, sideTableSet);
 119                  break;
 120              case AS:
 121                  SqlNode info = ((SqlBasicCall) sqlNode).getOperands()[0];
 122                  if (info.getKind() != IDENTIFIER) {
 123                      checkAndReplaceMultiJoin(info, sideTableSet);
 124                  }
 125                  break;
 126              case UNION:
 127                  SqlNode unionLeft = ((SqlBasicCall) sqlNode).getOperands()[0];
 128                  SqlNode unionRight = ((SqlBasicCall) sqlNode).getOperands()[1];
 129                  checkAndReplaceMultiJoin(unionLeft, sideTableSet);
 130                  checkAndReplaceMultiJoin(unionRight, sideTableSet);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 131 +                break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 132 +            default:</span>
 133                  break;
 134          }
 135      }
 136  
 137  
<abbr title=" 138      public Object parseSql(SqlNode sqlNode, Set&lt;String&gt; sideTableSet, Queue&lt;Object&gt; queueInfo, SqlNode parentWhere, SqlNodeList parentSelectList){"> 138      public Object parseSql(SqlNode sqlNode, Set&lt;String&gt; sideTableSet, Queue&lt;Object&gt; queueInfo, SqlNode parentWhere🔵</abbr>















 139          SqlKind sqlKind = sqlNode.getKind();
 140          switch (sqlKind){
 141              case WITH: {
 142                  SqlWith sqlWith = (SqlWith) sqlNode;
 143                  SqlNodeList sqlNodeList = sqlWith.withList;
 144                  for (SqlNode withAsTable : sqlNodeList) {
 145                      SqlWithItem sqlWithItem = (SqlWithItem) withAsTable;
 146                      parseSql(sqlWithItem.query, sideTableSet, queueInfo, parentWhere, parentSelectList);

 147                      queueInfo.add(sqlWithItem);
 148                  }
 149                  parseSql(sqlWith.body, sideTableSet, queueInfo, parentWhere, parentSelectList);

 150                  break;
 151              }
 152              case INSERT:
 153                  SqlNode sqlSource = ((SqlInsert)sqlNode).getSource();
 154                  return parseSql(sqlSource, sideTableSet, queueInfo, parentWhere, parentSelectList);

 155              case SELECT:
 156                  SqlNode sqlFrom = ((SqlSelect)sqlNode).getFrom();
 157                  SqlNode sqlWhere = ((SqlSelect)sqlNode).getWhere();
 158                  SqlNodeList selectList = ((SqlSelect)sqlNode).getSelectList();

 159  
 160                  if(sqlFrom.getKind() != IDENTIFIER){
 161                      Object result = parseSql(sqlFrom, sideTableSet, queueInfo, sqlWhere, selectList);

 162                      if(result instanceof JoinInfo){
<abbr title=" 163                          return TableUtils.dealSelectResultWithJoinInfo((JoinInfo) result, (SqlSelect) sqlNode, queueInfo);"> 163                          return TableUtils.dealSelectResultWithJoinInfo((JoinInfo) result, (SqlSelect) sqlNode, que🔵</abbr>
 164                      }else if(result instanceof AliasInfo){
 165                          String tableName = ((AliasInfo) result).getName();
 166                          if(sideTableSet.contains(tableName)){
 167                              throw new RuntimeException(&quot;side-table must be used in join operator&quot;);
 168                          }
 169                      }
 170                  }else{
 171                      String tableName = ((SqlIdentifier)sqlFrom).getSimple();
 172                      if(sideTableSet.contains(tableName)){
 173                          throw new RuntimeException(&quot;side-table must be used in join operator&quot;);
 174                      }
 175                  }
 176                  break;
 177              case JOIN:
 178                  JoinNodeDealer joinNodeDealer = new JoinNodeDealer(this);
 179                  Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet = Sets.newHashSet();
 180                  Map&lt;String, String&gt; tableRef = Maps.newHashMap();
<abbr title=" 181                  return joinNodeDealer.dealJoinNode((SqlJoin) sqlNode, sideTableSet, queueInfo, parentWhere, parentSelectList, joinFieldSet, tableRef);"> 181                  return joinNodeDealer.dealJoinNode((SqlJoin) sqlNode, sideTableSet, queueInfo, parentWhere, parent🔵</abbr>



 182              case AS:
 183                  SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 184                  SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 185                  String infoStr = &quot;&quot;;
 186  
 187                  if(info.getKind() == IDENTIFIER){
 188                      infoStr = info.toString();
 189                  } else {
 190                      infoStr = parseSql(info, sideTableSet, queueInfo, parentWhere, parentSelectList).toString();

 191                  }
 192  
 193                  AliasInfo aliasInfo = new AliasInfo();
 194                  aliasInfo.setName(infoStr);
 195                  aliasInfo.setAlias(alias.toString());
 196  
 197                  return aliasInfo;
 198  
 199              case UNION:
 200                  SqlNode unionLeft = ((SqlBasicCall)sqlNode).getOperands()[0];
 201                  SqlNode unionRight = ((SqlBasicCall)sqlNode).getOperands()[1];
 202  
 203                  parseSql(unionLeft, sideTableSet, queueInfo, parentWhere, parentSelectList);
 204                  parseSql(unionRight, sideTableSet, queueInfo, parentWhere, parentSelectList);


 205                  break;
 206              case ORDER_BY:
 207                  SqlOrderBy sqlOrderBy  = (SqlOrderBy) sqlNode;
 208                  parseSql(sqlOrderBy.query, sideTableSet, queueInfo, parentWhere, parentSelectList);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 209 +            default:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 210 +                break;</span>


 211          }
 212          return &quot;&quot;;
 213      }
 214  
 215      private AliasInfo getSqlNodeAliasInfo(SqlNode sqlNode) {
 216          SqlNode info = ((SqlBasicCall) sqlNode).getOperands()[0];
 217          SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 218          String infoStr = info.getKind() == IDENTIFIER ? info.toString() : null;
 219  
 220          AliasInfo aliasInfo = new AliasInfo();
 221          aliasInfo.setName(infoStr);
 222          aliasInfo.setAlias(alias.toString());
 223          return aliasInfo;
 224      }
 225  
 226      /**
 227       * 将和维表关联的join 替换为一个新的查询
 228       * @param sqlNode
 229       * @param sideTableSet
 230       */
 231      private void convertSideJoinToNewQuery(SqlJoin sqlNode, Set&lt;String&gt; sideTableSet) {
 232          checkAndReplaceMultiJoin(sqlNode.getLeft(), sideTableSet);
 233          checkAndReplaceMultiJoin(sqlNode.getRight(), sideTableSet);
 234      }
 235  
 236  
 237      public void setLocalTableCache(Map&lt;String, Table&gt; localTableCache) {
 238          this.localTableCache = localTableCache;
 239      }
 240  
 241  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            