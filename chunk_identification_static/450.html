<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>450</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    450
                    <a href="449.html">prev</a>
                    <a href="451.html">next</a>
                    <a href="450_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_3f89d1e66187447b56be7b8b76e9b09af9b9850d_core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;3f89d1e66187447b56be7b8b76e9b09af9b9850d:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;3f89d1e66187447b56be7b8b76e9b09af9b9850d^1:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;3f89d1e66187447b56be7b8b76e9b09af9b9850d^2:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;b2e4085e6d35798d51707eb23aa215e0e694591e:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b], [b], [b], [bj], [bj], [b], [j], [j]], subset: [[b], [b], [b], [b], [bj], [bj], [b], [j], [j]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.side;
  22 
  23 import org.apache.flink.api.common.typeinfo.TypeInformation;
  24 import org.apache.flink.api.java.tuple.Tuple2;
  25 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  26 import org.apache.flink.streaming.api.datastream.DataStream;
  27 import org.apache.flink.table.api.StreamQueryConfig;
  28 import org.apache.flink.table.api.Table;
  29 import org.apache.flink.table.api.TableSchema;
  30 import org.apache.flink.table.api.java.StreamTableEnvironment;
  31 import org.apache.flink.table.runtime.CRowKeySelector;
  32 import org.apache.flink.table.runtime.types.CRow;
  33 import org.apache.flink.table.runtime.types.CRowTypeInfo;
  34 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  35 import org.apache.flink.types.Row;
  36 
  37 import com.dtstack.flink.sql.enums.ECacheType;
  38 import com.dtstack.flink.sql.exec.FlinkSQLExec;
  39 import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  40 import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  41 import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  42 import com.dtstack.flink.sql.util.ClassUtil;
  43 import com.dtstack.flink.sql.util.ParseUtils;
  44 import com.dtstack.flink.sql.util.TableUtils;
  45 import com.google.common.base.Preconditions;
  46 import com.google.common.collect.HashBasedTable;
  47 import com.google.common.collect.Lists;
  48 import com.google.common.collect.Maps;
  49 import com.google.common.collect.Sets;
  50 import org.apache.calcite.sql.SqlAsOperator;
  51 import org.apache.calcite.sql.SqlBasicCall;
  52 import org.apache.calcite.sql.SqlDataTypeSpec;
  53 import org.apache.calcite.sql.SqlIdentifier;
  54 import org.apache.calcite.sql.SqlInsert;
  55 import org.apache.calcite.sql.SqlJoin;
  56 import org.apache.calcite.sql.SqlKind;
  57 import org.apache.calcite.sql.SqlLiteral;
  58 import org.apache.calcite.sql.SqlNode;
  59 import org.apache.calcite.sql.SqlNodeList;
  60 import org.apache.calcite.sql.SqlOperator;
  61 import org.apache.calcite.sql.SqlOrderBy;
  62 import org.apache.calcite.sql.SqlSelect;
  63 import org.apache.calcite.sql.SqlWithItem;
  64 import org.apache.calcite.sql.fun.SqlCase;
  65 import org.apache.calcite.sql.parser.SqlParseException;
  66 import org.apache.calcite.sql.parser.SqlParserPos;
  67 import org.apache.commons.collections.CollectionUtils;
  68 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  69 import org.apache.flink.api.common.typeinfo.TypeInformation;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  70 import org.apache.flink.api.java.tuple.Tuple2;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  71 import org.apache.flink.api.java.typeutils.RowTypeInfo;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  72 import com.google.common.collect.HashBasedTable;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  73 import com.google.common.collect.Lists;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  74 import com.google.common.collect.Maps;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  75 import org.apache.flink.streaming.api.datastream.DataStream;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  76 import org.apache.flink.table.api.Table;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  77 import org.apache.flink.table.api.java.StreamTableEnvironment;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  78 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  79 import org.apache.flink.types.Row;</span>
  80 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  81 import org.apache.flink.api.common.typeinfo.TypeInformation;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  82 import org.apache.flink.api.java.tuple.Tuple2;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  83 import org.apache.flink.api.java.typeutils.RowTypeInfo;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  84 import com.google.common.collect.HashBasedTable;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  85 import com.google.common.collect.Lists;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  86 import com.google.common.collect.Maps;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  87 import org.apache.flink.streaming.api.datastream.DataStream;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  88 import org.apache.flink.table.api.StreamQueryConfig;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  89 import org.apache.flink.table.api.Table;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  90 import org.apache.flink.table.api.java.StreamTableEnvironment;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  91 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  92 import org.apache.flink.types.Row;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  93 import org.slf4j.Logger;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  94 import org.slf4j.LoggerFactory;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  95 import java.sql.Timestamp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  96 import java.util.Collection;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  97 import java.util.LinkedList;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  98 import java.util.List;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  99 import java.util.Map;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 100 import java.util.Queue;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 101 </span>
 102 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 103 import org.apache.commons.lang3.StringUtils;</span>
 104 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 105 import org.slf4j.Logger;
 106 import org.slf4j.LoggerFactory;
 107 
 108 import java.sql.Timestamp;
 109 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 110 import java.time.LocalDateTime;</span>
 111 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 112 import java.sql.Timestamp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 113 import java.util.Collection;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 114 import java.util.LinkedList;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 115 import java.util.List;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 116 import java.util.Map;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 117 import java.util.Queue;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 118 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 119 import static org.apache.calcite.sql.SqlKind.*;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 120 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 121 /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 122  * Reason:</span>
 123 =======
 124 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 125 import java.util.Arrays;
 126 import java.util.Collection;
 127 import java.util.LinkedList;
 128 import java.util.List;
 129 import java.util.Map;
 130 import java.util.Queue;
 131 import java.util.Set;
 132 
 133 import static org.apache.calcite.sql.SqlKind.*;
 134 
 135 /**
 136  * Reason:
 137  * Date: 2018/7/24
 138  * Company: www.dtstack.com
 139  * @author xuchao
 140  */
 141 
 142 public class SideSqlExec {
 143 
 144     private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
 145 
 146     private String localSqlPluginPath = null;
 147 
 148     private String tmpFields = null;
 149 
 150     private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
 151 
 152     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
 153 
 154 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 155     public void exec(String sql, Map&lt;String, SideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,"> 155     public void exec(String sql, Map&lt;String, SideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv🔵</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 156                      Map&lt;String, Table&gt; tableCache) throws Exception {</span>
 157 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 158                      Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig) throws Exception {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 159         if(localSqlPluginPath == null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 160             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 161         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 162 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 163         localTableCache.putAll(tableCache);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 164         try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 165             sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 166         } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 167             LOG.error(&quot;fill predicates for sideTable fail &quot;, e);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 168         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 169 </span>
 170 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 171     public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,"> 171     public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment 🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 172                      Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.SqlParserResult createView) throws Exception {"> 172                      Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.S🔵</abbr></span>
 173 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 174         if(localSqlPluginPath == null){
 175             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
 176         }
 177 
 178         localTableCache.putAll(tableCache);
 179         try {
 180             sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 181         } catch (Exception e) {
 182             LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 183         }
 184 
 185         if(createView != null){
 186             LOG.warn(&quot;create view info\n&quot;);
 187             LOG.warn(createView.getExecSql());
 188             LOG.warn(&quot;-----------------&quot;);
 189         }
 190 
 191         SideSQLParser sideSQLParser = new SideSQLParser();
 192         sideSQLParser.setLocalTableCache(localTableCache);
 193         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());
 194         Object pollObj = null;
 195 
 196         //need clean
 197         boolean preIsSideJoin = false;
 198         List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();
 199 
 200         while((pollObj = exeQueue.poll()) != null){
 201 
 202             if(pollObj instanceof SqlNode){
 203                 SqlNode pollSqlNode = (SqlNode) pollObj;
 204 
 205                 if(preIsSideJoin){
 206                     preIsSideJoin = false;
 207                     List&lt;String&gt; fieldNames = null;
 208                     for(FieldReplaceInfo replaceInfo : replaceInfoList){
 209                         fieldNames = Lists.newArrayList();
 210                         replaceFieldName(pollSqlNode, replaceInfo);
 211                         addAliasForFieldNode(pollSqlNode, fieldNames, replaceInfo.getMappingTable());
 212                     }
 213                 }
 214 
 215                 if(pollSqlNode.getKind() == INSERT){
 216                     System.out.println(&quot;----------real exec sql-----------&quot; );
 217                     System.out.println(pollSqlNode.toString());
 218                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString());
 219                     if(LOG.isInfoEnabled()){
 220                         LOG.info(&quot;exec sql: &quot; + pollSqlNode.toString());
 221                     }
 222 
 223                 }else if(pollSqlNode.getKind() == AS){
 224                     dealAsSourceTable(tableEnv, pollSqlNode, tableCache, replaceInfoList);
 225 
 226                 } else if (pollSqlNode.getKind() == WITH_ITEM) {
 227                     SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 228                     String TableAlias = sqlWithItem.name.toString();
 229                     Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 230                     tableEnv.registerTable(TableAlias, table);
 231 
 232                 } else if (pollSqlNode.getKind() == SELECT){
<abbr title=" 233                     Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);"> 233                     Preconditions.checkState(createView != null, &quot;select sql must included by create view🔵</abbr>
 234                     Table table = tableEnv.sqlQuery(pollObj.toString());
 235 
 236                     if (createView.getFieldsInfoStr() == null){
 237                         tableEnv.registerTable(createView.getTableName(), table);
 238                     } else {
 239                         if (checkFieldsInfo(createView, table)){
 240                             table = table.as(tmpFields);
 241                             tableEnv.registerTable(createView.getTableName(), table);
 242                         } else {
 243                             throw new RuntimeException(&quot;Fields mismatch&quot;);
 244                         }
 245                     }
 246 
 247                     localTableCache.put(createView.getTableName(), table);
 248                 }
 249 
 250             }else if (pollObj instanceof JoinInfo){
 251                 System.out.println(&quot;----------exec join info----------&quot;);
 252                 System.out.println(pollObj.toString());
 253                 preIsSideJoin = true;
 254                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv, replaceInfoList);
 255             }
 256         }
 257 
 258     }
 259 
 260 
 261     /**
 262      * 解析出as查询的表和字段的关系
 263      * @param asSqlNode
 264      * @param tableCache
 265      * @return
 266      */
 267     private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 268         SqlNode info = asSqlNode.getOperands()[0];
 269         SqlNode alias = asSqlNode.getOperands()[1];
 270 
 271         SqlKind infoKind = info.getKind();
 272         if(infoKind != SELECT){
 273             return null;
 274         }
 275 
 276         List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 277 
 278         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 279         for (FieldInfo fieldInfo : extractFieldList) {
 280             String tableName = fieldInfo.getTable();
 281             String fieldName = fieldInfo.getFieldName();
 282             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 283             mappingTable.put(tableName, fieldName, mappingFieldName);
 284         }
 285 
 286         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 287         replaceInfo.setMappingTable(mappingTable);
 288         replaceInfo.setTargetTableName(alias.toString());
 289         replaceInfo.setTargetTableAlias(alias.toString());
 290         return replaceInfo;
 291     }
 292 
 293 
 294     /**
 295      * 添加字段别名
 296      * @param pollSqlNode
 297      * @param fieldList
 298      * @param mappingTable
 299      */
<abbr title=" 300     private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 300     private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String,🔵</abbr>
 301         SqlKind sqlKind = pollSqlNode.getKind();
 302         switch (sqlKind) {
 303             case INSERT:
 304                 SqlNode source = ((SqlInsert) pollSqlNode).getSource();
 305                 addAliasForFieldNode(source, fieldList, mappingTable);
 306                 break;
 307             case AS:
<abbr title=" 308                 addAliasForFieldNode(((SqlBasicCall) pollSqlNode).getOperands()[0], fieldList, mappingTable);"> 308                 addAliasForFieldNode(((SqlBasicCall) pollSqlNode).getOperands()[0], fieldList, mappingTab🔵</abbr>
 309                 break;
 310             case SELECT:
 311                 SqlNodeList selectList = ((SqlSelect) pollSqlNode).getSelectList();
 312                 selectList.getList().forEach(node -&gt; {
 313                     if (node.getKind() == IDENTIFIER) {
 314                         SqlIdentifier sqlIdentifier = (SqlIdentifier) node;
 315                         if (sqlIdentifier.names.size() == 1) {
 316                             return;
 317                         }
 318                         // save real field
 319                         String fieldName = sqlIdentifier.names.get(1);
<abbr title=" 320                         if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().containsKey(fieldName)) {"> 320                         if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap🔵</abbr>
 321                             fieldList.add(fieldName);
 322                         }
 323 
 324                     }
 325                 });
 326                 for (int i = 0; i &lt; selectList.getList().size(); i++) {
 327                     SqlNode node = selectList.get(i);
 328                     if (node.getKind() == IDENTIFIER) {
 329                         SqlIdentifier sqlIdentifier = (SqlIdentifier) node;
 330                         if (sqlIdentifier.names.size() == 1) {
 331                             return;
 332                         }
 333                         String name = sqlIdentifier.names.get(1);
 334                         // avoid real field pv0 convert pv
<abbr title=" 335                         if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring(0, name.length() - 1))) {"> 335                         if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.🔵</abbr>
 336                             SqlOperator operator = new SqlAsOperator();
 337                             SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 338 
<abbr title=" 339                             SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() - 1), null, sqlParserPos);"> 339                             SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.l🔵</abbr>
 340                             SqlNode[] sqlNodes = new SqlNode[2];
 341                             sqlNodes[0] = sqlIdentifier;
 342                             sqlNodes[1] = sqlIdentifierAlias;
<abbr title=" 343                             SqlBasicCall sqlBasicCall = new SqlBasicCall(operator, sqlNodes, sqlParserPos);"> 343                             SqlBasicCall sqlBasicCall = new SqlBasicCall(operator, sqlNodes, sqlParserPos🔵</abbr>
 344 
 345                             selectList.set(i, sqlBasicCall);
 346                         }
 347                     }
 348                 }
 349                 break;
 350             default:
 351                 break;
 352         }
 353     }
 354 
 355 
 356     public AliasInfo parseAsNode(SqlNode sqlNode) throws SqlParseException {
 357         SqlKind sqlKind = sqlNode.getKind();
 358         if(sqlKind != AS){
 359             throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 360         }
 361 
 362         SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 363         SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 364 
 365         AliasInfo aliasInfo = new AliasInfo();
 366         aliasInfo.setName(info.toString());
 367         aliasInfo.setAlias(alias.toString());
 368 
 369         return aliasInfo;
 370     }
 371 
<abbr title=" 372     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 372     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, Stri🔵</abbr>
 373         TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 374         String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 375         for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 376             FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 377             String tableName = fieldInfo.getTable();
 378             String fieldName = fieldInfo.getFieldName();
 379             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 380             mappingTable.put(tableName, fieldName, mappingFieldName);
 381 
 382             sideOutTypes[i] = fieldInfo.getTypeInformation();
 383             sideOutNames[i] = mappingFieldName;
 384         }
 385         return new RowTypeInfo(sideOutTypes, sideOutNames);
 386     }
 387 
 388 
 389 
 390     /**
 391      *  对时间类型进行类型转换
 392      * @param leftTypeInfo
 393      * @return
 394      */
 395     private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 396         TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 397         TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 398         for (int i = 0; i &lt; sideOutTypes.length; i++) {
 399             sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 400         }
 401         RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 402         return rowTypeInfo;
 403     }
 404 
 405     private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 406         if (typeInformation instanceof TimeIndicatorTypeInfo) {
 407             return TypeInformation.of(LocalDateTime.class);
 408         }
 409         return typeInformation;
 410     }
 411 
 412     //需要考虑更多的情况
 413     private void replaceFieldName(SqlNode sqlNode, FieldReplaceInfo replaceInfo) {
 414         SqlKind sqlKind = sqlNode.getKind();
 415         switch (sqlKind) {
 416             case INSERT:
 417                 SqlNode sqlSource = ((SqlInsert) sqlNode).getSource();
 418                 replaceFieldName(sqlSource, replaceInfo);
 419                 break;
 420             case AS:
 421                 SqlNode asNode = ((SqlBasicCall) sqlNode).getOperands()[0];
 422                 replaceFieldName(asNode, replaceInfo);
 423                 break;
 424             case SELECT:
<abbr title=" 425                 SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTargetTableName());"> 425                 SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTarget🔵</abbr>
 426                 if(sqlSelect == null){
 427                     return;
 428                 }
 429 
 430                 SqlNode sqlSource1 = sqlSelect.getFrom();
 431                 if(sqlSource1.getKind() == AS){
 432                     String tableName = ((SqlBasicCall)sqlSource1).getOperands()[0].toString();
 433                     if(tableName.equalsIgnoreCase(replaceInfo.getTargetTableName())){
 434                         SqlNodeList sqlSelectList = sqlSelect.getSelectList();
 435                         SqlNode whereNode = sqlSelect.getWhere();
 436                         SqlNodeList sqlGroup = sqlSelect.getGroup();
 437 
 438                         //TODO 暂时不处理having
 439                         SqlNode sqlHaving = sqlSelect.getHaving();
 440 
 441                         List&lt;SqlNode&gt; newSelectNodeList = Lists.newArrayList();
 442                         for( int i=0; i&lt;sqlSelectList.getList().size(); i++){
 443                             SqlNode selectNode = sqlSelectList.getList().get(i);
 444                             //特殊处理 isStar的标识
<abbr title=" 445                             if(selectNode.getKind() == IDENTIFIER &amp;&amp; ((SqlIdentifier) selectNode).isStar()){"> 445                             if(selectNode.getKind() == IDENTIFIER &amp;&amp; ((SqlIdentifier) selectNode).isStar(🔵</abbr>
<abbr title=" 446                                 List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, replaceInfo);"> 446                                 List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, re🔵</abbr>
 447                                 newSelectNodeList.addAll(replaceNodeList);
 448                                 continue;
 449                             }
 450 
 451                             SqlNode replaceNode = replaceSelectFieldName(selectNode, replaceInfo);
 452                             if(replaceNode == null){
 453                                 continue;
 454                             }
 455 
 456                             //sqlSelectList.set(i, replaceNode);
 457                             newSelectNodeList.add(replaceNode);
 458                         }
 459 
<abbr title=" 460                         SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosition());"> 460                         SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getP🔵</abbr>
 461                         sqlSelect.setSelectList(newSelectList);
 462 
 463                         //where
 464                         if(whereNode != null){
 465                             SqlNode[] sqlNodeList = ((SqlBasicCall)whereNode).getOperands();
 466                             for(int i =0; i&lt;sqlNodeList.length; i++) {
 467                                 SqlNode whereSqlNode = sqlNodeList[i];
 468                                 SqlNode replaceNode = replaceNodeInfo(whereSqlNode, replaceInfo);
 469                                 sqlNodeList[i] = replaceNode;
 470                             }
 471                         }
 472                         if(sqlGroup != null &amp;&amp; CollectionUtils.isNotEmpty(sqlGroup.getList())){
 473                             for( int i=0; i&lt;sqlGroup.getList().size(); i++){
 474                                 SqlNode selectNode = sqlGroup.getList().get(i);
 475                                 SqlNode replaceNode = replaceNodeInfo(selectNode, replaceInfo);
 476                                 sqlGroup.set(i, replaceNode);
 477                             }
 478                         }
 479                     }
 480                 }else{
 481                     //TODO
 482                     System.out.println(sqlNode);
 483                     throw new RuntimeException(&quot;---not deal type:&quot; + sqlNode);
 484                 }
 485 
 486                 break;
 487             case UNION:
 488                 SqlNode unionLeft = ((SqlBasicCall) sqlNode).getOperands()[0];
 489                 SqlNode unionRight = ((SqlBasicCall) sqlNode).getOperands()[1];
 490                 replaceFieldName(unionLeft, replaceInfo);
 491                 replaceFieldName(unionRight, replaceInfo);
 492 
 493                 break;
 494             case ORDER_BY:
 495                 SqlOrderBy sqlOrderBy  = (SqlOrderBy) sqlNode;
 496                 replaceFieldName(sqlOrderBy.query, replaceInfo);
 497                 SqlNodeList orderFiledList = sqlOrderBy.orderList;
 498                 for (int i=0 ;i&lt;orderFiledList.size();i++) {
<abbr title=" 499                     SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTableAlias());"> 499                     SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getT🔵</abbr>
 500                     orderFiledList.set(i, replaceNode);
 501                 }
 502 
 503             default:
 504                 break;
 505         }
 506     }
 507 
 508     private SqlNode replaceOrderByTableName(SqlNode orderNode, String tableAlias) {
 509         if(orderNode.getKind() == IDENTIFIER){
 510             SqlIdentifier sqlIdentifier = (SqlIdentifier) orderNode;
 511             if (sqlIdentifier.names.size() == 1) {
 512                 return orderNode;
 513             }
 514             return sqlIdentifier.setName(0, tableAlias);
 515         } else if (orderNode instanceof  SqlBasicCall) {
 516             SqlBasicCall sqlBasicCall = (SqlBasicCall) orderNode;
 517             for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 518                 SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 519                 sqlBasicCall.getOperands()[i] = replaceOrderByTableName(sqlNode , tableAlias);
 520             }
 521             return sqlBasicCall;
 522         } else {
 523             return orderNode;
 524         }
 525     }
 526 
 527     private SqlNode replaceNodeInfo(SqlNode groupNode, FieldReplaceInfo replaceInfo){
 528         if(groupNode.getKind() == IDENTIFIER){
 529             SqlIdentifier sqlIdentifier = (SqlIdentifier) groupNode;
 530             if(sqlIdentifier.names.size() == 1){
 531                 return sqlIdentifier;
 532             }
 533 
<abbr title=" 534             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 534             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSim🔵</abbr>
 535             if(mappingFieldName == null){
 536                 throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + sqlIdentifier.toString() );
 537             }
 538 
 539             sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());
 540             return sqlIdentifier.setName(1, mappingFieldName);
 541         }else if(groupNode instanceof  SqlBasicCall){
 542             SqlBasicCall sqlBasicCall = (SqlBasicCall) groupNode;
 543             for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 544                 SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 545                 SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);
 546                 sqlBasicCall.getOperands()[i] = replaceNode;
 547             }
 548 
 549             return sqlBasicCall;
 550         }else{
 551             return groupNode;
 552         }
 553     }
 554 
 555     public SqlNode filterNodeWithTargetName(SqlNode sqlNode, String targetTableName) {
 556 
 557         SqlKind sqlKind = sqlNode.getKind();
 558         switch (sqlKind){
 559             case SELECT:
 560                 SqlNode fromNode = ((SqlSelect)sqlNode).getFrom();
<abbr title=" 561                 if(fromNode.getKind() == AS &amp;&amp; ((SqlBasicCall)fromNode).getOperands()[0].getKind() == IDENTIFIER){"> 561                 if(fromNode.getKind() == AS &amp;&amp; ((SqlBasicCall)fromNode).getOperands()[0].getKind() == IDE🔵</abbr>
<abbr title=" 562                     if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableName)){"> 562                     if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableN🔵</abbr>
 563                         return sqlNode;
 564                     }else{
 565                         return null;
 566                     }
 567                 }else{
 568                     return filterNodeWithTargetName(fromNode, targetTableName);
 569                 }
 570             case AS:
 571                 SqlNode childNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 572                 return filterNodeWithTargetName(childNode, targetTableName);
 573             case JOIN:
 574                 SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 575                 SqlNode rightNode =  ((SqlJoin)sqlNode).getRight();
 576                 SqlNode leftReturnNode = filterNodeWithTargetName(leftNode, targetTableName);
 577                 SqlNode rightReturnNode = filterNodeWithTargetName(rightNode, targetTableName);
 578 
 579                 if(leftReturnNode != null) {
 580                     return leftReturnNode;
 581                 }else if(rightReturnNode != null){
 582                     return rightReturnNode;
 583                 }else{
 584                     return null;
 585                 }
 586             default:
 587                 break;
 588         }
 589 
 590         return null;
 591     }
 592 
 593 
 594     public void setLocalSqlPluginPath(String localSqlPluginPath) {
 595         this.localSqlPluginPath = localSqlPluginPath;
 596     }
 597 
<abbr title=" 598     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){"> 598     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableNa🔵</abbr>
 599         Table table = localTableCache.get(tableAlias);
 600         if(table == null){
 601             table = localTableCache.get(tableName);
 602         }
 603 
 604         if(table == null){
 605             throw new RuntimeException(&quot;not register table &quot; + tableName);
 606         }
 607 
 608         return table;
 609     }
 610 
 611     private List&lt;SqlNode&gt; replaceSelectStarFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo){
 612         SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 613         List&lt;SqlNode&gt; sqlNodes = Lists.newArrayList();
 614         if(sqlIdentifier.isStar()){//处理 [* or table.*]
 615             int identifierSize = sqlIdentifier.names.size();
 616             Collection&lt;String&gt; columns = null;
 617             if(identifierSize == 1){
 618                 columns = replaceInfo.getMappingTable().values();
 619             }else{
 620                 columns = replaceInfo.getMappingTable().row(sqlIdentifier.names.get(0)).values();
 621             }
 622 
 623             for(String colAlias : columns){
 624                 SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 625                 List&lt;String&gt; columnInfo = Lists.newArrayList();
 626                 columnInfo.add(replaceInfo.getTargetTableAlias());
 627                 columnInfo.add(colAlias);
 628                 SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(columnInfo, sqlParserPos);
 629                 sqlNodes.add(sqlIdentifierAlias);
 630             }
 631 
 632             return sqlNodes;
 633         }else{
 634             throw new RuntimeException(&quot;is not a star select field.&quot; + selectNode);
 635         }
 636     }
 637 
 638     private SqlNode replaceSelectFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo) {
 639         if (selectNode.getKind() == AS) {
 640             SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];
 641             SqlNode replaceNode = replaceSelectFieldName(leftNode, replaceInfo);
 642             if (replaceNode != null) {
 643                 ((SqlBasicCall) selectNode).getOperands()[0] = replaceNode;
 644             }
 645 
 646             return selectNode;
 647         }else if(selectNode.getKind() == IDENTIFIER){
 648             SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 649 
 650             if(sqlIdentifier.names.size() == 1){
 651                 return selectNode;
 652             }
 653 
 654             //Same level mappingTable
<abbr title=" 655             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 655             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSim🔵</abbr>
 656             if (mappingFieldName == null) {
 657                 throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + selectNode.toString() );
 658             }
 659 
 660             sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());
 661             sqlIdentifier = sqlIdentifier.setName(1, mappingFieldName);
 662             return sqlIdentifier;
 663         }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//字面含义
 664             return selectNode;
 665         }else if(  AGGREGATE.contains(selectNode.getKind())
 666                 || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 667                 || COMPARISON.contains(selectNode.getKind())
 668                 || selectNode.getKind() == OTHER_FUNCTION
 669                 || selectNode.getKind() == DIVIDE
 670                 || selectNode.getKind() == CAST
 671                 || selectNode.getKind() == TRIM
 672                 || selectNode.getKind() == TIMES
 673                 || selectNode.getKind() == PLUS
 674                 || selectNode.getKind() == NOT_IN
 675                 || selectNode.getKind() == OR
 676                 || selectNode.getKind() == AND
 677                 || selectNode.getKind() == MINUS
 678                 || selectNode.getKind() == TUMBLE
 679                 || selectNode.getKind() == TUMBLE_START
 680                 || selectNode.getKind() == TUMBLE_END
 681                 || selectNode.getKind() == SESSION
 682                 || selectNode.getKind() == SESSION_START
 683                 || selectNode.getKind() == SESSION_END
 684                 || selectNode.getKind() == HOP
 685                 || selectNode.getKind() == HOP_START
 686                 || selectNode.getKind() == HOP_END
 687                 || selectNode.getKind() == BETWEEN
 688                 || selectNode.getKind() == IS_NULL
 689                 || selectNode.getKind() == IS_NOT_NULL
 690                 || selectNode.getKind() == CONTAINS
 691                 || selectNode.getKind() == TIMESTAMP_ADD
 692                 || selectNode.getKind() == TIMESTAMP_DIFF
 693                 || selectNode.getKind() == LIKE
 694 
 695                 ){
 696             SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 697             for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 698                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 699                 if(sqlNode instanceof SqlLiteral){
 700                     continue;
 701                 }
 702 
 703                 if(sqlNode instanceof SqlDataTypeSpec){
 704                     continue;
 705                 }
 706 
 707                 SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);
 708                 if(replaceNode == null){
 709                     continue;
 710                 }
 711 
 712                 sqlBasicCall.getOperands()[i] = replaceNode;
 713             }
 714 
 715             return selectNode;
 716         }else if(selectNode.getKind() == CASE){
 717             System.out.println(&quot;selectNode&quot;);
 718             SqlCase sqlCase = (SqlCase) selectNode;
 719             SqlNodeList whenOperands = sqlCase.getWhenOperands();
 720             SqlNodeList thenOperands = sqlCase.getThenOperands();
 721             SqlNode elseNode = sqlCase.getElseOperand();
 722 
 723             for(int i=0; i&lt;whenOperands.size(); i++){
 724                 SqlNode oneOperand = whenOperands.get(i);
 725                 SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);
 726                 if (replaceNode != null) {
 727                     whenOperands.set(i, replaceNode);
 728                 }
 729             }
 730 
 731             for(int i=0; i&lt;thenOperands.size(); i++){
 732                 SqlNode oneOperand = thenOperands.get(i);
 733                 SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);
 734                 if (replaceNode != null) {
 735                     thenOperands.set(i, replaceNode);
 736                 }
 737             }
 738 
 739             ((SqlCase) selectNode).setOperand(3, replaceSelectFieldName(elseNode, replaceInfo));
 740             return selectNode;
 741         }else if(selectNode.getKind() == OTHER){
 742             //不处理
 743             return selectNode;
 744         }else{
<abbr title=" 745             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 745             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, 🔵</abbr>
 746         }
 747     }
 748 
 749     /**
<abbr title=" 750      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 750      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., d🔵</abbr>
 751      *
 752      * @return
 753      */
<abbr title=" 754     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 754     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInf🔵</abbr>
 755         List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 756         if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 757             return true;
 758         }
 759         return false;
 760     }
 761 
 762     private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 763         List&lt;String&gt; res = Lists.newArrayList();
 764         sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 765             res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 766         });
 767         return res;
 768     }
 769 
<abbr title=" 770     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 770     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTa🔵</abbr>
 771         List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 772         ParseUtils.parseAnd(conditionNode, sqlNodeList);
 773         List&lt;String&gt; conditionFields = Lists.newArrayList();
 774         for(SqlNode sqlNode : sqlNodeList){
 775             if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 776                 throw new RuntimeException(&quot;not compare operator.&quot;);
 777             }
 778 
 779             SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 780             SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 781 
 782             String leftTableName = left.getComponent(0).getSimple();
 783             String rightTableName = right.getComponent(0).getSimple();
 784 
 785             String tableCol = &quot;&quot;;
 786             if(leftTableName.equalsIgnoreCase(specifyTableName)){
 787                 tableCol = left.getComponent(1).getSimple();
 788             }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 789                 tableCol = right.getComponent(1).getSimple();
 790             }else{
<abbr title=" 791                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 791                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specify🔵</abbr>
 792             }
 793             tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 794             conditionFields.add(tableCol);
 795         }
 796 
 797         return conditionFields;
 798     }
 799 
 800     protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 801                                      SqlNode pollSqlNode,
 802                                      Map&lt;String, Table&gt; tableCache,
 803                                      List&lt;FieldReplaceInfo&gt; replaceInfoList) throws SqlParseException {
 804 
 805         AliasInfo aliasInfo = parseAsNode(pollSqlNode);
 806         if (localTableCache.containsKey(aliasInfo.getName())) {
 807             return;
 808         }
 809 
 810         Table table = tableEnv.sqlQuery(aliasInfo.getName());
 811         tableEnv.registerTable(aliasInfo.getAlias(), table);
 812         localTableCache.put(aliasInfo.getAlias(), table);
 813 
 814         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 815 
 816         FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 817         if(fieldReplaceInfo == null){
 818            return;
 819         }
 820 
 821 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 822             if(pollObj instanceof SqlNode){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 823                 SqlNode pollSqlNode = (SqlNode) pollObj;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 824 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 825                 if(preIsSideJoin){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 826                     preIsSideJoin = false;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 827                     List&lt;String&gt; fieldNames = null;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 828                     for (FieldReplaceInfo replaceInfo : replaceInfoList) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 829                         fieldNames = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 830                         replaceFieldName(pollSqlNode, replaceInfo.getMappingTable(), replaceInfo.getTargetTableName(), replaceInfo.getTargetTableAlias());"> 830                         replaceFieldName(pollSqlNode, replaceInfo.getMappingTable(), replaceInfo.getTarge🔵</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 831                         addAliasForFieldNode(pollSqlNode, fieldNames, replaceInfo.getMappingTable());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 832                     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 833                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 834 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 835                 if(pollSqlNode.getKind() == INSERT){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 836 //                    tableEnv.sqlUpdate(pollSqlNode.toString());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 837                     FlinkSQLExec.sqlUpdate(tableEnv,pollSqlNode.toString());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 838                 }else if(pollSqlNode.getKind() == AS){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 839                     AliasInfo aliasInfo = parseASNode(pollSqlNode);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 840                     Table table = tableEnv.sqlQuery(aliasInfo.getName());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 841                     tableEnv.registerTable(aliasInfo.getAlias(), table);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 842                     if(LOG.isInfoEnabled()){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 843                         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 844                     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 845                     localTableCache.put(aliasInfo.getAlias(), table);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 846                 } else if (pollSqlNode.getKind() == SELECT){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 847                     Table table = tableEnv.sqlQuery(pollObj.toString());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 848                     if (result.getFieldsInfoStr() == null){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 849                         tableEnv.registerTable(result.getTableName(), table);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 850                     } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 851                         if (checkFieldsInfo(result, table)){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 852                             table = table.as(tmpFields);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 853                             tableEnv.registerTable(result.getTableName(), table);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 854                         } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 855                             throw new RuntimeException(&quot;Fields mismatch&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 856                         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 857                     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 858                     localTableCache.put(result.getTableName(), table);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 859 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 860                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 861 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 862             }else if (pollObj instanceof JoinInfo){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 863                 preIsSideJoin = true;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 864                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv, replaceInfoList);</span>
 865 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 866         List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 867 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 868         while((pollObj = exeQueue.poll()) != null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 869 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 870             if(pollObj instanceof SqlNode){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 871                 SqlNode pollSqlNode = (SqlNode) pollObj;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 872 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 873                 if(preIsSideJoin){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 874                     preIsSideJoin = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 875                     List&lt;String&gt; fieldNames = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 876                     for (FieldReplaceInfo replaceInfo : replaceInfoList) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 877                         fieldNames = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 878                         replaceFieldName(pollSqlNode, replaceInfo.getMappingTable(), replaceInfo.getTargetTableName(), replaceInfo.getTargetTableAlias());"> 878                         replaceFieldName(pollSqlNode, replaceInfo.getMappingTable(), replaceInfo.getTarge🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 879                         addAliasForFieldNode(pollSqlNode, fieldNames, replaceInfo.getMappingTable());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 880                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 881                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 882 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 883                 if(pollSqlNode.getKind() == INSERT){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 884                     tableEnv.sqlUpdate(pollSqlNode.toString());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 885                 }else if(pollSqlNode.getKind() == AS){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 886                     AliasInfo aliasInfo = parseASNode(pollSqlNode);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 887                     Table table = tableEnv.sqlQuery(aliasInfo.getName());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 888                     tableEnv.registerTable(aliasInfo.getAlias(), table);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 889                     if(LOG.isInfoEnabled()){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 890                         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 891                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 892                     localTableCache.put(aliasInfo.getAlias(), table);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 893                 } else if (pollSqlNode.getKind() == SELECT){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 894                     Table table = tableEnv.sqlQuery(pollObj.toString());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 895                     if (result.getFieldsInfoStr() == null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 896                         tableEnv.registerTable(result.getTableName(), table);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 897                     } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 898                         if (checkFieldsInfo(result, table)){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 899                             table = table.as(tmpFields);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 900                             tableEnv.registerTable(result.getTableName(), table);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 901                         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 902                             throw new RuntimeException(&quot;Fields mismatch&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 903                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 904                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 905                     localTableCache.put(result.getTableName(), table);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 906 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 907                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 908 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 909             }else if (pollObj instanceof JoinInfo){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 910                 preIsSideJoin = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 911                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv, replaceInfoList);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 912             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 913         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 914     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 915 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 916     private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 917                          Map&lt;String, SideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 918                          List&lt;FieldReplaceInfo&gt; replaceInfoList) throws Exception{</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 919         JoinInfo joinInfo = (JoinInfo) pollObj;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 920 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 921         JoinScope joinScope = new JoinScope();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 922         JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 923         leftScopeChild.setAlias(joinInfo.getLeftTableAlias());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 924         leftScopeChild.setTableName(joinInfo.getLeftTableName());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 925 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 926         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 926         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLe🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 927         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColumnNames());"> 927         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema(🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 928         leftScopeChild.setRowTypeInfo(leftTypeInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 929 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 930         JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 931         rightScopeChild.setAlias(joinInfo.getRightTableAlias());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 932         rightScopeChild.setTableName(joinInfo.getRightTableName());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 933         SideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 934         if(sideTableInfo == null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 935             sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 936         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 937 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 938         if(sideTableInfo == null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 939             throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 940         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 941 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 942         if(!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 943             throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 944         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 945 </span>
 946 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 947         //as 的源表</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 948         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 949         SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 950         TableUtils.getFromTableInfo(fromNode, fromTableNameSet);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 951         for(FieldReplaceInfo tmp : replaceInfoList){</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 952             if(fromTableNameSet.contains(tmp.getTargetTableName())</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 953                     || fromTableNameSet.contains(tmp.getTargetTableAlias())){</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 954                 fieldReplaceInfo.setPreNode(tmp);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 955                 break;</span>
 956 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 957             }
 958         }
 959         replaceInfoList.add(fieldReplaceInfo);
 960     }
 961 
 962     private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache,
<abbr title=" 963                          Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,"> 963                          Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv🔵</abbr>
 964                          List&lt;FieldReplaceInfo&gt; replaceInfoList) throws Exception{
 965         JoinInfo joinInfo = (JoinInfo) pollObj;
 966 
 967         JoinScope joinScope = new JoinScope();
 968         JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 969         leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 970         leftScopeChild.setTableName(joinInfo.getLeftTableName());
 971 
 972         SqlKind sqlKind = joinInfo.getLeftNode().getKind();
 973         if(sqlKind == AS){
 974             dealAsSourceTable(tableEnv, joinInfo.getLeftNode(), localTableCache, replaceInfoList);
 975         }
 976 
<abbr title=" 977         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 977         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLe🔵</abbr>
<abbr title=" 978         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSchema().getFieldNames());"> 978         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSc🔵</abbr>
 979         leftScopeChild.setRowTypeInfo(leftTypeInfo);
 980 
 981         JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 982         rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 983         rightScopeChild.setTableName(joinInfo.getRightTableName());
 984         AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 985         if(sideTableInfo == null){
 986             sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 987         }
 988 
 989         if(sideTableInfo == null){
 990             throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 991         }
 992 
 993         if(!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)){
 994             throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);
 995         }
 996 
 997         rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 998 
 999         joinScope.addScope(leftScopeChild);
1000         joinScope.addScope(rightScopeChild);
1001 
1002         //获取两个表的所有字段
<abbr title="1003         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);">1003         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), join🔵</abbr>
1004 
1005         String leftTableAlias = joinInfo.getLeftTableAlias();
1006         Table targetTable = localTableCache.get(leftTableAlias);
1007         if(targetTable == null){
1008             targetTable = localTableCache.get(joinInfo.getLeftTableName());
1009         }
1010 
<abbr title="1011         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSchema().getFieldNames());">1011         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSc🔵</abbr>
1012 
1013 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1014         DataStream adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1015                                 .map((Tuple2&lt;Boolean, Row&gt; f0) -&gt; { return f0.f1; })</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1016                                 .returns(Row.class);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1017         //adaptStream.getTransformation().setOutputType(leftTypeInfo);</span>
1018 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1019 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="1020         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColumnNames());">1020         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema(🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1021 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1022         DataStream adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1023                                 .map((Tuple2&lt;Boolean, Row&gt; f0) -&gt; { return f0.f1; })</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1024                                 .returns(Row.class);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1025 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1026 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1027         //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1028         if(sideTableInfo.isPartitionedJoin()){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1029             RowTypeInfo leftTableOutType = buildLeftTableOutType(leftTypeInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1030             adaptStream.getTransformation().setOutputType(leftTableOutType);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="1031             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);">1031             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTa🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1032             String[] leftJoinColArr = leftJoinColList.toArray(new String[leftJoinColList.size()]);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1033             adaptStream = adaptStream.keyBy(leftJoinColArr);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1034         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1035 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1036         DataStream dsOut = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1037         if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="1038             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);">1038             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), 🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1039         }else{</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="1040             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);">1040             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSq🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1041         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1042 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1043         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1044         RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1045         dsOut.getTransformation().setOutputType(sideOutTypeInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1046         String targetTableName = joinInfo.getNewTableName();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1047         String targetTableAlias = joinInfo.getNewTableAlias();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1048 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1049         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1050         replaceInfo.setMappingTable(mappingTable);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1051         replaceInfo.setTargetTableName(targetTableName);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1052         replaceInfo.setTargetTableAlias(targetTableAlias);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1053 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1054         replaceInfoList.add(replaceInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1055 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1056         if (!tableEnv.isRegistered(joinInfo.getNewTableName())){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="1057             tableEnv.registerDataStream(joinInfo.getNewTableName(), dsOut, String.join(&quot;,&quot;, sideOutTypeInfo.getFieldNames()));">1057             tableEnv.registerDataStream(joinInfo.getNewTableName(), dsOut, String.join(&quot;,&quot;, sideOutTypeIn🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1058         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1059     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1060 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1061 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1062 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1063     private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1064         List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1065         String fieldsInfo = result.getFieldsInfoStr();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1066         String[] fields = fieldsInfo.split(&quot;,&quot;);</span>
1067 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title="1068         DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)">1068         DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.c🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1069                 .map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1070                     return new CRow(tp2.f1, tp2.f0);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1071                 }).returns(CRow.class);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1072 </span>
1073 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
1074 
1075         //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
1076         if (sideTableInfo.isPartitionedJoin()) {
<abbr title="1077             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);">1077             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTa🔵</abbr>
1078             List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
1079             int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title="1080             adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));">1080             adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, tar🔵</abbr>
1081         }
1082 
1083         DataStream&lt;CRow&gt; dsOut = null;
1084         if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title="1085             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);">1085             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), 🔵</abbr>
1086         }else{
<abbr title="1087             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);">1087             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSq🔵</abbr>
1088         }
1089 
1090         // TODO  将嵌套表中的字段传递过去, 去除冗余的ROWtime
1091         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
1092         RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
1093 
1094         CRowTypeInfo cRowTypeInfo = new CRowTypeInfo(sideOutTypeInfo);
1095         dsOut.getTransformation().setOutputType(cRowTypeInfo);
1096 
1097         String targetTableName = joinInfo.getNewTableName();
1098         String targetTableAlias = joinInfo.getNewTableAlias();
1099 
1100         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
1101         replaceInfo.setMappingTable(mappingTable);
1102         replaceInfo.setTargetTableName(targetTableName);
1103         replaceInfo.setTargetTableAlias(targetTableAlias);
1104 
1105         //判断之前是不是被替换过,被替换过则设置之前的替换信息作为上一个节点
1106         for(FieldReplaceInfo tmp : replaceInfoList){
1107             if(tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName())
1108             ||tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableAlias())){
1109                 replaceInfo.setPreNode(tmp);
1110                 break;
1111             }
1112         }
1113 
1114         replaceInfoList.add(replaceInfo);
1115 
1116 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1117         List&lt;String&gt; registeredTableName = Arrays.asList(tableEnv.listTables());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1118         if (!registeredTableName.contains(joinInfo.getNewTableName())) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title="1119             tableEnv.registerDataStream(joinInfo.getNewTableName(), dsOut, String.join(&quot;,&quot;, sideOutTypeInfo.getFieldNames()));">1119             tableEnv.registerDataStream(joinInfo.getNewTableName(), dsOut, String.join(&quot;,&quot;, sideOutTypeIn🔵</abbr></span>
1120 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1121 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1122         replaceInfoList.add(replaceInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1123 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1124         if (!tableEnv.isRegistered(joinInfo.getNewTableName())){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="1125             tableEnv.registerDataStream(joinInfo.getNewTableName(), dsOut, String.join(&quot;,&quot;, sideOutTypeInfo.getFieldNames()));">1125             tableEnv.registerDataStream(joinInfo.getNewTableName(), dsOut, String.join(&quot;,&quot;, sideOutTypeIn🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1126         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1127     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1128 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1129 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1130 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1131     private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1132         List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1133         String fieldsInfo = result.getFieldsInfoStr();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1134         String[] fields = fieldsInfo.split(&quot;,&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1135         for (int i = 0; i &lt; fields.length; i++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1136             String[] filed = fields[i].split(&quot;\\s&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1137             if (filed.length &lt; 2 || fields.length != table.getSchema().getColumnNames().length){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1138                 return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1139             } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1140                 String[] filedNameArr = new String[filed.length - 1];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1141                 System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1142                 String fieldName = String.join(&quot; &quot;, filedNameArr);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1143                 fieldNames.add(fieldName);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1144                 String fieldType = filed[filed.length - 1 ].trim();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1145                 Class fieldClass = ClassUtil.stringConvertClass(fieldType);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1146                 Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1147                 if (fieldClass == tableField){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1148                     continue;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1149                 } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1150                     return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1151                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1152             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1153         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1154         tmpFields = String.join(&quot;,&quot;, fieldNames);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1155         return true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1156     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1157 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1158 }</span>
1159 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1160         if (!tableEnv.isRegistered(joinInfo.getNewTableName())){</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1161             Table joinTable = tableEnv.fromDataStream(dsOut);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1162             tableEnv.registerTable(joinInfo.getNewTableName(), joinTable);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1163             localTableCache.put(joinInfo.getNewTableName(), joinTable);</span>
1164 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
1165         }
1166 
1167     }
1168 
1169 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
1170 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1171 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1172 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1173 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1174     private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1175         List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1176         String fieldsInfo = result.getFieldsInfoStr();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1177         String[] fields = fieldsInfo.split(&quot;,&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1178         for (int i = 0; i &lt; fields.length; i++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1179             String[] filed = fields[i].split(&quot;\\s&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1180             if (filed.length &lt; 2 || fields.length != table.getSchema().getColumnNames().length){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1181                 return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1182             } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1183                 String[] filedNameArr = new String[filed.length - 1];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1184                 System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1185                 String fieldName = String.join(&quot; &quot;, filedNameArr);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1186                 fieldNames.add(fieldName);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1187                 String fieldType = filed[filed.length - 1 ].trim();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1188                 Class fieldClass = ClassUtil.stringConvertClass(fieldType);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1189                 Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1190                 if (fieldClass == tableField){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1191                     continue;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1192                 } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1193                     return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1194                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1195             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1196         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1197         tmpFields = String.join(&quot;,&quot;, fieldNames);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1198         return true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1199     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1200 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1201 }</span>
1202 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1203     private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1204         String[] fieldNames = schema.getFieldNames();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1205         TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1206 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title="1207         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);">1207         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::ne🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title="1208         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);">1208         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(Typ🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1209         return new RowTypeInfo(projectedTypes, projectedNames);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1210     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1211 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1212 </span>
1213 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
1214     private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
1215         List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
1216         String fieldsInfo = result.getFieldsInfoStr();
1217         String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
1218         for (int i = 0; i &lt; fields.length; i++) {
1219             String[] filed = fields[i].split(&quot;\\s&quot;);
1220             if (filed.length &lt; 2 || fields.length != table.getSchema().getFieldNames().length){
1221                 return false;
1222             } else {
1223                 String[] filedNameArr = new String[filed.length - 1];
1224                 System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
1225                 String fieldName = String.join(&quot; &quot;, filedNameArr);
1226                 fieldNames.add(fieldName);
1227                 String fieldType = filed[filed.length - 1 ].trim();
1228                 Class fieldClass = ClassUtil.stringConvertClass(fieldType);
1229                 Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
1230                 if (fieldClass == tableField){
1231                     continue;
1232                 } else {
1233                     return false;
1234                 }
1235             }
1236         }
1237         tmpFields = String.join(&quot;,&quot;, fieldNames);
1238         return true;
1239     }
1240 
1241 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.side;
  22 
  23 import org.apache.flink.api.common.typeinfo.TypeInformation;
  24 import org.apache.flink.api.java.tuple.Tuple2;
  25 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  26 import org.apache.flink.streaming.api.datastream.DataStream;
  27 import org.apache.flink.table.api.Table;
  28 import org.apache.flink.table.api.TableSchema;
  29 import org.apache.flink.table.api.java.StreamTableEnvironment;
  30 import org.apache.flink.table.runtime.CRowKeySelector;
  31 import org.apache.flink.table.runtime.types.CRow;
  32 import org.apache.flink.table.runtime.types.CRowTypeInfo;
  33 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  34 import org.apache.flink.types.Row;
  35 
  36 import com.dtstack.flink.sql.enums.ECacheType;
  37 import com.dtstack.flink.sql.exec.FlinkSQLExec;
  38 import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  39 import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  40 import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  41 import com.dtstack.flink.sql.util.ClassUtil;
  42 import com.dtstack.flink.sql.util.ParseUtils;
  43 import com.dtstack.flink.sql.util.TableUtils;
  44 import com.google.common.base.Preconditions;
  45 import com.google.common.collect.HashBasedTable;
  46 import com.google.common.collect.Lists;
  47 import com.google.common.collect.Maps;
  48 import com.google.common.collect.Sets;
  49 import org.apache.calcite.sql.SqlAsOperator;
  50 import org.apache.calcite.sql.SqlBasicCall;
  51 import org.apache.calcite.sql.SqlDataTypeSpec;
  52 import org.apache.calcite.sql.SqlIdentifier;
  53 import org.apache.calcite.sql.SqlInsert;
  54 import org.apache.calcite.sql.SqlJoin;
  55 import org.apache.calcite.sql.SqlKind;
  56 import org.apache.calcite.sql.SqlLiteral;
  57 import org.apache.calcite.sql.SqlNode;
  58 import org.apache.calcite.sql.SqlNodeList;
  59 import org.apache.calcite.sql.SqlOperator;
  60 import org.apache.calcite.sql.SqlOrderBy;
  61 import org.apache.calcite.sql.SqlSelect;
  62 import org.apache.calcite.sql.SqlWithItem;
  63 import org.apache.calcite.sql.fun.SqlCase;
  64 import org.apache.calcite.sql.parser.SqlParseException;
  65 import org.apache.calcite.sql.parser.SqlParserPos;
  66 import org.apache.commons.collections.CollectionUtils;
  67 import org.apache.commons.lang3.StringUtils;
  68 import org.slf4j.Logger;
  69 import org.slf4j.LoggerFactory;
  70 
  71 import java.sql.Timestamp;
  72 import java.time.LocalDateTime;
  73 import java.util.Arrays;
  74 import java.util.Collection;
  75 import java.util.LinkedList;
  76 import java.util.List;
  77 import java.util.Map;
  78 import java.util.Queue;
  79 import java.util.Set;
  80 
  81 import static org.apache.calcite.sql.SqlKind.*;
  82 
  83 /**
  84  * Reason:
  85  * Date: 2018/7/24
  86  * Company: www.dtstack.com
  87  * @author xuchao
  88  */
  89 
  90 public class SideSqlExec {
  91 
  92     private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  93 
  94     private String localSqlPluginPath = null;
  95 
  96     private String tmpFields = null;
  97 
  98     private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  99 
 100     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
 101 
 102 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 103     public void exec(String sql, Map&lt;String, SideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,"> 103     public void exec(String sql, Map&lt;String, SideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv🔵</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 104                      Map&lt;String, Table&gt; tableCache) throws Exception {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 105         if(localSqlPluginPath == null){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 106             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 107         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 108 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 109         localTableCache.putAll(tableCache);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 110         try {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 111             sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 112         } catch (Exception e) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 113             LOG.error(&quot;fill predicates for sideTable fail &quot;, e);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 114         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 115 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 116         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 117         Object pollObj = null;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 118 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 119         //need clean</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 120         boolean preIsSideJoin = false;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 121         List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 122 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 123         while((pollObj = exeQueue.poll()) != null){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 124 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 125             if(pollObj instanceof SqlNode){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 126                 SqlNode pollSqlNode = (SqlNode) pollObj;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 127 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 128                 if(preIsSideJoin){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 129                     preIsSideJoin = false;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 130                     List&lt;String&gt; fieldNames = null;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 131                     for(FieldReplaceInfo replaceInfo : replaceInfoList){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 132                         fieldNames = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 133                         replaceFieldName(pollSqlNode, replaceInfo.getMappingTable(), replaceInfo.getTargetTableName(), replaceInfo.getTargetTableAlias());"> 133                         replaceFieldName(pollSqlNode, replaceInfo.getMappingTable(), replaceInfo.getTarge🔵</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 134                         addAliasForFieldNode(pollSqlNode, fieldNames, replaceInfo.getMappingTable());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 135                     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 136                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 137 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 138                 if(pollSqlNode.getKind() == INSERT){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 139                     System.out.println(&quot;----------real exec sql-----------&quot; );</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 140                     System.out.println(pollSqlNode.toString());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 141                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 142                     if(LOG.isInfoEnabled()){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 143                         LOG.info(&quot;exec sql: &quot; + pollSqlNode.toString());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 144                     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 145                 }else if(pollSqlNode.getKind() == AS){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 146                     AliasInfo aliasInfo = parseASNode(pollSqlNode);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 147                     Table table = tableEnv.sqlQuery(aliasInfo.getName());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 148                     tableEnv.registerTable(aliasInfo.getAlias(), table);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 149                     localTableCache.put(aliasInfo.getAlias(), table);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 150                 } else if (pollSqlNode.getKind() == WITH_ITEM) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 151                     SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 152                     String TableAlias = sqlWithItem.name.toString();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 153                     Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 154                     tableEnv.registerTable(TableAlias, table);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 155                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 156 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 157             }else if (pollObj instanceof JoinInfo){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 158                 preIsSideJoin = true;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 159                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv, replaceInfoList);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 160             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 161         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 162 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 163     }</span>
 164 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 165     public void exec(String sql, Map&lt;String, SideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,"> 165     public void exec(String sql, Map&lt;String, SideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 166                      Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig) throws Exception {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 167         if(localSqlPluginPath == null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 168             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 169         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 170 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 171         localTableCache.putAll(tableCache);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 172         try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 173             sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 174         } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 175             LOG.error(&quot;fill predicates for sideTable fail &quot;, e);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 176         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 177 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 178         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 179         Object pollObj = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 180 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 181         //need clean</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 182         boolean preIsSideJoin = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 183         List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 184 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 185         while((pollObj = exeQueue.poll()) != null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 186 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 187             if(pollObj instanceof SqlNode){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 188                 SqlNode pollSqlNode = (SqlNode) pollObj;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 189 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 190                 if(preIsSideJoin){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 191                     preIsSideJoin = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 192                     List&lt;String&gt; fieldNames = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 193                     for(FieldReplaceInfo replaceInfo : replaceInfoList){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 194                         fieldNames = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 195                         replaceFieldName(pollSqlNode, replaceInfo.getMappingTable(), replaceInfo.getTargetTableName(), replaceInfo.getTargetTableAlias());"> 195                         replaceFieldName(pollSqlNode, replaceInfo.getMappingTable(), replaceInfo.getTarge🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 196                         addAliasForFieldNode(pollSqlNode, fieldNames, replaceInfo.getMappingTable());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 197                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 198                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 199 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 200                 if(pollSqlNode.getKind() == INSERT){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 201                     System.out.println(&quot;----------real exec sql-----------&quot; );</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 202                     System.out.println(pollSqlNode.toString());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 203                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 204                     if(LOG.isInfoEnabled()){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 205                         LOG.info(&quot;exec sql: &quot; + pollSqlNode.toString());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 206                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 207                 }else if(pollSqlNode.getKind() == AS){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 208                     AliasInfo aliasInfo = parseASNode(pollSqlNode);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 209                     Table table = tableEnv.sqlQuery(aliasInfo.getName());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 210                     tableEnv.registerTable(aliasInfo.getAlias(), table);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 211                     localTableCache.put(aliasInfo.getAlias(), table);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 212                 } else if (pollSqlNode.getKind() == WITH_ITEM) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 213                     SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 214                     String TableAlias = sqlWithItem.name.toString();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 215                     Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 216                     tableEnv.registerTable(TableAlias, table);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 217                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 218 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 219             }else if (pollObj instanceof JoinInfo){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 220                 preIsSideJoin = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 221                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv, replaceInfoList);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 222             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 223         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 224 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 225     }</span>
 226 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 227 </span>
 228 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 229 
<abbr title=" 230     public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,"> 230     public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment 🔵</abbr>
<abbr title=" 231                      Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.SqlParserResult createView) throws Exception {"> 231                      Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.S🔵</abbr>
 232         if(localSqlPluginPath == null){
 233             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
 234         }
 235 
 236         localTableCache.putAll(tableCache);
 237         try {
 238             sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 239         } catch (Exception e) {
 240             LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 241         }
 242 
 243         if(createView != null){
 244             LOG.warn(&quot;create view info\n&quot;);
 245             LOG.warn(createView.getExecSql());
 246             LOG.warn(&quot;-----------------&quot;);
 247         }
 248 
 249         SideSQLParser sideSQLParser = new SideSQLParser();
 250         sideSQLParser.setLocalTableCache(localTableCache);
 251         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());
 252         Object pollObj = null;
 253 
 254         //need clean
 255         boolean preIsSideJoin = false;
 256         List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();
 257 
 258         while((pollObj = exeQueue.poll()) != null){
 259 
 260             if(pollObj instanceof SqlNode){
 261                 SqlNode pollSqlNode = (SqlNode) pollObj;
 262 
 263                 if(preIsSideJoin){
 264                     preIsSideJoin = false;
 265                     List&lt;String&gt; fieldNames = null;
 266                     for(FieldReplaceInfo replaceInfo : replaceInfoList){
 267                         fieldNames = Lists.newArrayList();
 268                         replaceFieldName(pollSqlNode, replaceInfo);
 269                         addAliasForFieldNode(pollSqlNode, fieldNames, replaceInfo.getMappingTable());
 270                     }
 271                 }
 272 
 273                 if(pollSqlNode.getKind() == INSERT){
 274                     System.out.println(&quot;----------real exec sql-----------&quot; );
 275                     System.out.println(pollSqlNode.toString());
 276                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);
 277                     if(LOG.isInfoEnabled()){
 278                         LOG.info(&quot;exec sql: &quot; + pollSqlNode.toString());
 279                     }
 280 
 281                 }else if(pollSqlNode.getKind() == AS){
 282                     dealAsSourceTable(tableEnv, pollSqlNode, tableCache, replaceInfoList);
 283 
 284                 } else if (pollSqlNode.getKind() == WITH_ITEM) {
 285                     SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 286                     String TableAlias = sqlWithItem.name.toString();
 287                     Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 288                     tableEnv.registerTable(TableAlias, table);
 289 
 290                 } else if (pollSqlNode.getKind() == SELECT){
<abbr title=" 291                     Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);"> 291                     Preconditions.checkState(createView != null, &quot;select sql must included by create view🔵</abbr>
 292                     Table table = tableEnv.sqlQuery(pollObj.toString());
 293 
 294                     if (createView.getFieldsInfoStr() == null){
 295                         tableEnv.registerTable(createView.getTableName(), table);
 296                     } else {
 297                         if (checkFieldsInfo(createView, table)){
 298                             table = table.as(tmpFields);
 299                             tableEnv.registerTable(createView.getTableName(), table);
 300                         } else {
 301                             throw new RuntimeException(&quot;Fields mismatch&quot;);
 302                         }
 303                     }
 304 
 305                     localTableCache.put(createView.getTableName(), table);
 306                 }
 307 
 308             }else if (pollObj instanceof JoinInfo){
 309                 System.out.println(&quot;----------exec join info----------&quot;);
 310                 System.out.println(pollObj.toString());
 311                 preIsSideJoin = true;
 312                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv, replaceInfoList);
 313             }
 314         }
 315 
 316     }
 317 
 318 
 319     /**
 320      * 解析出as查询的表和字段的关系
 321      * @param asSqlNode
 322      * @param tableCache
 323      * @return
 324      */
 325     private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 326         SqlNode info = asSqlNode.getOperands()[0];
 327         SqlNode alias = asSqlNode.getOperands()[1];
 328 
 329         SqlKind infoKind = info.getKind();
 330         if(infoKind != SELECT){
 331             return null;
 332         }
 333 
 334         List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 335 
 336         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 337         for (FieldInfo fieldInfo : extractFieldList) {
 338             String tableName = fieldInfo.getTable();
 339             String fieldName = fieldInfo.getFieldName();
 340             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 341             mappingTable.put(tableName, fieldName, mappingFieldName);
 342         }
 343 
 344         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 345         replaceInfo.setMappingTable(mappingTable);
 346         replaceInfo.setTargetTableName(alias.toString());
 347         replaceInfo.setTargetTableAlias(alias.toString());
 348         return replaceInfo;
 349     }
 350 
 351 
 352     /**
 353      * 添加字段别名
 354      * @param pollSqlNode
 355      * @param fieldList
 356      * @param mappingTable
 357      */
<abbr title=" 358     private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 358     private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String,🔵</abbr>
 359         SqlKind sqlKind = pollSqlNode.getKind();
 360         switch (sqlKind) {
 361             case INSERT:
 362                 SqlNode source = ((SqlInsert) pollSqlNode).getSource();
 363                 addAliasForFieldNode(source, fieldList, mappingTable);
 364                 break;
 365             case AS:
<abbr title=" 366                 addAliasForFieldNode(((SqlBasicCall) pollSqlNode).getOperands()[0], fieldList, mappingTable);"> 366                 addAliasForFieldNode(((SqlBasicCall) pollSqlNode).getOperands()[0], fieldList, mappingTab🔵</abbr>
 367                 break;
 368             case SELECT:
 369                 SqlNodeList selectList = ((SqlSelect) pollSqlNode).getSelectList();
 370                 selectList.getList().forEach(node -&gt; {
 371                     if (node.getKind() == IDENTIFIER) {
 372                         SqlIdentifier sqlIdentifier = (SqlIdentifier) node;
 373                         if (sqlIdentifier.names.size() == 1) {
 374                             return;
 375                         }
 376                         // save real field
 377                         String fieldName = sqlIdentifier.names.get(1);
<abbr title=" 378                         if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().containsKey(fieldName)) {"> 378                         if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap🔵</abbr>
 379                             fieldList.add(fieldName);
 380                         }
 381 
 382                     }
 383                 });
 384                 for (int i = 0; i &lt; selectList.getList().size(); i++) {
 385                     SqlNode node = selectList.get(i);
 386                     if (node.getKind() == IDENTIFIER) {
 387                         SqlIdentifier sqlIdentifier = (SqlIdentifier) node;
 388                         if (sqlIdentifier.names.size() == 1) {
 389                             return;
 390                         }
 391                         String name = sqlIdentifier.names.get(1);
 392                         // avoid real field pv0 convert pv
<abbr title=" 393                         if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring(0, name.length() - 1))) {"> 393                         if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.🔵</abbr>
 394                             SqlOperator operator = new SqlAsOperator();
 395                             SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 396 
<abbr title=" 397                             SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() - 1), null, sqlParserPos);"> 397                             SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.l🔵</abbr>
 398                             SqlNode[] sqlNodes = new SqlNode[2];
 399                             sqlNodes[0] = sqlIdentifier;
 400                             sqlNodes[1] = sqlIdentifierAlias;
<abbr title=" 401                             SqlBasicCall sqlBasicCall = new SqlBasicCall(operator, sqlNodes, sqlParserPos);"> 401                             SqlBasicCall sqlBasicCall = new SqlBasicCall(operator, sqlNodes, sqlParserPos🔵</abbr>
 402 
 403                             selectList.set(i, sqlBasicCall);
 404                         }
 405                     }
 406                 }
 407                 break;
 408             default:
 409                 break;
 410         }
 411     }
 412 
 413 
 414     public AliasInfo parseAsNode(SqlNode sqlNode) throws SqlParseException {
 415         SqlKind sqlKind = sqlNode.getKind();
 416         if(sqlKind != AS){
 417             throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 418         }
 419 
 420         SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 421         SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 422 
 423         AliasInfo aliasInfo = new AliasInfo();
 424         aliasInfo.setName(info.toString());
 425         aliasInfo.setAlias(alias.toString());
 426 
 427         return aliasInfo;
 428     }
 429 
<abbr title=" 430     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, String&gt; mappingTable){"> 430     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, Stri🔵</abbr>
 431         TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 432         String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 433         for(int i=0; i&lt;sideJoinFieldInfo.size(); i++){
 434             FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 435             String tableName = fieldInfo.getTable();
 436             String fieldName = fieldInfo.getFieldName();
 437             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 438             mappingTable.put(tableName, fieldName, mappingFieldName);
 439 
 440             sideOutTypes[i] = fieldInfo.getTypeInformation();
 441             sideOutNames[i] = mappingFieldName;
 442         }
 443         return new RowTypeInfo(sideOutTypes, sideOutNames);
 444     }
 445 
 446 
 447 
 448     /**
 449      *  对时间类型进行类型转换
 450      * @param leftTypeInfo
 451      * @return
 452      */
 453     private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 454         TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 455         TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 456         for (int i = 0; i &lt; sideOutTypes.length; i++) {
 457             sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 458         }
 459         RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 460         return rowTypeInfo;
 461     }
 462 
 463     private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 464         if (typeInformation instanceof TimeIndicatorTypeInfo) {
 465             return TypeInformation.of(LocalDateTime.class);
 466         }
 467         return typeInformation;
 468     }
 469 
 470     //需要考虑更多的情况
 471     private void replaceFieldName(SqlNode sqlNode, FieldReplaceInfo replaceInfo) {
 472         SqlKind sqlKind = sqlNode.getKind();
 473         switch (sqlKind) {
 474             case INSERT:
 475                 SqlNode sqlSource = ((SqlInsert) sqlNode).getSource();
 476                 replaceFieldName(sqlSource, replaceInfo);
 477                 break;
 478             case AS:
 479                 SqlNode asNode = ((SqlBasicCall) sqlNode).getOperands()[0];
 480                 replaceFieldName(asNode, replaceInfo);
 481                 break;
 482             case SELECT:
<abbr title=" 483                 SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTargetTableName());"> 483                 SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTarget🔵</abbr>
 484                 if(sqlSelect == null){
 485                     return;
 486                 }
 487 
 488                 SqlNode sqlSource1 = sqlSelect.getFrom();
 489                 if(sqlSource1.getKind() == AS){
 490                     String tableName = ((SqlBasicCall)sqlSource1).getOperands()[0].toString();
 491                     if(tableName.equalsIgnoreCase(replaceInfo.getTargetTableName())){
 492                         SqlNodeList sqlSelectList = sqlSelect.getSelectList();
 493                         SqlNode whereNode = sqlSelect.getWhere();
 494                         SqlNodeList sqlGroup = sqlSelect.getGroup();
 495 
 496                         //TODO 暂时不处理having
 497                         SqlNode sqlHaving = sqlSelect.getHaving();
 498 
 499                         List&lt;SqlNode&gt; newSelectNodeList = Lists.newArrayList();
 500                         for( int i=0; i&lt;sqlSelectList.getList().size(); i++){
 501                             SqlNode selectNode = sqlSelectList.getList().get(i);
 502                             //特殊处理 isStar的标识
<abbr title=" 503                             if(selectNode.getKind() == IDENTIFIER &amp;&amp; ((SqlIdentifier) selectNode).isStar()){"> 503                             if(selectNode.getKind() == IDENTIFIER &amp;&amp; ((SqlIdentifier) selectNode).isStar(🔵</abbr>
<abbr title=" 504                                 List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, replaceInfo);"> 504                                 List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, re🔵</abbr>
 505                                 newSelectNodeList.addAll(replaceNodeList);
 506                                 continue;
 507                             }
 508 
 509                             SqlNode replaceNode = replaceSelectFieldName(selectNode, replaceInfo);
 510                             if(replaceNode == null){
 511                                 continue;
 512                             }
 513 
 514                             //sqlSelectList.set(i, replaceNode);
 515                             newSelectNodeList.add(replaceNode);
 516                         }
 517 
<abbr title=" 518                         SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosition());"> 518                         SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getP🔵</abbr>
 519                         sqlSelect.setSelectList(newSelectList);
 520 
 521                         //where
 522                         if(whereNode != null){
 523                             SqlNode[] sqlNodeList = ((SqlBasicCall)whereNode).getOperands();
 524                             for(int i =0; i&lt;sqlNodeList.length; i++) {
 525                                 SqlNode whereSqlNode = sqlNodeList[i];
 526                                 SqlNode replaceNode = replaceNodeInfo(whereSqlNode, replaceInfo);
 527                                 sqlNodeList[i] = replaceNode;
 528                             }
 529                         }
 530                         if(sqlGroup != null &amp;&amp; CollectionUtils.isNotEmpty(sqlGroup.getList())){
 531                             for( int i=0; i&lt;sqlGroup.getList().size(); i++){
 532                                 SqlNode selectNode = sqlGroup.getList().get(i);
 533                                 SqlNode replaceNode = replaceNodeInfo(selectNode, replaceInfo);
 534                                 sqlGroup.set(i, replaceNode);
 535                             }
 536                         }
 537                     }
 538                 }else{
 539                     //TODO
 540                     System.out.println(sqlNode);
 541                     throw new RuntimeException(&quot;---not deal type:&quot; + sqlNode);
 542                 }
 543 
 544                 break;
 545             case UNION:
 546                 SqlNode unionLeft = ((SqlBasicCall) sqlNode).getOperands()[0];
 547                 SqlNode unionRight = ((SqlBasicCall) sqlNode).getOperands()[1];
 548                 replaceFieldName(unionLeft, replaceInfo);
 549                 replaceFieldName(unionRight, replaceInfo);
 550 
 551                 break;
 552             case ORDER_BY:
 553                 SqlOrderBy sqlOrderBy  = (SqlOrderBy) sqlNode;
 554                 replaceFieldName(sqlOrderBy.query, replaceInfo);
 555                 SqlNodeList orderFiledList = sqlOrderBy.orderList;
 556                 for (int i=0 ;i&lt;orderFiledList.size();i++) {
<abbr title=" 557                     SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTableAlias());"> 557                     SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getT🔵</abbr>
 558                     orderFiledList.set(i, replaceNode);
 559                 }
 560 
 561             default:
 562                 break;
 563         }
 564     }
 565 
 566     private SqlNode replaceOrderByTableName(SqlNode orderNode, String tableAlias) {
 567         if(orderNode.getKind() == IDENTIFIER){
 568             SqlIdentifier sqlIdentifier = (SqlIdentifier) orderNode;
 569             if (sqlIdentifier.names.size() == 1) {
 570                 return orderNode;
 571             }
 572             return sqlIdentifier.setName(0, tableAlias);
 573         } else if (orderNode instanceof  SqlBasicCall) {
 574             SqlBasicCall sqlBasicCall = (SqlBasicCall) orderNode;
 575             for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 576                 SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 577                 sqlBasicCall.getOperands()[i] = replaceOrderByTableName(sqlNode , tableAlias);
 578             }
 579             return sqlBasicCall;
 580         } else {
 581             return orderNode;
 582         }
 583     }
 584 
 585     private SqlNode replaceNodeInfo(SqlNode groupNode, FieldReplaceInfo replaceInfo){
 586         if(groupNode.getKind() == IDENTIFIER){
 587             SqlIdentifier sqlIdentifier = (SqlIdentifier) groupNode;
 588             if(sqlIdentifier.names.size() == 1){
 589                 return sqlIdentifier;
 590             }
 591 
<abbr title=" 592             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 592             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSim🔵</abbr>
 593             if(mappingFieldName == null){
 594                 throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + sqlIdentifier.toString() );
 595             }
 596 
 597             sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());
 598             return sqlIdentifier.setName(1, mappingFieldName);
 599         }else if(groupNode instanceof  SqlBasicCall){
 600             SqlBasicCall sqlBasicCall = (SqlBasicCall) groupNode;
 601             for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 602                 SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 603                 SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);
 604                 sqlBasicCall.getOperands()[i] = replaceNode;
 605             }
 606 
 607             return sqlBasicCall;
 608         }else{
 609             return groupNode;
 610         }
 611     }
 612 
 613     public SqlNode filterNodeWithTargetName(SqlNode sqlNode, String targetTableName) {
 614 
 615         SqlKind sqlKind = sqlNode.getKind();
 616         switch (sqlKind){
 617             case SELECT:
 618                 SqlNode fromNode = ((SqlSelect)sqlNode).getFrom();
<abbr title=" 619                 if(fromNode.getKind() == AS &amp;&amp; ((SqlBasicCall)fromNode).getOperands()[0].getKind() == IDENTIFIER){"> 619                 if(fromNode.getKind() == AS &amp;&amp; ((SqlBasicCall)fromNode).getOperands()[0].getKind() == IDE🔵</abbr>
<abbr title=" 620                     if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableName)){"> 620                     if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableN🔵</abbr>
 621                         return sqlNode;
 622                     }else{
 623                         return null;
 624                     }
 625                 }else{
 626                     return filterNodeWithTargetName(fromNode, targetTableName);
 627                 }
 628             case AS:
 629                 SqlNode childNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 630                 return filterNodeWithTargetName(childNode, targetTableName);
 631             case JOIN:
 632                 SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 633                 SqlNode rightNode =  ((SqlJoin)sqlNode).getRight();
 634                 SqlNode leftReturnNode = filterNodeWithTargetName(leftNode, targetTableName);
 635                 SqlNode rightReturnNode = filterNodeWithTargetName(rightNode, targetTableName);
 636 
 637                 if(leftReturnNode != null) {
 638                     return leftReturnNode;
 639                 }else if(rightReturnNode != null){
 640                     return rightReturnNode;
 641                 }else{
 642                     return null;
 643                 }
 644             default:
 645                 break;
 646         }
 647 
 648         return null;
 649     }
 650 
 651 
 652     public void setLocalSqlPluginPath(String localSqlPluginPath) {
 653         this.localSqlPluginPath = localSqlPluginPath;
 654     }
 655 
<abbr title=" 656     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){"> 656     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableNa🔵</abbr>
 657         Table table = localTableCache.get(tableAlias);
 658         if(table == null){
 659             table = localTableCache.get(tableName);
 660         }
 661 
 662         if(table == null){
 663             throw new RuntimeException(&quot;not register table &quot; + tableName);
 664         }
 665 
 666         return table;
 667     }
 668 
 669     private List&lt;SqlNode&gt; replaceSelectStarFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo){
 670         SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 671         List&lt;SqlNode&gt; sqlNodes = Lists.newArrayList();
 672         if(sqlIdentifier.isStar()){//处理 [* or table.*]
 673             int identifierSize = sqlIdentifier.names.size();
 674             Collection&lt;String&gt; columns = null;
 675             if(identifierSize == 1){
 676                 columns = replaceInfo.getMappingTable().values();
 677             }else{
 678                 columns = replaceInfo.getMappingTable().row(sqlIdentifier.names.get(0)).values();
 679             }
 680 
 681             for(String colAlias : columns){
 682                 SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 683                 List&lt;String&gt; columnInfo = Lists.newArrayList();
 684                 columnInfo.add(replaceInfo.getTargetTableAlias());
 685                 columnInfo.add(colAlias);
 686                 SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(columnInfo, sqlParserPos);
 687                 sqlNodes.add(sqlIdentifierAlias);
 688             }
 689 
 690             return sqlNodes;
 691         }else{
 692             throw new RuntimeException(&quot;is not a star select field.&quot; + selectNode);
 693         }
 694     }
 695 
 696     private SqlNode replaceSelectFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo) {
 697         if (selectNode.getKind() == AS) {
 698             SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];
 699             SqlNode replaceNode = replaceSelectFieldName(leftNode, replaceInfo);
 700             if (replaceNode != null) {
 701                 ((SqlBasicCall) selectNode).getOperands()[0] = replaceNode;
 702             }
 703 
 704             return selectNode;
 705         }else if(selectNode.getKind() == IDENTIFIER){
 706             SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 707 
 708             if(sqlIdentifier.names.size() == 1){
 709                 return selectNode;
 710             }
 711 
 712             //Same level mappingTable
<abbr title=" 713             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 713             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSim🔵</abbr>
 714             if(mappingFieldName == null){
 715                throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + selectNode.toString() );
 716             }
 717 
 718             sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());
 719             sqlIdentifier = sqlIdentifier.setName(1, mappingFieldName);
 720             return sqlIdentifier;
 721         }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//字面含义
 722             return selectNode;
 723         }else if(  AGGREGATE.contains(selectNode.getKind())
 724                 || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 725                 || COMPARISON.contains(selectNode.getKind())
 726                 || selectNode.getKind() == OTHER_FUNCTION
 727                 || selectNode.getKind() == DIVIDE
 728                 || selectNode.getKind() == CAST
 729                 || selectNode.getKind() == TRIM
 730                 || selectNode.getKind() == TIMES
 731                 || selectNode.getKind() == PLUS
 732                 || selectNode.getKind() == NOT_IN
 733                 || selectNode.getKind() == OR
 734                 || selectNode.getKind() == AND
 735                 || selectNode.getKind() == MINUS
 736                 || selectNode.getKind() == TUMBLE
 737                 || selectNode.getKind() == TUMBLE_START
 738                 || selectNode.getKind() == TUMBLE_END
 739                 || selectNode.getKind() == SESSION
 740                 || selectNode.getKind() == SESSION_START
 741                 || selectNode.getKind() == SESSION_END
 742                 || selectNode.getKind() == HOP
 743                 || selectNode.getKind() == HOP_START
 744                 || selectNode.getKind() == HOP_END
 745                 || selectNode.getKind() == BETWEEN
 746                 || selectNode.getKind() == IS_NULL
 747                 || selectNode.getKind() == IS_NOT_NULL
 748                 || selectNode.getKind() == CONTAINS
 749                 || selectNode.getKind() == TIMESTAMP_ADD
 750                 || selectNode.getKind() == TIMESTAMP_DIFF
 751                 || selectNode.getKind() == LIKE
 752 
 753                 ){
 754             SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 755             for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 756                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 757                 if(sqlNode instanceof SqlLiteral){
 758                     continue;
 759                 }
 760 
 761                 if(sqlNode instanceof SqlDataTypeSpec){
 762                     continue;
 763                 }
 764 
 765                 SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);
 766                 if(replaceNode == null){
 767                     continue;
 768                 }
 769 
 770                 sqlBasicCall.getOperands()[i] = replaceNode;
 771             }
 772 
 773             return selectNode;
 774         }else if(selectNode.getKind() == CASE){
 775             System.out.println(&quot;selectNode&quot;);
 776             SqlCase sqlCase = (SqlCase) selectNode;
 777             SqlNodeList whenOperands = sqlCase.getWhenOperands();
 778             SqlNodeList thenOperands = sqlCase.getThenOperands();
 779             SqlNode elseNode = sqlCase.getElseOperand();
 780 
 781             for(int i=0; i&lt;whenOperands.size(); i++){
 782                 SqlNode oneOperand = whenOperands.get(i);
 783                 SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);
 784                 if (replaceNode != null) {
 785                     whenOperands.set(i, replaceNode);
 786                 }
 787             }
 788 
 789             for(int i=0; i&lt;thenOperands.size(); i++){
 790                 SqlNode oneOperand = thenOperands.get(i);
 791                 SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);
 792                 if (replaceNode != null) {
 793                     thenOperands.set(i, replaceNode);
 794                 }
 795             }
 796 
 797             ((SqlCase) selectNode).setOperand(3, replaceSelectFieldName(elseNode, replaceInfo));
 798             return selectNode;
 799         }else if(selectNode.getKind() == OTHER){
 800             //不处理
 801             return selectNode;
 802         }else{
<abbr title=" 803             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 803             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, 🔵</abbr>
 804         }
 805     }
 806 
 807     /**
<abbr title=" 808      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 808      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., d🔵</abbr>
 809      *
 810      * @return
 811      */
<abbr title=" 812     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 812     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInf🔵</abbr>
 813         List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 814         if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 815             return true;
 816         }
 817         return false;
 818     }
 819 
 820     private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 821         List&lt;String&gt; res = Lists.newArrayList();
 822         sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 823             res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 824         });
 825         return res;
 826     }
 827 
<abbr title=" 828     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 828     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTa🔵</abbr>
 829         List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 830         ParseUtils.parseAnd(conditionNode, sqlNodeList);
 831         List&lt;String&gt; conditionFields = Lists.newArrayList();
 832         for(SqlNode sqlNode : sqlNodeList){
 833             if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 834                 throw new RuntimeException(&quot;not compare operator.&quot;);
 835             }
 836 
 837             SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 838             SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 839 
 840             String leftTableName = left.getComponent(0).getSimple();
 841             String rightTableName = right.getComponent(0).getSimple();
 842 
 843             String tableCol = &quot;&quot;;
 844             if(leftTableName.equalsIgnoreCase(specifyTableName)){
 845                 tableCol = left.getComponent(1).getSimple();
 846             }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 847                 tableCol = right.getComponent(1).getSimple();
 848             }else{
<abbr title=" 849                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 849                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specify🔵</abbr>
 850             }
 851             tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 852             conditionFields.add(tableCol);
 853         }
 854 
 855         return conditionFields;
 856     }
 857 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 858 public void registerTmpTable(CreateTmpTableParser.SqlParserResult result,</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 859                                  Map&lt;String, SideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,"> 859                                  Map&lt;String, SideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv🔵</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 860                                  Map&lt;String, Table&gt; tableCache)</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 861             throws Exception {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 862 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 863         if(localSqlPluginPath == null){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 864             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 865         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 866 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 867         localTableCache.putAll(tableCache);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 868         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(result.getExecSql(), sideTableMap.keySet());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 869         Object pollObj = null;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 870 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 871         //need clean</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 872         boolean preIsSideJoin = false;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 873         List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 874 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 875         while((pollObj = exeQueue.poll()) != null){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 876 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 877             if(pollObj instanceof SqlNode){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 878                 SqlNode pollSqlNode = (SqlNode) pollObj;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 879 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 880                 if(preIsSideJoin){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 881                     preIsSideJoin = false;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 882                     List&lt;String&gt; fieldNames = null;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 883                     for (FieldReplaceInfo replaceInfo : replaceInfoList) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 884                         fieldNames = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 885                         replaceFieldName(pollSqlNode, replaceInfo.getMappingTable(), replaceInfo.getTargetTableName(), replaceInfo.getTargetTableAlias());"> 885                         replaceFieldName(pollSqlNode, replaceInfo.getMappingTable(), replaceInfo.getTarge🔵</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 886                         addAliasForFieldNode(pollSqlNode, fieldNames, replaceInfo.getMappingTable());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 887                     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 888                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 889 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 890                 if(pollSqlNode.getKind() == INSERT){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 891 //                    tableEnv.sqlUpdate(pollSqlNode.toString());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 892                     FlinkSQLExec.sqlUpdate(tableEnv,pollSqlNode.toString());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 893                 }else if(pollSqlNode.getKind() == AS){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 894                     AliasInfo aliasInfo = parseASNode(pollSqlNode);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 895                     Table table = tableEnv.sqlQuery(aliasInfo.getName());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 896                     tableEnv.registerTable(aliasInfo.getAlias(), table);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 897                     if(LOG.isInfoEnabled()){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 898                         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 899                     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 900                     localTableCache.put(aliasInfo.getAlias(), table);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 901                 } else if (pollSqlNode.getKind() == SELECT){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 902                     Table table = tableEnv.sqlQuery(pollObj.toString());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 903                     if (result.getFieldsInfoStr() == null){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 904                         tableEnv.registerTable(result.getTableName(), table);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 905                     } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 906                         if (checkFieldsInfo(result, table)){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 907                             table = table.as(tmpFields);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 908                             tableEnv.registerTable(result.getTableName(), table);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 909                         } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 910                             throw new RuntimeException(&quot;Fields mismatch&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 911                         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 912                     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 913                     localTableCache.put(result.getTableName(), table);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 914 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 915                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 916 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 917             }else if (pollObj instanceof JoinInfo){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 918                 preIsSideJoin = true;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 919                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv, replaceInfoList);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 920             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 921         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 922     }</span>
 923 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 924 public void registerTmpTable(CreateTmpTableParser.SqlParserResult result,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 925                                  Map&lt;String, SideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,"> 925                                  Map&lt;String, SideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 926                                  Map&lt;String, Table&gt; tableCache)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 927             throws Exception {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 928 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 929         if(localSqlPluginPath == null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 930             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 931         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 932 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 933         localTableCache.putAll(tableCache);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 934         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(result.getExecSql(), sideTableMap.keySet());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 935         Object pollObj = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 936 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 937         //need clean</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 938         boolean preIsSideJoin = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 939         List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 940 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 941         while((pollObj = exeQueue.poll()) != null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 942 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 943             if(pollObj instanceof SqlNode){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 944                 SqlNode pollSqlNode = (SqlNode) pollObj;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 945 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 946                 if(preIsSideJoin){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 947                     preIsSideJoin = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 948                     List&lt;String&gt; fieldNames = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 949                     for (FieldReplaceInfo replaceInfo : replaceInfoList) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 950                         fieldNames = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 951                         replaceFieldName(pollSqlNode, replaceInfo.getMappingTable(), replaceInfo.getTargetTableName(), replaceInfo.getTargetTableAlias());"> 951                         replaceFieldName(pollSqlNode, replaceInfo.getMappingTable(), replaceInfo.getTarge🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 952                         addAliasForFieldNode(pollSqlNode, fieldNames, replaceInfo.getMappingTable());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 953                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 954                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 955 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 956                 if(pollSqlNode.getKind() == INSERT){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 957                     tableEnv.sqlUpdate(pollSqlNode.toString());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 958                 }else if(pollSqlNode.getKind() == AS){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 959                     AliasInfo aliasInfo = parseASNode(pollSqlNode);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 960                     Table table = tableEnv.sqlQuery(aliasInfo.getName());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 961                     tableEnv.registerTable(aliasInfo.getAlias(), table);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 962                     if(LOG.isInfoEnabled()){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 963                         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 964                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 965                     localTableCache.put(aliasInfo.getAlias(), table);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 966                 } else if (pollSqlNode.getKind() == SELECT){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 967                     Table table = tableEnv.sqlQuery(pollObj.toString());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 968                     if (result.getFieldsInfoStr() == null){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 969                         tableEnv.registerTable(result.getTableName(), table);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 970                     } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 971                         if (checkFieldsInfo(result, table)){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 972                             table = table.as(tmpFields);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 973                             tableEnv.registerTable(result.getTableName(), table);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 974                         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 975                             throw new RuntimeException(&quot;Fields mismatch&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 976                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 977                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 978                     localTableCache.put(result.getTableName(), table);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 979 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 980                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 981 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 982             }else if (pollObj instanceof JoinInfo){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 983                 preIsSideJoin = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 984                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv, replaceInfoList);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 985             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 986         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 987     }</span>
 988 =======
 989 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 990 
 991 
 992     private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache,
<abbr title=" 993                          Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,"> 993                          Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv🔵</abbr>
 994                          List&lt;FieldReplaceInfo&gt; replaceInfoList) throws Exception{
 995         JoinInfo joinInfo = (JoinInfo) pollObj;
 996 
 997         JoinScope joinScope = new JoinScope();
 998         JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 999         leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
1000         leftScopeChild.setTableName(joinInfo.getLeftTableName());
1001 
1002         SqlKind sqlKind = joinInfo.getLeftNode().getKind();
1003         if(sqlKind == AS){
1004             dealAsSourceTable(tableEnv, joinInfo.getLeftNode(), localTableCache, replaceInfoList);
1005         }
1006 
<abbr title="1007         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());">1007         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLe🔵</abbr>
<abbr title="1008         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSchema().getFieldNames());">1008         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSc🔵</abbr>
1009         leftScopeChild.setRowTypeInfo(leftTypeInfo);
1010 
1011         JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
1012         rightScopeChild.setAlias(joinInfo.getRightTableAlias());
1013         rightScopeChild.setTableName(joinInfo.getRightTableName());
1014         AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
1015         if(sideTableInfo == null){
1016             sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
1017         }
1018 
1019         if(sideTableInfo == null){
1020             throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
1021         }
1022 
1023         if(!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)){
1024             throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);
1025         }
1026 
1027         rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
1028 
1029         joinScope.addScope(leftScopeChild);
1030         joinScope.addScope(rightScopeChild);
1031 
1032         //获取两个表的所有字段
<abbr title="1033         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);">1033         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), join🔵</abbr>
1034 
1035         String leftTableAlias = joinInfo.getLeftTableAlias();
1036         Table targetTable = localTableCache.get(leftTableAlias);
1037         if(targetTable == null){
1038             targetTable = localTableCache.get(joinInfo.getLeftTableName());
1039         }
1040 
<abbr title="1041         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSchema().getFieldNames());">1041         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSc🔵</abbr>
1042 
1043 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1044         DataStream adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1045                                 .map((Tuple2&lt;Boolean, Row&gt; f0) -&gt; { return f0.f1; })</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1046                                 .returns(Row.class);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1047         //adaptStream.getTransformation().setOutputType(leftTypeInfo);</span>
1048 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1049         DataStream adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1050                                 .map((Tuple2&lt;Boolean, Row&gt; f0) -&gt; { return f0.f1; })</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1051                                 .returns(Row.class);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1052 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1053 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1054         //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1055         if(sideTableInfo.isPartitionedJoin()){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1056             RowTypeInfo leftTableOutType = buildLeftTableOutType(leftTypeInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1057             adaptStream.getTransformation().setOutputType(leftTableOutType);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="1058             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);">1058             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTa🔵</abbr></span>
1059 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title="1060         DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)">1060         DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.c🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1061                 .map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1062                     return new CRow(tp2.f1, tp2.f0);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1063                 }).returns(CRow.class);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1064 </span>
1065 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
1066 
1067         //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
1068         if(sideTableInfo.isPartitionedJoin()){
<abbr title="1069             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);">1069             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTa🔵</abbr>
1070             List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
1071             int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title="1072             adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));">1072             adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, tar🔵</abbr>
1073         }
1074 
1075         DataStream&lt;CRow&gt; dsOut = null;
1076         if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title="1077             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);">1077             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), 🔵</abbr>
1078         }else{
<abbr title="1079             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);">1079             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSq🔵</abbr>
1080         }
1081 
1082         // TODO  将嵌套表中的字段传递过去, 去除冗余的ROWtime
1083         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
1084         RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
1085 
1086         CRowTypeInfo cRowTypeInfo = new CRowTypeInfo(sideOutTypeInfo);
1087         dsOut.getTransformation().setOutputType(cRowTypeInfo);
1088 
1089         String targetTableName = joinInfo.getNewTableName();
1090         String targetTableAlias = joinInfo.getNewTableAlias();
1091 
1092         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
1093         replaceInfo.setMappingTable(mappingTable);
1094         replaceInfo.setTargetTableName(targetTableName);
1095         replaceInfo.setTargetTableAlias(targetTableAlias);
1096 
1097         //判断之前是不是被替换过,被替换过则设置之前的替换信息作为上一个节点
1098         for(FieldReplaceInfo tmp : replaceInfoList){
1099             if(tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName())
1100             ||tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableAlias())){
1101                 replaceInfo.setPreNode(tmp);
1102                 break;
1103             }
1104         }
1105 
1106         replaceInfoList.add(replaceInfo);
1107 
1108 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1109         List&lt;String&gt; registeredTableName = Arrays.asList(tableEnv.listTables());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1110         if (!registeredTableName.contains(joinInfo.getNewTableName())) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title="1111             tableEnv.registerDataStream(joinInfo.getNewTableName(), dsOut, String.join(&quot;,&quot;, sideOutTypeInfo.getFieldNames()));">1111             tableEnv.registerDataStream(joinInfo.getNewTableName(), dsOut, String.join(&quot;,&quot;, sideOutTypeIn🔵</abbr></span>
1112 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1113         if (!tableEnv.isRegistered(joinInfo.getNewTableName())){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="1114             tableEnv.registerDataStream(joinInfo.getNewTableName(), dsOut, String.join(&quot;,&quot;, sideOutTypeInfo.getFieldNames()));">1114             tableEnv.registerDataStream(joinInfo.getNewTableName(), dsOut, String.join(&quot;,&quot;, sideOutTypeIn🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1115         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1116     }</span>
1117 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1118         if (!tableEnv.isRegistered(joinInfo.getNewTableName())){</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1119             Table joinTable = tableEnv.fromDataStream(dsOut);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1120             tableEnv.registerTable(joinInfo.getNewTableName(), joinTable);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1121             localTableCache.put(joinInfo.getNewTableName(), joinTable);</span>
1122 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
1123         }
1124 
1125     }
1126 
1127     protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
1128                                      SqlNode pollSqlNode,
1129                                      Map&lt;String, Table&gt; tableCache,
1130                                      List&lt;FieldReplaceInfo&gt; replaceInfoList) throws SqlParseException {
1131 
1132         AliasInfo aliasInfo = parseAsNode(pollSqlNode);
1133         if (localTableCache.containsKey(aliasInfo.getName())) {
1134             return;
1135         }
1136 
1137         Table table = tableEnv.sqlQuery(aliasInfo.getName());
1138         tableEnv.registerTable(aliasInfo.getAlias(), table);
1139         localTableCache.put(aliasInfo.getAlias(), table);
1140 
1141         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
1142 
1143         FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
1144         if(fieldReplaceInfo == null){
1145            return;
1146         }
1147 
1148         //as 的源表
1149         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
1150         SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];
1151         TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
1152         for(FieldReplaceInfo tmp : replaceInfoList){
1153             if(fromTableNameSet.contains(tmp.getTargetTableName())
1154                     || fromTableNameSet.contains(tmp.getTargetTableAlias())){
1155                 fieldReplaceInfo.setPreNode(tmp);
1156                 break;
1157             }
1158         }
1159         replaceInfoList.add(fieldReplaceInfo);
1160     }
1161 
1162     private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
1163         String[] fieldNames = schema.getFieldNames();
1164         TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
1165 
<abbr title="1166         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);">1166         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::ne🔵</abbr>
<abbr title="1167         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);">1167         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(Typ🔵</abbr>
1168         return new RowTypeInfo(projectedTypes, projectedNames);
1169     }
1170 
1171     private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
1172         List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
1173         String fieldsInfo = result.getFieldsInfoStr();
1174         String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
1175         for (int i = 0; i &lt; fields.length; i++) {
1176             String[] filed = fields[i].split(&quot;\\s&quot;);
1177             if (filed.length &lt; 2 || fields.length != table.getSchema().getFieldNames().length){
1178                 return false;
1179             } else {
1180                 String[] filedNameArr = new String[filed.length - 1];
1181                 System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
1182                 String fieldName = String.join(&quot; &quot;, filedNameArr);
1183                 fieldNames.add(fieldName);
1184                 String fieldType = filed[filed.length - 1 ].trim();
1185                 Class fieldClass = ClassUtil.stringConvertClass(fieldType);
1186                 Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
1187                 if (fieldClass == tableField){
1188                     continue;
1189                 } else {
1190                     return false;
1191                 }
1192             }
1193         }
1194         tmpFields = String.join(&quot;,&quot;, fieldNames);
1195         return true;
1196     }
1197 
1198 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side;
  19 
  20 import com.dtstack.flink.sql.enums.ECacheType;
  21 import com.dtstack.flink.sql.exec.FlinkSQLExec;
  22 import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  23 import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  24 import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  25 import com.dtstack.flink.sql.util.ClassUtil;
  26 import com.dtstack.flink.sql.util.ParseUtils;
  27 import com.dtstack.flink.sql.util.TableUtils;
  28 import com.google.common.base.Preconditions;
  29 import com.google.common.collect.HashBasedTable;
  30 import com.google.common.collect.Lists;
  31 import com.google.common.collect.Maps;
  32 import com.google.common.collect.Sets;
  33 import java.sql.Timestamp;
  34 import java.time.LocalDateTime;
  35 import java.util.Arrays;
  36 import java.util.Collection;
  37 import java.util.LinkedList;
  38 import java.util.List;
  39 import java.util.Map;
  40 import java.util.Queue;
  41 import java.util.Set;
  42 import org.apache.calcite.sql.SqlAsOperator;
  43 import org.apache.calcite.sql.SqlBasicCall;
  44 import org.apache.calcite.sql.SqlDataTypeSpec;
  45 import org.apache.calcite.sql.SqlIdentifier;
  46 import org.apache.calcite.sql.SqlInsert;
  47 import org.apache.calcite.sql.SqlJoin;
  48 import org.apache.calcite.sql.SqlKind;
  49 import org.apache.calcite.sql.SqlLiteral;
  50 import org.apache.calcite.sql.SqlNode;
  51 import org.apache.calcite.sql.SqlNodeList;
  52 import org.apache.calcite.sql.SqlOperator;
  53 import org.apache.calcite.sql.SqlOrderBy;
  54 import org.apache.calcite.sql.SqlSelect;
  55 import org.apache.calcite.sql.SqlWithItem;
  56 import org.apache.calcite.sql.fun.SqlCase;
  57 import org.apache.calcite.sql.parser.SqlParseException;
  58 import org.apache.calcite.sql.parser.SqlParserPos;
  59 import org.apache.commons.collections.CollectionUtils;
  60 import org.apache.commons.lang3.StringUtils;
  61 import org.apache.flink.api.common.typeinfo.TypeInformation;
  62 import org.apache.flink.api.java.tuple.Tuple2;
  63 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  64 import org.apache.flink.streaming.api.datastream.DataStream;
  65 import org.apache.flink.table.api.Table;
  66 import org.apache.flink.table.api.TableSchema;
  67 import org.apache.flink.table.api.java.StreamTableEnvironment;
  68 import org.apache.flink.table.runtime.CRowKeySelector;
  69 import org.apache.flink.table.runtime.types.CRow;
  70 import org.apache.flink.table.runtime.types.CRowTypeInfo;
  71 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  72 import org.apache.flink.types.Row;
  73 import org.slf4j.Logger;
  74 import org.slf4j.LoggerFactory;
  75 import static org.apache.calcite.sql.SqlKind.*;
  76 
  77 
  78 /**
  79  * Reason:
  80  * Date: 2018/7/24
  81  * Company: www.dtstack.com
  82  * @author xuchao
  83  */
  84 public class SideSqlExec {
  85     private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  86 
  87     private String localSqlPluginPath = null;
  88 
  89     private String tmpFields = null;
  90 
  91     private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  92 
  93     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  94 
<abbr title="  95     public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv, Map&lt;String, Table&gt; tableCache) throws Exception {">  95     public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment 🔵</abbr>
  96         if (localSqlPluginPath == null) {
  97             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
  98         }
  99         localTableCache.putAll(tableCache);
 100         try {
 101             sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 102         } catch (java.lang.Exception e) {
 103             LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 104         }
 105         if (createView != null) {
 106             LOG.warn(&quot;create view info\n&quot;);
 107             LOG.warn(createView.getExecSql());
 108             LOG.warn(&quot;-----------------&quot;);
 109         }
 110         SideSQLParser sideSQLParser = new SideSQLParser();
 111         sideSQLParser.setLocalTableCache(localTableCache);
 112         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());
 113         Object pollObj = null;
 114         // need clean
 115         boolean preIsSideJoin = false;
 116         List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();
 117         while ((pollObj = exeQueue.poll()) != null) {
 118             if (pollObj instanceof SqlNode) {
 119                 SqlNode pollSqlNode = ((SqlNode) (pollObj));
 120                 if (preIsSideJoin) {
 121                     preIsSideJoin = false;
 122                     List&lt;String&gt; fieldNames = null;
 123                     for (FieldReplaceInfo replaceInfo : replaceInfoList) {
 124                         fieldNames = Lists.newArrayList();
 125                         replaceFieldName(pollSqlNode, replaceInfo);
 126                         addAliasForFieldNode(pollSqlNode, fieldNames, replaceInfo.getMappingTable());
 127                     }
 128                 }
 129                 if (pollSqlNode.getKind() == INSERT) {
 130                     System.out.println(&quot;----------real exec sql-----------&quot;);
 131                     System.out.println(pollSqlNode.toString());
 132                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString());
 133                     if (LOG.isInfoEnabled()) {
 134                         LOG.info(&quot;exec sql: &quot; + pollSqlNode.toString());
 135                     }
 136                 } else if (pollSqlNode.getKind() == AS) {
 137                     dealAsSourceTable(tableEnv, pollSqlNode, tableCache, replaceInfoList);
 138                 } else if (pollSqlNode.getKind() == WITH_ITEM) {
 139                     SqlWithItem sqlWithItem = ((SqlWithItem) (pollSqlNode));
 140                     String TableAlias = sqlWithItem.name.toString();
 141                     Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 142                     tableEnv.registerTable(TableAlias, table);
 143                 } else if (pollSqlNode.getKind() == SELECT) {
<abbr title=" 144                     Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);"> 144                     Preconditions.checkState(createView != null, &quot;select sql must included by create view🔵</abbr>
 145                     Table table = tableEnv.sqlQuery(pollObj.toString());
 146                     if (createView.getFieldsInfoStr() == null) {
 147                         tableEnv.registerTable(createView.getTableName(), table);
 148                     } else if (checkFieldsInfo(createView, table)) {
 149                         table = table.as(tmpFields);
 150                         tableEnv.registerTable(createView.getTableName(), table);
 151                     } else {
 152                         throw new RuntimeException(&quot;Fields mismatch&quot;);
 153                     }
 154                     localTableCache.put(createView.getTableName(), table);
 155                 }
 156             } else if (pollObj instanceof JoinInfo) {
 157                 System.out.println(&quot;----------exec join info----------&quot;);
 158                 System.out.println(pollObj.toString());
 159                 preIsSideJoin = true;
 160                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv, replaceInfoList);
 161             }
 162         }
 163     }
 164 
 165     /**
 166      * 解析出as查询的表和字段的关系
 167      * @param asSqlNode
 168      * @param tableCache
 169      * @return
 170      */
 171     private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache) {
 172         SqlNode info = asSqlNode.getOperands()[0];
 173         SqlNode alias = asSqlNode.getOperands()[1];
 174         SqlKind infoKind = info.getKind();
 175         if (infoKind != SELECT) {
 176             return null;
 177         }
<abbr title=" 178         List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField(((SqlSelect) (info)), tableCache);"> 178         List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField(((SqlSelect) (info)), tableCache)🔵</abbr>
 179         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 180         for (FieldInfo fieldInfo : extractFieldList) {
 181             String tableName = fieldInfo.getTable();
 182             String fieldName = fieldInfo.getFieldName();
 183             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 184             mappingTable.put(tableName, fieldName, mappingFieldName);
 185         }
 186         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 187         replaceInfo.setMappingTable(mappingTable);
 188         replaceInfo.setTargetTableName(alias.toString());
 189         replaceInfo.setTargetTableAlias(alias.toString());
 190         return replaceInfo;
 191     }
 192 
 193     /**
 194      * 添加字段别名
 195      * @param pollSqlNode
 196      * @param fieldList
 197      * @param mappingTable
 198      */
<abbr title=" 199     private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 199     private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String,🔵</abbr>
 200         SqlKind sqlKind = pollSqlNode.getKind();
 201         switch (sqlKind) {
 202             case INSERT :
 203                 SqlNode source = ((SqlInsert) (pollSqlNode)).getSource();
 204                 addAliasForFieldNode(source, fieldList, mappingTable);
 205                 break;
 206             case AS :
<abbr title=" 207                 addAliasForFieldNode(((SqlBasicCall) (pollSqlNode)).getOperands()[0], fieldList, mappingTable);"> 207                 addAliasForFieldNode(((SqlBasicCall) (pollSqlNode)).getOperands()[0], fieldList, mappingT🔵</abbr>
 208                 break;
 209             case SELECT :
 210                 SqlNodeList selectList = ((SqlSelect) (pollSqlNode)).getSelectList();
 211                 selectList.getList().forEach(( node) -&gt; {
 212                     if (node.getKind() == IDENTIFIER) {
 213                         SqlIdentifier sqlIdentifier = ((SqlIdentifier) (node));
 214                         if (sqlIdentifier.names.size() == 1) {
 215                             return;
 216                         }
 217                         // save real field
 218                         String fieldName = sqlIdentifier.names.get(1);
<abbr title=" 219                         if ((!fieldName.endsWith(&quot;0&quot;)) || (fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().containsKey(fieldName))) {"> 219                         if ((!fieldName.endsWith(&quot;0&quot;)) || (fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.column🔵</abbr>
 220                             fieldList.add(fieldName);
 221                         }
 222                     }
 223                 });
 224                 for (int i = 0; i &lt; selectList.getList().size(); i++) {
 225                     SqlNode node = selectList.get(i);
 226                     if (node.getKind() == IDENTIFIER) {
 227                         SqlIdentifier sqlIdentifier = ((SqlIdentifier) (node));
 228                         if (sqlIdentifier.names.size() == 1) {
 229                             return;
 230                         }
 231                         String name = sqlIdentifier.names.get(1);
 232                         // avoid real field pv0 convert pv
<abbr title=" 233                         if ((name.endsWith(&quot;0&quot;) &amp;&amp; (!fieldList.contains(name))) &amp;&amp; (!fieldList.contains(name.substring(0, name.length() - 1)))) {"> 233                         if ((name.endsWith(&quot;0&quot;) &amp;&amp; (!fieldList.contains(name))) &amp;&amp; (!fieldList.contains(n🔵</abbr>
 234                             SqlOperator operator = new SqlAsOperator();
 235                             SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
<abbr title=" 236                             SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() - 1), null, sqlParserPos);"> 236                             SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.l🔵</abbr>
 237                             SqlNode[] sqlNodes = new SqlNode[2];
 238                             sqlNodes[0] = sqlIdentifier;
 239                             sqlNodes[1] = sqlIdentifierAlias;
<abbr title=" 240                             SqlBasicCall sqlBasicCall = new SqlBasicCall(operator, sqlNodes, sqlParserPos);"> 240                             SqlBasicCall sqlBasicCall = new SqlBasicCall(operator, sqlNodes, sqlParserPos🔵</abbr>
 241                             selectList.set(i, sqlBasicCall);
 242                         }
 243                     }
 244                 }
 245                 break;
 246             default :
 247                 break;
 248         }
 249     }
 250 
 251     public AliasInfo parseAsNode(SqlNode sqlNode) throws SqlParseException {
 252         SqlKind sqlKind = sqlNode.getKind();
 253         if (sqlKind != AS) {
 254             throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 255         }
 256         SqlNode info = ((SqlBasicCall) (sqlNode)).getOperands()[0];
 257         SqlNode alias = ((SqlBasicCall) (sqlNode)).getOperands()[1];
 258         AliasInfo aliasInfo = new AliasInfo();
 259         aliasInfo.setName(info.toString());
 260         aliasInfo.setAlias(alias.toString());
 261         return aliasInfo;
 262     }
 263 
<abbr title=" 264     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 264     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, Stri🔵</abbr>
 265         TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 266         String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 267         for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 268             FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 269             String tableName = fieldInfo.getTable();
 270             String fieldName = fieldInfo.getFieldName();
 271             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 272             mappingTable.put(tableName, fieldName, mappingFieldName);
 273             sideOutTypes[i] = fieldInfo.getTypeInformation();
 274             sideOutNames[i] = mappingFieldName;
 275         }
 276         return new RowTypeInfo(sideOutTypes, sideOutNames);
 277     }
 278 
 279     /**
 280      *  对时间类型进行类型转换
 281      * @param leftTypeInfo
 282      * @return
 283      */
 284     private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 285         TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 286         TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 287         for (int i = 0; i &lt; sideOutTypes.length; i++) {
 288             sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 289         }
 290         RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 291         return rowTypeInfo;
 292     }
 293 
 294     private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 295         if (typeInformation instanceof TimeIndicatorTypeInfo) {
 296             return TypeInformation.of(LocalDateTime.class);
 297         }
 298         return typeInformation;
 299     }
 300 
 301     //需要考虑更多的情况
 302     private void replaceFieldName(SqlNode sqlNode, FieldReplaceInfo replaceInfo) {
 303         SqlKind sqlKind = sqlNode.getKind();
 304         switch (sqlKind) {
 305             case INSERT :
 306                 SqlNode sqlSource = ((SqlInsert) (sqlNode)).getSource();
 307                 replaceFieldName(sqlSource, replaceInfo);
 308                 break;
 309             case AS :
 310                 SqlNode asNode = ((SqlBasicCall) (sqlNode)).getOperands()[0];
 311                 replaceFieldName(asNode, replaceInfo);
 312                 break;
 313             case SELECT :
<abbr title=" 314                 SqlSelect sqlSelect = ((SqlSelect) (filterNodeWithTargetName(sqlNode, replaceInfo.getTargetTableName())));"> 314                 SqlSelect sqlSelect = ((SqlSelect) (filterNodeWithTargetName(sqlNode, replaceInfo.getTarg🔵</abbr>
 315                 if (sqlSelect == null) {
 316                     return;
 317                 }
 318                 SqlNode sqlSource1 = sqlSelect.getFrom();
 319                 if (sqlSource1.getKind() == AS) {
 320                     String tableName = ((SqlBasicCall) (sqlSource1)).getOperands()[0].toString();
 321                     if (tableName.equalsIgnoreCase(replaceInfo.getTargetTableName())) {
 322                         SqlNodeList sqlSelectList = sqlSelect.getSelectList();
 323                         SqlNode whereNode = sqlSelect.getWhere();
 324                         SqlNodeList sqlGroup = sqlSelect.getGroup();
 325                         // TODO 暂时不处理having
 326                         SqlNode sqlHaving = sqlSelect.getHaving();
 327                         List&lt;SqlNode&gt; newSelectNodeList = Lists.newArrayList();
 328                         for (int i = 0; i &lt; sqlSelectList.getList().size(); i++) {
 329                             SqlNode selectNode = sqlSelectList.getList().get(i);
 330                             //特殊处理 isStar的标识
<abbr title=" 331                             if ((selectNode.getKind() == IDENTIFIER) &amp;&amp; ((SqlIdentifier) (selectNode)).isStar()) {"> 331                             if ((selectNode.getKind() == IDENTIFIER) &amp;&amp; ((SqlIdentifier) (selectNode)).is🔵</abbr>
<abbr title=" 332                                 List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, replaceInfo);"> 332                                 List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, re🔵</abbr>
 333                                 newSelectNodeList.addAll(replaceNodeList);
 334                                 continue;
 335                             }
 336                             SqlNode replaceNode = replaceSelectFieldName(selectNode, replaceInfo);
 337                             if (replaceNode == null) {
 338                                 continue;
 339                             }
 340                             // sqlSelectList.set(i, replaceNode);
 341                             newSelectNodeList.add(replaceNode);
 342                         }
<abbr title=" 343                         SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosition());"> 343                         SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getP🔵</abbr>
 344                         sqlSelect.setSelectList(newSelectList);
 345                         //where
 346                         if (whereNode != null) {
 347                             SqlNode[] sqlNodeList = ((SqlBasicCall) (whereNode)).getOperands();
 348                             for (int i = 0; i &lt; sqlNodeList.length; i++) {
 349                                 SqlNode whereSqlNode = sqlNodeList[i];
 350                                 SqlNode replaceNode = replaceNodeInfo(whereSqlNode, replaceInfo);
 351                                 sqlNodeList[i] = replaceNode;
 352                             }
 353                         }
 354                         if ((sqlGroup != null) &amp;&amp; CollectionUtils.isNotEmpty(sqlGroup.getList())) {
 355                             for (int i = 0; i &lt; sqlGroup.getList().size(); i++) {
 356                                 SqlNode selectNode = sqlGroup.getList().get(i);
 357                                 SqlNode replaceNode = replaceNodeInfo(selectNode, replaceInfo);
 358                                 sqlGroup.set(i, replaceNode);
 359                             }
 360                         }
 361                     }
 362                 } else {
 363                     // TODO
 364                     System.out.println(sqlNode);
 365                     throw new RuntimeException(&quot;---not deal type:&quot; + sqlNode);
 366                 }
 367                 break;
 368             case UNION :
 369                 SqlNode unionLeft = ((SqlBasicCall) (sqlNode)).getOperands()[0];
 370                 SqlNode unionRight = ((SqlBasicCall) (sqlNode)).getOperands()[1];
 371                 replaceFieldName(unionLeft, replaceInfo);
 372                 replaceFieldName(unionRight, replaceInfo);
 373                 break;
 374             case ORDER_BY :
 375                 SqlOrderBy sqlOrderBy = ((SqlOrderBy) (sqlNode));
 376                 replaceFieldName(sqlOrderBy.query, replaceInfo);
 377                 SqlNodeList orderFiledList = sqlOrderBy.orderList;
 378                 for (int i = 0; i &lt; orderFiledList.size(); i++) {
<abbr title=" 379                     SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTableAlias());"> 379                     SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getT🔵</abbr>
 380                     orderFiledList.set(i, replaceNode);
 381                 }
 382             default :
 383                 break;
 384         }
 385     }
 386 
 387     private SqlNode replaceOrderByTableName(SqlNode orderNode, String tableAlias) {
 388         if(orderNode.getKind() == IDENTIFIER){
 389             SqlIdentifier sqlIdentifier = (SqlIdentifier) orderNode;
 390             if (sqlIdentifier.names.size() == 1) {
 391                 return orderNode;
 392             }
 393             return sqlIdentifier.setName(0, tableAlias);
 394         } else if (orderNode instanceof  SqlBasicCall) {
 395             SqlBasicCall sqlBasicCall = (SqlBasicCall) orderNode;
 396             for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 397                 SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 398                 sqlBasicCall.getOperands()[i] = replaceOrderByTableName(sqlNode , tableAlias);
 399             }
 400             return sqlBasicCall;
 401         } else {
 402             return orderNode;
 403         }
 404     }
 405 
 406     private SqlNode replaceNodeInfo(SqlNode groupNode, FieldReplaceInfo replaceInfo) {
 407         if (groupNode.getKind() == IDENTIFIER) {
 408             SqlIdentifier sqlIdentifier = ((SqlIdentifier) (groupNode));
 409             if (sqlIdentifier.names.size() == 1) {
 410                 return sqlIdentifier;
 411             }
<abbr title=" 412             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 412             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSim🔵</abbr>
 413             if (mappingFieldName == null) {
 414                 throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + sqlIdentifier.toString());
 415             }
 416             sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());
 417             return sqlIdentifier.setName(1, mappingFieldName);
 418         } else if (groupNode instanceof SqlBasicCall) {
 419             SqlBasicCall sqlBasicCall = ((SqlBasicCall) (groupNode));
 420             for (int i = 0; i &lt; sqlBasicCall.getOperandList().size(); i++) {
 421                 SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 422                 SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);
 423                 sqlBasicCall.getOperands()[i] = replaceNode;
 424             }
 425             return sqlBasicCall;
 426         } else {
 427             return groupNode;
 428         }
 429     }
 430 
 431     public SqlNode filterNodeWithTargetName(SqlNode sqlNode, String targetTableName) {
 432         SqlKind sqlKind = sqlNode.getKind();
 433         switch (sqlKind) {
 434             case SELECT :
 435                 SqlNode fromNode = ((SqlSelect) (sqlNode)).getFrom();
<abbr title=" 436                 if ((fromNode.getKind() == AS) &amp;&amp; (((SqlBasicCall) (fromNode)).getOperands()[0].getKind() == IDENTIFIER)) {"> 436                 if ((fromNode.getKind() == AS) &amp;&amp; (((SqlBasicCall) (fromNode)).getOperands()[0].getKind()🔵</abbr>
<abbr title=" 437                     if (((SqlBasicCall) (fromNode)).getOperands()[0].toString().equalsIgnoreCase(targetTableName)) {"> 437                     if (((SqlBasicCall) (fromNode)).getOperands()[0].toString().equalsIgnoreCase(targetTa🔵</abbr>
 438                         return sqlNode;
 439                     } else {
 440                         return null;
 441                     }
 442                 } else {
 443                     return filterNodeWithTargetName(fromNode, targetTableName);
 444                 }
 445             case AS :
 446                 SqlNode childNode = ((SqlBasicCall) (sqlNode)).getOperands()[0];
 447                 return filterNodeWithTargetName(childNode, targetTableName);
 448             case JOIN :
 449                 SqlNode leftNode = ((SqlJoin) (sqlNode)).getLeft();
 450                 SqlNode rightNode = ((SqlJoin) (sqlNode)).getRight();
 451                 SqlNode leftReturnNode = filterNodeWithTargetName(leftNode, targetTableName);
 452                 SqlNode rightReturnNode = filterNodeWithTargetName(rightNode, targetTableName);
 453                 if (leftReturnNode != null) {
 454                     return leftReturnNode;
 455                 } else if (rightReturnNode != null) {
 456                     return rightReturnNode;
 457                 } else {
 458                     return null;
 459                 }
 460             default :
 461                 break;
 462         }
 463         return null;
 464     }
 465 
 466     public void setLocalSqlPluginPath(String localSqlPluginPath) {
 467         this.localSqlPluginPath = localSqlPluginPath;
 468     }
 469 
<abbr title=" 470     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){"> 470     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableNa🔵</abbr>
 471         Table table = localTableCache.get(tableAlias);
 472         if(table == null){
 473             table = localTableCache.get(tableName);
 474         }
 475 
 476         if(table == null){
 477             throw new RuntimeException(&quot;not register table &quot; + tableName);
 478         }
 479 
 480         return table;
 481     }
 482 
 483     private List&lt;SqlNode&gt; replaceSelectStarFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo) {
 484         SqlIdentifier sqlIdentifier = ((SqlIdentifier) (selectNode));
 485         List&lt;SqlNode&gt; sqlNodes = Lists.newArrayList();
 486         if (sqlIdentifier.isStar()) {
 487             // 处理 [* or table.*]
 488             int identifierSize = sqlIdentifier.names.size();
 489             Collection&lt;String&gt; columns = null;
 490             if (identifierSize == 1) {
 491                 columns = replaceInfo.getMappingTable().values();
 492             } else {
 493                 columns = replaceInfo.getMappingTable().row(sqlIdentifier.names.get(0)).values();
 494             }
 495             for (String colAlias : columns) {
 496                 SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 497                 List&lt;String&gt; columnInfo = Lists.newArrayList();
 498                 columnInfo.add(replaceInfo.getTargetTableAlias());
 499                 columnInfo.add(colAlias);
 500                 SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(columnInfo, sqlParserPos);
 501                 sqlNodes.add(sqlIdentifierAlias);
 502             }
 503             return sqlNodes;
 504         } else {
 505             throw new RuntimeException(&quot;is not a star select field.&quot; + selectNode);
 506         }
 507     }
 508 
 509     private SqlNode replaceSelectFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo) {
 510         if (selectNode.getKind() == AS) {
 511             SqlNode leftNode = ((SqlBasicCall) (selectNode)).getOperands()[0];
 512             SqlNode replaceNode = replaceSelectFieldName(leftNode, replaceInfo);
 513             if (replaceNode != null) {
 514                 ((SqlBasicCall) (selectNode)).getOperands()[0] = replaceNode;
 515             }
 516             return selectNode;
 517         } else if (selectNode.getKind() == IDENTIFIER) {
 518             SqlIdentifier sqlIdentifier = ((SqlIdentifier) (selectNode));
 519             if (sqlIdentifier.names.size() == 1) {
 520                 return selectNode;
 521             }
 522             //Same level mappingTable
<abbr title=" 523             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 523             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSim🔵</abbr>
 524             if (mappingFieldName == null) {
 525                 throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + selectNode.toString());
 526             }
 527             sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());
 528             sqlIdentifier = sqlIdentifier.setName(1, mappingFieldName);
 529             return sqlIdentifier;
 530         } else if ((selectNode.getKind() == LITERAL) || (selectNode.getKind() == LITERAL_CHAIN)) {
 531             // 字面含义
 532             return selectNode;
<abbr title=" 533         } else if ((((((((((((((((((((((((((((AGGREGATE.contains(selectNode.getKind()) || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())) || COMPARISON.contains(selectNode.getKind())) || (selectNode.getKind() == OTHER_FUNCTION)) || (selectNode.getKind() == DIVIDE)) || (selectNode.getKind() == CAST)) || (selectNode.getKind() == TRIM)) || (selectNode.getKind() == TIMES)) || (selectNode.getKind() == PLUS)) || (selectNode.getKind() == NOT_IN)) || (selectNode.getKind() == OR)) || (selectNode.getKind() == AND)) || (selectNode.getKind() == MINUS)) || (selectNode.getKind() == TUMBLE)) || (selectNode.getKind() == TUMBLE_START)) || (selectNode.getKind() == TUMBLE_END)) || (selectNode.getKind() == SESSION)) || (selectNode.getKind() == SESSION_START)) || (selectNode.getKind() == SESSION_END)) || (selectNode.getKind() == HOP)) || (selectNode.getKind() == HOP_START)) || (selectNode.getKind() == HOP_END)) || (selectNode.getKind() == BETWEEN)) || (selectNode.getKind() == IS_NULL)) || (selectNode.getKind() == IS_NOT_NULL)) || (selectNode.getKind() == CONTAINS)) || (selectNode.getKind() == TIMESTAMP_ADD)) || (selectNode.getKind() == TIMESTAMP_DIFF)) || (selectNode.getKind() == LIKE)) {"> 533         } else if ((((((((((((((((((((((((((((AGGREGATE.contains(selectNode.getKind()) || AVG_AGG_FUNCTIO🔵</abbr>
 534             SqlBasicCall sqlBasicCall = ((SqlBasicCall) (selectNode));
 535             for (int i = 0; i &lt; sqlBasicCall.getOperands().length; i++) {
 536                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 537                 if (sqlNode instanceof SqlLiteral) {
 538                     continue;
 539                 }
 540                 if (sqlNode instanceof SqlDataTypeSpec) {
 541                     continue;
 542                 }
 543                 SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);
 544                 if (replaceNode == null) {
 545                     continue;
 546                 }
 547                 sqlBasicCall.getOperands()[i] = replaceNode;
 548             }
 549             return selectNode;
 550         } else if (selectNode.getKind() == CASE) {
 551             System.out.println(&quot;selectNode&quot;);
 552             SqlCase sqlCase = ((SqlCase) (selectNode));
 553             SqlNodeList whenOperands = sqlCase.getWhenOperands();
 554             SqlNodeList thenOperands = sqlCase.getThenOperands();
 555             SqlNode elseNode = sqlCase.getElseOperand();
 556             for (int i = 0; i &lt; whenOperands.size(); i++) {
 557                 SqlNode oneOperand = whenOperands.get(i);
 558                 SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);
 559                 if (replaceNode != null) {
 560                     whenOperands.set(i, replaceNode);
 561                 }
 562             }
 563             for (int i = 0; i &lt; thenOperands.size(); i++) {
 564                 SqlNode oneOperand = thenOperands.get(i);
 565                 SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);
 566                 if (replaceNode != null) {
 567                     thenOperands.set(i, replaceNode);
 568                 }
 569             }
 570             ((SqlCase) (selectNode)).setOperand(3, replaceSelectFieldName(elseNode, replaceInfo));
 571             return selectNode;
 572         } else if (selectNode.getKind() == OTHER) {
 573             // 不处理
 574             return selectNode;
 575         } else {
<abbr title=" 576             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 576             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, 🔵</abbr>
 577         }
 578     }
 579 
 580     /**
<abbr title=" 581      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 581      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., d🔵</abbr>
 582      *
 583      * @return
 584      */
<abbr title=" 585     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 585     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInf🔵</abbr>
 586         List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 587         if (CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))) {
 588             return true;
 589         }
 590         return false;
 591     }
 592 
 593     private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 594         List&lt;String&gt; res = Lists.newArrayList();
 595         sideTableInfo.getPrimaryKeys().forEach(( field) -&gt; {
 596             res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 597         });
 598         return res;
 599     }
 600 
<abbr title=" 601     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo) {"> 601     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTa🔵</abbr>
 602         List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 603         ParseUtils.parseAnd(conditionNode, sqlNodeList);
 604         List&lt;String&gt; conditionFields = Lists.newArrayList();
 605         for (SqlNode sqlNode : sqlNodeList) {
 606             if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 607                 throw new RuntimeException(&quot;not compare operator.&quot;);
 608             }
 609             SqlIdentifier left = ((SqlIdentifier) (((SqlBasicCall) (sqlNode)).getOperands()[0]));
 610             SqlIdentifier right = ((SqlIdentifier) (((SqlBasicCall) (sqlNode)).getOperands()[1]));
 611             String leftTableName = left.getComponent(0).getSimple();
 612             String rightTableName = right.getComponent(0).getSimple();
 613             String tableCol = &quot;&quot;;
 614             if (leftTableName.equalsIgnoreCase(specifyTableName)) {
 615                 tableCol = left.getComponent(1).getSimple();
 616             } else if (rightTableName.equalsIgnoreCase(specifyTableName)) {
 617                 tableCol = right.getComponent(1).getSimple();
 618             } else {
<abbr title=" 619                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 619                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specify🔵</abbr>
 620             }
 621             tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 622             conditionFields.add(tableCol);
 623         }
 624         return conditionFields;
 625     }
 626 
<abbr title=" 627     protected void dealAsSourceTable(StreamTableEnvironment tableEnv, SqlNode pollSqlNode, Map&lt;String, Table&gt; tableCache, List&lt;FieldReplaceInfo&gt; replaceInfoList) throws SqlParseException {"> 627     protected void dealAsSourceTable(StreamTableEnvironment tableEnv, SqlNode pollSqlNode, Map&lt;String, Ta🔵</abbr>
 628         AliasInfo aliasInfo = parseAsNode(pollSqlNode);
 629         if (localTableCache.containsKey(aliasInfo.getName())) {
 630             return;
 631         }
 632         Table table = tableEnv.sqlQuery(aliasInfo.getName());
 633         tableEnv.registerTable(aliasInfo.getAlias(), table);
 634         localTableCache.put(aliasInfo.getAlias(), table);
 635         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 636         FieldReplaceInfo fieldReplaceInfo = parseAsQuery(((SqlBasicCall) (pollSqlNode)), tableCache);
 637         if (fieldReplaceInfo == null) {
 638             return;
 639         }
 640         // as 的源表
 641         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 642         SqlNode fromNode = ((SqlBasicCall) (pollSqlNode)).getOperands()[0];
 643         TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 644         for (FieldReplaceInfo tmp : replaceInfoList) {
<abbr title=" 645             if (fromTableNameSet.contains(tmp.getTargetTableName()) || fromTableNameSet.contains(tmp.getTargetTableAlias())) {"> 645             if (fromTableNameSet.contains(tmp.getTargetTableName()) || fromTableNameSet.contains(tmp.getT🔵</abbr>
 646                 fieldReplaceInfo.setPreNode(tmp);
 647                 break;
 648             }
 649         }
 650         replaceInfoList.add(fieldReplaceInfo);
 651     }
 652 
<abbr title=" 653     private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv, List&lt;FieldReplaceInfo&gt; replaceInfoList) throws Exception {"> 653     private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache, Map&lt;String, AbstractSideTabl🔵</abbr>
 654         JoinInfo joinInfo = ((JoinInfo) (pollObj));
 655         JoinScope joinScope = new JoinScope();
 656         JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 657         leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 658         leftScopeChild.setTableName(joinInfo.getLeftTableName());
 659         SqlKind sqlKind = joinInfo.getLeftNode().getKind();
 660         if (sqlKind == AS) {
 661             dealAsSourceTable(tableEnv, joinInfo.getLeftNode(), localTableCache, replaceInfoList);
 662         }
<abbr title=" 663         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 663         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLe🔵</abbr>
<abbr title=" 664         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSchema().getFieldNames());"> 664         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSc🔵</abbr>
 665         leftScopeChild.setRowTypeInfo(leftTypeInfo);
 666         JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 667         rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 668         rightScopeChild.setTableName(joinInfo.getRightTableName());
 669         AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 670         if (sideTableInfo == null) {
 671             sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 672         }
 673         if (sideTableInfo == null) {
 674             throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 675         }
 676         if (!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)) {
 677             throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);
 678         }
 679         rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 680         joinScope.addScope(leftScopeChild);
 681         joinScope.addScope(rightScopeChild);
 682         // 获取两个表的所有字段
<abbr title=" 683         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 683         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), join🔵</abbr>
 684         String leftTableAlias = joinInfo.getLeftTableAlias();
 685         Table targetTable = localTableCache.get(leftTableAlias);
 686         if (targetTable == null) {
 687             targetTable = localTableCache.get(joinInfo.getLeftTableName());
 688         }
<abbr title=" 689         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSchema().getFieldNames());"> 689         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSc🔵</abbr>
<abbr title=" 690         DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, Row.class).map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; {"> 690         DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, Row.class).map((Tuple2&lt;Boole🔵</abbr>
 691             return new CRow(tp2.f1, tp2.f0);
 692         }).returns(CRow.class);
 693         //adaptStream.getTransformation().setOutputType(leftTypeInfo);
 694         //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 695         if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 696             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 696             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTa🔵</abbr>
 697             List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 698             int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 699             adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 699             adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, tar🔵</abbr>
 700         }
 701         DataStream&lt;CRow&gt; dsOut = null;
 702         if (ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())) {
<abbr title=" 703             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 703             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), 🔵</abbr>
 704         } else {
<abbr title=" 705             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 705             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSq🔵</abbr>
 706         }
 707         // TODO  将嵌套表中的字段传递过去, 去除冗余的ROWtime
 708         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 709         RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 710         CRowTypeInfo cRowTypeInfo = new CRowTypeInfo(sideOutTypeInfo);
 711         dsOut.getTransformation().setOutputType(cRowTypeInfo);
 712         String targetTableName = joinInfo.getNewTableName();
 713         String targetTableAlias = joinInfo.getNewTableAlias();
 714         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 715         replaceInfo.setMappingTable(mappingTable);
 716         replaceInfo.setTargetTableName(targetTableName);
 717         replaceInfo.setTargetTableAlias(targetTableAlias);
 718         // 判断之前是不是被替换过,被替换过则设置之前的替换信息作为上一个节点
 719         for (FieldReplaceInfo tmp : replaceInfoList) {
<abbr title=" 720             if (tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName()) || tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableAlias())) {"> 720             if (tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName()) || tmp.getTargetTa🔵</abbr>
 721                 replaceInfo.setPreNode(tmp);
 722                 break;
 723             }
 724         }
 725         replaceInfoList.add(replaceInfo);
 726         List&lt;String&gt; registeredTableName = Arrays.asList(tableEnv.listTables());
 727         if (!registeredTableName.contains(joinInfo.getNewTableName())) {
 728             Table joinTable = tableEnv.fromDataStream(dsOut);
 729             tableEnv.registerTable(joinInfo.getNewTableName(), joinTable);
 730             localTableCache.put(joinInfo.getNewTableName(), joinTable);
 731         }
 732     }
 733 
 734     private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 735         String[] fieldNames = schema.getFieldNames();
 736         TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
<abbr title=" 737         String[] projectedNames = Arrays.stream(fields).mapToObj(( i) -&gt; fieldNames[i]).toArray(String[]::new);"> 737         String[] projectedNames = Arrays.stream(fields).mapToObj(( i) -&gt; fieldNames[i]).toArray(String[]:🔵</abbr>
<abbr title=" 738         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(( i) -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 738         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(( i) -&gt; fieldTypes[i]).toArray(🔵</abbr>
 739         return new RowTypeInfo(projectedTypes, projectedNames);
 740     }
 741 
 742     private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 743         List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 744         String fieldsInfo = result.getFieldsInfoStr();
 745         String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 746         for (int i = 0; i &lt; fields.length; i++) {
 747             String[] filed = fields[i].split(&quot;\\s&quot;);
 748             if ((filed.length &lt; 2) || (fields.length != table.getSchema().getFieldNames().length)) {
 749                 return false;
 750             } else {
 751                 String[] filedNameArr = new String[filed.length - 1];
 752                 System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 753                 String fieldName = String.join(&quot; &quot;, filedNameArr);
 754                 fieldNames.add(fieldName);
 755                 String fieldType = filed[filed.length - 1].trim();
 756                 Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 757                 Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 758                 if (fieldClass == tableField) {
 759                     continue;
 760                 } else {
 761                     return false;
 762                 }
 763             }
 764         }
 765         tmpFields = String.join(&quot;,&quot;, fieldNames);
 766         return true;
 767     }
 768 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.side;
  22  














  23  import com.dtstack.flink.sql.enums.ECacheType;
  24  import com.dtstack.flink.sql.exec.FlinkSQLExec;
  25  import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  26  import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  27  import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  28  import com.dtstack.flink.sql.util.ClassUtil;
  29  import com.dtstack.flink.sql.util.ParseUtils;






  30  import org.apache.calcite.sql.SqlAsOperator;
  31  import org.apache.calcite.sql.SqlBasicCall;
  32  import org.apache.calcite.sql.SqlDataTypeSpec;
  33  import org.apache.calcite.sql.SqlIdentifier;
  34  import org.apache.calcite.sql.SqlInsert;
  35  import org.apache.calcite.sql.SqlJoin;
  36  import org.apache.calcite.sql.SqlKind;
  37  import org.apache.calcite.sql.SqlLiteral;
  38  import org.apache.calcite.sql.SqlNode;
  39  import org.apache.calcite.sql.SqlNodeList;
  40  import org.apache.calcite.sql.SqlOperator;
  41  import org.apache.calcite.sql.SqlOrderBy;
  42  import org.apache.calcite.sql.SqlSelect;
  43  import org.apache.calcite.sql.SqlWithItem;
  44  import org.apache.calcite.sql.fun.SqlCase;
  45  import org.apache.calcite.sql.parser.SqlParseException;
  46  import org.apache.calcite.sql.parser.SqlParserPos;
  47  import org.apache.commons.collections.CollectionUtils;
  48  import org.apache.flink.api.common.typeinfo.TypeInformation;
  49  import org.apache.flink.api.java.tuple.Tuple2;
  50  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  51  import com.google.common.collect.HashBasedTable;
  52  import com.google.common.collect.Lists;
  53  import com.google.common.collect.Maps;
  54  import org.apache.flink.streaming.api.datastream.DataStream;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  55 -import org.apache.flink.table.api.StreamQueryConfig;</span>
  56  import org.apache.flink.table.api.Table;
  57  import org.apache.flink.table.api.java.StreamTableEnvironment;
  58  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  59  import org.apache.flink.types.Row;

  60  import org.slf4j.Logger;
  61  import org.slf4j.LoggerFactory;

  62  import java.sql.Timestamp;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  63 +import java.time.LocalDateTime;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  64 +import java.util.Arrays;</span>
  65  import java.util.Collection;
  66  import java.util.LinkedList;
  67  import java.util.List;
  68  import java.util.Map;
  69  import java.util.Queue;

  70  
  71  import static org.apache.calcite.sql.SqlKind.*;
  72  
  73  /**
  74   * Reason:
  75   * Date: 2018/7/24
  76   * Company: www.dtstack.com
  77   * @author xuchao
  78   */
  79  
  80  public class SideSqlExec {
  81  
  82      private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  83  
  84      private String localSqlPluginPath = null;
  85  
  86      private String tmpFields = null;
  87  
  88      private SideSQLParser sideSQLParser = new SideSQLParser();
  89      private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  90  
  91      private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  92  
  93      public void exec(String sql, Map&lt;String, SideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  94 -                     Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig) throws Exception {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  95 +                     Map&lt;String, Table&gt; tableCache) throws Exception {</span>

  96          if(localSqlPluginPath == null){
  97              throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
  98          }
  99  
 100          localTableCache.putAll(tableCache);
 101          try {
 102              sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 103          } catch (Exception e) {
 104              LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 105          }
 106  








 107          Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());
 108          Object pollObj = null;
 109  
 110          //need clean
 111          boolean preIsSideJoin = false;
 112          List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();
 113  
 114          while((pollObj = exeQueue.poll()) != null){
 115  
 116              if(pollObj instanceof SqlNode){
 117                  SqlNode pollSqlNode = (SqlNode) pollObj;
 118  
 119                  if(preIsSideJoin){
 120                      preIsSideJoin = false;
 121                      List&lt;String&gt; fieldNames = null;
 122                      for(FieldReplaceInfo replaceInfo : replaceInfoList){
 123                          fieldNames = Lists.newArrayList();
<abbr title=" 124                          replaceFieldName(pollSqlNode, replaceInfo.getMappingTable(), replaceInfo.getTargetTableName(), replaceInfo.getTargetTableAlias());"> 124                          replaceFieldName(pollSqlNode, replaceInfo.getMappingTable(), replaceInfo.getTargetTableNam🔵</abbr>

 125                          addAliasForFieldNode(pollSqlNode, fieldNames, replaceInfo.getMappingTable());
 126                      }
 127                  }
 128  
 129                  if(pollSqlNode.getKind() == INSERT){
 130                      System.out.println(&quot;----------real exec sql-----------&quot; );
 131                      System.out.println(pollSqlNode.toString());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 132 -                    FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 133 +                    FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString());</span>
 134                      if(LOG.isInfoEnabled()){
 135                          LOG.info(&quot;exec sql: &quot; + pollSqlNode.toString());
 136                      }

 137                  }else if(pollSqlNode.getKind() == AS){
 138                      AliasInfo aliasInfo = parseASNode(pollSqlNode);
 139                      Table table = tableEnv.sqlQuery(aliasInfo.getName());
 140                      tableEnv.registerTable(aliasInfo.getAlias(), table);
 141                      localTableCache.put(aliasInfo.getAlias(), table);


 142                  } else if (pollSqlNode.getKind() == WITH_ITEM) {
 143                      SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 144                      String TableAlias = sqlWithItem.name.toString();
 145                      Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 146                      tableEnv.registerTable(TableAlias, table);

















 147                  }
 148  
 149              }else if (pollObj instanceof JoinInfo){


 150                  preIsSideJoin = true;
 151                  joinFun(pollObj, localTableCache, sideTableMap, tableEnv, replaceInfoList);
 152              }
 153          }
 154  
 155      }
 156  
 157  







































<abbr title=" 158      private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 158      private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, 🔵</abbr>
 159          SqlKind sqlKind = pollSqlNode.getKind();
 160          switch (sqlKind) {
 161              case INSERT:
 162                  SqlNode source = ((SqlInsert) pollSqlNode).getSource();
 163                  addAliasForFieldNode(source, fieldList, mappingTable);
 164                  break;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 165 -</span>
 166              case AS:
 167                  addAliasForFieldNode(((SqlBasicCall) pollSqlNode).getOperands()[0], fieldList, mappingTable);
 168                  break;
 169  
 170              case SELECT:
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 171 -</span>
 172                  SqlNodeList selectList = ((SqlSelect) pollSqlNode).getSelectList();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 173 -</span>
 174                  selectList.getList().forEach(node -&gt; {
 175                      if (node.getKind() == IDENTIFIER) {
 176                          SqlIdentifier sqlIdentifier = (SqlIdentifier) node;
 177                          if (sqlIdentifier.names.size() == 1) {
 178                              return;
 179                          }
 180                          // save real field
 181                          String fieldName = sqlIdentifier.names.get(1);
<abbr title=" 182                          if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().containsKey(fieldName)) {"> 182                          if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().contai🔵</abbr>
 183                              fieldList.add(fieldName);
 184                          }
 185  
 186                      }
 187                  });
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 188 -</span>
 189                  for (int i = 0; i &lt; selectList.getList().size(); i++) {
 190                      SqlNode node = selectList.get(i);
 191                      if (node.getKind() == IDENTIFIER) {
 192                          SqlIdentifier sqlIdentifier = (SqlIdentifier) node;
 193                          if (sqlIdentifier.names.size() == 1) {
 194                              return;
 195                          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 196 -</span>
 197                          String name = sqlIdentifier.names.get(1);
 198                          // avoid real field pv0 convert pv
<abbr title=" 199                          if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring(0, name.length() - 1))) {"> 199                          if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring🔵</abbr>
 200                              SqlOperator operator = new SqlAsOperator();
 201                              SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 202  
<abbr title=" 203                              SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() - 1), null, sqlParserPos);"> 203                              SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() -🔵</abbr>
 204                              SqlNode[] sqlNodes = new SqlNode[2];
 205                              sqlNodes[0] = sqlIdentifier;
 206                              sqlNodes[1] = sqlIdentifierAlias;
 207                              SqlBasicCall sqlBasicCall = new SqlBasicCall(operator, sqlNodes, sqlParserPos);
 208  
 209                              selectList.set(i, sqlBasicCall);
 210                          }
 211  
 212                      }
 213                  }
 214                  break;
 215          }
 216      }
 217  
 218  
 219      public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {







 220          SqlKind sqlKind = sqlNode.getKind();
 221          if(sqlKind != AS){
 222              throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 223          }
 224  
 225          SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 226          SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 227  
 228          AliasInfo aliasInfo = new AliasInfo();
 229          aliasInfo.setName(info.toString());
 230          aliasInfo.setAlias(alias.toString());
 231  
 232          return aliasInfo;
 233      }
 234  
<abbr title=" 235      public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, String&gt; mappingTable){"> 235      public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, Strin🔵</abbr>

 236          TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 237          String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 238          for(int i=0; i&lt;sideJoinFieldInfo.size(); i++){

 239              FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 240              String tableName = fieldInfo.getTable();
 241              String fieldName = fieldInfo.getFieldName();
 242              String mappingFieldName = fieldName;
 243              if(!mappingTable.column(fieldName).isEmpty()){
 244                  mappingFieldName = fieldName + &quot;0&quot;;
 245              }
 246  

 247              mappingTable.put(tableName, fieldName, mappingFieldName);
 248  
 249              sideOutTypes[i] = fieldInfo.getTypeInformation();
 250              sideOutNames[i] = mappingFieldName;
 251          }
 252  
 253          return new RowTypeInfo(sideOutTypes, sideOutNames);
 254      }


 255  
 256      /**
 257       *  对时间类型进行类型转换
 258       * @param leftTypeInfo
 259       * @return
 260       */
 261      private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 262          TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 263          TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 264          for (int i = 0; i &lt; sideOutTypes.length; i++) {
 265              sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 266          }
 267          RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 268          return rowTypeInfo;
 269      }
 270  
 271      private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 272          if (typeInformation instanceof TimeIndicatorTypeInfo) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 273 -            return TypeInformation.of(Timestamp.class);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 274 +            return TypeInformation.of(LocalDateTime.class);</span>
 275          }
 276          return typeInformation;
 277      }
 278  
 279      //需要考虑更多的情况
<abbr title=" 280      private void replaceFieldName(SqlNode sqlNode, HashBasedTable&lt;String, String, String&gt; mappingTable, String targetTableName, String tableAlias) {"> 280      private void replaceFieldName(SqlNode sqlNode, HashBasedTable&lt;String, String, String&gt; mappingTable, String tar🔵</abbr>

 281          SqlKind sqlKind = sqlNode.getKind();
 282          switch (sqlKind) {
 283              case INSERT:
 284                  SqlNode sqlSource = ((SqlInsert) sqlNode).getSource();
 285                  replaceFieldName(sqlSource, mappingTable, targetTableName, tableAlias);

 286                  break;
 287              case AS:
 288                  SqlNode asNode = ((SqlBasicCall) sqlNode).getOperands()[0];
 289                  replaceFieldName(asNode, mappingTable, targetTableName, tableAlias);

 290                  break;
 291              case SELECT:
 292                  SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, targetTableName);

 293                  if(sqlSelect == null){
 294                      return;
 295                  }
 296  
 297                  SqlNode sqlSource1 = sqlSelect.getFrom();
 298                  if(sqlSource1.getKind() == AS){
 299                      String tableName = ((SqlBasicCall)sqlSource1).getOperands()[0].toString();
 300                      if(tableName.equalsIgnoreCase(targetTableName)){

 301                          SqlNodeList sqlSelectList = sqlSelect.getSelectList();
 302                          SqlNode whereNode = sqlSelect.getWhere();
 303                          SqlNodeList sqlGroup = sqlSelect.getGroup();
 304  
 305                          //TODO 暂时不处理having
 306                          SqlNode sqlHaving = sqlSelect.getHaving();
 307  
 308                          List&lt;SqlNode&gt; newSelectNodeList = Lists.newArrayList();
 309                          for( int i=0; i&lt;sqlSelectList.getList().size(); i++){
 310                              SqlNode selectNode = sqlSelectList.getList().get(i);
 311                              //特殊处理 isStar的标识
 312                              if(selectNode.getKind() == IDENTIFIER &amp;&amp; ((SqlIdentifier) selectNode).isStar()){
<abbr title=" 313                                  List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, mappingTable, tableAlias);"> 313                                  List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, mappingTabl🔵</abbr>

 314                                  newSelectNodeList.addAll(replaceNodeList);
 315                                  continue;
 316                              }
 317  
 318                              SqlNode replaceNode = replaceSelectFieldName(selectNode, mappingTable, tableAlias);

 319                              if(replaceNode == null){
 320                                  continue;
 321                              }
 322  
 323                              //sqlSelectList.set(i, replaceNode);
 324                              newSelectNodeList.add(replaceNode);
 325                          }
 326  
<abbr title=" 327                          SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosition());"> 327                          SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosi🔵</abbr>
 328                          sqlSelect.setSelectList(newSelectList);
 329  
 330                          //where
 331                          if(whereNode != null){
 332                              SqlNode[] sqlNodeList = ((SqlBasicCall)whereNode).getOperands();
 333                              for(int i =0; i&lt;sqlNodeList.length; i++) {
 334                                  SqlNode whereSqlNode = sqlNodeList[i];
 335                                  SqlNode replaceNode = replaceNodeInfo(whereSqlNode, mappingTable, tableAlias);

 336                                  sqlNodeList[i] = replaceNode;
 337                              }
 338                          }
 339  
 340                          if(sqlGroup != null &amp;&amp; CollectionUtils.isNotEmpty(sqlGroup.getList())){
 341                              for( int i=0; i&lt;sqlGroup.getList().size(); i++){
 342                                  SqlNode selectNode = sqlGroup.getList().get(i);
 343                                  SqlNode replaceNode = replaceNodeInfo(selectNode, mappingTable, tableAlias);

 344                                  sqlGroup.set(i, replaceNode);
 345                              }
 346                          }
 347  
 348  
 349                          System.out.println(&quot;-----------------&quot;);
 350                      }
 351                  }else{
 352                      //TODO
 353                      System.out.println(sqlNode);
 354                      throw new RuntimeException(&quot;---not deal type:&quot; + sqlNode);
 355                  }
 356  
 357                  break;
 358              case UNION:
 359                  SqlNode unionLeft = ((SqlBasicCall) sqlNode).getOperands()[0];
 360  
 361                  SqlNode unionRight = ((SqlBasicCall) sqlNode).getOperands()[1];
 362  
 363                  replaceFieldName(unionLeft, mappingTable, targetTableName, tableAlias);
 364  
 365                  replaceFieldName(unionRight, mappingTable, targetTableName, tableAlias);


 366  
 367                  break;
 368              case ORDER_BY:
 369                  SqlOrderBy sqlOrderBy  = (SqlOrderBy) sqlNode;
 370                  replaceFieldName(sqlOrderBy.query, mappingTable, targetTableName, tableAlias);

 371                  SqlNodeList orderFiledList = sqlOrderBy.orderList;
 372                  for (int i=0 ;i&lt;orderFiledList.size();i++) {
 373                      SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), tableAlias);

 374                      orderFiledList.set(i, replaceNode);
 375                  }
 376  
 377              default:
 378                  break;
 379          }
 380      }
 381  
 382      private SqlNode replaceOrderByTableName(SqlNode orderNode, String tableAlias) {
 383          if(orderNode.getKind() == IDENTIFIER){
 384              SqlIdentifier sqlIdentifier = (SqlIdentifier) orderNode;
 385              if (sqlIdentifier.names.size() == 1) {
 386                  return orderNode;
 387              }
 388              return sqlIdentifier.setName(0, tableAlias);
 389          } else if (orderNode instanceof  SqlBasicCall) {
 390              SqlBasicCall sqlBasicCall = (SqlBasicCall) orderNode;
 391              for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 392                  SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 393                  sqlBasicCall.getOperands()[i] = replaceOrderByTableName(sqlNode , tableAlias);
 394              }
 395              return sqlBasicCall;
 396          } else {
 397              return orderNode;
 398          }
 399      }
 400  
<abbr title=" 401      private SqlNode replaceNodeInfo(SqlNode groupNode, HashBasedTable&lt;String, String, String&gt; mappingTable, String tableAlias){"> 401      private SqlNode replaceNodeInfo(SqlNode groupNode, HashBasedTable&lt;String, String, String&gt; mappingTable, String🔵</abbr>

 402          if(groupNode.getKind() == IDENTIFIER){
 403              SqlIdentifier sqlIdentifier = (SqlIdentifier) groupNode;
 404              if(sqlIdentifier.names.size() == 1){
 405                  return sqlIdentifier;
 406              }
<abbr title=" 407              String mappingFieldName = mappingTable.get(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 407              String mappingFieldName = mappingTable.get(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.ge🔵</abbr>
 408  


 409              if(mappingFieldName == null){
 410                  throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + sqlIdentifier.toString() );
 411              }
 412              sqlIdentifier = sqlIdentifier.setName(0, tableAlias);


 413              return sqlIdentifier.setName(1, mappingFieldName);
 414          }else if(groupNode instanceof  SqlBasicCall){
 415              SqlBasicCall sqlBasicCall = (SqlBasicCall) groupNode;
 416              for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 417                  SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 418                  SqlNode replaceNode = replaceSelectFieldName(sqlNode, mappingTable, tableAlias);

 419                  sqlBasicCall.getOperands()[i] = replaceNode;
 420              }
 421  
 422              return sqlBasicCall;
 423          }else{
 424              return groupNode;
 425          }
 426      }
 427  
 428      public SqlNode filterNodeWithTargetName(SqlNode sqlNode, String targetTableName) {
 429  
 430          SqlKind sqlKind = sqlNode.getKind();
 431          switch (sqlKind){
 432              case SELECT:
 433                  SqlNode fromNode = ((SqlSelect)sqlNode).getFrom();
 434                  if(fromNode.getKind() == AS &amp;&amp; ((SqlBasicCall)fromNode).getOperands()[0].getKind() == IDENTIFIER){
 435                      if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableName)){
 436                          return sqlNode;
 437                      }else{
 438                          return null;
 439                      }
 440                  }else{
 441                      return filterNodeWithTargetName(fromNode, targetTableName);
 442                  }
 443              case AS:
 444                  SqlNode childNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 445                  return filterNodeWithTargetName(childNode, targetTableName);
 446              case JOIN:
 447                  SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 448                  SqlNode rightNode =  ((SqlJoin)sqlNode).getRight();
 449                  SqlNode leftReturnNode = filterNodeWithTargetName(leftNode, targetTableName);
 450                  SqlNode rightReturnNode = filterNodeWithTargetName(rightNode, targetTableName);
 451  
 452                  if(leftReturnNode != null) {
 453                      return leftReturnNode;
 454                  }else if(rightReturnNode != null){
 455                      return rightReturnNode;
 456                  }else{
 457                      return null;
 458                  }


 459          }
 460  
 461          return null;
 462      }
 463  
 464  
 465      public void setLocalSqlPluginPath(String localSqlPluginPath) {
 466          this.localSqlPluginPath = localSqlPluginPath;
 467      }
 468  
 469      private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){
 470          Table table = localTableCache.get(tableAlias);
 471          if(table == null){
 472              table = localTableCache.get(tableName);
 473          }
 474  
 475          if(table == null){
 476              throw new RuntimeException(&quot;not register table &quot; + tableName);
 477          }
 478  
 479          return table;
 480      }
 481  
<abbr title=" 482      private List&lt;SqlNode&gt; replaceSelectStarFieldName(SqlNode selectNode, HashBasedTable&lt;String, String, String&gt; mappingTable, String tableAlias){"> 482      private List&lt;SqlNode&gt; replaceSelectStarFieldName(SqlNode selectNode, HashBasedTable&lt;String, String, String&gt; ma🔵</abbr>

 483          SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 484          List&lt;SqlNode&gt; sqlNodes = Lists.newArrayList();
 485          if(sqlIdentifier.isStar()){//处理 [* or table.*]
 486              int identifierSize = sqlIdentifier.names.size();
 487              Collection&lt;String&gt; columns = null;
 488              if(identifierSize == 1){
 489                  columns = mappingTable.values();

 490              }else{
 491                  columns = mappingTable.row(sqlIdentifier.names.get(0)).values();

 492              }
 493  
 494              for(String colAlias : columns){
 495                  SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 496                  List&lt;String&gt; columnInfo = Lists.newArrayList();
 497                  columnInfo.add(tableAlias);

 498                  columnInfo.add(colAlias);
 499                  SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(columnInfo, sqlParserPos);
 500                  sqlNodes.add(sqlIdentifierAlias);
 501              }
 502  
 503              return sqlNodes;
 504          }else{
 505              throw new RuntimeException(&quot;is not a star select field.&quot; + selectNode);
 506          }
 507      }
 508  
<abbr title=" 509      private SqlNode replaceSelectFieldName(SqlNode selectNode, HashBasedTable&lt;String, String, String&gt; mappingTable, String tableAlias) {"> 509      private SqlNode replaceSelectFieldName(SqlNode selectNode, HashBasedTable&lt;String, String, String&gt; mappingTable🔵</abbr>

 510          if (selectNode.getKind() == AS) {
 511              SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];
 512              SqlNode replaceNode = replaceSelectFieldName(leftNode, mappingTable, tableAlias);

 513              if (replaceNode != null) {
 514                  ((SqlBasicCall) selectNode).getOperands()[0] = replaceNode;
 515              }
 516  
 517              return selectNode;
 518          }else if(selectNode.getKind() == IDENTIFIER){
 519              SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 520  
 521              if(sqlIdentifier.names.size() == 1){
 522                  return selectNode;
 523              }
 524  
<abbr title=" 525              String mappingFieldName = mappingTable.get(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 525              String mappingFieldName = mappingTable.get(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.ge🔵</abbr>
 526              if(mappingFieldName == null){
 527                 throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + selectNode.toString() );
 528              }
 529  
 530              sqlIdentifier = sqlIdentifier.setName(0, tableAlias);







 531              sqlIdentifier = sqlIdentifier.setName(1, mappingFieldName);
 532              return sqlIdentifier;
 533          }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//字面含义
 534              return selectNode;
 535          }else if(  AGGREGATE.contains(selectNode.getKind())
 536                  || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 537                  || COMPARISON.contains(selectNode.getKind())
 538                  || selectNode.getKind() == OTHER_FUNCTION
 539                  || selectNode.getKind() == DIVIDE
 540                  || selectNode.getKind() == CAST
 541                  || selectNode.getKind() == TRIM
 542                  || selectNode.getKind() == TIMES
 543                  || selectNode.getKind() == PLUS
 544                  || selectNode.getKind() == NOT_IN
 545                  || selectNode.getKind() == OR
 546                  || selectNode.getKind() == AND
 547                  || selectNode.getKind() == MINUS
 548                  || selectNode.getKind() == TUMBLE
 549                  || selectNode.getKind() == TUMBLE_START
 550                  || selectNode.getKind() == TUMBLE_END
 551                  || selectNode.getKind() == SESSION
 552                  || selectNode.getKind() == SESSION_START
 553                  || selectNode.getKind() == SESSION_END
 554                  || selectNode.getKind() == HOP
 555                  || selectNode.getKind() == HOP_START
 556                  || selectNode.getKind() == HOP_END
 557                  || selectNode.getKind() == BETWEEN
 558                  || selectNode.getKind() == IS_NULL
 559                  || selectNode.getKind() == IS_NOT_NULL
 560                  || selectNode.getKind() == CONTAINS
 561                  || selectNode.getKind() == TIMESTAMP_ADD
 562                  || selectNode.getKind() == TIMESTAMP_DIFF
 563                  || selectNode.getKind() == LIKE
 564  
 565                  ){
 566              SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 567              for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 568                  SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 569                  if(sqlNode instanceof SqlLiteral){
 570                      continue;
 571                  }
 572  
 573                  if(sqlNode instanceof SqlDataTypeSpec){
 574                      continue;
 575                  }
 576  
 577                  SqlNode replaceNode = replaceSelectFieldName(sqlNode, mappingTable, tableAlias);

 578                  if(replaceNode == null){
 579                      continue;
 580                  }
 581  
 582                  sqlBasicCall.getOperands()[i] = replaceNode;
 583              }
 584  
 585              return selectNode;
 586          }else if(selectNode.getKind() == CASE){
 587              System.out.println(&quot;selectNode&quot;);
 588              SqlCase sqlCase = (SqlCase) selectNode;
 589              SqlNodeList whenOperands = sqlCase.getWhenOperands();
 590              SqlNodeList thenOperands = sqlCase.getThenOperands();
 591              SqlNode elseNode = sqlCase.getElseOperand();
 592  
 593              for(int i=0; i&lt;whenOperands.size(); i++){
 594                  SqlNode oneOperand = whenOperands.get(i);
 595                  SqlNode replaceNode = replaceSelectFieldName(oneOperand, mappingTable, tableAlias);

 596                  if (replaceNode != null) {
 597                      whenOperands.set(i, replaceNode);
 598                  }
 599              }
 600  
 601              for(int i=0; i&lt;thenOperands.size(); i++){
 602                  SqlNode oneOperand = thenOperands.get(i);
 603                  SqlNode replaceNode = replaceSelectFieldName(oneOperand, mappingTable, tableAlias);

 604                  if (replaceNode != null) {
 605                      thenOperands.set(i, replaceNode);
 606                  }
 607              }
 608  
 609              ((SqlCase) selectNode).setOperand(3, replaceSelectFieldName(elseNode, mappingTable, tableAlias));

 610              return selectNode;
 611          }else if(selectNode.getKind() == OTHER){
 612              //不处理
 613              return selectNode;
 614          }else{
<abbr title=" 615              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 615              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNod🔵</abbr>
 616          }
 617      }
 618  
 619      /**
<abbr title=" 620       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 620       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension 🔵</abbr>
 621       *
 622       * @return
 623       */
<abbr title=" 624      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, SideTableInfo sideTableInfo) {"> 624      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, SideTableInfo sideTableInfo) 🔵</abbr>

 625          List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 626          if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 627              return true;
 628          }
 629          return false;
 630      }
 631  
 632      private List&lt;String&gt; convertPrimaryAlias(SideTableInfo sideTableInfo) {

 633          List&lt;String&gt; res = Lists.newArrayList();
 634          sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 635              res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 636          });
 637          return res;
 638      }
 639  
<abbr title=" 640      public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, SideTableInfo sideTableInfo){"> 640      public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, SideTableInfo sideTable🔵</abbr>

 641          List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 642          ParseUtils.parseAnd(conditionNode, sqlNodeList);
 643          List&lt;String&gt; conditionFields = Lists.newArrayList();
 644          for(SqlNode sqlNode : sqlNodeList){
 645              if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 646                  throw new RuntimeException(&quot;not compare operator.&quot;);
 647              }
 648  
 649              SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 650              SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 651  
 652              String leftTableName = left.getComponent(0).getSimple();
 653              String rightTableName = right.getComponent(0).getSimple();
 654  
 655              String tableCol = &quot;&quot;;
 656              if(leftTableName.equalsIgnoreCase(specifyTableName)){
 657                  tableCol = left.getComponent(1).getSimple();
 658              }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 659                  tableCol = right.getComponent(1).getSimple();
 660              }else{
<abbr title=" 661                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 661                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName🔵</abbr>
 662              }
 663              tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 664              conditionFields.add(tableCol);
 665          }
 666  
 667          return conditionFields;
 668      }
 669  
 670      public void registerTmpTable(CreateTmpTableParser.SqlParserResult result,
 671                                   Map&lt;String, SideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,
 672                                   Map&lt;String, Table&gt; tableCache)
 673              throws Exception {
 674  
 675          if(localSqlPluginPath == null){
 676              throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
 677          }
 678  
 679          localTableCache.putAll(tableCache);
 680          Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(result.getExecSql(), sideTableMap.keySet());
 681          Object pollObj = null;
 682  
 683          //need clean
 684          boolean preIsSideJoin = false;
 685          List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();
 686  
 687          while((pollObj = exeQueue.poll()) != null){
 688  
 689              if(pollObj instanceof SqlNode){
 690                  SqlNode pollSqlNode = (SqlNode) pollObj;
 691  
 692                  if(preIsSideJoin){
 693                      preIsSideJoin = false;
 694                      List&lt;String&gt; fieldNames = null;
 695                      for (FieldReplaceInfo replaceInfo : replaceInfoList) {
 696                          fieldNames = Lists.newArrayList();
<abbr title=" 697                          replaceFieldName(pollSqlNode, replaceInfo.getMappingTable(), replaceInfo.getTargetTableName(), replaceInfo.getTargetTableAlias());"> 697                          replaceFieldName(pollSqlNode, replaceInfo.getMappingTable(), replaceInfo.getTargetTableNam🔵</abbr>
 698                          addAliasForFieldNode(pollSqlNode, fieldNames, replaceInfo.getMappingTable());
 699                      }
 700                  }
 701  
 702                  if(pollSqlNode.getKind() == INSERT){
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 703 -                    tableEnv.sqlUpdate(pollSqlNode.toString());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 704 +//                    tableEnv.sqlUpdate(pollSqlNode.toString());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 705 +                    FlinkSQLExec.sqlUpdate(tableEnv,pollSqlNode.toString());</span>
 706                  }else if(pollSqlNode.getKind() == AS){
 707                      AliasInfo aliasInfo = parseASNode(pollSqlNode);
 708                      Table table = tableEnv.sqlQuery(aliasInfo.getName());
 709                      tableEnv.registerTable(aliasInfo.getAlias(), table);
 710                      if(LOG.isInfoEnabled()){
 711                          LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 712                      }
 713                      localTableCache.put(aliasInfo.getAlias(), table);
 714                  } else if (pollSqlNode.getKind() == SELECT){
 715                      Table table = tableEnv.sqlQuery(pollObj.toString());
 716                      if (result.getFieldsInfoStr() == null){
 717                          tableEnv.registerTable(result.getTableName(), table);
 718                      } else {
 719                          if (checkFieldsInfo(result, table)){
 720                              table = table.as(tmpFields);
 721                              tableEnv.registerTable(result.getTableName(), table);
 722                          } else {
 723                              throw new RuntimeException(&quot;Fields mismatch&quot;);
 724                          }
 725                      }
 726                      localTableCache.put(result.getTableName(), table);
 727  
 728                  }
 729  
 730              }else if (pollObj instanceof JoinInfo){
 731                  preIsSideJoin = true;
 732                  joinFun(pollObj, localTableCache, sideTableMap, tableEnv, replaceInfoList);
 733              }
 734          }

































 735      }
 736  
 737      private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache,
 738                           Map&lt;String, SideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,

 739                           List&lt;FieldReplaceInfo&gt; replaceInfoList) throws Exception{
 740          JoinInfo joinInfo = (JoinInfo) pollObj;
 741  
 742          JoinScope joinScope = new JoinScope();
 743          JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 744          leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 745          leftScopeChild.setTableName(joinInfo.getLeftTableName());
 746  





<abbr title=" 747          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 747          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableNa🔵</abbr>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 748 -        RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColumnNames());"> 748 -        RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColu🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 749 +        RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSchema().getFieldNames());"> 749 +        RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSchema().ge🔵</abbr></span>
 750          leftScopeChild.setRowTypeInfo(leftTypeInfo);
 751  
 752          JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 753          rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 754          rightScopeChild.setTableName(joinInfo.getRightTableName());
 755          SideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());

 756          if(sideTableInfo == null){
 757              sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 758          }
 759  
 760          if(sideTableInfo == null){
 761              throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 762          }
 763  
 764          if(!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)){
 765              throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);
 766          }
 767  
 768          rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 769  
 770          joinScope.addScope(leftScopeChild);
 771          joinScope.addScope(rightScopeChild);
 772  
 773          //获取两个表的所有字段
<abbr title=" 774          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 774          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, tr🔵</abbr>
 775  
 776          String leftTableAlias = joinInfo.getLeftTableAlias();
 777          Table targetTable = localTableCache.get(leftTableAlias);
 778          if(targetTable == null){
 779              targetTable = localTableCache.get(joinInfo.getLeftTableName());
 780          }
 781  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 782 -        RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColumnNames());"> 782 -        RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColu🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 783 +        RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSchema().getFieldNames());"> 783 +        RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSchema().ge🔵</abbr></span>
 784  
 785          DataStream adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)
 786                                  .map((Tuple2&lt;Boolean, Row&gt; f0) -&gt; { return f0.f1; })
 787                                  .returns(Row.class);




<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 788 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 789 +        //adaptStream.getTransformation().setOutputType(leftTypeInfo);</span>
 790  
 791          //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 792          if(sideTableInfo.isPartitionedJoin()){
 793              RowTypeInfo leftTableOutType = buildLeftTableOutType(leftTypeInfo);
 794              adaptStream.getTransformation().setOutputType(leftTableOutType);

<abbr title=" 795              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 795              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(🔵</abbr>
 796              String[] leftJoinColArr = leftJoinColList.toArray(new String[leftJoinColList.size()]);
 797              adaptStream = adaptStream.keyBy(leftJoinColArr);
 798          }
 799  
 800          DataStream dsOut = null;






 801          if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title=" 802              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 802              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlP🔵</abbr>
 803          }else{
<abbr title=" 804              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 804              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPa🔵</abbr>
 805          }
 806  

 807          HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 808          RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 809          dsOut.getTransformation().setOutputType(sideOutTypeInfo);




 810          String targetTableName = joinInfo.getNewTableName();
 811          String targetTableAlias = joinInfo.getNewTableAlias();
 812  
 813          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 814          replaceInfo.setMappingTable(mappingTable);
 815          replaceInfo.setTargetTableName(targetTableName);
 816          replaceInfo.setTargetTableAlias(targetTableAlias);
 817  









 818          replaceInfoList.add(replaceInfo);
 819  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 820 -        if (!tableEnv.isRegistered(joinInfo.getNewTableName())){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 821 +        List&lt;String&gt; registeredTableName = Arrays.asList(tableEnv.listTables());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 822 +        if (!registeredTableName.contains(joinInfo.getNewTableName())) {</span>
<abbr title=" 823              tableEnv.registerDataStream(joinInfo.getNewTableName(), dsOut, String.join(&quot;,&quot;, sideOutTypeInfo.getFieldNames()));"> 823              tableEnv.registerDataStream(joinInfo.getNewTableName(), dsOut, String.join(&quot;,&quot;, sideOutTypeInfo.getFie🔵</abbr>
 824          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 825 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 826 -</span>














<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 827 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 828 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 829 +    }</span>
 830  
 831      private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 832          List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 833          String fieldsInfo = result.getFieldsInfoStr();
 834          String[] fields = fieldsInfo.split(&quot;,&quot;);

 835          for (int i = 0; i &lt; fields.length; i++) {
 836              String[] filed = fields[i].split(&quot;\\s&quot;);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 837 -            if (filed.length &lt; 2 || fields.length != table.getSchema().getColumnNames().length){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 838 +            if (filed.length &lt; 2 || fields.length != table.getSchema().getFieldNames().length){</span>
 839                  return false;
 840              } else {
 841                  String[] filedNameArr = new String[filed.length - 1];
 842                  System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 843                  String fieldName = String.join(&quot; &quot;, filedNameArr);
 844                  fieldNames.add(fieldName);
 845                  String fieldType = filed[filed.length - 1 ].trim();
 846                  Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 847                  Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 848                  if (fieldClass == tableField){
 849                      continue;
 850                  } else {
 851                      return false;
 852                  }
 853              }
 854          }
 855          tmpFields = String.join(&quot;,&quot;, fieldNames);
 856          return true;
 857      }
 858  
 859  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.side;
  22  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  23 +import org.apache.flink.api.common.typeinfo.TypeInformation;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  24 +import org.apache.flink.api.java.tuple.Tuple2;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  25 +import org.apache.flink.api.java.typeutils.RowTypeInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  26 +import org.apache.flink.streaming.api.datastream.DataStream;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  27 +import org.apache.flink.table.api.StreamQueryConfig;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  28 +import org.apache.flink.table.api.Table;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 +import org.apache.flink.table.api.TableSchema;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  30 +import org.apache.flink.table.api.java.StreamTableEnvironment;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  31 +import org.apache.flink.table.runtime.CRowKeySelector;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  32 +import org.apache.flink.table.runtime.types.CRow;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  33 +import org.apache.flink.table.runtime.types.CRowTypeInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  34 +import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  35 +import org.apache.flink.types.Row;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  36 +</span>
  37  import com.dtstack.flink.sql.enums.ECacheType;
  38  import com.dtstack.flink.sql.exec.FlinkSQLExec;
  39  import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  40  import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  41  import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  42  import com.dtstack.flink.sql.util.ClassUtil;
  43  import com.dtstack.flink.sql.util.ParseUtils;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  44 +import com.dtstack.flink.sql.util.TableUtils;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  45 +import com.google.common.base.Preconditions;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  46 +import com.google.common.collect.HashBasedTable;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  47 +import com.google.common.collect.Lists;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  48 +import com.google.common.collect.Maps;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  49 +import com.google.common.collect.Sets;</span>
  50  import org.apache.calcite.sql.SqlAsOperator;
  51  import org.apache.calcite.sql.SqlBasicCall;
  52  import org.apache.calcite.sql.SqlDataTypeSpec;
  53  import org.apache.calcite.sql.SqlIdentifier;
  54  import org.apache.calcite.sql.SqlInsert;
  55  import org.apache.calcite.sql.SqlJoin;
  56  import org.apache.calcite.sql.SqlKind;
  57  import org.apache.calcite.sql.SqlLiteral;
  58  import org.apache.calcite.sql.SqlNode;
  59  import org.apache.calcite.sql.SqlNodeList;
  60  import org.apache.calcite.sql.SqlOperator;
  61  import org.apache.calcite.sql.SqlOrderBy;
  62  import org.apache.calcite.sql.SqlSelect;
  63  import org.apache.calcite.sql.SqlWithItem;
  64  import org.apache.calcite.sql.fun.SqlCase;
  65  import org.apache.calcite.sql.parser.SqlParseException;
  66  import org.apache.calcite.sql.parser.SqlParserPos;
  67  import org.apache.commons.collections.CollectionUtils;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  68 -import org.apache.flink.api.common.typeinfo.TypeInformation;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  69 -import org.apache.flink.api.java.tuple.Tuple2;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  70 -import org.apache.flink.api.java.typeutils.RowTypeInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  71 -import com.google.common.collect.HashBasedTable;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  72 -import com.google.common.collect.Lists;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  73 -import com.google.common.collect.Maps;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  74 -import org.apache.flink.streaming.api.datastream.DataStream;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  75 -import org.apache.flink.table.api.StreamQueryConfig;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  76 -import org.apache.flink.table.api.Table;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  77 -import org.apache.flink.table.api.java.StreamTableEnvironment;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  78 -import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  79 -import org.apache.flink.types.Row;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  80 +import org.apache.commons.lang3.StringUtils;</span>
  81  import org.slf4j.Logger;
  82  import org.slf4j.LoggerFactory;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  83 +</span>
  84  import java.sql.Timestamp;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  85 +import java.util.Arrays;</span>

  86  import java.util.Collection;
  87  import java.util.LinkedList;
  88  import java.util.List;
  89  import java.util.Map;
  90  import java.util.Queue;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  91 +import java.util.Set;</span>
  92  
  93  import static org.apache.calcite.sql.SqlKind.*;
  94  
  95  /**
  96   * Reason:
  97   * Date: 2018/7/24
  98   * Company: www.dtstack.com
  99   * @author xuchao
 100   */
 101  
 102  public class SideSqlExec {
 103  
 104      private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
 105  
 106      private String localSqlPluginPath = null;
 107  
 108      private String tmpFields = null;
 109  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 110 -    private SideSQLParser sideSQLParser = new SideSQLParser();</span>
 111      private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
 112  
 113      private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
 114  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 115 -    public void exec(String sql, Map&lt;String, SideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 116 -                     Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig) throws Exception {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 117 +    public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 118 +                     Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.SqlParserResult createView) throws Exception {"> 118 +                     Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.SqlParserR🔵</abbr></span>
 119          if(localSqlPluginPath == null){
 120              throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
 121          }
 122  
 123          localTableCache.putAll(tableCache);
 124          try {
 125              sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 126          } catch (Exception e) {
 127              LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 128          }
 129  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 130 +        if(createView != null){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 131 +            LOG.warn(&quot;create view info\n&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 132 +            LOG.warn(createView.getExecSql());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 133 +            LOG.warn(&quot;-----------------&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 134 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 135 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 136 +        SideSQLParser sideSQLParser = new SideSQLParser();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 137 +        sideSQLParser.setLocalTableCache(localTableCache);</span>
 138          Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());
 139          Object pollObj = null;
 140  
 141          //need clean
 142          boolean preIsSideJoin = false;
 143          List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();
 144  
 145          while((pollObj = exeQueue.poll()) != null){
 146  
 147              if(pollObj instanceof SqlNode){
 148                  SqlNode pollSqlNode = (SqlNode) pollObj;
 149  
 150                  if(preIsSideJoin){
 151                      preIsSideJoin = false;
 152                      List&lt;String&gt; fieldNames = null;
 153                      for(FieldReplaceInfo replaceInfo : replaceInfoList){
 154                          fieldNames = Lists.newArrayList();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 155 -                        replaceFieldName(pollSqlNode, replaceInfo.getMappingTable(), replaceInfo.getTargetTableName(), replaceInfo.getTargetTableAlias());"> 155 -                        replaceFieldName(pollSqlNode, replaceInfo.getMappingTable(), replaceInfo.getTargetTableNam🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 156 +                        replaceFieldName(pollSqlNode, replaceInfo);</span>
 157                          addAliasForFieldNode(pollSqlNode, fieldNames, replaceInfo.getMappingTable());
 158                      }
 159                  }
 160  
 161                  if(pollSqlNode.getKind() == INSERT){
 162                      System.out.println(&quot;----------real exec sql-----------&quot; );
 163                      System.out.println(pollSqlNode.toString());
 164                      FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);

 165                      if(LOG.isInfoEnabled()){
 166                          LOG.info(&quot;exec sql: &quot; + pollSqlNode.toString());
 167                      }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 168 +</span>
 169                  }else if(pollSqlNode.getKind() == AS){
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 170 -                    AliasInfo aliasInfo = parseASNode(pollSqlNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 171 -                    Table table = tableEnv.sqlQuery(aliasInfo.getName());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 172 -                    tableEnv.registerTable(aliasInfo.getAlias(), table);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 173 -                    localTableCache.put(aliasInfo.getAlias(), table);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 174 +                    dealAsSourceTable(tableEnv, pollSqlNode, tableCache, replaceInfoList);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 175 +</span>
 176                  } else if (pollSqlNode.getKind() == WITH_ITEM) {
 177                      SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 178                      String TableAlias = sqlWithItem.name.toString();
 179                      Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 180                      tableEnv.registerTable(TableAlias, table);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 181 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 182 +                } else if (pollSqlNode.getKind() == SELECT){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 183 +                    Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 184 +                    Table table = tableEnv.sqlQuery(pollObj.toString());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 185 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 186 +                    if (createView.getFieldsInfoStr() == null){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 187 +                        tableEnv.registerTable(createView.getTableName(), table);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 188 +                    } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 189 +                        if (checkFieldsInfo(createView, table)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 190 +                            table = table.as(tmpFields);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 191 +                            tableEnv.registerTable(createView.getTableName(), table);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 192 +                        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 193 +                            throw new RuntimeException(&quot;Fields mismatch&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 194 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 195 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 196 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 197 +                    localTableCache.put(createView.getTableName(), table);</span>
 198                  }
 199  
 200              }else if (pollObj instanceof JoinInfo){
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 201 +                System.out.println(&quot;----------exec join info----------&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 202 +                System.out.println(pollObj.toString());</span>
 203                  preIsSideJoin = true;
 204                  joinFun(pollObj, localTableCache, sideTableMap, tableEnv, replaceInfoList);
 205              }
 206          }
 207  
 208      }
 209  
 210  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 211 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 212 +     * 解析出as查询的表和字段的关系</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 213 +     * @param asSqlNode</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 214 +     * @param tableCache</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 215 +     * @return</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 216 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 217 +    private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 218 +        SqlNode info = asSqlNode.getOperands()[0];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 219 +        SqlNode alias = asSqlNode.getOperands()[1];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 220 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 221 +        SqlKind infoKind = info.getKind();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 222 +        if(infoKind != SELECT){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 223 +            return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 224 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 225 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 226 +        List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 227 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 228 +        HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 229 +        for (FieldInfo fieldInfo : extractFieldList) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 230 +            String tableName = fieldInfo.getTable();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 231 +            String fieldName = fieldInfo.getFieldName();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 232 +            String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 233 +            mappingTable.put(tableName, fieldName, mappingFieldName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 234 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 235 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 236 +        FieldReplaceInfo replaceInfo = new FieldReplaceInfo();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 237 +        replaceInfo.setMappingTable(mappingTable);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 238 +        replaceInfo.setTargetTableName(alias.toString());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 239 +        replaceInfo.setTargetTableAlias(alias.toString());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 240 +        return replaceInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 241 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 242 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 243 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 244 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 245 +     * 添加字段别名</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 246 +     * @param pollSqlNode</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 247 +     * @param fieldList</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 248 +     * @param mappingTable</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 249 +     */</span>
<abbr title=" 250      private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 250      private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, 🔵</abbr>
 251          SqlKind sqlKind = pollSqlNode.getKind();
 252          switch (sqlKind) {
 253              case INSERT:
 254                  SqlNode source = ((SqlInsert) pollSqlNode).getSource();
 255                  addAliasForFieldNode(source, fieldList, mappingTable);
 256                  break;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 257 -</span>
 258              case AS:
 259                  addAliasForFieldNode(((SqlBasicCall) pollSqlNode).getOperands()[0], fieldList, mappingTable);
 260                  break;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 261 -</span>
 262              case SELECT:
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 263 -</span>
 264                  SqlNodeList selectList = ((SqlSelect) pollSqlNode).getSelectList();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 265 -</span>
 266                  selectList.getList().forEach(node -&gt; {
 267                      if (node.getKind() == IDENTIFIER) {
 268                          SqlIdentifier sqlIdentifier = (SqlIdentifier) node;
 269                          if (sqlIdentifier.names.size() == 1) {
 270                              return;
 271                          }
 272                          // save real field
 273                          String fieldName = sqlIdentifier.names.get(1);
<abbr title=" 274                          if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().containsKey(fieldName)) {"> 274                          if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().contai🔵</abbr>
 275                              fieldList.add(fieldName);
 276                          }
 277  
 278                      }
 279                  });
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 280 -</span>
 281                  for (int i = 0; i &lt; selectList.getList().size(); i++) {
 282                      SqlNode node = selectList.get(i);
 283                      if (node.getKind() == IDENTIFIER) {
 284                          SqlIdentifier sqlIdentifier = (SqlIdentifier) node;
 285                          if (sqlIdentifier.names.size() == 1) {
 286                              return;
 287                          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 288 -</span>
 289                          String name = sqlIdentifier.names.get(1);
 290                          // avoid real field pv0 convert pv
<abbr title=" 291                          if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring(0, name.length() - 1))) {"> 291                          if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring🔵</abbr>
 292                              SqlOperator operator = new SqlAsOperator();
 293                              SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 294  
<abbr title=" 295                              SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() - 1), null, sqlParserPos);"> 295                              SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() -🔵</abbr>
 296                              SqlNode[] sqlNodes = new SqlNode[2];
 297                              sqlNodes[0] = sqlIdentifier;
 298                              sqlNodes[1] = sqlIdentifierAlias;
 299                              SqlBasicCall sqlBasicCall = new SqlBasicCall(operator, sqlNodes, sqlParserPos);
 300  
 301                              selectList.set(i, sqlBasicCall);
 302                          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 303 -</span>
 304                      }
 305                  }
 306                  break;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 307 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 308 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 309 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 310 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 311 -    public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 312 +            default:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 313 +                break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 314 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 315 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 316 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 317 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 318 +    public AliasInfo parseAsNode(SqlNode sqlNode) throws SqlParseException {</span>
 319          SqlKind sqlKind = sqlNode.getKind();
 320          if(sqlKind != AS){
 321              throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 322          }
 323  
 324          SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 325          SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 326  
 327          AliasInfo aliasInfo = new AliasInfo();
 328          aliasInfo.setName(info.toString());
 329          aliasInfo.setAlias(alias.toString());
 330  
 331          return aliasInfo;
 332      }
 333  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 334 -    public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, String&gt; mappingTable){"> 334 -    public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, Strin🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 335 +    public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 335 +    public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, Strin🔵</abbr></span>
 336          TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 337          String[] sideOutNames = new String[sideJoinFieldInfo.size()];
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 338 -        for(int i=0; i&lt;sideJoinFieldInfo.size(); i++){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 339 +        for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {</span>
 340              FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 341              String tableName = fieldInfo.getTable();
 342              String fieldName = fieldInfo.getFieldName();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 343 -            String mappingFieldName = fieldName;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 344 -            if(!mappingTable.column(fieldName).isEmpty()){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 345 -                mappingFieldName = fieldName + &quot;0&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 346 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 347 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 348 +            String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);</span>
 349              mappingTable.put(tableName, fieldName, mappingFieldName);
 350  
 351              sideOutTypes[i] = fieldInfo.getTypeInformation();
 352              sideOutNames[i] = mappingFieldName;
 353          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 354 -</span>
 355          return new RowTypeInfo(sideOutTypes, sideOutNames);
 356      }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 357 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 358 +</span>
 359  
 360      /**
 361       *  对时间类型进行类型转换
 362       * @param leftTypeInfo
 363       * @return
 364       */
 365      private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 366          TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 367          TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 368          for (int i = 0; i &lt; sideOutTypes.length; i++) {
 369              sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 370          }
 371          RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 372          return rowTypeInfo;
 373      }
 374  
 375      private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 376          if (typeInformation instanceof TimeIndicatorTypeInfo) {
 377              return TypeInformation.of(Timestamp.class);

 378          }
 379          return typeInformation;
 380      }
 381  
 382      //需要考虑更多的情况
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 383 -    private void replaceFieldName(SqlNode sqlNode, HashBasedTable&lt;String, String, String&gt; mappingTable, String targetTableName, String tableAlias) {"> 383 -    private void replaceFieldName(SqlNode sqlNode, HashBasedTable&lt;String, String, String&gt; mappingTable, String tar🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 384 +    private void replaceFieldName(SqlNode sqlNode, FieldReplaceInfo replaceInfo) {</span>
 385          SqlKind sqlKind = sqlNode.getKind();
 386          switch (sqlKind) {
 387              case INSERT:
 388                  SqlNode sqlSource = ((SqlInsert) sqlNode).getSource();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 389 -                replaceFieldName(sqlSource, mappingTable, targetTableName, tableAlias);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 390 +                replaceFieldName(sqlSource, replaceInfo);</span>
 391                  break;
 392              case AS:
 393                  SqlNode asNode = ((SqlBasicCall) sqlNode).getOperands()[0];
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 394 -                replaceFieldName(asNode, mappingTable, targetTableName, tableAlias);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 395 +                replaceFieldName(asNode, replaceInfo);</span>
 396                  break;
 397              case SELECT:
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 398 -                SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, targetTableName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 399 +                SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTargetTableName());"> 399 +                SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTargetTableName🔵</abbr></span>
 400                  if(sqlSelect == null){
 401                      return;
 402                  }
 403  
 404                  SqlNode sqlSource1 = sqlSelect.getFrom();
 405                  if(sqlSource1.getKind() == AS){
 406                      String tableName = ((SqlBasicCall)sqlSource1).getOperands()[0].toString();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 407 -                    if(tableName.equalsIgnoreCase(targetTableName)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 408 +                    if(tableName.equalsIgnoreCase(replaceInfo.getTargetTableName())){</span>
 409                          SqlNodeList sqlSelectList = sqlSelect.getSelectList();
 410                          SqlNode whereNode = sqlSelect.getWhere();
 411                          SqlNodeList sqlGroup = sqlSelect.getGroup();
 412  
 413                          //TODO 暂时不处理having
 414                          SqlNode sqlHaving = sqlSelect.getHaving();
 415  
 416                          List&lt;SqlNode&gt; newSelectNodeList = Lists.newArrayList();
 417                          for( int i=0; i&lt;sqlSelectList.getList().size(); i++){
 418                              SqlNode selectNode = sqlSelectList.getList().get(i);
 419                              //特殊处理 isStar的标识
 420                              if(selectNode.getKind() == IDENTIFIER &amp;&amp; ((SqlIdentifier) selectNode).isStar()){
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 421 -                                List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, mappingTable, tableAlias);"> 421 -                                List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, mappingTabl🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 422 +                                List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, replaceInfo);"> 422 +                                List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, replaceInfo🔵</abbr></span>
 423                                  newSelectNodeList.addAll(replaceNodeList);
 424                                  continue;
 425                              }
 426  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 427 -                            SqlNode replaceNode = replaceSelectFieldName(selectNode, mappingTable, tableAlias);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 428 +                            SqlNode replaceNode = replaceSelectFieldName(selectNode, replaceInfo);</span>
 429                              if(replaceNode == null){
 430                                  continue;
 431                              }
 432  
 433                              //sqlSelectList.set(i, replaceNode);
 434                              newSelectNodeList.add(replaceNode);
 435                          }
 436  
<abbr title=" 437                          SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosition());"> 437                          SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosi🔵</abbr>
 438                          sqlSelect.setSelectList(newSelectList);
 439  
 440                          //where
 441                          if(whereNode != null){
 442                              SqlNode[] sqlNodeList = ((SqlBasicCall)whereNode).getOperands();
 443                              for(int i =0; i&lt;sqlNodeList.length; i++) {
 444                                  SqlNode whereSqlNode = sqlNodeList[i];
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 445 -                                SqlNode replaceNode = replaceNodeInfo(whereSqlNode, mappingTable, tableAlias);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 446 +                                SqlNode replaceNode = replaceNodeInfo(whereSqlNode, replaceInfo);</span>
 447                                  sqlNodeList[i] = replaceNode;
 448                              }
 449                          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 450 -</span>
 451                          if(sqlGroup != null &amp;&amp; CollectionUtils.isNotEmpty(sqlGroup.getList())){
 452                              for( int i=0; i&lt;sqlGroup.getList().size(); i++){
 453                                  SqlNode selectNode = sqlGroup.getList().get(i);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 454 -                                SqlNode replaceNode = replaceNodeInfo(selectNode, mappingTable, tableAlias);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 455 +                                SqlNode replaceNode = replaceNodeInfo(selectNode, replaceInfo);</span>
 456                                  sqlGroup.set(i, replaceNode);
 457                              }
 458                          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 459 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 460 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 461 -                        System.out.println(&quot;-----------------&quot;);</span>
 462                      }
 463                  }else{
 464                      //TODO
 465                      System.out.println(sqlNode);
 466                      throw new RuntimeException(&quot;---not deal type:&quot; + sqlNode);
 467                  }
 468  
 469                  break;
 470              case UNION:
 471                  SqlNode unionLeft = ((SqlBasicCall) sqlNode).getOperands()[0];
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 472 -</span>
 473                  SqlNode unionRight = ((SqlBasicCall) sqlNode).getOperands()[1];
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 474 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 475 -                replaceFieldName(unionLeft, mappingTable, targetTableName, tableAlias);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 476 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 477 -                replaceFieldName(unionRight, mappingTable, targetTableName, tableAlias);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 478 +                replaceFieldName(unionLeft, replaceInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 479 +                replaceFieldName(unionRight, replaceInfo);</span>
 480  
 481                  break;
 482              case ORDER_BY:
 483                  SqlOrderBy sqlOrderBy  = (SqlOrderBy) sqlNode;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 484 -                replaceFieldName(sqlOrderBy.query, mappingTable, targetTableName, tableAlias);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 485 +                replaceFieldName(sqlOrderBy.query, replaceInfo);</span>
 486                  SqlNodeList orderFiledList = sqlOrderBy.orderList;
 487                  for (int i=0 ;i&lt;orderFiledList.size();i++) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 488 -                    SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), tableAlias);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 489 +                    SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTableAlias());"> 489 +                    SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTabl🔵</abbr></span>
 490                      orderFiledList.set(i, replaceNode);
 491                  }
 492  
 493              default:
 494                  break;
 495          }
 496      }
 497  
 498      private SqlNode replaceOrderByTableName(SqlNode orderNode, String tableAlias) {
 499          if(orderNode.getKind() == IDENTIFIER){
 500              SqlIdentifier sqlIdentifier = (SqlIdentifier) orderNode;
 501              if (sqlIdentifier.names.size() == 1) {
 502                  return orderNode;
 503              }
 504              return sqlIdentifier.setName(0, tableAlias);
 505          } else if (orderNode instanceof  SqlBasicCall) {
 506              SqlBasicCall sqlBasicCall = (SqlBasicCall) orderNode;
 507              for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 508                  SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 509                  sqlBasicCall.getOperands()[i] = replaceOrderByTableName(sqlNode , tableAlias);
 510              }
 511              return sqlBasicCall;
 512          } else {
 513              return orderNode;
 514          }
 515      }
 516  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 517 -    private SqlNode replaceNodeInfo(SqlNode groupNode, HashBasedTable&lt;String, String, String&gt; mappingTable, String tableAlias){"> 517 -    private SqlNode replaceNodeInfo(SqlNode groupNode, HashBasedTable&lt;String, String, String&gt; mappingTable, String🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 518 +    private SqlNode replaceNodeInfo(SqlNode groupNode, FieldReplaceInfo replaceInfo){</span>
 519          if(groupNode.getKind() == IDENTIFIER){
 520              SqlIdentifier sqlIdentifier = (SqlIdentifier) groupNode;
 521              if(sqlIdentifier.names.size() == 1){
 522                  return sqlIdentifier;
 523              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 524 -            String mappingFieldName = mappingTable.get(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 524 -            String mappingFieldName = mappingTable.get(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.ge🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 525 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 526 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 527 +            String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 527 +            String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sq🔵</abbr></span>
 528              if(mappingFieldName == null){
 529                  throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + sqlIdentifier.toString() );
 530              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 531 -            sqlIdentifier = sqlIdentifier.setName(0, tableAlias);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 532 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 533 +            sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());</span>
 534              return sqlIdentifier.setName(1, mappingFieldName);
 535          }else if(groupNode instanceof  SqlBasicCall){
 536              SqlBasicCall sqlBasicCall = (SqlBasicCall) groupNode;
 537              for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 538                  SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 539 -                SqlNode replaceNode = replaceSelectFieldName(sqlNode, mappingTable, tableAlias);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 540 +                SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);</span>
 541                  sqlBasicCall.getOperands()[i] = replaceNode;
 542              }
 543  
 544              return sqlBasicCall;
 545          }else{
 546              return groupNode;
 547          }
 548      }
 549  
 550      public SqlNode filterNodeWithTargetName(SqlNode sqlNode, String targetTableName) {
 551  
 552          SqlKind sqlKind = sqlNode.getKind();
 553          switch (sqlKind){
 554              case SELECT:
 555                  SqlNode fromNode = ((SqlSelect)sqlNode).getFrom();
 556                  if(fromNode.getKind() == AS &amp;&amp; ((SqlBasicCall)fromNode).getOperands()[0].getKind() == IDENTIFIER){
 557                      if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableName)){
 558                          return sqlNode;
 559                      }else{
 560                          return null;
 561                      }
 562                  }else{
 563                      return filterNodeWithTargetName(fromNode, targetTableName);
 564                  }
 565              case AS:
 566                  SqlNode childNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 567                  return filterNodeWithTargetName(childNode, targetTableName);
 568              case JOIN:
 569                  SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 570                  SqlNode rightNode =  ((SqlJoin)sqlNode).getRight();
 571                  SqlNode leftReturnNode = filterNodeWithTargetName(leftNode, targetTableName);
 572                  SqlNode rightReturnNode = filterNodeWithTargetName(rightNode, targetTableName);
 573  
 574                  if(leftReturnNode != null) {
 575                      return leftReturnNode;
 576                  }else if(rightReturnNode != null){
 577                      return rightReturnNode;
 578                  }else{
 579                      return null;
 580                  }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 581 +            default:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 582 +                break;</span>
 583          }
 584  
 585          return null;
 586      }
 587  
 588  
 589      public void setLocalSqlPluginPath(String localSqlPluginPath) {
 590          this.localSqlPluginPath = localSqlPluginPath;
 591      }
 592  
 593      private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){
 594          Table table = localTableCache.get(tableAlias);
 595          if(table == null){
 596              table = localTableCache.get(tableName);
 597          }
 598  
 599          if(table == null){
 600              throw new RuntimeException(&quot;not register table &quot; + tableName);
 601          }
 602  
 603          return table;
 604      }
 605  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 606 -    private List&lt;SqlNode&gt; replaceSelectStarFieldName(SqlNode selectNode, HashBasedTable&lt;String, String, String&gt; mappingTable, String tableAlias){"> 606 -    private List&lt;SqlNode&gt; replaceSelectStarFieldName(SqlNode selectNode, HashBasedTable&lt;String, String, String&gt; ma🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 607 +    private List&lt;SqlNode&gt; replaceSelectStarFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo){</span>
 608          SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 609          List&lt;SqlNode&gt; sqlNodes = Lists.newArrayList();
 610          if(sqlIdentifier.isStar()){//处理 [* or table.*]
 611              int identifierSize = sqlIdentifier.names.size();
 612              Collection&lt;String&gt; columns = null;
 613              if(identifierSize == 1){
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 614 -                columns = mappingTable.values();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 615 +                columns = replaceInfo.getMappingTable().values();</span>
 616              }else{
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 617 -                columns = mappingTable.row(sqlIdentifier.names.get(0)).values();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 618 +                columns = replaceInfo.getMappingTable().row(sqlIdentifier.names.get(0)).values();</span>
 619              }
 620  
 621              for(String colAlias : columns){
 622                  SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 623                  List&lt;String&gt; columnInfo = Lists.newArrayList();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 624 -                columnInfo.add(tableAlias);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 625 +                columnInfo.add(replaceInfo.getTargetTableAlias());</span>
 626                  columnInfo.add(colAlias);
 627                  SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(columnInfo, sqlParserPos);
 628                  sqlNodes.add(sqlIdentifierAlias);
 629              }
 630  
 631              return sqlNodes;
 632          }else{
 633              throw new RuntimeException(&quot;is not a star select field.&quot; + selectNode);
 634          }
 635      }
 636  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 637 -    private SqlNode replaceSelectFieldName(SqlNode selectNode, HashBasedTable&lt;String, String, String&gt; mappingTable, String tableAlias) {"> 637 -    private SqlNode replaceSelectFieldName(SqlNode selectNode, HashBasedTable&lt;String, String, String&gt; mappingTable🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 638 +    private SqlNode replaceSelectFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo) {</span>
 639          if (selectNode.getKind() == AS) {
 640              SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 641 -            SqlNode replaceNode = replaceSelectFieldName(leftNode, mappingTable, tableAlias);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 642 +            SqlNode replaceNode = replaceSelectFieldName(leftNode, replaceInfo);</span>
 643              if (replaceNode != null) {
 644                  ((SqlBasicCall) selectNode).getOperands()[0] = replaceNode;
 645              }
 646  
 647              return selectNode;
 648          }else if(selectNode.getKind() == IDENTIFIER){
 649              SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 650  
 651              if(sqlIdentifier.names.size() == 1){
 652                  return selectNode;
 653              }
 654  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 655 -            String mappingFieldName = mappingTable.get(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 655 -            String mappingFieldName = mappingTable.get(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.ge🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 656 -            if(mappingFieldName == null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 657 -               throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + selectNode.toString() );</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 658 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 659 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 660 -            sqlIdentifier = sqlIdentifier.setName(0, tableAlias);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 661 +            //Same level mappingTable</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 662 +            String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 662 +            String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sq🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 663 +            if (mappingFieldName == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 664 +                throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + selectNode.toString() );</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 665 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 666 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 667 +            sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());</span>
 668              sqlIdentifier = sqlIdentifier.setName(1, mappingFieldName);
 669              return sqlIdentifier;
 670          }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//字面含义
 671              return selectNode;
 672          }else if(  AGGREGATE.contains(selectNode.getKind())
 673                  || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 674                  || COMPARISON.contains(selectNode.getKind())
 675                  || selectNode.getKind() == OTHER_FUNCTION
 676                  || selectNode.getKind() == DIVIDE
 677                  || selectNode.getKind() == CAST
 678                  || selectNode.getKind() == TRIM
 679                  || selectNode.getKind() == TIMES
 680                  || selectNode.getKind() == PLUS
 681                  || selectNode.getKind() == NOT_IN
 682                  || selectNode.getKind() == OR
 683                  || selectNode.getKind() == AND
 684                  || selectNode.getKind() == MINUS
 685                  || selectNode.getKind() == TUMBLE
 686                  || selectNode.getKind() == TUMBLE_START
 687                  || selectNode.getKind() == TUMBLE_END
 688                  || selectNode.getKind() == SESSION
 689                  || selectNode.getKind() == SESSION_START
 690                  || selectNode.getKind() == SESSION_END
 691                  || selectNode.getKind() == HOP
 692                  || selectNode.getKind() == HOP_START
 693                  || selectNode.getKind() == HOP_END
 694                  || selectNode.getKind() == BETWEEN
 695                  || selectNode.getKind() == IS_NULL
 696                  || selectNode.getKind() == IS_NOT_NULL
 697                  || selectNode.getKind() == CONTAINS
 698                  || selectNode.getKind() == TIMESTAMP_ADD
 699                  || selectNode.getKind() == TIMESTAMP_DIFF
 700                  || selectNode.getKind() == LIKE
 701  
 702                  ){
 703              SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 704              for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 705                  SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 706                  if(sqlNode instanceof SqlLiteral){
 707                      continue;
 708                  }
 709  
 710                  if(sqlNode instanceof SqlDataTypeSpec){
 711                      continue;
 712                  }
 713  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 714 -                SqlNode replaceNode = replaceSelectFieldName(sqlNode, mappingTable, tableAlias);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 715 +                SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);</span>
 716                  if(replaceNode == null){
 717                      continue;
 718                  }
 719  
 720                  sqlBasicCall.getOperands()[i] = replaceNode;
 721              }
 722  
 723              return selectNode;
 724          }else if(selectNode.getKind() == CASE){
 725              System.out.println(&quot;selectNode&quot;);
 726              SqlCase sqlCase = (SqlCase) selectNode;
 727              SqlNodeList whenOperands = sqlCase.getWhenOperands();
 728              SqlNodeList thenOperands = sqlCase.getThenOperands();
 729              SqlNode elseNode = sqlCase.getElseOperand();
 730  
 731              for(int i=0; i&lt;whenOperands.size(); i++){
 732                  SqlNode oneOperand = whenOperands.get(i);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 733 -                SqlNode replaceNode = replaceSelectFieldName(oneOperand, mappingTable, tableAlias);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 734 +                SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);</span>
 735                  if (replaceNode != null) {
 736                      whenOperands.set(i, replaceNode);
 737                  }
 738              }
 739  
 740              for(int i=0; i&lt;thenOperands.size(); i++){
 741                  SqlNode oneOperand = thenOperands.get(i);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 742 -                SqlNode replaceNode = replaceSelectFieldName(oneOperand, mappingTable, tableAlias);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 743 +                SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);</span>
 744                  if (replaceNode != null) {
 745                      thenOperands.set(i, replaceNode);
 746                  }
 747              }
 748  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 749 -            ((SqlCase) selectNode).setOperand(3, replaceSelectFieldName(elseNode, mappingTable, tableAlias));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 750 +            ((SqlCase) selectNode).setOperand(3, replaceSelectFieldName(elseNode, replaceInfo));</span>
 751              return selectNode;
 752          }else if(selectNode.getKind() == OTHER){
 753              //不处理
 754              return selectNode;
 755          }else{
<abbr title=" 756              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 756              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNod🔵</abbr>
 757          }
 758      }
 759  
 760      /**
<abbr title=" 761       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 761       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension 🔵</abbr>
 762       *
 763       * @return
 764       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 765 -    private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, SideTableInfo sideTableInfo) {"> 765 -    private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, SideTableInfo sideTableInfo) 🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 766 +    private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 766 +    private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTab🔵</abbr></span>
 767          List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 768          if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 769              return true;
 770          }
 771          return false;
 772      }
 773  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 774 -    private List&lt;String&gt; convertPrimaryAlias(SideTableInfo sideTableInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 775 +    private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {</span>
 776          List&lt;String&gt; res = Lists.newArrayList();
 777          sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 778              res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 779          });
 780          return res;
 781      }
 782  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 783 -    public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, SideTableInfo sideTableInfo){"> 783 -    public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, SideTableInfo sideTable🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 784 +    public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 784 +    public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo s🔵</abbr></span>
 785          List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 786          ParseUtils.parseAnd(conditionNode, sqlNodeList);
 787          List&lt;String&gt; conditionFields = Lists.newArrayList();
 788          for(SqlNode sqlNode : sqlNodeList){
 789              if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 790                  throw new RuntimeException(&quot;not compare operator.&quot;);
 791              }
 792  
 793              SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 794              SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 795  
 796              String leftTableName = left.getComponent(0).getSimple();
 797              String rightTableName = right.getComponent(0).getSimple();
 798  
 799              String tableCol = &quot;&quot;;
 800              if(leftTableName.equalsIgnoreCase(specifyTableName)){
 801                  tableCol = left.getComponent(1).getSimple();
 802              }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 803                  tableCol = right.getComponent(1).getSimple();
 804              }else{
<abbr title=" 805                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 805                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName🔵</abbr>
 806              }
 807              tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 808              conditionFields.add(tableCol);
 809          }
 810  
 811          return conditionFields;
 812      }
 813  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 814 -    public void registerTmpTable(CreateTmpTableParser.SqlParserResult result,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 815 -                                 Map&lt;String, SideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 816 -                                 Map&lt;String, Table&gt; tableCache)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 817 -            throws Exception {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 818 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 819 -        if(localSqlPluginPath == null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 820 -            throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 821 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 822 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 823 -        localTableCache.putAll(tableCache);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 824 -        Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(result.getExecSql(), sideTableMap.keySet());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 825 -        Object pollObj = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 826 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 827 -        //need clean</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 828 -        boolean preIsSideJoin = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 829 -        List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 830 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 831 -        while((pollObj = exeQueue.poll()) != null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 832 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 833 -            if(pollObj instanceof SqlNode){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 834 -                SqlNode pollSqlNode = (SqlNode) pollObj;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 835 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 836 -                if(preIsSideJoin){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 837 -                    preIsSideJoin = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 838 -                    List&lt;String&gt; fieldNames = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 839 -                    for (FieldReplaceInfo replaceInfo : replaceInfoList) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 840 -                        fieldNames = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 841 -                        replaceFieldName(pollSqlNode, replaceInfo.getMappingTable(), replaceInfo.getTargetTableName(), replaceInfo.getTargetTableAlias());"> 841 -                        replaceFieldName(pollSqlNode, replaceInfo.getMappingTable(), replaceInfo.getTargetTableNam🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 842 -                        addAliasForFieldNode(pollSqlNode, fieldNames, replaceInfo.getMappingTable());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 843 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 844 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 845 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 846 -                if(pollSqlNode.getKind() == INSERT){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 847 -                    tableEnv.sqlUpdate(pollSqlNode.toString());</span>


<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 848 -                }else if(pollSqlNode.getKind() == AS){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 849 -                    AliasInfo aliasInfo = parseASNode(pollSqlNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 850 -                    Table table = tableEnv.sqlQuery(aliasInfo.getName());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 851 -                    tableEnv.registerTable(aliasInfo.getAlias(), table);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 852 -                    if(LOG.isInfoEnabled()){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 853 -                        LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 854 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 855 -                    localTableCache.put(aliasInfo.getAlias(), table);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 856 -                } else if (pollSqlNode.getKind() == SELECT){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 857 -                    Table table = tableEnv.sqlQuery(pollObj.toString());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 858 -                    if (result.getFieldsInfoStr() == null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 859 -                        tableEnv.registerTable(result.getTableName(), table);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 860 -                    } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 861 -                        if (checkFieldsInfo(result, table)){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 862 -                            table = table.as(tmpFields);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 863 -                            tableEnv.registerTable(result.getTableName(), table);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 864 -                        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 865 -                            throw new RuntimeException(&quot;Fields mismatch&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 866 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 867 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 868 -                    localTableCache.put(result.getTableName(), table);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 869 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 870 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 871 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 872 -            }else if (pollObj instanceof JoinInfo){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 873 -                preIsSideJoin = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 874 -                joinFun(pollObj, localTableCache, sideTableMap, tableEnv, replaceInfoList);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 875 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 876 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 877 +    protected void dealAsSourceTable(StreamTableEnvironment tableEnv,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 878 +                                     SqlNode pollSqlNode,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 879 +                                     Map&lt;String, Table&gt; tableCache,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 880 +                                     List&lt;FieldReplaceInfo&gt; replaceInfoList) throws SqlParseException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 881 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 882 +        AliasInfo aliasInfo = parseAsNode(pollSqlNode);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 883 +        if (localTableCache.containsKey(aliasInfo.getName())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 884 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 885 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 886 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 887 +        Table table = tableEnv.sqlQuery(aliasInfo.getName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 888 +        tableEnv.registerTable(aliasInfo.getAlias(), table);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 889 +        localTableCache.put(aliasInfo.getAlias(), table);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 890 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 891 +        LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 892 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 893 +        FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 894 +        if(fieldReplaceInfo == null){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 895 +           return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 896 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 897 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 898 +        //as 的源表</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 899 +        Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 900 +        SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 901 +        TableUtils.getFromTableInfo(fromNode, fromTableNameSet);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 902 +        for(FieldReplaceInfo tmp : replaceInfoList){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 903 +            if(fromTableNameSet.contains(tmp.getTargetTableName())</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 904 +                    || fromTableNameSet.contains(tmp.getTargetTableAlias())){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 905 +                fieldReplaceInfo.setPreNode(tmp);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 906 +                break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 907 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 908 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 909 +        replaceInfoList.add(fieldReplaceInfo);</span>
 910      }
 911  
 912      private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 913 -                         Map&lt;String, SideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 914 +                         Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,</span>
 915                           List&lt;FieldReplaceInfo&gt; replaceInfoList) throws Exception{
 916          JoinInfo joinInfo = (JoinInfo) pollObj;
 917  
 918          JoinScope joinScope = new JoinScope();
 919          JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 920          leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 921          leftScopeChild.setTableName(joinInfo.getLeftTableName());
 922  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 923 +        SqlKind sqlKind = joinInfo.getLeftNode().getKind();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 924 +        if(sqlKind == AS){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 925 +            dealAsSourceTable(tableEnv, joinInfo.getLeftNode(), localTableCache, replaceInfoList);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 926 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 927 +</span>
<abbr title=" 928          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 928          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableNa🔵</abbr>
<abbr title=" 929          RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColumnNames());"> 929          RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColu🔵</abbr>

 930          leftScopeChild.setRowTypeInfo(leftTypeInfo);
 931  
 932          JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 933          rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 934          rightScopeChild.setTableName(joinInfo.getRightTableName());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 935 -        SideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 936 +        AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());</span>
 937          if(sideTableInfo == null){
 938              sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 939          }
 940  
 941          if(sideTableInfo == null){
 942              throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 943          }
 944  
 945          if(!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)){
 946              throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);
 947          }
 948  
 949          rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 950  
 951          joinScope.addScope(leftScopeChild);
 952          joinScope.addScope(rightScopeChild);
 953  
 954          //获取两个表的所有字段
<abbr title=" 955          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 955          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, tr🔵</abbr>
 956  
 957          String leftTableAlias = joinInfo.getLeftTableAlias();
 958          Table targetTable = localTableCache.get(leftTableAlias);
 959          if(targetTable == null){
 960              targetTable = localTableCache.get(joinInfo.getLeftTableName());
 961          }
 962  
<abbr title=" 963          RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColumnNames());"> 963          RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColu🔵</abbr>

 964  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 965 -        DataStream adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 966 -                                .map((Tuple2&lt;Boolean, Row&gt; f0) -&gt; { return f0.f1; })</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 967 -                                .returns(Row.class);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 968 +        DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 969 +                .map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 970 +                    return new CRow(tp2.f1, tp2.f0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 971 +                }).returns(CRow.class);</span>
 972  

 973  
 974          //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 975 -        if(sideTableInfo.isPartitionedJoin()){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 976 -            RowTypeInfo leftTableOutType = buildLeftTableOutType(leftTypeInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 977 -            adaptStream.getTransformation().setOutputType(leftTableOutType);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 978 +        if (sideTableInfo.isPartitionedJoin()) {</span>
<abbr title=" 979              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 979              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(🔵</abbr>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 980 -            String[] leftJoinColArr = leftJoinColList.toArray(new String[leftJoinColList.size()]);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 981 -            adaptStream = adaptStream.keyBy(leftJoinColArr);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 982 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 983 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 984 -        DataStream dsOut = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 985 +            List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 986 +            int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 987 +            adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 987 +            adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 988 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 989 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 990 +        DataStream&lt;CRow&gt; dsOut = null;</span>
 991          if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title=" 992              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 992              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlP🔵</abbr>
 993          }else{
<abbr title=" 994              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 994              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPa🔵</abbr>
 995          }
 996  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 997 +        // TODO  将嵌套表中的字段传递过去, 去除冗余的ROWtime</span>
 998          HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 999          RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1000 -        dsOut.getTransformation().setOutputType(sideOutTypeInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1001 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1002 +        CRowTypeInfo cRowTypeInfo = new CRowTypeInfo(sideOutTypeInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1003 +        dsOut.getTransformation().setOutputType(cRowTypeInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1004 +</span>
1005          String targetTableName = joinInfo.getNewTableName();
1006          String targetTableAlias = joinInfo.getNewTableAlias();
1007  
1008          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
1009          replaceInfo.setMappingTable(mappingTable);
1010          replaceInfo.setTargetTableName(targetTableName);
1011          replaceInfo.setTargetTableAlias(targetTableAlias);
1012  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1013 +        //判断之前是不是被替换过,被替换过则设置之前的替换信息作为上一个节点</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1014 +        for(FieldReplaceInfo tmp : replaceInfoList){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1015 +            if(tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName())</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1016 +            ||tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableAlias())){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1017 +                replaceInfo.setPreNode(tmp);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1018 +                break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1019 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1020 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1021 +</span>
1022          replaceInfoList.add(replaceInfo);
1023  
1024          if (!tableEnv.isRegistered(joinInfo.getNewTableName())){


<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="1025 -            tableEnv.registerDataStream(joinInfo.getNewTableName(), dsOut, String.join(&quot;,&quot;, sideOutTypeInfo.getFieldNames()));">1025 -            tableEnv.registerDataStream(joinInfo.getNewTableName(), dsOut, String.join(&quot;,&quot;, sideOutTypeInfo.getFie🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1026 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1027 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1028 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1029 +            Table joinTable = tableEnv.fromDataStream(dsOut);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1030 +            tableEnv.registerTable(joinInfo.getNewTableName(), joinTable);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1031 +            localTableCache.put(joinInfo.getNewTableName(), joinTable);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1032 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1033 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1034 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1035 +    private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1036 +        String[] fieldNames = schema.getFieldNames();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1037 +        TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1038 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1039 +        String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="1040 +        TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);">1040 +        TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformat🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1041 +        return new RowTypeInfo(projectedTypes, projectedNames);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1042 +    }</span>
1043  


1044  
1045      private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
1046          List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
1047          String fieldsInfo = result.getFieldsInfoStr();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1048 -        String[] fields = fieldsInfo.split(&quot;,&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1049 +        String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);</span>
1050          for (int i = 0; i &lt; fields.length; i++) {
1051              String[] filed = fields[i].split(&quot;\\s&quot;);
1052              if (filed.length &lt; 2 || fields.length != table.getSchema().getColumnNames().length){

1053                  return false;
1054              } else {
1055                  String[] filedNameArr = new String[filed.length - 1];
1056                  System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
1057                  String fieldName = String.join(&quot; &quot;, filedNameArr);
1058                  fieldNames.add(fieldName);
1059                  String fieldType = filed[filed.length - 1 ].trim();
1060                  Class fieldClass = ClassUtil.stringConvertClass(fieldType);
1061                  Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
1062                  if (fieldClass == tableField){
1063                      continue;
1064                  } else {
1065                      return false;
1066                  }
1067              }
1068          }
1069          tmpFields = String.join(&quot;,&quot;, fieldNames);
1070          return true;
1071      }
1072  
1073  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            