<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>606</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    606
                    <a href="605.html">prev</a>
                    <a href="607.html">next</a>
                    <a href="606_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_8165f0dd202a2c0fbf0816f7613d66938955dc76_src/com/android/launcher2/LauncherModel.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;8165f0dd202a2c0fbf0816f7613d66938955dc76:src/com/android/launcher2/LauncherModel.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;8165f0dd202a2c0fbf0816f7613d66938955dc76^1:src/com/android/launcher2/LauncherModel.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;8165f0dd202a2c0fbf0816f7613d66938955dc76^2:src/com/android/launcher2/LauncherModel.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;0ede734d0780a968c9c345f99a18f9f8b9fc02cd:src/com/android/launcher2/LauncherModel.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bj]], subset: [[bj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher2;
  18 
  19 import android.app.SearchManager;
  20 import android.appwidget.AppWidgetManager;
  21 import android.appwidget.AppWidgetProviderInfo;
  22 import android.content.BroadcastReceiver;
  23 import android.content.ComponentName;
  24 import android.content.ContentProviderClient;
  25 import android.content.ContentResolver;
  26 import android.content.ContentValues;
  27 import android.content.Context;
  28 import android.content.Intent;
  29 import android.content.Intent.ShortcutIconResource;
  30 import android.content.pm.ActivityInfo;
  31 import android.content.pm.PackageInfo;
  32 import android.content.pm.PackageManager;
  33 import android.content.pm.PackageManager.NameNotFoundException;
  34 import android.content.pm.ResolveInfo;
  35 import android.content.res.Configuration;
  36 import android.content.res.Resources;
  37 import android.database.Cursor;
  38 import android.graphics.Bitmap;
  39 import android.graphics.BitmapFactory;
  40 import android.net.Uri;
  41 import android.os.Environment;
  42 import android.os.Handler;
  43 import android.os.HandlerThread;
  44 import android.os.Parcelable;
  45 import android.os.Process;
  46 import android.os.RemoteException;
  47 import android.os.SystemClock;
  48 import android.util.Log;
  49 
  50 import com.android.launcher.R;
  51 import com.android.launcher2.InstallWidgetReceiver.WidgetMimeTypeHandlerData;
  52 
  53 import java.lang.ref.WeakReference;
  54 import java.net.URISyntaxException;
  55 import java.text.Collator;
  56 import java.util.ArrayList;
  57 import java.util.Collections;
  58 import java.util.Comparator;
  59 import java.util.HashMap;
  60 import java.util.HashSet;
  61 import java.util.Iterator;
  62 import java.util.List;
  63 import java.util.Set;
  64 
  65 /**
  66  * Maintains in-memory state of the Launcher. It is expected that there should be only one
  67  * LauncherModel object held in a static. Also provide APIs for updating the database state
  68  * for the Launcher.
  69  */
  70 public class LauncherModel extends BroadcastReceiver {
  71     static final boolean DEBUG_LOADERS = false;
  72     static final String TAG = &quot;Launcher.Model&quot;;
  73 
  74     private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
  75     private final boolean mAppsCanBeOnExternalStorage;
  76     private int mBatchSize; // 0 is all apps at once
  77     private int mAllAppsLoadDelay; // milliseconds between batches
  78 
  79     private final LauncherApplication mApp;
  80     private final Object mLock = new Object();
  81     private DeferredHandler mHandler = new DeferredHandler();
  82     private LoaderTask mLoaderTask;
  83     private boolean mIsLoaderTaskRunning;
  84 
  85     private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
  86     static {
  87         sWorkerThread.start();
  88     }
  89     private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
  90 
  91     // We start off with everything not loaded.  After that, we assume that
  92     // our monitoring of the package manager provides all updates and we never
  93     // need to do a requery.  These are only ever touched from the loader thread.
  94     private boolean mWorkspaceLoaded;
  95     private boolean mAllAppsLoaded;
  96 
  97     // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
  98     // pages as this delays the rotation process.  Instead, we wait for a callback from the first
  99     // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 100     // a normal load, we also clear this set of Runnables.
 101     static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 102 
 103     private WeakReference&lt;Callbacks&gt; mCallbacks;
 104 
 105     // &lt; only access in worker thread &gt;
 106     private AllAppsList mBgAllAppsList;
 107 
 108     // The lock that must be acquired before referencing any static bg data structures.  Unlike
 109     // other locks, this one can generally be held long-term because we never expect any of these
 110     // static data structures to be referenced outside of the worker thread except on the first
 111     // load after configuration change.
 112     static final Object sBgLock = new Object();
 113 
 114     // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 115     // LauncherModel to their ids
 116     static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
 117 
 118     // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 119     //       created by LauncherModel that are directly on the home screen (however, no widgets or
 120     //       shortcuts within folders).
 121     static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 122 
 123     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 124     static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 125         new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 126 
 127     // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 128     static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 129 
 130     // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 131     static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 132     // &lt;/ only access in worker thread &gt;
 133 
 134     private IconCache mIconCache;
 135     private Bitmap mDefaultIcon;
 136 
 137     private static int mCellCountX;
 138     private static int mCellCountY;
 139 
 140     protected int mPreviousConfigMcc;
 141 
 142     public interface Callbacks {
 143         public boolean setLoadOnResume();
 144         public int getCurrentWorkspaceScreen();
 145         public void startBinding();
 146         public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end);
 147         public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 148         public void finishBindingItems();
 149         public void bindAppWidget(LauncherAppWidgetInfo info);
 150         public void bindAllApplications(ArrayList&lt;ApplicationInfo&gt; apps);
 151         public void bindAppsAdded(ArrayList&lt;ApplicationInfo&gt; apps);
 152         public void bindAppsUpdated(ArrayList&lt;ApplicationInfo&gt; apps);
 153         public void bindAppsRemoved(ArrayList&lt;String&gt; packageNames, boolean permanent);
 154         public void bindPackagesUpdated();
 155         public boolean isAllAppsVisible();
 156         public boolean isAllAppsButtonRank(int rank);
 157         public void bindSearchablesChanged();
 158         public void onPageBoundSynchronously(int page);
 159     }
 160 
 161     LauncherModel(LauncherApplication app, IconCache iconCache) {
 162         mAppsCanBeOnExternalStorage = !Environment.isExternalStorageEmulated();
 163         mApp = app;
 164         mBgAllAppsList = new AllAppsList(iconCache);
 165         mIconCache = iconCache;
 166 
 167         mDefaultIcon = Utilities.createIconBitmap(
 168                 mIconCache.getFullResDefaultActivityIcon(), app);
 169 
 170         final Resources res = app.getResources();
 171         mAllAppsLoadDelay = res.getInteger(R.integer.config_allAppsBatchLoadDelay);
 172         mBatchSize = res.getInteger(R.integer.config_allAppsBatchSize);
 173         Configuration config = res.getConfiguration();
 174         mPreviousConfigMcc = config.mcc;
 175     }
 176 
 177     /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 178      * posted on the main thread handler. */
 179     private void runOnMainThread(Runnable r) {
 180         if (sWorkerThread.getThreadId() == Process.myTid()) {
 181             // If we are on the worker thread, post onto the main handler
 182             mHandler.post(r);
 183         } else {
 184             r.run();
 185         }
 186     }
 187 
 188     /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 189      * posted on the worker thread handler. */
 190     private static void runOnWorkerThread(Runnable r) {
 191         if (sWorkerThread.getThreadId() == Process.myTid()) {
 192             r.run();
 193         } else {
 194             // If we are not on the worker thread, then post to the worker handler
 195             sWorker.post(r);
 196         }
 197     }
 198 
 199     public Bitmap getFallbackIcon() {
 200         return Bitmap.createBitmap(mDefaultIcon);
 201     }
 202 
 203     public void unbindWorkspaceItems() {
 204         sWorker.post(new Runnable() {
 205             @Override
 206             public void run() {
 207                 unbindWorkspaceItemsOnMainThread();
 208             }
 209         });
 210     }
 211 
 212     /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 213     private void unbindWorkspaceItemsOnMainThread() {
 214         // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 215         // by making a copy of workspace items first.
 216         final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 217         final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 218         synchronized (sBgLock) {
 219             tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 220             tmpAppWidgets.addAll(sBgAppWidgets);
 221         }
 222         Runnable r = new Runnable() {
 223                 @Override
 224                 public void run() {
 225                    for (ItemInfo item : tmpWorkspaceItems) {
 226                        item.unbind();
 227                    }
 228                    for (ItemInfo item : tmpAppWidgets) {
 229                        item.unbind();
 230                    }
 231                 }
 232             };
 233         runOnMainThread(r);
 234     }
 235 
 236     /**
 237      * Adds an item to the DB if it was not created previously, or move it to a new
 238      * &lt;container, screen, cellX, cellY&gt;
 239      */
 240     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 241             int screen, int cellX, int cellY) {
 242         if (item.container == ItemInfo.NO_ID) {
 243             // From all apps
 244             addItemToDatabase(context, item, container, screen, cellX, cellY, false);
 245         } else {
 246             // From somewhere else
 247             moveItemInDatabase(context, item, container, screen, cellX, cellY);
 248         }
 249     }
 250 
 251     static void checkItemInfo(final ItemInfo item) {
 252         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 253         final long itemId = item.id;
 254         Runnable r = new Runnable() {
 255                 public void run() {
 256                     synchronized (sBgLock) {
 257                         ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 258                         if (modelItem != null &amp;&amp; item != modelItem) {
 259                             // the modelItem needs to match up perfectly with item if our model is
 260                             // to be consistent with the database-- for now, just require
 261                             // modelItem == item
 262                             String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 263                                 &quot;modelItem: &quot; +
 264                                     ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 265                                 &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 266                             RuntimeException e = new RuntimeException(msg);
 267                             e.setStackTrace(stackTrace);
 268                             throw e;
 269                         }
 270                     }
 271                 }
 272             };
 273         runOnWorkerThread(r);
 274     }
 275 
 276     static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 277             final ItemInfo item, final String callingFunction) {
 278         final long itemId = item.id;
 279         final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 280         final ContentResolver cr = context.getContentResolver();
 281 
 282         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 283         Runnable r = new Runnable() {
 284             public void run() {
 285                 cr.update(uri, values, null, null);
 286 
 287                 // Lock on mBgLock *after* the db operation
 288                 synchronized (sBgLock) {
 289                     ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 290                     if (item != modelItem) {
 291                         // the modelItem needs to match up perfectly with item if our model is to be
 292                         // consistent with the database-- for now, just require modelItem == item
 293                         String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 294                             &quot;modelItem: &quot; + ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 295                             &quot;Error: ItemInfo passed to &quot; + callingFunction + &quot; doesn&#x27;t match &quot; +
 296                             &quot;original&quot;;
 297                         throw new RuntimeException(msg);
 298                     }
 299 
 300                     if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
 301                             item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 302                         // Item is in a folder, make sure this folder exists
 303                         if (!sBgFolders.containsKey(item.container)) {
 304                             // An items container is being set to a that of an item which is not in
 305                             // the list of Folders.
 306                             String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +
 307                                     item.container + &quot;, not in the list of folders&quot;;
 308                             RuntimeException e = new RuntimeException(msg);
 309                             e.setStackTrace(stackTrace);
 310                             Launcher.dumpDebugLogsToConsole();
 311                             throw e;
 312                         }
 313                     }
 314 
 315                     // Items are added/removed from the corresponding FolderInfo elsewhere, such
 316                     // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 317                     // that are on the desktop, as appropriate
 318                     if (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 319                             modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 320                         switch (modelItem.itemType) {
 321                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 322                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 323                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 324                                 if (!sBgWorkspaceItems.contains(modelItem)) {
 325                                     sBgWorkspaceItems.add(modelItem);
 326                                 }
 327                                 break;
 328                             default:
 329                                 break;
 330                         }
 331                     } else {
 332                         sBgWorkspaceItems.remove(modelItem);
 333                     }
 334                 }
 335             }
 336         };
 337         runOnWorkerThread(r);
 338     }
 339 
 340     /**
 341      * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 342      */
 343     static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 344             final int screen, final int cellX, final int cellY) {
 345         String transaction = &quot;DbDebug    Modify item (&quot; + item.title + &quot;) in db, id: &quot; + item.id + 
 346                 &quot; (&quot; + item.container + &quot;, &quot; + item.screen + &quot;, &quot; + item.cellX + &quot;, &quot; + item.cellY + 
 347                 &quot;) --&gt; &quot; + &quot;(&quot; + container + &quot;, &quot; + screen + &quot;, &quot; + cellX + &quot;, &quot; + cellY + &quot;)&quot;;
 348         Launcher.sDumpLogs.add(transaction);
 349         Log.d(TAG, transaction);
 350         item.container = container;
 351         item.cellX = cellX;
 352         item.cellY = cellY;
 353 
 354         // We store hotseat items in canonical form which is this orientation invariant position
 355         // in the hotseat
 356         if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 357                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 358             item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 359         } else {
 360             item.screen = screen;
 361         }
 362 
 363         final ContentValues values = new ContentValues();
 364         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 365         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 366         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 367         values.put(LauncherSettings.Favorites.SCREEN, item.screen);
 368 
 369         updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 370     }
 371 
 372     /**
 373      * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 374      */
 375     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 376             final int screen, final int cellX, final int cellY, final int spanX, final int spanY) {
 377         String transaction = &quot;DbDebug    Modify item (&quot; + item.title + &quot;) in db, id: &quot; + item.id + 
 378                 &quot; (&quot; + item.container + &quot;, &quot; + item.screen + &quot;, &quot; + item.cellX + &quot;, &quot; + item.cellY + 
 379                 &quot;) --&gt; &quot; + &quot;(&quot; + container + &quot;, &quot; + screen + &quot;, &quot; + cellX + &quot;, &quot; + cellY + &quot;)&quot;;
 380         Launcher.sDumpLogs.add(transaction);
 381         Log.d(TAG, transaction);
 382         item.cellX = cellX;
 383         item.cellY = cellY;
 384         item.spanX = spanX;
 385         item.spanY = spanY;
 386 
 387         // We store hotseat items in canonical form which is this orientation invariant position
 388         // in the hotseat
 389         if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 390                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 391             item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 392         } else {
 393             item.screen = screen;
 394         }
 395 
 396         final ContentValues values = new ContentValues();
 397         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 398         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 399         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 400         values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 401         values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 402         values.put(LauncherSettings.Favorites.SCREEN, item.screen);
 403 
 404         updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 405     }
 406 
 407     /**
 408      * Update an item to the database in a specified container.
 409      */
 410     static void updateItemInDatabase(Context context, final ItemInfo item) {
 411         final ContentValues values = new ContentValues();
 412         item.onAddToDatabase(values);
 413         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 414         updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 415     }
 416 
 417     /**
 418      * Returns true if the shortcuts already exists in the database.
 419      * we identify a shortcut by its title and intent.
 420      */
 421     static boolean shortcutExists(Context context, String title, Intent intent) {
 422         final ContentResolver cr = context.getContentResolver();
 423         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 424             new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and intent=?&quot;,
 425             new String[] { title, intent.toUri(0) }, null);
 426         boolean result = false;
 427         try {
 428             result = c.moveToFirst();
 429         } finally {
 430             c.close();
 431         }
 432         return result;
 433     }
 434 
 435     /**
 436      * Returns an ItemInfo array containing all the items in the LauncherModel.
 437      * The ItemInfo.id is not set through this function.
 438      */
 439     static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 440         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 441         final ContentResolver cr = context.getContentResolver();
 442         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
 443                 LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
<abbr title=" 444                 LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,"> 444                 LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.FavðŸ”µ</abbr>
 445                 LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY }, null, null, null);
 446 
 447         final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 448         final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 449         final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 450         final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 451         final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 452         final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 453         final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 454 
 455         try {
 456             while (c.moveToNext()) {
 457                 ItemInfo item = new ItemInfo();
 458                 item.cellX = c.getInt(cellXIndex);
 459                 item.cellY = c.getInt(cellYIndex);
 460                 item.spanX = c.getInt(spanXIndex);
 461                 item.spanY = c.getInt(spanYIndex);
 462                 item.container = c.getInt(containerIndex);
 463                 item.itemType = c.getInt(itemTypeIndex);
 464                 item.screen = c.getInt(screenIndex);
 465 
 466                 items.add(item);
 467             }
 468         } catch (Exception e) {
 469             items.clear();
 470         } finally {
 471             c.close();
 472         }
 473 
 474         return items;
 475     }
 476 
 477     /**
 478      * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 479      */
 480     FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
 481         final ContentResolver cr = context.getContentResolver();
 482         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
 483                 &quot;_id=? and (itemType=? or itemType=?)&quot;,
 484                 new String[] { String.valueOf(id),
 485                         String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
 486 
 487         try {
 488             if (c.moveToFirst()) {
 489                 final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 490                 final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 491                 final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 492                 final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 493                 final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 494                 final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 495 
 496                 FolderInfo folderInfo = null;
 497                 switch (c.getInt(itemTypeIndex)) {
 498                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 499                         folderInfo = findOrMakeFolder(folderList, id);
 500                         break;
 501                 }
 502 
 503                 folderInfo.title = c.getString(titleIndex);
 504                 folderInfo.id = id;
 505                 folderInfo.container = c.getInt(containerIndex);
 506                 folderInfo.screen = c.getInt(screenIndex);
 507                 folderInfo.cellX = c.getInt(cellXIndex);
 508                 folderInfo.cellY = c.getInt(cellYIndex);
 509 
 510                 return folderInfo;
 511             }
 512         } finally {
 513             c.close();
 514         }
 515 
 516         return null;
 517     }
 518 
 519     /**
 520      * Add an item to the database in a specified container. Sets the container, screen, cellX and
 521      * cellY fields of the item. Also assigns an ID to the item.
 522      */
 523     static void addItemToDatabase(Context context, final ItemInfo item, final long container,
 524             final int screen, final int cellX, final int cellY, final boolean notify) {
 525         item.container = container;
 526         item.cellX = cellX;
 527         item.cellY = cellY;
 528         // We store hotseat items in canonical form which is this orientation invariant position
 529         // in the hotseat
 530         if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 531                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 532             item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 533         } else {
 534             item.screen = screen;
 535         }
 536 
 537         final ContentValues values = new ContentValues();
 538         final ContentResolver cr = context.getContentResolver();
 539         item.onAddToDatabase(values);
 540 
 541         LauncherApplication app = (LauncherApplication) context.getApplicationContext();
 542         item.id = app.getLauncherProvider().generateNewId();
 543         values.put(LauncherSettings.Favorites._ID, item.id);
 544         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 545 
 546         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 547 
 548         Runnable r = new Runnable() {
 549             public void run() {
 550                 String transaction = &quot;DbDebug    Add item (&quot; + item.title + &quot;) to db, id: &quot;
 551                         + item.id + &quot; (&quot; + container + &quot;, &quot; + screen + &quot;, &quot; + cellX + &quot;, &quot;
 552                         + cellY + &quot;)&quot;;
 553                 Launcher.sDumpLogs.add(transaction);
 554                 Log.d(TAG, transaction);
 555 
 556                 cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
 557                         LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);
 558 
 559                 // Lock on mBgLock *after* the db operation
 560                 synchronized (sBgLock) {
 561                     if (sBgItemsIdMap.containsKey(item.id)) {
 562                         // we should not be adding new items in the db with the same id
 563                         throw new RuntimeException(&quot;Error: ItemInfo id (&quot; + item.id + &quot;) passed to &quot; +
 564                             &quot;addItemToDatabase already exists.&quot; + item.toString());
 565                     }
 566                     sBgItemsIdMap.put(item.id, item);
 567                     switch (item.itemType) {
 568                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 569                             sBgFolders.put(item.id, (FolderInfo) item);
 570                             // Fall through
 571                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 572                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 573                             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 574                                     item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 575                                 sBgWorkspaceItems.add(item);
 576                             } else {
 577                                 if (!sBgFolders.containsKey(item.container)) {
 578                                     // Adding an item to a folder that doesn&#x27;t exist.
 579                                     String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +
 580                                             &quot; doesn&#x27;t exist&quot;;
 581                                     RuntimeException e = new RuntimeException(msg);
 582                                     e.setStackTrace(stackTrace);
 583                                     Launcher.dumpDebugLogsToConsole();
 584                                     throw e;
 585                                 }
 586                             }
 587                             break;
 588                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
 589                             sBgAppWidgets.add((LauncherAppWidgetInfo) item);
 590                             break;
 591                     }
 592                 }
 593             }
 594         };
 595         runOnWorkerThread(r);
 596     }
 597 
 598     /**
 599      * Creates a new unique child id, for a given cell span across all layouts.
 600      */
 601     static int getCellLayoutChildId(
 602             long container, int screen, int localCellX, int localCellY, int spanX, int spanY) {
 603         return (((int) container &amp; 0xFF) &lt;&lt; 24)
 604                 | (screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
 605     }
 606 
 607     static int getCellCountX() {
 608         return mCellCountX;
 609     }
 610 
 611     static int getCellCountY() {
 612         return mCellCountY;
 613     }
 614 
 615     /**
 616      * Updates the model orientation helper to take into account the current layout dimensions
 617      * when performing local/canonical coordinate transformations.
 618      */
 619     static void updateWorkspaceLayoutCells(int shortAxisCellCount, int longAxisCellCount) {
 620         mCellCountX = shortAxisCellCount;
 621         mCellCountY = longAxisCellCount;
 622     }
 623 
 624     /**
 625      * Removes the specified item from the database
 626      * @param context
 627      * @param item
 628      */
 629     static void deleteItemFromDatabase(Context context, final ItemInfo item) {
 630         final ContentResolver cr = context.getContentResolver();
 631         final Uri uriToDelete = LauncherSettings.Favorites.getContentUri(item.id, false);
 632         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 633 
 634         Runnable r = new Runnable() {
 635             public void run() {
 636                 String transaction = &quot;DbDebug    Delete item (&quot; + item.title + &quot;) from db, id: &quot;
 637                         + item.id + &quot; (&quot; + item.container + &quot;, &quot; + item.screen + &quot;, &quot; + item.cellX +
 638                         &quot;, &quot; + item.cellY + &quot;)&quot;;
 639                 Launcher.sDumpLogs.add(transaction);
 640                 Log.d(TAG, transaction);
 641 
 642                 cr.delete(uriToDelete, null, null);
 643 
 644                 // Lock on mBgLock *after* the db operation
 645                 synchronized (sBgLock) {
 646                     switch (item.itemType) {
 647                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 648                             sBgFolders.remove(item.id);
 649                             for (ItemInfo info: sBgItemsIdMap.values()) {
 650                                 if (info.container == item.id) {
 651                                     // We are deleting a folder which still contains items that
 652                                     // think they are contained by that folder.
 653                                     String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +
 654                                             &quot;contains items (&quot; + info + &quot;)&quot;;
 655                                     RuntimeException e = new RuntimeException(msg);
 656                                     e.setStackTrace(stackTrace);
 657                                     Launcher.dumpDebugLogsToConsole();
 658                                     throw e;
 659                                 }
 660                             }
 661                             sBgWorkspaceItems.remove(item);
 662                             break;
 663                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 664                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 665                             sBgWorkspaceItems.remove(item);
 666                             break;
 667                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
 668                             sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
 669                             break;
 670                     }
 671                     sBgItemsIdMap.remove(item.id);
 672                     sBgDbIconCache.remove(item);
 673                 }
 674             }
 675         };
 676         runOnWorkerThread(r);
 677     }
 678 
 679     /**
 680      * Remove the contents of the specified folder from the database
 681      */
 682     static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
 683         final ContentResolver cr = context.getContentResolver();
 684 
 685         Runnable r = new Runnable() {
 686             public void run() {
 687                 cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
 688                 // Lock on mBgLock *after* the db operation
 689                 synchronized (sBgLock) {
 690                     sBgItemsIdMap.remove(info.id);
 691                     sBgFolders.remove(info.id);
 692                     sBgDbIconCache.remove(info);
 693                     sBgWorkspaceItems.remove(info);
 694                 }
 695 
 696                 cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
 697                         LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
 698                 // Lock on mBgLock *after* the db operation
 699                 synchronized (sBgLock) {
 700                     for (ItemInfo childInfo : info.contents) {
 701                         sBgItemsIdMap.remove(childInfo.id);
 702                         sBgDbIconCache.remove(childInfo);
 703                     }
 704                 }
 705             }
 706         };
 707         runOnWorkerThread(r);
 708     }
 709 
 710     /**
 711      * Set this as the current Launcher activity object for the loader.
 712      */
 713     public void initialize(Callbacks callbacks) {
 714         synchronized (mLock) {
 715             mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
 716         }
 717     }
 718 
 719     /**
 720      * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
 721      * ACTION_PACKAGE_CHANGED.
 722      */
 723     @Override
 724     public void onReceive(Context context, Intent intent) {
 725         if (DEBUG_LOADERS) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
 726 
 727         final String action = intent.getAction();
 728 
 729         if (Intent.ACTION_PACKAGE_CHANGED.equals(action)
 730                 || Intent.ACTION_PACKAGE_REMOVED.equals(action)
 731                 || Intent.ACTION_PACKAGE_ADDED.equals(action)) {
 732             final String packageName = intent.getData().getSchemeSpecificPart();
 733             final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
 734 
 735             int op = PackageUpdatedTask.OP_NONE;
 736 
 737             if (packageName == null || packageName.length() == 0) {
 738                 // they sent us a bad intent
 739                 return;
 740             }
 741 
 742             if (Intent.ACTION_PACKAGE_CHANGED.equals(action)) {
 743                 op = PackageUpdatedTask.OP_UPDATE;
 744             } else if (Intent.ACTION_PACKAGE_REMOVED.equals(action)) {
 745                 if (!replacing) {
 746                     op = PackageUpdatedTask.OP_REMOVE;
 747                 }
 748                 // else, we are replacing the package, so a PACKAGE_ADDED will be sent
 749                 // later, we will update the package at this time
 750             } else if (Intent.ACTION_PACKAGE_ADDED.equals(action)) {
 751                 if (!replacing) {
 752                     op = PackageUpdatedTask.OP_ADD;
 753                 } else {
 754                     op = PackageUpdatedTask.OP_UPDATE;
 755                 }
 756             }
 757 
 758             if (op != PackageUpdatedTask.OP_NONE) {
 759                 enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName }));
 760             }
 761 
 762         } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(action)) {
 763             // First, schedule to add these apps back in.
 764             String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
 765             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packages));
 766             // Then, rebind everything.
 767             startLoaderFromBackground();
 768         } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(action)) {
 769             String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
 770             enqueuePackageUpdated(new PackageUpdatedTask(
 771                         PackageUpdatedTask.OP_UNAVAILABLE, packages));
 772         } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
 773             // If we have changed locale we need to clear out the labels in all apps/workspace.
 774             forceReload();
 775         } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
 776              // Check if configuration change was an mcc/mnc change which would affect app resources
 777              // and we would need to clear out the labels in all apps/workspace. Same handling as
 778              // above for ACTION_LOCALE_CHANGED
 779              Configuration currentConfig = context.getResources().getConfiguration();
 780              if (mPreviousConfigMcc != currentConfig.mcc) {
 781                    Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
 782                        + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
 783                    forceReload();
 784              }
 785              // Update previousConfig
 786              mPreviousConfigMcc = currentConfig.mcc;
 787         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
 788                    SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
 789             if (mCallbacks != null) {
 790                 Callbacks callbacks = mCallbacks.get();
 791                 if (callbacks != null) {
 792                     callbacks.bindSearchablesChanged();
 793                 }
 794             }
 795         }
 796     }
 797 
 798     private void forceReload() {
 799         resetLoadedState(true, true);
 800 
 801         // Do this here because if the launcher activity is running it will be restarted.
 802         // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
 803         // to reload.
 804         startLoaderFromBackground();
 805     }
 806 
 807     public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
 808         synchronized (mLock) {
 809             // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
 810             // mWorkspaceLoaded to true later
 811             stopLoaderLocked();
 812             if (resetAllAppsLoaded) mAllAppsLoaded = false;
 813             if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
 814         }
 815     }
 816 
 817     /**
 818      * When the launcher is in the background, it&#x27;s possible for it to miss paired
 819      * configuration changes.  So whenever we trigger the loader from the background
 820      * tell the launcher that it needs to re-run the loader when it comes back instead
 821      * of doing it now.
 822      */
 823     public void startLoaderFromBackground() {
 824         boolean runLoader = false;
 825         if (mCallbacks != null) {
 826             Callbacks callbacks = mCallbacks.get();
 827             if (callbacks != null) {
 828                 // Only actually run the loader if they&#x27;re not paused.
 829                 if (!callbacks.setLoadOnResume()) {
 830                     runLoader = true;
 831                 }
 832             }
 833         }
 834         if (runLoader) {
 835             startLoader(false, -1);
 836         }
 837     }
 838 
 839     // If there is already a loader task running, tell it to stop.
 840     // returns true if isLaunching() was true on the old task
 841     private boolean stopLoaderLocked() {
 842         boolean isLaunching = false;
 843         LoaderTask oldTask = mLoaderTask;
 844         if (oldTask != null) {
 845             if (oldTask.isLaunching()) {
 846                 isLaunching = true;
 847             }
 848             oldTask.stopLocked();
 849         }
 850         return isLaunching;
 851     }
 852 
 853     public void startLoader(boolean isLaunching, int synchronousBindPage) {
 854         synchronized (mLock) {
 855             if (DEBUG_LOADERS) {
 856                 Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
 857             }
 858 
 859             // Clear any deferred bind-runnables from the synchronized load process
 860             // We must do this before any loading/binding is scheduled below.
 861             mDeferredBindRunnables.clear();
 862 
 863             // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
 864             if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
 865                 // If there is already one running, tell it to stop.
 866                 // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
 867                 isLaunching = isLaunching || stopLoaderLocked();
 868                 mLoaderTask = new LoaderTask(mApp, isLaunching);
 869                 if (synchronousBindPage &gt; -1 &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {
 870                     mLoaderTask.runBindSynchronousPage(synchronousBindPage);
 871                 } else {
 872                     sWorkerThread.setPriority(Thread.NORM_PRIORITY);
 873                     sWorker.post(mLoaderTask);
 874                 }
 875             }
 876         }
 877     }
 878 
 879     void bindRemainingSynchronousPages() {
 880         // Post the remaining side pages to be loaded
 881         if (!mDeferredBindRunnables.isEmpty()) {
 882             for (final Runnable r : mDeferredBindRunnables) {
 883                 mHandler.post(r);
 884             }
 885             mDeferredBindRunnables.clear();
 886         }
 887     }
 888 
 889     public void stopLoader() {
 890         synchronized (mLock) {
 891             if (mLoaderTask != null) {
 892                 mLoaderTask.stopLocked();
 893             }
 894         }
 895     }
 896 
 897     public boolean isAllAppsLoaded() {
 898         return mAllAppsLoaded;
 899     }
 900 
 901     boolean isLoadingWorkspace() {
 902         synchronized (mLock) {
 903             if (mLoaderTask != null) {
 904                 return mLoaderTask.isLoadingWorkspace();
 905             }
 906         }
 907         return false;
 908     }
 909 
 910     /**
 911      * Runnable for the thread that loads the contents of the launcher:
 912      *   - workspace icons
 913      *   - widgets
 914      *   - all apps icons
 915      */
 916     private class LoaderTask implements Runnable {
 917         private Context mContext;
 918         private boolean mIsLaunching;
 919         private boolean mIsLoadingAndBindingWorkspace;
 920         private boolean mStopped;
 921         private boolean mLoadAndBindStepFinished;
 922 
 923         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
 924 
 925         LoaderTask(Context context, boolean isLaunching) {
 926             mContext = context;
 927             mIsLaunching = isLaunching;
 928             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
 929         }
 930 
 931         boolean isLaunching() {
 932             return mIsLaunching;
 933         }
 934 
 935         boolean isLoadingWorkspace() {
 936             return mIsLoadingAndBindingWorkspace;
 937         }
 938 
 939         private void loadAndBindWorkspace() {
 940             mIsLoadingAndBindingWorkspace = true;
 941 
 942             // Load the workspace
 943             if (DEBUG_LOADERS) {
 944                 Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
 945             }
 946 
 947             if (!mWorkspaceLoaded) {
 948                 loadWorkspace();
 949                 synchronized (LoaderTask.this) {
 950                     if (mStopped) {
 951                         return;
 952                     }
 953                     mWorkspaceLoaded = true;
 954                 }
 955             }
 956 
 957             // Bind the workspace
 958             bindWorkspace(-1);
 959         }
 960 
 961         private void waitForIdle() {
 962             // Wait until the either we&#x27;re stopped or the other threads are done.
 963             // This way we don&#x27;t start loading all apps until the workspace has settled
 964             // down.
 965             synchronized (LoaderTask.this) {
 966                 final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
 967 
 968                 mHandler.postIdle(new Runnable() {
 969                         public void run() {
 970                             synchronized (LoaderTask.this) {
 971                                 mLoadAndBindStepFinished = true;
 972                                 if (DEBUG_LOADERS) {
 973                                     Log.d(TAG, &quot;done with previous binding step&quot;);
 974                                 }
 975                                 LoaderTask.this.notify();
 976                             }
 977                         }
 978                     });
 979 
 980                 while (!mStopped &amp;&amp; !mLoadAndBindStepFinished) {
 981                     try {
 982                         this.wait();
 983                     } catch (InterruptedException ex) {
 984                         // Ignore
 985                     }
 986                 }
 987                 if (DEBUG_LOADERS) {
 988                     Log.d(TAG, &quot;waited &quot;
 989                             + (SystemClock.uptimeMillis()-workspaceWaitTime)
 990                             + &quot;ms for previous step to finish binding&quot;);
 991                 }
 992             }
 993         }
 994 
 995         void runBindSynchronousPage(int synchronousBindPage) {
 996             if (synchronousBindPage &lt; 0) {
 997                 // Ensure that we have a valid page index to load synchronously
 998                 throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
 999                         &quot;valid page index&quot;);
1000             }
1001             if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1002                 // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1003                 // loaded already (we should load everything asynchronously in that case)
1004                 throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1005             }
1006             synchronized (mLock) {
1007                 if (mIsLoaderTaskRunning) {
1008                     // Ensure that we are never running the background loading at this point since
1009                     // we also touch the background collections
1010                     throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1011                 }
1012             }
1013 
1014             // XXX: Throw an exception if we are already loading (since we touch the worker thread
1015             //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1016             //      this call is synchronous, we can get away with not locking).
1017 
1018             // The LauncherModel is static in the LauncherApplication and mHandler may have queued
1019             // operations from the previous activity.  We need to ensure that all queued operations
1020             // are executed before any synchronous binding work is done.
1021             mHandler.flush();
1022 
1023             // Divide the set of loaded items into those that we are binding synchronously, and
1024             // everything else that is to be bound normally (asynchronously).
1025             bindWorkspace(synchronousBindPage);
1026             // XXX: For now, continue posting the binding of AllApps as there are other issues that
1027             //      arise from that.
1028             onlyBindAllApps();
1029         }
1030 
1031         public void run() {
1032             synchronized (mLock) {
1033                 mIsLoaderTaskRunning = true;
1034             }
1035             // Optimize for end-user experience: if the Launcher is up and // running with the
1036             // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1037             // workspace first (default).
1038             final Callbacks cbk = mCallbacks.get();
1039             final boolean loadWorkspaceFirst = cbk != null ? (!cbk.isAllAppsVisible()) : true;
1040 
1041             keep_running: {
1042                 // Elevate priority when Home launches for the first time to avoid
1043                 // starving at boot time. Staring at a blank home is not cool.
1044                 synchronized (mLock) {
1045                     if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1046                             (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1047                     android.os.Process.setThreadPriority(mIsLaunching
1048                             ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1049                 }
1050                 if (loadWorkspaceFirst) {
1051                     if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1052                     loadAndBindWorkspace();
1053                 } else {
1054                     if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: special: loading all apps&quot;);
1055                     loadAndBindAllApps();
1056                 }
1057 
1058                 if (mStopped) {
1059                     break keep_running;
1060                 }
1061 
1062                 // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1063                 // settled down.
1064                 synchronized (mLock) {
1065                     if (mIsLaunching) {
1066                         if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1067                         android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1068                     }
1069                 }
1070                 waitForIdle();
1071 
1072                 // second step
1073                 if (loadWorkspaceFirst) {
1074                     if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1075                     loadAndBindAllApps();
1076                 } else {
1077                     if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: special: loading workspace&quot;);
1078                     loadAndBindWorkspace();
1079                 }
1080 
1081                 // Restore the default thread priority after we are done loading items
1082                 synchronized (mLock) {
1083                     android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1084                 }
1085             }
1086 
1087 
1088             // Update the saved icons if necessary
1089             if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1090             synchronized (sBgLock) {
1091                 for (Object key : sBgDbIconCache.keySet()) {
1092                     updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
1093                 }
1094                 sBgDbIconCache.clear();
1095             }
1096 
1097             // Clear out this reference, otherwise we end up holding it until all of the
1098             // callback runnables are done.
1099             mContext = null;
1100 
1101             synchronized (mLock) {
1102                 // If we are still the last one to be scheduled, remove ourselves.
1103                 if (mLoaderTask == this) {
1104                     mLoaderTask = null;
1105                 }
1106                 mIsLoaderTaskRunning = false;
1107             }
1108         }
1109 
1110         public void stopLocked() {
1111             synchronized (LoaderTask.this) {
1112                 mStopped = true;
1113                 this.notify();
1114             }
1115         }
1116 
1117         /**
1118          * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1119          * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1120          * object that was around when the deferred message was scheduled, and if there&#x27;s
1121          * a new Callbacks object around then also return null.  This will save us from
1122          * calling onto it with data that will be ignored.
1123          */
1124         Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1125             synchronized (mLock) {
1126                 if (mStopped) {
1127                     return null;
1128                 }
1129 
1130                 if (mCallbacks == null) {
1131                     return null;
1132                 }
1133 
1134                 final Callbacks callbacks = mCallbacks.get();
1135                 if (callbacks != oldCallbacks) {
1136                     return null;
1137                 }
1138                 if (callbacks == null) {
1139                     Log.w(TAG, &quot;no mCallbacks&quot;);
1140                     return null;
1141                 }
1142 
1143                 return callbacks;
1144             }
1145         }
1146 
1147         // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1148         private boolean checkItemPlacement(ItemInfo occupied[][][], ItemInfo item) {
1149             int containerIndex = item.screen;
1150             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1151                 // Return early if we detect that an item is under the hotseat button
1152                 if (mCallbacks == null || mCallbacks.get().isAllAppsButtonRank(item.screen)) {
1153                     return false;
1154                 }
1155 
1156                 // We use the last index to refer to the hotseat and the screen as the rank, so
1157                 // test and update the occupied state accordingly
1158                 if (occupied[Launcher.SCREEN_COUNT][item.screen][0] != null) {
1159                     Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1160                         + &quot; into position (&quot; + item.screen + &quot;:&quot; + item.cellX + &quot;,&quot; + item.cellY
1161                         + &quot;) occupied by &quot; + occupied[Launcher.SCREEN_COUNT][item.screen][0]);
1162                     return false;
1163                 } else {
1164                     occupied[Launcher.SCREEN_COUNT][item.screen][0] = item;
1165                     return true;
1166                 }
1167             } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1168                 // Skip further checking if it is not the hotseat or workspace container
1169                 return true;
1170             }
1171 
1172             // Check if any workspace icons overlap with each other
1173             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1174                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1175                     if (occupied[containerIndex][x][y] != null) {
1176                         Log.e(TAG, &quot;Error loading shortcut &quot; + item
1177                             + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screen + &quot;:&quot;
1178                             + x + &quot;,&quot; + y
1179                             + &quot;) occupied by &quot;
1180                             + occupied[containerIndex][x][y]);
1181                         return false;
1182                     }
1183                 }
1184             }
1185             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1186                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1187                     occupied[containerIndex][x][y] = item;
1188                 }
1189             }
1190 
1191             return true;
1192         }
1193 
1194         private void loadWorkspace() {
1195             final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1196 
1197             final Context context = mContext;
1198             final ContentResolver contentResolver = context.getContentResolver();
1199             final PackageManager manager = context.getPackageManager();
1200             final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1201             final boolean isSafeMode = manager.isSafeMode();
1202 
1203             // Make sure the default workspace is loaded, if needed
1204             mApp.getLauncherProvider().loadDefaultFavoritesIfNecessary();
1205 
1206             synchronized (sBgLock) {
1207                 sBgWorkspaceItems.clear();
1208                 sBgAppWidgets.clear();
1209                 sBgFolders.clear();
1210                 sBgItemsIdMap.clear();
1211                 sBgDbIconCache.clear();
1212 
1213                 final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1214 
1215                 final Cursor c = contentResolver.query(
1216                         LauncherSettings.Favorites.CONTENT_URI, null, null, null, null);
1217 
1218                 // +1 for the hotseat (it can be larger than the workspace)
1219                 // Load workspace in reverse order to ensure that latest items are loaded first (and
1220                 // before any earlier duplicates)
1221                 final ItemInfo occupied[][][] =
1222                         new ItemInfo[Launcher.SCREEN_COUNT + 1][mCellCountX + 1][mCellCountY + 1];
1223 
1224                 try {
1225                     final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1226                     final int intentIndex = c.getColumnIndexOrThrow
1227                             (LauncherSettings.Favorites.INTENT);
1228                     final int titleIndex = c.getColumnIndexOrThrow
1229                             (LauncherSettings.Favorites.TITLE);
1230                     final int iconTypeIndex = c.getColumnIndexOrThrow(
1231                             LauncherSettings.Favorites.ICON_TYPE);
1232                     final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
1233                     final int iconPackageIndex = c.getColumnIndexOrThrow(
1234                             LauncherSettings.Favorites.ICON_PACKAGE);
1235                     final int iconResourceIndex = c.getColumnIndexOrThrow(
1236                             LauncherSettings.Favorites.ICON_RESOURCE);
1237                     final int containerIndex = c.getColumnIndexOrThrow(
1238                             LauncherSettings.Favorites.CONTAINER);
1239                     final int itemTypeIndex = c.getColumnIndexOrThrow(
1240                             LauncherSettings.Favorites.ITEM_TYPE);
1241                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(
1242                             LauncherSettings.Favorites.APPWIDGET_ID);
1243                     final int screenIndex = c.getColumnIndexOrThrow(
1244                             LauncherSettings.Favorites.SCREEN);
1245                     final int cellXIndex = c.getColumnIndexOrThrow
1246                             (LauncherSettings.Favorites.CELLX);
1247                     final int cellYIndex = c.getColumnIndexOrThrow
1248                             (LauncherSettings.Favorites.CELLY);
1249                     final int spanXIndex = c.getColumnIndexOrThrow
1250                             (LauncherSettings.Favorites.SPANX);
1251                     final int spanYIndex = c.getColumnIndexOrThrow(
1252                             LauncherSettings.Favorites.SPANY);
1253                     //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1254                     //final int displayModeIndex = c.getColumnIndexOrThrow(
1255                     //        LauncherSettings.Favorites.DISPLAY_MODE);
1256 
1257                     ShortcutInfo info;
1258                     String intentDescription;
1259                     LauncherAppWidgetInfo appWidgetInfo;
1260                     int container;
1261                     long id;
1262                     Intent intent;
1263 
1264                     while (!mStopped &amp;&amp; c.moveToNext()) {
1265                         try {
1266                             int itemType = c.getInt(itemTypeIndex);
1267 
1268                             switch (itemType) {
1269                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1270                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1271                                 intentDescription = c.getString(intentIndex);
1272                                 try {
1273                                     intent = Intent.parseUri(intentDescription, 0);
1274                                 } catch (URISyntaxException e) {
1275                                     continue;
1276                                 }
1277 
1278                                 if (itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
1279                                     info = getShortcutInfo(manager, intent, context, c, iconIndex,
1280                                             titleIndex, mLabelCache);
1281                                 } else {
1282                                     info = getShortcutInfo(c, context, iconTypeIndex,
1283                                             iconPackageIndex, iconResourceIndex, iconIndex,
1284                                             titleIndex);
1285 
1286                                     // App shortcuts that used to be automatically added to Launcher
1287                                     // didn&#x27;t always have the correct intent flags set, so do that
1288                                     // here
1289                                     if (intent.getAction() != null &amp;&amp;
1290                                         intent.getCategories() != null &amp;&amp;
1291                                         intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
1292                                         intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
1293                                         intent.addFlags(
1294                                             Intent.FLAG_ACTIVITY_NEW_TASK |
1295                                             Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
1296                                     }
1297                                 }
1298 
1299                                 if (info != null) {
1300                                     info.intent = intent;
1301                                     info.id = c.getLong(idIndex);
1302                                     container = c.getInt(containerIndex);
1303                                     info.container = container;
1304                                     info.screen = c.getInt(screenIndex);
1305                                     info.cellX = c.getInt(cellXIndex);
1306                                     info.cellY = c.getInt(cellYIndex);
1307 
1308                                     // check &amp; update map of what&#x27;s occupied
1309                                     if (!checkItemPlacement(occupied, info)) {
1310                                         break;
1311                                     }
1312 
1313                                     switch (container) {
1314                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
1315                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
1316                                         sBgWorkspaceItems.add(info);
1317                                         break;
1318                                     default:
1319                                         // Item is in a user folder
1320                                         FolderInfo folderInfo =
1321                                                 findOrMakeFolder(sBgFolders, container);
1322                                         folderInfo.add(info);
1323                                         break;
1324                                     }
1325                                     sBgItemsIdMap.put(info.id, info);
1326 
1327                                     // now that we&#x27;ve loaded everthing re-save it with the
1328                                     // icon in case it disappears somehow.
1329                                     queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
1330                                 } else {
1331                                     // Failed to load the shortcut, probably because the
1332                                     // activity manager couldn&#x27;t resolve it (maybe the app
1333                                     // was uninstalled), or the db row was somehow screwed up.
1334                                     // Delete it.
1335                                     id = c.getLong(idIndex);
1336                                     Log.e(TAG, &quot;Error loading shortcut &quot; + id + &quot;, removing it&quot;);
1337                                     contentResolver.delete(LauncherSettings.Favorites.getContentUri(
1338                                                 id, false), null, null);
1339                                 }
1340                                 break;
1341 
1342                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1343                                 id = c.getLong(idIndex);
1344                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
1345 
1346                                 folderInfo.title = c.getString(titleIndex);
1347                                 folderInfo.id = id;
1348                                 container = c.getInt(containerIndex);
1349                                 folderInfo.container = container;
1350                                 folderInfo.screen = c.getInt(screenIndex);
1351                                 folderInfo.cellX = c.getInt(cellXIndex);
1352                                 folderInfo.cellY = c.getInt(cellYIndex);
1353 
1354                                 // check &amp; update map of what&#x27;s occupied
1355                                 if (!checkItemPlacement(occupied, folderInfo)) {
1356                                     break;
1357                                 }
1358                                 switch (container) {
1359                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
1360                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
1361                                         sBgWorkspaceItems.add(folderInfo);
1362                                         break;
1363                                 }
1364 
1365                                 sBgItemsIdMap.put(folderInfo.id, folderInfo);
1366                                 sBgFolders.put(folderInfo.id, folderInfo);
1367                                 break;
1368 
1369                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1370                                 // Read all Launcher-specific widget details
1371                                 int appWidgetId = c.getInt(appWidgetIdIndex);
1372                                 id = c.getLong(idIndex);
1373 
1374                                 final AppWidgetProviderInfo provider =
1375                                         widgets.getAppWidgetInfo(appWidgetId);
1376 
1377                                 if (!isSafeMode &amp;&amp; (provider == null || provider.provider == null ||
1378                                         provider.provider.getPackageName() == null)) {
1379                                     String log = &quot;Deleting widget that isn&#x27;t installed anymore: id=&quot;
1380                                         + id + &quot; appWidgetId=&quot; + appWidgetId;
1381                                     Log.e(TAG, log);
1382                                     Launcher.sDumpLogs.add(log);
1383                                     itemsToRemove.add(id);
1384                                 } else {
1385                                     appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
1386                                             provider.provider);
1387                                     appWidgetInfo.id = id;
1388                                     appWidgetInfo.screen = c.getInt(screenIndex);
1389                                     appWidgetInfo.cellX = c.getInt(cellXIndex);
1390                                     appWidgetInfo.cellY = c.getInt(cellYIndex);
1391                                     appWidgetInfo.spanX = c.getInt(spanXIndex);
1392                                     appWidgetInfo.spanY = c.getInt(spanYIndex);
1393                                     int[] minSpan = Launcher.getMinSpanForWidget(context, provider);
1394                                     appWidgetInfo.minSpanX = minSpan[0];
1395                                     appWidgetInfo.minSpanY = minSpan[1];
1396 
1397                                     container = c.getInt(containerIndex);
1398                                     if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1399                                         container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1400                                         Log.e(TAG, &quot;Widget found where container != &quot; +
1401                                             &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
1402                                         continue;
1403                                     }
1404                                     appWidgetInfo.container = c.getInt(containerIndex);
1405 
1406                                     // check &amp; update map of what&#x27;s occupied
1407                                     if (!checkItemPlacement(occupied, appWidgetInfo)) {
1408                                         break;
1409                                     }
1410                                     sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
1411                                     sBgAppWidgets.add(appWidgetInfo);
1412                                 }
1413                                 break;
1414                             }
1415                         } catch (Exception e) {
1416                             Log.w(TAG, &quot;Desktop items loading interrupted:&quot;, e);
1417                         }
1418                     }
1419                 } finally {
1420                     c.close();
1421                 }
1422 
1423                 if (itemsToRemove.size() &gt; 0) {
1424                     ContentProviderClient client = contentResolver.acquireContentProviderClient(
1425                                     LauncherSettings.Favorites.CONTENT_URI);
1426                     // Remove dead items
1427                     for (long id : itemsToRemove) {
1428                         if (DEBUG_LOADERS) {
1429                             Log.d(TAG, &quot;Removed id = &quot; + id);
1430                         }
1431                         // Don&#x27;t notify content observers
1432                         try {
1433                             client.delete(LauncherSettings.Favorites.getContentUri(id, false),
1434                                     null, null);
1435                         } catch (RemoteException e) {
1436                             Log.w(TAG, &quot;Could not remove id = &quot; + id);
1437                         }
1438                     }
1439                 }
1440 
1441                 if (DEBUG_LOADERS) {
1442                     Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
1443                     Log.d(TAG, &quot;workspace layout: &quot;);
1444                     for (int y = 0; y &lt; mCellCountY; y++) {
1445                         String line = &quot;&quot;;
1446                         for (int s = 0; s &lt; Launcher.SCREEN_COUNT; s++) {
1447                             if (s &gt; 0) {
1448                                 line += &quot; | &quot;;
1449                             }
1450                             for (int x = 0; x &lt; mCellCountX; x++) {
1451                                 line += ((occupied[s][x][y] != null) ? &quot;#&quot; : &quot;.&quot;);
1452                             }
1453                         }
1454                         Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
1455                     }
1456                 }
1457             }
1458         }
1459 
1460         /** Filters the set of items who are directly or indirectly (via another container) on the
1461          * specified screen. */
1462         private void filterCurrentWorkspaceItems(int currentScreen,
1463                 ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
1464                 ArrayList&lt;ItemInfo&gt; currentScreenItems,
1465                 ArrayList&lt;ItemInfo&gt; otherScreenItems) {
1466             // Purge any null ItemInfos
1467             Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
1468             while (iter.hasNext()) {
1469                 ItemInfo i = iter.next();
1470                 if (i == null) {
1471                     iter.remove();
1472                 }
1473             }
1474 
1475             // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of
1476             // items given.
1477             if (currentScreen &lt; 0) {
1478                 currentScreenItems.addAll(allWorkspaceItems);
1479             }
1480 
1481             // Order the set of items by their containers first, this allows use to walk through the
1482             // list sequentially, build up a list of containers that are in the specified screen,
1483             // as well as all items in those containers.
1484             Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
1485             Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
1486                 @Override
1487                 public int compare(ItemInfo lhs, ItemInfo rhs) {
1488                     return (int) (lhs.container - rhs.container);
1489                 }
1490             });
1491             for (ItemInfo info : allWorkspaceItems) {
1492                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1493                     if (info.screen == currentScreen) {
1494                         currentScreenItems.add(info);
1495                         itemsOnScreen.add(info.id);
1496                     } else {
1497                         otherScreenItems.add(info);
1498                     }
1499                 } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1500                     currentScreenItems.add(info);
1501                     itemsOnScreen.add(info.id);
1502                 } else {
1503                     if (itemsOnScreen.contains(info.container)) {
1504                         currentScreenItems.add(info);
1505                         itemsOnScreen.add(info.id);
1506                     } else {
1507                         otherScreenItems.add(info);
1508                     }
1509                 }
1510             }
1511         }
1512 
1513         /** Filters the set of widgets which are on the specified screen. */
1514         private void filterCurrentAppWidgets(int currentScreen,
1515                 ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
1516                 ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
1517                 ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
1518             // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of
1519             // widgets given.
1520             if (currentScreen &lt; 0) {
1521                 currentScreenWidgets.addAll(appWidgets);
1522             }
1523 
1524             for (LauncherAppWidgetInfo widget : appWidgets) {
1525                 if (widget == null) continue;
1526                 if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1527                         widget.screen == currentScreen) {
1528                     currentScreenWidgets.add(widget);
1529                 } else {
1530                     otherScreenWidgets.add(widget);
1531                 }
1532             }
1533         }
1534 
1535         /** Filters the set of folders which are on the specified screen. */
1536         private void filterCurrentFolders(int currentScreen,
1537                 HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
1538                 HashMap&lt;Long, FolderInfo&gt; folders,
1539                 HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
1540                 HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
1541             // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of
1542             // widgets given.
1543             if (currentScreen &lt; 0) {
1544                 currentScreenFolders.putAll(folders);
1545             }
1546 
1547             for (long id : folders.keySet()) {
1548                 ItemInfo info = itemsIdMap.get(id);
1549                 FolderInfo folder = folders.get(id);
1550                 if (info == null || folder == null) continue;
1551                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1552                         info.screen == currentScreen) {
1553                     currentScreenFolders.put(id, folder);
1554                 } else {
1555                     otherScreenFolders.put(id, folder);
1556                 }
1557             }
1558         }
1559 
1560         /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
1561          * right) */
1562         private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
1563             // XXX: review this
1564             Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
1565                 @Override
1566                 public int compare(ItemInfo lhs, ItemInfo rhs) {
1567                     int cellCountX = LauncherModel.getCellCountX();
1568                     int cellCountY = LauncherModel.getCellCountY();
1569                     int screenOffset = cellCountX * cellCountY;
1570                     int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
1571                     long lr = (lhs.container * containerOffset + lhs.screen * screenOffset +
1572                             lhs.cellY * cellCountX + lhs.cellX);
1573                     long rr = (rhs.container * containerOffset + rhs.screen * screenOffset +
1574                             rhs.cellY * cellCountX + rhs.cellX);
1575                     return (int) (lr - rr);
1576                 }
1577             });
1578         }
1579 
1580         private void bindWorkspaceItems(final Callbacks oldCallbacks,
1581                 final ArrayList&lt;ItemInfo&gt; workspaceItems,
1582                 final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
1583                 final HashMap&lt;Long, FolderInfo&gt; folders,
1584                 ArrayList&lt;Runnable&gt; deferredBindRunnables) {
1585 
1586             final boolean postOnMainThread = (deferredBindRunnables != null);
1587 
1588             // Bind the workspace items
1589             int N = workspaceItems.size();
1590             for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
1591                 final int start = i;
1592                 final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
1593                 final Runnable r = new Runnable() {
1594                     @Override
1595                     public void run() {
1596                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1597                         if (callbacks != null) {
1598                             callbacks.bindItems(workspaceItems, start, start+chunkSize);
1599                         }
1600                     }
1601                 };
1602                 if (postOnMainThread) {
1603                     deferredBindRunnables.add(r);
1604                 } else {
1605                     runOnMainThread(r);
1606                 }
1607             }
1608 
1609             // Bind the folders
1610             if (!folders.isEmpty()) {
1611                 final Runnable r = new Runnable() {
1612                     public void run() {
1613                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1614                         if (callbacks != null) {
1615                             callbacks.bindFolders(folders);
1616                         }
1617                     }
1618                 };
1619                 if (postOnMainThread) {
1620                     deferredBindRunnables.add(r);
1621                 } else {
1622                     runOnMainThread(r);
1623                 }
1624             }
1625 
1626             // Bind the widgets, one at a time
1627             N = appWidgets.size();
1628             for (int i = 0; i &lt; N; i++) {
1629                 final LauncherAppWidgetInfo widget = appWidgets.get(i);
1630                 final Runnable r = new Runnable() {
1631                     public void run() {
1632                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1633                         if (callbacks != null) {
1634                             callbacks.bindAppWidget(widget);
1635                         }
1636                     }
1637                 };
1638                 if (postOnMainThread) {
1639                     deferredBindRunnables.add(r);
1640                 } else {
1641                     runOnMainThread(r);
1642                 }
1643             }
1644         }
1645 
1646         /**
1647          * Binds all loaded data to actual views on the main thread.
1648          */
1649         private void bindWorkspace(int synchronizeBindPage) {
1650             final long t = SystemClock.uptimeMillis();
1651             Runnable r;
1652 
1653             // Don&#x27;t use these two variables in any of the callback runnables.
1654             // Otherwise we hold a reference to them.
1655             final Callbacks oldCallbacks = mCallbacks.get();
1656             if (oldCallbacks == null) {
1657                 // This launcher has exited and nobody bothered to tell us.  Just bail.
1658                 Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
1659                 return;
1660             }
1661 
1662             final boolean isLoadingSynchronously = (synchronizeBindPage &gt; -1);
1663             final int currentScreen = isLoadingSynchronously ? synchronizeBindPage :
1664                 oldCallbacks.getCurrentWorkspaceScreen();
1665 
1666             // Load all the items that are on the current page first (and in the process, unbind
1667             // all the existing workspace items before we call startBinding() below.
1668             unbindWorkspaceItemsOnMainThread();
1669             ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
1670             ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
1671                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
1672             HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
1673             HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
1674             synchronized (sBgLock) {
1675                 workspaceItems.addAll(sBgWorkspaceItems);
1676                 appWidgets.addAll(sBgAppWidgets);
1677                 folders.putAll(sBgFolders);
1678                 itemsIdMap.putAll(sBgItemsIdMap);
1679             }
1680 
1681             ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
1682             ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
1683             ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
1684                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
1685             ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
1686                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
1687             HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
1688             HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
1689 
1690             // Separate the items that are on the current screen, and all the other remaining items
1691             filterCurrentWorkspaceItems(currentScreen, workspaceItems, currentWorkspaceItems,
1692                     otherWorkspaceItems);
1693             filterCurrentAppWidgets(currentScreen, appWidgets, currentAppWidgets,
1694                     otherAppWidgets);
1695             filterCurrentFolders(currentScreen, itemsIdMap, folders, currentFolders,
1696                     otherFolders);
1697             sortWorkspaceItemsSpatially(currentWorkspaceItems);
1698             sortWorkspaceItemsSpatially(otherWorkspaceItems);
1699 
1700             // Tell the workspace that we&#x27;re about to start binding items
1701             r = new Runnable() {
1702                 public void run() {
1703                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1704                     if (callbacks != null) {
1705                         callbacks.startBinding();
1706                     }
1707                 }
1708             };
1709             runOnMainThread(r);
1710 
1711             // Load items on the current page
1712             bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
1713                     currentFolders, null);
1714             if (isLoadingSynchronously) {
1715                 r = new Runnable() {
1716                     public void run() {
1717                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1718                         if (callbacks != null) {
1719                             callbacks.onPageBoundSynchronously(currentScreen);
1720                         }
1721                     }
1722                 };
1723                 runOnMainThread(r);
1724             }
1725 
1726             // Load all the remaining pages (if we are loading synchronously, we want to defer this
1727             // work until after the first render)
1728             mDeferredBindRunnables.clear();
1729             bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
1730                     (isLoadingSynchronously ? mDeferredBindRunnables : null));
1731 
1732             // Tell the workspace that we&#x27;re done binding items
1733             r = new Runnable() {
1734                 public void run() {
1735                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1736                     if (callbacks != null) {
1737                         callbacks.finishBindingItems();
1738                     }
1739 
1740                     // If we&#x27;re profiling, ensure this is the last thing in the queue.
1741                     if (DEBUG_LOADERS) {
1742                         Log.d(TAG, &quot;bound workspace in &quot;
1743                             + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
1744                     }
1745 
1746                     mIsLoadingAndBindingWorkspace = false;
1747                 }
1748             };
1749             if (isLoadingSynchronously) {
1750                 mDeferredBindRunnables.add(r);
1751             } else {
1752                 runOnMainThread(r);
1753             }
1754         }
1755 
1756         private void loadAndBindAllApps() {
1757             if (DEBUG_LOADERS) {
1758                 Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
1759             }
1760             if (!mAllAppsLoaded) {
1761                 loadAllAppsByBatch();
1762                 synchronized (LoaderTask.this) {
1763                     if (mStopped) {
1764                         return;
1765                     }
1766                     mAllAppsLoaded = true;
1767                 }
1768             } else {
1769                 onlyBindAllApps();
1770             }
1771         }
1772 
1773         private void onlyBindAllApps() {
1774             final Callbacks oldCallbacks = mCallbacks.get();
1775             if (oldCallbacks == null) {
1776                 // This launcher has exited and nobody bothered to tell us.  Just bail.
1777                 Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
1778                 return;
1779             }
1780 
1781             // shallow copy
1782             @SuppressWarnings(&quot;unchecked&quot;)
1783             final ArrayList&lt;ApplicationInfo&gt; list
1784 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1785                     = (ArrayList&lt;ApplicationInfo&gt;) mBgAllAppsList.data.clone();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1786             mHandler.post(new Runnable() {</span>
1787 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1788                     = (ArrayList&lt;ApplicationInfo&gt;) mAllAppsList.data.clone();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1789             mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1790                 public void run() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1791                     final long t = SystemClock.uptimeMillis();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1792                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1793                     if (callbacks != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1794                         callbacks.bindAllApplications(list);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1795                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1796                     if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1797                         Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1798                                 + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1799                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1800                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1801             });</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1802         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1803 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1804         private void loadAllAppsByBatch() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1805             final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1806 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1807             // Don&#x27;t use these two variables in any of the callback runnables.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1808             // Otherwise we hold a reference to them.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1809             final Callbacks oldCallbacks = mCallbacks.get();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1810             if (oldCallbacks == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1811                 // This launcher has exited and nobody bothered to tell us.  Just bail.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1812                 Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllAppsByBatch)&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1813                 return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1814             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1815 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1816             final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1817             mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1818 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1819             final PackageManager packageManager = mContext.getPackageManager();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1820             List&lt;ResolveInfo&gt; apps = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1821 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1822             int N = Integer.MAX_VALUE;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1823 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1824             int startIndex;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1825             int i=0;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1826             int batchSize = -1;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1827             while (i &lt; N &amp;&amp; !mStopped) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1828                 if (i == 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1829                     mAllAppsList.clear();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1830                     final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1831                     apps = packageManager.queryIntentActivities(mainIntent, 0);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1832                     if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1833                         Log.d(TAG, &quot;queryIntentActivities took &quot;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1834                                 + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1835                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1836                     if (apps == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1837                         return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1838                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1839                     N = apps.size();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1840                     if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1841                         Log.d(TAG, &quot;queryIntentActivities got &quot; + N + &quot; apps&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1842                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1843                     if (N == 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1844                         // There are no apps?!?</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1845                         return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1846                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1847                     if (mBatchSize == 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1848                         batchSize = N;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1849                     } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1850                         batchSize = mBatchSize;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1851                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1852 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1853                     final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1854                     Collections.sort(apps,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1855                             new LauncherModel.ShortcutNameComparator(packageManager, mLabelCache));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1856                     if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1857                         Log.d(TAG, &quot;sort took &quot;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1858                                 + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1859                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1860                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1861 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1862                 final long t2 = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1863 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1864                 startIndex = i;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1865                 for (int j=0; i&lt;N &amp;&amp; j&lt;batchSize; j++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1866                     // This builds the icon bitmaps.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1867                     mAllAppsList.add(new ApplicationInfo(packageManager, apps.get(i),</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1868                             mIconCache, mLabelCache));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1869                     i++;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1870                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1871 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1872                 final boolean first = i &lt;= batchSize;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1873                 final Callbacks callbacks = tryGetCallbacks(oldCallbacks);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1874                 final ArrayList&lt;ApplicationInfo&gt; added = mAllAppsList.added;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1875                 mAllAppsList.added = new ArrayList&lt;ApplicationInfo&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1876 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1877                 mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1878                     public void run() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1879                         final long t = SystemClock.uptimeMillis();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1880                         if (callbacks != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1881                             if (first) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1882                                 callbacks.bindAllApplications(added);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1883                             } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1884                                 callbacks.bindAppsAdded(added);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1885                             }</span>
1886 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1887                     = (ArrayList&lt;ApplicationInfo&gt;) mAllAppsList.data.clone();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1888             Runnable r = new Runnable() {</span>
1889 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
1890                 public void run() {
1891                     final long t = SystemClock.uptimeMillis();
1892                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1893                     if (callbacks != null) {
1894                         callbacks.bindAllApplications(list);
1895                     }
1896                     if (DEBUG_LOADERS) {
1897                         Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
1898                                 + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
1899                     }
1900                 }
1901             };
1902             boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
1903             if (oldCallbacks.isAllAppsVisible() &amp;&amp; isRunningOnMainThread) {
1904                 r.run();
1905             } else {
1906                 mHandler.post(r);
1907             }
1908         }
1909 
1910         private void loadAllAppsByBatch() {
1911             final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1912 
1913             // Don&#x27;t use these two variables in any of the callback runnables.
1914             // Otherwise we hold a reference to them.
1915             final Callbacks oldCallbacks = mCallbacks.get();
1916             if (oldCallbacks == null) {
1917                 // This launcher has exited and nobody bothered to tell us.  Just bail.
1918                 Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllAppsByBatch)&quot;);
1919                 return;
1920             }
1921 
1922             final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
1923             mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
1924 
1925             final PackageManager packageManager = mContext.getPackageManager();
1926             List&lt;ResolveInfo&gt; apps = null;
1927 
1928             int N = Integer.MAX_VALUE;
1929 
1930             int startIndex;
1931             int i=0;
1932             int batchSize = -1;
1933             while (i &lt; N &amp;&amp; !mStopped) {
1934                 if (i == 0) {
1935                     mBgAllAppsList.clear();
1936                     final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1937                     apps = packageManager.queryIntentActivities(mainIntent, 0);
1938                     if (DEBUG_LOADERS) {
1939                         Log.d(TAG, &quot;queryIntentActivities took &quot;
1940                                 + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms&quot;);
1941                     }
1942                     if (apps == null) {
1943                         return;
1944                     }
1945                     N = apps.size();
1946                     if (DEBUG_LOADERS) {
1947                         Log.d(TAG, &quot;queryIntentActivities got &quot; + N + &quot; apps&quot;);
1948                     }
1949                     if (N == 0) {
1950                         // There are no apps?!?
1951                         return;
1952                     }
1953                     if (mBatchSize == 0) {
1954                         batchSize = N;
1955                     } else {
1956                         batchSize = mBatchSize;
1957                     }
1958 
1959                     final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1960                     Collections.sort(apps,
1961                             new LauncherModel.ShortcutNameComparator(packageManager, mLabelCache));
1962                     if (DEBUG_LOADERS) {
1963                         Log.d(TAG, &quot;sort took &quot;
1964                                 + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);
1965                     }
1966                 }
1967 
1968                 final long t2 = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1969 
1970                 startIndex = i;
1971                 for (int j=0; i&lt;N &amp;&amp; j&lt;batchSize; j++) {
1972                     // This builds the icon bitmaps.
1973                     mBgAllAppsList.add(new ApplicationInfo(packageManager, apps.get(i),
1974                             mIconCache, mLabelCache));
1975                     i++;
1976                 }
1977 
1978                 final boolean first = i &lt;= batchSize;
1979                 final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1980                 final ArrayList&lt;ApplicationInfo&gt; added = mBgAllAppsList.added;
1981                 mBgAllAppsList.added = new ArrayList&lt;ApplicationInfo&gt;();
1982 
1983                 mHandler.post(new Runnable() {
1984                     public void run() {
1985                         final long t = SystemClock.uptimeMillis();
1986                         if (callbacks != null) {
1987                             if (first) {
1988                                 callbacks.bindAllApplications(added);
1989                             } else {
1990                                 callbacks.bindAppsAdded(added);
1991                             }
1992                             if (DEBUG_LOADERS) {
1993                                 Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
1994                                     + (SystemClock.uptimeMillis() - t) + &quot;ms&quot;);
1995                             }
1996                         } else {
1997                             Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
1998                         }
1999                     }
2000                 });
2001 
2002                 if (DEBUG_LOADERS) {
2003                     Log.d(TAG, &quot;batch of &quot; + (i-startIndex) + &quot; icons processed in &quot;
2004                             + (SystemClock.uptimeMillis()-t2) + &quot;ms&quot;);
2005                 }
2006 
2007                 if (mAllAppsLoadDelay &gt; 0 &amp;&amp; i &lt; N) {
2008                     try {
2009                         if (DEBUG_LOADERS) {
2010                             Log.d(TAG, &quot;sleeping for &quot; + mAllAppsLoadDelay + &quot;ms&quot;);
2011                         }
2012                         Thread.sleep(mAllAppsLoadDelay);
2013                     } catch (InterruptedException exc) { }
2014                 }
2015             }
2016 
2017             if (DEBUG_LOADERS) {
2018                 Log.d(TAG, &quot;cached all &quot; + N + &quot; apps in &quot;
2019                         + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;
2020                         + (mAllAppsLoadDelay &gt; 0 ? &quot; (including delay)&quot; : &quot;&quot;));
2021             }
2022         }
2023 
2024         public void dumpState() {
2025             synchronized (sBgLock) {
2026                 Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
2027                 Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
2028                 Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
2029                 Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
2030                 Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
2031             }
2032         }
2033     }
2034 
2035     void enqueuePackageUpdated(PackageUpdatedTask task) {
2036         sWorker.post(task);
2037     }
2038 
2039     private class PackageUpdatedTask implements Runnable {
2040         int mOp;
2041         String[] mPackages;
2042 
2043         public static final int OP_NONE = 0;
2044         public static final int OP_ADD = 1;
2045         public static final int OP_UPDATE = 2;
2046         public static final int OP_REMOVE = 3; // uninstlled
2047         public static final int OP_UNAVAILABLE = 4; // external media unmounted
2048 
2049 
2050         public PackageUpdatedTask(int op, String[] packages) {
2051             mOp = op;
2052             mPackages = packages;
2053         }
2054 
2055         public void run() {
2056             final Context context = mApp;
2057 
2058             final String[] packages = mPackages;
2059             final int N = packages.length;
2060             switch (mOp) {
2061                 case OP_ADD:
2062                     for (int i=0; i&lt;N; i++) {
2063                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
2064                         mBgAllAppsList.addPackage(context, packages[i]);
2065                     }
2066                     break;
2067                 case OP_UPDATE:
2068                     for (int i=0; i&lt;N; i++) {
2069                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
2070                         mBgAllAppsList.updatePackage(context, packages[i]);
2071                     }
2072                     break;
2073                 case OP_REMOVE:
2074                 case OP_UNAVAILABLE:
2075                     for (int i=0; i&lt;N; i++) {
2076                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
2077                         mBgAllAppsList.removePackage(packages[i]);
2078                     }
2079                     break;
2080             }
2081 
2082             ArrayList&lt;ApplicationInfo&gt; added = null;
2083             ArrayList&lt;ApplicationInfo&gt; modified = null;
2084 
2085             if (mBgAllAppsList.added.size() &gt; 0) {
2086                 added = new ArrayList&lt;ApplicationInfo&gt;(mBgAllAppsList.added);
2087                 mBgAllAppsList.added.clear();
2088             }
2089             if (mBgAllAppsList.modified.size() &gt; 0) {
2090                 modified = new ArrayList&lt;ApplicationInfo&gt;(mBgAllAppsList.modified);
2091                 mBgAllAppsList.modified.clear();
2092             }
2093             // We may be removing packages that have no associated launcher application, so we
2094             // pass through the removed package names directly.
2095             // NOTE: We flush the icon cache aggressively in removePackage() above.
2096             final ArrayList&lt;String&gt; removedPackageNames = new ArrayList&lt;String&gt;();
2097             if (mBgAllAppsList.removed.size() &gt; 0) {
2098                 mBgAllAppsList.removed.clear();
2099 
2100                 for (int i = 0; i &lt; N; ++i) {
2101                     removedPackageNames.add(packages[i]);
2102                 }
2103             }
2104 
2105             final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
2106             if (callbacks == null) {
2107                 Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
2108                 return;
2109             }
2110 
2111             if (added != null) {
2112                 final ArrayList&lt;ApplicationInfo&gt; addedFinal = added;
2113                 mHandler.post(new Runnable() {
2114                     public void run() {
2115                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2116                         if (callbacks == cb &amp;&amp; cb != null) {
2117                             callbacks.bindAppsAdded(addedFinal);
2118                         }
2119                     }
2120                 });
2121             }
2122             if (modified != null) {
2123                 final ArrayList&lt;ApplicationInfo&gt; modifiedFinal = modified;
2124                 mHandler.post(new Runnable() {
2125                     public void run() {
2126                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2127                         if (callbacks == cb &amp;&amp; cb != null) {
2128                             callbacks.bindAppsUpdated(modifiedFinal);
2129                         }
2130                     }
2131                 });
2132             }
2133             if (!removedPackageNames.isEmpty()) {
2134                 final boolean permanent = mOp != OP_UNAVAILABLE;
2135                 mHandler.post(new Runnable() {
2136                     public void run() {
2137                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2138                         if (callbacks == cb &amp;&amp; cb != null) {
2139                             callbacks.bindAppsRemoved(removedPackageNames, permanent);
2140                         }
2141                     }
2142                 });
2143             }
2144 
2145             mHandler.post(new Runnable() {
2146                 @Override
2147                 public void run() {
2148                     Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2149                     if (callbacks == cb &amp;&amp; cb != null) {
2150                         callbacks.bindPackagesUpdated();
2151                     }
2152                 }
2153             });
2154         }
2155     }
2156 
2157     /**
2158      * This is called from the code that adds shortcuts from the intent receiver.  This
2159      * doesn&#x27;t have a Cursor, but
2160      */
2161     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context) {
2162         return getShortcutInfo(manager, intent, context, null, -1, -1, null);
2163     }
2164 
2165     /**
2166      * Make an ShortcutInfo object for a shortcut that is an application.
2167      *
2168      * If c is not null, then it will be used to fill in missing data like the title and icon.
2169      */
2170     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context,
2171             Cursor c, int iconIndex, int titleIndex, HashMap&lt;Object, CharSequence&gt; labelCache) {
2172         Bitmap icon = null;
2173         final ShortcutInfo info = new ShortcutInfo();
2174 
2175         ComponentName componentName = intent.getComponent();
2176         if (componentName == null) {
2177             return null;
2178         }
2179 
2180         try {
2181             PackageInfo pi = manager.getPackageInfo(componentName.getPackageName(), 0);
2182             if (!pi.applicationInfo.enabled) {
2183                 // If we return null here, the corresponding item will be removed from the launcher
2184                 // db and will not appear in the workspace.
2185                 return null;
2186             }
2187         } catch (NameNotFoundException e) {
2188             Log.d(TAG, &quot;getPackInfo failed for package &quot; + componentName.getPackageName());
2189         }
2190 
2191         // TODO: See if the PackageManager knows about this case.  If it doesn&#x27;t
2192         // then return null &amp; delete this.
2193 
2194         // the resource -- This may implicitly give us back the fallback icon,
2195         // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
2196         // to avoid saving lots of copies of that in the database, and most apps
2197         // have icons anyway.
2198 
2199         // Attempt to use queryIntentActivities to get the ResolveInfo (with IntentFilter info) and
2200         // if that fails, or is ambiguious, fallback to the standard way of getting the resolve info
2201         // via resolveActivity().
2202         ResolveInfo resolveInfo = null;
2203         ComponentName oldComponent = intent.getComponent();
2204         Intent newIntent = new Intent(intent.getAction(), null);
2205         newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2206         newIntent.setPackage(oldComponent.getPackageName());
2207         List&lt;ResolveInfo&gt; infos = manager.queryIntentActivities(newIntent, 0);
2208         for (ResolveInfo i : infos) {
2209             ComponentName cn = new ComponentName(i.activityInfo.packageName,
2210                     i.activityInfo.name);
2211             if (cn.equals(oldComponent)) {
2212                 resolveInfo = i;
2213             }
2214         }
2215         if (resolveInfo == null) {
2216             resolveInfo = manager.resolveActivity(intent, 0);
2217         }
2218         if (resolveInfo != null) {
2219             icon = mIconCache.getIcon(componentName, resolveInfo, labelCache);
2220         }
2221         // the db
2222         if (icon == null) {
2223             if (c != null) {
2224                 icon = getIconFromCursor(c, iconIndex, context);
2225             }
2226         }
2227         // the fallback icon
2228         if (icon == null) {
2229             icon = getFallbackIcon();
2230             info.usingFallbackIcon = true;
2231         }
2232         info.setIcon(icon);
2233 
2234         // from the resource
2235         if (resolveInfo != null) {
2236             ComponentName key = LauncherModel.getComponentNameFromResolveInfo(resolveInfo);
2237             if (labelCache != null &amp;&amp; labelCache.containsKey(key)) {
2238                 info.title = labelCache.get(key);
2239             } else {
2240                 info.title = resolveInfo.activityInfo.loadLabel(manager);
2241                 if (labelCache != null) {
2242                     labelCache.put(key, info.title);
2243                 }
2244             }
2245         }
2246         // from the db
2247         if (info.title == null) {
2248             if (c != null) {
2249                 info.title =  c.getString(titleIndex);
2250             }
2251         }
2252         // fall back to the class name of the activity
2253         if (info.title == null) {
2254             info.title = componentName.getClassName();
2255         }
2256         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
2257         return info;
2258     }
2259 
2260     /**
2261      * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
2262      */
2263     private ShortcutInfo getShortcutInfo(Cursor c, Context context,
2264             int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
2265             int titleIndex) {
2266 
2267         Bitmap icon = null;
2268         final ShortcutInfo info = new ShortcutInfo();
2269         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
2270 
2271         // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
2272 
2273         info.title = c.getString(titleIndex);
2274 
2275         int iconType = c.getInt(iconTypeIndex);
2276         switch (iconType) {
2277         case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
2278             String packageName = c.getString(iconPackageIndex);
2279             String resourceName = c.getString(iconResourceIndex);
2280             PackageManager packageManager = context.getPackageManager();
2281             info.customIcon = false;
2282             // the resource
2283             try {
2284                 Resources resources = packageManager.getResourcesForApplication(packageName);
2285                 if (resources != null) {
2286                     final int id = resources.getIdentifier(resourceName, null, null);
2287                     icon = Utilities.createIconBitmap(
2288                             mIconCache.getFullResIcon(resources, id), context);
2289                 }
2290             } catch (Exception e) {
2291                 // drop this.  we have other places to look for icons
2292             }
2293             // the db
2294             if (icon == null) {
2295                 icon = getIconFromCursor(c, iconIndex, context);
2296             }
2297             // the fallback icon
2298             if (icon == null) {
2299                 icon = getFallbackIcon();
2300                 info.usingFallbackIcon = true;
2301             }
2302             break;
2303         case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
2304             icon = getIconFromCursor(c, iconIndex, context);
2305             if (icon == null) {
2306                 icon = getFallbackIcon();
2307                 info.customIcon = false;
2308                 info.usingFallbackIcon = true;
2309             } else {
2310                 info.customIcon = true;
2311             }
2312             break;
2313         default:
2314             icon = getFallbackIcon();
2315             info.usingFallbackIcon = true;
2316             info.customIcon = false;
2317             break;
2318         }
2319         info.setIcon(icon);
2320         return info;
2321     }
2322 
2323     Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
2324         @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
2325         final boolean debug = false;
2326         if (debug) {
2327             Log.d(TAG, &quot;getIconFromCursor app=&quot;
2328                     + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
2329         }
2330         byte[] data = c.getBlob(iconIndex);
2331         try {
2332             return Utilities.createIconBitmap(
2333                     BitmapFactory.decodeByteArray(data, 0, data.length), context);
2334         } catch (Exception e) {
2335             return null;
2336         }
2337     }
2338 
2339     ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
2340             int cellX, int cellY, boolean notify) {
2341         final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
2342         if (info == null) {
2343             return null;
2344         }
2345         addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
2346 
2347         return info;
2348     }
2349 
2350     /**
2351      * Attempts to find an AppWidgetProviderInfo that matches the given component.
2352      */
2353     AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,
2354             ComponentName component) {
2355         List&lt;AppWidgetProviderInfo&gt; widgets =
2356             AppWidgetManager.getInstance(context).getInstalledProviders();
2357         for (AppWidgetProviderInfo info : widgets) {
2358             if (info.provider.equals(component)) {
2359                 return info;
2360             }
2361         }
2362         return null;
2363     }
2364 
2365     /**
2366      * Returns a list of all the widgets that can handle configuration with a particular mimeType.
2367      */
2368     List&lt;WidgetMimeTypeHandlerData&gt; resolveWidgetsForMimeType(Context context, String mimeType) {
2369         final PackageManager packageManager = context.getPackageManager();
2370         final List&lt;WidgetMimeTypeHandlerData&gt; supportedConfigurationActivities =
2371             new ArrayList&lt;WidgetMimeTypeHandlerData&gt;();
2372 
2373         final Intent supportsIntent =
2374             new Intent(InstallWidgetReceiver.ACTION_SUPPORTS_CLIPDATA_MIMETYPE);
2375         supportsIntent.setType(mimeType);
2376 
2377         // Create a set of widget configuration components that we can test against
2378         final List&lt;AppWidgetProviderInfo&gt; widgets =
2379             AppWidgetManager.getInstance(context).getInstalledProviders();
2380         final HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; configurationComponentToWidget =
2381             new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;();
2382         for (AppWidgetProviderInfo info : widgets) {
2383             configurationComponentToWidget.put(info.configure, info);
2384         }
2385 
2386         // Run through each of the intents that can handle this type of clip data, and cross
2387         // reference them with the components that are actual configuration components
2388         final List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(supportsIntent,
2389                 PackageManager.MATCH_DEFAULT_ONLY);
2390         for (ResolveInfo info : activities) {
2391             final ActivityInfo activityInfo = info.activityInfo;
2392             final ComponentName infoComponent = new ComponentName(activityInfo.packageName,
2393                     activityInfo.name);
2394             if (configurationComponentToWidget.containsKey(infoComponent)) {
2395                 supportedConfigurationActivities.add(
2396                         new InstallWidgetReceiver.WidgetMimeTypeHandlerData(info,
2397                                 configurationComponentToWidget.get(infoComponent)));
2398             }
2399         }
2400         return supportedConfigurationActivities;
2401     }
2402 
2403     ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
2404         Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
2405         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
2406         Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
2407 
2408         if (intent == null) {
2409             // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
2410             Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
2411             return null;
2412         }
2413 
2414         Bitmap icon = null;
2415         boolean customIcon = false;
2416         ShortcutIconResource iconResource = null;
2417 
2418         if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {
2419             icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);
2420             customIcon = true;
2421         } else {
2422             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
2423             if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {
2424                 try {
2425                     iconResource = (ShortcutIconResource) extra;
2426                     final PackageManager packageManager = context.getPackageManager();
2427                     Resources resources = packageManager.getResourcesForApplication(
2428                             iconResource.packageName);
2429                     final int id = resources.getIdentifier(iconResource.resourceName, null, null);
2430                     icon = Utilities.createIconBitmap(
2431                             mIconCache.getFullResIcon(resources, id), context);
2432                 } catch (Exception e) {
2433                     Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);
2434                 }
2435             }
2436         }
2437 
2438         final ShortcutInfo info = new ShortcutInfo();
2439 
2440         if (icon == null) {
2441             if (fallbackIcon != null) {
2442                 icon = fallbackIcon;
2443             } else {
2444                 icon = getFallbackIcon();
2445                 info.usingFallbackIcon = true;
2446             }
2447         }
2448         info.setIcon(icon);
2449 
2450         info.title = name;
2451         info.intent = intent;
2452         info.customIcon = customIcon;
2453         info.iconResource = iconResource;
2454 
2455         return info;
2456     }
2457 
2458     boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
2459             int iconIndex) {
2460         // If apps can&#x27;t be on SD, don&#x27;t even bother.
2461         if (!mAppsCanBeOnExternalStorage) {
2462             return false;
2463         }
2464         // If this icon doesn&#x27;t have a custom icon, check to see
2465         // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
2466         // we&#x27;re going to show, store what we are going to show back
2467         // into the DB.  We do this so when we&#x27;re loading, if the
2468         // package manager can&#x27;t find an icon (for example because
2469         // the app is on SD) then we can use that instead.
2470         if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
2471             cache.put(info, c.getBlob(iconIndex));
2472             return true;
2473         }
2474         return false;
2475     }
2476     void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
2477         boolean needSave = false;
2478         try {
2479             if (data != null) {
2480                 Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
2481                 Bitmap loaded = info.getIcon(mIconCache);
2482                 needSave = !saved.sameAs(loaded);
2483             } else {
2484                 needSave = true;
2485             }
2486         } catch (Exception e) {
2487             needSave = true;
2488         }
2489         if (needSave) {
2490             Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
2491             // This is slower than is ideal, but this only happens once
2492             // or when the app is updated with a new icon.
2493             updateItemInDatabase(context, info);
2494         }
2495     }
2496 
2497     /**
2498      * Return an existing FolderInfo object if we have encountered this ID previously,
2499      * or make a new one.
2500      */
2501     private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
2502         // See if a placeholder was created for us already
2503         FolderInfo folderInfo = folders.get(id);
2504         if (folderInfo == null) {
2505             // No placeholder -- create a new instance
2506             folderInfo = new FolderInfo();
2507             folders.put(id, folderInfo);
2508         }
2509         return folderInfo;
2510     }
2511 
2512     private static final Collator sCollator = Collator.getInstance();
2513     public static final Comparator&lt;ApplicationInfo&gt; APP_NAME_COMPARATOR
2514             = new Comparator&lt;ApplicationInfo&gt;() {
2515         public final int compare(ApplicationInfo a, ApplicationInfo b) {
2516             int result = sCollator.compare(a.title.toString(), b.title.toString());
2517             if (result == 0) {
2518                 result = a.componentName.compareTo(b.componentName);
2519             }
2520             return result;
2521         }
2522     };
2523     public static final Comparator&lt;ApplicationInfo&gt; APP_INSTALL_TIME_COMPARATOR
2524             = new Comparator&lt;ApplicationInfo&gt;() {
2525         public final int compare(ApplicationInfo a, ApplicationInfo b) {
2526             if (a.firstInstallTime &lt; b.firstInstallTime) return 1;
2527             if (a.firstInstallTime &gt; b.firstInstallTime) return -1;
2528             return 0;
2529         }
2530     };
2531     public static final Comparator&lt;AppWidgetProviderInfo&gt; WIDGET_NAME_COMPARATOR
2532             = new Comparator&lt;AppWidgetProviderInfo&gt;() {
2533         public final int compare(AppWidgetProviderInfo a, AppWidgetProviderInfo b) {
2534             return sCollator.compare(a.label.toString(), b.label.toString());
2535         }
2536     };
2537     static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
2538         if (info.activityInfo != null) {
2539             return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
2540         } else {
2541             return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
2542         }
2543     }
2544     public static class ShortcutNameComparator implements Comparator&lt;ResolveInfo&gt; {
2545         private PackageManager mPackageManager;
2546         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
2547         ShortcutNameComparator(PackageManager pm) {
2548             mPackageManager = pm;
2549             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
2550         }
2551         ShortcutNameComparator(PackageManager pm, HashMap&lt;Object, CharSequence&gt; labelCache) {
2552             mPackageManager = pm;
2553             mLabelCache = labelCache;
2554         }
2555         public final int compare(ResolveInfo a, ResolveInfo b) {
2556             CharSequence labelA, labelB;
2557             ComponentName keyA = LauncherModel.getComponentNameFromResolveInfo(a);
2558             ComponentName keyB = LauncherModel.getComponentNameFromResolveInfo(b);
2559             if (mLabelCache.containsKey(keyA)) {
2560                 labelA = mLabelCache.get(keyA);
2561             } else {
2562                 labelA = a.loadLabel(mPackageManager).toString();
2563 
2564                 mLabelCache.put(keyA, labelA);
2565             }
2566             if (mLabelCache.containsKey(keyB)) {
2567                 labelB = mLabelCache.get(keyB);
2568             } else {
2569                 labelB = b.loadLabel(mPackageManager).toString();
2570 
2571                 mLabelCache.put(keyB, labelB);
2572             }
2573             return sCollator.compare(labelA, labelB);
2574         }
2575     };
2576     public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
2577         private PackageManager mPackageManager;
2578         private HashMap&lt;Object, String&gt; mLabelCache;
2579         WidgetAndShortcutNameComparator(PackageManager pm) {
2580             mPackageManager = pm;
2581             mLabelCache = new HashMap&lt;Object, String&gt;();
2582         }
2583         public final int compare(Object a, Object b) {
2584             String labelA, labelB;
2585             if (mLabelCache.containsKey(a)) {
2586                 labelA = mLabelCache.get(a);
2587             } else {
2588                 labelA = (a instanceof AppWidgetProviderInfo) ?
2589                     ((AppWidgetProviderInfo) a).label :
2590                     ((ResolveInfo) a).loadLabel(mPackageManager).toString();
2591                 mLabelCache.put(a, labelA);
2592             }
2593             if (mLabelCache.containsKey(b)) {
2594                 labelB = mLabelCache.get(b);
2595             } else {
2596                 labelB = (b instanceof AppWidgetProviderInfo) ?
2597                     ((AppWidgetProviderInfo) b).label :
2598                     ((ResolveInfo) b).loadLabel(mPackageManager).toString();
2599                 mLabelCache.put(b, labelB);
2600             }
2601             return sCollator.compare(labelA, labelB);
2602         }
2603     };
2604 
2605     public void dumpState() {
2606         Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
2607         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
2608         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
2609         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
2610         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
2611         if (mLoaderTask != null) {
2612             mLoaderTask.dumpState();
2613         } else {
2614             Log.d(TAG, &quot;mLoaderTask=null&quot;);
2615         }
2616     }
2617 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher2;
  18 
  19 import android.app.SearchManager;
  20 import android.appwidget.AppWidgetManager;
  21 import android.appwidget.AppWidgetProviderInfo;
  22 import android.content.BroadcastReceiver;
  23 import android.content.ComponentName;
  24 import android.content.ContentProviderClient;
  25 import android.content.ContentResolver;
  26 import android.content.ContentValues;
  27 import android.content.Context;
  28 import android.content.Intent;
  29 import android.content.Intent.ShortcutIconResource;
  30 import android.content.pm.ActivityInfo;
  31 import android.content.pm.PackageInfo;
  32 import android.content.pm.PackageManager;
  33 import android.content.pm.PackageManager.NameNotFoundException;
  34 import android.content.pm.ResolveInfo;
  35 import android.content.res.Configuration;
  36 import android.content.res.Resources;
  37 import android.database.Cursor;
  38 import android.graphics.Bitmap;
  39 import android.graphics.BitmapFactory;
  40 import android.net.Uri;
  41 import android.os.Environment;
  42 import android.os.Handler;
  43 import android.os.HandlerThread;
  44 import android.os.Parcelable;
  45 import android.os.Process;
  46 import android.os.RemoteException;
  47 import android.os.SystemClock;
  48 import android.util.Log;
  49 
  50 import com.android.launcher.R;
  51 import com.android.launcher2.InstallWidgetReceiver.WidgetMimeTypeHandlerData;
  52 
  53 import java.lang.ref.WeakReference;
  54 import java.net.URISyntaxException;
  55 import java.text.Collator;
  56 import java.util.ArrayList;
  57 import java.util.Collections;
  58 import java.util.Comparator;
  59 import java.util.HashMap;
  60 import java.util.HashSet;
  61 import java.util.Iterator;
  62 import java.util.List;
  63 import java.util.Set;
  64 
  65 /**
  66  * Maintains in-memory state of the Launcher. It is expected that there should be only one
  67  * LauncherModel object held in a static. Also provide APIs for updating the database state
  68  * for the Launcher.
  69  */
  70 public class LauncherModel extends BroadcastReceiver {
  71     static final boolean DEBUG_LOADERS = false;
  72     static final String TAG = &quot;Launcher.Model&quot;;
  73 
  74     private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
  75     private final boolean mAppsCanBeOnExternalStorage;
  76     private int mBatchSize; // 0 is all apps at once
  77     private int mAllAppsLoadDelay; // milliseconds between batches
  78 
  79     private final LauncherApplication mApp;
  80     private final Object mLock = new Object();
  81     private DeferredHandler mHandler = new DeferredHandler();
  82     private LoaderTask mLoaderTask;
  83     private boolean mIsLoaderTaskRunning;
  84 
  85     private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
  86     static {
  87         sWorkerThread.start();
  88     }
  89     private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
  90 
  91     // We start off with everything not loaded.  After that, we assume that
  92     // our monitoring of the package manager provides all updates and we never
  93     // need to do a requery.  These are only ever touched from the loader thread.
  94     private boolean mWorkspaceLoaded;
  95     private boolean mAllAppsLoaded;
  96 
  97     // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
  98     // pages as this delays the rotation process.  Instead, we wait for a callback from the first
  99     // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 100     // a normal load, we also clear this set of Runnables.
 101     static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 102 
 103     private WeakReference&lt;Callbacks&gt; mCallbacks;
 104 
 105     // &lt; only access in worker thread &gt;
 106     private AllAppsList mBgAllAppsList;
 107 
 108     // The lock that must be acquired before referencing any static bg data structures.  Unlike
 109     // other locks, this one can generally be held long-term because we never expect any of these
 110     // static data structures to be referenced outside of the worker thread except on the first
 111     // load after configuration change.
 112     static final Object sBgLock = new Object();
 113 
 114     // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 115     // LauncherModel to their ids
 116     static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
 117 
 118     // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 119     //       created by LauncherModel that are directly on the home screen (however, no widgets or
 120     //       shortcuts within folders).
 121     static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 122 
 123     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 124     static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 125         new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 126 
 127     // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 128     static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 129 
 130     // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 131     static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 132     // &lt;/ only access in worker thread &gt;
 133 
 134     private IconCache mIconCache;
 135     private Bitmap mDefaultIcon;
 136 
 137     private static int mCellCountX;
 138     private static int mCellCountY;
 139 
 140     protected int mPreviousConfigMcc;
 141 
 142     public interface Callbacks {
 143         public boolean setLoadOnResume();
 144         public int getCurrentWorkspaceScreen();
 145         public void startBinding();
 146         public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end);
 147         public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 148         public void finishBindingItems();
 149         public void bindAppWidget(LauncherAppWidgetInfo info);
 150         public void bindAllApplications(ArrayList&lt;ApplicationInfo&gt; apps);
 151         public void bindAppsAdded(ArrayList&lt;ApplicationInfo&gt; apps);
 152         public void bindAppsUpdated(ArrayList&lt;ApplicationInfo&gt; apps);
 153         public void bindAppsRemoved(ArrayList&lt;String&gt; packageNames, boolean permanent);
 154         public void bindPackagesUpdated();
 155         public boolean isAllAppsVisible();
 156         public boolean isAllAppsButtonRank(int rank);
 157         public void bindSearchablesChanged();
 158         public void onPageBoundSynchronously(int page);
 159     }
 160 
 161     LauncherModel(LauncherApplication app, IconCache iconCache) {
 162         mAppsCanBeOnExternalStorage = !Environment.isExternalStorageEmulated();
 163         mApp = app;
 164         mBgAllAppsList = new AllAppsList(iconCache);
 165         mIconCache = iconCache;
 166 
 167         mDefaultIcon = Utilities.createIconBitmap(
 168                 mIconCache.getFullResDefaultActivityIcon(), app);
 169 
 170         final Resources res = app.getResources();
 171         mAllAppsLoadDelay = res.getInteger(R.integer.config_allAppsBatchLoadDelay);
 172         mBatchSize = res.getInteger(R.integer.config_allAppsBatchSize);
 173         Configuration config = res.getConfiguration();
 174         mPreviousConfigMcc = config.mcc;
 175     }
 176 
 177     /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 178      * posted on the main thread handler. */
 179     private void runOnMainThread(Runnable r) {
 180         if (sWorkerThread.getThreadId() == Process.myTid()) {
 181             // If we are on the worker thread, post onto the main handler
 182             mHandler.post(r);
 183         } else {
 184             r.run();
 185         }
 186     }
 187 
 188     /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 189      * posted on the worker thread handler. */
 190     private static void runOnWorkerThread(Runnable r) {
 191         if (sWorkerThread.getThreadId() == Process.myTid()) {
 192             r.run();
 193         } else {
 194             // If we are not on the worker thread, then post to the worker handler
 195             sWorker.post(r);
 196         }
 197     }
 198 
 199     public Bitmap getFallbackIcon() {
 200         return Bitmap.createBitmap(mDefaultIcon);
 201     }
 202 
 203     public void unbindWorkspaceItems() {
 204         sWorker.post(new Runnable() {
 205             @Override
 206             public void run() {
 207                 unbindWorkspaceItemsOnMainThread();
 208             }
 209         });
 210     }
 211 
 212     /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 213     private void unbindWorkspaceItemsOnMainThread() {
 214         // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 215         // by making a copy of workspace items first.
 216         final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 217         final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 218         synchronized (sBgLock) {
 219             tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 220             tmpAppWidgets.addAll(sBgAppWidgets);
 221         }
 222         Runnable r = new Runnable() {
 223                 @Override
 224                 public void run() {
 225                    for (ItemInfo item : tmpWorkspaceItems) {
 226                        item.unbind();
 227                    }
 228                    for (ItemInfo item : tmpAppWidgets) {
 229                        item.unbind();
 230                    }
 231                 }
 232             };
 233         runOnMainThread(r);
 234     }
 235 
 236     /**
 237      * Adds an item to the DB if it was not created previously, or move it to a new
 238      * &lt;container, screen, cellX, cellY&gt;
 239      */
 240     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 241             int screen, int cellX, int cellY) {
 242         if (item.container == ItemInfo.NO_ID) {
 243             // From all apps
 244             addItemToDatabase(context, item, container, screen, cellX, cellY, false);
 245         } else {
 246             // From somewhere else
 247             moveItemInDatabase(context, item, container, screen, cellX, cellY);
 248         }
 249     }
 250 
 251     static void checkItemInfo(final ItemInfo item) {
 252         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 253         final long itemId = item.id;
 254         Runnable r = new Runnable() {
 255                 public void run() {
 256                     synchronized (sBgLock) {
 257                         ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 258                         if (modelItem != null &amp;&amp; item != modelItem) {
 259                             // the modelItem needs to match up perfectly with item if our model is
 260                             // to be consistent with the database-- for now, just require
 261                             // modelItem == item
 262                             String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 263                                 &quot;modelItem: &quot; +
 264                                     ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 265                                 &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 266                             RuntimeException e = new RuntimeException(msg);
 267                             e.setStackTrace(stackTrace);
 268                             throw e;
 269                         }
 270                     }
 271                 }
 272             };
 273         runOnWorkerThread(r);
 274     }
 275 
 276     static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 277             final ItemInfo item, final String callingFunction) {
 278         final long itemId = item.id;
 279         final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 280         final ContentResolver cr = context.getContentResolver();
 281 
 282         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 283         Runnable r = new Runnable() {
 284             public void run() {
 285                 cr.update(uri, values, null, null);
 286 
 287                 // Lock on mBgLock *after* the db operation
 288                 synchronized (sBgLock) {
 289                     ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 290                     if (item != modelItem) {
 291                         // the modelItem needs to match up perfectly with item if our model is to be
 292                         // consistent with the database-- for now, just require modelItem == item
 293                         String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 294                             &quot;modelItem: &quot; + ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 295                             &quot;Error: ItemInfo passed to &quot; + callingFunction + &quot; doesn&#x27;t match &quot; +
 296                             &quot;original&quot;;
 297                         throw new RuntimeException(msg);
 298                     }
 299 
 300                     if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
 301                             item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 302                         // Item is in a folder, make sure this folder exists
 303                         if (!sBgFolders.containsKey(item.container)) {
 304                             // An items container is being set to a that of an item which is not in
 305                             // the list of Folders.
 306                             String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +
 307                                     item.container + &quot;, not in the list of folders&quot;;
 308                             RuntimeException e = new RuntimeException(msg);
 309                             e.setStackTrace(stackTrace);
 310                             Launcher.dumpDebugLogsToConsole();
 311                             throw e;
 312                         }
 313                     }
 314 
 315                     // Items are added/removed from the corresponding FolderInfo elsewhere, such
 316                     // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 317                     // that are on the desktop, as appropriate
 318                     if (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 319                             modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 320                         switch (modelItem.itemType) {
 321                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 322                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 323                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 324                         if (!sBgWorkspaceItems.contains(modelItem)) {
 325                             sBgWorkspaceItems.add(modelItem);
 326                                 }
 327                                 break;
 328                             default:
 329                                 break;
 330                         }
 331                     } else {
 332                         sBgWorkspaceItems.remove(modelItem);
 333                     }
 334                 }
 335             }
 336         };
 337         runOnWorkerThread(r);
 338     }
 339 
 340     /**
 341      * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 342      */
 343     static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 344             final int screen, final int cellX, final int cellY) {
 345         String transaction = &quot;DbDebug    Modify item (&quot; + item.title + &quot;) in db, id: &quot; + item.id +
 346                 &quot; (&quot; + item.container + &quot;, &quot; + item.screen + &quot;, &quot; + item.cellX + &quot;, &quot; + item.cellY +
 347                 &quot;) --&gt; &quot; + &quot;(&quot; + container + &quot;, &quot; + screen + &quot;, &quot; + cellX + &quot;, &quot; + cellY + &quot;)&quot;;
 348         Launcher.sDumpLogs.add(transaction);
 349         Log.d(TAG, transaction);
 350         item.container = container;
 351         item.cellX = cellX;
 352         item.cellY = cellY;
 353 
 354         // We store hotseat items in canonical form which is this orientation invariant position
 355         // in the hotseat
 356         if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 357                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 358             item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 359         } else {
 360             item.screen = screen;
 361         }
 362 
 363         final ContentValues values = new ContentValues();
 364         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 365         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 366         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 367         values.put(LauncherSettings.Favorites.SCREEN, item.screen);
 368 
 369         updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 370     }
 371 
 372     /**
 373      * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 374      */
 375     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 376             final int screen, final int cellX, final int cellY, final int spanX, final int spanY) {
 377         String transaction = &quot;DbDebug    Modify item (&quot; + item.title + &quot;) in db, id: &quot; + item.id +
 378                 &quot; (&quot; + item.container + &quot;, &quot; + item.screen + &quot;, &quot; + item.cellX + &quot;, &quot; + item.cellY +
 379                 &quot;) --&gt; &quot; + &quot;(&quot; + container + &quot;, &quot; + screen + &quot;, &quot; + cellX + &quot;, &quot; + cellY + &quot;)&quot;;
 380         Launcher.sDumpLogs.add(transaction);
 381         Log.d(TAG, transaction);
 382         item.cellX = cellX;
 383         item.cellY = cellY;
 384         item.spanX = spanX;
 385         item.spanY = spanY;
 386 
 387         // We store hotseat items in canonical form which is this orientation invariant position
 388         // in the hotseat
 389         if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 390                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 391             item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 392         } else {
 393             item.screen = screen;
 394         }
 395 
 396         final ContentValues values = new ContentValues();
 397         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 398         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 399         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 400         values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 401         values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 402         values.put(LauncherSettings.Favorites.SCREEN, item.screen);
 403 
 404         updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 405     }
 406 
 407     /**
 408      * Update an item to the database in a specified container.
 409      */
 410     static void updateItemInDatabase(Context context, final ItemInfo item) {
 411         final ContentValues values = new ContentValues();
 412         item.onAddToDatabase(values);
 413         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 414         updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 415     }
 416 
 417     /**
 418      * Returns true if the shortcuts already exists in the database.
 419      * we identify a shortcut by its title and intent.
 420      */
 421     static boolean shortcutExists(Context context, String title, Intent intent) {
 422         final ContentResolver cr = context.getContentResolver();
 423         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 424             new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and intent=?&quot;,
 425             new String[] { title, intent.toUri(0) }, null);
 426         boolean result = false;
 427         try {
 428             result = c.moveToFirst();
 429         } finally {
 430             c.close();
 431         }
 432         return result;
 433     }
 434 
 435     /**
 436      * Returns an ItemInfo array containing all the items in the LauncherModel.
 437      * The ItemInfo.id is not set through this function.
 438      */
 439     static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 440         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 441         final ContentResolver cr = context.getContentResolver();
 442         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
 443                 LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
<abbr title=" 444                 LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,"> 444                 LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.FavðŸ”µ</abbr>
 445                 LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY }, null, null, null);
 446 
 447         final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 448         final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 449         final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 450         final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 451         final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 452         final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 453         final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 454 
 455         try {
 456             while (c.moveToNext()) {
 457                 ItemInfo item = new ItemInfo();
 458                 item.cellX = c.getInt(cellXIndex);
 459                 item.cellY = c.getInt(cellYIndex);
 460                 item.spanX = c.getInt(spanXIndex);
 461                 item.spanY = c.getInt(spanYIndex);
 462                 item.container = c.getInt(containerIndex);
 463                 item.itemType = c.getInt(itemTypeIndex);
 464                 item.screen = c.getInt(screenIndex);
 465 
 466                 items.add(item);
 467             }
 468         } catch (Exception e) {
 469             items.clear();
 470         } finally {
 471             c.close();
 472         }
 473 
 474         return items;
 475     }
 476 
 477     /**
 478      * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 479      */
 480     FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
 481         final ContentResolver cr = context.getContentResolver();
 482         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
 483                 &quot;_id=? and (itemType=? or itemType=?)&quot;,
 484                 new String[] { String.valueOf(id),
 485                         String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
 486 
 487         try {
 488             if (c.moveToFirst()) {
 489                 final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 490                 final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 491                 final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 492                 final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 493                 final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 494                 final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 495 
 496                 FolderInfo folderInfo = null;
 497                 switch (c.getInt(itemTypeIndex)) {
 498                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 499                         folderInfo = findOrMakeFolder(folderList, id);
 500                         break;
 501                 }
 502 
 503                 folderInfo.title = c.getString(titleIndex);
 504                 folderInfo.id = id;
 505                 folderInfo.container = c.getInt(containerIndex);
 506                 folderInfo.screen = c.getInt(screenIndex);
 507                 folderInfo.cellX = c.getInt(cellXIndex);
 508                 folderInfo.cellY = c.getInt(cellYIndex);
 509 
 510                 return folderInfo;
 511             }
 512         } finally {
 513             c.close();
 514         }
 515 
 516         return null;
 517     }
 518 
 519     /**
 520      * Add an item to the database in a specified container. Sets the container, screen, cellX and
 521      * cellY fields of the item. Also assigns an ID to the item.
 522      */
 523     static void addItemToDatabase(Context context, final ItemInfo item, final long container,
 524             final int screen, final int cellX, final int cellY, final boolean notify) {
 525         item.container = container;
 526         item.cellX = cellX;
 527         item.cellY = cellY;
 528         // We store hotseat items in canonical form which is this orientation invariant position
 529         // in the hotseat
 530         if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 531                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 532             item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 533         } else {
 534             item.screen = screen;
 535         }
 536 
 537         final ContentValues values = new ContentValues();
 538         final ContentResolver cr = context.getContentResolver();
 539         item.onAddToDatabase(values);
 540 
 541         LauncherApplication app = (LauncherApplication) context.getApplicationContext();
 542         item.id = app.getLauncherProvider().generateNewId();
 543         values.put(LauncherSettings.Favorites._ID, item.id);
 544         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 545 
 546         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 547 
 548         Runnable r = new Runnable() {
 549             public void run() {
 550                 String transaction = &quot;DbDebug    Add item (&quot; + item.title + &quot;) to db, id: &quot;
 551                         + item.id + &quot; (&quot; + container + &quot;, &quot; + screen + &quot;, &quot; + cellX + &quot;, &quot;
 552                         + cellY + &quot;)&quot;;
 553                 Launcher.sDumpLogs.add(transaction);
 554                 Log.d(TAG, transaction);
 555 
 556                 cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
 557                         LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);
 558 
 559                 // Lock on mBgLock *after* the db operation
 560                 synchronized (sBgLock) {
 561                     if (sBgItemsIdMap.containsKey(item.id)) {
 562                         // we should not be adding new items in the db with the same id
 563                         throw new RuntimeException(&quot;Error: ItemInfo id (&quot; + item.id + &quot;) passed to &quot; +
 564                             &quot;addItemToDatabase already exists.&quot; + item.toString());
 565                     }
 566                     sBgItemsIdMap.put(item.id, item);
 567                     switch (item.itemType) {
 568                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 569                             sBgFolders.put(item.id, (FolderInfo) item);
 570                             // Fall through
 571                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 572                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 573                             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 574                                     item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 575                                 sBgWorkspaceItems.add(item);
 576                             } else {
 577                                 if (!sBgFolders.containsKey(item.container)) {
 578                                     // Adding an item to a folder that doesn&#x27;t exist.
 579                                     String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +
 580                                             &quot; doesn&#x27;t exist&quot;;
 581                                     RuntimeException e = new RuntimeException(msg);
 582                                     e.setStackTrace(stackTrace);
 583                                     Launcher.dumpDebugLogsToConsole();
 584                                     throw e;
 585                                 }
 586                             }
 587                             break;
 588                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
 589                             sBgAppWidgets.add((LauncherAppWidgetInfo) item);
 590                             break;
 591                     }
 592                 }
 593             }
 594         };
 595         runOnWorkerThread(r);
 596     }
 597 
 598     /**
 599      * Creates a new unique child id, for a given cell span across all layouts.
 600      */
 601     static int getCellLayoutChildId(
 602             long container, int screen, int localCellX, int localCellY, int spanX, int spanY) {
 603         return (((int) container &amp; 0xFF) &lt;&lt; 24)
 604                 | (screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
 605     }
 606 
 607     static int getCellCountX() {
 608         return mCellCountX;
 609     }
 610 
 611     static int getCellCountY() {
 612         return mCellCountY;
 613     }
 614 
 615     /**
 616      * Updates the model orientation helper to take into account the current layout dimensions
 617      * when performing local/canonical coordinate transformations.
 618      */
 619     static void updateWorkspaceLayoutCells(int shortAxisCellCount, int longAxisCellCount) {
 620         mCellCountX = shortAxisCellCount;
 621         mCellCountY = longAxisCellCount;
 622     }
 623 
 624     /**
 625      * Removes the specified item from the database
 626      * @param context
 627      * @param item
 628      */
 629     static void deleteItemFromDatabase(Context context, final ItemInfo item) {
 630         final ContentResolver cr = context.getContentResolver();
 631         final Uri uriToDelete = LauncherSettings.Favorites.getContentUri(item.id, false);
 632         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 633 
 634         Runnable r = new Runnable() {
 635             public void run() {
 636                 String transaction = &quot;DbDebug    Delete item (&quot; + item.title + &quot;) from db, id: &quot;
 637                         + item.id + &quot; (&quot; + item.container + &quot;, &quot; + item.screen + &quot;, &quot; + item.cellX +
 638                         &quot;, &quot; + item.cellY + &quot;)&quot;;
 639                 Launcher.sDumpLogs.add(transaction);
 640                 Log.d(TAG, transaction);
 641 
 642                 cr.delete(uriToDelete, null, null);
 643 
 644                 // Lock on mBgLock *after* the db operation
 645                 synchronized (sBgLock) {
 646                     switch (item.itemType) {
 647                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 648                             sBgFolders.remove(item.id);
 649                             for (ItemInfo info: sBgItemsIdMap.values()) {
 650                                 if (info.container == item.id) {
 651                                     // We are deleting a folder which still contains items that
 652                                     // think they are contained by that folder.
 653                                     String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +
 654                                             &quot;contains items (&quot; + info + &quot;)&quot;;
 655                                     RuntimeException e = new RuntimeException(msg);
 656                                     e.setStackTrace(stackTrace);
 657                                     Launcher.dumpDebugLogsToConsole();
 658                                     throw e;
 659                                 }
 660                             }
 661                             sBgWorkspaceItems.remove(item);
 662                             break;
 663                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 664                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 665                             sBgWorkspaceItems.remove(item);
 666                             break;
 667                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
 668                             sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
 669                             break;
 670                     }
 671                     sBgItemsIdMap.remove(item.id);
 672                     sBgDbIconCache.remove(item);
 673                 }
 674             }
 675         };
 676         runOnWorkerThread(r);
 677     }
 678 
 679     /**
 680      * Remove the contents of the specified folder from the database
 681      */
 682     static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
 683         final ContentResolver cr = context.getContentResolver();
 684 
 685         Runnable r = new Runnable() {
 686             public void run() {
 687                 cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
 688                 // Lock on mBgLock *after* the db operation
 689                 synchronized (sBgLock) {
 690                     sBgItemsIdMap.remove(info.id);
 691                     sBgFolders.remove(info.id);
 692                     sBgDbIconCache.remove(info);
 693                     sBgWorkspaceItems.remove(info);
 694                 }
 695 
 696                 cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
 697                         LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
 698                 // Lock on mBgLock *after* the db operation
 699                 synchronized (sBgLock) {
 700                     for (ItemInfo childInfo : info.contents) {
 701                         sBgItemsIdMap.remove(childInfo.id);
 702                         sBgDbIconCache.remove(childInfo);
 703                     }
 704                 }
 705             }
 706         };
 707         runOnWorkerThread(r);
 708     }
 709 
 710     /**
 711      * Set this as the current Launcher activity object for the loader.
 712      */
 713     public void initialize(Callbacks callbacks) {
 714         synchronized (mLock) {
 715             mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
 716         }
 717     }
 718 
 719     /**
 720      * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
 721      * ACTION_PACKAGE_CHANGED.
 722      */
 723     @Override
 724     public void onReceive(Context context, Intent intent) {
 725         if (DEBUG_LOADERS) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
 726 
 727         final String action = intent.getAction();
 728 
 729         if (Intent.ACTION_PACKAGE_CHANGED.equals(action)
 730                 || Intent.ACTION_PACKAGE_REMOVED.equals(action)
 731                 || Intent.ACTION_PACKAGE_ADDED.equals(action)) {
 732             final String packageName = intent.getData().getSchemeSpecificPart();
 733             final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
 734 
 735             int op = PackageUpdatedTask.OP_NONE;
 736 
 737             if (packageName == null || packageName.length() == 0) {
 738                 // they sent us a bad intent
 739                 return;
 740             }
 741 
 742             if (Intent.ACTION_PACKAGE_CHANGED.equals(action)) {
 743                 op = PackageUpdatedTask.OP_UPDATE;
 744             } else if (Intent.ACTION_PACKAGE_REMOVED.equals(action)) {
 745                 if (!replacing) {
 746                     op = PackageUpdatedTask.OP_REMOVE;
 747                 }
 748                 // else, we are replacing the package, so a PACKAGE_ADDED will be sent
 749                 // later, we will update the package at this time
 750             } else if (Intent.ACTION_PACKAGE_ADDED.equals(action)) {
 751                 if (!replacing) {
 752                     op = PackageUpdatedTask.OP_ADD;
 753                 } else {
 754                     op = PackageUpdatedTask.OP_UPDATE;
 755                 }
 756             }
 757 
 758             if (op != PackageUpdatedTask.OP_NONE) {
 759                 enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName }));
 760             }
 761 
 762         } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(action)) {
 763             // First, schedule to add these apps back in.
 764             String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
 765             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packages));
 766             // Then, rebind everything.
 767             startLoaderFromBackground();
 768         } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(action)) {
 769             String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
 770             enqueuePackageUpdated(new PackageUpdatedTask(
 771                         PackageUpdatedTask.OP_UNAVAILABLE, packages));
 772         } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
 773             // If we have changed locale we need to clear out the labels in all apps/workspace.
 774             forceReload();
 775         } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
 776              // Check if configuration change was an mcc/mnc change which would affect app resources
 777              // and we would need to clear out the labels in all apps/workspace. Same handling as
 778              // above for ACTION_LOCALE_CHANGED
 779              Configuration currentConfig = context.getResources().getConfiguration();
 780              if (mPreviousConfigMcc != currentConfig.mcc) {
 781                    Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
 782                        + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
 783                    forceReload();
 784              }
 785              // Update previousConfig
 786              mPreviousConfigMcc = currentConfig.mcc;
 787         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
 788                    SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
 789             if (mCallbacks != null) {
 790                 Callbacks callbacks = mCallbacks.get();
 791                 if (callbacks != null) {
 792                     callbacks.bindSearchablesChanged();
 793                 }
 794             }
 795         }
 796     }
 797 
 798     private void forceReload() {
 799         resetLoadedState(true, true);
 800 
 801         // Do this here because if the launcher activity is running it will be restarted.
 802         // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
 803         // to reload.
 804         startLoaderFromBackground();
 805     }
 806 
 807     public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
 808         synchronized (mLock) {
 809             // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
 810             // mWorkspaceLoaded to true later
 811             stopLoaderLocked();
 812             if (resetAllAppsLoaded) mAllAppsLoaded = false;
 813             if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
 814         }
 815     }
 816 
 817     /**
 818      * When the launcher is in the background, it&#x27;s possible for it to miss paired
 819      * configuration changes.  So whenever we trigger the loader from the background
 820      * tell the launcher that it needs to re-run the loader when it comes back instead
 821      * of doing it now.
 822      */
 823     public void startLoaderFromBackground() {
 824         boolean runLoader = false;
 825         if (mCallbacks != null) {
 826             Callbacks callbacks = mCallbacks.get();
 827             if (callbacks != null) {
 828                 // Only actually run the loader if they&#x27;re not paused.
 829                 if (!callbacks.setLoadOnResume()) {
 830                     runLoader = true;
 831                 }
 832             }
 833         }
 834         if (runLoader) {
 835             startLoader(false, -1);
 836         }
 837     }
 838 
 839     // If there is already a loader task running, tell it to stop.
 840     // returns true if isLaunching() was true on the old task
 841     private boolean stopLoaderLocked() {
 842         boolean isLaunching = false;
 843         LoaderTask oldTask = mLoaderTask;
 844         if (oldTask != null) {
 845             if (oldTask.isLaunching()) {
 846                 isLaunching = true;
 847             }
 848             oldTask.stopLocked();
 849         }
 850         return isLaunching;
 851     }
 852 
 853     public void startLoader(boolean isLaunching, int synchronousBindPage) {
 854         synchronized (mLock) {
 855             if (DEBUG_LOADERS) {
 856                 Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
 857             }
 858 
 859             // Clear any deferred bind-runnables from the synchronized load process
 860             // We must do this before any loading/binding is scheduled below.
 861             mDeferredBindRunnables.clear();
 862 
 863             // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
 864             if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
 865                 // If there is already one running, tell it to stop.
 866                 // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
 867                 isLaunching = isLaunching || stopLoaderLocked();
 868                 mLoaderTask = new LoaderTask(mApp, isLaunching);
 869                 if (synchronousBindPage &gt; -1 &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {
 870                     mLoaderTask.runBindSynchronousPage(synchronousBindPage);
 871                 } else {
 872                     sWorkerThread.setPriority(Thread.NORM_PRIORITY);
 873                     sWorker.post(mLoaderTask);
 874                 }
 875             }
 876         }
 877     }
 878 
 879     void bindRemainingSynchronousPages() {
 880         // Post the remaining side pages to be loaded
 881         if (!mDeferredBindRunnables.isEmpty()) {
 882             for (final Runnable r : mDeferredBindRunnables) {
 883                 mHandler.post(r);
 884             }
 885             mDeferredBindRunnables.clear();
 886         }
 887     }
 888 
 889     public void stopLoader() {
 890         synchronized (mLock) {
 891             if (mLoaderTask != null) {
 892                 mLoaderTask.stopLocked();
 893             }
 894         }
 895     }
 896 
 897     public boolean isAllAppsLoaded() {
 898         return mAllAppsLoaded;
 899     }
 900 
 901     boolean isLoadingWorkspace() {
 902         synchronized (mLock) {
 903             if (mLoaderTask != null) {
 904                 return mLoaderTask.isLoadingWorkspace();
 905             }
 906         }
 907         return false;
 908     }
 909 
 910     /**
 911      * Runnable for the thread that loads the contents of the launcher:
 912      *   - workspace icons
 913      *   - widgets
 914      *   - all apps icons
 915      */
 916     private class LoaderTask implements Runnable {
 917         private Context mContext;
 918         private boolean mIsLaunching;
 919         private boolean mIsLoadingAndBindingWorkspace;
 920         private boolean mStopped;
 921         private boolean mLoadAndBindStepFinished;
 922 
 923         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
 924 
 925         LoaderTask(Context context, boolean isLaunching) {
 926             mContext = context;
 927             mIsLaunching = isLaunching;
 928             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
 929         }
 930 
 931         boolean isLaunching() {
 932             return mIsLaunching;
 933         }
 934 
 935         boolean isLoadingWorkspace() {
 936             return mIsLoadingAndBindingWorkspace;
 937         }
 938 
 939         private void loadAndBindWorkspace() {
 940             mIsLoadingAndBindingWorkspace = true;
 941 
 942             // Load the workspace
 943             if (DEBUG_LOADERS) {
 944                 Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
 945             }
 946 
 947             if (!mWorkspaceLoaded) {
 948                 loadWorkspace();
 949                 synchronized (LoaderTask.this) {
 950                     if (mStopped) {
 951                         return;
 952                     }
 953                     mWorkspaceLoaded = true;
 954                 }
 955             }
 956 
 957             // Bind the workspace
 958             bindWorkspace(-1);
 959         }
 960 
 961         private void waitForIdle() {
 962             // Wait until the either we&#x27;re stopped or the other threads are done.
 963             // This way we don&#x27;t start loading all apps until the workspace has settled
 964             // down.
 965             synchronized (LoaderTask.this) {
 966                 final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
 967 
 968                 mHandler.postIdle(new Runnable() {
 969                         public void run() {
 970                             synchronized (LoaderTask.this) {
 971                                 mLoadAndBindStepFinished = true;
 972                                 if (DEBUG_LOADERS) {
 973                                     Log.d(TAG, &quot;done with previous binding step&quot;);
 974                                 }
 975                                 LoaderTask.this.notify();
 976                             }
 977                         }
 978                     });
 979 
 980                 while (!mStopped &amp;&amp; !mLoadAndBindStepFinished) {
 981                     try {
 982                         this.wait();
 983                     } catch (InterruptedException ex) {
 984                         // Ignore
 985                     }
 986                 }
 987                 if (DEBUG_LOADERS) {
 988                     Log.d(TAG, &quot;waited &quot;
 989                             + (SystemClock.uptimeMillis()-workspaceWaitTime)
 990                             + &quot;ms for previous step to finish binding&quot;);
 991                 }
 992             }
 993         }
 994 
 995         void runBindSynchronousPage(int synchronousBindPage) {
 996             if (synchronousBindPage &lt; 0) {
 997                 // Ensure that we have a valid page index to load synchronously
 998                 throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
 999                         &quot;valid page index&quot;);
1000             }
1001             if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1002                 // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1003                 // loaded already (we should load everything asynchronously in that case)
1004                 throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1005             }
1006             synchronized (mLock) {
1007                 if (mIsLoaderTaskRunning) {
1008                     // Ensure that we are never running the background loading at this point since
1009                     // we also touch the background collections
1010                     throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1011                 }
1012             }
1013 
1014             // XXX: Throw an exception if we are already loading (since we touch the worker thread
1015             //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1016             //      this call is synchronous, we can get away with not locking).
1017 
1018             // The LauncherModel is static in the LauncherApplication and mHandler may have queued
1019             // operations from the previous activity.  We need to ensure that all queued operations
1020             // are executed before any synchronous binding work is done.
1021             mHandler.flush();
1022 
1023             // Divide the set of loaded items into those that we are binding synchronously, and
1024             // everything else that is to be bound normally (asynchronously).
1025             bindWorkspace(synchronousBindPage);
1026             // XXX: For now, continue posting the binding of AllApps as there are other issues that
1027             //      arise from that.
1028             onlyBindAllApps();
1029         }
1030 
1031         public void run() {
1032             synchronized (mLock) {
1033                 mIsLoaderTaskRunning = true;
1034             }
1035             // Optimize for end-user experience: if the Launcher is up and // running with the
1036             // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1037             // workspace first (default).
1038             final Callbacks cbk = mCallbacks.get();
1039             final boolean loadWorkspaceFirst = cbk != null ? (!cbk.isAllAppsVisible()) : true;
1040 
1041             keep_running: {
1042                 // Elevate priority when Home launches for the first time to avoid
1043                 // starving at boot time. Staring at a blank home is not cool.
1044                 synchronized (mLock) {
1045                     if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1046                             (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1047                     android.os.Process.setThreadPriority(mIsLaunching
1048                             ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1049                 }
1050                 if (loadWorkspaceFirst) {
1051                     if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1052                     loadAndBindWorkspace();
1053                 } else {
1054                     if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: special: loading all apps&quot;);
1055                     loadAndBindAllApps();
1056                 }
1057 
1058                 if (mStopped) {
1059                     break keep_running;
1060                 }
1061 
1062                 // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1063                 // settled down.
1064                 synchronized (mLock) {
1065                     if (mIsLaunching) {
1066                         if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1067                         android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1068                     }
1069                 }
1070                 waitForIdle();
1071 
1072                 // second step
1073                 if (loadWorkspaceFirst) {
1074                     if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1075                     loadAndBindAllApps();
1076                 } else {
1077                     if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: special: loading workspace&quot;);
1078                     loadAndBindWorkspace();
1079                 }
1080 
1081                 // Restore the default thread priority after we are done loading items
1082                 synchronized (mLock) {
1083                     android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1084                 }
1085             }
1086 
1087 
1088             // Update the saved icons if necessary
1089             if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1090             synchronized (sBgLock) {
1091                 for (Object key : sBgDbIconCache.keySet()) {
1092                     updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
1093                 }
1094                 sBgDbIconCache.clear();
1095             }
1096 
1097             // Clear out this reference, otherwise we end up holding it until all of the
1098             // callback runnables are done.
1099             mContext = null;
1100 
1101             synchronized (mLock) {
1102                 // If we are still the last one to be scheduled, remove ourselves.
1103                 if (mLoaderTask == this) {
1104                     mLoaderTask = null;
1105                 }
1106                 mIsLoaderTaskRunning = false;
1107             }
1108         }
1109 
1110         public void stopLocked() {
1111             synchronized (LoaderTask.this) {
1112                 mStopped = true;
1113                 this.notify();
1114             }
1115         }
1116 
1117         /**
1118          * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1119          * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1120          * object that was around when the deferred message was scheduled, and if there&#x27;s
1121          * a new Callbacks object around then also return null.  This will save us from
1122          * calling onto it with data that will be ignored.
1123          */
1124         Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1125             synchronized (mLock) {
1126                 if (mStopped) {
1127                     return null;
1128                 }
1129 
1130                 if (mCallbacks == null) {
1131                     return null;
1132                 }
1133 
1134                 final Callbacks callbacks = mCallbacks.get();
1135                 if (callbacks != oldCallbacks) {
1136                     return null;
1137                 }
1138                 if (callbacks == null) {
1139                     Log.w(TAG, &quot;no mCallbacks&quot;);
1140                     return null;
1141                 }
1142 
1143                 return callbacks;
1144             }
1145         }
1146 
1147         // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1148         private boolean checkItemPlacement(ItemInfo occupied[][][], ItemInfo item) {
1149             int containerIndex = item.screen;
1150             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1151                 // Return early if we detect that an item is under the hotseat button
1152                 if (mCallbacks == null || mCallbacks.get().isAllAppsButtonRank(item.screen)) {
1153                     return false;
1154                 }
1155 
1156                 // We use the last index to refer to the hotseat and the screen as the rank, so
1157                 // test and update the occupied state accordingly
1158                 if (occupied[Launcher.SCREEN_COUNT][item.screen][0] != null) {
1159                     Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1160                         + &quot; into position (&quot; + item.screen + &quot;:&quot; + item.cellX + &quot;,&quot; + item.cellY
1161                         + &quot;) occupied by &quot; + occupied[Launcher.SCREEN_COUNT][item.screen][0]);
1162                     return false;
1163                 } else {
1164                     occupied[Launcher.SCREEN_COUNT][item.screen][0] = item;
1165                     return true;
1166                 }
1167             } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1168                 // Skip further checking if it is not the hotseat or workspace container
1169                 return true;
1170             }
1171 
1172             // Check if any workspace icons overlap with each other
1173             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1174                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1175                     if (occupied[containerIndex][x][y] != null) {
1176                         Log.e(TAG, &quot;Error loading shortcut &quot; + item
1177                             + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screen + &quot;:&quot;
1178                             + x + &quot;,&quot; + y
1179                             + &quot;) occupied by &quot;
1180                             + occupied[containerIndex][x][y]);
1181                         return false;
1182                     }
1183                 }
1184             }
1185             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1186                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1187                     occupied[containerIndex][x][y] = item;
1188                 }
1189             }
1190 
1191             return true;
1192         }
1193 
1194         private void loadWorkspace() {
1195             final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1196 
1197             final Context context = mContext;
1198             final ContentResolver contentResolver = context.getContentResolver();
1199             final PackageManager manager = context.getPackageManager();
1200             final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1201             final boolean isSafeMode = manager.isSafeMode();
1202 
1203             // Make sure the default workspace is loaded, if needed
1204             mApp.getLauncherProvider().loadDefaultFavoritesIfNecessary();
1205 
1206             synchronized (sBgLock) {
1207                 sBgWorkspaceItems.clear();
1208                 sBgAppWidgets.clear();
1209                 sBgFolders.clear();
1210                 sBgItemsIdMap.clear();
1211                 sBgDbIconCache.clear();
1212 
1213                 final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1214 
1215                 final Cursor c = contentResolver.query(
1216                         LauncherSettings.Favorites.CONTENT_URI, null, null, null, null);
1217 
1218                 // +1 for the hotseat (it can be larger than the workspace)
1219                 // Load workspace in reverse order to ensure that latest items are loaded first (and
1220                 // before any earlier duplicates)
1221                 final ItemInfo occupied[][][] =
1222                         new ItemInfo[Launcher.SCREEN_COUNT + 1][mCellCountX + 1][mCellCountY + 1];
1223 
1224                 try {
1225                     final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1226                     final int intentIndex = c.getColumnIndexOrThrow
1227                             (LauncherSettings.Favorites.INTENT);
1228                     final int titleIndex = c.getColumnIndexOrThrow
1229                             (LauncherSettings.Favorites.TITLE);
1230                     final int iconTypeIndex = c.getColumnIndexOrThrow(
1231                             LauncherSettings.Favorites.ICON_TYPE);
1232                     final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
1233                     final int iconPackageIndex = c.getColumnIndexOrThrow(
1234                             LauncherSettings.Favorites.ICON_PACKAGE);
1235                     final int iconResourceIndex = c.getColumnIndexOrThrow(
1236                             LauncherSettings.Favorites.ICON_RESOURCE);
1237                     final int containerIndex = c.getColumnIndexOrThrow(
1238                             LauncherSettings.Favorites.CONTAINER);
1239                     final int itemTypeIndex = c.getColumnIndexOrThrow(
1240                             LauncherSettings.Favorites.ITEM_TYPE);
1241                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(
1242                             LauncherSettings.Favorites.APPWIDGET_ID);
1243                     final int screenIndex = c.getColumnIndexOrThrow(
1244                             LauncherSettings.Favorites.SCREEN);
1245                     final int cellXIndex = c.getColumnIndexOrThrow
1246                             (LauncherSettings.Favorites.CELLX);
1247                     final int cellYIndex = c.getColumnIndexOrThrow
1248                             (LauncherSettings.Favorites.CELLY);
1249                     final int spanXIndex = c.getColumnIndexOrThrow
1250                             (LauncherSettings.Favorites.SPANX);
1251                     final int spanYIndex = c.getColumnIndexOrThrow(
1252                             LauncherSettings.Favorites.SPANY);
1253                     //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1254                     //final int displayModeIndex = c.getColumnIndexOrThrow(
1255                     //        LauncherSettings.Favorites.DISPLAY_MODE);
1256 
1257                     ShortcutInfo info;
1258                     String intentDescription;
1259                     LauncherAppWidgetInfo appWidgetInfo;
1260                     int container;
1261                     long id;
1262                     Intent intent;
1263 
1264                     while (!mStopped &amp;&amp; c.moveToNext()) {
1265                         try {
1266                             int itemType = c.getInt(itemTypeIndex);
1267 
1268                             switch (itemType) {
1269                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1270                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1271                                 intentDescription = c.getString(intentIndex);
1272                                 try {
1273                                     intent = Intent.parseUri(intentDescription, 0);
1274                                 } catch (URISyntaxException e) {
1275                                     continue;
1276                                 }
1277 
1278                                 if (itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
1279                                     info = getShortcutInfo(manager, intent, context, c, iconIndex,
1280                                             titleIndex, mLabelCache);
1281                                 } else {
1282                                     info = getShortcutInfo(c, context, iconTypeIndex,
1283                                             iconPackageIndex, iconResourceIndex, iconIndex,
1284                                             titleIndex);
1285 
1286                                     // App shortcuts that used to be automatically added to Launcher
1287                                     // didn&#x27;t always have the correct intent flags set, so do that
1288                                     // here
1289                                     if (intent.getAction() != null &amp;&amp;
1290                                         intent.getCategories() != null &amp;&amp;
1291                                         intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
1292                                         intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
1293                                         intent.addFlags(
1294                                             Intent.FLAG_ACTIVITY_NEW_TASK |
1295                                             Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
1296                                     }
1297                                 }
1298 
1299                                 if (info != null) {
1300                                     info.intent = intent;
1301                                     info.id = c.getLong(idIndex);
1302                                     container = c.getInt(containerIndex);
1303                                     info.container = container;
1304                                     info.screen = c.getInt(screenIndex);
1305                                     info.cellX = c.getInt(cellXIndex);
1306                                     info.cellY = c.getInt(cellYIndex);
1307 
1308                                     // check &amp; update map of what&#x27;s occupied
1309                                     if (!checkItemPlacement(occupied, info)) {
1310                                         break;
1311                                     }
1312 
1313                                     switch (container) {
1314                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
1315                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
1316                                         sBgWorkspaceItems.add(info);
1317                                         break;
1318                                     default:
1319                                         // Item is in a user folder
1320                                         FolderInfo folderInfo =
1321                                                 findOrMakeFolder(sBgFolders, container);
1322                                         folderInfo.add(info);
1323                                         break;
1324                                     }
1325                                     sBgItemsIdMap.put(info.id, info);
1326 
1327                                     // now that we&#x27;ve loaded everthing re-save it with the
1328                                     // icon in case it disappears somehow.
1329                                     queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
1330                                 } else {
1331                                     // Failed to load the shortcut, probably because the
1332                                     // activity manager couldn&#x27;t resolve it (maybe the app
1333                                     // was uninstalled), or the db row was somehow screwed up.
1334                                     // Delete it.
1335                                     id = c.getLong(idIndex);
1336                                     Log.e(TAG, &quot;Error loading shortcut &quot; + id + &quot;, removing it&quot;);
1337                                     contentResolver.delete(LauncherSettings.Favorites.getContentUri(
1338                                                 id, false), null, null);
1339                                 }
1340                                 break;
1341 
1342                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1343                                 id = c.getLong(idIndex);
1344                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
1345 
1346                                 folderInfo.title = c.getString(titleIndex);
1347                                 folderInfo.id = id;
1348                                 container = c.getInt(containerIndex);
1349                                 folderInfo.container = container;
1350                                 folderInfo.screen = c.getInt(screenIndex);
1351                                 folderInfo.cellX = c.getInt(cellXIndex);
1352                                 folderInfo.cellY = c.getInt(cellYIndex);
1353 
1354                                 // check &amp; update map of what&#x27;s occupied
1355                                 if (!checkItemPlacement(occupied, folderInfo)) {
1356                                     break;
1357                                 }
1358                                 switch (container) {
1359                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
1360                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
1361                                         sBgWorkspaceItems.add(folderInfo);
1362                                         break;
1363                                 }
1364 
1365                                 sBgItemsIdMap.put(folderInfo.id, folderInfo);
1366                                 sBgFolders.put(folderInfo.id, folderInfo);
1367                                 break;
1368 
1369                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1370                                 // Read all Launcher-specific widget details
1371                                 int appWidgetId = c.getInt(appWidgetIdIndex);
1372                                 id = c.getLong(idIndex);
1373 
1374                                 final AppWidgetProviderInfo provider =
1375                                         widgets.getAppWidgetInfo(appWidgetId);
1376 
1377                                 if (!isSafeMode &amp;&amp; (provider == null || provider.provider == null ||
1378                                         provider.provider.getPackageName() == null)) {
1379                                     String log = &quot;Deleting widget that isn&#x27;t installed anymore: id=&quot;
1380                                         + id + &quot; appWidgetId=&quot; + appWidgetId;
1381                                     Log.e(TAG, log);
1382                                     Launcher.sDumpLogs.add(log);
1383                                     itemsToRemove.add(id);
1384                                 } else {
1385                                     appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
1386                                             provider.provider);
1387                                     appWidgetInfo.id = id;
1388                                     appWidgetInfo.screen = c.getInt(screenIndex);
1389                                     appWidgetInfo.cellX = c.getInt(cellXIndex);
1390                                     appWidgetInfo.cellY = c.getInt(cellYIndex);
1391                                     appWidgetInfo.spanX = c.getInt(spanXIndex);
1392                                     appWidgetInfo.spanY = c.getInt(spanYIndex);
1393                                     int[] minSpan = Launcher.getMinSpanForWidget(context, provider);
1394                                     appWidgetInfo.minSpanX = minSpan[0];
1395                                     appWidgetInfo.minSpanY = minSpan[1];
1396 
1397                                     container = c.getInt(containerIndex);
1398                                     if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1399                                         container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1400                                         Log.e(TAG, &quot;Widget found where container != &quot; +
1401                                             &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
1402                                         continue;
1403                                     }
1404                                     appWidgetInfo.container = c.getInt(containerIndex);
1405 
1406                                     // check &amp; update map of what&#x27;s occupied
1407                                     if (!checkItemPlacement(occupied, appWidgetInfo)) {
1408                                         break;
1409                                     }
1410                                     sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
1411                                     sBgAppWidgets.add(appWidgetInfo);
1412                                 }
1413                                 break;
1414                             }
1415                         } catch (Exception e) {
1416                             Log.w(TAG, &quot;Desktop items loading interrupted:&quot;, e);
1417                         }
1418                     }
1419                 } finally {
1420                     c.close();
1421                 }
1422 
1423                 if (itemsToRemove.size() &gt; 0) {
1424                     ContentProviderClient client = contentResolver.acquireContentProviderClient(
1425                                     LauncherSettings.Favorites.CONTENT_URI);
1426                     // Remove dead items
1427                     for (long id : itemsToRemove) {
1428                         if (DEBUG_LOADERS) {
1429                             Log.d(TAG, &quot;Removed id = &quot; + id);
1430                         }
1431                         // Don&#x27;t notify content observers
1432                         try {
1433                             client.delete(LauncherSettings.Favorites.getContentUri(id, false),
1434                                     null, null);
1435                         } catch (RemoteException e) {
1436                             Log.w(TAG, &quot;Could not remove id = &quot; + id);
1437                         }
1438                     }
1439                 }
1440 
1441                 if (DEBUG_LOADERS) {
1442                     Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
1443                     Log.d(TAG, &quot;workspace layout: &quot;);
1444                     for (int y = 0; y &lt; mCellCountY; y++) {
1445                         String line = &quot;&quot;;
1446                         for (int s = 0; s &lt; Launcher.SCREEN_COUNT; s++) {
1447                             if (s &gt; 0) {
1448                                 line += &quot; | &quot;;
1449                             }
1450                             for (int x = 0; x &lt; mCellCountX; x++) {
1451                                 line += ((occupied[s][x][y] != null) ? &quot;#&quot; : &quot;.&quot;);
1452                             }
1453                         }
1454                         Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
1455                     }
1456                 }
1457             }
1458         }
1459 
1460         /** Filters the set of items who are directly or indirectly (via another container) on the
1461          * specified screen. */
1462         private void filterCurrentWorkspaceItems(int currentScreen,
1463                 ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
1464                 ArrayList&lt;ItemInfo&gt; currentScreenItems,
1465                 ArrayList&lt;ItemInfo&gt; otherScreenItems) {
1466             // Purge any null ItemInfos
1467             Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
1468             while (iter.hasNext()) {
1469                 ItemInfo i = iter.next();
1470                 if (i == null) {
1471                     iter.remove();
1472                 }
1473             }
1474 
1475             // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of
1476             // items given.
1477             if (currentScreen &lt; 0) {
1478                 currentScreenItems.addAll(allWorkspaceItems);
1479             }
1480 
1481             // Order the set of items by their containers first, this allows use to walk through the
1482             // list sequentially, build up a list of containers that are in the specified screen,
1483             // as well as all items in those containers.
1484             Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
1485             Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
1486                 @Override
1487                 public int compare(ItemInfo lhs, ItemInfo rhs) {
1488                     return (int) (lhs.container - rhs.container);
1489                 }
1490             });
1491             for (ItemInfo info : allWorkspaceItems) {
1492                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1493                     if (info.screen == currentScreen) {
1494                         currentScreenItems.add(info);
1495                         itemsOnScreen.add(info.id);
1496                     } else {
1497                         otherScreenItems.add(info);
1498                     }
1499                 } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1500                     currentScreenItems.add(info);
1501                     itemsOnScreen.add(info.id);
1502                 } else {
1503                     if (itemsOnScreen.contains(info.container)) {
1504                         currentScreenItems.add(info);
1505                         itemsOnScreen.add(info.id);
1506                     } else {
1507                         otherScreenItems.add(info);
1508                     }
1509                 }
1510             }
1511         }
1512 
1513         /** Filters the set of widgets which are on the specified screen. */
1514         private void filterCurrentAppWidgets(int currentScreen,
1515                 ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
1516                 ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
1517                 ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
1518             // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of
1519             // widgets given.
1520             if (currentScreen &lt; 0) {
1521                 currentScreenWidgets.addAll(appWidgets);
1522             }
1523 
1524             for (LauncherAppWidgetInfo widget : appWidgets) {
1525                 if (widget == null) continue;
1526                 if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1527                         widget.screen == currentScreen) {
1528                     currentScreenWidgets.add(widget);
1529                 } else {
1530                     otherScreenWidgets.add(widget);
1531                 }
1532             }
1533         }
1534 
1535         /** Filters the set of folders which are on the specified screen. */
1536         private void filterCurrentFolders(int currentScreen,
1537                 HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
1538                 HashMap&lt;Long, FolderInfo&gt; folders,
1539                 HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
1540                 HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
1541             // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of
1542             // widgets given.
1543             if (currentScreen &lt; 0) {
1544                 currentScreenFolders.putAll(folders);
1545             }
1546 
1547             for (long id : folders.keySet()) {
1548                 ItemInfo info = itemsIdMap.get(id);
1549                 FolderInfo folder = folders.get(id);
1550                 if (info == null || folder == null) continue;
1551                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1552                         info.screen == currentScreen) {
1553                     currentScreenFolders.put(id, folder);
1554                 } else {
1555                     otherScreenFolders.put(id, folder);
1556                 }
1557             }
1558         }
1559 
1560         /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
1561          * right) */
1562         private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
1563             // XXX: review this
1564             Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
1565                 @Override
1566                 public int compare(ItemInfo lhs, ItemInfo rhs) {
1567                     int cellCountX = LauncherModel.getCellCountX();
1568                     int cellCountY = LauncherModel.getCellCountY();
1569                     int screenOffset = cellCountX * cellCountY;
1570                     int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
1571                     long lr = (lhs.container * containerOffset + lhs.screen * screenOffset +
1572                             lhs.cellY * cellCountX + lhs.cellX);
1573                     long rr = (rhs.container * containerOffset + rhs.screen * screenOffset +
1574                             rhs.cellY * cellCountX + rhs.cellX);
1575                     return (int) (lr - rr);
1576                 }
1577             });
1578         }
1579 
1580         private void bindWorkspaceItems(final Callbacks oldCallbacks,
1581                 final ArrayList&lt;ItemInfo&gt; workspaceItems,
1582                 final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
1583                 final HashMap&lt;Long, FolderInfo&gt; folders,
1584                 ArrayList&lt;Runnable&gt; deferredBindRunnables) {
1585 
1586             final boolean postOnMainThread = (deferredBindRunnables != null);
1587 
1588             // Bind the workspace items
1589             int N = workspaceItems.size();
1590             for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
1591                 final int start = i;
1592                 final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
1593                 final Runnable r = new Runnable() {
1594                     @Override
1595                     public void run() {
1596                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1597                         if (callbacks != null) {
1598                             callbacks.bindItems(workspaceItems, start, start+chunkSize);
1599                         }
1600                     }
1601                 };
1602                 if (postOnMainThread) {
1603                     deferredBindRunnables.add(r);
1604                 } else {
1605                     runOnMainThread(r);
1606                 }
1607             }
1608 
1609             // Bind the folders
1610             if (!folders.isEmpty()) {
1611                 final Runnable r = new Runnable() {
1612                     public void run() {
1613                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1614                         if (callbacks != null) {
1615                             callbacks.bindFolders(folders);
1616                         }
1617                     }
1618                 };
1619                 if (postOnMainThread) {
1620                     deferredBindRunnables.add(r);
1621                 } else {
1622                     runOnMainThread(r);
1623                 }
1624             }
1625 
1626             // Bind the widgets, one at a time
1627             N = appWidgets.size();
1628             for (int i = 0; i &lt; N; i++) {
1629                 final LauncherAppWidgetInfo widget = appWidgets.get(i);
1630                 final Runnable r = new Runnable() {
1631                     public void run() {
1632                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1633                         if (callbacks != null) {
1634                             callbacks.bindAppWidget(widget);
1635                         }
1636                     }
1637                 };
1638                 if (postOnMainThread) {
1639                     deferredBindRunnables.add(r);
1640                 } else {
1641                     runOnMainThread(r);
1642                 }
1643             }
1644         }
1645 
1646         /**
1647          * Binds all loaded data to actual views on the main thread.
1648          */
1649         private void bindWorkspace(int synchronizeBindPage) {
1650             final long t = SystemClock.uptimeMillis();
1651             Runnable r;
1652 
1653             // Don&#x27;t use these two variables in any of the callback runnables.
1654             // Otherwise we hold a reference to them.
1655             final Callbacks oldCallbacks = mCallbacks.get();
1656             if (oldCallbacks == null) {
1657                 // This launcher has exited and nobody bothered to tell us.  Just bail.
1658                 Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
1659                 return;
1660             }
1661 
1662             final boolean isLoadingSynchronously = (synchronizeBindPage &gt; -1);
1663             final int currentScreen = isLoadingSynchronously ? synchronizeBindPage :
1664                 oldCallbacks.getCurrentWorkspaceScreen();
1665 
1666             // Load all the items that are on the current page first (and in the process, unbind
1667             // all the existing workspace items before we call startBinding() below.
1668             unbindWorkspaceItemsOnMainThread();
1669             ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
1670             ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
1671                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
1672             HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
1673             HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
1674             synchronized (sBgLock) {
1675                 workspaceItems.addAll(sBgWorkspaceItems);
1676                 appWidgets.addAll(sBgAppWidgets);
1677                 folders.putAll(sBgFolders);
1678                 itemsIdMap.putAll(sBgItemsIdMap);
1679             }
1680 
1681             ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
1682             ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
1683             ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
1684                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
1685             ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
1686                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
1687             HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
1688             HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
1689 
1690             // Separate the items that are on the current screen, and all the other remaining items
1691             filterCurrentWorkspaceItems(currentScreen, workspaceItems, currentWorkspaceItems,
1692                     otherWorkspaceItems);
1693             filterCurrentAppWidgets(currentScreen, appWidgets, currentAppWidgets,
1694                     otherAppWidgets);
1695             filterCurrentFolders(currentScreen, itemsIdMap, folders, currentFolders,
1696                     otherFolders);
1697             sortWorkspaceItemsSpatially(currentWorkspaceItems);
1698             sortWorkspaceItemsSpatially(otherWorkspaceItems);
1699 
1700             // Tell the workspace that we&#x27;re about to start binding items
1701             r = new Runnable() {
1702                 public void run() {
1703                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1704                     if (callbacks != null) {
1705                         callbacks.startBinding();
1706                     }
1707                 }
1708             };
1709             runOnMainThread(r);
1710 
1711             // Load items on the current page
1712             bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
1713                     currentFolders, null);
1714             if (isLoadingSynchronously) {
1715                 r = new Runnable() {
1716                     public void run() {
1717                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1718                         if (callbacks != null) {
1719                             callbacks.onPageBoundSynchronously(currentScreen);
1720                         }
1721                     }
1722                 };
1723                 runOnMainThread(r);
1724             }
1725 
1726             // Load all the remaining pages (if we are loading synchronously, we want to defer this
1727             // work until after the first render)
1728             mDeferredBindRunnables.clear();
1729             bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
1730                     (isLoadingSynchronously ? mDeferredBindRunnables : null));
1731 
1732             // Tell the workspace that we&#x27;re done binding items
1733             r = new Runnable() {
1734                 public void run() {
1735                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1736                     if (callbacks != null) {
1737                         callbacks.finishBindingItems();
1738                     }
1739 
1740                     // If we&#x27;re profiling, ensure this is the last thing in the queue.
1741                     if (DEBUG_LOADERS) {
1742                         Log.d(TAG, &quot;bound workspace in &quot;
1743                             + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
1744                     }
1745 
1746                     mIsLoadingAndBindingWorkspace = false;
1747                 }
1748             };
1749             if (isLoadingSynchronously) {
1750                 mDeferredBindRunnables.add(r);
1751             } else {
1752                 runOnMainThread(r);
1753             }
1754         }
1755 
1756         private void loadAndBindAllApps() {
1757             if (DEBUG_LOADERS) {
1758                 Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
1759             }
1760             if (!mAllAppsLoaded) {
1761                 loadAllAppsByBatch();
1762                 synchronized (LoaderTask.this) {
1763                     if (mStopped) {
1764                         return;
1765                     }
1766                     mAllAppsLoaded = true;
1767                 }
1768             } else {
1769                 onlyBindAllApps();
1770             }
1771         }
1772 
1773         private void onlyBindAllApps() {
1774             final Callbacks oldCallbacks = mCallbacks.get();
1775             if (oldCallbacks == null) {
1776                 // This launcher has exited and nobody bothered to tell us.  Just bail.
1777                 Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
1778                 return;
1779             }
1780 
1781             // shallow copy
1782             @SuppressWarnings(&quot;unchecked&quot;)
1783             final ArrayList&lt;ApplicationInfo&gt; list
1784 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1785                     = (ArrayList&lt;ApplicationInfo&gt;) mBgAllAppsList.data.clone();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1786             mHandler.post(new Runnable() {</span>
1787 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1788                     = (ArrayList&lt;ApplicationInfo&gt;) mAllAppsList.data.clone();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1789             mHandler.post(new Runnable() {</span>
1790 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1791                     = (ArrayList&lt;ApplicationInfo&gt;) mAllAppsList.data.clone();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1792             Runnable r = new Runnable() {</span>
1793 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
1794                 public void run() {
1795                     final long t = SystemClock.uptimeMillis();
1796                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1797                     if (callbacks != null) {
1798                         callbacks.bindAllApplications(list);
1799                     }
1800                     if (DEBUG_LOADERS) {
1801                         Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
1802                                 + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
1803                     }
1804                 }
1805             };
1806             boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
1807             if (oldCallbacks.isAllAppsVisible() &amp;&amp; isRunningOnMainThread) {
1808                 r.run();
1809             } else {
1810                 mHandler.post(r);
1811             }
1812         }
1813 
1814         private void loadAllAppsByBatch() {
1815             final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1816 
1817             // Don&#x27;t use these two variables in any of the callback runnables.
1818             // Otherwise we hold a reference to them.
1819             final Callbacks oldCallbacks = mCallbacks.get();
1820             if (oldCallbacks == null) {
1821                 // This launcher has exited and nobody bothered to tell us.  Just bail.
1822                 Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllAppsByBatch)&quot;);
1823                 return;
1824             }
1825 
1826             final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
1827             mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
1828 
1829             final PackageManager packageManager = mContext.getPackageManager();
1830             List&lt;ResolveInfo&gt; apps = null;
1831 
1832             int N = Integer.MAX_VALUE;
1833 
1834             int startIndex;
1835             int i=0;
1836             int batchSize = -1;
1837             while (i &lt; N &amp;&amp; !mStopped) {
1838                 if (i == 0) {
1839                     mBgAllAppsList.clear();
1840                     final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1841                     apps = packageManager.queryIntentActivities(mainIntent, 0);
1842                     if (DEBUG_LOADERS) {
1843                         Log.d(TAG, &quot;queryIntentActivities took &quot;
1844                                 + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms&quot;);
1845                     }
1846                     if (apps == null) {
1847                         return;
1848                     }
1849                     N = apps.size();
1850                     if (DEBUG_LOADERS) {
1851                         Log.d(TAG, &quot;queryIntentActivities got &quot; + N + &quot; apps&quot;);
1852                     }
1853                     if (N == 0) {
1854                         // There are no apps?!?
1855                         return;
1856                     }
1857                     if (mBatchSize == 0) {
1858                         batchSize = N;
1859                     } else {
1860                         batchSize = mBatchSize;
1861                     }
1862 
1863                     final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1864                     Collections.sort(apps,
1865                             new LauncherModel.ShortcutNameComparator(packageManager, mLabelCache));
1866                     if (DEBUG_LOADERS) {
1867                         Log.d(TAG, &quot;sort took &quot;
1868                                 + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);
1869                     }
1870                 }
1871 
1872                 final long t2 = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1873 
1874                 startIndex = i;
1875                 for (int j=0; i&lt;N &amp;&amp; j&lt;batchSize; j++) {
1876                     // This builds the icon bitmaps.
1877                     mBgAllAppsList.add(new ApplicationInfo(packageManager, apps.get(i),
1878                             mIconCache, mLabelCache));
1879                     i++;
1880                 }
1881 
1882                 final boolean first = i &lt;= batchSize;
1883                 final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1884                 final ArrayList&lt;ApplicationInfo&gt; added = mBgAllAppsList.added;
1885                 mBgAllAppsList.added = new ArrayList&lt;ApplicationInfo&gt;();
1886 
1887                 mHandler.post(new Runnable() {
1888                     public void run() {
1889                         final long t = SystemClock.uptimeMillis();
1890                         if (callbacks != null) {
1891                             if (first) {
1892                                 callbacks.bindAllApplications(added);
1893                             } else {
1894                                 callbacks.bindAppsAdded(added);
1895                             }
1896                             if (DEBUG_LOADERS) {
1897                                 Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
1898                                     + (SystemClock.uptimeMillis() - t) + &quot;ms&quot;);
1899                             }
1900                         } else {
1901                             Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
1902                         }
1903                     }
1904                 });
1905 
1906                 if (DEBUG_LOADERS) {
1907                     Log.d(TAG, &quot;batch of &quot; + (i-startIndex) + &quot; icons processed in &quot;
1908                             + (SystemClock.uptimeMillis()-t2) + &quot;ms&quot;);
1909                 }
1910 
1911                 if (mAllAppsLoadDelay &gt; 0 &amp;&amp; i &lt; N) {
1912                     try {
1913                         if (DEBUG_LOADERS) {
1914                             Log.d(TAG, &quot;sleeping for &quot; + mAllAppsLoadDelay + &quot;ms&quot;);
1915                         }
1916                         Thread.sleep(mAllAppsLoadDelay);
1917                     } catch (InterruptedException exc) { }
1918                 }
1919             }
1920 
1921             if (DEBUG_LOADERS) {
1922                 Log.d(TAG, &quot;cached all &quot; + N + &quot; apps in &quot;
1923                         + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;
1924                         + (mAllAppsLoadDelay &gt; 0 ? &quot; (including delay)&quot; : &quot;&quot;));
1925             }
1926         }
1927 
1928         public void dumpState() {
1929             synchronized (sBgLock) {
1930                 Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
1931                 Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
1932                 Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
1933                 Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
1934                 Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
1935             }
1936         }
1937     }
1938 
1939     void enqueuePackageUpdated(PackageUpdatedTask task) {
1940         sWorker.post(task);
1941     }
1942 
1943     private class PackageUpdatedTask implements Runnable {
1944         int mOp;
1945         String[] mPackages;
1946 
1947         public static final int OP_NONE = 0;
1948         public static final int OP_ADD = 1;
1949         public static final int OP_UPDATE = 2;
1950         public static final int OP_REMOVE = 3; // uninstlled
1951         public static final int OP_UNAVAILABLE = 4; // external media unmounted
1952 
1953 
1954         public PackageUpdatedTask(int op, String[] packages) {
1955             mOp = op;
1956             mPackages = packages;
1957         }
1958 
1959         public void run() {
1960             final Context context = mApp;
1961 
1962             final String[] packages = mPackages;
1963             final int N = packages.length;
1964             switch (mOp) {
1965                 case OP_ADD:
1966                     for (int i=0; i&lt;N; i++) {
1967                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
1968                         mBgAllAppsList.addPackage(context, packages[i]);
1969                     }
1970                     break;
1971                 case OP_UPDATE:
1972                     for (int i=0; i&lt;N; i++) {
1973                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
1974                         mBgAllAppsList.updatePackage(context, packages[i]);
1975                     }
1976                     break;
1977                 case OP_REMOVE:
1978                 case OP_UNAVAILABLE:
1979                     for (int i=0; i&lt;N; i++) {
1980                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
1981                         mBgAllAppsList.removePackage(packages[i]);
1982                     }
1983                     break;
1984             }
1985 
1986             ArrayList&lt;ApplicationInfo&gt; added = null;
1987             ArrayList&lt;ApplicationInfo&gt; modified = null;
1988 
1989             if (mBgAllAppsList.added.size() &gt; 0) {
1990                 added = new ArrayList&lt;ApplicationInfo&gt;(mBgAllAppsList.added);
1991                 mBgAllAppsList.added.clear();
1992             }
1993             if (mBgAllAppsList.modified.size() &gt; 0) {
1994                 modified = new ArrayList&lt;ApplicationInfo&gt;(mBgAllAppsList.modified);
1995                 mBgAllAppsList.modified.clear();
1996                 }
1997             // We may be removing packages that have no associated launcher application, so we
1998             // pass through the removed package names directly.
1999             // NOTE: We flush the icon cache aggressively in removePackage() above.
2000             final ArrayList&lt;String&gt; removedPackageNames = new ArrayList&lt;String&gt;();
2001             if (mBgAllAppsList.removed.size() &gt; 0) {
2002                 mBgAllAppsList.removed.clear();
2003 
2004                 for (int i = 0; i &lt; N; ++i) {
2005                     removedPackageNames.add(packages[i]);
2006             }
2007             }
2008 
2009             final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
2010             if (callbacks == null) {
2011                 Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
2012                 return;
2013             }
2014 
2015             if (added != null) {
2016                 final ArrayList&lt;ApplicationInfo&gt; addedFinal = added;
2017                 mHandler.post(new Runnable() {
2018                     public void run() {
2019                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2020                         if (callbacks == cb &amp;&amp; cb != null) {
2021                             callbacks.bindAppsAdded(addedFinal);
2022                         }
2023                     }
2024                 });
2025             }
2026             if (modified != null) {
2027                 final ArrayList&lt;ApplicationInfo&gt; modifiedFinal = modified;
2028                 mHandler.post(new Runnable() {
2029                     public void run() {
2030                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2031                         if (callbacks == cb &amp;&amp; cb != null) {
2032                             callbacks.bindAppsUpdated(modifiedFinal);
2033                         }
2034                     }
2035                 });
2036             }
2037             if (!removedPackageNames.isEmpty()) {
2038                 final boolean permanent = mOp != OP_UNAVAILABLE;
2039                 mHandler.post(new Runnable() {
2040                     public void run() {
2041                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2042                         if (callbacks == cb &amp;&amp; cb != null) {
2043                             callbacks.bindAppsRemoved(removedPackageNames, permanent);
2044                         }
2045                     }
2046                 });
2047             }
2048 
2049             mHandler.post(new Runnable() {
2050                 @Override
2051                 public void run() {
2052                     Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2053                     if (callbacks == cb &amp;&amp; cb != null) {
2054                         callbacks.bindPackagesUpdated();
2055                     }
2056                 }
2057             });
2058         }
2059     }
2060 
2061     /**
2062      * This is called from the code that adds shortcuts from the intent receiver.  This
2063      * doesn&#x27;t have a Cursor, but
2064      */
2065     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context) {
2066         return getShortcutInfo(manager, intent, context, null, -1, -1, null);
2067     }
2068 
2069     /**
2070      * Make an ShortcutInfo object for a shortcut that is an application.
2071      *
2072      * If c is not null, then it will be used to fill in missing data like the title and icon.
2073      */
2074     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context,
2075             Cursor c, int iconIndex, int titleIndex, HashMap&lt;Object, CharSequence&gt; labelCache) {
2076         Bitmap icon = null;
2077         final ShortcutInfo info = new ShortcutInfo();
2078 
2079         ComponentName componentName = intent.getComponent();
2080         if (componentName == null) {
2081             return null;
2082         }
2083 
2084         try {
2085             PackageInfo pi = manager.getPackageInfo(componentName.getPackageName(), 0);
2086             if (!pi.applicationInfo.enabled) {
2087                 // If we return null here, the corresponding item will be removed from the launcher
2088                 // db and will not appear in the workspace.
2089                 return null;
2090             }
2091         } catch (NameNotFoundException e) {
2092             Log.d(TAG, &quot;getPackInfo failed for package &quot; + componentName.getPackageName());
2093         }
2094 
2095         // TODO: See if the PackageManager knows about this case.  If it doesn&#x27;t
2096         // then return null &amp; delete this.
2097 
2098         // the resource -- This may implicitly give us back the fallback icon,
2099         // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
2100         // to avoid saving lots of copies of that in the database, and most apps
2101         // have icons anyway.
2102 
2103         // Attempt to use queryIntentActivities to get the ResolveInfo (with IntentFilter info) and
2104         // if that fails, or is ambiguious, fallback to the standard way of getting the resolve info
2105         // via resolveActivity().
2106         ResolveInfo resolveInfo = null;
2107         ComponentName oldComponent = intent.getComponent();
2108         Intent newIntent = new Intent(intent.getAction(), null);
2109         newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2110         newIntent.setPackage(oldComponent.getPackageName());
2111         List&lt;ResolveInfo&gt; infos = manager.queryIntentActivities(newIntent, 0);
2112         for (ResolveInfo i : infos) {
2113             ComponentName cn = new ComponentName(i.activityInfo.packageName,
2114                     i.activityInfo.name);
2115             if (cn.equals(oldComponent)) {
2116                 resolveInfo = i;
2117             }
2118         }
2119         if (resolveInfo == null) {
2120             resolveInfo = manager.resolveActivity(intent, 0);
2121         }
2122         if (resolveInfo != null) {
2123             icon = mIconCache.getIcon(componentName, resolveInfo, labelCache);
2124         }
2125         // the db
2126         if (icon == null) {
2127             if (c != null) {
2128                 icon = getIconFromCursor(c, iconIndex, context);
2129             }
2130         }
2131         // the fallback icon
2132         if (icon == null) {
2133             icon = getFallbackIcon();
2134             info.usingFallbackIcon = true;
2135         }
2136         info.setIcon(icon);
2137 
2138         // from the resource
2139         if (resolveInfo != null) {
2140             ComponentName key = LauncherModel.getComponentNameFromResolveInfo(resolveInfo);
2141             if (labelCache != null &amp;&amp; labelCache.containsKey(key)) {
2142                 info.title = labelCache.get(key);
2143             } else {
2144                 info.title = resolveInfo.activityInfo.loadLabel(manager);
2145                 if (labelCache != null) {
2146                     labelCache.put(key, info.title);
2147                 }
2148             }
2149         }
2150         // from the db
2151         if (info.title == null) {
2152             if (c != null) {
2153                 info.title =  c.getString(titleIndex);
2154             }
2155         }
2156         // fall back to the class name of the activity
2157         if (info.title == null) {
2158             info.title = componentName.getClassName();
2159         }
2160         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
2161         return info;
2162     }
2163 
2164     /**
2165      * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
2166      */
2167     private ShortcutInfo getShortcutInfo(Cursor c, Context context,
2168             int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
2169             int titleIndex) {
2170 
2171         Bitmap icon = null;
2172         final ShortcutInfo info = new ShortcutInfo();
2173         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
2174 
2175         // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
2176 
2177         info.title = c.getString(titleIndex);
2178 
2179         int iconType = c.getInt(iconTypeIndex);
2180         switch (iconType) {
2181         case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
2182             String packageName = c.getString(iconPackageIndex);
2183             String resourceName = c.getString(iconResourceIndex);
2184             PackageManager packageManager = context.getPackageManager();
2185             info.customIcon = false;
2186             // the resource
2187             try {
2188                 Resources resources = packageManager.getResourcesForApplication(packageName);
2189                 if (resources != null) {
2190                     final int id = resources.getIdentifier(resourceName, null, null);
2191                     icon = Utilities.createIconBitmap(
2192                             mIconCache.getFullResIcon(resources, id), context);
2193                 }
2194             } catch (Exception e) {
2195                 // drop this.  we have other places to look for icons
2196             }
2197             // the db
2198             if (icon == null) {
2199                 icon = getIconFromCursor(c, iconIndex, context);
2200             }
2201             // the fallback icon
2202             if (icon == null) {
2203                 icon = getFallbackIcon();
2204                 info.usingFallbackIcon = true;
2205             }
2206             break;
2207         case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
2208             icon = getIconFromCursor(c, iconIndex, context);
2209             if (icon == null) {
2210                 icon = getFallbackIcon();
2211                 info.customIcon = false;
2212                 info.usingFallbackIcon = true;
2213             } else {
2214                 info.customIcon = true;
2215             }
2216             break;
2217         default:
2218             icon = getFallbackIcon();
2219             info.usingFallbackIcon = true;
2220             info.customIcon = false;
2221             break;
2222         }
2223         info.setIcon(icon);
2224         return info;
2225     }
2226 
2227     Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
2228         @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
2229         final boolean debug = false;
2230         if (debug) {
2231             Log.d(TAG, &quot;getIconFromCursor app=&quot;
2232                     + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
2233         }
2234         byte[] data = c.getBlob(iconIndex);
2235         try {
2236             return Utilities.createIconBitmap(
2237                     BitmapFactory.decodeByteArray(data, 0, data.length), context);
2238         } catch (Exception e) {
2239             return null;
2240         }
2241     }
2242 
2243     ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
2244             int cellX, int cellY, boolean notify) {
2245         final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
2246         if (info == null) {
2247             return null;
2248         }
2249         addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
2250 
2251         return info;
2252     }
2253 
2254     /**
2255      * Attempts to find an AppWidgetProviderInfo that matches the given component.
2256      */
2257     AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,
2258             ComponentName component) {
2259         List&lt;AppWidgetProviderInfo&gt; widgets =
2260             AppWidgetManager.getInstance(context).getInstalledProviders();
2261         for (AppWidgetProviderInfo info : widgets) {
2262             if (info.provider.equals(component)) {
2263                 return info;
2264             }
2265         }
2266         return null;
2267     }
2268 
2269     /**
2270      * Returns a list of all the widgets that can handle configuration with a particular mimeType.
2271      */
2272     List&lt;WidgetMimeTypeHandlerData&gt; resolveWidgetsForMimeType(Context context, String mimeType) {
2273         final PackageManager packageManager = context.getPackageManager();
2274         final List&lt;WidgetMimeTypeHandlerData&gt; supportedConfigurationActivities =
2275             new ArrayList&lt;WidgetMimeTypeHandlerData&gt;();
2276 
2277         final Intent supportsIntent =
2278             new Intent(InstallWidgetReceiver.ACTION_SUPPORTS_CLIPDATA_MIMETYPE);
2279         supportsIntent.setType(mimeType);
2280 
2281         // Create a set of widget configuration components that we can test against
2282         final List&lt;AppWidgetProviderInfo&gt; widgets =
2283             AppWidgetManager.getInstance(context).getInstalledProviders();
2284         final HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; configurationComponentToWidget =
2285             new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;();
2286         for (AppWidgetProviderInfo info : widgets) {
2287             configurationComponentToWidget.put(info.configure, info);
2288         }
2289 
2290         // Run through each of the intents that can handle this type of clip data, and cross
2291         // reference them with the components that are actual configuration components
2292         final List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(supportsIntent,
2293                 PackageManager.MATCH_DEFAULT_ONLY);
2294         for (ResolveInfo info : activities) {
2295             final ActivityInfo activityInfo = info.activityInfo;
2296             final ComponentName infoComponent = new ComponentName(activityInfo.packageName,
2297                     activityInfo.name);
2298             if (configurationComponentToWidget.containsKey(infoComponent)) {
2299                 supportedConfigurationActivities.add(
2300                         new InstallWidgetReceiver.WidgetMimeTypeHandlerData(info,
2301                                 configurationComponentToWidget.get(infoComponent)));
2302             }
2303         }
2304         return supportedConfigurationActivities;
2305     }
2306 
2307     ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
2308         Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
2309         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
2310         Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
2311 
2312         if (intent == null) {
2313             // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
2314             Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
2315             return null;
2316         }
2317 
2318         Bitmap icon = null;
2319         boolean customIcon = false;
2320         ShortcutIconResource iconResource = null;
2321 
2322         if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {
2323             icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);
2324             customIcon = true;
2325         } else {
2326             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
2327             if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {
2328                 try {
2329                     iconResource = (ShortcutIconResource) extra;
2330                     final PackageManager packageManager = context.getPackageManager();
2331                     Resources resources = packageManager.getResourcesForApplication(
2332                             iconResource.packageName);
2333                     final int id = resources.getIdentifier(iconResource.resourceName, null, null);
2334                     icon = Utilities.createIconBitmap(
2335                             mIconCache.getFullResIcon(resources, id), context);
2336                 } catch (Exception e) {
2337                     Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);
2338                 }
2339             }
2340         }
2341 
2342         final ShortcutInfo info = new ShortcutInfo();
2343 
2344         if (icon == null) {
2345             if (fallbackIcon != null) {
2346                 icon = fallbackIcon;
2347             } else {
2348                 icon = getFallbackIcon();
2349                 info.usingFallbackIcon = true;
2350             }
2351         }
2352         info.setIcon(icon);
2353 
2354         info.title = name;
2355         info.intent = intent;
2356         info.customIcon = customIcon;
2357         info.iconResource = iconResource;
2358 
2359         return info;
2360     }
2361 
2362     boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
2363             int iconIndex) {
2364         // If apps can&#x27;t be on SD, don&#x27;t even bother.
2365         if (!mAppsCanBeOnExternalStorage) {
2366             return false;
2367         }
2368         // If this icon doesn&#x27;t have a custom icon, check to see
2369         // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
2370         // we&#x27;re going to show, store what we are going to show back
2371         // into the DB.  We do this so when we&#x27;re loading, if the
2372         // package manager can&#x27;t find an icon (for example because
2373         // the app is on SD) then we can use that instead.
2374         if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
2375             cache.put(info, c.getBlob(iconIndex));
2376             return true;
2377         }
2378         return false;
2379     }
2380     void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
2381         boolean needSave = false;
2382         try {
2383             if (data != null) {
2384                 Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
2385                 Bitmap loaded = info.getIcon(mIconCache);
2386                 needSave = !saved.sameAs(loaded);
2387             } else {
2388                 needSave = true;
2389             }
2390         } catch (Exception e) {
2391             needSave = true;
2392         }
2393         if (needSave) {
2394             Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
2395             // This is slower than is ideal, but this only happens once
2396             // or when the app is updated with a new icon.
2397             updateItemInDatabase(context, info);
2398         }
2399     }
2400 
2401     /**
2402      * Return an existing FolderInfo object if we have encountered this ID previously,
2403      * or make a new one.
2404      */
2405     private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
2406         // See if a placeholder was created for us already
2407         FolderInfo folderInfo = folders.get(id);
2408         if (folderInfo == null) {
2409             // No placeholder -- create a new instance
2410             folderInfo = new FolderInfo();
2411             folders.put(id, folderInfo);
2412         }
2413         return folderInfo;
2414     }
2415 
2416     private static final Collator sCollator = Collator.getInstance();
2417     public static final Comparator&lt;ApplicationInfo&gt; APP_NAME_COMPARATOR
2418             = new Comparator&lt;ApplicationInfo&gt;() {
2419         public final int compare(ApplicationInfo a, ApplicationInfo b) {
2420             int result = sCollator.compare(a.title.toString(), b.title.toString());
2421             if (result == 0) {
2422                 result = a.componentName.compareTo(b.componentName);
2423             }
2424             return result;
2425         }
2426     };
2427     public static final Comparator&lt;ApplicationInfo&gt; APP_INSTALL_TIME_COMPARATOR
2428             = new Comparator&lt;ApplicationInfo&gt;() {
2429         public final int compare(ApplicationInfo a, ApplicationInfo b) {
2430             if (a.firstInstallTime &lt; b.firstInstallTime) return 1;
2431             if (a.firstInstallTime &gt; b.firstInstallTime) return -1;
2432             return 0;
2433         }
2434     };
2435     public static final Comparator&lt;AppWidgetProviderInfo&gt; WIDGET_NAME_COMPARATOR
2436             = new Comparator&lt;AppWidgetProviderInfo&gt;() {
2437         public final int compare(AppWidgetProviderInfo a, AppWidgetProviderInfo b) {
2438             return sCollator.compare(a.label.toString(), b.label.toString());
2439         }
2440     };
2441     static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
2442         if (info.activityInfo != null) {
2443             return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
2444         } else {
2445             return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
2446         }
2447     }
2448     public static class ShortcutNameComparator implements Comparator&lt;ResolveInfo&gt; {
2449         private PackageManager mPackageManager;
2450         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
2451         ShortcutNameComparator(PackageManager pm) {
2452             mPackageManager = pm;
2453             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
2454         }
2455         ShortcutNameComparator(PackageManager pm, HashMap&lt;Object, CharSequence&gt; labelCache) {
2456             mPackageManager = pm;
2457             mLabelCache = labelCache;
2458         }
2459         public final int compare(ResolveInfo a, ResolveInfo b) {
2460             CharSequence labelA, labelB;
2461             ComponentName keyA = LauncherModel.getComponentNameFromResolveInfo(a);
2462             ComponentName keyB = LauncherModel.getComponentNameFromResolveInfo(b);
2463             if (mLabelCache.containsKey(keyA)) {
2464                 labelA = mLabelCache.get(keyA);
2465             } else {
2466                 labelA = a.loadLabel(mPackageManager).toString();
2467 
2468                 mLabelCache.put(keyA, labelA);
2469             }
2470             if (mLabelCache.containsKey(keyB)) {
2471                 labelB = mLabelCache.get(keyB);
2472             } else {
2473                 labelB = b.loadLabel(mPackageManager).toString();
2474 
2475                 mLabelCache.put(keyB, labelB);
2476             }
2477             return sCollator.compare(labelA, labelB);
2478         }
2479     }
2480     public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
2481         private PackageManager mPackageManager;
2482         private HashMap&lt;Object, String&gt; mLabelCache;
2483         WidgetAndShortcutNameComparator(PackageManager pm) {
2484             mPackageManager = pm;
2485             mLabelCache = new HashMap&lt;Object, String&gt;();
2486         }
2487         public final int compare(Object a, Object b) {
2488             String labelA, labelB;
2489             if (mLabelCache.containsKey(a)) {
2490                 labelA = mLabelCache.get(a);
2491             } else {
2492                 labelA = (a instanceof AppWidgetProviderInfo) ?
2493                     ((AppWidgetProviderInfo) a).label :
2494                     ((ResolveInfo) a).loadLabel(mPackageManager).toString();
2495                 mLabelCache.put(a, labelA);
2496             }
2497             if (mLabelCache.containsKey(b)) {
2498                 labelB = mLabelCache.get(b);
2499             } else {
2500                 labelB = (b instanceof AppWidgetProviderInfo) ?
2501                     ((AppWidgetProviderInfo) b).label :
2502                     ((ResolveInfo) b).loadLabel(mPackageManager).toString();
2503                 mLabelCache.put(b, labelB);
2504             }
2505             return sCollator.compare(labelA, labelB);
2506         }
2507     }
2508 
2509     public void dumpState() {
2510         Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
2511         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
2512         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
2513         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
2514         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
2515         if (mLoaderTask != null) {
2516             mLoaderTask.dumpState();
2517         } else {
2518             Log.d(TAG, &quot;mLoaderTask=null&quot;);
2519         }
2520     }
2521 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher2;
  17 
  18 import android.app.SearchManager;
  19 import android.appwidget.AppWidgetManager;
  20 import android.appwidget.AppWidgetProviderInfo;
  21 import android.content.BroadcastReceiver;
  22 import android.content.ComponentName;
  23 import android.content.ContentProviderClient;
  24 import android.content.ContentResolver;
  25 import android.content.ContentValues;
  26 import android.content.Context;
  27 import android.content.Intent.ShortcutIconResource;
  28 import android.content.Intent;
  29 import android.content.pm.ActivityInfo;
  30 import android.content.pm.PackageInfo;
  31 import android.content.pm.PackageManager.NameNotFoundException;
  32 import android.content.pm.PackageManager;
  33 import android.content.pm.ResolveInfo;
  34 import android.content.res.Configuration;
  35 import android.content.res.Resources;
  36 import android.database.Cursor;
  37 import android.graphics.Bitmap;
  38 import android.graphics.BitmapFactory;
  39 import android.net.Uri;
  40 import android.os.Environment;
  41 import android.os.Handler;
  42 import android.os.HandlerThread;
  43 import android.os.Parcelable;
  44 import android.os.Process;
  45 import android.os.RemoteException;
  46 import android.os.SystemClock;
  47 import android.util.Log;
  48 import com.android.launcher.R;
  49 import com.android.launcher2.InstallWidgetReceiver.WidgetMimeTypeHandlerData;
  50 import java.lang.ref.WeakReference;
  51 import java.net.URISyntaxException;
  52 import java.text.Collator;
  53 import java.util.ArrayList;
  54 import java.util.Collections;
  55 import java.util.Comparator;
  56 import java.util.HashMap;
  57 import java.util.HashSet;
  58 import java.util.Iterator;
  59 import java.util.List;
  60 import java.util.Set;
  61 
  62 
  63 /**
  64  * Maintains in-memory state of the Launcher. It is expected that there should be only one
  65  * LauncherModel object held in a static. Also provide APIs for updating the database state
  66  * for the Launcher.
  67  */
  68 public class LauncherModel extends BroadcastReceiver {
  69     static final boolean DEBUG_LOADERS = false;
  70 
  71     static final String TAG = &quot;Launcher.Model&quot;;
  72 
  73     // batch size for the workspace icons
  74     private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
  75 
  76     private final boolean mAppsCanBeOnExternalStorage;
  77 
  78     // 0 is all apps at once
  79     private int mBatchSize; // 0 is all apps at once
  80 
  81     // milliseconds between batches
  82     private int mAllAppsLoadDelay; // milliseconds between batches
  83 
  84     private final LauncherApplication mApp;
  85 
  86     private final Object mLock = new Object();
  87 
  88     private DeferredHandler mHandler = new DeferredHandler();
  89 
  90     private LoaderTask mLoaderTask;
  91 
  92     private boolean mIsLoaderTaskRunning;
  93 
  94     private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
  95 
  96     static {
  97         sWorkerThread.start();
  98     }
  99 
 100     private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
 101 
 102     // We start off with everything not loaded.  After that, we assume that
 103     // our monitoring of the package manager provides all updates and we never
 104     // need to do a requery.  These are only ever touched from the loader thread.
 105     private boolean mWorkspaceLoaded;
 106 
 107     private boolean mAllAppsLoaded;
 108 
 109     // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
 110     // pages as this delays the rotation process.  Instead, we wait for a callback from the first
 111     // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 112     // a normal load, we also clear this set of Runnables.
 113     static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 114 
 115     private WeakReference&lt;Callbacks&gt; mCallbacks;
 116 
 117     // &lt; only access in worker thread &gt;
 118     private AllAppsList mBgAllAppsList;
 119 
 120     // The lock that must be acquired before referencing any static bg data structures.  Unlike
 121     // other locks, this one can generally be held long-term because we never expect any of these
 122     // static data structures to be referenced outside of the worker thread except on the first
 123     // load after configuration change.
 124     static final Object sBgLock = new Object();
 125 
 126     // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 127     // LauncherModel to their ids
 128     static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
 129 
 130     // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 131     // created by LauncherModel that are directly on the home screen (however, no widgets or
 132     // shortcuts within folders).
 133     static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 134 
 135     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 136     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 137     static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 138         new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 139 
 140     // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 141     static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 142 
 143     // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 144     static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 145 
 146     // &lt;/ only access in worker thread &gt;
 147     // &lt;/ only access in worker thread &gt;
 148 
 149     private IconCache mIconCache;
 150 
 151     private Bitmap mDefaultIcon;
 152 
 153     private static int mCellCountX;
 154 
 155     private static int mCellCountY;
 156 
 157     protected int mPreviousConfigMcc;
 158 
 159     public interface Callbacks {
 160         public boolean setLoadOnResume();
 161 
 162         public int getCurrentWorkspaceScreen();
 163 
 164         public void startBinding();
 165 
 166         public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end);
 167 
 168         public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 169 
 170         public void finishBindingItems();
 171 
 172         public void bindAppWidget(LauncherAppWidgetInfo info);
 173 
 174         public void bindAllApplications(ArrayList&lt;ApplicationInfo&gt; apps);
 175 
 176         public void bindAppsAdded(ArrayList&lt;ApplicationInfo&gt; apps);
 177 
 178         public void bindAppsUpdated(ArrayList&lt;ApplicationInfo&gt; apps);
 179 
 180         public abstract void bindAppsRemoved(ArrayList&lt;String&gt; packageNames, boolean permanent);
 181 
 182         public void bindPackagesUpdated();
 183 
 184         public boolean isAllAppsVisible();
 185 
 186         public boolean isAllAppsButtonRank(int rank);
 187 
 188         public void bindSearchablesChanged();
 189 
 190         public void onPageBoundSynchronously(int page);
 191     }
 192 
 193     LauncherModel(LauncherApplication app, IconCache iconCache) {
 194         mAppsCanBeOnExternalStorage = !Environment.isExternalStorageEmulated();
 195         mApp = app;
 196         mBgAllAppsList = new AllAppsList(iconCache);
 197         mIconCache = iconCache;
 198         mDefaultIcon = Utilities.createIconBitmap(mIconCache.getFullResDefaultActivityIcon(), app);
 199         final Resources res = app.getResources();
 200         mAllAppsLoadDelay = res.getInteger(R.integer.config_allAppsBatchLoadDelay);
 201         mBatchSize = res.getInteger(R.integer.config_allAppsBatchSize);
 202         Configuration config = res.getConfiguration();
 203         mPreviousConfigMcc = config.mcc;
 204     }
 205 
 206     /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 207      * posted on the main thread handler. */
 208     private void runOnMainThread(Runnable r) {
 209         if (sWorkerThread.getThreadId() == Process.myTid()) {
 210             // If we are on the worker thread, post onto the main handler
 211             mHandler.post(r);
 212         } else {
 213             r.run();
 214         }
 215     }
 216 
 217     /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 218      * posted on the worker thread handler. */
 219     private static void runOnWorkerThread(Runnable r) {
 220         if (sWorkerThread.getThreadId() == Process.myTid()) {
 221             r.run();
 222         } else {
 223             // If we are not on the worker thread, then post to the worker handler
 224             sWorker.post(r);
 225         }
 226     }
 227 
 228     public Bitmap getFallbackIcon() {
 229         return Bitmap.createBitmap(mDefaultIcon);
 230     }
 231 
 232     public void unbindWorkspaceItems() {
 233         sWorker.post(new Runnable() {
 234             @Override
 235             public void run() {
 236                 unbindWorkspaceItemsOnMainThread();
 237             }
 238         });
 239     }
 240 
 241     /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 242     private void unbindWorkspaceItemsOnMainThread() {
 243         // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 244         // by making a copy of workspace items first.
 245         final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 246         final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 247         synchronized (sBgLock) {
 248             tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 249             tmpAppWidgets.addAll(sBgAppWidgets);
 250         }
 251         Runnable r = new Runnable() {
 252                 @Override
 253                 public void run() {
 254                    for (ItemInfo item : tmpWorkspaceItems) {
 255                        item.unbind();
 256                    }
 257                    for (ItemInfo item : tmpAppWidgets) {
 258                        item.unbind();
 259                    }
 260                 }
 261             };
 262         runOnMainThread(r);
 263     }
 264 
 265     /**
 266      * Adds an item to the DB if it was not created previously, or move it to a new
 267      * &lt;container, screen, cellX, cellY&gt;
 268      */
 269     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 270             int screen, int cellX, int cellY) {
 271         if (item.container == ItemInfo.NO_ID) {
 272             // From all apps
 273             addItemToDatabase(context, item, container, screen, cellX, cellY, false);
 274         } else {
 275             // From somewhere else
 276             moveItemInDatabase(context, item, container, screen, cellX, cellY);
 277         }
 278     }
 279 
 280     static void checkItemInfo(final ItemInfo item) {
 281         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 282         final long itemId = item.id;
 283         Runnable r = new Runnable() {
 284             public void run() {
 285                 synchronized(sBgLock) {
 286                     ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 287                     if ((modelItem != null) &amp;&amp; (item != modelItem)) {
 288                         // the modelItem needs to match up perfectly with item if our model is
 289                         // to be consistent with the database-- for now, just require
 290                         // modelItem == item
<abbr title=" 291                         String msg = (((&quot;item: &quot; + (item != null ? item.toString() : &quot;null&quot;)) + &quot;modelItem: &quot;) + (modelItem != null ? modelItem.toString() : &quot;null&quot;)) + &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;"> 291                         String msg = (((&quot;item: &quot; + (item != null ? item.toString() : &quot;null&quot;)) + &quot;modelIteðŸ”µ</abbr>
 292                         RuntimeException e = new RuntimeException(msg);
 293                         e.setStackTrace(stackTrace);
 294                         throw e;
 295                     }
 296                 }
 297             }
 298         };
 299         runOnWorkerThread(r);
 300     }
 301 
<abbr title=" 302     static void updateItemInDatabaseHelper(Context context, final ContentValues values, final ItemInfo item, final String callingFunction) {"> 302     static void updateItemInDatabaseHelper(Context context, final ContentValues values, final ItemInfo itðŸ”µ</abbr>
 303         final long itemId = item.id;
 304         final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 305         final ContentResolver cr = context.getContentResolver();
 306         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 307         Runnable r = new Runnable() {
 308             public void run() {
 309                 cr.update(uri, values, null, null);
 310                 // Lock on mBgLock *after* the db operation
 311                 synchronized(sBgLock) {
 312                     ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 313                     if (item != modelItem) {
 314                         // the modelItem needs to match up perfectly with item if our model is to be
 315                         // consistent with the database-- for now, just require modelItem == item
<abbr title=" 316                         String msg = ((((((&quot;item: &quot; + (item != null ? item.toString() : &quot;null&quot;)) + &quot;modelItem: &quot;) + (modelItem != null ? modelItem.toString() : &quot;null&quot;)) + &quot;Error: ItemInfo passed to &quot;) + callingFunction) + &quot; doesn&#x27;t match &quot;) + &quot;original&quot;;"> 316                         String msg = ((((((&quot;item: &quot; + (item != null ? item.toString() : &quot;null&quot;)) + &quot;modelðŸ”µ</abbr>
 317                         throw new RuntimeException(msg);
 318                     }
<abbr title=" 319                     if ((item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {"> 319                     if ((item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (item.containðŸ”µ</abbr>
 320                         // Item is in a folder, make sure this folder exists
 321                         if (!sBgFolders.containsKey(item.container)) {
 322                             // An items container is being set to a that of an item which is not in
 323                             // the list of Folders.
<abbr title=" 324                             String msg = (((&quot;item: &quot; + item) + &quot; container being set to: &quot;) + item.container) + &quot;, not in the list of folders&quot;;"> 324                             String msg = (((&quot;item: &quot; + item) + &quot; container being set to: &quot;) + item.contaiðŸ”µ</abbr>
 325                             RuntimeException e = new RuntimeException(msg);
 326                             e.setStackTrace(stackTrace);
 327                             Launcher.dumpDebugLogsToConsole();
 328                             throw e;
 329                         }
 330                     }
 331                     // Items are added/removed from the corresponding FolderInfo elsewhere, such
 332                     // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 333                     // that are on the desktop, as appropriate
<abbr title=" 334                     if ((modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) || (modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {"> 334                     if ((modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) || (modelItðŸ”µ</abbr>
 335                         switch (modelItem.itemType) {
 336                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION :
 337                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT :
 338                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER :
 339                                 if (!sBgWorkspaceItems.contains(modelItem)) {
 340                                     sBgWorkspaceItems.add(modelItem);
 341                                 }
 342                                 break;
 343                             default :
 344                                 break;
 345                         }
 346                     } else {
 347                         sBgWorkspaceItems.remove(modelItem);
 348                     }
 349                 }
 350             }
 351         };
 352         runOnWorkerThread(r);
 353     }
 354 
 355     /**
 356      * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 357      */
<abbr title=" 358     static void moveItemInDatabase(Context context, final ItemInfo item, final long container, final int screen, final int cellX, final int cellY) {"> 358     static void moveItemInDatabase(Context context, final ItemInfo item, final long container, final int ðŸ”µ</abbr>
<abbr title=" 359         String transaction = ((((((((((((((((((((&quot;DbDebug    Modify item (&quot; + item.title) + &quot;) in db, id: &quot;) + item.id) + &quot; (&quot;) + item.container) + &quot;, &quot;) + item.screen) + &quot;, &quot;) + item.cellX) + &quot;, &quot;) + item.cellY) + &quot;) --&gt; &quot;) + &quot;(&quot;) + container) + &quot;, &quot;) + screen) + &quot;, &quot;) + cellX) + &quot;, &quot;) + cellY) + &quot;)&quot;;"> 359         String transaction = ((((((((((((((((((((&quot;DbDebug    Modify item (&quot; + item.title) + &quot;) in db, id:ðŸ”µ</abbr>
 360         Launcher.sDumpLogs.add(transaction);
 361         Log.d(TAG, transaction);
 362         item.container = container;
 363         item.cellX = cellX;
 364         item.cellY = cellY;
 365         // We store hotseat items in canonical form which is this orientation invariant position
 366         // in the hotseat
<abbr title=" 367         if (((context instanceof Launcher) &amp;&amp; (screen &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {"> 367         if (((context instanceof Launcher) &amp;&amp; (screen &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorites.CðŸ”µ</abbr>
 368             item.screen = ((Launcher) (context)).getHotseat().getOrderInHotseat(cellX, cellY);
 369         } else {
 370             item.screen = screen;
 371         }
 372         final ContentValues values = new ContentValues();
 373         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 374         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 375         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 376         values.put(LauncherSettings.Favorites.SCREEN, item.screen);
 377         updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 378     }
 379 
 380     /**
 381      * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 382      */
<abbr title=" 383     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container, final int screen, final int cellX, final int cellY, final int spanX, final int spanY) {"> 383     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container, final inðŸ”µ</abbr>
<abbr title=" 384         String transaction = ((((((((((((((((((((&quot;DbDebug    Modify item (&quot; + item.title) + &quot;) in db, id: &quot;) + item.id) + &quot; (&quot;) + item.container) + &quot;, &quot;) + item.screen) + &quot;, &quot;) + item.cellX) + &quot;, &quot;) + item.cellY) + &quot;) --&gt; &quot;) + &quot;(&quot;) + container) + &quot;, &quot;) + screen) + &quot;, &quot;) + cellX) + &quot;, &quot;) + cellY) + &quot;)&quot;;"> 384         String transaction = ((((((((((((((((((((&quot;DbDebug    Modify item (&quot; + item.title) + &quot;) in db, id:ðŸ”µ</abbr>
 385         Launcher.sDumpLogs.add(transaction);
 386         Log.d(TAG, transaction);
 387         item.cellX = cellX;
 388         item.cellY = cellY;
 389         item.spanX = spanX;
 390         item.spanY = spanY;
 391         // We store hotseat items in canonical form which is this orientation invariant position
 392         // in the hotseat
<abbr title=" 393         if (((context instanceof Launcher) &amp;&amp; (screen &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {"> 393         if (((context instanceof Launcher) &amp;&amp; (screen &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorites.CðŸ”µ</abbr>
 394             item.screen = ((Launcher) (context)).getHotseat().getOrderInHotseat(cellX, cellY);
 395         } else {
 396             item.screen = screen;
 397         }
 398         final ContentValues values = new ContentValues();
 399         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 400         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 401         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 402         values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 403         values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 404         values.put(LauncherSettings.Favorites.SCREEN, item.screen);
 405         updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 406     }
 407 
 408     /**
 409      * Update an item to the database in a specified container.
 410      */
 411     static void updateItemInDatabase(Context context, final ItemInfo item) {
 412         final ContentValues values = new ContentValues();
 413         item.onAddToDatabase(values);
 414         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 415         updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 416     }
 417 
 418     /**
 419      * Returns true if the shortcuts already exists in the database.
 420      * we identify a shortcut by its title and intent.
 421      */
 422     static boolean shortcutExists(Context context, String title, Intent intent) {
 423         final ContentResolver cr = context.getContentResolver();
 424         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 425             new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and intent=?&quot;,
 426             new String[] { title, intent.toUri(0) }, null);
 427         boolean result = false;
 428         try {
 429             result = c.moveToFirst();
 430         } finally {
 431             c.close();
 432         }
 433         return result;
 434     }
 435 
 436     /**
 437      * Returns an ItemInfo array containing all the items in the LauncherModel.
 438      * The ItemInfo.id is not set through this function.
 439      */
 440     static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 441         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 442         final ContentResolver cr = context.getContentResolver();
 443         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
 444                 LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
<abbr title=" 445                 LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,"> 445                 LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.FavðŸ”µ</abbr>
 446                 LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY }, null, null, null);
 447 
 448         final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 449         final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 450         final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 451         final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 452         final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 453         final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 454         final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 455 
 456         try {
 457             while (c.moveToNext()) {
 458                 ItemInfo item = new ItemInfo();
 459                 item.cellX = c.getInt(cellXIndex);
 460                 item.cellY = c.getInt(cellYIndex);
 461                 item.spanX = c.getInt(spanXIndex);
 462                 item.spanY = c.getInt(spanYIndex);
 463                 item.container = c.getInt(containerIndex);
 464                 item.itemType = c.getInt(itemTypeIndex);
 465                 item.screen = c.getInt(screenIndex);
 466 
 467                 items.add(item);
 468             }
 469         } catch (Exception e) {
 470             items.clear();
 471         } finally {
 472             c.close();
 473         }
 474 
 475         return items;
 476     }
 477 
 478     /**
 479      * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 480      */
 481     FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
 482         final ContentResolver cr = context.getContentResolver();
 483         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
 484                 &quot;_id=? and (itemType=? or itemType=?)&quot;,
 485                 new String[] { String.valueOf(id),
 486                         String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
 487 
 488         try {
 489             if (c.moveToFirst()) {
 490                 final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 491                 final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 492                 final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 493                 final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 494                 final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 495                 final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 496 
 497                 FolderInfo folderInfo = null;
 498                 switch (c.getInt(itemTypeIndex)) {
 499                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 500                         folderInfo = findOrMakeFolder(folderList, id);
 501                         break;
 502                 }
 503 
 504                 folderInfo.title = c.getString(titleIndex);
 505                 folderInfo.id = id;
 506                 folderInfo.container = c.getInt(containerIndex);
 507                 folderInfo.screen = c.getInt(screenIndex);
 508                 folderInfo.cellX = c.getInt(cellXIndex);
 509                 folderInfo.cellY = c.getInt(cellYIndex);
 510 
 511                 return folderInfo;
 512             }
 513         } finally {
 514             c.close();
 515         }
 516 
 517         return null;
 518     }
 519 
 520     /**
 521      * Add an item to the database in a specified container. Sets the container, screen, cellX and
 522      * cellY fields of the item. Also assigns an ID to the item.
 523      */
<abbr title=" 524     static void addItemToDatabase(Context context, final ItemInfo item, final long container, final int screen, final int cellX, final int cellY, final boolean notify) {"> 524     static void addItemToDatabase(Context context, final ItemInfo item, final long container, final int sðŸ”µ</abbr>
 525         item.container = container;
 526         item.cellX = cellX;
 527         item.cellY = cellY;
 528         // We store hotseat items in canonical form which is this orientation invariant position
 529         // in the hotseat
<abbr title=" 530         if (((context instanceof Launcher) &amp;&amp; (screen &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {"> 530         if (((context instanceof Launcher) &amp;&amp; (screen &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorites.CðŸ”µ</abbr>
 531             item.screen = ((Launcher) (context)).getHotseat().getOrderInHotseat(cellX, cellY);
 532         } else {
 533             item.screen = screen;
 534         }
 535         final ContentValues values = new ContentValues();
 536         final ContentResolver cr = context.getContentResolver();
 537         item.onAddToDatabase(values);
 538         LauncherApplication app = ((LauncherApplication) (context.getApplicationContext()));
 539         item.id = app.getLauncherProvider().generateNewId();
 540         values.put(LauncherSettings.Favorites._ID, item.id);
 541         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 542         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 543         Runnable r = new Runnable() {
 544             public void run() {
<abbr title=" 545                 String transaction = (((((((((((&quot;DbDebug    Add item (&quot; + item.title) + &quot;) to db, id: &quot;) + item.id) + &quot; (&quot;) + container) + &quot;, &quot;) + screen) + &quot;, &quot;) + cellX) + &quot;, &quot;) + cellY) + &quot;)&quot;;"> 545                 String transaction = (((((((((((&quot;DbDebug    Add item (&quot; + item.title) + &quot;) to db, id: &quot;) ðŸ”µ</abbr>
 546                 Launcher.sDumpLogs.add(transaction);
 547                 Log.d(TAG, transaction);
<abbr title=" 548                 cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI : LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);"> 548                 cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI : LauncherSettings.Favorites.COðŸ”µ</abbr>
 549                 // Lock on mBgLock *after* the db operation
 550                 synchronized(sBgLock) {
 551                     if (sBgItemsIdMap.containsKey(item.id)) {
 552                         // we should not be adding new items in the db with the same id
<abbr title=" 553                         throw new RuntimeException((((&quot;Error: ItemInfo id (&quot; + item.id) + &quot;) passed to &quot;) + &quot;addItemToDatabase already exists.&quot;) + item.toString());"> 553                         throw new RuntimeException((((&quot;Error: ItemInfo id (&quot; + item.id) + &quot;) passed to &quot;)ðŸ”µ</abbr>
 554                     }
 555                     sBgItemsIdMap.put(item.id, item);
 556                     switch (item.itemType) {
 557                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER :
 558                             sBgFolders.put(item.id, ((FolderInfo) (item)));
 559                             // Fall through
 560                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION :
 561                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT :
<abbr title=" 562                             if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) || (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {"> 562                             if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) || (itemðŸ”µ</abbr>
 563                                 sBgWorkspaceItems.add(item);
 564                             } else if (!sBgFolders.containsKey(item.container)) {
 565                                 // Adding an item to a folder that doesn&#x27;t exist.
<abbr title=" 566                                 String msg = ((&quot;adding item: &quot; + item) + &quot; to a folder that &quot;) + &quot; doesn&#x27;t exist&quot;;"> 566                                 String msg = ((&quot;adding item: &quot; + item) + &quot; to a folder that &quot;) + &quot; doesn&#x27;ðŸ”µ</abbr>
 567                                 RuntimeException e = new RuntimeException(msg);
 568                                 e.setStackTrace(stackTrace);
 569                                 Launcher.dumpDebugLogsToConsole();
 570                                 throw e;
 571                             }
 572                             break;
 573                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET :
 574                             sBgAppWidgets.add(((LauncherAppWidgetInfo) (item)));
 575                             break;
 576                     }
 577                 }
 578             }
 579         };
 580         runOnWorkerThread(r);
 581     }
 582 
 583     /**
 584      * Creates a new unique child id, for a given cell span across all layouts.
 585      */
 586     static int getCellLayoutChildId(
 587             long container, int screen, int localCellX, int localCellY, int spanX, int spanY) {
 588         return (((int) container &amp; 0xFF) &lt;&lt; 24)
 589                 | (screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
 590     }
 591 
 592     static int getCellCountX() {
 593         return mCellCountX;
 594     }
 595 
 596     static int getCellCountY() {
 597         return mCellCountY;
 598     }
 599 
 600     /**
 601      * Updates the model orientation helper to take into account the current layout dimensions
 602      * when performing local/canonical coordinate transformations.
 603      */
 604     static void updateWorkspaceLayoutCells(int shortAxisCellCount, int longAxisCellCount) {
 605         mCellCountX = shortAxisCellCount;
 606         mCellCountY = longAxisCellCount;
 607     }
 608 
 609     /**
 610      * Removes the specified item from the database
 611      * @param context
 612      * @param item
 613      */
 614     static void deleteItemFromDatabase(Context context, final ItemInfo item) {
 615         final ContentResolver cr = context.getContentResolver();
 616         final Uri uriToDelete = LauncherSettings.Favorites.getContentUri(item.id, false);
 617         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 618         Runnable r = new Runnable() {
 619             public void run() {
<abbr title=" 620                 String transaction = (((((((((((&quot;DbDebug    Delete item (&quot; + item.title) + &quot;) from db, id: &quot;) + item.id) + &quot; (&quot;) + item.container) + &quot;, &quot;) + item.screen) + &quot;, &quot;) + item.cellX) + &quot;, &quot;) + item.cellY) + &quot;)&quot;;"> 620                 String transaction = (((((((((((&quot;DbDebug    Delete item (&quot; + item.title) + &quot;) from db, idðŸ”µ</abbr>
 621                 Launcher.sDumpLogs.add(transaction);
 622                 Log.d(TAG, transaction);
 623                 cr.delete(uriToDelete, null, null);
 624                 // Lock on mBgLock *after* the db operation
 625                 synchronized(sBgLock) {
 626                     switch (item.itemType) {
 627                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER :
 628                             sBgFolders.remove(item.id);
 629                             for (ItemInfo info : sBgItemsIdMap.values()) {
 630                                 if (info.container == item.id) {
 631                                     // We are deleting a folder which still contains items that
 632                                     // think they are contained by that folder.
<abbr title=" 633                                     String msg = ((((&quot;deleting a folder (&quot; + item) + &quot;) which still &quot;) + &quot;contains items (&quot;) + info) + &quot;)&quot;;"> 633                                     String msg = ((((&quot;deleting a folder (&quot; + item) + &quot;) which still &quot;) + ðŸ”µ</abbr>
 634                                     RuntimeException e = new RuntimeException(msg);
 635                                     e.setStackTrace(stackTrace);
 636                                     Launcher.dumpDebugLogsToConsole();
 637                                     throw e;
 638                                 }
 639                             }
 640                             sBgWorkspaceItems.remove(item);
 641                             break;
 642                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION :
 643                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT :
 644                             sBgWorkspaceItems.remove(item);
 645                             break;
 646                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET :
 647                             sBgAppWidgets.remove(((LauncherAppWidgetInfo) (item)));
 648                             break;
 649                     }
 650                     sBgItemsIdMap.remove(item.id);
 651                     sBgDbIconCache.remove(item);
 652                 }
 653             }
 654         };
 655         runOnWorkerThread(r);
 656     }
 657 
 658     /**
 659      * Remove the contents of the specified folder from the database
 660      */
 661     static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
 662         final ContentResolver cr = context.getContentResolver();
 663 
 664         Runnable r = new Runnable() {
 665             public void run() {
 666                 cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
 667                 // Lock on mBgLock *after* the db operation
 668                 synchronized (sBgLock) {
 669                     sBgItemsIdMap.remove(info.id);
 670                     sBgFolders.remove(info.id);
 671                     sBgDbIconCache.remove(info);
 672                     sBgWorkspaceItems.remove(info);
 673                 }
 674 
 675                 cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
 676                         LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
 677                 // Lock on mBgLock *after* the db operation
 678                 synchronized (sBgLock) {
 679                     for (ItemInfo childInfo : info.contents) {
 680                         sBgItemsIdMap.remove(childInfo.id);
 681                         sBgDbIconCache.remove(childInfo);
 682                     }
 683                 }
 684             }
 685         };
 686         runOnWorkerThread(r);
 687     }
 688 
 689     /**
 690      * Set this as the current Launcher activity object for the loader.
 691      */
 692     public void initialize(Callbacks callbacks) {
 693         synchronized (mLock) {
 694             mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
 695         }
 696     }
 697 
 698     /**
 699      * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
 700      * ACTION_PACKAGE_CHANGED.
 701      */
 702     @Override
 703     public void onReceive(Context context, Intent intent) {
 704         if (DEBUG_LOADERS) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
 705 
 706         final String action = intent.getAction();
 707 
 708         if (Intent.ACTION_PACKAGE_CHANGED.equals(action)
 709                 || Intent.ACTION_PACKAGE_REMOVED.equals(action)
 710                 || Intent.ACTION_PACKAGE_ADDED.equals(action)) {
 711             final String packageName = intent.getData().getSchemeSpecificPart();
 712             final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
 713 
 714             int op = PackageUpdatedTask.OP_NONE;
 715 
 716             if (packageName == null || packageName.length() == 0) {
 717                 // they sent us a bad intent
 718                 return;
 719             }
 720 
 721             if (Intent.ACTION_PACKAGE_CHANGED.equals(action)) {
 722                 op = PackageUpdatedTask.OP_UPDATE;
 723             } else if (Intent.ACTION_PACKAGE_REMOVED.equals(action)) {
 724                 if (!replacing) {
 725                     op = PackageUpdatedTask.OP_REMOVE;
 726                 }
 727                 // else, we are replacing the package, so a PACKAGE_ADDED will be sent
 728                 // later, we will update the package at this time
 729             } else if (Intent.ACTION_PACKAGE_ADDED.equals(action)) {
 730                 if (!replacing) {
 731                     op = PackageUpdatedTask.OP_ADD;
 732                 } else {
 733                     op = PackageUpdatedTask.OP_UPDATE;
 734                 }
 735             }
 736 
 737             if (op != PackageUpdatedTask.OP_NONE) {
 738                 enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName }));
 739             }
 740 
 741         } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(action)) {
 742             // First, schedule to add these apps back in.
 743             String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
 744             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packages));
 745             // Then, rebind everything.
 746             startLoaderFromBackground();
 747         } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(action)) {
 748             String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
 749             enqueuePackageUpdated(new PackageUpdatedTask(
 750                         PackageUpdatedTask.OP_UNAVAILABLE, packages));
 751         } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
 752             // If we have changed locale we need to clear out the labels in all apps/workspace.
 753             forceReload();
 754         } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
 755              // Check if configuration change was an mcc/mnc change which would affect app resources
 756              // and we would need to clear out the labels in all apps/workspace. Same handling as
 757              // above for ACTION_LOCALE_CHANGED
 758              Configuration currentConfig = context.getResources().getConfiguration();
 759              if (mPreviousConfigMcc != currentConfig.mcc) {
 760                    Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
 761                        + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
 762                    forceReload();
 763              }
 764              // Update previousConfig
 765              mPreviousConfigMcc = currentConfig.mcc;
 766         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
 767                    SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
 768             if (mCallbacks != null) {
 769                 Callbacks callbacks = mCallbacks.get();
 770                 if (callbacks != null) {
 771                     callbacks.bindSearchablesChanged();
 772                 }
 773             }
 774         }
 775     }
 776 
 777     private void forceReload() {
 778         resetLoadedState(true, true);
 779 
 780         // Do this here because if the launcher activity is running it will be restarted.
 781         // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
 782         // to reload.
 783         startLoaderFromBackground();
 784     }
 785 
 786     public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
 787         synchronized (mLock) {
 788             // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
 789             // mWorkspaceLoaded to true later
 790             stopLoaderLocked();
 791             if (resetAllAppsLoaded) mAllAppsLoaded = false;
 792             if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
 793         }
 794     }
 795 
 796     /**
 797      * When the launcher is in the background, it&#x27;s possible for it to miss paired
 798      * configuration changes.  So whenever we trigger the loader from the background
 799      * tell the launcher that it needs to re-run the loader when it comes back instead
 800      * of doing it now.
 801      */
 802     public void startLoaderFromBackground() {
 803         boolean runLoader = false;
 804         if (mCallbacks != null) {
 805             Callbacks callbacks = mCallbacks.get();
 806             if (callbacks != null) {
 807                 // Only actually run the loader if they&#x27;re not paused.
 808                 if (!callbacks.setLoadOnResume()) {
 809                     runLoader = true;
 810                 }
 811             }
 812         }
 813         if (runLoader) {
 814             startLoader(false, -1);
 815         }
 816     }
 817 
 818     // If there is already a loader task running, tell it to stop.
 819     // returns true if isLaunching() was true on the old task
 820     private boolean stopLoaderLocked() {
 821         boolean isLaunching = false;
 822         LoaderTask oldTask = mLoaderTask;
 823         if (oldTask != null) {
 824             if (oldTask.isLaunching()) {
 825                 isLaunching = true;
 826             }
 827             oldTask.stopLocked();
 828         }
 829         return isLaunching;
 830     }
 831 
 832     public void startLoader(boolean isLaunching, int synchronousBindPage) {
 833         synchronized (mLock) {
 834             if (DEBUG_LOADERS) {
 835                 Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
 836             }
 837 
 838             // Clear any deferred bind-runnables from the synchronized load process
 839             // We must do this before any loading/binding is scheduled below.
 840             mDeferredBindRunnables.clear();
 841 
 842             // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
 843             if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
 844                 // If there is already one running, tell it to stop.
 845                 // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
 846                 isLaunching = isLaunching || stopLoaderLocked();
 847                 mLoaderTask = new LoaderTask(mApp, isLaunching);
 848                 if (synchronousBindPage &gt; -1 &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {
 849                     mLoaderTask.runBindSynchronousPage(synchronousBindPage);
 850                 } else {
 851                     sWorkerThread.setPriority(Thread.NORM_PRIORITY);
 852                     sWorker.post(mLoaderTask);
 853                 }
 854             }
 855         }
 856     }
 857 
 858     void bindRemainingSynchronousPages() {
 859         // Post the remaining side pages to be loaded
 860         if (!mDeferredBindRunnables.isEmpty()) {
 861             for (final Runnable r : mDeferredBindRunnables) {
 862                 mHandler.post(r);
 863             }
 864             mDeferredBindRunnables.clear();
 865         }
 866     }
 867 
 868     public void stopLoader() {
 869         synchronized (mLock) {
 870             if (mLoaderTask != null) {
 871                 mLoaderTask.stopLocked();
 872             }
 873         }
 874     }
 875 
 876     public boolean isAllAppsLoaded() {
 877         return mAllAppsLoaded;
 878     }
 879 
 880     boolean isLoadingWorkspace() {
 881         synchronized (mLock) {
 882             if (mLoaderTask != null) {
 883                 return mLoaderTask.isLoadingWorkspace();
 884             }
 885         }
 886         return false;
 887     }
 888 
 889     /**
 890      * Runnable for the thread that loads the contents of the launcher:
 891      *   - workspace icons
 892      *   - widgets
 893      *   - all apps icons
 894      */
 895     private class LoaderTask implements Runnable {
 896         private Context mContext;
 897 
 898         private boolean mIsLaunching;
 899 
 900         private boolean mIsLoadingAndBindingWorkspace;
 901 
 902         private boolean mStopped;
 903 
 904         private boolean mLoadAndBindStepFinished;
 905 
 906         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
 907 
 908         LoaderTask(Context context, boolean isLaunching) {
 909             mContext = context;
 910             mIsLaunching = isLaunching;
 911             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
 912         }
 913 
 914         boolean isLaunching() {
 915             return mIsLaunching;
 916         }
 917 
 918         boolean isLoadingWorkspace() {
 919             return mIsLoadingAndBindingWorkspace;
 920         }
 921 
 922         private void loadAndBindWorkspace() {
 923             mIsLoadingAndBindingWorkspace = true;
 924 
 925             // Load the workspace
 926             if (DEBUG_LOADERS) {
 927                 Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
 928             }
 929 
 930             if (!mWorkspaceLoaded) {
 931                 loadWorkspace();
 932                 synchronized (LoaderTask.this) {
 933                     if (mStopped) {
 934                         return;
 935                     }
 936                     mWorkspaceLoaded = true;
 937                 }
 938             }
 939 
 940             // Bind the workspace
 941             bindWorkspace(-1);
 942         }
 943 
 944         private void waitForIdle() {
 945             // Wait until the either we&#x27;re stopped or the other threads are done.
 946             // This way we don&#x27;t start loading all apps until the workspace has settled
 947             // down.
 948             synchronized (LoaderTask.this) {
 949                 final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
 950 
 951                 mHandler.postIdle(new Runnable() {
 952                         public void run() {
 953                             synchronized (LoaderTask.this) {
 954                                 mLoadAndBindStepFinished = true;
 955                                 if (DEBUG_LOADERS) {
 956                                     Log.d(TAG, &quot;done with previous binding step&quot;);
 957                                 }
 958                                 LoaderTask.this.notify();
 959                             }
 960                         }
 961                     });
 962 
 963                 while (!mStopped &amp;&amp; !mLoadAndBindStepFinished) {
 964                     try {
 965                         this.wait();
 966                     } catch (InterruptedException ex) {
 967                         // Ignore
 968                     }
 969                 }
 970                 if (DEBUG_LOADERS) {
 971                     Log.d(TAG, &quot;waited &quot;
 972                             + (SystemClock.uptimeMillis()-workspaceWaitTime)
 973                             + &quot;ms for previous step to finish binding&quot;);
 974                 }
 975             }
 976         }
 977 
 978         void runBindSynchronousPage(int synchronousBindPage) {
 979             if (synchronousBindPage &lt; 0) {
 980                 // Ensure that we have a valid page index to load synchronously
 981                 throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
 982                         &quot;valid page index&quot;);
 983             }
 984             if (!mAllAppsLoaded || !mWorkspaceLoaded) {
 985                 // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
 986                 // loaded already (we should load everything asynchronously in that case)
 987                 throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
 988             }
 989             synchronized (mLock) {
 990                 if (mIsLoaderTaskRunning) {
 991                     // Ensure that we are never running the background loading at this point since
 992                     // we also touch the background collections
 993                     throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
 994                 }
 995             }
 996 
 997             // XXX: Throw an exception if we are already loading (since we touch the worker thread
 998             //      data structures, we can&#x27;t allow any other thread to touch that data, but because
 999             //      this call is synchronous, we can get away with not locking).
1000 
1001             // The LauncherModel is static in the LauncherApplication and mHandler may have queued
1002             // operations from the previous activity.  We need to ensure that all queued operations
1003             // are executed before any synchronous binding work is done.
1004             mHandler.flush();
1005 
1006             // Divide the set of loaded items into those that we are binding synchronously, and
1007             // everything else that is to be bound normally (asynchronously).
1008             bindWorkspace(synchronousBindPage);
1009             // XXX: For now, continue posting the binding of AllApps as there are other issues that
1010             //      arise from that.
1011             onlyBindAllApps();
1012         }
1013 
1014         public void run() {
1015             synchronized (mLock) {
1016                 mIsLoaderTaskRunning = true;
1017             }
1018             // Optimize for end-user experience: if the Launcher is up and // running with the
1019             // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1020             // workspace first (default).
1021             final Callbacks cbk = mCallbacks.get();
1022             final boolean loadWorkspaceFirst = cbk != null ? (!cbk.isAllAppsVisible()) : true;
1023 
1024             keep_running: {
1025                 // Elevate priority when Home launches for the first time to avoid
1026                 // starving at boot time. Staring at a blank home is not cool.
1027                 synchronized (mLock) {
1028                     if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1029                             (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1030                     android.os.Process.setThreadPriority(mIsLaunching
1031                             ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1032                 }
1033                 if (loadWorkspaceFirst) {
1034                     if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1035                     loadAndBindWorkspace();
1036                 } else {
1037                     if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: special: loading all apps&quot;);
1038                     loadAndBindAllApps();
1039                 }
1040 
1041                 if (mStopped) {
1042                     break keep_running;
1043                 }
1044 
1045                 // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1046                 // settled down.
1047                 synchronized (mLock) {
1048                     if (mIsLaunching) {
1049                         if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1050                         android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1051                     }
1052                 }
1053                 waitForIdle();
1054 
1055                 // second step
1056                 if (loadWorkspaceFirst) {
1057                     if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1058                     loadAndBindAllApps();
1059                 } else {
1060                     if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: special: loading workspace&quot;);
1061                     loadAndBindWorkspace();
1062                 }
1063 
1064                 // Restore the default thread priority after we are done loading items
1065                 synchronized (mLock) {
1066                     android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1067                 }
1068             }
1069 
1070 
1071             // Update the saved icons if necessary
1072             if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1073             synchronized (sBgLock) {
1074                 for (Object key : sBgDbIconCache.keySet()) {
1075                     updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
1076                 }
1077                 sBgDbIconCache.clear();
1078             }
1079 
1080             // Clear out this reference, otherwise we end up holding it until all of the
1081             // callback runnables are done.
1082             mContext = null;
1083 
1084             synchronized (mLock) {
1085                 // If we are still the last one to be scheduled, remove ourselves.
1086                 if (mLoaderTask == this) {
1087                     mLoaderTask = null;
1088                 }
1089                 mIsLoaderTaskRunning = false;
1090             }
1091         }
1092 
1093         public void stopLocked() {
1094             synchronized (LoaderTask.this) {
1095                 mStopped = true;
1096                 this.notify();
1097             }
1098         }
1099 
1100         /**
1101          * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1102          * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1103          * object that was around when the deferred message was scheduled, and if there&#x27;s
1104          * a new Callbacks object around then also return null.  This will save us from
1105          * calling onto it with data that will be ignored.
1106          */
1107         Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1108             synchronized (mLock) {
1109                 if (mStopped) {
1110                     return null;
1111                 }
1112 
1113                 if (mCallbacks == null) {
1114                     return null;
1115                 }
1116 
1117                 final Callbacks callbacks = mCallbacks.get();
1118                 if (callbacks != oldCallbacks) {
1119                     return null;
1120                 }
1121                 if (callbacks == null) {
1122                     Log.w(TAG, &quot;no mCallbacks&quot;);
1123                     return null;
1124                 }
1125 
1126                 return callbacks;
1127             }
1128         }
1129 
1130         // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1131         private boolean checkItemPlacement(ItemInfo occupied[][][], ItemInfo item) {
1132             int containerIndex = item.screen;
1133             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1134                 // Return early if we detect that an item is under the hotseat button
1135                 if (mCallbacks == null || mCallbacks.get().isAllAppsButtonRank(item.screen)) {
1136                     return false;
1137                 }
1138 
1139                 // We use the last index to refer to the hotseat and the screen as the rank, so
1140                 // test and update the occupied state accordingly
1141                 if (occupied[Launcher.SCREEN_COUNT][item.screen][0] != null) {
1142                     Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1143                         + &quot; into position (&quot; + item.screen + &quot;:&quot; + item.cellX + &quot;,&quot; + item.cellY
1144                         + &quot;) occupied by &quot; + occupied[Launcher.SCREEN_COUNT][item.screen][0]);
1145                     return false;
1146                 } else {
1147                     occupied[Launcher.SCREEN_COUNT][item.screen][0] = item;
1148                     return true;
1149                 }
1150             } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1151                 // Skip further checking if it is not the hotseat or workspace container
1152                 return true;
1153             }
1154 
1155             // Check if any workspace icons overlap with each other
1156             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1157                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1158                     if (occupied[containerIndex][x][y] != null) {
1159                         Log.e(TAG, &quot;Error loading shortcut &quot; + item
1160                             + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screen + &quot;:&quot;
1161                             + x + &quot;,&quot; + y
1162                             + &quot;) occupied by &quot;
1163                             + occupied[containerIndex][x][y]);
1164                         return false;
1165                     }
1166                 }
1167             }
1168             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1169                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1170                     occupied[containerIndex][x][y] = item;
1171                 }
1172             }
1173 
1174             return true;
1175         }
1176 
1177         private void loadWorkspace() {
1178             final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1179 
1180             final Context context = mContext;
1181             final ContentResolver contentResolver = context.getContentResolver();
1182             final PackageManager manager = context.getPackageManager();
1183             final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1184             final boolean isSafeMode = manager.isSafeMode();
1185 
1186             // Make sure the default workspace is loaded, if needed
1187             mApp.getLauncherProvider().loadDefaultFavoritesIfNecessary();
1188 
1189             synchronized (sBgLock) {
1190                 sBgWorkspaceItems.clear();
1191                 sBgAppWidgets.clear();
1192                 sBgFolders.clear();
1193                 sBgItemsIdMap.clear();
1194                 sBgDbIconCache.clear();
1195 
1196                 final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1197 
1198                 final Cursor c = contentResolver.query(
1199                         LauncherSettings.Favorites.CONTENT_URI, null, null, null, null);
1200 
1201                 // +1 for the hotseat (it can be larger than the workspace)
1202                 // Load workspace in reverse order to ensure that latest items are loaded first (and
1203                 // before any earlier duplicates)
1204                 final ItemInfo occupied[][][] =
1205                         new ItemInfo[Launcher.SCREEN_COUNT + 1][mCellCountX + 1][mCellCountY + 1];
1206 
1207                 try {
1208                     final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1209                     final int intentIndex = c.getColumnIndexOrThrow
1210                             (LauncherSettings.Favorites.INTENT);
1211                     final int titleIndex = c.getColumnIndexOrThrow
1212                             (LauncherSettings.Favorites.TITLE);
1213                     final int iconTypeIndex = c.getColumnIndexOrThrow(
1214                             LauncherSettings.Favorites.ICON_TYPE);
1215                     final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
1216                     final int iconPackageIndex = c.getColumnIndexOrThrow(
1217                             LauncherSettings.Favorites.ICON_PACKAGE);
1218                     final int iconResourceIndex = c.getColumnIndexOrThrow(
1219                             LauncherSettings.Favorites.ICON_RESOURCE);
1220                     final int containerIndex = c.getColumnIndexOrThrow(
1221                             LauncherSettings.Favorites.CONTAINER);
1222                     final int itemTypeIndex = c.getColumnIndexOrThrow(
1223                             LauncherSettings.Favorites.ITEM_TYPE);
1224                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(
1225                             LauncherSettings.Favorites.APPWIDGET_ID);
1226                     final int screenIndex = c.getColumnIndexOrThrow(
1227                             LauncherSettings.Favorites.SCREEN);
1228                     final int cellXIndex = c.getColumnIndexOrThrow
1229                             (LauncherSettings.Favorites.CELLX);
1230                     final int cellYIndex = c.getColumnIndexOrThrow
1231                             (LauncherSettings.Favorites.CELLY);
1232                     final int spanXIndex = c.getColumnIndexOrThrow
1233                             (LauncherSettings.Favorites.SPANX);
1234                     final int spanYIndex = c.getColumnIndexOrThrow(
1235                             LauncherSettings.Favorites.SPANY);
1236                     //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1237                     //final int displayModeIndex = c.getColumnIndexOrThrow(
1238                     //        LauncherSettings.Favorites.DISPLAY_MODE);
1239 
1240                     ShortcutInfo info;
1241                     String intentDescription;
1242                     LauncherAppWidgetInfo appWidgetInfo;
1243                     int container;
1244                     long id;
1245                     Intent intent;
1246 
1247                     while (!mStopped &amp;&amp; c.moveToNext()) {
1248                         try {
1249                             int itemType = c.getInt(itemTypeIndex);
1250 
1251                             switch (itemType) {
1252                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1253                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1254                                 intentDescription = c.getString(intentIndex);
1255                                 try {
1256                                     intent = Intent.parseUri(intentDescription, 0);
1257                                 } catch (URISyntaxException e) {
1258                                     continue;
1259                                 }
1260 
1261                                 if (itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
1262                                     info = getShortcutInfo(manager, intent, context, c, iconIndex,
1263                                             titleIndex, mLabelCache);
1264                                 } else {
1265                                     info = getShortcutInfo(c, context, iconTypeIndex,
1266                                             iconPackageIndex, iconResourceIndex, iconIndex,
1267                                             titleIndex);
1268 
1269                                     // App shortcuts that used to be automatically added to Launcher
1270                                     // didn&#x27;t always have the correct intent flags set, so do that
1271                                     // here
1272                                     if (intent.getAction() != null &amp;&amp;
1273                                         intent.getCategories() != null &amp;&amp;
1274                                         intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
1275                                         intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
1276                                         intent.addFlags(
1277                                             Intent.FLAG_ACTIVITY_NEW_TASK |
1278                                             Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
1279                                     }
1280                                 }
1281 
1282                                 if (info != null) {
1283                                     info.intent = intent;
1284                                     info.id = c.getLong(idIndex);
1285                                     container = c.getInt(containerIndex);
1286                                     info.container = container;
1287                                     info.screen = c.getInt(screenIndex);
1288                                     info.cellX = c.getInt(cellXIndex);
1289                                     info.cellY = c.getInt(cellYIndex);
1290 
1291                                     // check &amp; update map of what&#x27;s occupied
1292                                     if (!checkItemPlacement(occupied, info)) {
1293                                         break;
1294                                     }
1295 
1296                                     switch (container) {
1297                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
1298                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
1299                                         sBgWorkspaceItems.add(info);
1300                                         break;
1301                                     default:
1302                                         // Item is in a user folder
1303                                         FolderInfo folderInfo =
1304                                                 findOrMakeFolder(sBgFolders, container);
1305                                         folderInfo.add(info);
1306                                         break;
1307                                     }
1308                                     sBgItemsIdMap.put(info.id, info);
1309 
1310                                     // now that we&#x27;ve loaded everthing re-save it with the
1311                                     // icon in case it disappears somehow.
1312                                     queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
1313                                 } else {
1314                                     // Failed to load the shortcut, probably because the
1315                                     // activity manager couldn&#x27;t resolve it (maybe the app
1316                                     // was uninstalled), or the db row was somehow screwed up.
1317                                     // Delete it.
1318                                     id = c.getLong(idIndex);
1319                                     Log.e(TAG, &quot;Error loading shortcut &quot; + id + &quot;, removing it&quot;);
1320                                     contentResolver.delete(LauncherSettings.Favorites.getContentUri(
1321                                                 id, false), null, null);
1322                                 }
1323                                 break;
1324 
1325                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1326                                 id = c.getLong(idIndex);
1327                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
1328 
1329                                 folderInfo.title = c.getString(titleIndex);
1330                                 folderInfo.id = id;
1331                                 container = c.getInt(containerIndex);
1332                                 folderInfo.container = container;
1333                                 folderInfo.screen = c.getInt(screenIndex);
1334                                 folderInfo.cellX = c.getInt(cellXIndex);
1335                                 folderInfo.cellY = c.getInt(cellYIndex);
1336 
1337                                 // check &amp; update map of what&#x27;s occupied
1338                                 if (!checkItemPlacement(occupied, folderInfo)) {
1339                                     break;
1340                                 }
1341                                 switch (container) {
1342                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
1343                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
1344                                         sBgWorkspaceItems.add(folderInfo);
1345                                         break;
1346                                 }
1347 
1348                                 sBgItemsIdMap.put(folderInfo.id, folderInfo);
1349                                 sBgFolders.put(folderInfo.id, folderInfo);
1350                                 break;
1351 
1352                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1353                                 // Read all Launcher-specific widget details
1354                                 int appWidgetId = c.getInt(appWidgetIdIndex);
1355                                 id = c.getLong(idIndex);
1356 
1357                                 final AppWidgetProviderInfo provider =
1358                                         widgets.getAppWidgetInfo(appWidgetId);
1359 
1360                                 if (!isSafeMode &amp;&amp; (provider == null || provider.provider == null ||
1361                                         provider.provider.getPackageName() == null)) {
1362                                     String log = &quot;Deleting widget that isn&#x27;t installed anymore: id=&quot;
1363                                         + id + &quot; appWidgetId=&quot; + appWidgetId;
1364                                     Log.e(TAG, log);
1365                                     Launcher.sDumpLogs.add(log);
1366                                     itemsToRemove.add(id);
1367                                 } else {
1368                                     appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
1369                                             provider.provider);
1370                                     appWidgetInfo.id = id;
1371                                     appWidgetInfo.screen = c.getInt(screenIndex);
1372                                     appWidgetInfo.cellX = c.getInt(cellXIndex);
1373                                     appWidgetInfo.cellY = c.getInt(cellYIndex);
1374                                     appWidgetInfo.spanX = c.getInt(spanXIndex);
1375                                     appWidgetInfo.spanY = c.getInt(spanYIndex);
1376                                     int[] minSpan = Launcher.getMinSpanForWidget(context, provider);
1377                                     appWidgetInfo.minSpanX = minSpan[0];
1378                                     appWidgetInfo.minSpanY = minSpan[1];
1379 
1380                                     container = c.getInt(containerIndex);
1381                                     if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1382                                         container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1383                                         Log.e(TAG, &quot;Widget found where container != &quot; +
1384                                             &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
1385                                         continue;
1386                                     }
1387                                     appWidgetInfo.container = c.getInt(containerIndex);
1388 
1389                                     // check &amp; update map of what&#x27;s occupied
1390                                     if (!checkItemPlacement(occupied, appWidgetInfo)) {
1391                                         break;
1392                                     }
1393                                     sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
1394                                     sBgAppWidgets.add(appWidgetInfo);
1395                                 }
1396                                 break;
1397                             }
1398                         } catch (Exception e) {
1399                             Log.w(TAG, &quot;Desktop items loading interrupted:&quot;, e);
1400                         }
1401                     }
1402                 } finally {
1403                     c.close();
1404                 }
1405 
1406                 if (itemsToRemove.size() &gt; 0) {
1407                     ContentProviderClient client = contentResolver.acquireContentProviderClient(
1408                                     LauncherSettings.Favorites.CONTENT_URI);
1409                     // Remove dead items
1410                     for (long id : itemsToRemove) {
1411                         if (DEBUG_LOADERS) {
1412                             Log.d(TAG, &quot;Removed id = &quot; + id);
1413                         }
1414                         // Don&#x27;t notify content observers
1415                         try {
1416                             client.delete(LauncherSettings.Favorites.getContentUri(id, false),
1417                                     null, null);
1418                         } catch (RemoteException e) {
1419                             Log.w(TAG, &quot;Could not remove id = &quot; + id);
1420                         }
1421                     }
1422                 }
1423 
1424                 if (DEBUG_LOADERS) {
1425                     Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
1426                     Log.d(TAG, &quot;workspace layout: &quot;);
1427                     for (int y = 0; y &lt; mCellCountY; y++) {
1428                         String line = &quot;&quot;;
1429                         for (int s = 0; s &lt; Launcher.SCREEN_COUNT; s++) {
1430                             if (s &gt; 0) {
1431                                 line += &quot; | &quot;;
1432                             }
1433                             for (int x = 0; x &lt; mCellCountX; x++) {
1434                                 line += ((occupied[s][x][y] != null) ? &quot;#&quot; : &quot;.&quot;);
1435                             }
1436                         }
1437                         Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
1438                     }
1439                 }
1440             }
1441         }
1442 
1443         /** Filters the set of items who are directly or indirectly (via another container) on the
1444          * specified screen. */
1445         private void filterCurrentWorkspaceItems(int currentScreen,
1446                 ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
1447                 ArrayList&lt;ItemInfo&gt; currentScreenItems,
1448                 ArrayList&lt;ItemInfo&gt; otherScreenItems) {
1449             // Purge any null ItemInfos
1450             Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
1451             while (iter.hasNext()) {
1452                 ItemInfo i = iter.next();
1453                 if (i == null) {
1454                     iter.remove();
1455                 }
1456             }
1457 
1458             // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of
1459             // items given.
1460             if (currentScreen &lt; 0) {
1461                 currentScreenItems.addAll(allWorkspaceItems);
1462             }
1463 
1464             // Order the set of items by their containers first, this allows use to walk through the
1465             // list sequentially, build up a list of containers that are in the specified screen,
1466             // as well as all items in those containers.
1467             Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
1468             Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
1469                 @Override
1470                 public int compare(ItemInfo lhs, ItemInfo rhs) {
1471                     return (int) (lhs.container - rhs.container);
1472                 }
1473             });
1474             for (ItemInfo info : allWorkspaceItems) {
1475                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1476                     if (info.screen == currentScreen) {
1477                         currentScreenItems.add(info);
1478                         itemsOnScreen.add(info.id);
1479                     } else {
1480                         otherScreenItems.add(info);
1481                     }
1482                 } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1483                     currentScreenItems.add(info);
1484                     itemsOnScreen.add(info.id);
1485                 } else {
1486                     if (itemsOnScreen.contains(info.container)) {
1487                         currentScreenItems.add(info);
1488                         itemsOnScreen.add(info.id);
1489                     } else {
1490                         otherScreenItems.add(info);
1491                     }
1492                 }
1493             }
1494         }
1495 
1496         /** Filters the set of widgets which are on the specified screen. */
1497         private void filterCurrentAppWidgets(int currentScreen,
1498                 ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
1499                 ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
1500                 ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
1501             // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of
1502             // widgets given.
1503             if (currentScreen &lt; 0) {
1504                 currentScreenWidgets.addAll(appWidgets);
1505             }
1506 
1507             for (LauncherAppWidgetInfo widget : appWidgets) {
1508                 if (widget == null) continue;
1509                 if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1510                         widget.screen == currentScreen) {
1511                     currentScreenWidgets.add(widget);
1512                 } else {
1513                     otherScreenWidgets.add(widget);
1514                 }
1515             }
1516         }
1517 
1518         /** Filters the set of folders which are on the specified screen. */
1519         private void filterCurrentFolders(int currentScreen,
1520                 HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
1521                 HashMap&lt;Long, FolderInfo&gt; folders,
1522                 HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
1523                 HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
1524             // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of
1525             // widgets given.
1526             if (currentScreen &lt; 0) {
1527                 currentScreenFolders.putAll(folders);
1528             }
1529 
1530             for (long id : folders.keySet()) {
1531                 ItemInfo info = itemsIdMap.get(id);
1532                 FolderInfo folder = folders.get(id);
1533                 if (info == null || folder == null) continue;
1534                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1535                         info.screen == currentScreen) {
1536                     currentScreenFolders.put(id, folder);
1537                 } else {
1538                     otherScreenFolders.put(id, folder);
1539                 }
1540             }
1541         }
1542 
1543         /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
1544          * right) */
1545         private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
1546             // XXX: review this
1547             Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
1548                 @Override
1549                 public int compare(ItemInfo lhs, ItemInfo rhs) {
1550                     int cellCountX = LauncherModel.getCellCountX();
1551                     int cellCountY = LauncherModel.getCellCountY();
1552                     int screenOffset = cellCountX * cellCountY;
1553                     int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
1554                     long lr = (lhs.container * containerOffset + lhs.screen * screenOffset +
1555                             lhs.cellY * cellCountX + lhs.cellX);
1556                     long rr = (rhs.container * containerOffset + rhs.screen * screenOffset +
1557                             rhs.cellY * cellCountX + rhs.cellX);
1558                     return (int) (lr - rr);
1559                 }
1560             });
1561         }
1562 
1563         private void bindWorkspaceItems(final Callbacks oldCallbacks,
1564                 final ArrayList&lt;ItemInfo&gt; workspaceItems,
1565                 final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
1566                 final HashMap&lt;Long, FolderInfo&gt; folders,
1567                 ArrayList&lt;Runnable&gt; deferredBindRunnables) {
1568 
1569             final boolean postOnMainThread = (deferredBindRunnables != null);
1570 
1571             // Bind the workspace items
1572             int N = workspaceItems.size();
1573             for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
1574                 final int start = i;
1575                 final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
1576                 final Runnable r = new Runnable() {
1577                     @Override
1578                     public void run() {
1579                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1580                         if (callbacks != null) {
1581                             callbacks.bindItems(workspaceItems, start, start+chunkSize);
1582                         }
1583                     }
1584                 };
1585                 if (postOnMainThread) {
1586                     deferredBindRunnables.add(r);
1587                 } else {
1588                     runOnMainThread(r);
1589                 }
1590             }
1591 
1592             // Bind the folders
1593             if (!folders.isEmpty()) {
1594                 final Runnable r = new Runnable() {
1595                     public void run() {
1596                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1597                         if (callbacks != null) {
1598                             callbacks.bindFolders(folders);
1599                         }
1600                     }
1601                 };
1602                 if (postOnMainThread) {
1603                     deferredBindRunnables.add(r);
1604                 } else {
1605                     runOnMainThread(r);
1606                 }
1607             }
1608 
1609             // Bind the widgets, one at a time
1610             N = appWidgets.size();
1611             for (int i = 0; i &lt; N; i++) {
1612                 final LauncherAppWidgetInfo widget = appWidgets.get(i);
1613                 final Runnable r = new Runnable() {
1614                     public void run() {
1615                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1616                         if (callbacks != null) {
1617                             callbacks.bindAppWidget(widget);
1618                         }
1619                     }
1620                 };
1621                 if (postOnMainThread) {
1622                     deferredBindRunnables.add(r);
1623                 } else {
1624                     runOnMainThread(r);
1625                 }
1626             }
1627         }
1628 
1629         /**
1630          * Binds all loaded data to actual views on the main thread.
1631          */
1632         private void bindWorkspace(int synchronizeBindPage) {
1633             final long t = SystemClock.uptimeMillis();
1634             Runnable r;
1635 
1636             // Don&#x27;t use these two variables in any of the callback runnables.
1637             // Otherwise we hold a reference to them.
1638             final Callbacks oldCallbacks = mCallbacks.get();
1639             if (oldCallbacks == null) {
1640                 // This launcher has exited and nobody bothered to tell us.  Just bail.
1641                 Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
1642                 return;
1643             }
1644 
1645             final boolean isLoadingSynchronously = (synchronizeBindPage &gt; -1);
1646             final int currentScreen = isLoadingSynchronously ? synchronizeBindPage :
1647                 oldCallbacks.getCurrentWorkspaceScreen();
1648 
1649             // Load all the items that are on the current page first (and in the process, unbind
1650             // all the existing workspace items before we call startBinding() below.
1651             unbindWorkspaceItemsOnMainThread();
1652             ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
1653             ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
1654                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
1655             HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
1656             HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
1657             synchronized (sBgLock) {
1658                 workspaceItems.addAll(sBgWorkspaceItems);
1659                 appWidgets.addAll(sBgAppWidgets);
1660                 folders.putAll(sBgFolders);
1661                 itemsIdMap.putAll(sBgItemsIdMap);
1662             }
1663 
1664             ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
1665             ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
1666             ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
1667                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
1668             ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
1669                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
1670             HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
1671             HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
1672 
1673             // Separate the items that are on the current screen, and all the other remaining items
1674             filterCurrentWorkspaceItems(currentScreen, workspaceItems, currentWorkspaceItems,
1675                     otherWorkspaceItems);
1676             filterCurrentAppWidgets(currentScreen, appWidgets, currentAppWidgets,
1677                     otherAppWidgets);
1678             filterCurrentFolders(currentScreen, itemsIdMap, folders, currentFolders,
1679                     otherFolders);
1680             sortWorkspaceItemsSpatially(currentWorkspaceItems);
1681             sortWorkspaceItemsSpatially(otherWorkspaceItems);
1682 
1683             // Tell the workspace that we&#x27;re about to start binding items
1684             r = new Runnable() {
1685                 public void run() {
1686                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1687                     if (callbacks != null) {
1688                         callbacks.startBinding();
1689                     }
1690                 }
1691             };
1692             runOnMainThread(r);
1693 
1694             // Load items on the current page
1695             bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
1696                     currentFolders, null);
1697             if (isLoadingSynchronously) {
1698                 r = new Runnable() {
1699                     public void run() {
1700                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1701                         if (callbacks != null) {
1702                             callbacks.onPageBoundSynchronously(currentScreen);
1703                         }
1704                     }
1705                 };
1706                 runOnMainThread(r);
1707             }
1708 
1709             // Load all the remaining pages (if we are loading synchronously, we want to defer this
1710             // work until after the first render)
1711             mDeferredBindRunnables.clear();
1712             bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
1713                     (isLoadingSynchronously ? mDeferredBindRunnables : null));
1714 
1715             // Tell the workspace that we&#x27;re done binding items
1716             r = new Runnable() {
1717                 public void run() {
1718                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1719                     if (callbacks != null) {
1720                         callbacks.finishBindingItems();
1721                     }
1722 
1723                     // If we&#x27;re profiling, ensure this is the last thing in the queue.
1724                     if (DEBUG_LOADERS) {
1725                         Log.d(TAG, &quot;bound workspace in &quot;
1726                             + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
1727                     }
1728 
1729                     mIsLoadingAndBindingWorkspace = false;
1730                 }
1731             };
1732             if (isLoadingSynchronously) {
1733                 mDeferredBindRunnables.add(r);
1734             } else {
1735                 runOnMainThread(r);
1736             }
1737         }
1738 
1739         private void loadAndBindAllApps() {
1740             if (DEBUG_LOADERS) {
1741                 Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
1742             }
1743             if (!mAllAppsLoaded) {
1744                 loadAllAppsByBatch();
1745                 synchronized (LoaderTask.this) {
1746                     if (mStopped) {
1747                         return;
1748                     }
1749                     mAllAppsLoaded = true;
1750                 }
1751             } else {
1752                 onlyBindAllApps();
1753             }
1754         }
1755 
1756         private void onlyBindAllApps() {
1757             final Callbacks oldCallbacks = mCallbacks.get();
1758             if (oldCallbacks == null) {
1759                 // This launcher has exited and nobody bothered to tell us.  Just bail.
1760                 Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
1761                 return;
1762             }
1763             // shallow copy
1764             @SuppressWarnings(&quot;unchecked&quot;)
<abbr title="1765             final ArrayList&lt;ApplicationInfo&gt; list = ((ArrayList&lt;ApplicationInfo&gt;) (mBgAllAppsList.data.clone()));">1765             final ArrayList&lt;ApplicationInfo&gt; list = ((ArrayList&lt;ApplicationInfo&gt;) (mBgAllAppsList.data.clðŸ”µ</abbr>
1766             Runnable r = new Runnable() {
1767                 public void run() {
1768                     final long t = SystemClock.uptimeMillis();
1769                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1770                     if (callbacks != null) {
1771                         callbacks.bindAllApplications(list);
1772                     }
1773                     if (DEBUG_LOADERS) {
<abbr title="1774                         Log.d(TAG, (((&quot;bound all &quot; + list.size()) + &quot; apps from cache in &quot;) + (SystemClock.uptimeMillis() - t)) + &quot;ms&quot;);">1774                         Log.d(TAG, (((&quot;bound all &quot; + list.size()) + &quot; apps from cache in &quot;) + (SystemClocðŸ”µ</abbr>
1775                     }
1776                 }
1777             };
1778             boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
1779             if (oldCallbacks.isAllAppsVisible() &amp;&amp; isRunningOnMainThread) {
1780                 r.run();
1781             } else {
1782                 mHandler.post(r);
1783             }
1784         }
1785 
1786         private void loadAllAppsByBatch() {
1787             final long t = (DEBUG_LOADERS) ? SystemClock.uptimeMillis() : 0;
1788             // Don&#x27;t use these two variables in any of the callback runnables.
1789             // Otherwise we hold a reference to them.
1790             final Callbacks oldCallbacks = mCallbacks.get();
1791             if (oldCallbacks == null) {
1792                 // This launcher has exited and nobody bothered to tell us.  Just bail.
1793                 Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllAppsByBatch)&quot;);
1794                 return;
1795             }
1796             final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
1797             mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
1798             final PackageManager packageManager = mContext.getPackageManager();
1799             List&lt;ResolveInfo&gt; apps = null;
1800             int N = Integer.MAX_VALUE;
1801             int startIndex;
1802             int i = 0;
1803             int batchSize = -1;
1804             while ((i &lt; N) &amp;&amp; (!mStopped)) {
1805                 if (i == 0) {
1806                     mBgAllAppsList.clear();
1807                     final long qiaTime = (DEBUG_LOADERS) ? SystemClock.uptimeMillis() : 0;
1808                     apps = packageManager.queryIntentActivities(mainIntent, 0);
1809                     if (DEBUG_LOADERS) {
<abbr title="1810                         Log.d(TAG, (&quot;queryIntentActivities took &quot; + (SystemClock.uptimeMillis() - qiaTime)) + &quot;ms&quot;);">1810                         Log.d(TAG, (&quot;queryIntentActivities took &quot; + (SystemClock.uptimeMillis() - qiaTimeðŸ”µ</abbr>
1811                     }
1812                     if (apps == null) {
1813                         return;
1814                     }
1815                     N = apps.size();
1816                     if (DEBUG_LOADERS) {
1817                         Log.d(TAG, (&quot;queryIntentActivities got &quot; + N) + &quot; apps&quot;);
1818                     }
1819                     if (N == 0) {
1820                         // There are no apps?!?
1821                         return;
1822                     }
1823                     if (mBatchSize == 0) {
1824                         batchSize = N;
1825                     } else {
1826                         batchSize = mBatchSize;
1827                     }
1828                     final long sortTime = (DEBUG_LOADERS) ? SystemClock.uptimeMillis() : 0;
<abbr title="1829                     Collections.sort(apps, new LauncherModel.ShortcutNameComparator(packageManager, mLabelCache));">1829                     Collections.sort(apps, new LauncherModel.ShortcutNameComparator(packageManager, mLabeðŸ”µ</abbr>
1830                     if (DEBUG_LOADERS) {
1831                         Log.d(TAG, (&quot;sort took &quot; + (SystemClock.uptimeMillis() - sortTime)) + &quot;ms&quot;);
1832                     }
1833                 }
1834                 final long t2 = (DEBUG_LOADERS) ? SystemClock.uptimeMillis() : 0;
1835                 startIndex = i;
1836                 for (int j = 0; (i &lt; N) &amp;&amp; (j &lt; batchSize); j++) {
1837                     // This builds the icon bitmaps.
<abbr title="1838                     mBgAllAppsList.add(new ApplicationInfo(packageManager, apps.get(i), mIconCache, mLabelCache));">1838                     mBgAllAppsList.add(new ApplicationInfo(packageManager, apps.get(i), mIconCache, mLabeðŸ”µ</abbr>
1839                     i++;
1840                 }
1841                 final boolean first = i &lt;= batchSize;
1842                 final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1843                 final ArrayList&lt;ApplicationInfo&gt; added = mBgAllAppsList.added;
1844                 mBgAllAppsList.added = new ArrayList&lt;ApplicationInfo&gt;();
1845                 mHandler.post(new Runnable() {
1846                     public void run() {
1847                         final long t = SystemClock.uptimeMillis();
1848                         if (callbacks != null) {
1849                             if (first) {
1850                                 callbacks.bindAllApplications(added);
1851                             } else {
1852                                 callbacks.bindAppsAdded(added);
1853                             }
1854                             if (DEBUG_LOADERS) {
<abbr title="1855                                 Log.d(TAG, (((&quot;bound &quot; + added.size()) + &quot; apps in &quot;) + (SystemClock.uptimeMillis() - t)) + &quot;ms&quot;);">1855                                 Log.d(TAG, (((&quot;bound &quot; + added.size()) + &quot; apps in &quot;) + (SystemClock.uptiðŸ”µ</abbr>
1856                             }
1857                         } else {
1858                             Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
1859                         }
1860                     }
1861                 });
1862                 if (DEBUG_LOADERS) {
<abbr title="1863                     Log.d(TAG, (((&quot;batch of &quot; + (i - startIndex)) + &quot; icons processed in &quot;) + (SystemClock.uptimeMillis() - t2)) + &quot;ms&quot;);">1863                     Log.d(TAG, (((&quot;batch of &quot; + (i - startIndex)) + &quot; icons processed in &quot;) + (SystemClocðŸ”µ</abbr>
1864                 }
1865                 if ((mAllAppsLoadDelay &gt; 0) &amp;&amp; (i &lt; N)) {
1866                     try {
1867                         if (DEBUG_LOADERS) {
1868                             Log.d(TAG, (&quot;sleeping for &quot; + mAllAppsLoadDelay) + &quot;ms&quot;);
1869                         }
1870                         Thread.sleep(mAllAppsLoadDelay);
1871                     } catch (java.lang.InterruptedException exc) {
1872                     }
1873                 }
1874             }
1875             if (DEBUG_LOADERS) {
<abbr title="1876                 Log.d(TAG, ((((&quot;cached all &quot; + N) + &quot; apps in &quot;) + (SystemClock.uptimeMillis() - t)) + &quot;ms&quot;) + (mAllAppsLoadDelay &gt; 0 ? &quot; (including delay)&quot; : &quot;&quot;));">1876                 Log.d(TAG, ((((&quot;cached all &quot; + N) + &quot; apps in &quot;) + (SystemClock.uptimeMillis() - t)) + &quot;mðŸ”µ</abbr>
1877             }
1878         }
1879 
1880         public void dumpState() {
1881             synchronized (sBgLock) {
1882                 Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
1883                 Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
1884                 Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
1885                 Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
1886                 Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
1887             }
1888         }
1889     }
1890 
1891     void enqueuePackageUpdated(PackageUpdatedTask task) {
1892         sWorker.post(task);
1893     }
1894 
1895     private class PackageUpdatedTask implements Runnable {
1896         int mOp;
1897 
1898         String[] mPackages;
1899 
1900         public static final int OP_NONE = 0;
1901 
1902         public static final int OP_ADD = 1;
1903 
1904         public static final int OP_UPDATE = 2;
1905 
1906         // uninstlled
1907         public static final int OP_REMOVE = 3; // uninstlled
1908 
1909         // external media unmounted
1910         public static final int OP_UNAVAILABLE = 4; // external media unmounted
1911 
1912         public PackageUpdatedTask(int op, String[] packages) {
1913             mOp = op;
1914             mPackages = packages;
1915         }
1916 
1917         public void run() {
1918             final Context context = mApp;
1919             final String[] packages = mPackages;
1920             final int N = packages.length;
1921             switch (mOp) {
1922                 case OP_ADD :
1923                     for (int i = 0; i &lt; N; i++) {
1924                         if (DEBUG_LOADERS) {
1925                             Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
1926                         }
1927                         mBgAllAppsList.addPackage(context, packages[i]);
1928                     }
1929                     break;
1930                 case OP_UPDATE :
1931                     for (int i = 0; i &lt; N; i++) {
1932                         if (DEBUG_LOADERS) {
1933                             Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
1934                         }
1935                         mBgAllAppsList.updatePackage(context, packages[i]);
1936                     }
1937                     break;
1938                 case OP_REMOVE :
1939                 case OP_UNAVAILABLE :
1940                     for (int i = 0; i &lt; N; i++) {
1941                         if (DEBUG_LOADERS) {
1942                             Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
1943                         }
1944                         mBgAllAppsList.removePackage(packages[i]);
1945                     }
1946                     break;
1947             }
1948             ArrayList&lt;ApplicationInfo&gt; added = null;
1949             ArrayList&lt;ApplicationInfo&gt; modified = null;
1950             if (mBgAllAppsList.added.size() &gt; 0) {
1951                 added = new ArrayList&lt;ApplicationInfo&gt;(mBgAllAppsList.added);
1952                 mBgAllAppsList.added.clear();
1953             }
1954             if (mBgAllAppsList.modified.size() &gt; 0) {
1955                 modified = new ArrayList&lt;ApplicationInfo&gt;(mBgAllAppsList.modified);
1956                 mBgAllAppsList.modified.clear();
1957             }
1958             // We may be removing packages that have no associated launcher application, so we
1959             // pass through the removed package names directly.
1960             // NOTE: We flush the icon cache aggressively in removePackage() above.
1961             final ArrayList&lt;String&gt; removedPackageNames = new ArrayList&lt;String&gt;();
1962             if (mBgAllAppsList.removed.size() &gt; 0) {
1963                 mBgAllAppsList.removed.clear();
1964                 for (int i = 0; i &lt; N; ++i) {
1965                     removedPackageNames.add(packages[i]);
1966                 }
1967             }
1968             final Callbacks callbacks = (mCallbacks != null) ? mCallbacks.get() : null;
1969             if (callbacks == null) {
1970                 Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
1971                 return;
1972             }
1973             if (added != null) {
1974                 final ArrayList&lt;ApplicationInfo&gt; addedFinal = added;
1975                 mHandler.post(new Runnable() {
1976                     public void run() {
1977                         Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
1978                         if ((callbacks == cb) &amp;&amp; (cb != null)) {
1979                             callbacks.bindAppsAdded(addedFinal);
1980                         }
1981                     }
1982                 });
1983             }
1984             if (modified != null) {
1985                 final ArrayList&lt;ApplicationInfo&gt; modifiedFinal = modified;
1986                 mHandler.post(new Runnable() {
1987                     public void run() {
1988                         Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
1989                         if ((callbacks == cb) &amp;&amp; (cb != null)) {
1990                             callbacks.bindAppsUpdated(modifiedFinal);
1991                         }
1992                     }
1993                 });
1994             }
1995             if (!removedPackageNames.isEmpty()) {
1996                 final boolean permanent = mOp != OP_UNAVAILABLE;
1997                 mHandler.post(new Runnable() {
1998                     public void run() {
1999                         Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
2000                         if ((callbacks == cb) &amp;&amp; (cb != null)) {
2001                             callbacks.bindAppsRemoved(removedPackageNames, permanent);
2002                         }
2003                     }
2004                 });
2005             }
2006             mHandler.post(new Runnable() {
2007                 @Override
2008                 public void run() {
2009                     Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
2010                     if ((callbacks == cb) &amp;&amp; (cb != null)) {
2011                         callbacks.bindPackagesUpdated();
2012                     }
2013                 }
2014             });
2015         }
2016     }
2017 
2018     /**
2019      * This is called from the code that adds shortcuts from the intent receiver.  This
2020      * doesn&#x27;t have a Cursor, but
2021      */
2022     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context) {
2023         return getShortcutInfo(manager, intent, context, null, -1, -1, null);
2024     }
2025 
2026     /**
2027      * Make an ShortcutInfo object for a shortcut that is an application.
2028      *
2029      * If c is not null, then it will be used to fill in missing data like the title and icon.
2030      */
2031     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context,
2032             Cursor c, int iconIndex, int titleIndex, HashMap&lt;Object, CharSequence&gt; labelCache) {
2033         Bitmap icon = null;
2034         final ShortcutInfo info = new ShortcutInfo();
2035 
2036         ComponentName componentName = intent.getComponent();
2037         if (componentName == null) {
2038             return null;
2039         }
2040 
2041         try {
2042             PackageInfo pi = manager.getPackageInfo(componentName.getPackageName(), 0);
2043             if (!pi.applicationInfo.enabled) {
2044                 // If we return null here, the corresponding item will be removed from the launcher
2045                 // db and will not appear in the workspace.
2046                 return null;
2047             }
2048         } catch (NameNotFoundException e) {
2049             Log.d(TAG, &quot;getPackInfo failed for package &quot; + componentName.getPackageName());
2050         }
2051 
2052         // TODO: See if the PackageManager knows about this case.  If it doesn&#x27;t
2053         // then return null &amp; delete this.
2054 
2055         // the resource -- This may implicitly give us back the fallback icon,
2056         // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
2057         // to avoid saving lots of copies of that in the database, and most apps
2058         // have icons anyway.
2059 
2060         // Attempt to use queryIntentActivities to get the ResolveInfo (with IntentFilter info) and
2061         // if that fails, or is ambiguious, fallback to the standard way of getting the resolve info
2062         // via resolveActivity().
2063         ResolveInfo resolveInfo = null;
2064         ComponentName oldComponent = intent.getComponent();
2065         Intent newIntent = new Intent(intent.getAction(), null);
2066         newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2067         newIntent.setPackage(oldComponent.getPackageName());
2068         List&lt;ResolveInfo&gt; infos = manager.queryIntentActivities(newIntent, 0);
2069         for (ResolveInfo i : infos) {
2070             ComponentName cn = new ComponentName(i.activityInfo.packageName,
2071                     i.activityInfo.name);
2072             if (cn.equals(oldComponent)) {
2073                 resolveInfo = i;
2074             }
2075         }
2076         if (resolveInfo == null) {
2077             resolveInfo = manager.resolveActivity(intent, 0);
2078         }
2079         if (resolveInfo != null) {
2080             icon = mIconCache.getIcon(componentName, resolveInfo, labelCache);
2081         }
2082         // the db
2083         if (icon == null) {
2084             if (c != null) {
2085                 icon = getIconFromCursor(c, iconIndex, context);
2086             }
2087         }
2088         // the fallback icon
2089         if (icon == null) {
2090             icon = getFallbackIcon();
2091             info.usingFallbackIcon = true;
2092         }
2093         info.setIcon(icon);
2094 
2095         // from the resource
2096         if (resolveInfo != null) {
2097             ComponentName key = LauncherModel.getComponentNameFromResolveInfo(resolveInfo);
2098             if (labelCache != null &amp;&amp; labelCache.containsKey(key)) {
2099                 info.title = labelCache.get(key);
2100             } else {
2101                 info.title = resolveInfo.activityInfo.loadLabel(manager);
2102                 if (labelCache != null) {
2103                     labelCache.put(key, info.title);
2104                 }
2105             }
2106         }
2107         // from the db
2108         if (info.title == null) {
2109             if (c != null) {
2110                 info.title =  c.getString(titleIndex);
2111             }
2112         }
2113         // fall back to the class name of the activity
2114         if (info.title == null) {
2115             info.title = componentName.getClassName();
2116         }
2117         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
2118         return info;
2119     }
2120 
2121     /**
2122      * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
2123      */
2124     private ShortcutInfo getShortcutInfo(Cursor c, Context context,
2125             int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
2126             int titleIndex) {
2127 
2128         Bitmap icon = null;
2129         final ShortcutInfo info = new ShortcutInfo();
2130         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
2131 
2132         // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
2133 
2134         info.title = c.getString(titleIndex);
2135 
2136         int iconType = c.getInt(iconTypeIndex);
2137         switch (iconType) {
2138         case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
2139             String packageName = c.getString(iconPackageIndex);
2140             String resourceName = c.getString(iconResourceIndex);
2141             PackageManager packageManager = context.getPackageManager();
2142             info.customIcon = false;
2143             // the resource
2144             try {
2145                 Resources resources = packageManager.getResourcesForApplication(packageName);
2146                 if (resources != null) {
2147                     final int id = resources.getIdentifier(resourceName, null, null);
2148                     icon = Utilities.createIconBitmap(
2149                             mIconCache.getFullResIcon(resources, id), context);
2150                 }
2151             } catch (Exception e) {
2152                 // drop this.  we have other places to look for icons
2153             }
2154             // the db
2155             if (icon == null) {
2156                 icon = getIconFromCursor(c, iconIndex, context);
2157             }
2158             // the fallback icon
2159             if (icon == null) {
2160                 icon = getFallbackIcon();
2161                 info.usingFallbackIcon = true;
2162             }
2163             break;
2164         case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
2165             icon = getIconFromCursor(c, iconIndex, context);
2166             if (icon == null) {
2167                 icon = getFallbackIcon();
2168                 info.customIcon = false;
2169                 info.usingFallbackIcon = true;
2170             } else {
2171                 info.customIcon = true;
2172             }
2173             break;
2174         default:
2175             icon = getFallbackIcon();
2176             info.usingFallbackIcon = true;
2177             info.customIcon = false;
2178             break;
2179         }
2180         info.setIcon(icon);
2181         return info;
2182     }
2183 
2184     Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
2185         @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
2186         final boolean debug = false;
2187         if (debug) {
2188             Log.d(TAG, &quot;getIconFromCursor app=&quot;
2189                     + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
2190         }
2191         byte[] data = c.getBlob(iconIndex);
2192         try {
2193             return Utilities.createIconBitmap(
2194                     BitmapFactory.decodeByteArray(data, 0, data.length), context);
2195         } catch (Exception e) {
2196             return null;
2197         }
2198     }
2199 
2200     ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
2201             int cellX, int cellY, boolean notify) {
2202         final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
2203         if (info == null) {
2204             return null;
2205         }
2206         addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
2207 
2208         return info;
2209     }
2210 
2211     /**
2212      * Attempts to find an AppWidgetProviderInfo that matches the given component.
2213      */
2214     AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,
2215             ComponentName component) {
2216         List&lt;AppWidgetProviderInfo&gt; widgets =
2217             AppWidgetManager.getInstance(context).getInstalledProviders();
2218         for (AppWidgetProviderInfo info : widgets) {
2219             if (info.provider.equals(component)) {
2220                 return info;
2221             }
2222         }
2223         return null;
2224     }
2225 
2226     /**
2227      * Returns a list of all the widgets that can handle configuration with a particular mimeType.
2228      */
2229     List&lt;WidgetMimeTypeHandlerData&gt; resolveWidgetsForMimeType(Context context, String mimeType) {
2230         final PackageManager packageManager = context.getPackageManager();
2231         final List&lt;WidgetMimeTypeHandlerData&gt; supportedConfigurationActivities =
2232             new ArrayList&lt;WidgetMimeTypeHandlerData&gt;();
2233 
2234         final Intent supportsIntent =
2235             new Intent(InstallWidgetReceiver.ACTION_SUPPORTS_CLIPDATA_MIMETYPE);
2236         supportsIntent.setType(mimeType);
2237 
2238         // Create a set of widget configuration components that we can test against
2239         final List&lt;AppWidgetProviderInfo&gt; widgets =
2240             AppWidgetManager.getInstance(context).getInstalledProviders();
2241         final HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; configurationComponentToWidget =
2242             new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;();
2243         for (AppWidgetProviderInfo info : widgets) {
2244             configurationComponentToWidget.put(info.configure, info);
2245         }
2246 
2247         // Run through each of the intents that can handle this type of clip data, and cross
2248         // reference them with the components that are actual configuration components
2249         final List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(supportsIntent,
2250                 PackageManager.MATCH_DEFAULT_ONLY);
2251         for (ResolveInfo info : activities) {
2252             final ActivityInfo activityInfo = info.activityInfo;
2253             final ComponentName infoComponent = new ComponentName(activityInfo.packageName,
2254                     activityInfo.name);
2255             if (configurationComponentToWidget.containsKey(infoComponent)) {
2256                 supportedConfigurationActivities.add(
2257                         new InstallWidgetReceiver.WidgetMimeTypeHandlerData(info,
2258                                 configurationComponentToWidget.get(infoComponent)));
2259             }
2260         }
2261         return supportedConfigurationActivities;
2262     }
2263 
2264     ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
2265         Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
2266         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
2267         Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
2268 
2269         if (intent == null) {
2270             // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
2271             Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
2272             return null;
2273         }
2274 
2275         Bitmap icon = null;
2276         boolean customIcon = false;
2277         ShortcutIconResource iconResource = null;
2278 
2279         if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {
2280             icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);
2281             customIcon = true;
2282         } else {
2283             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
2284             if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {
2285                 try {
2286                     iconResource = (ShortcutIconResource) extra;
2287                     final PackageManager packageManager = context.getPackageManager();
2288                     Resources resources = packageManager.getResourcesForApplication(
2289                             iconResource.packageName);
2290                     final int id = resources.getIdentifier(iconResource.resourceName, null, null);
2291                     icon = Utilities.createIconBitmap(
2292                             mIconCache.getFullResIcon(resources, id), context);
2293                 } catch (Exception e) {
2294                     Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);
2295                 }
2296             }
2297         }
2298 
2299         final ShortcutInfo info = new ShortcutInfo();
2300 
2301         if (icon == null) {
2302             if (fallbackIcon != null) {
2303                 icon = fallbackIcon;
2304             } else {
2305                 icon = getFallbackIcon();
2306                 info.usingFallbackIcon = true;
2307             }
2308         }
2309         info.setIcon(icon);
2310 
2311         info.title = name;
2312         info.intent = intent;
2313         info.customIcon = customIcon;
2314         info.iconResource = iconResource;
2315 
2316         return info;
2317     }
2318 
2319     boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
2320             int iconIndex) {
2321         // If apps can&#x27;t be on SD, don&#x27;t even bother.
2322         if (!mAppsCanBeOnExternalStorage) {
2323             return false;
2324         }
2325         // If this icon doesn&#x27;t have a custom icon, check to see
2326         // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
2327         // we&#x27;re going to show, store what we are going to show back
2328         // into the DB.  We do this so when we&#x27;re loading, if the
2329         // package manager can&#x27;t find an icon (for example because
2330         // the app is on SD) then we can use that instead.
2331         if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
2332             cache.put(info, c.getBlob(iconIndex));
2333             return true;
2334         }
2335         return false;
2336     }
2337 
2338     void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
2339         boolean needSave = false;
2340         try {
2341             if (data != null) {
2342                 Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
2343                 Bitmap loaded = info.getIcon(mIconCache);
2344                 needSave = !saved.sameAs(loaded);
2345             } else {
2346                 needSave = true;
2347             }
2348         } catch (Exception e) {
2349             needSave = true;
2350         }
2351         if (needSave) {
2352             Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
2353             // This is slower than is ideal, but this only happens once
2354             // or when the app is updated with a new icon.
2355             updateItemInDatabase(context, info);
2356         }
2357     }
2358 
2359     /**
2360      * Return an existing FolderInfo object if we have encountered this ID previously,
2361      * or make a new one.
2362      */
2363     private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
2364         // See if a placeholder was created for us already
2365         FolderInfo folderInfo = folders.get(id);
2366         if (folderInfo == null) {
2367             // No placeholder -- create a new instance
2368             folderInfo = new FolderInfo();
2369             folders.put(id, folderInfo);
2370         }
2371         return folderInfo;
2372     }
2373 
2374     private static final Collator sCollator = Collator.getInstance();
2375 
<abbr title="2376     public static final Comparator&lt;ApplicationInfo&gt; APP_NAME_COMPARATOR = new Comparator&lt;ApplicationInfo&gt;() {">2376     public static final Comparator&lt;ApplicationInfo&gt; APP_NAME_COMPARATOR = new Comparator&lt;ApplicationInfo&gt;ðŸ”µ</abbr>
2377         public final int compare(ApplicationInfo a, ApplicationInfo b) {
2378             int result = sCollator.compare(a.title.toString(), b.title.toString());
2379             if (result == 0) {
2380                 result = a.componentName.compareTo(b.componentName);
2381             }
2382             return result;
2383         }
2384     };
2385 
<abbr title="2386     public static final Comparator&lt;ApplicationInfo&gt; APP_INSTALL_TIME_COMPARATOR = new Comparator&lt;ApplicationInfo&gt;() {">2386     public static final Comparator&lt;ApplicationInfo&gt; APP_INSTALL_TIME_COMPARATOR = new Comparator&lt;ApplicatðŸ”µ</abbr>
2387         public final int compare(ApplicationInfo a, ApplicationInfo b) {
2388             if (a.firstInstallTime &lt; b.firstInstallTime) {
2389                 return 1;
2390             }
2391             if (a.firstInstallTime &gt; b.firstInstallTime) {
2392                 return -1;
2393             }
2394             return 0;
2395         }
2396     };
2397 
<abbr title="2398     public static final Comparator&lt;AppWidgetProviderInfo&gt; WIDGET_NAME_COMPARATOR = new Comparator&lt;AppWidgetProviderInfo&gt;() {">2398     public static final Comparator&lt;AppWidgetProviderInfo&gt; WIDGET_NAME_COMPARATOR = new Comparator&lt;AppWidgðŸ”µ</abbr>
2399         public final int compare(AppWidgetProviderInfo a, AppWidgetProviderInfo b) {
2400             return sCollator.compare(a.label.toString(), b.label.toString());
2401         }
2402     };
2403 
2404     static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
2405         if (info.activityInfo != null) {
2406             return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
2407         } else {
2408             return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
2409         }
2410     }
2411 
2412     public static class ShortcutNameComparator implements Comparator&lt;ResolveInfo&gt; {
2413         private PackageManager mPackageManager;
2414 
2415         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
2416 
2417         ShortcutNameComparator(PackageManager pm) {
2418             mPackageManager = pm;
2419             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
2420         }
2421 
2422         ShortcutNameComparator(PackageManager pm, HashMap&lt;Object, CharSequence&gt; labelCache) {
2423             mPackageManager = pm;
2424             mLabelCache = labelCache;
2425         }
2426 
2427         public final int compare(ResolveInfo a, ResolveInfo b) {
2428             CharSequence labelA;
2429             CharSequence labelB;
2430             ComponentName keyA = LauncherModel.getComponentNameFromResolveInfo(a);
2431             ComponentName keyB = LauncherModel.getComponentNameFromResolveInfo(b);
2432             if (mLabelCache.containsKey(keyA)) {
2433                 labelA = mLabelCache.get(keyA);
2434             } else {
2435                 labelA = a.loadLabel(mPackageManager).toString();
2436                 mLabelCache.put(keyA, labelA);
2437             }
2438             if (mLabelCache.containsKey(keyB)) {
2439                 labelB = mLabelCache.get(keyB);
2440             } else {
2441                 labelB = b.loadLabel(mPackageManager).toString();
2442                 mLabelCache.put(keyB, labelB);
2443             }
2444             return sCollator.compare(labelA, labelB);
2445         }
2446     }
2447 
2448     public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
2449         private PackageManager mPackageManager;
2450 
2451         private HashMap&lt;Object, String&gt; mLabelCache;
2452 
2453         WidgetAndShortcutNameComparator(PackageManager pm) {
2454             mPackageManager = pm;
2455             mLabelCache = new HashMap&lt;Object, String&gt;();
2456         }
2457 
2458         public final int compare(Object a, Object b) {
2459             String labelA;
2460             String labelB;
2461             if (mLabelCache.containsKey(a)) {
2462                 labelA = mLabelCache.get(a);
2463             } else {
<abbr title="2464                 labelA = (a instanceof AppWidgetProviderInfo) ? ((AppWidgetProviderInfo) (a)).label : ((ResolveInfo) (a)).loadLabel(mPackageManager).toString();">2464                 labelA = (a instanceof AppWidgetProviderInfo) ? ((AppWidgetProviderInfo) (a)).label : ((RðŸ”µ</abbr>
2465                 mLabelCache.put(a, labelA);
2466             }
2467             if (mLabelCache.containsKey(b)) {
2468                 labelB = mLabelCache.get(b);
2469             } else {
<abbr title="2470                 labelB = (b instanceof AppWidgetProviderInfo) ? ((AppWidgetProviderInfo) (b)).label : ((ResolveInfo) (b)).loadLabel(mPackageManager).toString();">2470                 labelB = (b instanceof AppWidgetProviderInfo) ? ((AppWidgetProviderInfo) (b)).label : ((RðŸ”µ</abbr>
2471                 mLabelCache.put(b, labelB);
2472             }
2473             return sCollator.compare(labelA, labelB);
2474         }
2475     }
2476 
2477     public void dumpState() {
2478         Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
2479         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
2480         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
2481         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
2482         ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
2483         if (mLoaderTask != null) {
2484             mLoaderTask.dumpState();
2485         } else {
2486             Log.d(TAG, &quot;mLoaderTask=null&quot;);
2487         }
2488     }
2489 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher2;
  18  
  19  import android.app.SearchManager;
  20  import android.appwidget.AppWidgetManager;
  21  import android.appwidget.AppWidgetProviderInfo;
  22  import android.content.BroadcastReceiver;
  23  import android.content.ComponentName;
  24  import android.content.ContentProviderClient;
  25  import android.content.ContentResolver;
  26  import android.content.ContentValues;
  27  import android.content.Context;
  28  import android.content.Intent;
  29  import android.content.Intent.ShortcutIconResource;
  30  import android.content.pm.ActivityInfo;
  31  import android.content.pm.PackageInfo;
  32  import android.content.pm.PackageManager;
  33  import android.content.pm.PackageManager.NameNotFoundException;
  34  import android.content.pm.ResolveInfo;
  35  import android.content.res.Configuration;
  36  import android.content.res.Resources;
  37  import android.database.Cursor;
  38  import android.graphics.Bitmap;
  39  import android.graphics.BitmapFactory;
  40  import android.net.Uri;
  41  import android.os.Environment;
  42  import android.os.Handler;
  43  import android.os.HandlerThread;
  44  import android.os.Parcelable;
  45  import android.os.Process;
  46  import android.os.RemoteException;
  47  import android.os.SystemClock;
  48  import android.util.Log;
  49  
  50  import com.android.launcher.R;
  51  import com.android.launcher2.InstallWidgetReceiver.WidgetMimeTypeHandlerData;
  52  
  53  import java.lang.ref.WeakReference;
  54  import java.net.URISyntaxException;
  55  import java.text.Collator;
  56  import java.util.ArrayList;
  57  import java.util.Collections;
  58  import java.util.Comparator;
  59  import java.util.HashMap;
  60  import java.util.HashSet;
  61  import java.util.Iterator;
  62  import java.util.List;
  63  import java.util.Set;
  64  
  65  /**
  66   * Maintains in-memory state of the Launcher. It is expected that there should be only one
  67   * LauncherModel object held in a static. Also provide APIs for updating the database state
  68   * for the Launcher.
  69   */
  70  public class LauncherModel extends BroadcastReceiver {
  71      static final boolean DEBUG_LOADERS = false;
  72      static final String TAG = &quot;Launcher.Model&quot;;
  73  
  74      private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
  75      private final boolean mAppsCanBeOnExternalStorage;
  76      private int mBatchSize; // 0 is all apps at once
  77      private int mAllAppsLoadDelay; // milliseconds between batches
  78  
  79      private final LauncherApplication mApp;
  80      private final Object mLock = new Object();
  81      private DeferredHandler mHandler = new DeferredHandler();
  82      private LoaderTask mLoaderTask;
  83      private boolean mIsLoaderTaskRunning;
  84  
  85      private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
  86      static {
  87          sWorkerThread.start();
  88      }
  89      private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
  90  
  91      // We start off with everything not loaded.  After that, we assume that
  92      // our monitoring of the package manager provides all updates and we never
  93      // need to do a requery.  These are only ever touched from the loader thread.
  94      private boolean mWorkspaceLoaded;
  95      private boolean mAllAppsLoaded;
  96  
  97      // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
  98      // pages as this delays the rotation process.  Instead, we wait for a callback from the first
  99      // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 100      // a normal load, we also clear this set of Runnables.
 101      static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 102  
 103      private WeakReference&lt;Callbacks&gt; mCallbacks;
 104  
 105      // &lt; only access in worker thread &gt;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 106 -    private AllAppsList mAllAppsList;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 107 +    private AllAppsList mBgAllAppsList;</span>
 108  
 109      // The lock that must be acquired before referencing any static bg data structures.  Unlike
 110      // other locks, this one can generally be held long-term because we never expect any of these
 111      // static data structures to be referenced outside of the worker thread except on the first
 112      // load after configuration change.
 113      static final Object sBgLock = new Object();
 114  
 115      // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 116      // LauncherModel to their ids
 117      static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
 118  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 119 -    // sBgItems is passed to bindItems, which expects a list of all folders and shortcuts created by</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 120 -    //       LauncherModel that are directly on the home screen (however, no widgets or shortcuts</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 121 -    //       within folders).</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 122 +    // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 123 +    //       created by LauncherModel that are directly on the home screen (however, no widgets or</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 124 +    //       shortcuts within folders).</span>
 125      static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 126  
 127      // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 128      static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 129          new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 130  
 131      // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 132      static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 133  
 134      // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 135      static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 136 -</span>
 137      // &lt;/ only access in worker thread &gt;
 138  
 139      private IconCache mIconCache;
 140      private Bitmap mDefaultIcon;
 141  
 142      private static int mCellCountX;
 143      private static int mCellCountY;
 144  
 145      protected int mPreviousConfigMcc;
 146  
 147      public interface Callbacks {
 148          public boolean setLoadOnResume();
 149          public int getCurrentWorkspaceScreen();
 150          public void startBinding();
 151          public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end);
 152          public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 153          public void finishBindingItems();
 154          public void bindAppWidget(LauncherAppWidgetInfo info);
 155          public void bindAllApplications(ArrayList&lt;ApplicationInfo&gt; apps);
 156          public void bindAppsAdded(ArrayList&lt;ApplicationInfo&gt; apps);
 157          public void bindAppsUpdated(ArrayList&lt;ApplicationInfo&gt; apps);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 158 -        public void bindAppsRemoved(ArrayList&lt;ApplicationInfo&gt; apps, boolean permanent);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 159 +        public void bindAppsRemoved(ArrayList&lt;String&gt; packageNames, boolean permanent);</span>
 160          public void bindPackagesUpdated();
 161          public boolean isAllAppsVisible();
 162          public boolean isAllAppsButtonRank(int rank);
 163          public void bindSearchablesChanged();
 164          public void onPageBoundSynchronously(int page);
 165      }
 166  
 167      LauncherModel(LauncherApplication app, IconCache iconCache) {
 168          mAppsCanBeOnExternalStorage = !Environment.isExternalStorageEmulated();
 169          mApp = app;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 170 -        mAllAppsList = new AllAppsList(iconCache);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 171 +        mBgAllAppsList = new AllAppsList(iconCache);</span>
 172          mIconCache = iconCache;
 173  
 174          mDefaultIcon = Utilities.createIconBitmap(
 175                  mIconCache.getFullResDefaultActivityIcon(), app);
 176  
 177          final Resources res = app.getResources();
 178          mAllAppsLoadDelay = res.getInteger(R.integer.config_allAppsBatchLoadDelay);
 179          mBatchSize = res.getInteger(R.integer.config_allAppsBatchSize);
 180          Configuration config = res.getConfiguration();
 181          mPreviousConfigMcc = config.mcc;
 182      }
 183  
 184      /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 185       * posted on the main thread handler. */
 186      private void runOnMainThread(Runnable r) {
 187          if (sWorkerThread.getThreadId() == Process.myTid()) {
 188              // If we are on the worker thread, post onto the main handler
 189              mHandler.post(r);
 190          } else {
 191              r.run();
 192          }
 193      }
 194  
 195      /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 196       * posted on the worker thread handler. */
 197      private static void runOnWorkerThread(Runnable r) {
 198          if (sWorkerThread.getThreadId() == Process.myTid()) {
 199              r.run();
 200          } else {
 201              // If we are not on the worker thread, then post to the worker handler
 202              sWorker.post(r);
 203          }
 204      }
 205  
 206      public Bitmap getFallbackIcon() {
 207          return Bitmap.createBitmap(mDefaultIcon);
 208      }
 209  
 210      public void unbindWorkspaceItems() {
 211          sWorker.post(new Runnable() {
 212              @Override
 213              public void run() {
 214                  unbindWorkspaceItemsOnMainThread();
 215              }
 216          });
 217      }
 218  
 219      /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 220      private void unbindWorkspaceItemsOnMainThread() {
 221          // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 222          // by making a copy of workspace items first.
 223          final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 224          final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 225          synchronized (sBgLock) {
 226              tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 227              tmpAppWidgets.addAll(sBgAppWidgets);
 228          }
 229          Runnable r = new Runnable() {
 230                  @Override
 231                  public void run() {
 232                     for (ItemInfo item : tmpWorkspaceItems) {
 233                         item.unbind();
 234                     }
 235                     for (ItemInfo item : tmpAppWidgets) {
 236                         item.unbind();
 237                     }
 238                  }
 239              };
 240          runOnMainThread(r);
 241      }
 242  
 243      /**
 244       * Adds an item to the DB if it was not created previously, or move it to a new
 245       * &lt;container, screen, cellX, cellY&gt;
 246       */
 247      static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 248              int screen, int cellX, int cellY) {
 249          if (item.container == ItemInfo.NO_ID) {
 250              // From all apps
 251              addItemToDatabase(context, item, container, screen, cellX, cellY, false);
 252          } else {
 253              // From somewhere else
 254              moveItemInDatabase(context, item, container, screen, cellX, cellY);
 255          }
 256      }
 257  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 258 +    static void checkItemInfo(final ItemInfo item) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 259 +        final StackTraceElement[] stackTrace = new Throwable().getStackTrace();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 260 +        final long itemId = item.id;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 261 +        Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 262 +                public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 263 +                    synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 264 +                        ItemInfo modelItem = sBgItemsIdMap.get(itemId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 265 +                        if (modelItem != null &amp;&amp; item != modelItem) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 266 +                            // the modelItem needs to match up perfectly with item if our model is</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 267 +                            // to be consistent with the database-- for now, just require</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 268 +                            // modelItem == item</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 269 +                            String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 270 +                                &quot;modelItem: &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 271 +                                    ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 272 +                                &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 273 +                            RuntimeException e = new RuntimeException(msg);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 274 +                            e.setStackTrace(stackTrace);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 275 +                            throw e;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 276 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 277 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 278 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 279 +            };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 280 +        runOnWorkerThread(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 281 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 282 +</span>
 283      static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 284              final ItemInfo item, final String callingFunction) {
 285          final long itemId = item.id;
 286          final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 287          final ContentResolver cr = context.getContentResolver();
 288  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 289 +        final StackTraceElement[] stackTrace = new Throwable().getStackTrace();</span>
 290          Runnable r = new Runnable() {
 291              public void run() {
 292                  cr.update(uri, values, null, null);
 293  
 294                  // Lock on mBgLock *after* the db operation
 295                  synchronized (sBgLock) {
 296                      ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 297                      if (item != modelItem) {
 298                          // the modelItem needs to match up perfectly with item if our model is to be
 299                          // consistent with the database-- for now, just require modelItem == item
 300                          String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 301                              &quot;modelItem: &quot; + ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 302                              &quot;Error: ItemInfo passed to &quot; + callingFunction + &quot; doesn&#x27;t match &quot; +
 303                              &quot;original&quot;;
 304                          throw new RuntimeException(msg);
 305                      }
 306  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 307 +                    if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 308 +                            item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 309 +                        // Item is in a folder, make sure this folder exists</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 310 +                        if (!sBgFolders.containsKey(item.container)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 311 +                            // An items container is being set to a that of an item which is not in</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 312 +                            // the list of Folders.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 313 +                            String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 314 +                                    item.container + &quot;, not in the list of folders&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 315 +                            RuntimeException e = new RuntimeException(msg);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 316 +                            e.setStackTrace(stackTrace);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 317 +                            Launcher.dumpDebugLogsToConsole();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 318 +                            throw e;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 319 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 320 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 321 +</span>
 322                      // Items are added/removed from the corresponding FolderInfo elsewhere, such
 323                      // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 324                      // that are on the desktop, as appropriate
 325                      if (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 326                              modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 327 -                        if (!sBgWorkspaceItems.contains(modelItem)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 328 -                            sBgWorkspaceItems.add(modelItem);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 329 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 330 +                        switch (modelItem.itemType) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 331 +                            case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 332 +                            case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 333 +                            case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 334 +                                if (!sBgWorkspaceItems.contains(modelItem)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 335 +                                    sBgWorkspaceItems.add(modelItem);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 336 +                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 337 +                                break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 338 +                            default:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 339 +                                break;</span>
 340                          }
 341                      } else {
 342                          sBgWorkspaceItems.remove(modelItem);
 343                      }
 344                  }
 345              }
 346          };
 347          runOnWorkerThread(r);
 348      }
 349  
 350      /**
 351       * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 352       */
 353      static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 354              final int screen, final int cellX, final int cellY) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 355 +        String transaction = &quot;DbDebug    Modify item (&quot; + item.title + &quot;) in db, id: &quot; + item.id +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 356 +                &quot; (&quot; + item.container + &quot;, &quot; + item.screen + &quot;, &quot; + item.cellX + &quot;, &quot; + item.cellY +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 357 +                &quot;) --&gt; &quot; + &quot;(&quot; + container + &quot;, &quot; + screen + &quot;, &quot; + cellX + &quot;, &quot; + cellY + &quot;)&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 358 +        Launcher.sDumpLogs.add(transaction);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 359 +        Log.d(TAG, transaction);</span>
 360          item.container = container;
 361          item.cellX = cellX;
 362          item.cellY = cellY;
 363  
 364          // We store hotseat items in canonical form which is this orientation invariant position
 365          // in the hotseat
 366          if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 367                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 368              item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 369          } else {
 370              item.screen = screen;
 371          }
 372  
 373          final ContentValues values = new ContentValues();
 374          values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 375          values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 376          values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 377          values.put(LauncherSettings.Favorites.SCREEN, item.screen);
 378  
 379          updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 380      }
 381  
 382      /**
 383       * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 384       */
 385      static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 386              final int screen, final int cellX, final int cellY, final int spanX, final int spanY) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 387 -        item.container = container;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 388 +        String transaction = &quot;DbDebug    Modify item (&quot; + item.title + &quot;) in db, id: &quot; + item.id +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 389 +                &quot; (&quot; + item.container + &quot;, &quot; + item.screen + &quot;, &quot; + item.cellX + &quot;, &quot; + item.cellY +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 390 +                &quot;) --&gt; &quot; + &quot;(&quot; + container + &quot;, &quot; + screen + &quot;, &quot; + cellX + &quot;, &quot; + cellY + &quot;)&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 391 +        Launcher.sDumpLogs.add(transaction);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 392 +        Log.d(TAG, transaction);</span>
 393          item.cellX = cellX;
 394          item.cellY = cellY;
 395          item.spanX = spanX;
 396          item.spanY = spanY;
 397  
 398          // We store hotseat items in canonical form which is this orientation invariant position
 399          // in the hotseat
 400          if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 401                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 402              item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 403          } else {
 404              item.screen = screen;
 405          }
 406  
 407          final ContentValues values = new ContentValues();
 408          values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 409          values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 410          values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 411          values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 412          values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 413          values.put(LauncherSettings.Favorites.SCREEN, item.screen);
 414  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 415 -        updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 416 +        updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);</span>
 417      }
 418  
 419      /**
 420       * Update an item to the database in a specified container.
 421       */
 422      static void updateItemInDatabase(Context context, final ItemInfo item) {
 423          final ContentValues values = new ContentValues();
 424          item.onAddToDatabase(values);
 425          item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 426          updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 427      }
 428  
 429      /**
 430       * Returns true if the shortcuts already exists in the database.
 431       * we identify a shortcut by its title and intent.
 432       */
 433      static boolean shortcutExists(Context context, String title, Intent intent) {
 434          final ContentResolver cr = context.getContentResolver();
 435          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 436              new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and intent=?&quot;,
 437              new String[] { title, intent.toUri(0) }, null);
 438          boolean result = false;
 439          try {
 440              result = c.moveToFirst();
 441          } finally {
 442              c.close();
 443          }
 444          return result;
 445      }
 446  
 447      /**
 448       * Returns an ItemInfo array containing all the items in the LauncherModel.
 449       * The ItemInfo.id is not set through this function.
 450       */
 451      static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 452          ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 453          final ContentResolver cr = context.getContentResolver();
 454          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
 455                  LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
<abbr title=" 456                  LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,"> 456                  LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CEðŸ”µ</abbr>
 457                  LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY }, null, null, null);
 458  
 459          final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 460          final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 461          final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 462          final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 463          final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 464          final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 465          final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 466  
 467          try {
 468              while (c.moveToNext()) {
 469                  ItemInfo item = new ItemInfo();
 470                  item.cellX = c.getInt(cellXIndex);
 471                  item.cellY = c.getInt(cellYIndex);
 472                  item.spanX = c.getInt(spanXIndex);
 473                  item.spanY = c.getInt(spanYIndex);
 474                  item.container = c.getInt(containerIndex);
 475                  item.itemType = c.getInt(itemTypeIndex);
 476                  item.screen = c.getInt(screenIndex);
 477  
 478                  items.add(item);
 479              }
 480          } catch (Exception e) {
 481              items.clear();
 482          } finally {
 483              c.close();
 484          }
 485  
 486          return items;
 487      }
 488  
 489      /**
 490       * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 491       */
 492      FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
 493          final ContentResolver cr = context.getContentResolver();
 494          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
 495                  &quot;_id=? and (itemType=? or itemType=?)&quot;,
 496                  new String[] { String.valueOf(id),
 497                          String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
 498  
 499          try {
 500              if (c.moveToFirst()) {
 501                  final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 502                  final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 503                  final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 504                  final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 505                  final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 506                  final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 507  
 508                  FolderInfo folderInfo = null;
 509                  switch (c.getInt(itemTypeIndex)) {
 510                      case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 511                          folderInfo = findOrMakeFolder(folderList, id);
 512                          break;
 513                  }
 514  
 515                  folderInfo.title = c.getString(titleIndex);
 516                  folderInfo.id = id;
 517                  folderInfo.container = c.getInt(containerIndex);
 518                  folderInfo.screen = c.getInt(screenIndex);
 519                  folderInfo.cellX = c.getInt(cellXIndex);
 520                  folderInfo.cellY = c.getInt(cellYIndex);
 521  
 522                  return folderInfo;
 523              }
 524          } finally {
 525              c.close();
 526          }
 527  
 528          return null;
 529      }
 530  
 531      /**
 532       * Add an item to the database in a specified container. Sets the container, screen, cellX and
 533       * cellY fields of the item. Also assigns an ID to the item.
 534       */
 535      static void addItemToDatabase(Context context, final ItemInfo item, final long container,
 536              final int screen, final int cellX, final int cellY, final boolean notify) {
 537          item.container = container;
 538          item.cellX = cellX;
 539          item.cellY = cellY;
 540          // We store hotseat items in canonical form which is this orientation invariant position
 541          // in the hotseat
 542          if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 543                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 544              item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 545          } else {
 546              item.screen = screen;
 547          }
 548  
 549          final ContentValues values = new ContentValues();
 550          final ContentResolver cr = context.getContentResolver();
 551          item.onAddToDatabase(values);
 552  
 553          LauncherApplication app = (LauncherApplication) context.getApplicationContext();
 554          item.id = app.getLauncherProvider().generateNewId();
 555          values.put(LauncherSettings.Favorites._ID, item.id);
 556          item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 557  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 558 +        final StackTraceElement[] stackTrace = new Throwable().getStackTrace();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 559 +</span>
 560          Runnable r = new Runnable() {
 561              public void run() {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 562 +                String transaction = &quot;DbDebug    Add item (&quot; + item.title + &quot;) to db, id: &quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 563 +                        + item.id + &quot; (&quot; + container + &quot;, &quot; + screen + &quot;, &quot; + cellX + &quot;, &quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 564 +                        + cellY + &quot;)&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 565 +                Launcher.sDumpLogs.add(transaction);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 566 +                Log.d(TAG, transaction);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 567 +</span>
 568                  cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
 569                          LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 570 +</span>
 571                  // Lock on mBgLock *after* the db operation
 572                  synchronized (sBgLock) {
 573                      if (sBgItemsIdMap.containsKey(item.id)) {
 574                          // we should not be adding new items in the db with the same id
 575                          throw new RuntimeException(&quot;Error: ItemInfo id (&quot; + item.id + &quot;) passed to &quot; +
 576                              &quot;addItemToDatabase already exists.&quot; + item.toString());
 577                      }
 578                      sBgItemsIdMap.put(item.id, item);
 579                      switch (item.itemType) {
 580                          case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 581                              sBgFolders.put(item.id, (FolderInfo) item);
 582                              // Fall through
 583                          case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 584                          case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 585                              if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 586                                      item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 587                                  sBgWorkspaceItems.add(item);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 588 +                            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 589 +                                if (!sBgFolders.containsKey(item.container)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 590 +                                    // Adding an item to a folder that doesn&#x27;t exist.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 591 +                                    String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 592 +                                            &quot; doesn&#x27;t exist&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 593 +                                    RuntimeException e = new RuntimeException(msg);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 594 +                                    e.setStackTrace(stackTrace);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 595 +                                    Launcher.dumpDebugLogsToConsole();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 596 +                                    throw e;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 597 +                                }</span>
 598                              }
 599                              break;
 600                          case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
 601                              sBgAppWidgets.add((LauncherAppWidgetInfo) item);
 602                              break;
 603                      }
 604                  }
 605              }
 606          };
 607          runOnWorkerThread(r);
 608      }
 609  
 610      /**
 611       * Creates a new unique child id, for a given cell span across all layouts.
 612       */
 613      static int getCellLayoutChildId(
 614              long container, int screen, int localCellX, int localCellY, int spanX, int spanY) {
 615          return (((int) container &amp; 0xFF) &lt;&lt; 24)
 616                  | (screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
 617      }
 618  
 619      static int getCellCountX() {
 620          return mCellCountX;
 621      }
 622  
 623      static int getCellCountY() {
 624          return mCellCountY;
 625      }
 626  
 627      /**
 628       * Updates the model orientation helper to take into account the current layout dimensions
 629       * when performing local/canonical coordinate transformations.
 630       */
 631      static void updateWorkspaceLayoutCells(int shortAxisCellCount, int longAxisCellCount) {
 632          mCellCountX = shortAxisCellCount;
 633          mCellCountY = longAxisCellCount;
 634      }
 635  
 636      /**
 637       * Removes the specified item from the database
 638       * @param context
 639       * @param item
 640       */
 641      static void deleteItemFromDatabase(Context context, final ItemInfo item) {
 642          final ContentResolver cr = context.getContentResolver();
 643          final Uri uriToDelete = LauncherSettings.Favorites.getContentUri(item.id, false);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 644 +        final StackTraceElement[] stackTrace = new Throwable().getStackTrace();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 645 +</span>
 646          Runnable r = new Runnable() {
 647              public void run() {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 648 +                String transaction = &quot;DbDebug    Delete item (&quot; + item.title + &quot;) from db, id: &quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 649 +                        + item.id + &quot; (&quot; + item.container + &quot;, &quot; + item.screen + &quot;, &quot; + item.cellX +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 650 +                        &quot;, &quot; + item.cellY + &quot;)&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 651 +                Launcher.sDumpLogs.add(transaction);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 652 +                Log.d(TAG, transaction);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 653 +</span>
 654                  cr.delete(uriToDelete, null, null);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 655 +</span>
 656                  // Lock on mBgLock *after* the db operation
 657                  synchronized (sBgLock) {
 658                      switch (item.itemType) {
 659                          case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 660                              sBgFolders.remove(item.id);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 661 +                            for (ItemInfo info: sBgItemsIdMap.values()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 662 +                                if (info.container == item.id) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 663 +                                    // We are deleting a folder which still contains items that</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 664 +                                    // think they are contained by that folder.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 665 +                                    String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 666 +                                            &quot;contains items (&quot; + info + &quot;)&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 667 +                                    RuntimeException e = new RuntimeException(msg);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 668 +                                    e.setStackTrace(stackTrace);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 669 +                                    Launcher.dumpDebugLogsToConsole();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 670 +                                    throw e;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 671 +                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 672 +                            }</span>
 673                              sBgWorkspaceItems.remove(item);
 674                              break;
 675                          case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 676                          case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 677                              sBgWorkspaceItems.remove(item);
 678                              break;
 679                          case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
 680                              sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
 681                              break;
 682                      }
 683                      sBgItemsIdMap.remove(item.id);
 684                      sBgDbIconCache.remove(item);
 685                  }
 686              }
 687          };
 688          runOnWorkerThread(r);
 689      }
 690  
 691      /**
 692       * Remove the contents of the specified folder from the database
 693       */
 694      static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
 695          final ContentResolver cr = context.getContentResolver();
 696  
 697          Runnable r = new Runnable() {
 698              public void run() {
 699                  cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
 700                  // Lock on mBgLock *after* the db operation
 701                  synchronized (sBgLock) {
 702                      sBgItemsIdMap.remove(info.id);
 703                      sBgFolders.remove(info.id);
 704                      sBgDbIconCache.remove(info);
 705                      sBgWorkspaceItems.remove(info);
 706                  }
 707  
 708                  cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
 709                          LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
 710                  // Lock on mBgLock *after* the db operation
 711                  synchronized (sBgLock) {
 712                      for (ItemInfo childInfo : info.contents) {
 713                          sBgItemsIdMap.remove(childInfo.id);
 714                          sBgDbIconCache.remove(childInfo);
 715                      }
 716                  }
 717              }
 718          };
 719          runOnWorkerThread(r);
 720      }
 721  
 722      /**
 723       * Set this as the current Launcher activity object for the loader.
 724       */
 725      public void initialize(Callbacks callbacks) {
 726          synchronized (mLock) {
 727              mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
 728          }
 729      }
 730  
 731      /**
 732       * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
 733       * ACTION_PACKAGE_CHANGED.
 734       */
 735      @Override
 736      public void onReceive(Context context, Intent intent) {
 737          if (DEBUG_LOADERS) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
 738  
 739          final String action = intent.getAction();
 740  
 741          if (Intent.ACTION_PACKAGE_CHANGED.equals(action)
 742                  || Intent.ACTION_PACKAGE_REMOVED.equals(action)
 743                  || Intent.ACTION_PACKAGE_ADDED.equals(action)) {
 744              final String packageName = intent.getData().getSchemeSpecificPart();
 745              final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
 746  
 747              int op = PackageUpdatedTask.OP_NONE;
 748  
 749              if (packageName == null || packageName.length() == 0) {
 750                  // they sent us a bad intent
 751                  return;
 752              }
 753  
 754              if (Intent.ACTION_PACKAGE_CHANGED.equals(action)) {
 755                  op = PackageUpdatedTask.OP_UPDATE;
 756              } else if (Intent.ACTION_PACKAGE_REMOVED.equals(action)) {
 757                  if (!replacing) {
 758                      op = PackageUpdatedTask.OP_REMOVE;
 759                  }
 760                  // else, we are replacing the package, so a PACKAGE_ADDED will be sent
 761                  // later, we will update the package at this time
 762              } else if (Intent.ACTION_PACKAGE_ADDED.equals(action)) {
 763                  if (!replacing) {
 764                      op = PackageUpdatedTask.OP_ADD;
 765                  } else {
 766                      op = PackageUpdatedTask.OP_UPDATE;
 767                  }
 768              }
 769  
 770              if (op != PackageUpdatedTask.OP_NONE) {
 771                  enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName }));
 772              }
 773  
 774          } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(action)) {
 775              // First, schedule to add these apps back in.
 776              String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
 777              enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packages));
 778              // Then, rebind everything.
 779              startLoaderFromBackground();
 780          } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(action)) {
 781              String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
 782              enqueuePackageUpdated(new PackageUpdatedTask(
 783                          PackageUpdatedTask.OP_UNAVAILABLE, packages));
 784          } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
 785              // If we have changed locale we need to clear out the labels in all apps/workspace.
 786              forceReload();
 787          } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
 788               // Check if configuration change was an mcc/mnc change which would affect app resources
 789               // and we would need to clear out the labels in all apps/workspace. Same handling as
 790               // above for ACTION_LOCALE_CHANGED
 791               Configuration currentConfig = context.getResources().getConfiguration();
 792               if (mPreviousConfigMcc != currentConfig.mcc) {
 793                     Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
 794                         + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
 795                     forceReload();
 796               }
 797               // Update previousConfig
 798               mPreviousConfigMcc = currentConfig.mcc;
 799          } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
 800                     SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
 801              if (mCallbacks != null) {
 802                  Callbacks callbacks = mCallbacks.get();
 803                  if (callbacks != null) {
 804                      callbacks.bindSearchablesChanged();
 805                  }
 806              }
 807          }
 808      }
 809  
 810      private void forceReload() {
 811          resetLoadedState(true, true);
 812  
 813          // Do this here because if the launcher activity is running it will be restarted.
 814          // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
 815          // to reload.
 816          startLoaderFromBackground();
 817      }
 818  
 819      public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
 820          synchronized (mLock) {
 821              // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
 822              // mWorkspaceLoaded to true later
 823              stopLoaderLocked();
 824              if (resetAllAppsLoaded) mAllAppsLoaded = false;
 825              if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
 826          }
 827      }
 828  
 829      /**
 830       * When the launcher is in the background, it&#x27;s possible for it to miss paired
 831       * configuration changes.  So whenever we trigger the loader from the background
 832       * tell the launcher that it needs to re-run the loader when it comes back instead
 833       * of doing it now.
 834       */
 835      public void startLoaderFromBackground() {
 836          boolean runLoader = false;
 837          if (mCallbacks != null) {
 838              Callbacks callbacks = mCallbacks.get();
 839              if (callbacks != null) {
 840                  // Only actually run the loader if they&#x27;re not paused.
 841                  if (!callbacks.setLoadOnResume()) {
 842                      runLoader = true;
 843                  }
 844              }
 845          }
 846          if (runLoader) {
 847              startLoader(false, -1);
 848          }
 849      }
 850  
 851      // If there is already a loader task running, tell it to stop.
 852      // returns true if isLaunching() was true on the old task
 853      private boolean stopLoaderLocked() {
 854          boolean isLaunching = false;
 855          LoaderTask oldTask = mLoaderTask;
 856          if (oldTask != null) {
 857              if (oldTask.isLaunching()) {
 858                  isLaunching = true;
 859              }
 860              oldTask.stopLocked();
 861          }
 862          return isLaunching;
 863      }
 864  
 865      public void startLoader(boolean isLaunching, int synchronousBindPage) {
 866          synchronized (mLock) {
 867              if (DEBUG_LOADERS) {
 868                  Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
 869              }
 870  
 871              // Clear any deferred bind-runnables from the synchronized load process
 872              // We must do this before any loading/binding is scheduled below.
 873              mDeferredBindRunnables.clear();
 874  
 875              // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
 876              if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
 877                  // If there is already one running, tell it to stop.
 878                  // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
 879                  isLaunching = isLaunching || stopLoaderLocked();
 880                  mLoaderTask = new LoaderTask(mApp, isLaunching);
 881                  if (synchronousBindPage &gt; -1 &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {
 882                      mLoaderTask.runBindSynchronousPage(synchronousBindPage);
 883                  } else {
 884                      sWorkerThread.setPriority(Thread.NORM_PRIORITY);
 885                      sWorker.post(mLoaderTask);
 886                  }
 887              }
 888          }
 889      }
 890  
 891      void bindRemainingSynchronousPages() {
 892          // Post the remaining side pages to be loaded
 893          if (!mDeferredBindRunnables.isEmpty()) {
 894              for (final Runnable r : mDeferredBindRunnables) {
 895                  mHandler.post(r);
 896              }
 897              mDeferredBindRunnables.clear();
 898          }
 899      }
 900  
 901      public void stopLoader() {
 902          synchronized (mLock) {
 903              if (mLoaderTask != null) {
 904                  mLoaderTask.stopLocked();
 905              }
 906          }
 907      }
 908  
 909      public boolean isAllAppsLoaded() {
 910          return mAllAppsLoaded;
 911      }
 912  
 913      boolean isLoadingWorkspace() {
 914          synchronized (mLock) {
 915              if (mLoaderTask != null) {
 916                  return mLoaderTask.isLoadingWorkspace();
 917              }
 918          }
 919          return false;
 920      }
 921  
 922      /**
 923       * Runnable for the thread that loads the contents of the launcher:
 924       *   - workspace icons
 925       *   - widgets
 926       *   - all apps icons
 927       */
 928      private class LoaderTask implements Runnable {
 929          private Context mContext;
 930          private boolean mIsLaunching;
 931          private boolean mIsLoadingAndBindingWorkspace;
 932          private boolean mStopped;
 933          private boolean mLoadAndBindStepFinished;
 934  
 935          private HashMap&lt;Object, CharSequence&gt; mLabelCache;
 936  
 937          LoaderTask(Context context, boolean isLaunching) {
 938              mContext = context;
 939              mIsLaunching = isLaunching;
 940              mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
 941          }
 942  
 943          boolean isLaunching() {
 944              return mIsLaunching;
 945          }
 946  
 947          boolean isLoadingWorkspace() {
 948              return mIsLoadingAndBindingWorkspace;
 949          }
 950  
 951          private void loadAndBindWorkspace() {
 952              mIsLoadingAndBindingWorkspace = true;
 953  
 954              // Load the workspace
 955              if (DEBUG_LOADERS) {
 956                  Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
 957              }
 958  
 959              if (!mWorkspaceLoaded) {
 960                  loadWorkspace();
 961                  synchronized (LoaderTask.this) {
 962                      if (mStopped) {
 963                          return;
 964                      }
 965                      mWorkspaceLoaded = true;
 966                  }
 967              }
 968  
 969              // Bind the workspace
 970              bindWorkspace(-1);
 971          }
 972  
 973          private void waitForIdle() {
 974              // Wait until the either we&#x27;re stopped or the other threads are done.
 975              // This way we don&#x27;t start loading all apps until the workspace has settled
 976              // down.
 977              synchronized (LoaderTask.this) {
 978                  final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
 979  
 980                  mHandler.postIdle(new Runnable() {
 981                          public void run() {
 982                              synchronized (LoaderTask.this) {
 983                                  mLoadAndBindStepFinished = true;
 984                                  if (DEBUG_LOADERS) {
 985                                      Log.d(TAG, &quot;done with previous binding step&quot;);
 986                                  }
 987                                  LoaderTask.this.notify();
 988                              }
 989                          }
 990                      });
 991  
 992                  while (!mStopped &amp;&amp; !mLoadAndBindStepFinished) {
 993                      try {
 994                          this.wait();
 995                      } catch (InterruptedException ex) {
 996                          // Ignore
 997                      }
 998                  }
 999                  if (DEBUG_LOADERS) {
1000                      Log.d(TAG, &quot;waited &quot;
1001                              + (SystemClock.uptimeMillis()-workspaceWaitTime)
1002                              + &quot;ms for previous step to finish binding&quot;);
1003                  }
1004              }
1005          }
1006  
1007          void runBindSynchronousPage(int synchronousBindPage) {
1008              if (synchronousBindPage &lt; 0) {
1009                  // Ensure that we have a valid page index to load synchronously
1010                  throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1011                          &quot;valid page index&quot;);
1012              }
1013              if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1014                  // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1015                  // loaded already (we should load everything asynchronously in that case)
1016                  throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1017              }
1018              synchronized (mLock) {
1019                  if (mIsLoaderTaskRunning) {
1020                      // Ensure that we are never running the background loading at this point since
1021                      // we also touch the background collections
1022                      throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1023                  }
1024              }
1025  
1026              // XXX: Throw an exception if we are already loading (since we touch the worker thread
1027              //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1028              //      this call is synchronous, we can get away with not locking).
1029  
1030              // The LauncherModel is static in the LauncherApplication and mHandler may have queued
1031              // operations from the previous activity.  We need to ensure that all queued operations
1032              // are executed before any synchronous binding work is done.
1033              mHandler.flush();
1034  
1035              // Divide the set of loaded items into those that we are binding synchronously, and
1036              // everything else that is to be bound normally (asynchronously).
1037              bindWorkspace(synchronousBindPage);
1038              // XXX: For now, continue posting the binding of AllApps as there are other issues that
1039              //      arise from that.
1040              onlyBindAllApps();
1041          }
1042  
1043          public void run() {
1044              synchronized (mLock) {
1045                  mIsLoaderTaskRunning = true;
1046              }
1047              // Optimize for end-user experience: if the Launcher is up and // running with the
1048              // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1049              // workspace first (default).
1050              final Callbacks cbk = mCallbacks.get();
1051              final boolean loadWorkspaceFirst = cbk != null ? (!cbk.isAllAppsVisible()) : true;
1052  
1053              keep_running: {
1054                  // Elevate priority when Home launches for the first time to avoid
1055                  // starving at boot time. Staring at a blank home is not cool.
1056                  synchronized (mLock) {
1057                      if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1058                              (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1059                      android.os.Process.setThreadPriority(mIsLaunching
1060                              ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1061                  }
1062                  if (loadWorkspaceFirst) {
1063                      if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1064                      loadAndBindWorkspace();
1065                  } else {
1066                      if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: special: loading all apps&quot;);
1067                      loadAndBindAllApps();
1068                  }
1069  
1070                  if (mStopped) {
1071                      break keep_running;
1072                  }
1073  
1074                  // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1075                  // settled down.
1076                  synchronized (mLock) {
1077                      if (mIsLaunching) {
1078                          if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1079                          android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1080                      }
1081                  }
1082                  waitForIdle();
1083  
1084                  // second step
1085                  if (loadWorkspaceFirst) {
1086                      if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1087                      loadAndBindAllApps();
1088                  } else {
1089                      if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: special: loading workspace&quot;);
1090                      loadAndBindWorkspace();
1091                  }
1092  
1093                  // Restore the default thread priority after we are done loading items
1094                  synchronized (mLock) {
1095                      android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1096                  }
1097              }
1098  
1099  
1100              // Update the saved icons if necessary
1101              if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1102              synchronized (sBgLock) {
1103                  for (Object key : sBgDbIconCache.keySet()) {
1104                      updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
1105                  }
1106                  sBgDbIconCache.clear();
1107              }
1108  
1109              // Clear out this reference, otherwise we end up holding it until all of the
1110              // callback runnables are done.
1111              mContext = null;
1112  
1113              synchronized (mLock) {
1114                  // If we are still the last one to be scheduled, remove ourselves.
1115                  if (mLoaderTask == this) {
1116                      mLoaderTask = null;
1117                  }
1118                  mIsLoaderTaskRunning = false;
1119              }
1120          }
1121  
1122          public void stopLocked() {
1123              synchronized (LoaderTask.this) {
1124                  mStopped = true;
1125                  this.notify();
1126              }
1127          }
1128  
1129          /**
1130           * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1131           * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1132           * object that was around when the deferred message was scheduled, and if there&#x27;s
1133           * a new Callbacks object around then also return null.  This will save us from
1134           * calling onto it with data that will be ignored.
1135           */
1136          Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1137              synchronized (mLock) {
1138                  if (mStopped) {
1139                      return null;
1140                  }
1141  
1142                  if (mCallbacks == null) {
1143                      return null;
1144                  }
1145  
1146                  final Callbacks callbacks = mCallbacks.get();
1147                  if (callbacks != oldCallbacks) {
1148                      return null;
1149                  }
1150                  if (callbacks == null) {
1151                      Log.w(TAG, &quot;no mCallbacks&quot;);
1152                      return null;
1153                  }
1154  
1155                  return callbacks;
1156              }
1157          }
1158  
1159          // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1160          private boolean checkItemPlacement(ItemInfo occupied[][][], ItemInfo item) {
1161              int containerIndex = item.screen;
1162              if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1163                  // Return early if we detect that an item is under the hotseat button
1164                  if (mCallbacks == null || mCallbacks.get().isAllAppsButtonRank(item.screen)) {
1165                      return false;
1166                  }
1167  
1168                  // We use the last index to refer to the hotseat and the screen as the rank, so
1169                  // test and update the occupied state accordingly
1170                  if (occupied[Launcher.SCREEN_COUNT][item.screen][0] != null) {
1171                      Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1172                          + &quot; into position (&quot; + item.screen + &quot;:&quot; + item.cellX + &quot;,&quot; + item.cellY
1173                          + &quot;) occupied by &quot; + occupied[Launcher.SCREEN_COUNT][item.screen][0]);
1174                      return false;
1175                  } else {
1176                      occupied[Launcher.SCREEN_COUNT][item.screen][0] = item;
1177                      return true;
1178                  }
1179              } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1180                  // Skip further checking if it is not the hotseat or workspace container
1181                  return true;
1182              }
1183  
1184              // Check if any workspace icons overlap with each other
1185              for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1186                  for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1187                      if (occupied[containerIndex][x][y] != null) {
1188                          Log.e(TAG, &quot;Error loading shortcut &quot; + item
1189                              + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screen + &quot;:&quot;
1190                              + x + &quot;,&quot; + y
1191                              + &quot;) occupied by &quot;
1192                              + occupied[containerIndex][x][y]);
1193                          return false;
1194                      }
1195                  }
1196              }
1197              for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1198                  for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1199                      occupied[containerIndex][x][y] = item;
1200                  }
1201              }
1202  
1203              return true;
1204          }
1205  
1206          private void loadWorkspace() {
1207              final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1208  
1209              final Context context = mContext;
1210              final ContentResolver contentResolver = context.getContentResolver();
1211              final PackageManager manager = context.getPackageManager();
1212              final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1213              final boolean isSafeMode = manager.isSafeMode();
1214  
1215              // Make sure the default workspace is loaded, if needed
1216              mApp.getLauncherProvider().loadDefaultFavoritesIfNecessary();
1217  
1218              synchronized (sBgLock) {
1219                  sBgWorkspaceItems.clear();
1220                  sBgAppWidgets.clear();
1221                  sBgFolders.clear();
1222                  sBgItemsIdMap.clear();
1223                  sBgDbIconCache.clear();
1224  
1225                  final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1226  
1227                  final Cursor c = contentResolver.query(
1228                          LauncherSettings.Favorites.CONTENT_URI, null, null, null, null);
1229  
1230                  // +1 for the hotseat (it can be larger than the workspace)
1231                  // Load workspace in reverse order to ensure that latest items are loaded first (and
1232                  // before any earlier duplicates)
1233                  final ItemInfo occupied[][][] =
1234                          new ItemInfo[Launcher.SCREEN_COUNT + 1][mCellCountX + 1][mCellCountY + 1];
1235  
1236                  try {
1237                      final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1238                      final int intentIndex = c.getColumnIndexOrThrow
1239                              (LauncherSettings.Favorites.INTENT);
1240                      final int titleIndex = c.getColumnIndexOrThrow
1241                              (LauncherSettings.Favorites.TITLE);
1242                      final int iconTypeIndex = c.getColumnIndexOrThrow(
1243                              LauncherSettings.Favorites.ICON_TYPE);
1244                      final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
1245                      final int iconPackageIndex = c.getColumnIndexOrThrow(
1246                              LauncherSettings.Favorites.ICON_PACKAGE);
1247                      final int iconResourceIndex = c.getColumnIndexOrThrow(
1248                              LauncherSettings.Favorites.ICON_RESOURCE);
1249                      final int containerIndex = c.getColumnIndexOrThrow(
1250                              LauncherSettings.Favorites.CONTAINER);
1251                      final int itemTypeIndex = c.getColumnIndexOrThrow(
1252                              LauncherSettings.Favorites.ITEM_TYPE);
1253                      final int appWidgetIdIndex = c.getColumnIndexOrThrow(
1254                              LauncherSettings.Favorites.APPWIDGET_ID);
1255                      final int screenIndex = c.getColumnIndexOrThrow(
1256                              LauncherSettings.Favorites.SCREEN);
1257                      final int cellXIndex = c.getColumnIndexOrThrow
1258                              (LauncherSettings.Favorites.CELLX);
1259                      final int cellYIndex = c.getColumnIndexOrThrow
1260                              (LauncherSettings.Favorites.CELLY);
1261                      final int spanXIndex = c.getColumnIndexOrThrow
1262                              (LauncherSettings.Favorites.SPANX);
1263                      final int spanYIndex = c.getColumnIndexOrThrow(
1264                              LauncherSettings.Favorites.SPANY);
1265                      //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1266                      //final int displayModeIndex = c.getColumnIndexOrThrow(
1267                      //        LauncherSettings.Favorites.DISPLAY_MODE);
1268  
1269                      ShortcutInfo info;
1270                      String intentDescription;
1271                      LauncherAppWidgetInfo appWidgetInfo;
1272                      int container;
1273                      long id;
1274                      Intent intent;
1275  
1276                      while (!mStopped &amp;&amp; c.moveToNext()) {
1277                          try {
1278                              int itemType = c.getInt(itemTypeIndex);
1279  
1280                              switch (itemType) {
1281                              case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1282                              case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1283                                  intentDescription = c.getString(intentIndex);
1284                                  try {
1285                                      intent = Intent.parseUri(intentDescription, 0);
1286                                  } catch (URISyntaxException e) {
1287                                      continue;
1288                                  }
1289  
1290                                  if (itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
1291                                      info = getShortcutInfo(manager, intent, context, c, iconIndex,
1292                                              titleIndex, mLabelCache);
1293                                  } else {
1294                                      info = getShortcutInfo(c, context, iconTypeIndex,
1295                                              iconPackageIndex, iconResourceIndex, iconIndex,
1296                                              titleIndex);
1297  
1298                                      // App shortcuts that used to be automatically added to Launcher
1299                                      // didn&#x27;t always have the correct intent flags set, so do that
1300                                      // here
1301                                      if (intent.getAction() != null &amp;&amp;
1302                                          intent.getCategories() != null &amp;&amp;
1303                                          intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
1304                                          intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
1305                                          intent.addFlags(
1306                                              Intent.FLAG_ACTIVITY_NEW_TASK |
1307                                              Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
1308                                      }
1309                                  }
1310  
1311                                  if (info != null) {
1312                                      info.intent = intent;
1313                                      info.id = c.getLong(idIndex);
1314                                      container = c.getInt(containerIndex);
1315                                      info.container = container;
1316                                      info.screen = c.getInt(screenIndex);
1317                                      info.cellX = c.getInt(cellXIndex);
1318                                      info.cellY = c.getInt(cellYIndex);
1319  
1320                                      // check &amp; update map of what&#x27;s occupied
1321                                      if (!checkItemPlacement(occupied, info)) {
1322                                          break;
1323                                      }
1324  
1325                                      switch (container) {
1326                                      case LauncherSettings.Favorites.CONTAINER_DESKTOP:
1327                                      case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
1328                                          sBgWorkspaceItems.add(info);
1329                                          break;
1330                                      default:
1331                                          // Item is in a user folder
1332                                          FolderInfo folderInfo =
1333                                                  findOrMakeFolder(sBgFolders, container);
1334                                          folderInfo.add(info);
1335                                          break;
1336                                      }
1337                                      sBgItemsIdMap.put(info.id, info);
1338  
1339                                      // now that we&#x27;ve loaded everthing re-save it with the
1340                                      // icon in case it disappears somehow.
1341                                      queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
1342                                  } else {
1343                                      // Failed to load the shortcut, probably because the
1344                                      // activity manager couldn&#x27;t resolve it (maybe the app
1345                                      // was uninstalled), or the db row was somehow screwed up.
1346                                      // Delete it.
1347                                      id = c.getLong(idIndex);
1348                                      Log.e(TAG, &quot;Error loading shortcut &quot; + id + &quot;, removing it&quot;);
1349                                      contentResolver.delete(LauncherSettings.Favorites.getContentUri(
1350                                                  id, false), null, null);
1351                                  }
1352                                  break;
1353  
1354                              case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1355                                  id = c.getLong(idIndex);
1356                                  FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
1357  
1358                                  folderInfo.title = c.getString(titleIndex);
1359                                  folderInfo.id = id;
1360                                  container = c.getInt(containerIndex);
1361                                  folderInfo.container = container;
1362                                  folderInfo.screen = c.getInt(screenIndex);
1363                                  folderInfo.cellX = c.getInt(cellXIndex);
1364                                  folderInfo.cellY = c.getInt(cellYIndex);
1365  
1366                                  // check &amp; update map of what&#x27;s occupied
1367                                  if (!checkItemPlacement(occupied, folderInfo)) {
1368                                      break;
1369                                  }
1370                                  switch (container) {
1371                                      case LauncherSettings.Favorites.CONTAINER_DESKTOP:
1372                                      case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
1373                                          sBgWorkspaceItems.add(folderInfo);
1374                                          break;
1375                                  }
1376  
1377                                  sBgItemsIdMap.put(folderInfo.id, folderInfo);
1378                                  sBgFolders.put(folderInfo.id, folderInfo);
1379                                  break;
1380  
1381                              case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1382                                  // Read all Launcher-specific widget details
1383                                  int appWidgetId = c.getInt(appWidgetIdIndex);
1384                                  id = c.getLong(idIndex);
1385  
1386                                  final AppWidgetProviderInfo provider =
1387                                          widgets.getAppWidgetInfo(appWidgetId);
1388  
1389                                  if (!isSafeMode &amp;&amp; (provider == null || provider.provider == null ||
1390                                          provider.provider.getPackageName() == null)) {
1391                                      String log = &quot;Deleting widget that isn&#x27;t installed anymore: id=&quot;
1392                                          + id + &quot; appWidgetId=&quot; + appWidgetId;
1393                                      Log.e(TAG, log);
1394                                      Launcher.sDumpLogs.add(log);
1395                                      itemsToRemove.add(id);
1396                                  } else {
1397                                      appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
1398                                              provider.provider);
1399                                      appWidgetInfo.id = id;
1400                                      appWidgetInfo.screen = c.getInt(screenIndex);
1401                                      appWidgetInfo.cellX = c.getInt(cellXIndex);
1402                                      appWidgetInfo.cellY = c.getInt(cellYIndex);
1403                                      appWidgetInfo.spanX = c.getInt(spanXIndex);
1404                                      appWidgetInfo.spanY = c.getInt(spanYIndex);
1405                                      int[] minSpan = Launcher.getMinSpanForWidget(context, provider);
1406                                      appWidgetInfo.minSpanX = minSpan[0];
1407                                      appWidgetInfo.minSpanY = minSpan[1];
1408  
1409                                      container = c.getInt(containerIndex);
1410                                      if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1411                                          container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1412                                          Log.e(TAG, &quot;Widget found where container != &quot; +
1413                                              &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
1414                                          continue;
1415                                      }
1416                                      appWidgetInfo.container = c.getInt(containerIndex);
1417  
1418                                      // check &amp; update map of what&#x27;s occupied
1419                                      if (!checkItemPlacement(occupied, appWidgetInfo)) {
1420                                          break;
1421                                      }
1422                                      sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
1423                                      sBgAppWidgets.add(appWidgetInfo);
1424                                  }
1425                                  break;
1426                              }
1427                          } catch (Exception e) {
1428                              Log.w(TAG, &quot;Desktop items loading interrupted:&quot;, e);
1429                          }
1430                      }
1431                  } finally {
1432                      c.close();
1433                  }
1434  
1435                  if (itemsToRemove.size() &gt; 0) {
1436                      ContentProviderClient client = contentResolver.acquireContentProviderClient(
1437                                      LauncherSettings.Favorites.CONTENT_URI);
1438                      // Remove dead items
1439                      for (long id : itemsToRemove) {
1440                          if (DEBUG_LOADERS) {
1441                              Log.d(TAG, &quot;Removed id = &quot; + id);
1442                          }
1443                          // Don&#x27;t notify content observers
1444                          try {
1445                              client.delete(LauncherSettings.Favorites.getContentUri(id, false),
1446                                      null, null);
1447                          } catch (RemoteException e) {
1448                              Log.w(TAG, &quot;Could not remove id = &quot; + id);
1449                          }
1450                      }
1451                  }
1452  
1453                  if (DEBUG_LOADERS) {
1454                      Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
1455                      Log.d(TAG, &quot;workspace layout: &quot;);
1456                      for (int y = 0; y &lt; mCellCountY; y++) {
1457                          String line = &quot;&quot;;
1458                          for (int s = 0; s &lt; Launcher.SCREEN_COUNT; s++) {
1459                              if (s &gt; 0) {
1460                                  line += &quot; | &quot;;
1461                              }
1462                              for (int x = 0; x &lt; mCellCountX; x++) {
1463                                  line += ((occupied[s][x][y] != null) ? &quot;#&quot; : &quot;.&quot;);
1464                              }
1465                          }
1466                          Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
1467                      }
1468                  }
1469              }
1470          }
1471  
1472          /** Filters the set of items who are directly or indirectly (via another container) on the
1473           * specified screen. */
1474          private void filterCurrentWorkspaceItems(int currentScreen,
1475                  ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
1476                  ArrayList&lt;ItemInfo&gt; currentScreenItems,
1477                  ArrayList&lt;ItemInfo&gt; otherScreenItems) {
1478              // Purge any null ItemInfos
1479              Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
1480              while (iter.hasNext()) {
1481                  ItemInfo i = iter.next();
1482                  if (i == null) {
1483                      iter.remove();
1484                  }
1485              }
1486  
1487              // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of
1488              // items given.
1489              if (currentScreen &lt; 0) {
1490                  currentScreenItems.addAll(allWorkspaceItems);
1491              }
1492  
1493              // Order the set of items by their containers first, this allows use to walk through the
1494              // list sequentially, build up a list of containers that are in the specified screen,
1495              // as well as all items in those containers.
1496              Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
1497              Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
1498                  @Override
1499                  public int compare(ItemInfo lhs, ItemInfo rhs) {
1500                      return (int) (lhs.container - rhs.container);
1501                  }
1502              });
1503              for (ItemInfo info : allWorkspaceItems) {
1504                  if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1505                      if (info.screen == currentScreen) {
1506                          currentScreenItems.add(info);
1507                          itemsOnScreen.add(info.id);
1508                      } else {
1509                          otherScreenItems.add(info);
1510                      }
1511                  } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1512                      currentScreenItems.add(info);
1513                      itemsOnScreen.add(info.id);
1514                  } else {
1515                      if (itemsOnScreen.contains(info.container)) {
1516                          currentScreenItems.add(info);
1517                          itemsOnScreen.add(info.id);
1518                      } else {
1519                          otherScreenItems.add(info);
1520                      }
1521                  }
1522              }
1523          }
1524  
1525          /** Filters the set of widgets which are on the specified screen. */
1526          private void filterCurrentAppWidgets(int currentScreen,
1527                  ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
1528                  ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
1529                  ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
1530              // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of
1531              // widgets given.
1532              if (currentScreen &lt; 0) {
1533                  currentScreenWidgets.addAll(appWidgets);
1534              }
1535  
1536              for (LauncherAppWidgetInfo widget : appWidgets) {
1537                  if (widget == null) continue;
1538                  if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1539                          widget.screen == currentScreen) {
1540                      currentScreenWidgets.add(widget);
1541                  } else {
1542                      otherScreenWidgets.add(widget);
1543                  }
1544              }
1545          }
1546  
1547          /** Filters the set of folders which are on the specified screen. */
1548          private void filterCurrentFolders(int currentScreen,
1549                  HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
1550                  HashMap&lt;Long, FolderInfo&gt; folders,
1551                  HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
1552                  HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
1553              // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of
1554              // widgets given.
1555              if (currentScreen &lt; 0) {
1556                  currentScreenFolders.putAll(folders);
1557              }
1558  
1559              for (long id : folders.keySet()) {
1560                  ItemInfo info = itemsIdMap.get(id);
1561                  FolderInfo folder = folders.get(id);
1562                  if (info == null || folder == null) continue;
1563                  if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1564                          info.screen == currentScreen) {
1565                      currentScreenFolders.put(id, folder);
1566                  } else {
1567                      otherScreenFolders.put(id, folder);
1568                  }
1569              }
1570          }
1571  
1572          /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
1573           * right) */
1574          private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
1575              // XXX: review this
1576              Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
1577                  @Override
1578                  public int compare(ItemInfo lhs, ItemInfo rhs) {
1579                      int cellCountX = LauncherModel.getCellCountX();
1580                      int cellCountY = LauncherModel.getCellCountY();
1581                      int screenOffset = cellCountX * cellCountY;
1582                      int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
1583                      long lr = (lhs.container * containerOffset + lhs.screen * screenOffset +
1584                              lhs.cellY * cellCountX + lhs.cellX);
1585                      long rr = (rhs.container * containerOffset + rhs.screen * screenOffset +
1586                              rhs.cellY * cellCountX + rhs.cellX);
1587                      return (int) (lr - rr);
1588                  }
1589              });
1590          }
1591  
1592          private void bindWorkspaceItems(final Callbacks oldCallbacks,
1593                  final ArrayList&lt;ItemInfo&gt; workspaceItems,
1594                  final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
1595                  final HashMap&lt;Long, FolderInfo&gt; folders,
1596                  ArrayList&lt;Runnable&gt; deferredBindRunnables) {
1597  
1598              final boolean postOnMainThread = (deferredBindRunnables != null);
1599  
1600              // Bind the workspace items
1601              int N = workspaceItems.size();
1602              for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
1603                  final int start = i;
1604                  final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
1605                  final Runnable r = new Runnable() {
1606                      @Override
1607                      public void run() {
1608                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1609                          if (callbacks != null) {
1610                              callbacks.bindItems(workspaceItems, start, start+chunkSize);
1611                          }
1612                      }
1613                  };
1614                  if (postOnMainThread) {
1615                      deferredBindRunnables.add(r);
1616                  } else {
1617                      runOnMainThread(r);
1618                  }
1619              }
1620  
1621              // Bind the folders
1622              if (!folders.isEmpty()) {
1623                  final Runnable r = new Runnable() {
1624                      public void run() {
1625                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1626                          if (callbacks != null) {
1627                              callbacks.bindFolders(folders);
1628                          }
1629                      }
1630                  };
1631                  if (postOnMainThread) {
1632                      deferredBindRunnables.add(r);
1633                  } else {
1634                      runOnMainThread(r);
1635                  }
1636              }
1637  
1638              // Bind the widgets, one at a time
1639              N = appWidgets.size();
1640              for (int i = 0; i &lt; N; i++) {
1641                  final LauncherAppWidgetInfo widget = appWidgets.get(i);
1642                  final Runnable r = new Runnable() {
1643                      public void run() {
1644                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1645                          if (callbacks != null) {
1646                              callbacks.bindAppWidget(widget);
1647                          }
1648                      }
1649                  };
1650                  if (postOnMainThread) {
1651                      deferredBindRunnables.add(r);
1652                  } else {
1653                      runOnMainThread(r);
1654                  }
1655              }
1656          }
1657  
1658          /**
1659           * Binds all loaded data to actual views on the main thread.
1660           */
1661          private void bindWorkspace(int synchronizeBindPage) {
1662              final long t = SystemClock.uptimeMillis();
1663              Runnable r;
1664  
1665              // Don&#x27;t use these two variables in any of the callback runnables.
1666              // Otherwise we hold a reference to them.
1667              final Callbacks oldCallbacks = mCallbacks.get();
1668              if (oldCallbacks == null) {
1669                  // This launcher has exited and nobody bothered to tell us.  Just bail.
1670                  Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
1671                  return;
1672              }
1673  
1674              final boolean isLoadingSynchronously = (synchronizeBindPage &gt; -1);
1675              final int currentScreen = isLoadingSynchronously ? synchronizeBindPage :
1676                  oldCallbacks.getCurrentWorkspaceScreen();
1677  
1678              // Load all the items that are on the current page first (and in the process, unbind
1679              // all the existing workspace items before we call startBinding() below.
1680              unbindWorkspaceItemsOnMainThread();
1681              ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
1682              ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
1683                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
1684              HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
1685              HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
1686              synchronized (sBgLock) {
1687                  workspaceItems.addAll(sBgWorkspaceItems);
1688                  appWidgets.addAll(sBgAppWidgets);
1689                  folders.putAll(sBgFolders);
1690                  itemsIdMap.putAll(sBgItemsIdMap);
1691              }
1692  
1693              ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
1694              ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
1695              ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
1696                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
1697              ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
1698                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
1699              HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
1700              HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
1701  
1702              // Separate the items that are on the current screen, and all the other remaining items
1703              filterCurrentWorkspaceItems(currentScreen, workspaceItems, currentWorkspaceItems,
1704                      otherWorkspaceItems);
1705              filterCurrentAppWidgets(currentScreen, appWidgets, currentAppWidgets,
1706                      otherAppWidgets);
1707              filterCurrentFolders(currentScreen, itemsIdMap, folders, currentFolders,
1708                      otherFolders);
1709              sortWorkspaceItemsSpatially(currentWorkspaceItems);
1710              sortWorkspaceItemsSpatially(otherWorkspaceItems);
1711  
1712              // Tell the workspace that we&#x27;re about to start binding items
1713              r = new Runnable() {
1714                  public void run() {
1715                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1716                      if (callbacks != null) {
1717                          callbacks.startBinding();
1718                      }
1719                  }
1720              };
1721              runOnMainThread(r);
1722  
1723              // Load items on the current page
1724              bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
1725                      currentFolders, null);
1726              if (isLoadingSynchronously) {
1727                  r = new Runnable() {
1728                      public void run() {
1729                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1730                          if (callbacks != null) {
1731                              callbacks.onPageBoundSynchronously(currentScreen);
1732                          }
1733                      }
1734                  };
1735                  runOnMainThread(r);
1736              }
1737  
1738              // Load all the remaining pages (if we are loading synchronously, we want to defer this
1739              // work until after the first render)
1740              mDeferredBindRunnables.clear();
1741              bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
1742                      (isLoadingSynchronously ? mDeferredBindRunnables : null));
1743  
1744              // Tell the workspace that we&#x27;re done binding items
1745              r = new Runnable() {
1746                  public void run() {
1747                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1748                      if (callbacks != null) {
1749                          callbacks.finishBindingItems();
1750                      }
1751  
1752                      // If we&#x27;re profiling, ensure this is the last thing in the queue.
1753                      if (DEBUG_LOADERS) {
1754                          Log.d(TAG, &quot;bound workspace in &quot;
1755                              + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
1756                      }
1757  
1758                      mIsLoadingAndBindingWorkspace = false;
1759                  }
1760              };
1761              if (isLoadingSynchronously) {
1762                  mDeferredBindRunnables.add(r);
1763              } else {
1764                  runOnMainThread(r);
1765              }
1766          }
1767  
1768          private void loadAndBindAllApps() {
1769              if (DEBUG_LOADERS) {
1770                  Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
1771              }
1772              if (!mAllAppsLoaded) {
1773                  loadAllAppsByBatch();
1774                  synchronized (LoaderTask.this) {
1775                      if (mStopped) {
1776                          return;
1777                      }
1778                      mAllAppsLoaded = true;
1779                  }
1780              } else {
1781                  onlyBindAllApps();
1782              }
1783          }
1784  
1785          private void onlyBindAllApps() {
1786              final Callbacks oldCallbacks = mCallbacks.get();
1787              if (oldCallbacks == null) {
1788                  // This launcher has exited and nobody bothered to tell us.  Just bail.
1789                  Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
1790                  return;
1791              }
1792  
1793              // shallow copy
1794              @SuppressWarnings(&quot;unchecked&quot;)
1795              final ArrayList&lt;ApplicationInfo&gt; list
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1796 -                    = (ArrayList&lt;ApplicationInfo&gt;) mAllAppsList.data.clone();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1797 +                    = (ArrayList&lt;ApplicationInfo&gt;) mBgAllAppsList.data.clone();</span>
1798              mHandler.post(new Runnable() {

1799                  public void run() {
1800                      final long t = SystemClock.uptimeMillis();
1801                      final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1802                      if (callbacks != null) {
1803                          callbacks.bindAllApplications(list);
1804                      }
1805                      if (DEBUG_LOADERS) {
1806                          Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
1807                                  + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
1808                      }
1809                  }
1810              });







1811          }
1812  
1813          private void loadAllAppsByBatch() {
1814              final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1815  
1816              // Don&#x27;t use these two variables in any of the callback runnables.
1817              // Otherwise we hold a reference to them.
1818              final Callbacks oldCallbacks = mCallbacks.get();
1819              if (oldCallbacks == null) {
1820                  // This launcher has exited and nobody bothered to tell us.  Just bail.
1821                  Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllAppsByBatch)&quot;);
1822                  return;
1823              }
1824  
1825              final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
1826              mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
1827  
1828              final PackageManager packageManager = mContext.getPackageManager();
1829              List&lt;ResolveInfo&gt; apps = null;
1830  
1831              int N = Integer.MAX_VALUE;
1832  
1833              int startIndex;
1834              int i=0;
1835              int batchSize = -1;
1836              while (i &lt; N &amp;&amp; !mStopped) {
1837                  if (i == 0) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1838 -                    mAllAppsList.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1839 +                    mBgAllAppsList.clear();</span>
1840                      final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1841                      apps = packageManager.queryIntentActivities(mainIntent, 0);
1842                      if (DEBUG_LOADERS) {
1843                          Log.d(TAG, &quot;queryIntentActivities took &quot;
1844                                  + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms&quot;);
1845                      }
1846                      if (apps == null) {
1847                          return;
1848                      }
1849                      N = apps.size();
1850                      if (DEBUG_LOADERS) {
1851                          Log.d(TAG, &quot;queryIntentActivities got &quot; + N + &quot; apps&quot;);
1852                      }
1853                      if (N == 0) {
1854                          // There are no apps?!?
1855                          return;
1856                      }
1857                      if (mBatchSize == 0) {
1858                          batchSize = N;
1859                      } else {
1860                          batchSize = mBatchSize;
1861                      }
1862  
1863                      final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1864                      Collections.sort(apps,
1865                              new LauncherModel.ShortcutNameComparator(packageManager, mLabelCache));
1866                      if (DEBUG_LOADERS) {
1867                          Log.d(TAG, &quot;sort took &quot;
1868                                  + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);
1869                      }
1870                  }
1871  
1872                  final long t2 = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1873  
1874                  startIndex = i;
1875                  for (int j=0; i&lt;N &amp;&amp; j&lt;batchSize; j++) {
1876                      // This builds the icon bitmaps.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1877 -                    mAllAppsList.add(new ApplicationInfo(packageManager, apps.get(i),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1878 +                    mBgAllAppsList.add(new ApplicationInfo(packageManager, apps.get(i),</span>
1879                              mIconCache, mLabelCache));
1880                      i++;
1881                  }
1882  
1883                  final boolean first = i &lt;= batchSize;
1884                  final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1885 -                final ArrayList&lt;ApplicationInfo&gt; added = mAllAppsList.added;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1886 -                mAllAppsList.added = new ArrayList&lt;ApplicationInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1887 +                final ArrayList&lt;ApplicationInfo&gt; added = mBgAllAppsList.added;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1888 +                mBgAllAppsList.added = new ArrayList&lt;ApplicationInfo&gt;();</span>
1889  
1890                  mHandler.post(new Runnable() {
1891                      public void run() {
1892                          final long t = SystemClock.uptimeMillis();
1893                          if (callbacks != null) {
1894                              if (first) {
1895                                  callbacks.bindAllApplications(added);
1896                              } else {
1897                                  callbacks.bindAppsAdded(added);
1898                              }
1899                              if (DEBUG_LOADERS) {
1900                                  Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
1901                                      + (SystemClock.uptimeMillis() - t) + &quot;ms&quot;);
1902                              }
1903                          } else {
1904                              Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
1905                          }
1906                      }
1907                  });
1908  
1909                  if (DEBUG_LOADERS) {
1910                      Log.d(TAG, &quot;batch of &quot; + (i-startIndex) + &quot; icons processed in &quot;
1911                              + (SystemClock.uptimeMillis()-t2) + &quot;ms&quot;);
1912                  }
1913  
1914                  if (mAllAppsLoadDelay &gt; 0 &amp;&amp; i &lt; N) {
1915                      try {
1916                          if (DEBUG_LOADERS) {
1917                              Log.d(TAG, &quot;sleeping for &quot; + mAllAppsLoadDelay + &quot;ms&quot;);
1918                          }
1919                          Thread.sleep(mAllAppsLoadDelay);
1920                      } catch (InterruptedException exc) { }
1921                  }
1922              }
1923  
1924              if (DEBUG_LOADERS) {
1925                  Log.d(TAG, &quot;cached all &quot; + N + &quot; apps in &quot;
1926                          + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;
1927                          + (mAllAppsLoadDelay &gt; 0 ? &quot; (including delay)&quot; : &quot;&quot;));
1928              }
1929          }
1930  
1931          public void dumpState() {
1932              synchronized (sBgLock) {
1933                  Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
1934                  Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
1935                  Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
1936                  Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
1937                  Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
1938              }
1939          }
1940      }
1941  
1942      void enqueuePackageUpdated(PackageUpdatedTask task) {
1943          sWorker.post(task);
1944      }
1945  
1946      private class PackageUpdatedTask implements Runnable {
1947          int mOp;
1948          String[] mPackages;
1949  
1950          public static final int OP_NONE = 0;
1951          public static final int OP_ADD = 1;
1952          public static final int OP_UPDATE = 2;
1953          public static final int OP_REMOVE = 3; // uninstlled
1954          public static final int OP_UNAVAILABLE = 4; // external media unmounted
1955  
1956  
1957          public PackageUpdatedTask(int op, String[] packages) {
1958              mOp = op;
1959              mPackages = packages;
1960          }
1961  
1962          public void run() {
1963              final Context context = mApp;
1964  
1965              final String[] packages = mPackages;
1966              final int N = packages.length;
1967              switch (mOp) {
1968                  case OP_ADD:
1969                      for (int i=0; i&lt;N; i++) {
1970                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1971 -                        mAllAppsList.addPackage(context, packages[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1972 +                        mBgAllAppsList.addPackage(context, packages[i]);</span>
1973                      }
1974                      break;
1975                  case OP_UPDATE:
1976                      for (int i=0; i&lt;N; i++) {
1977                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1978 -                        mAllAppsList.updatePackage(context, packages[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1979 +                        mBgAllAppsList.updatePackage(context, packages[i]);</span>
1980                      }
1981                      break;
1982                  case OP_REMOVE:
1983                  case OP_UNAVAILABLE:
1984                      for (int i=0; i&lt;N; i++) {
1985                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1986 -                        mAllAppsList.removePackage(packages[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1987 +                        mBgAllAppsList.removePackage(packages[i]);</span>
1988                      }
1989                      break;
1990              }
1991  
1992              ArrayList&lt;ApplicationInfo&gt; added = null;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1993 -            ArrayList&lt;ApplicationInfo&gt; removed = null;</span>
1994              ArrayList&lt;ApplicationInfo&gt; modified = null;
1995  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1996 -            if (mAllAppsList.added.size() &gt; 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1997 -                added = mAllAppsList.added;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1998 -                mAllAppsList.added = new ArrayList&lt;ApplicationInfo&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1999 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2000 -            if (mAllAppsList.removed.size() &gt; 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2001 -                removed = mAllAppsList.removed;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2002 -                mAllAppsList.removed = new ArrayList&lt;ApplicationInfo&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2003 -                for (ApplicationInfo info: removed) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2004 -                    mIconCache.remove(info.intent.getComponent());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2005 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2006 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2007 -            if (mAllAppsList.modified.size() &gt; 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2008 -                modified = mAllAppsList.modified;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2009 -                mAllAppsList.modified = new ArrayList&lt;ApplicationInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2010 +            if (mBgAllAppsList.added.size() &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2011 +                added = new ArrayList&lt;ApplicationInfo&gt;(mBgAllAppsList.added);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2012 +                mBgAllAppsList.added.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2013 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2014 +            if (mBgAllAppsList.modified.size() &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2015 +                modified = new ArrayList&lt;ApplicationInfo&gt;(mBgAllAppsList.modified);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2016 +                mBgAllAppsList.modified.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2017 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2018 +            // We may be removing packages that have no associated launcher application, so we</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2019 +            // pass through the removed package names directly.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2020 +            // NOTE: We flush the icon cache aggressively in removePackage() above.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2021 +            final ArrayList&lt;String&gt; removedPackageNames = new ArrayList&lt;String&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2022 +            if (mBgAllAppsList.removed.size() &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2023 +                mBgAllAppsList.removed.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2024 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2025 +                for (int i = 0; i &lt; N; ++i) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2026 +                    removedPackageNames.add(packages[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2027 +                }</span>
2028              }
2029  
2030              final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
2031              if (callbacks == null) {
2032                  Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
2033                  return;
2034              }
2035  
2036              if (added != null) {
2037                  final ArrayList&lt;ApplicationInfo&gt; addedFinal = added;
2038                  mHandler.post(new Runnable() {
2039                      public void run() {
2040                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2041                          if (callbacks == cb &amp;&amp; cb != null) {
2042                              callbacks.bindAppsAdded(addedFinal);
2043                          }
2044                      }
2045                  });
2046              }
2047              if (modified != null) {
2048                  final ArrayList&lt;ApplicationInfo&gt; modifiedFinal = modified;
2049                  mHandler.post(new Runnable() {
2050                      public void run() {
2051                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2052                          if (callbacks == cb &amp;&amp; cb != null) {
2053                              callbacks.bindAppsUpdated(modifiedFinal);
2054                          }
2055                      }
2056                  });
2057              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2058 -            if (removed != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2059 +            if (!removedPackageNames.isEmpty()) {</span>
2060                  final boolean permanent = mOp != OP_UNAVAILABLE;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2061 -                final ArrayList&lt;ApplicationInfo&gt; removedFinal = removed;</span>
2062                  mHandler.post(new Runnable() {
2063                      public void run() {
2064                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2065                          if (callbacks == cb &amp;&amp; cb != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2066 -                            callbacks.bindAppsRemoved(removedFinal, permanent);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2067 +                            callbacks.bindAppsRemoved(removedPackageNames, permanent);</span>
2068                          }
2069                      }
2070                  });
2071              }
2072  
2073              mHandler.post(new Runnable() {
2074                  @Override
2075                  public void run() {
2076                      Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2077                      if (callbacks == cb &amp;&amp; cb != null) {
2078                          callbacks.bindPackagesUpdated();
2079                      }
2080                  }
2081              });
2082          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2083 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2084 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2085 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2086 -     * Returns all the Workspace ShortcutInfos associated with a particular package.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2087 -     * @param intent</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2088 -     * @return</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2089 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2090 -    ArrayList&lt;ShortcutInfo&gt; getShortcutInfosForPackage(String packageName) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2091 -        ArrayList&lt;ShortcutInfo&gt; infos = new ArrayList&lt;ShortcutInfo&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2092 -        synchronized (sBgLock) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2093 -            for (ItemInfo i : sBgWorkspaceItems) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2094 -                if (i instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2095 -                    ShortcutInfo info = (ShortcutInfo) i;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2096 -                    if (packageName.equals(info.getPackageName())) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2097 -                        infos.add(info);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2098 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2099 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2100 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2101 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2102 -        return infos;</span>
2103      }
2104  
2105      /**
2106       * This is called from the code that adds shortcuts from the intent receiver.  This
2107       * doesn&#x27;t have a Cursor, but
2108       */
2109      public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context) {
2110          return getShortcutInfo(manager, intent, context, null, -1, -1, null);
2111      }
2112  
2113      /**
2114       * Make an ShortcutInfo object for a shortcut that is an application.
2115       *
2116       * If c is not null, then it will be used to fill in missing data like the title and icon.
2117       */
2118      public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context,
2119              Cursor c, int iconIndex, int titleIndex, HashMap&lt;Object, CharSequence&gt; labelCache) {
2120          Bitmap icon = null;
2121          final ShortcutInfo info = new ShortcutInfo();
2122  
2123          ComponentName componentName = intent.getComponent();
2124          if (componentName == null) {
2125              return null;
2126          }
2127  
2128          try {
2129              PackageInfo pi = manager.getPackageInfo(componentName.getPackageName(), 0);
2130              if (!pi.applicationInfo.enabled) {
2131                  // If we return null here, the corresponding item will be removed from the launcher
2132                  // db and will not appear in the workspace.
2133                  return null;
2134              }
2135          } catch (NameNotFoundException e) {
2136              Log.d(TAG, &quot;getPackInfo failed for package &quot; + componentName.getPackageName());
2137          }
2138  
2139          // TODO: See if the PackageManager knows about this case.  If it doesn&#x27;t
2140          // then return null &amp; delete this.
2141  
2142          // the resource -- This may implicitly give us back the fallback icon,
2143          // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
2144          // to avoid saving lots of copies of that in the database, and most apps
2145          // have icons anyway.
2146  
2147          // Attempt to use queryIntentActivities to get the ResolveInfo (with IntentFilter info) and
2148          // if that fails, or is ambiguious, fallback to the standard way of getting the resolve info
2149          // via resolveActivity().
2150          ResolveInfo resolveInfo = null;
2151          ComponentName oldComponent = intent.getComponent();
2152          Intent newIntent = new Intent(intent.getAction(), null);
2153          newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2154          newIntent.setPackage(oldComponent.getPackageName());
2155          List&lt;ResolveInfo&gt; infos = manager.queryIntentActivities(newIntent, 0);
2156          for (ResolveInfo i : infos) {
2157              ComponentName cn = new ComponentName(i.activityInfo.packageName,
2158                      i.activityInfo.name);
2159              if (cn.equals(oldComponent)) {
2160                  resolveInfo = i;
2161              }
2162          }
2163          if (resolveInfo == null) {
2164              resolveInfo = manager.resolveActivity(intent, 0);
2165          }
2166          if (resolveInfo != null) {
2167              icon = mIconCache.getIcon(componentName, resolveInfo, labelCache);
2168          }
2169          // the db
2170          if (icon == null) {
2171              if (c != null) {
2172                  icon = getIconFromCursor(c, iconIndex, context);
2173              }
2174          }
2175          // the fallback icon
2176          if (icon == null) {
2177              icon = getFallbackIcon();
2178              info.usingFallbackIcon = true;
2179          }
2180          info.setIcon(icon);
2181  
2182          // from the resource
2183          if (resolveInfo != null) {
2184              ComponentName key = LauncherModel.getComponentNameFromResolveInfo(resolveInfo);
2185              if (labelCache != null &amp;&amp; labelCache.containsKey(key)) {
2186                  info.title = labelCache.get(key);
2187              } else {
2188                  info.title = resolveInfo.activityInfo.loadLabel(manager);
2189                  if (labelCache != null) {
2190                      labelCache.put(key, info.title);
2191                  }
2192              }
2193          }
2194          // from the db
2195          if (info.title == null) {
2196              if (c != null) {
2197                  info.title =  c.getString(titleIndex);
2198              }
2199          }
2200          // fall back to the class name of the activity
2201          if (info.title == null) {
2202              info.title = componentName.getClassName();
2203          }
2204          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
2205          return info;
2206      }
2207  
2208      /**
2209       * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
2210       */
2211      private ShortcutInfo getShortcutInfo(Cursor c, Context context,
2212              int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
2213              int titleIndex) {
2214  
2215          Bitmap icon = null;
2216          final ShortcutInfo info = new ShortcutInfo();
2217          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
2218  
2219          // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
2220  
2221          info.title = c.getString(titleIndex);
2222  
2223          int iconType = c.getInt(iconTypeIndex);
2224          switch (iconType) {
2225          case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
2226              String packageName = c.getString(iconPackageIndex);
2227              String resourceName = c.getString(iconResourceIndex);
2228              PackageManager packageManager = context.getPackageManager();
2229              info.customIcon = false;
2230              // the resource
2231              try {
2232                  Resources resources = packageManager.getResourcesForApplication(packageName);
2233                  if (resources != null) {
2234                      final int id = resources.getIdentifier(resourceName, null, null);
2235                      icon = Utilities.createIconBitmap(
2236                              mIconCache.getFullResIcon(resources, id), context);
2237                  }
2238              } catch (Exception e) {
2239                  // drop this.  we have other places to look for icons
2240              }
2241              // the db
2242              if (icon == null) {
2243                  icon = getIconFromCursor(c, iconIndex, context);
2244              }
2245              // the fallback icon
2246              if (icon == null) {
2247                  icon = getFallbackIcon();
2248                  info.usingFallbackIcon = true;
2249              }
2250              break;
2251          case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
2252              icon = getIconFromCursor(c, iconIndex, context);
2253              if (icon == null) {
2254                  icon = getFallbackIcon();
2255                  info.customIcon = false;
2256                  info.usingFallbackIcon = true;
2257              } else {
2258                  info.customIcon = true;
2259              }
2260              break;
2261          default:
2262              icon = getFallbackIcon();
2263              info.usingFallbackIcon = true;
2264              info.customIcon = false;
2265              break;
2266          }
2267          info.setIcon(icon);
2268          return info;
2269      }
2270  
2271      Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
2272          @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
2273          final boolean debug = false;
2274          if (debug) {
2275              Log.d(TAG, &quot;getIconFromCursor app=&quot;
2276                      + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
2277          }
2278          byte[] data = c.getBlob(iconIndex);
2279          try {
2280              return Utilities.createIconBitmap(
2281                      BitmapFactory.decodeByteArray(data, 0, data.length), context);
2282          } catch (Exception e) {
2283              return null;
2284          }
2285      }
2286  
2287      ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
2288              int cellX, int cellY, boolean notify) {
2289          final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
2290          if (info == null) {
2291              return null;
2292          }
2293          addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
2294  
2295          return info;
2296      }
2297  
2298      /**
2299       * Attempts to find an AppWidgetProviderInfo that matches the given component.
2300       */
2301      AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,
2302              ComponentName component) {
2303          List&lt;AppWidgetProviderInfo&gt; widgets =
2304              AppWidgetManager.getInstance(context).getInstalledProviders();
2305          for (AppWidgetProviderInfo info : widgets) {
2306              if (info.provider.equals(component)) {
2307                  return info;
2308              }
2309          }
2310          return null;
2311      }
2312  
2313      /**
2314       * Returns a list of all the widgets that can handle configuration with a particular mimeType.
2315       */
2316      List&lt;WidgetMimeTypeHandlerData&gt; resolveWidgetsForMimeType(Context context, String mimeType) {
2317          final PackageManager packageManager = context.getPackageManager();
2318          final List&lt;WidgetMimeTypeHandlerData&gt; supportedConfigurationActivities =
2319              new ArrayList&lt;WidgetMimeTypeHandlerData&gt;();
2320  
2321          final Intent supportsIntent =
2322              new Intent(InstallWidgetReceiver.ACTION_SUPPORTS_CLIPDATA_MIMETYPE);
2323          supportsIntent.setType(mimeType);
2324  
2325          // Create a set of widget configuration components that we can test against
2326          final List&lt;AppWidgetProviderInfo&gt; widgets =
2327              AppWidgetManager.getInstance(context).getInstalledProviders();
2328          final HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; configurationComponentToWidget =
2329              new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;();
2330          for (AppWidgetProviderInfo info : widgets) {
2331              configurationComponentToWidget.put(info.configure, info);
2332          }
2333  
2334          // Run through each of the intents that can handle this type of clip data, and cross
2335          // reference them with the components that are actual configuration components
2336          final List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(supportsIntent,
2337                  PackageManager.MATCH_DEFAULT_ONLY);
2338          for (ResolveInfo info : activities) {
2339              final ActivityInfo activityInfo = info.activityInfo;
2340              final ComponentName infoComponent = new ComponentName(activityInfo.packageName,
2341                      activityInfo.name);
2342              if (configurationComponentToWidget.containsKey(infoComponent)) {
2343                  supportedConfigurationActivities.add(
2344                          new InstallWidgetReceiver.WidgetMimeTypeHandlerData(info,
2345                                  configurationComponentToWidget.get(infoComponent)));
2346              }
2347          }
2348          return supportedConfigurationActivities;
2349      }
2350  
2351      ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
2352          Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
2353          String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
2354          Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
2355  
2356          if (intent == null) {
2357              // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
2358              Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
2359              return null;
2360          }
2361  
2362          Bitmap icon = null;
2363          boolean customIcon = false;
2364          ShortcutIconResource iconResource = null;
2365  
2366          if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {
2367              icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);
2368              customIcon = true;
2369          } else {
2370              Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
2371              if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {
2372                  try {
2373                      iconResource = (ShortcutIconResource) extra;
2374                      final PackageManager packageManager = context.getPackageManager();
2375                      Resources resources = packageManager.getResourcesForApplication(
2376                              iconResource.packageName);
2377                      final int id = resources.getIdentifier(iconResource.resourceName, null, null);
2378                      icon = Utilities.createIconBitmap(
2379                              mIconCache.getFullResIcon(resources, id), context);
2380                  } catch (Exception e) {
2381                      Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);
2382                  }
2383              }
2384          }
2385  
2386          final ShortcutInfo info = new ShortcutInfo();
2387  
2388          if (icon == null) {
2389              if (fallbackIcon != null) {
2390                  icon = fallbackIcon;
2391              } else {
2392                  icon = getFallbackIcon();
2393                  info.usingFallbackIcon = true;
2394              }
2395          }
2396          info.setIcon(icon);
2397  
2398          info.title = name;
2399          info.intent = intent;
2400          info.customIcon = customIcon;
2401          info.iconResource = iconResource;
2402  
2403          return info;
2404      }
2405  
2406      boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
2407              int iconIndex) {
2408          // If apps can&#x27;t be on SD, don&#x27;t even bother.
2409          if (!mAppsCanBeOnExternalStorage) {
2410              return false;
2411          }
2412          // If this icon doesn&#x27;t have a custom icon, check to see
2413          // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
2414          // we&#x27;re going to show, store what we are going to show back
2415          // into the DB.  We do this so when we&#x27;re loading, if the
2416          // package manager can&#x27;t find an icon (for example because
2417          // the app is on SD) then we can use that instead.
2418          if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
2419              cache.put(info, c.getBlob(iconIndex));
2420              return true;
2421          }
2422          return false;
2423      }
2424      void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
2425          boolean needSave = false;
2426          try {
2427              if (data != null) {
2428                  Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
2429                  Bitmap loaded = info.getIcon(mIconCache);
2430                  needSave = !saved.sameAs(loaded);
2431              } else {
2432                  needSave = true;
2433              }
2434          } catch (Exception e) {
2435              needSave = true;
2436          }
2437          if (needSave) {
2438              Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
2439              // This is slower than is ideal, but this only happens once
2440              // or when the app is updated with a new icon.
2441              updateItemInDatabase(context, info);
2442          }
2443      }
2444  
2445      /**
2446       * Return an existing FolderInfo object if we have encountered this ID previously,
2447       * or make a new one.
2448       */
2449      private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
2450          // See if a placeholder was created for us already
2451          FolderInfo folderInfo = folders.get(id);
2452          if (folderInfo == null) {
2453              // No placeholder -- create a new instance
2454              folderInfo = new FolderInfo();
2455              folders.put(id, folderInfo);
2456          }
2457          return folderInfo;
2458      }
2459  
2460      private static final Collator sCollator = Collator.getInstance();
2461      public static final Comparator&lt;ApplicationInfo&gt; APP_NAME_COMPARATOR
2462              = new Comparator&lt;ApplicationInfo&gt;() {
2463          public final int compare(ApplicationInfo a, ApplicationInfo b) {
2464              int result = sCollator.compare(a.title.toString(), b.title.toString());
2465              if (result == 0) {
2466                  result = a.componentName.compareTo(b.componentName);
2467              }
2468              return result;
2469          }
2470      };
2471      public static final Comparator&lt;ApplicationInfo&gt; APP_INSTALL_TIME_COMPARATOR
2472              = new Comparator&lt;ApplicationInfo&gt;() {
2473          public final int compare(ApplicationInfo a, ApplicationInfo b) {
2474              if (a.firstInstallTime &lt; b.firstInstallTime) return 1;
2475              if (a.firstInstallTime &gt; b.firstInstallTime) return -1;
2476              return 0;
2477          }
2478      };
2479      public static final Comparator&lt;AppWidgetProviderInfo&gt; WIDGET_NAME_COMPARATOR
2480              = new Comparator&lt;AppWidgetProviderInfo&gt;() {
2481          public final int compare(AppWidgetProviderInfo a, AppWidgetProviderInfo b) {
2482              return sCollator.compare(a.label.toString(), b.label.toString());
2483          }
2484      };
2485      static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
2486          if (info.activityInfo != null) {
2487              return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
2488          } else {
2489              return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
2490          }
2491      }
2492      public static class ShortcutNameComparator implements Comparator&lt;ResolveInfo&gt; {
2493          private PackageManager mPackageManager;
2494          private HashMap&lt;Object, CharSequence&gt; mLabelCache;
2495          ShortcutNameComparator(PackageManager pm) {
2496              mPackageManager = pm;
2497              mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
2498          }
2499          ShortcutNameComparator(PackageManager pm, HashMap&lt;Object, CharSequence&gt; labelCache) {
2500              mPackageManager = pm;
2501              mLabelCache = labelCache;
2502          }
2503          public final int compare(ResolveInfo a, ResolveInfo b) {
2504              CharSequence labelA, labelB;
2505              ComponentName keyA = LauncherModel.getComponentNameFromResolveInfo(a);
2506              ComponentName keyB = LauncherModel.getComponentNameFromResolveInfo(b);
2507              if (mLabelCache.containsKey(keyA)) {
2508                  labelA = mLabelCache.get(keyA);
2509              } else {
2510                  labelA = a.loadLabel(mPackageManager).toString();
2511  
2512                  mLabelCache.put(keyA, labelA);
2513              }
2514              if (mLabelCache.containsKey(keyB)) {
2515                  labelB = mLabelCache.get(keyB);
2516              } else {
2517                  labelB = b.loadLabel(mPackageManager).toString();
2518  
2519                  mLabelCache.put(keyB, labelB);
2520              }
2521              return sCollator.compare(labelA, labelB);
2522          }
2523      };
2524      public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
2525          private PackageManager mPackageManager;
2526          private HashMap&lt;Object, String&gt; mLabelCache;
2527          WidgetAndShortcutNameComparator(PackageManager pm) {
2528              mPackageManager = pm;
2529              mLabelCache = new HashMap&lt;Object, String&gt;();
2530          }
2531          public final int compare(Object a, Object b) {
2532              String labelA, labelB;
2533              if (mLabelCache.containsKey(a)) {
2534                  labelA = mLabelCache.get(a);
2535              } else {
2536                  labelA = (a instanceof AppWidgetProviderInfo) ?
2537                      ((AppWidgetProviderInfo) a).label :
2538                      ((ResolveInfo) a).loadLabel(mPackageManager).toString();
2539                  mLabelCache.put(a, labelA);
2540              }
2541              if (mLabelCache.containsKey(b)) {
2542                  labelB = mLabelCache.get(b);
2543              } else {
2544                  labelB = (b instanceof AppWidgetProviderInfo) ?
2545                      ((AppWidgetProviderInfo) b).label :
2546                      ((ResolveInfo) b).loadLabel(mPackageManager).toString();
2547                  mLabelCache.put(b, labelB);
2548              }
2549              return sCollator.compare(labelA, labelB);
2550          }
2551      };
2552  
2553      public void dumpState() {
2554          Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2555 -        ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mAllAppsList.data);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2556 -        ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mAllAppsList.added);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2557 -        ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mAllAppsList.removed);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2558 -        ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mAllAppsList.modified);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2559 +        ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2560 +        ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2561 +        ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2562 +        ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);</span>
2563          if (mLoaderTask != null) {
2564              mLoaderTask.dumpState();
2565          } else {
2566              Log.d(TAG, &quot;mLoaderTask=null&quot;);
2567          }
2568      }
2569  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher2;
  18  
  19  import android.app.SearchManager;
  20  import android.appwidget.AppWidgetManager;
  21  import android.appwidget.AppWidgetProviderInfo;
  22  import android.content.BroadcastReceiver;
  23  import android.content.ComponentName;
  24  import android.content.ContentProviderClient;
  25  import android.content.ContentResolver;
  26  import android.content.ContentValues;
  27  import android.content.Context;
  28  import android.content.Intent;
  29  import android.content.Intent.ShortcutIconResource;
  30  import android.content.pm.ActivityInfo;
  31  import android.content.pm.PackageInfo;
  32  import android.content.pm.PackageManager;
  33  import android.content.pm.PackageManager.NameNotFoundException;
  34  import android.content.pm.ResolveInfo;
  35  import android.content.res.Configuration;
  36  import android.content.res.Resources;
  37  import android.database.Cursor;
  38  import android.graphics.Bitmap;
  39  import android.graphics.BitmapFactory;
  40  import android.net.Uri;
  41  import android.os.Environment;
  42  import android.os.Handler;
  43  import android.os.HandlerThread;
  44  import android.os.Parcelable;
  45  import android.os.Process;
  46  import android.os.RemoteException;
  47  import android.os.SystemClock;
  48  import android.util.Log;
  49  
  50  import com.android.launcher.R;
  51  import com.android.launcher2.InstallWidgetReceiver.WidgetMimeTypeHandlerData;
  52  
  53  import java.lang.ref.WeakReference;
  54  import java.net.URISyntaxException;
  55  import java.text.Collator;
  56  import java.util.ArrayList;
  57  import java.util.Collections;
  58  import java.util.Comparator;
  59  import java.util.HashMap;
  60  import java.util.HashSet;
  61  import java.util.Iterator;
  62  import java.util.List;
  63  import java.util.Set;
  64  
  65  /**
  66   * Maintains in-memory state of the Launcher. It is expected that there should be only one
  67   * LauncherModel object held in a static. Also provide APIs for updating the database state
  68   * for the Launcher.
  69   */
  70  public class LauncherModel extends BroadcastReceiver {
  71      static final boolean DEBUG_LOADERS = false;
  72      static final String TAG = &quot;Launcher.Model&quot;;
  73  
  74      private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
  75      private final boolean mAppsCanBeOnExternalStorage;
  76      private int mBatchSize; // 0 is all apps at once
  77      private int mAllAppsLoadDelay; // milliseconds between batches
  78  
  79      private final LauncherApplication mApp;
  80      private final Object mLock = new Object();
  81      private DeferredHandler mHandler = new DeferredHandler();
  82      private LoaderTask mLoaderTask;
  83      private boolean mIsLoaderTaskRunning;
  84  
  85      private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
  86      static {
  87          sWorkerThread.start();
  88      }
  89      private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
  90  
  91      // We start off with everything not loaded.  After that, we assume that
  92      // our monitoring of the package manager provides all updates and we never
  93      // need to do a requery.  These are only ever touched from the loader thread.
  94      private boolean mWorkspaceLoaded;
  95      private boolean mAllAppsLoaded;
  96  
  97      // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
  98      // pages as this delays the rotation process.  Instead, we wait for a callback from the first
  99      // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 100      // a normal load, we also clear this set of Runnables.
 101      static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 102  
 103      private WeakReference&lt;Callbacks&gt; mCallbacks;
 104  
 105      // &lt; only access in worker thread &gt;
 106      private AllAppsList mAllAppsList;

 107  
 108      // The lock that must be acquired before referencing any static bg data structures.  Unlike
 109      // other locks, this one can generally be held long-term because we never expect any of these
 110      // static data structures to be referenced outside of the worker thread except on the first
 111      // load after configuration change.
 112      static final Object sBgLock = new Object();
 113  
 114      // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 115      // LauncherModel to their ids
 116      static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
 117  
 118      // sBgItems is passed to bindItems, which expects a list of all folders and shortcuts created by
 119      //       LauncherModel that are directly on the home screen (however, no widgets or shortcuts
 120      //       within folders).



 121      static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 122  
 123      // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 124      static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 125          new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 126  
 127      // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 128      static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 129  
 130      // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 131      static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 132  
 133      // &lt;/ only access in worker thread &gt;
 134  
 135      private IconCache mIconCache;
 136      private Bitmap mDefaultIcon;
 137  
 138      private static int mCellCountX;
 139      private static int mCellCountY;
 140  
 141      protected int mPreviousConfigMcc;
 142  
 143      public interface Callbacks {
 144          public boolean setLoadOnResume();
 145          public int getCurrentWorkspaceScreen();
 146          public void startBinding();
 147          public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end);
 148          public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 149          public void finishBindingItems();
 150          public void bindAppWidget(LauncherAppWidgetInfo info);
 151          public void bindAllApplications(ArrayList&lt;ApplicationInfo&gt; apps);
 152          public void bindAppsAdded(ArrayList&lt;ApplicationInfo&gt; apps);
 153          public void bindAppsUpdated(ArrayList&lt;ApplicationInfo&gt; apps);
 154          public void bindAppsRemoved(ArrayList&lt;ApplicationInfo&gt; apps, boolean permanent);

 155          public void bindPackagesUpdated();
 156          public boolean isAllAppsVisible();
 157          public boolean isAllAppsButtonRank(int rank);
 158          public void bindSearchablesChanged();
 159          public void onPageBoundSynchronously(int page);
 160      }
 161  
 162      LauncherModel(LauncherApplication app, IconCache iconCache) {
 163          mAppsCanBeOnExternalStorage = !Environment.isExternalStorageEmulated();
 164          mApp = app;
 165          mAllAppsList = new AllAppsList(iconCache);

 166          mIconCache = iconCache;
 167  
 168          mDefaultIcon = Utilities.createIconBitmap(
 169                  mIconCache.getFullResDefaultActivityIcon(), app);
 170  
 171          final Resources res = app.getResources();
 172          mAllAppsLoadDelay = res.getInteger(R.integer.config_allAppsBatchLoadDelay);
 173          mBatchSize = res.getInteger(R.integer.config_allAppsBatchSize);
 174          Configuration config = res.getConfiguration();
 175          mPreviousConfigMcc = config.mcc;
 176      }
 177  
 178      /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 179       * posted on the main thread handler. */
 180      private void runOnMainThread(Runnable r) {
 181          if (sWorkerThread.getThreadId() == Process.myTid()) {
 182              // If we are on the worker thread, post onto the main handler
 183              mHandler.post(r);
 184          } else {
 185              r.run();
 186          }
 187      }
 188  
 189      /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 190       * posted on the worker thread handler. */
 191      private static void runOnWorkerThread(Runnable r) {
 192          if (sWorkerThread.getThreadId() == Process.myTid()) {
 193              r.run();
 194          } else {
 195              // If we are not on the worker thread, then post to the worker handler
 196              sWorker.post(r);
 197          }
 198      }
 199  
 200      public Bitmap getFallbackIcon() {
 201          return Bitmap.createBitmap(mDefaultIcon);
 202      }
 203  
 204      public void unbindWorkspaceItems() {
 205          sWorker.post(new Runnable() {
 206              @Override
 207              public void run() {
 208                  unbindWorkspaceItemsOnMainThread();
 209              }
 210          });
 211      }
 212  
 213      /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 214      private void unbindWorkspaceItemsOnMainThread() {
 215          // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 216          // by making a copy of workspace items first.
 217          final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 218          final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 219          synchronized (sBgLock) {
 220              tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 221              tmpAppWidgets.addAll(sBgAppWidgets);
 222          }
 223          Runnable r = new Runnable() {
 224                  @Override
 225                  public void run() {
 226                     for (ItemInfo item : tmpWorkspaceItems) {
 227                         item.unbind();
 228                     }
 229                     for (ItemInfo item : tmpAppWidgets) {
 230                         item.unbind();
 231                     }
 232                  }
 233              };
 234          runOnMainThread(r);
 235      }
 236  
 237      /**
 238       * Adds an item to the DB if it was not created previously, or move it to a new
 239       * &lt;container, screen, cellX, cellY&gt;
 240       */
 241      static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 242              int screen, int cellX, int cellY) {
 243          if (item.container == ItemInfo.NO_ID) {
 244              // From all apps
 245              addItemToDatabase(context, item, container, screen, cellX, cellY, false);
 246          } else {
 247              // From somewhere else
 248              moveItemInDatabase(context, item, container, screen, cellX, cellY);
 249          }
 250      }
 251  

























 252      static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 253              final ItemInfo item, final String callingFunction) {
 254          final long itemId = item.id;
 255          final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 256          final ContentResolver cr = context.getContentResolver();
 257  

 258          Runnable r = new Runnable() {
 259              public void run() {
 260                  cr.update(uri, values, null, null);
 261  
 262                  // Lock on mBgLock *after* the db operation
 263                  synchronized (sBgLock) {
 264                      ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 265                      if (item != modelItem) {
 266                          // the modelItem needs to match up perfectly with item if our model is to be
 267                          // consistent with the database-- for now, just require modelItem == item
 268                          String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 269                              &quot;modelItem: &quot; + ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 270                              &quot;Error: ItemInfo passed to &quot; + callingFunction + &quot; doesn&#x27;t match &quot; +
 271                              &quot;original&quot;;
 272                          throw new RuntimeException(msg);
 273                      }
 274  















 275                      // Items are added/removed from the corresponding FolderInfo elsewhere, such
 276                      // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 277                      // that are on the desktop, as appropriate
 278                      if (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 279                              modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 280                          if (!sBgWorkspaceItems.contains(modelItem)) {
 281                              sBgWorkspaceItems.add(modelItem);
 282  










 283                          }
 284                      } else {
 285                          sBgWorkspaceItems.remove(modelItem);
 286                      }
 287                  }
 288              }
 289          };
 290          runOnWorkerThread(r);
 291      }
 292  
 293      /**
 294       * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 295       */
 296      static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 297              final int screen, final int cellX, final int cellY) {





 298          item.container = container;
 299          item.cellX = cellX;
 300          item.cellY = cellY;
 301  
 302          // We store hotseat items in canonical form which is this orientation invariant position
 303          // in the hotseat
 304          if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 305                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 306              item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 307          } else {
 308              item.screen = screen;
 309          }
 310  
 311          final ContentValues values = new ContentValues();
 312          values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 313          values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 314          values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 315          values.put(LauncherSettings.Favorites.SCREEN, item.screen);
 316  
 317          updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 318      }
 319  
 320      /**
 321       * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 322       */
 323      static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 324              final int screen, final int cellX, final int cellY, final int spanX, final int spanY) {
 325          item.container = container;





 326          item.cellX = cellX;
 327          item.cellY = cellY;
 328          item.spanX = spanX;
 329          item.spanY = spanY;
 330  
 331          // We store hotseat items in canonical form which is this orientation invariant position
 332          // in the hotseat
 333          if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 334                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 335              item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 336          } else {
 337              item.screen = screen;
 338          }
 339  
 340          final ContentValues values = new ContentValues();
 341          values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 342          values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 343          values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 344          values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 345          values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 346          values.put(LauncherSettings.Favorites.SCREEN, item.screen);
 347  
 348          updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);

 349      }
 350  
 351      /**
 352       * Update an item to the database in a specified container.
 353       */
 354      static void updateItemInDatabase(Context context, final ItemInfo item) {
 355          final ContentValues values = new ContentValues();
 356          item.onAddToDatabase(values);
 357          item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 358          updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 359      }
 360  
 361      /**
 362       * Returns true if the shortcuts already exists in the database.
 363       * we identify a shortcut by its title and intent.
 364       */
 365      static boolean shortcutExists(Context context, String title, Intent intent) {
 366          final ContentResolver cr = context.getContentResolver();
 367          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 368              new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and intent=?&quot;,
 369              new String[] { title, intent.toUri(0) }, null);
 370          boolean result = false;
 371          try {
 372              result = c.moveToFirst();
 373          } finally {
 374              c.close();
 375          }
 376          return result;
 377      }
 378  
 379      /**
 380       * Returns an ItemInfo array containing all the items in the LauncherModel.
 381       * The ItemInfo.id is not set through this function.
 382       */
 383      static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 384          ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 385          final ContentResolver cr = context.getContentResolver();
 386          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
 387                  LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
<abbr title=" 388                  LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,"> 388                  LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CEðŸ”µ</abbr>
 389                  LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY }, null, null, null);
 390  
 391          final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 392          final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 393          final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 394          final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 395          final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 396          final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 397          final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 398  
 399          try {
 400              while (c.moveToNext()) {
 401                  ItemInfo item = new ItemInfo();
 402                  item.cellX = c.getInt(cellXIndex);
 403                  item.cellY = c.getInt(cellYIndex);
 404                  item.spanX = c.getInt(spanXIndex);
 405                  item.spanY = c.getInt(spanYIndex);
 406                  item.container = c.getInt(containerIndex);
 407                  item.itemType = c.getInt(itemTypeIndex);
 408                  item.screen = c.getInt(screenIndex);
 409  
 410                  items.add(item);
 411              }
 412          } catch (Exception e) {
 413              items.clear();
 414          } finally {
 415              c.close();
 416          }
 417  
 418          return items;
 419      }
 420  
 421      /**
 422       * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 423       */
 424      FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
 425          final ContentResolver cr = context.getContentResolver();
 426          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
 427                  &quot;_id=? and (itemType=? or itemType=?)&quot;,
 428                  new String[] { String.valueOf(id),
 429                          String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
 430  
 431          try {
 432              if (c.moveToFirst()) {
 433                  final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 434                  final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 435                  final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 436                  final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 437                  final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 438                  final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 439  
 440                  FolderInfo folderInfo = null;
 441                  switch (c.getInt(itemTypeIndex)) {
 442                      case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 443                          folderInfo = findOrMakeFolder(folderList, id);
 444                          break;
 445                  }
 446  
 447                  folderInfo.title = c.getString(titleIndex);
 448                  folderInfo.id = id;
 449                  folderInfo.container = c.getInt(containerIndex);
 450                  folderInfo.screen = c.getInt(screenIndex);
 451                  folderInfo.cellX = c.getInt(cellXIndex);
 452                  folderInfo.cellY = c.getInt(cellYIndex);
 453  
 454                  return folderInfo;
 455              }
 456          } finally {
 457              c.close();
 458          }
 459  
 460          return null;
 461      }
 462  
 463      /**
 464       * Add an item to the database in a specified container. Sets the container, screen, cellX and
 465       * cellY fields of the item. Also assigns an ID to the item.
 466       */
 467      static void addItemToDatabase(Context context, final ItemInfo item, final long container,
 468              final int screen, final int cellX, final int cellY, final boolean notify) {
 469          item.container = container;
 470          item.cellX = cellX;
 471          item.cellY = cellY;
 472          // We store hotseat items in canonical form which is this orientation invariant position
 473          // in the hotseat
 474          if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 475                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 476              item.screen = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 477          } else {
 478              item.screen = screen;
 479          }
 480  
 481          final ContentValues values = new ContentValues();
 482          final ContentResolver cr = context.getContentResolver();
 483          item.onAddToDatabase(values);
 484  
 485          LauncherApplication app = (LauncherApplication) context.getApplicationContext();
 486          item.id = app.getLauncherProvider().generateNewId();
 487          values.put(LauncherSettings.Favorites._ID, item.id);
 488          item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 489  


 490          Runnable r = new Runnable() {
 491              public void run() {






 492                  cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
 493                          LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);

 494                  // Lock on mBgLock *after* the db operation
 495                  synchronized (sBgLock) {
 496                      if (sBgItemsIdMap.containsKey(item.id)) {
 497                          // we should not be adding new items in the db with the same id
 498                          throw new RuntimeException(&quot;Error: ItemInfo id (&quot; + item.id + &quot;) passed to &quot; +
 499                              &quot;addItemToDatabase already exists.&quot; + item.toString());
 500                      }
 501                      sBgItemsIdMap.put(item.id, item);
 502                      switch (item.itemType) {
 503                          case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 504                              sBgFolders.put(item.id, (FolderInfo) item);
 505                              // Fall through
 506                          case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 507                          case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 508                              if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 509                                      item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 510                                  sBgWorkspaceItems.add(item);










 511                              }
 512                              break;
 513                          case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
 514                              sBgAppWidgets.add((LauncherAppWidgetInfo) item);
 515                              break;
 516                      }
 517                  }
 518              }
 519          };
 520          runOnWorkerThread(r);
 521      }
 522  
 523      /**
 524       * Creates a new unique child id, for a given cell span across all layouts.
 525       */
 526      static int getCellLayoutChildId(
 527              long container, int screen, int localCellX, int localCellY, int spanX, int spanY) {
 528          return (((int) container &amp; 0xFF) &lt;&lt; 24)
 529                  | (screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
 530      }
 531  
 532      static int getCellCountX() {
 533          return mCellCountX;
 534      }
 535  
 536      static int getCellCountY() {
 537          return mCellCountY;
 538      }
 539  
 540      /**
 541       * Updates the model orientation helper to take into account the current layout dimensions
 542       * when performing local/canonical coordinate transformations.
 543       */
 544      static void updateWorkspaceLayoutCells(int shortAxisCellCount, int longAxisCellCount) {
 545          mCellCountX = shortAxisCellCount;
 546          mCellCountY = longAxisCellCount;
 547      }
 548  
 549      /**
 550       * Removes the specified item from the database
 551       * @param context
 552       * @param item
 553       */
 554      static void deleteItemFromDatabase(Context context, final ItemInfo item) {
 555          final ContentResolver cr = context.getContentResolver();
 556          final Uri uriToDelete = LauncherSettings.Favorites.getContentUri(item.id, false);


 557          Runnable r = new Runnable() {
 558              public void run() {






 559                  cr.delete(uriToDelete, null, null);

 560                  // Lock on mBgLock *after* the db operation
 561                  synchronized (sBgLock) {
 562                      switch (item.itemType) {
 563                          case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 564                              sBgFolders.remove(item.id);












 565                              sBgWorkspaceItems.remove(item);
 566                              break;
 567                          case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 568                          case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 569                              sBgWorkspaceItems.remove(item);
 570                              break;
 571                          case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
 572                              sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
 573                              break;
 574                      }
 575                      sBgItemsIdMap.remove(item.id);
 576                      sBgDbIconCache.remove(item);
 577                  }
 578              }
 579          };
 580          runOnWorkerThread(r);
 581      }
 582  
 583      /**
 584       * Remove the contents of the specified folder from the database
 585       */
 586      static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
 587          final ContentResolver cr = context.getContentResolver();
 588  
 589          Runnable r = new Runnable() {
 590              public void run() {
 591                  cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
 592                  // Lock on mBgLock *after* the db operation
 593                  synchronized (sBgLock) {
 594                      sBgItemsIdMap.remove(info.id);
 595                      sBgFolders.remove(info.id);
 596                      sBgDbIconCache.remove(info);
 597                      sBgWorkspaceItems.remove(info);
 598                  }
 599  
 600                  cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
 601                          LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
 602                  // Lock on mBgLock *after* the db operation
 603                  synchronized (sBgLock) {
 604                      for (ItemInfo childInfo : info.contents) {
 605                          sBgItemsIdMap.remove(childInfo.id);
 606                          sBgDbIconCache.remove(childInfo);
 607                      }
 608                  }
 609              }
 610          };
 611          runOnWorkerThread(r);
 612      }
 613  
 614      /**
 615       * Set this as the current Launcher activity object for the loader.
 616       */
 617      public void initialize(Callbacks callbacks) {
 618          synchronized (mLock) {
 619              mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
 620          }
 621      }
 622  
 623      /**
 624       * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
 625       * ACTION_PACKAGE_CHANGED.
 626       */
 627      @Override
 628      public void onReceive(Context context, Intent intent) {
 629          if (DEBUG_LOADERS) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
 630  
 631          final String action = intent.getAction();
 632  
 633          if (Intent.ACTION_PACKAGE_CHANGED.equals(action)
 634                  || Intent.ACTION_PACKAGE_REMOVED.equals(action)
 635                  || Intent.ACTION_PACKAGE_ADDED.equals(action)) {
 636              final String packageName = intent.getData().getSchemeSpecificPart();
 637              final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
 638  
 639              int op = PackageUpdatedTask.OP_NONE;
 640  
 641              if (packageName == null || packageName.length() == 0) {
 642                  // they sent us a bad intent
 643                  return;
 644              }
 645  
 646              if (Intent.ACTION_PACKAGE_CHANGED.equals(action)) {
 647                  op = PackageUpdatedTask.OP_UPDATE;
 648              } else if (Intent.ACTION_PACKAGE_REMOVED.equals(action)) {
 649                  if (!replacing) {
 650                      op = PackageUpdatedTask.OP_REMOVE;
 651                  }
 652                  // else, we are replacing the package, so a PACKAGE_ADDED will be sent
 653                  // later, we will update the package at this time
 654              } else if (Intent.ACTION_PACKAGE_ADDED.equals(action)) {
 655                  if (!replacing) {
 656                      op = PackageUpdatedTask.OP_ADD;
 657                  } else {
 658                      op = PackageUpdatedTask.OP_UPDATE;
 659                  }
 660              }
 661  
 662              if (op != PackageUpdatedTask.OP_NONE) {
 663                  enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName }));
 664              }
 665  
 666          } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(action)) {
 667              // First, schedule to add these apps back in.
 668              String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
 669              enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packages));
 670              // Then, rebind everything.
 671              startLoaderFromBackground();
 672          } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(action)) {
 673              String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
 674              enqueuePackageUpdated(new PackageUpdatedTask(
 675                          PackageUpdatedTask.OP_UNAVAILABLE, packages));
 676          } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
 677              // If we have changed locale we need to clear out the labels in all apps/workspace.
 678              forceReload();
 679          } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
 680               // Check if configuration change was an mcc/mnc change which would affect app resources
 681               // and we would need to clear out the labels in all apps/workspace. Same handling as
 682               // above for ACTION_LOCALE_CHANGED
 683               Configuration currentConfig = context.getResources().getConfiguration();
 684               if (mPreviousConfigMcc != currentConfig.mcc) {
 685                     Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
 686                         + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
 687                     forceReload();
 688               }
 689               // Update previousConfig
 690               mPreviousConfigMcc = currentConfig.mcc;
 691          } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
 692                     SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
 693              if (mCallbacks != null) {
 694                  Callbacks callbacks = mCallbacks.get();
 695                  if (callbacks != null) {
 696                      callbacks.bindSearchablesChanged();
 697                  }
 698              }
 699          }
 700      }
 701  
 702      private void forceReload() {
 703          resetLoadedState(true, true);
 704  
 705          // Do this here because if the launcher activity is running it will be restarted.
 706          // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
 707          // to reload.
 708          startLoaderFromBackground();
 709      }
 710  
 711      public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
 712          synchronized (mLock) {
 713              // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
 714              // mWorkspaceLoaded to true later
 715              stopLoaderLocked();
 716              if (resetAllAppsLoaded) mAllAppsLoaded = false;
 717              if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
 718          }
 719      }
 720  
 721      /**
 722       * When the launcher is in the background, it&#x27;s possible for it to miss paired
 723       * configuration changes.  So whenever we trigger the loader from the background
 724       * tell the launcher that it needs to re-run the loader when it comes back instead
 725       * of doing it now.
 726       */
 727      public void startLoaderFromBackground() {
 728          boolean runLoader = false;
 729          if (mCallbacks != null) {
 730              Callbacks callbacks = mCallbacks.get();
 731              if (callbacks != null) {
 732                  // Only actually run the loader if they&#x27;re not paused.
 733                  if (!callbacks.setLoadOnResume()) {
 734                      runLoader = true;
 735                  }
 736              }
 737          }
 738          if (runLoader) {
 739              startLoader(false, -1);
 740          }
 741      }
 742  
 743      // If there is already a loader task running, tell it to stop.
 744      // returns true if isLaunching() was true on the old task
 745      private boolean stopLoaderLocked() {
 746          boolean isLaunching = false;
 747          LoaderTask oldTask = mLoaderTask;
 748          if (oldTask != null) {
 749              if (oldTask.isLaunching()) {
 750                  isLaunching = true;
 751              }
 752              oldTask.stopLocked();
 753          }
 754          return isLaunching;
 755      }
 756  
 757      public void startLoader(boolean isLaunching, int synchronousBindPage) {
 758          synchronized (mLock) {
 759              if (DEBUG_LOADERS) {
 760                  Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
 761              }
 762  
 763              // Clear any deferred bind-runnables from the synchronized load process
 764              // We must do this before any loading/binding is scheduled below.
 765              mDeferredBindRunnables.clear();
 766  
 767              // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
 768              if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
 769                  // If there is already one running, tell it to stop.
 770                  // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
 771                  isLaunching = isLaunching || stopLoaderLocked();
 772                  mLoaderTask = new LoaderTask(mApp, isLaunching);
 773                  if (synchronousBindPage &gt; -1 &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {
 774                      mLoaderTask.runBindSynchronousPage(synchronousBindPage);
 775                  } else {
 776                      sWorkerThread.setPriority(Thread.NORM_PRIORITY);
 777                      sWorker.post(mLoaderTask);
 778                  }
 779              }
 780          }
 781      }
 782  
 783      void bindRemainingSynchronousPages() {
 784          // Post the remaining side pages to be loaded
 785          if (!mDeferredBindRunnables.isEmpty()) {
 786              for (final Runnable r : mDeferredBindRunnables) {
 787                  mHandler.post(r);
 788              }
 789              mDeferredBindRunnables.clear();
 790          }
 791      }
 792  
 793      public void stopLoader() {
 794          synchronized (mLock) {
 795              if (mLoaderTask != null) {
 796                  mLoaderTask.stopLocked();
 797              }
 798          }
 799      }
 800  
 801      public boolean isAllAppsLoaded() {
 802          return mAllAppsLoaded;
 803      }
 804  
 805      boolean isLoadingWorkspace() {
 806          synchronized (mLock) {
 807              if (mLoaderTask != null) {
 808                  return mLoaderTask.isLoadingWorkspace();
 809              }
 810          }
 811          return false;
 812      }
 813  
 814      /**
 815       * Runnable for the thread that loads the contents of the launcher:
 816       *   - workspace icons
 817       *   - widgets
 818       *   - all apps icons
 819       */
 820      private class LoaderTask implements Runnable {
 821          private Context mContext;
 822          private boolean mIsLaunching;
 823          private boolean mIsLoadingAndBindingWorkspace;
 824          private boolean mStopped;
 825          private boolean mLoadAndBindStepFinished;
 826  
 827          private HashMap&lt;Object, CharSequence&gt; mLabelCache;
 828  
 829          LoaderTask(Context context, boolean isLaunching) {
 830              mContext = context;
 831              mIsLaunching = isLaunching;
 832              mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
 833          }
 834  
 835          boolean isLaunching() {
 836              return mIsLaunching;
 837          }
 838  
 839          boolean isLoadingWorkspace() {
 840              return mIsLoadingAndBindingWorkspace;
 841          }
 842  
 843          private void loadAndBindWorkspace() {
 844              mIsLoadingAndBindingWorkspace = true;
 845  
 846              // Load the workspace
 847              if (DEBUG_LOADERS) {
 848                  Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
 849              }
 850  
 851              if (!mWorkspaceLoaded) {
 852                  loadWorkspace();
 853                  synchronized (LoaderTask.this) {
 854                      if (mStopped) {
 855                          return;
 856                      }
 857                      mWorkspaceLoaded = true;
 858                  }
 859              }
 860  
 861              // Bind the workspace
 862              bindWorkspace(-1);
 863          }
 864  
 865          private void waitForIdle() {
 866              // Wait until the either we&#x27;re stopped or the other threads are done.
 867              // This way we don&#x27;t start loading all apps until the workspace has settled
 868              // down.
 869              synchronized (LoaderTask.this) {
 870                  final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
 871  
 872                  mHandler.postIdle(new Runnable() {
 873                          public void run() {
 874                              synchronized (LoaderTask.this) {
 875                                  mLoadAndBindStepFinished = true;
 876                                  if (DEBUG_LOADERS) {
 877                                      Log.d(TAG, &quot;done with previous binding step&quot;);
 878                                  }
 879                                  LoaderTask.this.notify();
 880                              }
 881                          }
 882                      });
 883  
 884                  while (!mStopped &amp;&amp; !mLoadAndBindStepFinished) {
 885                      try {
 886                          this.wait();
 887                      } catch (InterruptedException ex) {
 888                          // Ignore
 889                      }
 890                  }
 891                  if (DEBUG_LOADERS) {
 892                      Log.d(TAG, &quot;waited &quot;
 893                              + (SystemClock.uptimeMillis()-workspaceWaitTime)
 894                              + &quot;ms for previous step to finish binding&quot;);
 895                  }
 896              }
 897          }
 898  
 899          void runBindSynchronousPage(int synchronousBindPage) {
 900              if (synchronousBindPage &lt; 0) {
 901                  // Ensure that we have a valid page index to load synchronously
 902                  throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
 903                          &quot;valid page index&quot;);
 904              }
 905              if (!mAllAppsLoaded || !mWorkspaceLoaded) {
 906                  // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
 907                  // loaded already (we should load everything asynchronously in that case)
 908                  throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
 909              }
 910              synchronized (mLock) {
 911                  if (mIsLoaderTaskRunning) {
 912                      // Ensure that we are never running the background loading at this point since
 913                      // we also touch the background collections
 914                      throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
 915                  }
 916              }
 917  
 918              // XXX: Throw an exception if we are already loading (since we touch the worker thread
 919              //      data structures, we can&#x27;t allow any other thread to touch that data, but because
 920              //      this call is synchronous, we can get away with not locking).
 921  
 922              // The LauncherModel is static in the LauncherApplication and mHandler may have queued
 923              // operations from the previous activity.  We need to ensure that all queued operations
 924              // are executed before any synchronous binding work is done.
 925              mHandler.flush();
 926  
 927              // Divide the set of loaded items into those that we are binding synchronously, and
 928              // everything else that is to be bound normally (asynchronously).
 929              bindWorkspace(synchronousBindPage);
 930              // XXX: For now, continue posting the binding of AllApps as there are other issues that
 931              //      arise from that.
 932              onlyBindAllApps();
 933          }
 934  
 935          public void run() {
 936              synchronized (mLock) {
 937                  mIsLoaderTaskRunning = true;
 938              }
 939              // Optimize for end-user experience: if the Launcher is up and // running with the
 940              // All Apps interface in the foreground, load All Apps first. Otherwise, load the
 941              // workspace first (default).
 942              final Callbacks cbk = mCallbacks.get();
 943              final boolean loadWorkspaceFirst = cbk != null ? (!cbk.isAllAppsVisible()) : true;
 944  
 945              keep_running: {
 946                  // Elevate priority when Home launches for the first time to avoid
 947                  // starving at boot time. Staring at a blank home is not cool.
 948                  synchronized (mLock) {
 949                      if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
 950                              (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
 951                      android.os.Process.setThreadPriority(mIsLaunching
 952                              ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
 953                  }
 954                  if (loadWorkspaceFirst) {
 955                      if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
 956                      loadAndBindWorkspace();
 957                  } else {
 958                      if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: special: loading all apps&quot;);
 959                      loadAndBindAllApps();
 960                  }
 961  
 962                  if (mStopped) {
 963                      break keep_running;
 964                  }
 965  
 966                  // Whew! Hard work done.  Slow us down, and wait until the UI thread has
 967                  // settled down.
 968                  synchronized (mLock) {
 969                      if (mIsLaunching) {
 970                          if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
 971                          android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
 972                      }
 973                  }
 974                  waitForIdle();
 975  
 976                  // second step
 977                  if (loadWorkspaceFirst) {
 978                      if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
 979                      loadAndBindAllApps();
 980                  } else {
 981                      if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: special: loading workspace&quot;);
 982                      loadAndBindWorkspace();
 983                  }
 984  
 985                  // Restore the default thread priority after we are done loading items
 986                  synchronized (mLock) {
 987                      android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
 988                  }
 989              }
 990  
 991  
 992              // Update the saved icons if necessary
 993              if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
 994              synchronized (sBgLock) {
 995                  for (Object key : sBgDbIconCache.keySet()) {
 996                      updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
 997                  }
 998                  sBgDbIconCache.clear();
 999              }
1000  
1001              // Clear out this reference, otherwise we end up holding it until all of the
1002              // callback runnables are done.
1003              mContext = null;
1004  
1005              synchronized (mLock) {
1006                  // If we are still the last one to be scheduled, remove ourselves.
1007                  if (mLoaderTask == this) {
1008                      mLoaderTask = null;
1009                  }
1010                  mIsLoaderTaskRunning = false;
1011              }
1012          }
1013  
1014          public void stopLocked() {
1015              synchronized (LoaderTask.this) {
1016                  mStopped = true;
1017                  this.notify();
1018              }
1019          }
1020  
1021          /**
1022           * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1023           * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1024           * object that was around when the deferred message was scheduled, and if there&#x27;s
1025           * a new Callbacks object around then also return null.  This will save us from
1026           * calling onto it with data that will be ignored.
1027           */
1028          Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1029              synchronized (mLock) {
1030                  if (mStopped) {
1031                      return null;
1032                  }
1033  
1034                  if (mCallbacks == null) {
1035                      return null;
1036                  }
1037  
1038                  final Callbacks callbacks = mCallbacks.get();
1039                  if (callbacks != oldCallbacks) {
1040                      return null;
1041                  }
1042                  if (callbacks == null) {
1043                      Log.w(TAG, &quot;no mCallbacks&quot;);
1044                      return null;
1045                  }
1046  
1047                  return callbacks;
1048              }
1049          }
1050  
1051          // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1052          private boolean checkItemPlacement(ItemInfo occupied[][][], ItemInfo item) {
1053              int containerIndex = item.screen;
1054              if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1055                  // Return early if we detect that an item is under the hotseat button
1056                  if (mCallbacks == null || mCallbacks.get().isAllAppsButtonRank(item.screen)) {
1057                      return false;
1058                  }
1059  
1060                  // We use the last index to refer to the hotseat and the screen as the rank, so
1061                  // test and update the occupied state accordingly
1062                  if (occupied[Launcher.SCREEN_COUNT][item.screen][0] != null) {
1063                      Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1064                          + &quot; into position (&quot; + item.screen + &quot;:&quot; + item.cellX + &quot;,&quot; + item.cellY
1065                          + &quot;) occupied by &quot; + occupied[Launcher.SCREEN_COUNT][item.screen][0]);
1066                      return false;
1067                  } else {
1068                      occupied[Launcher.SCREEN_COUNT][item.screen][0] = item;
1069                      return true;
1070                  }
1071              } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1072                  // Skip further checking if it is not the hotseat or workspace container
1073                  return true;
1074              }
1075  
1076              // Check if any workspace icons overlap with each other
1077              for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1078                  for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1079                      if (occupied[containerIndex][x][y] != null) {
1080                          Log.e(TAG, &quot;Error loading shortcut &quot; + item
1081                              + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screen + &quot;:&quot;
1082                              + x + &quot;,&quot; + y
1083                              + &quot;) occupied by &quot;
1084                              + occupied[containerIndex][x][y]);
1085                          return false;
1086                      }
1087                  }
1088              }
1089              for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1090                  for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1091                      occupied[containerIndex][x][y] = item;
1092                  }
1093              }
1094  
1095              return true;
1096          }
1097  
1098          private void loadWorkspace() {
1099              final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1100  
1101              final Context context = mContext;
1102              final ContentResolver contentResolver = context.getContentResolver();
1103              final PackageManager manager = context.getPackageManager();
1104              final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1105              final boolean isSafeMode = manager.isSafeMode();
1106  
1107              // Make sure the default workspace is loaded, if needed
1108              mApp.getLauncherProvider().loadDefaultFavoritesIfNecessary();
1109  
1110              synchronized (sBgLock) {
1111                  sBgWorkspaceItems.clear();
1112                  sBgAppWidgets.clear();
1113                  sBgFolders.clear();
1114                  sBgItemsIdMap.clear();
1115                  sBgDbIconCache.clear();
1116  
1117                  final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1118  
1119                  final Cursor c = contentResolver.query(
1120                          LauncherSettings.Favorites.CONTENT_URI, null, null, null, null);
1121  
1122                  // +1 for the hotseat (it can be larger than the workspace)
1123                  // Load workspace in reverse order to ensure that latest items are loaded first (and
1124                  // before any earlier duplicates)
1125                  final ItemInfo occupied[][][] =
1126                          new ItemInfo[Launcher.SCREEN_COUNT + 1][mCellCountX + 1][mCellCountY + 1];
1127  
1128                  try {
1129                      final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1130                      final int intentIndex = c.getColumnIndexOrThrow
1131                              (LauncherSettings.Favorites.INTENT);
1132                      final int titleIndex = c.getColumnIndexOrThrow
1133                              (LauncherSettings.Favorites.TITLE);
1134                      final int iconTypeIndex = c.getColumnIndexOrThrow(
1135                              LauncherSettings.Favorites.ICON_TYPE);
1136                      final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
1137                      final int iconPackageIndex = c.getColumnIndexOrThrow(
1138                              LauncherSettings.Favorites.ICON_PACKAGE);
1139                      final int iconResourceIndex = c.getColumnIndexOrThrow(
1140                              LauncherSettings.Favorites.ICON_RESOURCE);
1141                      final int containerIndex = c.getColumnIndexOrThrow(
1142                              LauncherSettings.Favorites.CONTAINER);
1143                      final int itemTypeIndex = c.getColumnIndexOrThrow(
1144                              LauncherSettings.Favorites.ITEM_TYPE);
1145                      final int appWidgetIdIndex = c.getColumnIndexOrThrow(
1146                              LauncherSettings.Favorites.APPWIDGET_ID);
1147                      final int screenIndex = c.getColumnIndexOrThrow(
1148                              LauncherSettings.Favorites.SCREEN);
1149                      final int cellXIndex = c.getColumnIndexOrThrow
1150                              (LauncherSettings.Favorites.CELLX);
1151                      final int cellYIndex = c.getColumnIndexOrThrow
1152                              (LauncherSettings.Favorites.CELLY);
1153                      final int spanXIndex = c.getColumnIndexOrThrow
1154                              (LauncherSettings.Favorites.SPANX);
1155                      final int spanYIndex = c.getColumnIndexOrThrow(
1156                              LauncherSettings.Favorites.SPANY);
1157                      //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1158                      //final int displayModeIndex = c.getColumnIndexOrThrow(
1159                      //        LauncherSettings.Favorites.DISPLAY_MODE);
1160  
1161                      ShortcutInfo info;
1162                      String intentDescription;
1163                      LauncherAppWidgetInfo appWidgetInfo;
1164                      int container;
1165                      long id;
1166                      Intent intent;
1167  
1168                      while (!mStopped &amp;&amp; c.moveToNext()) {
1169                          try {
1170                              int itemType = c.getInt(itemTypeIndex);
1171  
1172                              switch (itemType) {
1173                              case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1174                              case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1175                                  intentDescription = c.getString(intentIndex);
1176                                  try {
1177                                      intent = Intent.parseUri(intentDescription, 0);
1178                                  } catch (URISyntaxException e) {
1179                                      continue;
1180                                  }
1181  
1182                                  if (itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
1183                                      info = getShortcutInfo(manager, intent, context, c, iconIndex,
1184                                              titleIndex, mLabelCache);
1185                                  } else {
1186                                      info = getShortcutInfo(c, context, iconTypeIndex,
1187                                              iconPackageIndex, iconResourceIndex, iconIndex,
1188                                              titleIndex);
1189  
1190                                      // App shortcuts that used to be automatically added to Launcher
1191                                      // didn&#x27;t always have the correct intent flags set, so do that
1192                                      // here
1193                                      if (intent.getAction() != null &amp;&amp;
1194                                          intent.getCategories() != null &amp;&amp;
1195                                          intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
1196                                          intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
1197                                          intent.addFlags(
1198                                              Intent.FLAG_ACTIVITY_NEW_TASK |
1199                                              Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
1200                                      }
1201                                  }
1202  
1203                                  if (info != null) {
1204                                      info.intent = intent;
1205                                      info.id = c.getLong(idIndex);
1206                                      container = c.getInt(containerIndex);
1207                                      info.container = container;
1208                                      info.screen = c.getInt(screenIndex);
1209                                      info.cellX = c.getInt(cellXIndex);
1210                                      info.cellY = c.getInt(cellYIndex);
1211  
1212                                      // check &amp; update map of what&#x27;s occupied
1213                                      if (!checkItemPlacement(occupied, info)) {
1214                                          break;
1215                                      }
1216  
1217                                      switch (container) {
1218                                      case LauncherSettings.Favorites.CONTAINER_DESKTOP:
1219                                      case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
1220                                          sBgWorkspaceItems.add(info);
1221                                          break;
1222                                      default:
1223                                          // Item is in a user folder
1224                                          FolderInfo folderInfo =
1225                                                  findOrMakeFolder(sBgFolders, container);
1226                                          folderInfo.add(info);
1227                                          break;
1228                                      }
1229                                      sBgItemsIdMap.put(info.id, info);
1230  
1231                                      // now that we&#x27;ve loaded everthing re-save it with the
1232                                      // icon in case it disappears somehow.
1233                                      queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
1234                                  } else {
1235                                      // Failed to load the shortcut, probably because the
1236                                      // activity manager couldn&#x27;t resolve it (maybe the app
1237                                      // was uninstalled), or the db row was somehow screwed up.
1238                                      // Delete it.
1239                                      id = c.getLong(idIndex);
1240                                      Log.e(TAG, &quot;Error loading shortcut &quot; + id + &quot;, removing it&quot;);
1241                                      contentResolver.delete(LauncherSettings.Favorites.getContentUri(
1242                                                  id, false), null, null);
1243                                  }
1244                                  break;
1245  
1246                              case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1247                                  id = c.getLong(idIndex);
1248                                  FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
1249  
1250                                  folderInfo.title = c.getString(titleIndex);
1251                                  folderInfo.id = id;
1252                                  container = c.getInt(containerIndex);
1253                                  folderInfo.container = container;
1254                                  folderInfo.screen = c.getInt(screenIndex);
1255                                  folderInfo.cellX = c.getInt(cellXIndex);
1256                                  folderInfo.cellY = c.getInt(cellYIndex);
1257  
1258                                  // check &amp; update map of what&#x27;s occupied
1259                                  if (!checkItemPlacement(occupied, folderInfo)) {
1260                                      break;
1261                                  }
1262                                  switch (container) {
1263                                      case LauncherSettings.Favorites.CONTAINER_DESKTOP:
1264                                      case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
1265                                          sBgWorkspaceItems.add(folderInfo);
1266                                          break;
1267                                  }
1268  
1269                                  sBgItemsIdMap.put(folderInfo.id, folderInfo);
1270                                  sBgFolders.put(folderInfo.id, folderInfo);
1271                                  break;
1272  
1273                              case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1274                                  // Read all Launcher-specific widget details
1275                                  int appWidgetId = c.getInt(appWidgetIdIndex);
1276                                  id = c.getLong(idIndex);
1277  
1278                                  final AppWidgetProviderInfo provider =
1279                                          widgets.getAppWidgetInfo(appWidgetId);
1280  
1281                                  if (!isSafeMode &amp;&amp; (provider == null || provider.provider == null ||
1282                                          provider.provider.getPackageName() == null)) {
1283                                      String log = &quot;Deleting widget that isn&#x27;t installed anymore: id=&quot;
1284                                          + id + &quot; appWidgetId=&quot; + appWidgetId;
1285                                      Log.e(TAG, log);
1286                                      Launcher.sDumpLogs.add(log);
1287                                      itemsToRemove.add(id);
1288                                  } else {
1289                                      appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
1290                                              provider.provider);
1291                                      appWidgetInfo.id = id;
1292                                      appWidgetInfo.screen = c.getInt(screenIndex);
1293                                      appWidgetInfo.cellX = c.getInt(cellXIndex);
1294                                      appWidgetInfo.cellY = c.getInt(cellYIndex);
1295                                      appWidgetInfo.spanX = c.getInt(spanXIndex);
1296                                      appWidgetInfo.spanY = c.getInt(spanYIndex);
1297                                      int[] minSpan = Launcher.getMinSpanForWidget(context, provider);
1298                                      appWidgetInfo.minSpanX = minSpan[0];
1299                                      appWidgetInfo.minSpanY = minSpan[1];
1300  
1301                                      container = c.getInt(containerIndex);
1302                                      if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1303                                          container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1304                                          Log.e(TAG, &quot;Widget found where container != &quot; +
1305                                              &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
1306                                          continue;
1307                                      }
1308                                      appWidgetInfo.container = c.getInt(containerIndex);
1309  
1310                                      // check &amp; update map of what&#x27;s occupied
1311                                      if (!checkItemPlacement(occupied, appWidgetInfo)) {
1312                                          break;
1313                                      }
1314                                      sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
1315                                      sBgAppWidgets.add(appWidgetInfo);
1316                                  }
1317                                  break;
1318                              }
1319                          } catch (Exception e) {
1320                              Log.w(TAG, &quot;Desktop items loading interrupted:&quot;, e);
1321                          }
1322                      }
1323                  } finally {
1324                      c.close();
1325                  }
1326  
1327                  if (itemsToRemove.size() &gt; 0) {
1328                      ContentProviderClient client = contentResolver.acquireContentProviderClient(
1329                                      LauncherSettings.Favorites.CONTENT_URI);
1330                      // Remove dead items
1331                      for (long id : itemsToRemove) {
1332                          if (DEBUG_LOADERS) {
1333                              Log.d(TAG, &quot;Removed id = &quot; + id);
1334                          }
1335                          // Don&#x27;t notify content observers
1336                          try {
1337                              client.delete(LauncherSettings.Favorites.getContentUri(id, false),
1338                                      null, null);
1339                          } catch (RemoteException e) {
1340                              Log.w(TAG, &quot;Could not remove id = &quot; + id);
1341                          }
1342                      }
1343                  }
1344  
1345                  if (DEBUG_LOADERS) {
1346                      Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
1347                      Log.d(TAG, &quot;workspace layout: &quot;);
1348                      for (int y = 0; y &lt; mCellCountY; y++) {
1349                          String line = &quot;&quot;;
1350                          for (int s = 0; s &lt; Launcher.SCREEN_COUNT; s++) {
1351                              if (s &gt; 0) {
1352                                  line += &quot; | &quot;;
1353                              }
1354                              for (int x = 0; x &lt; mCellCountX; x++) {
1355                                  line += ((occupied[s][x][y] != null) ? &quot;#&quot; : &quot;.&quot;);
1356                              }
1357                          }
1358                          Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
1359                      }
1360                  }
1361              }
1362          }
1363  
1364          /** Filters the set of items who are directly or indirectly (via another container) on the
1365           * specified screen. */
1366          private void filterCurrentWorkspaceItems(int currentScreen,
1367                  ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
1368                  ArrayList&lt;ItemInfo&gt; currentScreenItems,
1369                  ArrayList&lt;ItemInfo&gt; otherScreenItems) {
1370              // Purge any null ItemInfos
1371              Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
1372              while (iter.hasNext()) {
1373                  ItemInfo i = iter.next();
1374                  if (i == null) {
1375                      iter.remove();
1376                  }
1377              }
1378  
1379              // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of
1380              // items given.
1381              if (currentScreen &lt; 0) {
1382                  currentScreenItems.addAll(allWorkspaceItems);
1383              }
1384  
1385              // Order the set of items by their containers first, this allows use to walk through the
1386              // list sequentially, build up a list of containers that are in the specified screen,
1387              // as well as all items in those containers.
1388              Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
1389              Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
1390                  @Override
1391                  public int compare(ItemInfo lhs, ItemInfo rhs) {
1392                      return (int) (lhs.container - rhs.container);
1393                  }
1394              });
1395              for (ItemInfo info : allWorkspaceItems) {
1396                  if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1397                      if (info.screen == currentScreen) {
1398                          currentScreenItems.add(info);
1399                          itemsOnScreen.add(info.id);
1400                      } else {
1401                          otherScreenItems.add(info);
1402                      }
1403                  } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1404                      currentScreenItems.add(info);
1405                      itemsOnScreen.add(info.id);
1406                  } else {
1407                      if (itemsOnScreen.contains(info.container)) {
1408                          currentScreenItems.add(info);
1409                          itemsOnScreen.add(info.id);
1410                      } else {
1411                          otherScreenItems.add(info);
1412                      }
1413                  }
1414              }
1415          }
1416  
1417          /** Filters the set of widgets which are on the specified screen. */
1418          private void filterCurrentAppWidgets(int currentScreen,
1419                  ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
1420                  ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
1421                  ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
1422              // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of
1423              // widgets given.
1424              if (currentScreen &lt; 0) {
1425                  currentScreenWidgets.addAll(appWidgets);
1426              }
1427  
1428              for (LauncherAppWidgetInfo widget : appWidgets) {
1429                  if (widget == null) continue;
1430                  if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1431                          widget.screen == currentScreen) {
1432                      currentScreenWidgets.add(widget);
1433                  } else {
1434                      otherScreenWidgets.add(widget);
1435                  }
1436              }
1437          }
1438  
1439          /** Filters the set of folders which are on the specified screen. */
1440          private void filterCurrentFolders(int currentScreen,
1441                  HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
1442                  HashMap&lt;Long, FolderInfo&gt; folders,
1443                  HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
1444                  HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
1445              // If we aren&#x27;t filtering on a screen, then the set of items to load is the full set of
1446              // widgets given.
1447              if (currentScreen &lt; 0) {
1448                  currentScreenFolders.putAll(folders);
1449              }
1450  
1451              for (long id : folders.keySet()) {
1452                  ItemInfo info = itemsIdMap.get(id);
1453                  FolderInfo folder = folders.get(id);
1454                  if (info == null || folder == null) continue;
1455                  if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1456                          info.screen == currentScreen) {
1457                      currentScreenFolders.put(id, folder);
1458                  } else {
1459                      otherScreenFolders.put(id, folder);
1460                  }
1461              }
1462          }
1463  
1464          /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
1465           * right) */
1466          private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
1467              // XXX: review this
1468              Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
1469                  @Override
1470                  public int compare(ItemInfo lhs, ItemInfo rhs) {
1471                      int cellCountX = LauncherModel.getCellCountX();
1472                      int cellCountY = LauncherModel.getCellCountY();
1473                      int screenOffset = cellCountX * cellCountY;
1474                      int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
1475                      long lr = (lhs.container * containerOffset + lhs.screen * screenOffset +
1476                              lhs.cellY * cellCountX + lhs.cellX);
1477                      long rr = (rhs.container * containerOffset + rhs.screen * screenOffset +
1478                              rhs.cellY * cellCountX + rhs.cellX);
1479                      return (int) (lr - rr);
1480                  }
1481              });
1482          }
1483  
1484          private void bindWorkspaceItems(final Callbacks oldCallbacks,
1485                  final ArrayList&lt;ItemInfo&gt; workspaceItems,
1486                  final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
1487                  final HashMap&lt;Long, FolderInfo&gt; folders,
1488                  ArrayList&lt;Runnable&gt; deferredBindRunnables) {
1489  
1490              final boolean postOnMainThread = (deferredBindRunnables != null);
1491  
1492              // Bind the workspace items
1493              int N = workspaceItems.size();
1494              for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
1495                  final int start = i;
1496                  final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
1497                  final Runnable r = new Runnable() {
1498                      @Override
1499                      public void run() {
1500                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1501                          if (callbacks != null) {
1502                              callbacks.bindItems(workspaceItems, start, start+chunkSize);
1503                          }
1504                      }
1505                  };
1506                  if (postOnMainThread) {
1507                      deferredBindRunnables.add(r);
1508                  } else {
1509                      runOnMainThread(r);
1510                  }
1511              }
1512  
1513              // Bind the folders
1514              if (!folders.isEmpty()) {
1515                  final Runnable r = new Runnable() {
1516                      public void run() {
1517                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1518                          if (callbacks != null) {
1519                              callbacks.bindFolders(folders);
1520                          }
1521                      }
1522                  };
1523                  if (postOnMainThread) {
1524                      deferredBindRunnables.add(r);
1525                  } else {
1526                      runOnMainThread(r);
1527                  }
1528              }
1529  
1530              // Bind the widgets, one at a time
1531              N = appWidgets.size();
1532              for (int i = 0; i &lt; N; i++) {
1533                  final LauncherAppWidgetInfo widget = appWidgets.get(i);
1534                  final Runnable r = new Runnable() {
1535                      public void run() {
1536                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1537                          if (callbacks != null) {
1538                              callbacks.bindAppWidget(widget);
1539                          }
1540                      }
1541                  };
1542                  if (postOnMainThread) {
1543                      deferredBindRunnables.add(r);
1544                  } else {
1545                      runOnMainThread(r);
1546                  }
1547              }
1548          }
1549  
1550          /**
1551           * Binds all loaded data to actual views on the main thread.
1552           */
1553          private void bindWorkspace(int synchronizeBindPage) {
1554              final long t = SystemClock.uptimeMillis();
1555              Runnable r;
1556  
1557              // Don&#x27;t use these two variables in any of the callback runnables.
1558              // Otherwise we hold a reference to them.
1559              final Callbacks oldCallbacks = mCallbacks.get();
1560              if (oldCallbacks == null) {
1561                  // This launcher has exited and nobody bothered to tell us.  Just bail.
1562                  Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
1563                  return;
1564              }
1565  
1566              final boolean isLoadingSynchronously = (synchronizeBindPage &gt; -1);
1567              final int currentScreen = isLoadingSynchronously ? synchronizeBindPage :
1568                  oldCallbacks.getCurrentWorkspaceScreen();
1569  
1570              // Load all the items that are on the current page first (and in the process, unbind
1571              // all the existing workspace items before we call startBinding() below.
1572              unbindWorkspaceItemsOnMainThread();
1573              ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
1574              ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
1575                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
1576              HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
1577              HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
1578              synchronized (sBgLock) {
1579                  workspaceItems.addAll(sBgWorkspaceItems);
1580                  appWidgets.addAll(sBgAppWidgets);
1581                  folders.putAll(sBgFolders);
1582                  itemsIdMap.putAll(sBgItemsIdMap);
1583              }
1584  
1585              ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
1586              ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
1587              ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
1588                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
1589              ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
1590                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
1591              HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
1592              HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
1593  
1594              // Separate the items that are on the current screen, and all the other remaining items
1595              filterCurrentWorkspaceItems(currentScreen, workspaceItems, currentWorkspaceItems,
1596                      otherWorkspaceItems);
1597              filterCurrentAppWidgets(currentScreen, appWidgets, currentAppWidgets,
1598                      otherAppWidgets);
1599              filterCurrentFolders(currentScreen, itemsIdMap, folders, currentFolders,
1600                      otherFolders);
1601              sortWorkspaceItemsSpatially(currentWorkspaceItems);
1602              sortWorkspaceItemsSpatially(otherWorkspaceItems);
1603  
1604              // Tell the workspace that we&#x27;re about to start binding items
1605              r = new Runnable() {
1606                  public void run() {
1607                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1608                      if (callbacks != null) {
1609                          callbacks.startBinding();
1610                      }
1611                  }
1612              };
1613              runOnMainThread(r);
1614  
1615              // Load items on the current page
1616              bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
1617                      currentFolders, null);
1618              if (isLoadingSynchronously) {
1619                  r = new Runnable() {
1620                      public void run() {
1621                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1622                          if (callbacks != null) {
1623                              callbacks.onPageBoundSynchronously(currentScreen);
1624                          }
1625                      }
1626                  };
1627                  runOnMainThread(r);
1628              }
1629  
1630              // Load all the remaining pages (if we are loading synchronously, we want to defer this
1631              // work until after the first render)
1632              mDeferredBindRunnables.clear();
1633              bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
1634                      (isLoadingSynchronously ? mDeferredBindRunnables : null));
1635  
1636              // Tell the workspace that we&#x27;re done binding items
1637              r = new Runnable() {
1638                  public void run() {
1639                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1640                      if (callbacks != null) {
1641                          callbacks.finishBindingItems();
1642                      }
1643  
1644                      // If we&#x27;re profiling, ensure this is the last thing in the queue.
1645                      if (DEBUG_LOADERS) {
1646                          Log.d(TAG, &quot;bound workspace in &quot;
1647                              + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
1648                      }
1649  
1650                      mIsLoadingAndBindingWorkspace = false;
1651                  }
1652              };
1653              if (isLoadingSynchronously) {
1654                  mDeferredBindRunnables.add(r);
1655              } else {
1656                  runOnMainThread(r);
1657              }
1658          }
1659  
1660          private void loadAndBindAllApps() {
1661              if (DEBUG_LOADERS) {
1662                  Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
1663              }
1664              if (!mAllAppsLoaded) {
1665                  loadAllAppsByBatch();
1666                  synchronized (LoaderTask.this) {
1667                      if (mStopped) {
1668                          return;
1669                      }
1670                      mAllAppsLoaded = true;
1671                  }
1672              } else {
1673                  onlyBindAllApps();
1674              }
1675          }
1676  
1677          private void onlyBindAllApps() {
1678              final Callbacks oldCallbacks = mCallbacks.get();
1679              if (oldCallbacks == null) {
1680                  // This launcher has exited and nobody bothered to tell us.  Just bail.
1681                  Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
1682                  return;
1683              }
1684  
1685              // shallow copy
1686              @SuppressWarnings(&quot;unchecked&quot;)
1687              final ArrayList&lt;ApplicationInfo&gt; list
1688                      = (ArrayList&lt;ApplicationInfo&gt;) mAllAppsList.data.clone();

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1689 -            mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1690 +            Runnable r = new Runnable() {</span>
1691                  public void run() {
1692                      final long t = SystemClock.uptimeMillis();
1693                      final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1694                      if (callbacks != null) {
1695                          callbacks.bindAllApplications(list);
1696                      }
1697                      if (DEBUG_LOADERS) {
1698                          Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
1699                                  + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
1700                      }
1701                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1702 -            });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1703 +            };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1704 +            boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1705 +            if (oldCallbacks.isAllAppsVisible() &amp;&amp; isRunningOnMainThread) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1706 +                r.run();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1707 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1708 +                mHandler.post(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1709 +            }</span>
1710          }
1711  
1712          private void loadAllAppsByBatch() {
1713              final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1714  
1715              // Don&#x27;t use these two variables in any of the callback runnables.
1716              // Otherwise we hold a reference to them.
1717              final Callbacks oldCallbacks = mCallbacks.get();
1718              if (oldCallbacks == null) {
1719                  // This launcher has exited and nobody bothered to tell us.  Just bail.
1720                  Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllAppsByBatch)&quot;);
1721                  return;
1722              }
1723  
1724              final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
1725              mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
1726  
1727              final PackageManager packageManager = mContext.getPackageManager();
1728              List&lt;ResolveInfo&gt; apps = null;
1729  
1730              int N = Integer.MAX_VALUE;
1731  
1732              int startIndex;
1733              int i=0;
1734              int batchSize = -1;
1735              while (i &lt; N &amp;&amp; !mStopped) {
1736                  if (i == 0) {
1737                      mAllAppsList.clear();

1738                      final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1739                      apps = packageManager.queryIntentActivities(mainIntent, 0);
1740                      if (DEBUG_LOADERS) {
1741                          Log.d(TAG, &quot;queryIntentActivities took &quot;
1742                                  + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms&quot;);
1743                      }
1744                      if (apps == null) {
1745                          return;
1746                      }
1747                      N = apps.size();
1748                      if (DEBUG_LOADERS) {
1749                          Log.d(TAG, &quot;queryIntentActivities got &quot; + N + &quot; apps&quot;);
1750                      }
1751                      if (N == 0) {
1752                          // There are no apps?!?
1753                          return;
1754                      }
1755                      if (mBatchSize == 0) {
1756                          batchSize = N;
1757                      } else {
1758                          batchSize = mBatchSize;
1759                      }
1760  
1761                      final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1762                      Collections.sort(apps,
1763                              new LauncherModel.ShortcutNameComparator(packageManager, mLabelCache));
1764                      if (DEBUG_LOADERS) {
1765                          Log.d(TAG, &quot;sort took &quot;
1766                                  + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);
1767                      }
1768                  }
1769  
1770                  final long t2 = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1771  
1772                  startIndex = i;
1773                  for (int j=0; i&lt;N &amp;&amp; j&lt;batchSize; j++) {
1774                      // This builds the icon bitmaps.
1775                      mAllAppsList.add(new ApplicationInfo(packageManager, apps.get(i),

1776                              mIconCache, mLabelCache));
1777                      i++;
1778                  }
1779  
1780                  final boolean first = i &lt;= batchSize;
1781                  final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
1782                  final ArrayList&lt;ApplicationInfo&gt; added = mAllAppsList.added;
1783                  mAllAppsList.added = new ArrayList&lt;ApplicationInfo&gt;();


1784  
1785                  mHandler.post(new Runnable() {
1786                      public void run() {
1787                          final long t = SystemClock.uptimeMillis();
1788                          if (callbacks != null) {
1789                              if (first) {
1790                                  callbacks.bindAllApplications(added);
1791                              } else {
1792                                  callbacks.bindAppsAdded(added);
1793                              }
1794                              if (DEBUG_LOADERS) {
1795                                  Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
1796                                      + (SystemClock.uptimeMillis() - t) + &quot;ms&quot;);
1797                              }
1798                          } else {
1799                              Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
1800                          }
1801                      }
1802                  });
1803  
1804                  if (DEBUG_LOADERS) {
1805                      Log.d(TAG, &quot;batch of &quot; + (i-startIndex) + &quot; icons processed in &quot;
1806                              + (SystemClock.uptimeMillis()-t2) + &quot;ms&quot;);
1807                  }
1808  
1809                  if (mAllAppsLoadDelay &gt; 0 &amp;&amp; i &lt; N) {
1810                      try {
1811                          if (DEBUG_LOADERS) {
1812                              Log.d(TAG, &quot;sleeping for &quot; + mAllAppsLoadDelay + &quot;ms&quot;);
1813                          }
1814                          Thread.sleep(mAllAppsLoadDelay);
1815                      } catch (InterruptedException exc) { }
1816                  }
1817              }
1818  
1819              if (DEBUG_LOADERS) {
1820                  Log.d(TAG, &quot;cached all &quot; + N + &quot; apps in &quot;
1821                          + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;
1822                          + (mAllAppsLoadDelay &gt; 0 ? &quot; (including delay)&quot; : &quot;&quot;));
1823              }
1824          }
1825  
1826          public void dumpState() {
1827              synchronized (sBgLock) {
1828                  Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
1829                  Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
1830                  Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
1831                  Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
1832                  Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
1833              }
1834          }
1835      }
1836  
1837      void enqueuePackageUpdated(PackageUpdatedTask task) {
1838          sWorker.post(task);
1839      }
1840  
1841      private class PackageUpdatedTask implements Runnable {
1842          int mOp;
1843          String[] mPackages;
1844  
1845          public static final int OP_NONE = 0;
1846          public static final int OP_ADD = 1;
1847          public static final int OP_UPDATE = 2;
1848          public static final int OP_REMOVE = 3; // uninstlled
1849          public static final int OP_UNAVAILABLE = 4; // external media unmounted
1850  
1851  
1852          public PackageUpdatedTask(int op, String[] packages) {
1853              mOp = op;
1854              mPackages = packages;
1855          }
1856  
1857          public void run() {
1858              final Context context = mApp;
1859  
1860              final String[] packages = mPackages;
1861              final int N = packages.length;
1862              switch (mOp) {
1863                  case OP_ADD:
1864                      for (int i=0; i&lt;N; i++) {
1865                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
1866                          mAllAppsList.addPackage(context, packages[i]);

1867                      }
1868                      break;
1869                  case OP_UPDATE:
1870                      for (int i=0; i&lt;N; i++) {
1871                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
1872                          mAllAppsList.updatePackage(context, packages[i]);

1873                      }
1874                      break;
1875                  case OP_REMOVE:
1876                  case OP_UNAVAILABLE:
1877                      for (int i=0; i&lt;N; i++) {
1878                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
1879                          mAllAppsList.removePackage(packages[i]);

1880                      }
1881                      break;
1882              }
1883  
1884              ArrayList&lt;ApplicationInfo&gt; added = null;
1885              ArrayList&lt;ApplicationInfo&gt; removed = null;
1886              ArrayList&lt;ApplicationInfo&gt; modified = null;
1887  
1888              if (mAllAppsList.added.size() &gt; 0) {
1889                  added = mAllAppsList.added;
1890                  mAllAppsList.added = new ArrayList&lt;ApplicationInfo&gt;();
1891              }
1892              if (mAllAppsList.removed.size() &gt; 0) {
1893                  removed = mAllAppsList.removed;
1894                  mAllAppsList.removed = new ArrayList&lt;ApplicationInfo&gt;();
1895                  for (ApplicationInfo info: removed) {
1896                      mIconCache.remove(info.intent.getComponent());
1897                  }
1898              }
1899              if (mAllAppsList.modified.size() &gt; 0) {
1900                  modified = mAllAppsList.modified;
1901                  mAllAppsList.modified = new ArrayList&lt;ApplicationInfo&gt;();


















1902              }
1903  
1904              final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
1905              if (callbacks == null) {
1906                  Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
1907                  return;
1908              }
1909  
1910              if (added != null) {
1911                  final ArrayList&lt;ApplicationInfo&gt; addedFinal = added;
1912                  mHandler.post(new Runnable() {
1913                      public void run() {
1914                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
1915                          if (callbacks == cb &amp;&amp; cb != null) {
1916                              callbacks.bindAppsAdded(addedFinal);
1917                          }
1918                      }
1919                  });
1920              }
1921              if (modified != null) {
1922                  final ArrayList&lt;ApplicationInfo&gt; modifiedFinal = modified;
1923                  mHandler.post(new Runnable() {
1924                      public void run() {
1925                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
1926                          if (callbacks == cb &amp;&amp; cb != null) {
1927                              callbacks.bindAppsUpdated(modifiedFinal);
1928                          }
1929                      }
1930                  });
1931              }
1932              if (removed != null) {

1933                  final boolean permanent = mOp != OP_UNAVAILABLE;
1934                  final ArrayList&lt;ApplicationInfo&gt; removedFinal = removed;
1935                  mHandler.post(new Runnable() {
1936                      public void run() {
1937                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
1938                          if (callbacks == cb &amp;&amp; cb != null) {
1939                              callbacks.bindAppsRemoved(removedFinal, permanent);

1940                          }
1941                      }
1942                  });
1943              }
1944  
1945              mHandler.post(new Runnable() {
1946                  @Override
1947                  public void run() {
1948                      Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
1949                      if (callbacks == cb &amp;&amp; cb != null) {
1950                          callbacks.bindPackagesUpdated();
1951                      }
1952                  }
1953              });
1954          }
1955      }
1956  
1957      /**
1958       * Returns all the Workspace ShortcutInfos associated with a particular package.
1959       * @param intent
1960       * @return
1961       */
1962      ArrayList&lt;ShortcutInfo&gt; getShortcutInfosForPackage(String packageName) {
1963          ArrayList&lt;ShortcutInfo&gt; infos = new ArrayList&lt;ShortcutInfo&gt;();
1964          synchronized (sBgLock) {
1965              for (ItemInfo i : sBgWorkspaceItems) {
1966                  if (i instanceof ShortcutInfo) {
1967                      ShortcutInfo info = (ShortcutInfo) i;
1968                      if (packageName.equals(info.getPackageName())) {
1969                          infos.add(info);
1970                      }
1971                  }
1972              }
1973          }
1974          return infos;
1975      }
1976  
1977      /**
1978       * This is called from the code that adds shortcuts from the intent receiver.  This
1979       * doesn&#x27;t have a Cursor, but
1980       */
1981      public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context) {
1982          return getShortcutInfo(manager, intent, context, null, -1, -1, null);
1983      }
1984  
1985      /**
1986       * Make an ShortcutInfo object for a shortcut that is an application.
1987       *
1988       * If c is not null, then it will be used to fill in missing data like the title and icon.
1989       */
1990      public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context,
1991              Cursor c, int iconIndex, int titleIndex, HashMap&lt;Object, CharSequence&gt; labelCache) {
1992          Bitmap icon = null;
1993          final ShortcutInfo info = new ShortcutInfo();
1994  
1995          ComponentName componentName = intent.getComponent();
1996          if (componentName == null) {
1997              return null;
1998          }
1999  
2000          try {
2001              PackageInfo pi = manager.getPackageInfo(componentName.getPackageName(), 0);
2002              if (!pi.applicationInfo.enabled) {
2003                  // If we return null here, the corresponding item will be removed from the launcher
2004                  // db and will not appear in the workspace.
2005                  return null;
2006              }
2007          } catch (NameNotFoundException e) {
2008              Log.d(TAG, &quot;getPackInfo failed for package &quot; + componentName.getPackageName());
2009          }
2010  
2011          // TODO: See if the PackageManager knows about this case.  If it doesn&#x27;t
2012          // then return null &amp; delete this.
2013  
2014          // the resource -- This may implicitly give us back the fallback icon,
2015          // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
2016          // to avoid saving lots of copies of that in the database, and most apps
2017          // have icons anyway.
2018  
2019          // Attempt to use queryIntentActivities to get the ResolveInfo (with IntentFilter info) and
2020          // if that fails, or is ambiguious, fallback to the standard way of getting the resolve info
2021          // via resolveActivity().
2022          ResolveInfo resolveInfo = null;
2023          ComponentName oldComponent = intent.getComponent();
2024          Intent newIntent = new Intent(intent.getAction(), null);
2025          newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2026          newIntent.setPackage(oldComponent.getPackageName());
2027          List&lt;ResolveInfo&gt; infos = manager.queryIntentActivities(newIntent, 0);
2028          for (ResolveInfo i : infos) {
2029              ComponentName cn = new ComponentName(i.activityInfo.packageName,
2030                      i.activityInfo.name);
2031              if (cn.equals(oldComponent)) {
2032                  resolveInfo = i;
2033              }
2034          }
2035          if (resolveInfo == null) {
2036              resolveInfo = manager.resolveActivity(intent, 0);
2037          }
2038          if (resolveInfo != null) {
2039              icon = mIconCache.getIcon(componentName, resolveInfo, labelCache);
2040          }
2041          // the db
2042          if (icon == null) {
2043              if (c != null) {
2044                  icon = getIconFromCursor(c, iconIndex, context);
2045              }
2046          }
2047          // the fallback icon
2048          if (icon == null) {
2049              icon = getFallbackIcon();
2050              info.usingFallbackIcon = true;
2051          }
2052          info.setIcon(icon);
2053  
2054          // from the resource
2055          if (resolveInfo != null) {
2056              ComponentName key = LauncherModel.getComponentNameFromResolveInfo(resolveInfo);
2057              if (labelCache != null &amp;&amp; labelCache.containsKey(key)) {
2058                  info.title = labelCache.get(key);
2059              } else {
2060                  info.title = resolveInfo.activityInfo.loadLabel(manager);
2061                  if (labelCache != null) {
2062                      labelCache.put(key, info.title);
2063                  }
2064              }
2065          }
2066          // from the db
2067          if (info.title == null) {
2068              if (c != null) {
2069                  info.title =  c.getString(titleIndex);
2070              }
2071          }
2072          // fall back to the class name of the activity
2073          if (info.title == null) {
2074              info.title = componentName.getClassName();
2075          }
2076          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
2077          return info;
2078      }
2079  
2080      /**
2081       * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
2082       */
2083      private ShortcutInfo getShortcutInfo(Cursor c, Context context,
2084              int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
2085              int titleIndex) {
2086  
2087          Bitmap icon = null;
2088          final ShortcutInfo info = new ShortcutInfo();
2089          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
2090  
2091          // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
2092  
2093          info.title = c.getString(titleIndex);
2094  
2095          int iconType = c.getInt(iconTypeIndex);
2096          switch (iconType) {
2097          case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
2098              String packageName = c.getString(iconPackageIndex);
2099              String resourceName = c.getString(iconResourceIndex);
2100              PackageManager packageManager = context.getPackageManager();
2101              info.customIcon = false;
2102              // the resource
2103              try {
2104                  Resources resources = packageManager.getResourcesForApplication(packageName);
2105                  if (resources != null) {
2106                      final int id = resources.getIdentifier(resourceName, null, null);
2107                      icon = Utilities.createIconBitmap(
2108                              mIconCache.getFullResIcon(resources, id), context);
2109                  }
2110              } catch (Exception e) {
2111                  // drop this.  we have other places to look for icons
2112              }
2113              // the db
2114              if (icon == null) {
2115                  icon = getIconFromCursor(c, iconIndex, context);
2116              }
2117              // the fallback icon
2118              if (icon == null) {
2119                  icon = getFallbackIcon();
2120                  info.usingFallbackIcon = true;
2121              }
2122              break;
2123          case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
2124              icon = getIconFromCursor(c, iconIndex, context);
2125              if (icon == null) {
2126                  icon = getFallbackIcon();
2127                  info.customIcon = false;
2128                  info.usingFallbackIcon = true;
2129              } else {
2130                  info.customIcon = true;
2131              }
2132              break;
2133          default:
2134              icon = getFallbackIcon();
2135              info.usingFallbackIcon = true;
2136              info.customIcon = false;
2137              break;
2138          }
2139          info.setIcon(icon);
2140          return info;
2141      }
2142  
2143      Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
2144          @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
2145          final boolean debug = false;
2146          if (debug) {
2147              Log.d(TAG, &quot;getIconFromCursor app=&quot;
2148                      + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
2149          }
2150          byte[] data = c.getBlob(iconIndex);
2151          try {
2152              return Utilities.createIconBitmap(
2153                      BitmapFactory.decodeByteArray(data, 0, data.length), context);
2154          } catch (Exception e) {
2155              return null;
2156          }
2157      }
2158  
2159      ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
2160              int cellX, int cellY, boolean notify) {
2161          final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
2162          if (info == null) {
2163              return null;
2164          }
2165          addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
2166  
2167          return info;
2168      }
2169  
2170      /**
2171       * Attempts to find an AppWidgetProviderInfo that matches the given component.
2172       */
2173      AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,
2174              ComponentName component) {
2175          List&lt;AppWidgetProviderInfo&gt; widgets =
2176              AppWidgetManager.getInstance(context).getInstalledProviders();
2177          for (AppWidgetProviderInfo info : widgets) {
2178              if (info.provider.equals(component)) {
2179                  return info;
2180              }
2181          }
2182          return null;
2183      }
2184  
2185      /**
2186       * Returns a list of all the widgets that can handle configuration with a particular mimeType.
2187       */
2188      List&lt;WidgetMimeTypeHandlerData&gt; resolveWidgetsForMimeType(Context context, String mimeType) {
2189          final PackageManager packageManager = context.getPackageManager();
2190          final List&lt;WidgetMimeTypeHandlerData&gt; supportedConfigurationActivities =
2191              new ArrayList&lt;WidgetMimeTypeHandlerData&gt;();
2192  
2193          final Intent supportsIntent =
2194              new Intent(InstallWidgetReceiver.ACTION_SUPPORTS_CLIPDATA_MIMETYPE);
2195          supportsIntent.setType(mimeType);
2196  
2197          // Create a set of widget configuration components that we can test against
2198          final List&lt;AppWidgetProviderInfo&gt; widgets =
2199              AppWidgetManager.getInstance(context).getInstalledProviders();
2200          final HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; configurationComponentToWidget =
2201              new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;();
2202          for (AppWidgetProviderInfo info : widgets) {
2203              configurationComponentToWidget.put(info.configure, info);
2204          }
2205  
2206          // Run through each of the intents that can handle this type of clip data, and cross
2207          // reference them with the components that are actual configuration components
2208          final List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(supportsIntent,
2209                  PackageManager.MATCH_DEFAULT_ONLY);
2210          for (ResolveInfo info : activities) {
2211              final ActivityInfo activityInfo = info.activityInfo;
2212              final ComponentName infoComponent = new ComponentName(activityInfo.packageName,
2213                      activityInfo.name);
2214              if (configurationComponentToWidget.containsKey(infoComponent)) {
2215                  supportedConfigurationActivities.add(
2216                          new InstallWidgetReceiver.WidgetMimeTypeHandlerData(info,
2217                                  configurationComponentToWidget.get(infoComponent)));
2218              }
2219          }
2220          return supportedConfigurationActivities;
2221      }
2222  
2223      ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
2224          Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
2225          String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
2226          Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
2227  
2228          if (intent == null) {
2229              // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
2230              Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
2231              return null;
2232          }
2233  
2234          Bitmap icon = null;
2235          boolean customIcon = false;
2236          ShortcutIconResource iconResource = null;
2237  
2238          if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {
2239              icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);
2240              customIcon = true;
2241          } else {
2242              Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
2243              if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {
2244                  try {
2245                      iconResource = (ShortcutIconResource) extra;
2246                      final PackageManager packageManager = context.getPackageManager();
2247                      Resources resources = packageManager.getResourcesForApplication(
2248                              iconResource.packageName);
2249                      final int id = resources.getIdentifier(iconResource.resourceName, null, null);
2250                      icon = Utilities.createIconBitmap(
2251                              mIconCache.getFullResIcon(resources, id), context);
2252                  } catch (Exception e) {
2253                      Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);
2254                  }
2255              }
2256          }
2257  
2258          final ShortcutInfo info = new ShortcutInfo();
2259  
2260          if (icon == null) {
2261              if (fallbackIcon != null) {
2262                  icon = fallbackIcon;
2263              } else {
2264                  icon = getFallbackIcon();
2265                  info.usingFallbackIcon = true;
2266              }
2267          }
2268          info.setIcon(icon);
2269  
2270          info.title = name;
2271          info.intent = intent;
2272          info.customIcon = customIcon;
2273          info.iconResource = iconResource;
2274  
2275          return info;
2276      }
2277  
2278      boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
2279              int iconIndex) {
2280          // If apps can&#x27;t be on SD, don&#x27;t even bother.
2281          if (!mAppsCanBeOnExternalStorage) {
2282              return false;
2283          }
2284          // If this icon doesn&#x27;t have a custom icon, check to see
2285          // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
2286          // we&#x27;re going to show, store what we are going to show back
2287          // into the DB.  We do this so when we&#x27;re loading, if the
2288          // package manager can&#x27;t find an icon (for example because
2289          // the app is on SD) then we can use that instead.
2290          if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
2291              cache.put(info, c.getBlob(iconIndex));
2292              return true;
2293          }
2294          return false;
2295      }
2296      void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
2297          boolean needSave = false;
2298          try {
2299              if (data != null) {
2300                  Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
2301                  Bitmap loaded = info.getIcon(mIconCache);
2302                  needSave = !saved.sameAs(loaded);
2303              } else {
2304                  needSave = true;
2305              }
2306          } catch (Exception e) {
2307              needSave = true;
2308          }
2309          if (needSave) {
2310              Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
2311              // This is slower than is ideal, but this only happens once
2312              // or when the app is updated with a new icon.
2313              updateItemInDatabase(context, info);
2314          }
2315      }
2316  
2317      /**
2318       * Return an existing FolderInfo object if we have encountered this ID previously,
2319       * or make a new one.
2320       */
2321      private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
2322          // See if a placeholder was created for us already
2323          FolderInfo folderInfo = folders.get(id);
2324          if (folderInfo == null) {
2325              // No placeholder -- create a new instance
2326              folderInfo = new FolderInfo();
2327              folders.put(id, folderInfo);
2328          }
2329          return folderInfo;
2330      }
2331  
2332      private static final Collator sCollator = Collator.getInstance();
2333      public static final Comparator&lt;ApplicationInfo&gt; APP_NAME_COMPARATOR
2334              = new Comparator&lt;ApplicationInfo&gt;() {
2335          public final int compare(ApplicationInfo a, ApplicationInfo b) {
2336              int result = sCollator.compare(a.title.toString(), b.title.toString());
2337              if (result == 0) {
2338                  result = a.componentName.compareTo(b.componentName);
2339              }
2340              return result;
2341          }
2342      };
2343      public static final Comparator&lt;ApplicationInfo&gt; APP_INSTALL_TIME_COMPARATOR
2344              = new Comparator&lt;ApplicationInfo&gt;() {
2345          public final int compare(ApplicationInfo a, ApplicationInfo b) {
2346              if (a.firstInstallTime &lt; b.firstInstallTime) return 1;
2347              if (a.firstInstallTime &gt; b.firstInstallTime) return -1;
2348              return 0;
2349          }
2350      };
2351      public static final Comparator&lt;AppWidgetProviderInfo&gt; WIDGET_NAME_COMPARATOR
2352              = new Comparator&lt;AppWidgetProviderInfo&gt;() {
2353          public final int compare(AppWidgetProviderInfo a, AppWidgetProviderInfo b) {
2354              return sCollator.compare(a.label.toString(), b.label.toString());
2355          }
2356      };
2357      static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
2358          if (info.activityInfo != null) {
2359              return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
2360          } else {
2361              return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
2362          }
2363      }
2364      public static class ShortcutNameComparator implements Comparator&lt;ResolveInfo&gt; {
2365          private PackageManager mPackageManager;
2366          private HashMap&lt;Object, CharSequence&gt; mLabelCache;
2367          ShortcutNameComparator(PackageManager pm) {
2368              mPackageManager = pm;
2369              mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
2370          }
2371          ShortcutNameComparator(PackageManager pm, HashMap&lt;Object, CharSequence&gt; labelCache) {
2372              mPackageManager = pm;
2373              mLabelCache = labelCache;
2374          }
2375          public final int compare(ResolveInfo a, ResolveInfo b) {
2376              CharSequence labelA, labelB;
2377              ComponentName keyA = LauncherModel.getComponentNameFromResolveInfo(a);
2378              ComponentName keyB = LauncherModel.getComponentNameFromResolveInfo(b);
2379              if (mLabelCache.containsKey(keyA)) {
2380                  labelA = mLabelCache.get(keyA);
2381              } else {
2382                  labelA = a.loadLabel(mPackageManager).toString();
2383  
2384                  mLabelCache.put(keyA, labelA);
2385              }
2386              if (mLabelCache.containsKey(keyB)) {
2387                  labelB = mLabelCache.get(keyB);
2388              } else {
2389                  labelB = b.loadLabel(mPackageManager).toString();
2390  
2391                  mLabelCache.put(keyB, labelB);
2392              }
2393              return sCollator.compare(labelA, labelB);
2394          }
2395      };
2396      public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
2397          private PackageManager mPackageManager;
2398          private HashMap&lt;Object, String&gt; mLabelCache;
2399          WidgetAndShortcutNameComparator(PackageManager pm) {
2400              mPackageManager = pm;
2401              mLabelCache = new HashMap&lt;Object, String&gt;();
2402          }
2403          public final int compare(Object a, Object b) {
2404              String labelA, labelB;
2405              if (mLabelCache.containsKey(a)) {
2406                  labelA = mLabelCache.get(a);
2407              } else {
2408                  labelA = (a instanceof AppWidgetProviderInfo) ?
2409                      ((AppWidgetProviderInfo) a).label :
2410                      ((ResolveInfo) a).loadLabel(mPackageManager).toString();
2411                  mLabelCache.put(a, labelA);
2412              }
2413              if (mLabelCache.containsKey(b)) {
2414                  labelB = mLabelCache.get(b);
2415              } else {
2416                  labelB = (b instanceof AppWidgetProviderInfo) ?
2417                      ((AppWidgetProviderInfo) b).label :
2418                      ((ResolveInfo) b).loadLabel(mPackageManager).toString();
2419                  mLabelCache.put(b, labelB);
2420              }
2421              return sCollator.compare(labelA, labelB);
2422          }
2423      };
2424  
2425      public void dumpState() {
2426          Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
2427          ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mAllAppsList.data);
2428          ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mAllAppsList.added);
2429          ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mAllAppsList.removed);
2430          ApplicationInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mAllAppsList.modified);




2431          if (mLoaderTask != null) {
2432              mLoaderTask.dumpState();
2433          } else {
2434              Log.d(TAG, &quot;mLoaderTask=null&quot;);
2435          }
2436      }
2437  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            