<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>257</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    257
                    <a href="256.html">prev</a>
                    <a href="258.html">next</a>
                    <a href="257_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    Automattic/simplenote-android_f6b200b2a988ba1c8c9bdce1f9018ade9b322480_Simplenote/src/main/java/com/automattic/simplenote/models/Note.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;f6b200b2a988ba1c8c9bdce1f9018ade9b322480:Simplenote/src/main/java/com/automattic/simplenote/models/Note.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;f6b200b2a988ba1c8c9bdce1f9018ade9b322480^1:Simplenote/src/main/java/com/automattic/simplenote/models/Note.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;f6b200b2a988ba1c8c9bdce1f9018ade9b322480^2:Simplenote/src/main/java/com/automattic/simplenote/models/Note.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;9e22297053412e6b042d92d1d612bb91cc42a7e0:Simplenote/src/main/java/com/automattic/simplenote/models/Note.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [j]], subset: [[b], [j]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 package com.automattic.simplenote.models;
   2 
   3 import android.content.Context;
   4 import android.text.TextUtils;
   5 
   6 import com.automattic.simplenote.R;
   7 import com.simperium.client.Bucket;
   8 import com.simperium.client.BucketObject;
   9 import com.simperium.client.BucketSchema;
  10 import com.simperium.client.Query;
  11 import com.simperium.client.Query.ComparisonType;
  12 
  13 import org.json.JSONArray;
  14 import org.json.JSONException;
  15 import org.json.JSONObject;
  16 
  17 import java.text.DateFormat;
  18 import java.text.SimpleDateFormat;
  19 import java.util.ArrayList;
  20 import java.util.Calendar;
  21 import java.util.List;
  22 import java.util.Locale;
  23 
  24 public class Note extends BucketObject {
  25 	
  26 	public static final String BUCKET_NAME=&quot;note&quot;;
  27     public static final String MARKDOWN_TAG=&quot;markdown&quot;;
  28     public static final String PINNED_TAG=&quot;pinned&quot;;
  29     public static final String PUBLISHED_TAG=&quot;published&quot;;
  30     public static final String NEW_LINE=&quot;\n&quot;;
  31 
  32     private static final String BLANK_CONTENT=&quot;&quot;;
  33     private static final String SPACE = &quot; &quot;;
  34     private static final int MAX_PREVIEW_CHARS = 300;
  35     
  36     public static final String CONTENT_PROPERTY=&quot;content&quot;;
  37     public static final String TAGS_PROPERTY=&quot;tags&quot;;
  38     public static final String SYSTEM_TAGS_PROPERTY=&quot;systemTags&quot;;
  39     public static final String CREATION_DATE_PROPERTY=&quot;creationDate&quot;;
  40     public static final String MODIFICATION_DATE_PROPERTY=&quot;modificationDate&quot;;
  41     public static final String SHARE_URL_PROPERTY=&quot;shareURL&quot;;
  42     public static final String PUBLISH_URL_PROPERTY=&quot;publishURL&quot;;
  43     public static final String DELETED_PROPERTY=&quot;deleted&quot;;
  44     public static final String TITLE_INDEX_NAME=&quot;title&quot;;
  45     public static final String CONTENT_PREVIEW_INDEX_NAME=&quot;contentPreview&quot;;
  46     public static final String PINNED_INDEX_NAME=&quot;pinned&quot;;
  47     public static final String MODIFIED_INDEX_NAME=&quot;modified&quot;;
  48     public static final String CREATED_INDEX_NAME=&quot;created&quot;;
  49     public static final String MATCHED_TITLE_INDEX_NAME=&quot;matchedTitle&quot;;
  50     public static final String MATCHED_CONTENT_INDEX_NAME=&quot;matchedContent&quot;;
  51     public static final String PUBLISH_URL=&quot;http://simp.ly/publish/&quot;;
  52 
  53     static public final String[] FULL_TEXT_INDEXES = new String[]{
  54         Note.TITLE_INDEX_NAME, Note.CONTENT_PROPERTY };
  55 	
  56 	protected String mTitle = null;
  57 	protected String mContentPreview = null;
  58 
  59 
  60 	public static class Schema extends BucketSchema&lt;Note&gt; {
  61 
  62         protected static NoteIndexer sNoteIndexer = new NoteIndexer();
  63         protected static NoteFullTextIndexer sFullTextIndexer = new NoteFullTextIndexer();
  64 
  65         public Schema(){
  66             autoIndex();
  67             addIndex(sNoteIndexer);
  68             setupFullTextIndex(sFullTextIndexer, NoteFullTextIndexer.INDEXES);
  69             setDefault(CONTENT_PROPERTY, &quot;&quot;);
  70             setDefault(SYSTEM_TAGS_PROPERTY, new JSONArray());
  71             setDefault(TAGS_PROPERTY, new JSONArray());
  72             setDefault(DELETED_PROPERTY, false);
  73             setDefault(SHARE_URL_PROPERTY, &quot;&quot;);
  74             setDefault(PUBLISH_URL_PROPERTY, &quot;&quot;);
  75         }
  76 
  77         public String getRemoteName(){
  78             return Note.BUCKET_NAME;
  79         }
  80 
  81         public Note build(String key, JSONObject properties) {
  82             return new Note(key, properties);
  83         }
  84 
  85         public void update(Note note, JSONObject properties) {
  86             note.setProperties(properties);
  87             note.mTitle = null;
  88             note.mContentPreview = null;
  89         }
  90 	}
  91 
  92     public static Query&lt;Note&gt; all(Bucket&lt;Note&gt; noteBucket){
  93         return noteBucket.query()
  94                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true);
  95     }
  96 
  97     public static Query&lt;Note&gt; allDeleted(Bucket&lt;Note&gt; noteBucket){
  98         return noteBucket.query()
  99                 .where(DELETED_PROPERTY, ComparisonType.EQUAL_TO, true);
 100     }
 101 
 102     public static Query&lt;Note&gt; search(Bucket&lt;Note&gt; noteBucket, String searchString){
 103         return noteBucket.query()
 104                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 105                 .where(CONTENT_PROPERTY, ComparisonType.LIKE, &quot;%&quot; + searchString + &quot;%&quot;);
 106     }
 107 
 108     public static Query&lt;Note&gt; allInTag(Bucket&lt;Note&gt; noteBucket, String tag){
 109         return noteBucket.query()
 110                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 111                 .where(TAGS_PROPERTY, ComparisonType.LIKE, tag);
 112     }
 113 
 114 
 115     public Note(String key) {
 116         super(key, new JSONObject());
 117     }
 118 
 119     public Note(String key, JSONObject properties) {
 120         super(key, properties);
 121     }
 122 
 123     protected void updateTitleAndPreview() {
 124         // try to build a title and preview property out of content
 125         String content = getContent().trim();
 126         if (content.length() &gt; MAX_PREVIEW_CHARS) {
 127             content = content.substring(0, MAX_PREVIEW_CHARS - 1);
 128         }
 129 
 130         int firstNewLinePosition = content.indexOf(NEW_LINE);
 131         if (firstNewLinePosition &gt; -1 &amp;&amp; firstNewLinePosition &lt; 200) {
 132             mTitle = content.substring(0, firstNewLinePosition).trim();
 133 
 134             if (firstNewLinePosition &lt; content.length()) {
 135                 mContentPreview = content.substring(firstNewLinePosition, content.length());
<abbr title=" 136                 mContentPreview = mContentPreview.replace(NEW_LINE, SPACE).replace(SPACE+SPACE, SPACE).trim();"> 136                 mContentPreview = mContentPreview.replace(NEW_LINE, SPACE).replace(SPACE+SPACE, SPACE).trðŸ”µ</abbr>
 137             }
 138             else {
 139                 mContentPreview = content;
 140             }
 141         }
 142         else {
 143             mTitle = content;
 144             mContentPreview = content;
 145         }
 146     }
 147 	
 148 	public String getTitle() {
 149         if (mTitle == null) {
 150             updateTitleAndPreview();
 151         }
 152 		return mTitle;
 153 	}
 154 
 155 	public String getContent() {
 156         Object content = getProperty(CONTENT_PROPERTY);
 157         if (content == null) {
 158             return BLANK_CONTENT;
 159         }
 160         return (String) content;
 161 	}
 162 
 163 	public void setContent(String content) {
 164         mTitle = null;
 165         mContentPreview = null;
 166         setProperty(CONTENT_PROPERTY, content);
 167 	}
 168 	
 169 	public String getContentPreview() {
 170         if (mContentPreview == null) {
 171             updateTitleAndPreview();
 172         }
 173 		return mContentPreview;
 174 	}
 175 
 176 	public Calendar getCreationDate() {
 177         return numberToDate((Number)getProperty(CREATION_DATE_PROPERTY));
 178 	}
 179 
 180 	public void setCreationDate(Calendar creationDate) {
 181         setProperty(CREATION_DATE_PROPERTY, creationDate.getTimeInMillis()/1000);
 182 	}
 183 
 184 	public Calendar getModificationDate() {
 185         return numberToDate((Number)getProperty(MODIFICATION_DATE_PROPERTY));
 186 	}
 187 
 188 	public void setModificationDate(Calendar modificationDate) {
 189         setProperty(MODIFICATION_DATE_PROPERTY, modificationDate.getTimeInMillis()/1000);
 190 	}
 191 
 192     public String getPublishedUrl() {
 193         String urlCode = (String)getProperty(PUBLISH_URL_PROPERTY);
 194         if (TextUtils.isEmpty(urlCode)) {
 195             return &quot;&quot;;
 196         }
 197 
 198         return PUBLISH_URL + urlCode;
 199     }
 200 
 201     public boolean hasTag(String tag){
 202         List&lt;String&gt; tags = getTags();
 203         String tagLower = tag.toLowerCase();
 204         for (String tagName : tags) {
 205             if (tagLower.equals(tagName.toLowerCase())) return true;
 206         }
 207         return false;
 208     }
 209 
 210     public boolean hasTag(Tag tag){
 211         return hasTag(tag.getSimperiumKey());
 212     }
 213 
 214     public List&lt;String&gt; getTags() {
 215 
 216         JSONArray tags = (JSONArray) getProperty(TAGS_PROPERTY);
 217 
 218         if (tags == null) {
 219             tags = new JSONArray();
 220             setProperty(TAGS_PROPERTY, tags);
 221         }
 222 
 223         int length = tags.length();
 224 
 225         List&lt;String&gt; tagList = new ArrayList&lt;&gt;(length);
 226 
 227         if (length == 0) return tagList;
 228 
 229         for (int i=0; i&lt;length; i++) {
 230             String tag = tags.optString(i);
 231             if (!tag.equals(&quot;&quot;))
 232                 tagList.add(tag);
 233         }
 234 
 235         return tagList;
 236     }
 237 
 238     public void setTags(List&lt;String&gt; tags) {
 239         setProperty(TAGS_PROPERTY, new JSONArray(tags));
 240     }
 241 
 242     /**
 243      * String of tags delimited by a space
 244      */
 245     public CharSequence getTagString(){
 246         StringBuilder tagString = new StringBuilder();
 247         List&lt;String&gt; tags = getTags();
 248         for(String tag : tags){
 249             if (tagString.length() &gt; 0) {
 250                 tagString.append(SPACE);
 251             }
 252             tagString.append(tag);
 253         }
 254         return tagString;
 255     }
 256 
 257     /**
 258      * Sets the note&#x27;s tags by providing it with a {@link String} of space
 259      * seperated tags. Filters out duplicate tags.
 260      * 
 261      * @param tagString a space delimited list of tags
 262      */
 263     public void setTagString(String tagString){
 264         List&lt;String&gt; tags = getTags();
 265         tags.clear();
 266 
 267         if (tagString == null) {
 268             setTags(tags);
 269             return;
 270         }
 271 
 272         // Make sure string has a trailing space
 273         if (tagString.length() &gt; 1 &amp;&amp; !tagString.substring(tagString.length() - 1).equals(SPACE))
 274             tagString = tagString + SPACE;
 275         // for comparing case-insensitive strings, would like to find a way to
 276         // do this without allocating a new list and strings
 277         List&lt;String&gt; tagsUpperCase = new ArrayList&lt;&gt;();
 278         // remove all current tags
 279         int start = 0;
 280         int next = -1;
 281         String possible;
 282         String possibleUpperCase;
 283         // search tag string for space characters and pull out individual tags
 284         do {
 285             next = tagString.indexOf(SPACE, start);
 286             if (next &gt; start) {
 287                 possible = tagString.substring(start, next);
 288                 possibleUpperCase = possible.toUpperCase();
 289                 if (!possible.equals(SPACE) &amp;&amp; !tagsUpperCase.contains(possibleUpperCase)) {
 290                     tagsUpperCase.add(possibleUpperCase);
 291                     tags.add(possible);
 292                 }
 293             }
 294             start = next + 1;
 295         } while(next &gt; -1);
 296         setTags(tags);
 297     }
 298 
 299     public JSONArray getSystemTags() {
 300         JSONArray tags = (JSONArray) getProperty(SYSTEM_TAGS_PROPERTY);
 301         if (tags == null) {
 302             tags = new JSONArray();
 303             setProperty(SYSTEM_TAGS_PROPERTY, tags);
 304         }
 305         return tags;
 306     }
 307 
 308 	public Boolean isDeleted() {
 309         Object deleted = getProperty(DELETED_PROPERTY);
 310         if (deleted == null) {
 311             return false;
 312         }
 313         if (deleted instanceof Boolean) {
 314             return (Boolean) deleted;
 315         } else
 316             return deleted instanceof Number &amp;&amp; ((Number) deleted).intValue() != 0;
 317     }
 318 
 319     public void setDeleted(boolean deleted) {
 320         setProperty(DELETED_PROPERTY, deleted);
 321     }
 322 
 323     public boolean isMarkdownEnabled() {
 324         return hasSystemTag(MARKDOWN_TAG);
 325     }
 326 
 327     public void setMarkdownEnabled(boolean isMarkdownEnabled) {
 328         if (isMarkdownEnabled) {
 329             addSystemTag(MARKDOWN_TAG);
 330         } else {
 331             removeSystemTag(MARKDOWN_TAG);
 332         }
 333     }
 334 
 335     public boolean isPinned() {
 336         return hasSystemTag(PINNED_TAG);
 337     }
 338 
 339     public void setPinned(boolean isPinned) {
 340         if (isPinned) {
 341             addSystemTag(PINNED_TAG);
 342         } else {
 343             removeSystemTag(PINNED_TAG);
 344         }
 345     }
 346 
 347     public boolean isPublished() {
 348         return hasSystemTag(PUBLISHED_TAG) &amp;&amp; !TextUtils.isEmpty(getPublishedUrl());
 349     }
 350 
 351     public void setPublished(boolean isPublished) {
 352         if (isPublished) {
 353             addSystemTag(PUBLISHED_TAG);
 354         } else {
 355             removeSystemTag(PUBLISHED_TAG);
 356         }
 357     }
 358 
 359     private boolean hasSystemTag(String tag) {
 360         if (TextUtils.isEmpty(tag))
 361             return false;
 362 
 363         JSONArray tags = getSystemTags();
 364         int length = tags.length();
 365         for (int i=0; i&lt;length; i++) {
 366             if (tags.optString(i).equals(tag)) {
 367                 return true;
 368             }
 369         }
 370 
 371         return false;
 372     }
 373 
 374     private void addSystemTag(String tag) {
 375         if (TextUtils.isEmpty(tag)) {
 376             return;
 377         }
 378 
 379         // Ensure we don&#x27;t add the same tag again
 380         if (!hasSystemTag(tag)) {
 381             getSystemTags().put(tag);
 382         }
 383     }
 384 
 385     private void removeSystemTag(String tag) {
 386         if (!hasSystemTag(tag)) {
 387             return;
 388         }
 389 
 390         JSONArray tags = getSystemTags();
 391         JSONArray newTags = new JSONArray();
 392         int length = tags.length();
 393         try {
 394             for (int i = 0; i &lt; length; i++) {
 395                 Object val = tags.get(i);
 396                 if (!val.equals(tag))
 397                     newTags.put(val);
 398             }
 399         } catch (JSONException e) {
 400             // could not update pinned setting
 401         }
 402 
 403         setProperty(SYSTEM_TAGS_PROPERTY, newTags);
 404     }
 405 
 406     public static String dateString(Number time, boolean useShortFormat, Context context){
 407         Calendar c = numberToDate(time);
 408         return dateString(c, useShortFormat, context);
 409     }
 410 
 411 	public static String dateString(Calendar c, boolean useShortFormat, Context context) {
 412 		int year, month, day;
 413 
 414 		String time, date, retVal;
 415 		time = date = &quot;&quot;;
 416 
 417 		Calendar diff = Calendar.getInstance();
 418 		diff.setTimeInMillis(diff.getTimeInMillis() - c.getTimeInMillis());
 419 
 420 		year = diff.get(Calendar.YEAR);
 421 		month = diff.get(Calendar.MONTH);
 422 		day = diff.get(Calendar.DAY_OF_MONTH);
 423 
 424 		diff.setTimeInMillis(0); // starting time
 425 		time = DateFormat.getTimeInstance(DateFormat.SHORT).format(c.getTime());
<abbr title=" 426 		if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(Calendar.DAY_OF_MONTH))) {"> 426 		if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(CalendðŸ”µ</abbr>
 427 			date = context.getResources().getString(R.string.today);
 428 			if (useShortFormat)
 429 				retVal = time;
 430 			else
 431 				retVal = date + &quot;, &quot; + time;
 432 		} else if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == 1)) {
 433 			date = context.getResources().getString(R.string.yesterday);
 434 			if (useShortFormat)
 435 				retVal = date;
 436 			else
 437 				retVal = date + &quot;, &quot; + time;
 438 		} else {
 439 			date = new SimpleDateFormat(&quot;MMM dd&quot;, Locale.US).format(c.getTime());
 440 			retVal = date + &quot;, &quot; + time;
 441 		}
 442 
 443 		return retVal;
 444 	}
 445 
 446     public static Calendar numberToDate(Number time){
 447         Calendar date = Calendar.getInstance();
 448         if (time != null) {
 449             // Flick Note uses millisecond resolution timestamps Simplenote expects seconds
 450             // since we only deal with create and modify timestamps, they should all have occured
 451             // at the present time or in the past.
 452             float now = date.getTimeInMillis()/1000;
 453             float magnitude = time.floatValue()/now;
 454             if (magnitude &gt;= 2.f) time = time.longValue()/1000;
 455             date.setTimeInMillis(time.longValue()*1000);
 456         }
 457         return date;
 458     }
 459 
 460     /**
 461      * Check if the note has any changes
 462      * @param content the new note content
 463      * @param tagString space separated tags
 464      * @param isPinned note is pinned
 465      * @param isMarkdownEnabled note has markdown enabled
 466      * @return true if note has changes, false if it is unchanged.
 467      */
 468 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 469     public boolean hasChanges(String content, String tagString, boolean isPinned) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 470         return !(content.equals(this.getContent()) &amp;&amp; this.isPinned() == isPinned &amp;&amp; tagString.equals(this.getTagString().toString()));"> 470         return !(content.equals(this.getContent()) &amp;&amp; this.isPinned() == isPinned &amp;&amp; tagString.equals(thiðŸ”µ</abbr></span>
 471 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 472      * @param isPinned note is pinned</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 473      * @return true if note has changes, false if it is unchanged.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 474      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 475     public boolean hasChanges(String content, String tagString, boolean isPinned) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 476 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 477         if (content.equals(this.getContent()) &amp;&amp; this.isPinned() == isPinned &amp;&amp; tagString.equals(this.getTagString().toString()))"> 477         if (content.equals(this.getContent()) &amp;&amp; this.isPinned() == isPinned &amp;&amp; tagString.equals(this.getðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 478             return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 479         else</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 480             return true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 481     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 482 }</span>
 483 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 484     public boolean hasChanges(String content, String tagString, boolean isPinned, boolean isMarkdownEnabled) {"> 484     public boolean hasChanges(String content, String tagString, boolean isPinned, boolean isMarkdownEnablðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 485         return !content.equals(this.getContent())</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 486             || !tagString.equals(this.getTagString().toString())</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 487             || this.isPinned() != isPinned</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 488             || this.isMarkdownEnabled() != isMarkdownEnabled;</span>
 489 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 490     }
 491 }</pre></td>
                            <td><pre>   1 package com.automattic.simplenote.models;
   2 
   3 import android.content.Context;
   4 import android.text.TextUtils;
   5 
   6 import com.automattic.simplenote.R;
   7 import com.simperium.client.Bucket;
   8 import com.simperium.client.BucketObject;
   9 import com.simperium.client.BucketSchema;
  10 import com.simperium.client.Query;
  11 import com.simperium.client.Query.ComparisonType;
  12 
  13 import org.json.JSONArray;
  14 import org.json.JSONException;
  15 import org.json.JSONObject;
  16 
  17 import java.text.DateFormat;
  18 import java.text.SimpleDateFormat;
  19 import java.util.ArrayList;
  20 import java.util.Calendar;
  21 import java.util.List;
  22 import java.util.Locale;
  23 
  24 public class Note extends BucketObject {
  25 
  26 	public static final String BUCKET_NAME=&quot;note&quot;;
  27     public static final String MARKDOWN_TAG=&quot;markdown&quot;;
  28     public static final String PINNED_TAG=&quot;pinned&quot;;
  29     public static final String PUBLISHED_TAG=&quot;published&quot;;
  30     public static final String NEW_LINE=&quot;\n&quot;;
  31 
  32     private static final String BLANK_CONTENT=&quot;&quot;;
  33     private static final String SPACE = &quot; &quot;;
  34     private static final int MAX_PREVIEW_CHARS = 300;
  35 
  36     public static final String CONTENT_PROPERTY=&quot;content&quot;;
  37     public static final String TAGS_PROPERTY=&quot;tags&quot;;
  38     public static final String SYSTEM_TAGS_PROPERTY=&quot;systemTags&quot;;
  39     public static final String CREATION_DATE_PROPERTY=&quot;creationDate&quot;;
  40     public static final String MODIFICATION_DATE_PROPERTY=&quot;modificationDate&quot;;
  41     public static final String SHARE_URL_PROPERTY=&quot;shareURL&quot;;
  42     public static final String PUBLISH_URL_PROPERTY=&quot;publishURL&quot;;
  43     public static final String DELETED_PROPERTY=&quot;deleted&quot;;
  44     public static final String TITLE_INDEX_NAME=&quot;title&quot;;
  45     public static final String CONTENT_PREVIEW_INDEX_NAME=&quot;contentPreview&quot;;
  46     public static final String PINNED_INDEX_NAME=&quot;pinned&quot;;
  47     public static final String MODIFIED_INDEX_NAME=&quot;modified&quot;;
  48     public static final String CREATED_INDEX_NAME=&quot;created&quot;;
  49     public static final String MATCHED_TITLE_INDEX_NAME=&quot;matchedTitle&quot;;
  50     public static final String MATCHED_CONTENT_INDEX_NAME=&quot;matchedContent&quot;;
  51     public static final String PUBLISH_URL=&quot;http://simp.ly/publish/&quot;;
  52 
  53     static public final String[] FULL_TEXT_INDEXES = new String[]{
  54         Note.TITLE_INDEX_NAME, Note.CONTENT_PROPERTY };
  55 
  56 	protected String mTitle = null;
  57 	protected String mContentPreview = null;
  58 
  59 
  60 	public static class Schema extends BucketSchema&lt;Note&gt; {
  61 
  62         protected static NoteIndexer sNoteIndexer = new NoteIndexer();
  63         protected static NoteFullTextIndexer sFullTextIndexer = new NoteFullTextIndexer();
  64 
  65         public Schema(){
  66             autoIndex();
  67             addIndex(sNoteIndexer);
  68             setupFullTextIndex(sFullTextIndexer, NoteFullTextIndexer.INDEXES);
  69             setDefault(CONTENT_PROPERTY, &quot;&quot;);
  70             setDefault(SYSTEM_TAGS_PROPERTY, new JSONArray());
  71             setDefault(TAGS_PROPERTY, new JSONArray());
  72             setDefault(DELETED_PROPERTY, false);
  73             setDefault(SHARE_URL_PROPERTY, &quot;&quot;);
  74             setDefault(PUBLISH_URL_PROPERTY, &quot;&quot;);
  75         }
  76 
  77         public String getRemoteName(){
  78             return Note.BUCKET_NAME;
  79         }
  80 
  81         public Note build(String key, JSONObject properties) {
  82             return new Note(key, properties);
  83         }
  84 
  85         public void update(Note note, JSONObject properties) {
  86             note.setProperties(properties);
  87             note.mTitle = null;
  88             note.mContentPreview = null;
  89         }
  90 	}
  91 
  92     public static Query&lt;Note&gt; all(Bucket&lt;Note&gt; noteBucket){
  93         return noteBucket.query()
  94                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true);
  95     }
  96 
  97     public static Query&lt;Note&gt; allDeleted(Bucket&lt;Note&gt; noteBucket){
  98         return noteBucket.query()
  99                 .where(DELETED_PROPERTY, ComparisonType.EQUAL_TO, true);
 100     }
 101 
 102     public static Query&lt;Note&gt; search(Bucket&lt;Note&gt; noteBucket, String searchString){
 103         return noteBucket.query()
 104                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 105                 .where(CONTENT_PROPERTY, ComparisonType.LIKE, &quot;%&quot; + searchString + &quot;%&quot;);
 106     }
 107 
 108     public static Query&lt;Note&gt; allInTag(Bucket&lt;Note&gt; noteBucket, String tag){
 109         return noteBucket.query()
 110                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 111                 .where(TAGS_PROPERTY, ComparisonType.LIKE, tag);
 112     }
 113 
 114 
 115     public Note(String key) {
 116         super(key, new JSONObject());
 117     }
 118 
 119     public Note(String key, JSONObject properties) {
 120         super(key, properties);
 121     }
 122 
 123     protected void updateTitleAndPreview() {
 124         // try to build a title and preview property out of content
 125         String content = getContent().trim();
 126         if (content.length() &gt; MAX_PREVIEW_CHARS) {
 127             content = content.substring(0, MAX_PREVIEW_CHARS - 1);
 128         }
 129 
 130         int firstNewLinePosition = content.indexOf(NEW_LINE);
 131         if (firstNewLinePosition &gt; -1 &amp;&amp; firstNewLinePosition &lt; 200) {
 132             mTitle = content.substring(0, firstNewLinePosition).trim();
 133 
 134             if (firstNewLinePosition &lt; content.length()) {
 135                 mContentPreview = content.substring(firstNewLinePosition, content.length());
<abbr title=" 136                 mContentPreview = mContentPreview.replace(NEW_LINE, SPACE).replace(SPACE+SPACE, SPACE).trim();"> 136                 mContentPreview = mContentPreview.replace(NEW_LINE, SPACE).replace(SPACE+SPACE, SPACE).trðŸ”µ</abbr>
 137             }
 138             else {
 139                 mContentPreview = content;
 140             }
 141         }
 142         else {
 143             mTitle = content;
 144             mContentPreview = content;
 145         }
 146     }
 147 
 148 	public String getTitle() {
 149         if (mTitle == null) {
 150             updateTitleAndPreview();
 151         }
 152 		return mTitle;
 153 	}
 154 
 155 	public String getContent() {
 156         Object content = getProperty(CONTENT_PROPERTY);
 157         if (content == null) {
 158             return BLANK_CONTENT;
 159         }
 160         return (String) content;
 161 	}
 162 
 163 	public void setContent(String content) {
 164         mTitle = null;
 165         mContentPreview = null;
 166         setProperty(CONTENT_PROPERTY, content);
 167 	}
 168 
 169 	public String getContentPreview() {
 170         if (mContentPreview == null) {
 171             updateTitleAndPreview();
 172         }
 173 		return mContentPreview;
 174 	}
 175 
 176 	public Calendar getCreationDate() {
 177         return numberToDate((Number)getProperty(CREATION_DATE_PROPERTY));
 178 	}
 179 
 180 	public void setCreationDate(Calendar creationDate) {
 181         setProperty(CREATION_DATE_PROPERTY, creationDate.getTimeInMillis()/1000);
 182 	}
 183 
 184 	public Calendar getModificationDate() {
 185         return numberToDate((Number)getProperty(MODIFICATION_DATE_PROPERTY));
 186 	}
 187 
 188 	public void setModificationDate(Calendar modificationDate) {
 189         setProperty(MODIFICATION_DATE_PROPERTY, modificationDate.getTimeInMillis()/1000);
 190 	}
 191 
 192     public String getPublishedUrl() {
 193         String urlCode = (String)getProperty(PUBLISH_URL_PROPERTY);
 194         if (TextUtils.isEmpty(urlCode)) {
 195             return &quot;&quot;;
 196         }
 197 
 198         return PUBLISH_URL + urlCode;
 199     }
 200 
 201     public boolean hasTag(String tag){
 202         List&lt;String&gt; tags = getTags();
 203         String tagLower = tag.toLowerCase();
 204         for (String tagName : tags) {
 205             if (tagLower.equals(tagName.toLowerCase())) return true;
 206         }
 207         return false;
 208     }
 209 
 210     public boolean hasTag(Tag tag){
 211         return hasTag(tag.getSimperiumKey());
 212     }
 213 
 214     public List&lt;String&gt; getTags() {
 215 
 216         JSONArray tags = (JSONArray) getProperty(TAGS_PROPERTY);
 217 
 218         if (tags == null) {
 219             tags = new JSONArray();
 220             setProperty(TAGS_PROPERTY, tags);
 221         }
 222 
 223         int length = tags.length();
 224 
 225         List&lt;String&gt; tagList = new ArrayList&lt;&gt;(length);
 226 
 227         if (length == 0) return tagList;
 228 
 229         for (int i=0; i&lt;length; i++) {
 230             String tag = tags.optString(i);
 231             if (!tag.equals(&quot;&quot;))
 232                 tagList.add(tag);
 233         }
 234 
 235         return tagList;
 236     }
 237 
 238     public void setTags(List&lt;String&gt; tags) {
 239         setProperty(TAGS_PROPERTY, new JSONArray(tags));
 240     }
 241 
 242     /**
 243      * String of tags delimited by a space
 244      */
 245     public CharSequence getTagString(){
 246         StringBuilder tagString = new StringBuilder();
 247         List&lt;String&gt; tags = getTags();
 248         for(String tag : tags){
 249             if (tagString.length() &gt; 0) {
 250                 tagString.append(SPACE);
 251             }
 252             tagString.append(tag);
 253         }
 254         return tagString;
 255     }
 256 
 257     /**
 258      * Sets the note&#x27;s tags by providing it with a {@link String} of space
 259      * seperated tags. Filters out duplicate tags.
 260      *
 261      * @param tagString a space delimited list of tags
 262      */
 263     public void setTagString(String tagString){
 264         List&lt;String&gt; tags = getTags();
 265         tags.clear();
 266 
 267         if (tagString == null) {
 268             setTags(tags);
 269             return;
 270         }
 271 
 272         // Make sure string has a trailing space
 273         if (tagString.length() &gt; 1 &amp;&amp; !tagString.substring(tagString.length() - 1).equals(SPACE))
 274             tagString = tagString + SPACE;
 275         // for comparing case-insensitive strings, would like to find a way to
 276         // do this without allocating a new list and strings
 277         List&lt;String&gt; tagsUpperCase = new ArrayList&lt;&gt;();
 278         // remove all current tags
 279         int start = 0;
 280         int next = -1;
 281         String possible;
 282         String possibleUpperCase;
 283         // search tag string for space characters and pull out individual tags
 284         do {
 285             next = tagString.indexOf(SPACE, start);
 286             if (next &gt; start) {
 287                 possible = tagString.substring(start, next);
 288                 possibleUpperCase = possible.toUpperCase();
 289                 if (!possible.equals(SPACE) &amp;&amp; !tagsUpperCase.contains(possibleUpperCase)) {
 290                     tagsUpperCase.add(possibleUpperCase);
 291                     tags.add(possible);
 292                 }
 293             }
 294             start = next + 1;
 295         } while(next &gt; -1);
 296         setTags(tags);
 297     }
 298 
 299     public JSONArray getSystemTags() {
 300         JSONArray tags = (JSONArray) getProperty(SYSTEM_TAGS_PROPERTY);
 301         if (tags == null) {
 302             tags = new JSONArray();
 303             setProperty(SYSTEM_TAGS_PROPERTY, tags);
 304         }
 305         return tags;
 306     }
 307 
 308 	public Boolean isDeleted() {
 309         Object deleted = getProperty(DELETED_PROPERTY);
 310         if (deleted == null) {
 311             return false;
 312         }
 313         if (deleted instanceof Boolean) {
 314             return (Boolean) deleted;
 315         } else
 316             return deleted instanceof Number &amp;&amp; ((Number) deleted).intValue() != 0;
 317     }
 318 
 319     public void setDeleted(boolean deleted) {
 320         setProperty(DELETED_PROPERTY, deleted);
 321     }
 322 
 323     public boolean isMarkdownEnabled() {
 324         return hasSystemTag(MARKDOWN_TAG);
 325     }
 326 
 327     public void setMarkdownEnabled(boolean isMarkdownEnabled) {
 328         if (isMarkdownEnabled) {
 329             addSystemTag(MARKDOWN_TAG);
 330         } else {
 331             removeSystemTag(MARKDOWN_TAG);
 332         }
 333     }
 334 
 335     public boolean isPinned() {
 336         return hasSystemTag(PINNED_TAG);
 337     }
 338 
 339     public void setPinned(boolean isPinned) {
 340         if (isPinned) {
 341             addSystemTag(PINNED_TAG);
 342         } else {
 343             removeSystemTag(PINNED_TAG);
 344         }
 345     }
 346 
 347     public boolean isPublished() {
 348         return hasSystemTag(PUBLISHED_TAG) &amp;&amp; !TextUtils.isEmpty(getPublishedUrl());
 349     }
 350 
 351     public void setPublished(boolean isPublished) {
 352         if (isPublished) {
 353             addSystemTag(PUBLISHED_TAG);
 354         } else {
 355             removeSystemTag(PUBLISHED_TAG);
 356         }
 357     }
 358 
 359     private boolean hasSystemTag(String tag) {
 360         if (TextUtils.isEmpty(tag))
 361             return false;
 362 
 363         JSONArray tags = getSystemTags();
 364         int length = tags.length();
 365         for (int i=0; i&lt;length; i++) {
 366             if (tags.optString(i).equals(tag)) {
 367                 return true;
 368             }
 369         }
 370 
 371         return false;
 372     }
 373 
 374     private void addSystemTag(String tag) {
 375         if (TextUtils.isEmpty(tag)) {
 376             return;
 377         }
 378 
 379         // Ensure we don&#x27;t add the same tag again
 380         if (!hasSystemTag(tag)) {
 381             getSystemTags().put(tag);
 382         }
 383     }
 384 
 385     private void removeSystemTag(String tag) {
 386         if (!hasSystemTag(tag)) {
 387             return;
 388         }
 389 
 390         JSONArray tags = getSystemTags();
 391         JSONArray newTags = new JSONArray();
 392         int length = tags.length();
 393         try {
 394             for (int i = 0; i &lt; length; i++) {
 395                 Object val = tags.get(i);
 396                 if (!val.equals(tag))
 397                     newTags.put(val);
 398             }
 399         } catch (JSONException e) {
 400             // could not update pinned setting
 401         }
 402 
 403         setProperty(SYSTEM_TAGS_PROPERTY, newTags);
 404     }
 405 
 406     public static String dateString(Number time, boolean useShortFormat, Context context){
 407         Calendar c = numberToDate(time);
 408         return dateString(c, useShortFormat, context);
 409     }
 410 
 411 	public static String dateString(Calendar c, boolean useShortFormat, Context context) {
 412 		int year, month, day;
 413 
 414 		String time, date, retVal;
 415 		time = date = &quot;&quot;;
 416 
 417 		Calendar diff = Calendar.getInstance();
 418 		diff.setTimeInMillis(diff.getTimeInMillis() - c.getTimeInMillis());
 419 
 420 		year = diff.get(Calendar.YEAR);
 421 		month = diff.get(Calendar.MONTH);
 422 		day = diff.get(Calendar.DAY_OF_MONTH);
 423 
 424 		diff.setTimeInMillis(0); // starting time
 425 		time = DateFormat.getTimeInstance(DateFormat.SHORT).format(c.getTime());
<abbr title=" 426 		if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(Calendar.DAY_OF_MONTH))) {"> 426 		if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(CalendðŸ”µ</abbr>
 427 			date = context.getResources().getString(R.string.today);
 428 			if (useShortFormat)
 429 				retVal = time;
 430 			else
 431 				retVal = date + &quot;, &quot; + time;
 432 		} else if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == 1)) {
 433 			date = context.getResources().getString(R.string.yesterday);
 434 			if (useShortFormat)
 435 				retVal = date;
 436 			else
 437 				retVal = date + &quot;, &quot; + time;
 438 		} else {
 439 			date = new SimpleDateFormat(&quot;MMM dd&quot;, Locale.US).format(c.getTime());
 440 			retVal = date + &quot;, &quot; + time;
 441 		}
 442 
 443 		return retVal;
 444 	}
 445 
 446     public static Calendar numberToDate(Number time){
 447         Calendar date = Calendar.getInstance();
 448         if (time != null) {
 449             // Flick Note uses millisecond resolution timestamps Simplenote expects seconds
 450             // since we only deal with create and modify timestamps, they should all have occured
 451             // at the present time or in the past.
 452             float now = date.getTimeInMillis()/1000;
 453             float magnitude = time.floatValue()/now;
 454             if (magnitude &gt;= 2.f) time = time.longValue()/1000;
 455             date.setTimeInMillis(time.longValue()*1000);
 456         }
 457         return date;
 458     }
 459 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 460 public boolean hasChanges(String content, String tagString, boolean isPinned) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 461         return !(content.equals(this.getContent()) &amp;&amp; this.isPinned() == isPinned &amp;&amp; tagString.equals(this.getTagString().toString()));"> 461         return !(content.equals(this.getContent()) &amp;&amp; this.isPinned() == isPinned &amp;&amp; tagString.equals(thiðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 462     }</span>
 463 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 464 public boolean hasChanges(String content, String tagString, boolean isPinned) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 465 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 466         if (content.equals(this.getContent()) &amp;&amp; this.isPinned() == isPinned &amp;&amp; tagString.equals(this.getTagString().toString()))"> 466         if (content.equals(this.getContent()) &amp;&amp; this.isPinned() == isPinned &amp;&amp; tagString.equals(this.getðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 467             return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 468         else</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 469             return true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 470     }</span>
 471 =======
 472 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 473 
 474 
 475     /**
 476      * Check if the note has any changes
 477      * @param content the new note content
 478      * @param tagString space separated tags
 479      * @param isPinned note is pinned
 480      * @param isMarkdownEnabled note has markdown enabled
 481      * @return true if note has changes, false if it is unchanged.
 482      */
<abbr title=" 483     public boolean hasChanges(String content, String tagString, boolean isPinned, boolean isMarkdownEnabled) {"> 483     public boolean hasChanges(String content, String tagString, boolean isPinned, boolean isMarkdownEnablðŸ”µ</abbr>
 484         return !content.equals(this.getContent())
 485             || !tagString.equals(this.getTagString().toString())
 486             || this.isPinned() != isPinned
 487             || this.isMarkdownEnabled() != isMarkdownEnabled;
 488     }
 489 }
 </pre></td>
                            <td><pre>   1 package com.automattic.simplenote.models;
   2 
   3 import android.content.Context;
   4 import android.text.TextUtils;
   5 import com.automattic.simplenote.R;
   6 import com.simperium.client.Bucket;
   7 import com.simperium.client.BucketObject;
   8 import com.simperium.client.BucketSchema;
   9 import com.simperium.client.Query.ComparisonType;
  10 import com.simperium.client.Query;
  11 import java.text.DateFormat;
  12 import java.text.SimpleDateFormat;
  13 import java.util.ArrayList;
  14 import java.util.Calendar;
  15 import java.util.List;
  16 import java.util.Locale;
  17 import org.json.JSONArray;
  18 import org.json.JSONException;
  19 import org.json.JSONObject;
  20 
  21 
  22 public class Note extends BucketObject {
  23 public static final String BUCKET_NAME=&quot;note&quot;;
  24 
  25     public static final String MARKDOWN_TAG=&quot;markdown&quot;;
  26 
  27     public static final String PINNED_TAG=&quot;pinned&quot;;
  28 
  29     public static final String PUBLISHED_TAG=&quot;published&quot;;
  30 
  31     public static final String NEW_LINE=&quot;\n&quot;;
  32 
  33     private static final String BLANK_CONTENT=&quot;&quot;;
  34 
  35     private static final String SPACE = &quot; &quot;;
  36 
  37     private static final int MAX_PREVIEW_CHARS = 300;
  38 
  39     public static final String CONTENT_PROPERTY=&quot;content&quot;;
  40 
  41     public static final String TAGS_PROPERTY=&quot;tags&quot;;
  42 
  43     public static final String SYSTEM_TAGS_PROPERTY=&quot;systemTags&quot;;
  44 
  45     public static final String CREATION_DATE_PROPERTY=&quot;creationDate&quot;;
  46 
  47     public static final String MODIFICATION_DATE_PROPERTY=&quot;modificationDate&quot;;
  48 
  49     public static final String SHARE_URL_PROPERTY=&quot;shareURL&quot;;
  50 
  51     public static final String PUBLISH_URL_PROPERTY=&quot;publishURL&quot;;
  52 
  53     public static final String DELETED_PROPERTY=&quot;deleted&quot;;
  54 
  55     public static final String TITLE_INDEX_NAME=&quot;title&quot;;
  56 
  57     public static final String CONTENT_PREVIEW_INDEX_NAME=&quot;contentPreview&quot;;
  58 
  59     public static final String PINNED_INDEX_NAME=&quot;pinned&quot;;
  60 
  61     public static final String MODIFIED_INDEX_NAME=&quot;modified&quot;;
  62 
  63     public static final String CREATED_INDEX_NAME=&quot;created&quot;;
  64 
  65     public static final String MATCHED_TITLE_INDEX_NAME=&quot;matchedTitle&quot;;
  66 
  67     public static final String MATCHED_CONTENT_INDEX_NAME=&quot;matchedContent&quot;;
  68 
  69     public static final String PUBLISH_URL=&quot;http://simp.ly/publish/&quot;;
  70 
<abbr title="  71     public static final String[] FULL_TEXT_INDEXES = new String[]{ Note.TITLE_INDEX_NAME, Note.CONTENT_PROPERTY };">  71     public static final String[] FULL_TEXT_INDEXES = new String[]{ Note.TITLE_INDEX_NAME, Note.CONTENT_PRðŸ”µ</abbr>
  72 
  73 protected String mTitle = null;
  74 
  75 protected String mContentPreview = null;
  76 
  77     public static class Schema extends BucketSchema&lt;Note&gt; {
  78         protected static NoteIndexer sNoteIndexer = new NoteIndexer();
  79 
  80         protected static NoteFullTextIndexer sFullTextIndexer = new NoteFullTextIndexer();
  81 
  82         public Schema() {
  83             autoIndex();
  84             addIndex(sNoteIndexer);
  85             setupFullTextIndex(sFullTextIndexer, NoteFullTextIndexer.INDEXES);
  86             setDefault(CONTENT_PROPERTY, &quot;&quot;);
  87             setDefault(SYSTEM_TAGS_PROPERTY, new JSONArray());
  88             setDefault(TAGS_PROPERTY, new JSONArray());
  89             setDefault(DELETED_PROPERTY, false);
  90             setDefault(SHARE_URL_PROPERTY, &quot;&quot;);
  91             setDefault(PUBLISH_URL_PROPERTY, &quot;&quot;);
  92         }
  93 
  94         public String getRemoteName() {
  95             return Note.BUCKET_NAME;
  96         }
  97 
  98         public Note build(String key, JSONObject properties) {
  99             return new Note(key, properties);
 100         }
 101 
 102         public void update(Note note, JSONObject properties) {
 103             note.setProperties(properties);
 104             note.mTitle = null;
 105             note.mContentPreview = null;
 106         }
 107     }
 108 
 109     public static Query&lt;Note&gt; all(Bucket&lt;Note&gt; noteBucket){
 110         return noteBucket.query()
 111                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true);
 112     }
 113 
 114     public static Query&lt;Note&gt; allDeleted(Bucket&lt;Note&gt; noteBucket){
 115         return noteBucket.query()
 116                 .where(DELETED_PROPERTY, ComparisonType.EQUAL_TO, true);
 117     }
 118 
 119     public static Query&lt;Note&gt; search(Bucket&lt;Note&gt; noteBucket, String searchString){
 120         return noteBucket.query()
 121                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 122                 .where(CONTENT_PROPERTY, ComparisonType.LIKE, &quot;%&quot; + searchString + &quot;%&quot;);
 123     }
 124 
 125     public static Query&lt;Note&gt; allInTag(Bucket&lt;Note&gt; noteBucket, String tag){
 126         return noteBucket.query()
 127                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 128                 .where(TAGS_PROPERTY, ComparisonType.LIKE, tag);
 129     }
 130 
 131     public Note(String key) {
 132         super(key, new JSONObject());
 133     }
 134 
 135     public Note(String key, JSONObject properties) {
 136         super(key, properties);
 137     }
 138 
 139     protected void updateTitleAndPreview() {
 140         // try to build a title and preview property out of content
 141         String content = getContent().trim();
 142         if (content.length() &gt; MAX_PREVIEW_CHARS) {
 143             content = content.substring(0, MAX_PREVIEW_CHARS - 1);
 144         }
 145 
 146         int firstNewLinePosition = content.indexOf(NEW_LINE);
 147         if (firstNewLinePosition &gt; -1 &amp;&amp; firstNewLinePosition &lt; 200) {
 148             mTitle = content.substring(0, firstNewLinePosition).trim();
 149 
 150             if (firstNewLinePosition &lt; content.length()) {
 151                 mContentPreview = content.substring(firstNewLinePosition, content.length());
<abbr title=" 152                 mContentPreview = mContentPreview.replace(NEW_LINE, SPACE).replace(SPACE+SPACE, SPACE).trim();"> 152                 mContentPreview = mContentPreview.replace(NEW_LINE, SPACE).replace(SPACE+SPACE, SPACE).trðŸ”µ</abbr>
 153             }
 154             else {
 155                 mContentPreview = content;
 156             }
 157         }
 158         else {
 159             mTitle = content;
 160             mContentPreview = content;
 161         }
 162     }
 163 
 164 public String getTitle() {
 165        if (mTitle == null) {
 166            updateTitleAndPreview();
 167        }
 168 	return mTitle;
 169 }
 170 
 171 public String getContent() {
 172        Object content = getProperty(CONTENT_PROPERTY);
 173        if (content == null) {
 174            return BLANK_CONTENT;
 175        }
 176        return (String) content;
 177 }
 178 
 179 public void setContent(String content) {
 180        mTitle = null;
 181        mContentPreview = null;
 182        setProperty(CONTENT_PROPERTY, content);
 183 }
 184 
 185 public String getContentPreview() {
 186        if (mContentPreview == null) {
 187            updateTitleAndPreview();
 188        }
 189 	return mContentPreview;
 190 }
 191 
 192 public Calendar getCreationDate() {
 193        return numberToDate((Number)getProperty(CREATION_DATE_PROPERTY));
 194 }
 195 
 196 public void setCreationDate(Calendar creationDate) {
 197        setProperty(CREATION_DATE_PROPERTY, creationDate.getTimeInMillis()/1000);
 198 }
 199 
 200 public Calendar getModificationDate() {
 201        return numberToDate((Number)getProperty(MODIFICATION_DATE_PROPERTY));
 202 }
 203 
 204 public void setModificationDate(Calendar modificationDate) {
 205        setProperty(MODIFICATION_DATE_PROPERTY, modificationDate.getTimeInMillis()/1000);
 206 }
 207 
 208     public String getPublishedUrl() {
 209         String urlCode = (String)getProperty(PUBLISH_URL_PROPERTY);
 210         if (TextUtils.isEmpty(urlCode)) {
 211             return &quot;&quot;;
 212         }
 213 
 214         return PUBLISH_URL + urlCode;
 215     }
 216 
 217     public boolean hasTag(String tag){
 218         List&lt;String&gt; tags = getTags();
 219         String tagLower = tag.toLowerCase();
 220         for (String tagName : tags) {
 221             if (tagLower.equals(tagName.toLowerCase())) return true;
 222         }
 223         return false;
 224     }
 225 
 226     public boolean hasTag(Tag tag){
 227         return hasTag(tag.getSimperiumKey());
 228     }
 229 
 230     public List&lt;String&gt; getTags() {
 231         JSONArray tags = ((JSONArray) (getProperty(TAGS_PROPERTY)));
 232         if (tags == null) {
 233             tags = new JSONArray();
 234             setProperty(TAGS_PROPERTY, tags);
 235         }
 236         int length = tags.length();
 237         List&lt;String&gt; tagList = new ArrayList&lt;&gt;(length);
 238         if (length == 0) {
 239             return tagList;
 240         }
 241         for (int i = 0; i &lt; length; i++) {
 242             String tag = tags.optString(i);
 243             if (!tag.equals(&quot;&quot;)) {
 244                 tagList.add(tag);
 245             }
 246         }
 247         return tagList;
 248     }
 249 
 250     public void setTags(List&lt;String&gt; tags) {
 251         setProperty(TAGS_PROPERTY, new JSONArray(tags));
 252     }
 253 
 254     /**
 255      * String of tags delimited by a space
 256      */
 257     public CharSequence getTagString(){
 258         StringBuilder tagString = new StringBuilder();
 259         List&lt;String&gt; tags = getTags();
 260         for(String tag : tags){
 261             if (tagString.length() &gt; 0) {
 262                 tagString.append(SPACE);
 263             }
 264             tagString.append(tag);
 265         }
 266         return tagString;
 267     }
 268 
 269     /**
 270      * Sets the note&#x27;s tags by providing it with a {@link String} of space
 271      * seperated tags. Filters out duplicate tags.
 272      *
 273      * @param tagString a space delimited list of tags
 274      */
 275     public void setTagString(String tagString) {
 276         List&lt;String&gt; tags = getTags();
 277         tags.clear();
 278         if (tagString == null) {
 279             setTags(tags);
 280             return;
 281         }
 282         // Make sure string has a trailing space
 283         if ((tagString.length() &gt; 1) &amp;&amp; (!tagString.substring(tagString.length() - 1).equals(SPACE))) {
 284             tagString = tagString + SPACE;
 285         }
 286         // for comparing case-insensitive strings, would like to find a way to
 287         // do this without allocating a new list and strings
 288         List&lt;String&gt; tagsUpperCase = new ArrayList&lt;&gt;();
 289         // remove all current tags
 290         int start = 0;
 291         int next = -1;
 292         String possible;
 293         String possibleUpperCase;
 294         // search tag string for space characters and pull out individual tags
 295         do {
 296             next = tagString.indexOf(SPACE, start);
 297             if (next &gt; start) {
 298                 possible = tagString.substring(start, next);
 299                 possibleUpperCase = possible.toUpperCase();
 300                 if ((!possible.equals(SPACE)) &amp;&amp; (!tagsUpperCase.contains(possibleUpperCase))) {
 301                     tagsUpperCase.add(possibleUpperCase);
 302                     tags.add(possible);
 303                 }
 304             }
 305             start = next + 1;
 306         } while (next &gt; (-1) );
 307         setTags(tags);
 308     }
 309 
 310     public JSONArray getSystemTags() {
 311         JSONArray tags = (JSONArray) getProperty(SYSTEM_TAGS_PROPERTY);
 312         if (tags == null) {
 313             tags = new JSONArray();
 314             setProperty(SYSTEM_TAGS_PROPERTY, tags);
 315         }
 316         return tags;
 317     }
 318 
 319     public Boolean isDeleted() {
 320         Object deleted = getProperty(DELETED_PROPERTY);
 321         if (deleted == null) {
 322             return false;
 323         }
 324         if (deleted instanceof Boolean) {
 325             return ((Boolean) (deleted));
 326         } else {
 327             return (deleted instanceof Number) &amp;&amp; (((Number) (deleted)).intValue() != 0);
 328         }
 329     }
 330 
 331     public void setDeleted(boolean deleted) {
 332         setProperty(DELETED_PROPERTY, deleted);
 333     }
 334 
 335     public boolean isMarkdownEnabled() {
 336         return hasSystemTag(MARKDOWN_TAG);
 337     }
 338 
 339     public void setMarkdownEnabled(boolean isMarkdownEnabled) {
 340         if (isMarkdownEnabled) {
 341             addSystemTag(MARKDOWN_TAG);
 342         } else {
 343             removeSystemTag(MARKDOWN_TAG);
 344         }
 345     }
 346 
 347     public boolean isPinned() {
 348         return hasSystemTag(PINNED_TAG);
 349     }
 350 
 351     public void setPinned(boolean isPinned) {
 352         if (isPinned) {
 353             addSystemTag(PINNED_TAG);
 354         } else {
 355             removeSystemTag(PINNED_TAG);
 356         }
 357     }
 358 
 359     public boolean isPublished() {
 360         return hasSystemTag(PUBLISHED_TAG) &amp;&amp; !TextUtils.isEmpty(getPublishedUrl());
 361     }
 362 
 363     public void setPublished(boolean isPublished) {
 364         if (isPublished) {
 365             addSystemTag(PUBLISHED_TAG);
 366         } else {
 367             removeSystemTag(PUBLISHED_TAG);
 368         }
 369     }
 370 
 371     private boolean hasSystemTag(String tag) {
 372         if (TextUtils.isEmpty(tag))
 373             return false;
 374 
 375         JSONArray tags = getSystemTags();
 376         int length = tags.length();
 377         for (int i=0; i&lt;length; i++) {
 378             if (tags.optString(i).equals(tag)) {
 379                 return true;
 380             }
 381         }
 382 
 383         return false;
 384     }
 385 
 386     private void addSystemTag(String tag) {
 387         if (TextUtils.isEmpty(tag)) {
 388             return;
 389         }
 390 
 391         // Ensure we don&#x27;t add the same tag again
 392         if (!hasSystemTag(tag)) {
 393             getSystemTags().put(tag);
 394         }
 395     }
 396 
 397     private void removeSystemTag(String tag) {
 398         if (!hasSystemTag(tag)) {
 399             return;
 400         }
 401 
 402         JSONArray tags = getSystemTags();
 403         JSONArray newTags = new JSONArray();
 404         int length = tags.length();
 405         try {
 406             for (int i = 0; i &lt; length; i++) {
 407                 Object val = tags.get(i);
 408                 if (!val.equals(tag))
 409                     newTags.put(val);
 410             }
 411         } catch (JSONException e) {
 412             // could not update pinned setting
 413         }
 414 
 415         setProperty(SYSTEM_TAGS_PROPERTY, newTags);
 416     }
 417 
 418     public static String dateString(Number time, boolean useShortFormat, Context context){
 419         Calendar c = numberToDate(time);
 420         return dateString(c, useShortFormat, context);
 421     }
 422 
 423 public static String dateString(Calendar c, boolean useShortFormat, Context context) {
 424 	int year, month, day;
 425 
 426 	String time, date, retVal;
 427 	time = date = &quot;&quot;;
 428 
 429 	Calendar diff = Calendar.getInstance();
 430 	diff.setTimeInMillis(diff.getTimeInMillis() - c.getTimeInMillis());
 431 
 432 	year = diff.get(Calendar.YEAR);
 433 	month = diff.get(Calendar.MONTH);
 434 	day = diff.get(Calendar.DAY_OF_MONTH);
 435 
 436 	diff.setTimeInMillis(0); // starting time
 437 	time = DateFormat.getTimeInstance(DateFormat.SHORT).format(c.getTime());
<abbr title=" 438 	if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(Calendar.DAY_OF_MONTH))) {"> 438 	if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(CalendaðŸ”µ</abbr>
 439 		date = context.getResources().getString(R.string.today);
 440 		if (useShortFormat)
 441 			retVal = time;
 442 		else
 443 			retVal = date + &quot;, &quot; + time;
 444 	} else if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == 1)) {
 445 		date = context.getResources().getString(R.string.yesterday);
 446 		if (useShortFormat)
 447 			retVal = date;
 448 		else
 449 			retVal = date + &quot;, &quot; + time;
 450 	} else {
 451 		date = new SimpleDateFormat(&quot;MMM dd&quot;, Locale.US).format(c.getTime());
 452 		retVal = date + &quot;, &quot; + time;
 453 	}
 454 
 455 	return retVal;
 456 }
 457 
 458     public static Calendar numberToDate(Number time){
 459         Calendar date = Calendar.getInstance();
 460         if (time != null) {
 461             // Flick Note uses millisecond resolution timestamps Simplenote expects seconds
 462             // since we only deal with create and modify timestamps, they should all have occured
 463             // at the present time or in the past.
 464             float now = date.getTimeInMillis()/1000;
 465             float magnitude = time.floatValue()/now;
 466             if (magnitude &gt;= 2.f) time = time.longValue()/1000;
 467             date.setTimeInMillis(time.longValue()*1000);
 468         }
 469         return date;
 470     }
 471 
 472     /**
 473      * Check if the note has any changes
 474      *
 475      * @param content
 476      * 		the new note content
 477      * @param tagString
 478      * 		space separated tags
 479      * @param isPinned
 480      * 		note is pinned
 481      * @return true if note has changes, false if it is unchanged.
 482      * @return true if note has changes, false if it is unchanged.
 483      */
<abbr title=" 484     public boolean hasChanges(String content, String tagString, boolean isPinned, boolean isMarkdownEnabled) {"> 484     public boolean hasChanges(String content, String tagString, boolean isPinned, boolean isMarkdownEnablðŸ”µ</abbr>
<abbr title=" 485         return (((!content.equals(this.getContent())) || (!tagString.equals(this.getTagString().toString()))) || (this.isPinned() != isPinned)) || (this.isMarkdownEnabled() != isMarkdownEnabled);"> 485         return (((!content.equals(this.getContent())) || (!tagString.equals(this.getTagString().toString(ðŸ”µ</abbr>
 486     }
 487 }
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  package com.automattic.simplenote.models;
   2  
   3  import android.content.Context;
   4  import android.text.TextUtils;
   5  
   6  import com.automattic.simplenote.R;
   7  import com.simperium.client.Bucket;
   8  import com.simperium.client.BucketObject;
   9  import com.simperium.client.BucketSchema;
  10  import com.simperium.client.Query;
  11  import com.simperium.client.Query.ComparisonType;
  12  
  13  import org.json.JSONArray;
  14  import org.json.JSONException;
  15  import org.json.JSONObject;
  16  
  17  import java.text.DateFormat;
  18  import java.text.SimpleDateFormat;
  19  import java.util.ArrayList;
  20  import java.util.Calendar;
  21  import java.util.List;
  22  import java.util.Locale;
  23  
  24  public class Note extends BucketObject {
  25  
  26  	public static final String BUCKET_NAME=&quot;note&quot;;

  27      public static final String PINNED_TAG=&quot;pinned&quot;;
  28      public static final String PUBLISHED_TAG=&quot;published&quot;;
  29      public static final String NEW_LINE=&quot;\n&quot;;
  30  
  31      private static final String BLANK_CONTENT=&quot;&quot;;
  32      private static final String SPACE = &quot; &quot;;
  33      private static final int MAX_PREVIEW_CHARS = 300;
  34  
  35      public static final String CONTENT_PROPERTY=&quot;content&quot;;
  36      public static final String TAGS_PROPERTY=&quot;tags&quot;;
  37      public static final String SYSTEM_TAGS_PROPERTY=&quot;systemTags&quot;;
  38      public static final String CREATION_DATE_PROPERTY=&quot;creationDate&quot;;
  39      public static final String MODIFICATION_DATE_PROPERTY=&quot;modificationDate&quot;;
  40      public static final String SHARE_URL_PROPERTY=&quot;shareURL&quot;;
  41      public static final String PUBLISH_URL_PROPERTY=&quot;publishURL&quot;;
  42      public static final String DELETED_PROPERTY=&quot;deleted&quot;;
  43      public static final String TITLE_INDEX_NAME=&quot;title&quot;;
  44      public static final String CONTENT_PREVIEW_INDEX_NAME=&quot;contentPreview&quot;;
  45      public static final String PINNED_INDEX_NAME=&quot;pinned&quot;;
  46      public static final String MODIFIED_INDEX_NAME=&quot;modified&quot;;
  47      public static final String CREATED_INDEX_NAME=&quot;created&quot;;
  48      public static final String MATCHED_TITLE_INDEX_NAME=&quot;matchedTitle&quot;;
  49      public static final String MATCHED_CONTENT_INDEX_NAME=&quot;matchedContent&quot;;
  50      public static final String PUBLISH_URL=&quot;http://simp.ly/publish/&quot;;
  51  
  52      static public final String[] FULL_TEXT_INDEXES = new String[]{
  53          Note.TITLE_INDEX_NAME, Note.CONTENT_PROPERTY };
  54  
  55  	protected String mTitle = null;
  56  	protected String mContentPreview = null;
  57  
  58  
  59  	public static class Schema extends BucketSchema&lt;Note&gt; {
  60  
  61          protected static NoteIndexer sNoteIndexer = new NoteIndexer();
  62          protected static NoteFullTextIndexer sFullTextIndexer = new NoteFullTextIndexer();
  63  
  64          public Schema(){
  65              autoIndex();
  66              addIndex(sNoteIndexer);
  67              setupFullTextIndex(sFullTextIndexer, NoteFullTextIndexer.INDEXES);
  68              setDefault(CONTENT_PROPERTY, &quot;&quot;);
  69              setDefault(SYSTEM_TAGS_PROPERTY, new JSONArray());
  70              setDefault(TAGS_PROPERTY, new JSONArray());
  71              setDefault(DELETED_PROPERTY, false);
  72              setDefault(SHARE_URL_PROPERTY, &quot;&quot;);
  73              setDefault(PUBLISH_URL_PROPERTY, &quot;&quot;);
  74          }
  75  
  76          public String getRemoteName(){
  77              return Note.BUCKET_NAME;
  78          }
  79  
  80          public Note build(String key, JSONObject properties) {
  81              return new Note(key, properties);
  82          }
  83  
  84          public void update(Note note, JSONObject properties) {
  85              note.setProperties(properties);
  86              note.mTitle = null;
  87              note.mContentPreview = null;
  88          }
  89  	}
  90  
  91      public static Query&lt;Note&gt; all(Bucket&lt;Note&gt; noteBucket){
  92          return noteBucket.query()
  93                  .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true);
  94      }
  95  
  96      public static Query&lt;Note&gt; allDeleted(Bucket&lt;Note&gt; noteBucket){
  97          return noteBucket.query()
  98                  .where(DELETED_PROPERTY, ComparisonType.EQUAL_TO, true);
  99      }
 100  
 101      public static Query&lt;Note&gt; search(Bucket&lt;Note&gt; noteBucket, String searchString){
 102          return noteBucket.query()
 103                  .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 104                  .where(CONTENT_PROPERTY, ComparisonType.LIKE, &quot;%&quot; + searchString + &quot;%&quot;);
 105      }
 106  
 107      public static Query&lt;Note&gt; allInTag(Bucket&lt;Note&gt; noteBucket, String tag){
 108          return noteBucket.query()
 109                  .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 110                  .where(TAGS_PROPERTY, ComparisonType.LIKE, tag);
 111      }
 112  
 113  
 114      public Note(String key) {
 115          super(key, new JSONObject());
 116      }
 117  
 118      public Note(String key, JSONObject properties) {
 119          super(key, properties);
 120      }
 121  
 122      protected void updateTitleAndPreview() {
 123          // try to build a title and preview property out of content
 124          String content = getContent().trim();
 125          if (content.length() &gt; MAX_PREVIEW_CHARS) {
 126              content = content.substring(0, MAX_PREVIEW_CHARS - 1);
 127          }
 128  
 129          int firstNewLinePosition = content.indexOf(NEW_LINE);
 130          if (firstNewLinePosition &gt; -1 &amp;&amp; firstNewLinePosition &lt; 200) {
 131              mTitle = content.substring(0, firstNewLinePosition).trim();
 132  
 133              if (firstNewLinePosition &lt; content.length()) {
 134                  mContentPreview = content.substring(firstNewLinePosition, content.length());
 135                  mContentPreview = mContentPreview.replace(NEW_LINE, SPACE).replace(SPACE+SPACE, SPACE).trim();
 136              }
 137              else {
 138                  mContentPreview = content;
 139              }
 140          }
 141          else {
 142              mTitle = content;
 143              mContentPreview = content;
 144          }
 145      }
 146  
 147  	public String getTitle() {
 148          if (mTitle == null) {
 149              updateTitleAndPreview();
 150          }
 151  		return mTitle;
 152  	}
 153  
 154  	public String getContent() {
 155          Object content = getProperty(CONTENT_PROPERTY);
 156          if (content == null) {
 157              return BLANK_CONTENT;
 158          }
 159          return (String) content;
 160  	}
 161  
 162  	public void setContent(String content) {
 163          mTitle = null;
 164          mContentPreview = null;
 165          setProperty(CONTENT_PROPERTY, content);
 166  	}
 167  
 168  	public String getContentPreview() {
 169          if (mContentPreview == null) {
 170              updateTitleAndPreview();
 171          }
 172  		return mContentPreview;
 173  	}
 174  
 175  	public Calendar getCreationDate() {
 176          return numberToDate((Number)getProperty(CREATION_DATE_PROPERTY));
 177  	}
 178  
 179  	public void setCreationDate(Calendar creationDate) {
 180          setProperty(CREATION_DATE_PROPERTY, creationDate.getTimeInMillis()/1000);
 181  	}
 182  
 183  	public Calendar getModificationDate() {
 184          return numberToDate((Number)getProperty(MODIFICATION_DATE_PROPERTY));
 185  	}
 186  
 187  	public void setModificationDate(Calendar modificationDate) {
 188          setProperty(MODIFICATION_DATE_PROPERTY, modificationDate.getTimeInMillis()/1000);
 189  	}
 190  
 191      public String getPublishedUrl() {
 192          String urlCode = (String)getProperty(PUBLISH_URL_PROPERTY);
 193          if (TextUtils.isEmpty(urlCode)) {
 194              return &quot;&quot;;
 195          }
 196  
 197          return PUBLISH_URL + urlCode;
 198      }
 199  
 200      public boolean hasTag(String tag){
 201          List&lt;String&gt; tags = getTags();
 202          String tagLower = tag.toLowerCase();
 203          for (String tagName : tags) {
 204              if (tagLower.equals(tagName.toLowerCase())) return true;
 205          }
 206          return false;
 207      }
 208  
 209      public boolean hasTag(Tag tag){
 210          return hasTag(tag.getSimperiumKey());
 211      }
 212  
 213      public List&lt;String&gt; getTags() {
 214  
 215          JSONArray tags = (JSONArray) getProperty(TAGS_PROPERTY);
 216  
 217          if (tags == null) {
 218              tags = new JSONArray();
 219              setProperty(TAGS_PROPERTY, tags);
 220          }
 221  
 222          int length = tags.length();
 223  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 224 -        List&lt;String&gt; tagList = new ArrayList&lt;String&gt;(length);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 225 +        List&lt;String&gt; tagList = new ArrayList&lt;&gt;(length);</span>
 226  
 227          if (length == 0) return tagList;
 228  
 229          for (int i=0; i&lt;length; i++) {
 230              String tag = tags.optString(i);
 231              if (!tag.equals(&quot;&quot;))
 232                  tagList.add(tag);
 233          }
 234  
 235          return tagList;
 236      }
 237  
 238      public void setTags(List&lt;String&gt; tags) {
 239          setProperty(TAGS_PROPERTY, new JSONArray(tags));
 240      }
 241  
 242      /**
 243       * String of tags delimited by a space
 244       */
 245      public CharSequence getTagString(){
 246          StringBuilder tagString = new StringBuilder();
 247          List&lt;String&gt; tags = getTags();
 248          for(String tag : tags){
 249              if (tagString.length() &gt; 0) {
 250                  tagString.append(SPACE);
 251              }
 252              tagString.append(tag);
 253          }
 254          return tagString;
 255      }
 256  
 257      /**
 258       * Sets the note&#x27;s tags by providing it with a {@link String} of space
 259       * seperated tags. Filters out duplicate tags.
 260       *
 261       * @param tagString a space delimited list of tags
 262       */
 263      public void setTagString(String tagString){
 264          List&lt;String&gt; tags = getTags();
 265          tags.clear();
 266  
 267          if (tagString == null) {
 268              setTags(tags);
 269              return;
 270          }
 271  
 272          // Make sure string has a trailing space
 273          if (tagString.length() &gt; 1 &amp;&amp; !tagString.substring(tagString.length() - 1).equals(SPACE))
 274              tagString = tagString + SPACE;
 275          // for comparing case-insensitive strings, would like to find a way to
 276          // do this without allocating a new list and strings
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 277 -        List&lt;String&gt; tagsUpperCase = new ArrayList&lt;String&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 278 +        List&lt;String&gt; tagsUpperCase = new ArrayList&lt;&gt;();</span>
 279          // remove all current tags
 280          int start = 0;
 281          int next = -1;
 282          String possible;
 283          String possibleUpperCase;
 284          // search tag string for space characters and pull out individual tags
 285          do {
 286              next = tagString.indexOf(SPACE, start);
 287              if (next &gt; start) {
 288                  possible = tagString.substring(start, next);
 289                  possibleUpperCase = possible.toUpperCase();
 290                  if (!possible.equals(SPACE) &amp;&amp; !tagsUpperCase.contains(possibleUpperCase)) {
 291                      tagsUpperCase.add(possibleUpperCase);
 292                      tags.add(possible);
 293                  }
 294              }
 295              start = next + 1;
 296          } while(next &gt; -1);
 297          setTags(tags);
 298      }
 299  
 300      public JSONArray getSystemTags() {
 301          JSONArray tags = (JSONArray) getProperty(SYSTEM_TAGS_PROPERTY);
 302          if (tags == null) {
 303              tags = new JSONArray();
 304              setProperty(SYSTEM_TAGS_PROPERTY, tags);
 305          }
 306          return tags;
 307      }
 308  
 309  	public Boolean isDeleted() {
 310          Object deleted = getProperty(DELETED_PROPERTY);
 311          if (deleted == null) {
 312              return false;
 313          }
 314          if (deleted instanceof Boolean) {
 315              return (Boolean) deleted;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 316 -        } else if (deleted instanceof Number) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 317 -            return ((Number)deleted).intValue() == 0 ? false : true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 318 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 319 -            return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 320 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 321 +        } else</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 322 +            return deleted instanceof Number &amp;&amp; ((Number) deleted).intValue() != 0;</span>
 323      }
 324  
 325      public void setDeleted(boolean deleted) {
 326          setProperty(DELETED_PROPERTY, deleted);
 327      }
 328  












 329      public boolean isPinned() {
 330          return hasSystemTag(PINNED_TAG);
 331      }
 332  
 333      public void setPinned(boolean isPinned) {
 334          if (isPinned) {
 335              addSystemTag(PINNED_TAG);
 336          } else {
 337              removeSystemTag(PINNED_TAG);
 338          }
 339      }
 340  
 341      public boolean isPublished() {
 342          return hasSystemTag(PUBLISHED_TAG) &amp;&amp; !TextUtils.isEmpty(getPublishedUrl());
 343      }
 344  
 345      public void setPublished(boolean isPublished) {
 346          if (isPublished) {
 347              addSystemTag(PUBLISHED_TAG);
 348          } else {
 349              removeSystemTag(PUBLISHED_TAG);
 350          }
 351      }
 352  
 353      private boolean hasSystemTag(String tag) {
 354          if (TextUtils.isEmpty(tag))
 355              return false;
 356  
 357          JSONArray tags = getSystemTags();
 358          int length = tags.length();
 359          for (int i=0; i&lt;length; i++) {
 360              if (tags.optString(i).equals(tag)) {
 361                  return true;
 362              }
 363          }
 364  
 365          return false;
 366      }
 367  
 368      private void addSystemTag(String tag) {
 369          if (TextUtils.isEmpty(tag)) {
 370              return;
 371          }
 372  
 373          // Ensure we don&#x27;t add the same tag again
 374          if (!hasSystemTag(tag)) {
 375              getSystemTags().put(tag);
 376          }
 377      }
 378  
 379      private void removeSystemTag(String tag) {
 380          if (!hasSystemTag(tag)) {
 381              return;
 382          }
 383  
 384          JSONArray tags = getSystemTags();
 385          JSONArray newTags = new JSONArray();
 386          int length = tags.length();
 387          try {
 388              for (int i = 0; i &lt; length; i++) {
 389                  Object val = tags.get(i);
 390                  if (!val.equals(tag))
 391                      newTags.put(val);
 392              }
 393          } catch (JSONException e) {
 394              // could not update pinned setting
 395          }
 396  
 397          setProperty(SYSTEM_TAGS_PROPERTY, newTags);
 398      }
 399  
 400      public static String dateString(Number time, boolean useShortFormat, Context context){
 401          Calendar c = numberToDate(time);
 402          return dateString(c, useShortFormat, context);
 403      }
 404  
 405  	public static String dateString(Calendar c, boolean useShortFormat, Context context) {
 406  		int year, month, day;
 407  
 408  		String time, date, retVal;
 409  		time = date = &quot;&quot;;
 410  
 411  		Calendar diff = Calendar.getInstance();
 412  		diff.setTimeInMillis(diff.getTimeInMillis() - c.getTimeInMillis());
 413  
 414  		year = diff.get(Calendar.YEAR);
 415  		month = diff.get(Calendar.MONTH);
 416  		day = diff.get(Calendar.DAY_OF_MONTH);
 417  
 418  		diff.setTimeInMillis(0); // starting time
 419  		time = DateFormat.getTimeInstance(DateFormat.SHORT).format(c.getTime());
<abbr title=" 420  		if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(Calendar.DAY_OF_MONTH))) {"> 420  		if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(Calendar.DAY_OFðŸ”µ</abbr>
 421  			date = context.getResources().getString(R.string.today);
 422  			if (useShortFormat)
 423  				retVal = time;
 424  			else
 425  				retVal = date + &quot;, &quot; + time;
 426  		} else if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == 1)) {
 427  			date = context.getResources().getString(R.string.yesterday);
 428  			if (useShortFormat)
 429  				retVal = date;
 430  			else
 431  				retVal = date + &quot;, &quot; + time;
 432  		} else {
 433  			date = new SimpleDateFormat(&quot;MMM dd&quot;, Locale.US).format(c.getTime());
 434  			retVal = date + &quot;, &quot; + time;
 435  		}
 436  
 437  		return retVal;
 438  	}
 439  
 440      public static Calendar numberToDate(Number time){
 441          Calendar date = Calendar.getInstance();
 442          if (time != null) {
 443              // Flick Note uses millisecond resolution timestamps Simplenote expects seconds
 444              // since we only deal with create and modify timestamps, they should all have occured
 445              // at the present time or in the past.
 446              float now = date.getTimeInMillis()/1000;
 447              float magnitude = time.floatValue()/now;
 448              if (magnitude &gt;= 2.f) time = time.longValue()/1000;
 449              date.setTimeInMillis(time.longValue()*1000);
 450          }
 451          return date;
 452      }
 453  
 454      /**
 455       * Check if the note has any changes
 456       * @param content the new note content
 457       * @param tagString space separated tags
 458       * @param isPinned note is pinned

 459       * @return true if note has changes, false if it is unchanged.
 460       */
 461      public boolean hasChanges(String content, String tagString, boolean isPinned) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 462 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 463 -        if (content.equals(this.getContent()) &amp;&amp; this.isPinned() == isPinned &amp;&amp; tagString.equals(this.getTagString().toString()))"> 463 -        if (content.equals(this.getContent()) &amp;&amp; this.isPinned() == isPinned &amp;&amp; tagString.equals(this.getTagStringðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 464 -            return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 465 -        else</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 466 -            return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 467 +        return !(content.equals(this.getContent()) &amp;&amp; this.isPinned() == isPinned &amp;&amp; tagString.equals(this.getTagString().toString()));"> 467 +        return !(content.equals(this.getContent()) &amp;&amp; this.isPinned() == isPinned &amp;&amp; tagString.equals(this.getTagSðŸ”µ</abbr></span>




 468      }
 469  }</pre></td>
                            <td><pre>   1  package com.automattic.simplenote.models;
   2  
   3  import android.content.Context;
   4  import android.text.TextUtils;
   5  
   6  import com.automattic.simplenote.R;
   7  import com.simperium.client.Bucket;
   8  import com.simperium.client.BucketObject;
   9  import com.simperium.client.BucketSchema;
  10  import com.simperium.client.Query;
  11  import com.simperium.client.Query.ComparisonType;
  12  
  13  import org.json.JSONArray;
  14  import org.json.JSONException;
  15  import org.json.JSONObject;
  16  
  17  import java.text.DateFormat;
  18  import java.text.SimpleDateFormat;
  19  import java.util.ArrayList;
  20  import java.util.Calendar;
  21  import java.util.List;
  22  import java.util.Locale;
  23  
  24  public class Note extends BucketObject {
  25  
  26  	public static final String BUCKET_NAME=&quot;note&quot;;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  27 +    public static final String MARKDOWN_TAG=&quot;markdown&quot;;</span>
  28      public static final String PINNED_TAG=&quot;pinned&quot;;
  29      public static final String PUBLISHED_TAG=&quot;published&quot;;
  30      public static final String NEW_LINE=&quot;\n&quot;;
  31  
  32      private static final String BLANK_CONTENT=&quot;&quot;;
  33      private static final String SPACE = &quot; &quot;;
  34      private static final int MAX_PREVIEW_CHARS = 300;
  35  
  36      public static final String CONTENT_PROPERTY=&quot;content&quot;;
  37      public static final String TAGS_PROPERTY=&quot;tags&quot;;
  38      public static final String SYSTEM_TAGS_PROPERTY=&quot;systemTags&quot;;
  39      public static final String CREATION_DATE_PROPERTY=&quot;creationDate&quot;;
  40      public static final String MODIFICATION_DATE_PROPERTY=&quot;modificationDate&quot;;
  41      public static final String SHARE_URL_PROPERTY=&quot;shareURL&quot;;
  42      public static final String PUBLISH_URL_PROPERTY=&quot;publishURL&quot;;
  43      public static final String DELETED_PROPERTY=&quot;deleted&quot;;
  44      public static final String TITLE_INDEX_NAME=&quot;title&quot;;
  45      public static final String CONTENT_PREVIEW_INDEX_NAME=&quot;contentPreview&quot;;
  46      public static final String PINNED_INDEX_NAME=&quot;pinned&quot;;
  47      public static final String MODIFIED_INDEX_NAME=&quot;modified&quot;;
  48      public static final String CREATED_INDEX_NAME=&quot;created&quot;;
  49      public static final String MATCHED_TITLE_INDEX_NAME=&quot;matchedTitle&quot;;
  50      public static final String MATCHED_CONTENT_INDEX_NAME=&quot;matchedContent&quot;;
  51      public static final String PUBLISH_URL=&quot;http://simp.ly/publish/&quot;;
  52  
  53      static public final String[] FULL_TEXT_INDEXES = new String[]{
  54          Note.TITLE_INDEX_NAME, Note.CONTENT_PROPERTY };
  55  
  56  	protected String mTitle = null;
  57  	protected String mContentPreview = null;
  58  
  59  
  60  	public static class Schema extends BucketSchema&lt;Note&gt; {
  61  
  62          protected static NoteIndexer sNoteIndexer = new NoteIndexer();
  63          protected static NoteFullTextIndexer sFullTextIndexer = new NoteFullTextIndexer();
  64  
  65          public Schema(){
  66              autoIndex();
  67              addIndex(sNoteIndexer);
  68              setupFullTextIndex(sFullTextIndexer, NoteFullTextIndexer.INDEXES);
  69              setDefault(CONTENT_PROPERTY, &quot;&quot;);
  70              setDefault(SYSTEM_TAGS_PROPERTY, new JSONArray());
  71              setDefault(TAGS_PROPERTY, new JSONArray());
  72              setDefault(DELETED_PROPERTY, false);
  73              setDefault(SHARE_URL_PROPERTY, &quot;&quot;);
  74              setDefault(PUBLISH_URL_PROPERTY, &quot;&quot;);
  75          }
  76  
  77          public String getRemoteName(){
  78              return Note.BUCKET_NAME;
  79          }
  80  
  81          public Note build(String key, JSONObject properties) {
  82              return new Note(key, properties);
  83          }
  84  
  85          public void update(Note note, JSONObject properties) {
  86              note.setProperties(properties);
  87              note.mTitle = null;
  88              note.mContentPreview = null;
  89          }
  90  	}
  91  
  92      public static Query&lt;Note&gt; all(Bucket&lt;Note&gt; noteBucket){
  93          return noteBucket.query()
  94                  .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true);
  95      }
  96  
  97      public static Query&lt;Note&gt; allDeleted(Bucket&lt;Note&gt; noteBucket){
  98          return noteBucket.query()
  99                  .where(DELETED_PROPERTY, ComparisonType.EQUAL_TO, true);
 100      }
 101  
 102      public static Query&lt;Note&gt; search(Bucket&lt;Note&gt; noteBucket, String searchString){
 103          return noteBucket.query()
 104                  .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 105                  .where(CONTENT_PROPERTY, ComparisonType.LIKE, &quot;%&quot; + searchString + &quot;%&quot;);
 106      }
 107  
 108      public static Query&lt;Note&gt; allInTag(Bucket&lt;Note&gt; noteBucket, String tag){
 109          return noteBucket.query()
 110                  .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 111                  .where(TAGS_PROPERTY, ComparisonType.LIKE, tag);
 112      }
 113  
 114  
 115      public Note(String key) {
 116          super(key, new JSONObject());
 117      }
 118  
 119      public Note(String key, JSONObject properties) {
 120          super(key, properties);
 121      }
 122  
 123      protected void updateTitleAndPreview() {
 124          // try to build a title and preview property out of content
 125          String content = getContent().trim();
 126          if (content.length() &gt; MAX_PREVIEW_CHARS) {
 127              content = content.substring(0, MAX_PREVIEW_CHARS - 1);
 128          }
 129  
 130          int firstNewLinePosition = content.indexOf(NEW_LINE);
 131          if (firstNewLinePosition &gt; -1 &amp;&amp; firstNewLinePosition &lt; 200) {
 132              mTitle = content.substring(0, firstNewLinePosition).trim();
 133  
 134              if (firstNewLinePosition &lt; content.length()) {
 135                  mContentPreview = content.substring(firstNewLinePosition, content.length());
 136                  mContentPreview = mContentPreview.replace(NEW_LINE, SPACE).replace(SPACE+SPACE, SPACE).trim();
 137              }
 138              else {
 139                  mContentPreview = content;
 140              }
 141          }
 142          else {
 143              mTitle = content;
 144              mContentPreview = content;
 145          }
 146      }
 147  
 148  	public String getTitle() {
 149          if (mTitle == null) {
 150              updateTitleAndPreview();
 151          }
 152  		return mTitle;
 153  	}
 154  
 155  	public String getContent() {
 156          Object content = getProperty(CONTENT_PROPERTY);
 157          if (content == null) {
 158              return BLANK_CONTENT;
 159          }
 160          return (String) content;
 161  	}
 162  
 163  	public void setContent(String content) {
 164          mTitle = null;
 165          mContentPreview = null;
 166          setProperty(CONTENT_PROPERTY, content);
 167  	}
 168  
 169  	public String getContentPreview() {
 170          if (mContentPreview == null) {
 171              updateTitleAndPreview();
 172          }
 173  		return mContentPreview;
 174  	}
 175  
 176  	public Calendar getCreationDate() {
 177          return numberToDate((Number)getProperty(CREATION_DATE_PROPERTY));
 178  	}
 179  
 180  	public void setCreationDate(Calendar creationDate) {
 181          setProperty(CREATION_DATE_PROPERTY, creationDate.getTimeInMillis()/1000);
 182  	}
 183  
 184  	public Calendar getModificationDate() {
 185          return numberToDate((Number)getProperty(MODIFICATION_DATE_PROPERTY));
 186  	}
 187  
 188  	public void setModificationDate(Calendar modificationDate) {
 189          setProperty(MODIFICATION_DATE_PROPERTY, modificationDate.getTimeInMillis()/1000);
 190  	}
 191  
 192      public String getPublishedUrl() {
 193          String urlCode = (String)getProperty(PUBLISH_URL_PROPERTY);
 194          if (TextUtils.isEmpty(urlCode)) {
 195              return &quot;&quot;;
 196          }
 197  
 198          return PUBLISH_URL + urlCode;
 199      }
 200  
 201      public boolean hasTag(String tag){
 202          List&lt;String&gt; tags = getTags();
 203          String tagLower = tag.toLowerCase();
 204          for (String tagName : tags) {
 205              if (tagLower.equals(tagName.toLowerCase())) return true;
 206          }
 207          return false;
 208      }
 209  
 210      public boolean hasTag(Tag tag){
 211          return hasTag(tag.getSimperiumKey());
 212      }
 213  
 214      public List&lt;String&gt; getTags() {
 215  
 216          JSONArray tags = (JSONArray) getProperty(TAGS_PROPERTY);
 217  
 218          if (tags == null) {
 219              tags = new JSONArray();
 220              setProperty(TAGS_PROPERTY, tags);
 221          }
 222  
 223          int length = tags.length();
 224  
 225          List&lt;String&gt; tagList = new ArrayList&lt;String&gt;(length);

 226  
 227          if (length == 0) return tagList;
 228  
 229          for (int i=0; i&lt;length; i++) {
 230              String tag = tags.optString(i);
 231              if (!tag.equals(&quot;&quot;))
 232                  tagList.add(tag);
 233          }
 234  
 235          return tagList;
 236      }
 237  
 238      public void setTags(List&lt;String&gt; tags) {
 239          setProperty(TAGS_PROPERTY, new JSONArray(tags));
 240      }
 241  
 242      /**
 243       * String of tags delimited by a space
 244       */
 245      public CharSequence getTagString(){
 246          StringBuilder tagString = new StringBuilder();
 247          List&lt;String&gt; tags = getTags();
 248          for(String tag : tags){
 249              if (tagString.length() &gt; 0) {
 250                  tagString.append(SPACE);
 251              }
 252              tagString.append(tag);
 253          }
 254          return tagString;
 255      }
 256  
 257      /**
 258       * Sets the note&#x27;s tags by providing it with a {@link String} of space
 259       * seperated tags. Filters out duplicate tags.
 260       *
 261       * @param tagString a space delimited list of tags
 262       */
 263      public void setTagString(String tagString){
 264          List&lt;String&gt; tags = getTags();
 265          tags.clear();
 266  
 267          if (tagString == null) {
 268              setTags(tags);
 269              return;
 270          }
 271  
 272          // Make sure string has a trailing space
 273          if (tagString.length() &gt; 1 &amp;&amp; !tagString.substring(tagString.length() - 1).equals(SPACE))
 274              tagString = tagString + SPACE;
 275          // for comparing case-insensitive strings, would like to find a way to
 276          // do this without allocating a new list and strings
 277          List&lt;String&gt; tagsUpperCase = new ArrayList&lt;String&gt;();

 278          // remove all current tags
 279          int start = 0;
 280          int next = -1;
 281          String possible;
 282          String possibleUpperCase;
 283          // search tag string for space characters and pull out individual tags
 284          do {
 285              next = tagString.indexOf(SPACE, start);
 286              if (next &gt; start) {
 287                  possible = tagString.substring(start, next);
 288                  possibleUpperCase = possible.toUpperCase();
 289                  if (!possible.equals(SPACE) &amp;&amp; !tagsUpperCase.contains(possibleUpperCase)) {
 290                      tagsUpperCase.add(possibleUpperCase);
 291                      tags.add(possible);
 292                  }
 293              }
 294              start = next + 1;
 295          } while(next &gt; -1);
 296          setTags(tags);
 297      }
 298  
 299      public JSONArray getSystemTags() {
 300          JSONArray tags = (JSONArray) getProperty(SYSTEM_TAGS_PROPERTY);
 301          if (tags == null) {
 302              tags = new JSONArray();
 303              setProperty(SYSTEM_TAGS_PROPERTY, tags);
 304          }
 305          return tags;
 306      }
 307  
 308  	public Boolean isDeleted() {
 309          Object deleted = getProperty(DELETED_PROPERTY);
 310          if (deleted == null) {
 311              return false;
 312          }
 313          if (deleted instanceof Boolean) {
 314              return (Boolean) deleted;
 315          } else if (deleted instanceof Number) {
 316              return ((Number)deleted).intValue() == 0 ? false : true;
 317          } else {
 318              return false;
 319          }


 320      }
 321  
 322      public void setDeleted(boolean deleted) {
 323          setProperty(DELETED_PROPERTY, deleted);
 324      }
 325  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 326 +    public boolean isMarkdownEnabled() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 327 +        return hasSystemTag(MARKDOWN_TAG);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 328 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 329 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 330 +    public void setMarkdownEnabled(boolean isMarkdownEnabled) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 331 +        if (isMarkdownEnabled) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 332 +            addSystemTag(MARKDOWN_TAG);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 333 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 334 +            removeSystemTag(MARKDOWN_TAG);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 335 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 336 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 337 +</span>
 338      public boolean isPinned() {
 339          return hasSystemTag(PINNED_TAG);
 340      }
 341  
 342      public void setPinned(boolean isPinned) {
 343          if (isPinned) {
 344              addSystemTag(PINNED_TAG);
 345          } else {
 346              removeSystemTag(PINNED_TAG);
 347          }
 348      }
 349  
 350      public boolean isPublished() {
 351          return hasSystemTag(PUBLISHED_TAG) &amp;&amp; !TextUtils.isEmpty(getPublishedUrl());
 352      }
 353  
 354      public void setPublished(boolean isPublished) {
 355          if (isPublished) {
 356              addSystemTag(PUBLISHED_TAG);
 357          } else {
 358              removeSystemTag(PUBLISHED_TAG);
 359          }
 360      }
 361  
 362      private boolean hasSystemTag(String tag) {
 363          if (TextUtils.isEmpty(tag))
 364              return false;
 365  
 366          JSONArray tags = getSystemTags();
 367          int length = tags.length();
 368          for (int i=0; i&lt;length; i++) {
 369              if (tags.optString(i).equals(tag)) {
 370                  return true;
 371              }
 372          }
 373  
 374          return false;
 375      }
 376  
 377      private void addSystemTag(String tag) {
 378          if (TextUtils.isEmpty(tag)) {
 379              return;
 380          }
 381  
 382          // Ensure we don&#x27;t add the same tag again
 383          if (!hasSystemTag(tag)) {
 384              getSystemTags().put(tag);
 385          }
 386      }
 387  
 388      private void removeSystemTag(String tag) {
 389          if (!hasSystemTag(tag)) {
 390              return;
 391          }
 392  
 393          JSONArray tags = getSystemTags();
 394          JSONArray newTags = new JSONArray();
 395          int length = tags.length();
 396          try {
 397              for (int i = 0; i &lt; length; i++) {
 398                  Object val = tags.get(i);
 399                  if (!val.equals(tag))
 400                      newTags.put(val);
 401              }
 402          } catch (JSONException e) {
 403              // could not update pinned setting
 404          }
 405  
 406          setProperty(SYSTEM_TAGS_PROPERTY, newTags);
 407      }
 408  
 409      public static String dateString(Number time, boolean useShortFormat, Context context){
 410          Calendar c = numberToDate(time);
 411          return dateString(c, useShortFormat, context);
 412      }
 413  
 414  	public static String dateString(Calendar c, boolean useShortFormat, Context context) {
 415  		int year, month, day;
 416  
 417  		String time, date, retVal;
 418  		time = date = &quot;&quot;;
 419  
 420  		Calendar diff = Calendar.getInstance();
 421  		diff.setTimeInMillis(diff.getTimeInMillis() - c.getTimeInMillis());
 422  
 423  		year = diff.get(Calendar.YEAR);
 424  		month = diff.get(Calendar.MONTH);
 425  		day = diff.get(Calendar.DAY_OF_MONTH);
 426  
 427  		diff.setTimeInMillis(0); // starting time
 428  		time = DateFormat.getTimeInstance(DateFormat.SHORT).format(c.getTime());
<abbr title=" 429  		if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(Calendar.DAY_OF_MONTH))) {"> 429  		if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(Calendar.DAY_OFðŸ”µ</abbr>
 430  			date = context.getResources().getString(R.string.today);
 431  			if (useShortFormat)
 432  				retVal = time;
 433  			else
 434  				retVal = date + &quot;, &quot; + time;
 435  		} else if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == 1)) {
 436  			date = context.getResources().getString(R.string.yesterday);
 437  			if (useShortFormat)
 438  				retVal = date;
 439  			else
 440  				retVal = date + &quot;, &quot; + time;
 441  		} else {
 442  			date = new SimpleDateFormat(&quot;MMM dd&quot;, Locale.US).format(c.getTime());
 443  			retVal = date + &quot;, &quot; + time;
 444  		}
 445  
 446  		return retVal;
 447  	}
 448  
 449      public static Calendar numberToDate(Number time){
 450          Calendar date = Calendar.getInstance();
 451          if (time != null) {
 452              // Flick Note uses millisecond resolution timestamps Simplenote expects seconds
 453              // since we only deal with create and modify timestamps, they should all have occured
 454              // at the present time or in the past.
 455              float now = date.getTimeInMillis()/1000;
 456              float magnitude = time.floatValue()/now;
 457              if (magnitude &gt;= 2.f) time = time.longValue()/1000;
 458              date.setTimeInMillis(time.longValue()*1000);
 459          }
 460          return date;
 461      }
 462  
 463      /**
 464       * Check if the note has any changes
 465       * @param content the new note content
 466       * @param tagString space separated tags
 467       * @param isPinned note is pinned
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 468 +     * @param isMarkdownEnabled note has markdown enabled</span>
 469       * @return true if note has changes, false if it is unchanged.
 470       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 471 -    public boolean hasChanges(String content, String tagString, boolean isPinned) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 472 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 473 -        if (content.equals(this.getContent()) &amp;&amp; this.isPinned() == isPinned &amp;&amp; tagString.equals(this.getTagString().toString()))"> 473 -        if (content.equals(this.getContent()) &amp;&amp; this.isPinned() == isPinned &amp;&amp; tagString.equals(this.getTagStringðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 474 -            return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 475 -        else</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 476 -            return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 477 +    public boolean hasChanges(String content, String tagString, boolean isPinned, boolean isMarkdownEnabled) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 478 +        return !content.equals(this.getContent())</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 479 +            || !tagString.equals(this.getTagString().toString())</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 480 +            || this.isPinned() != isPinned</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 481 +            || this.isMarkdownEnabled() != isMarkdownEnabled;</span>
 482      }
 483  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            