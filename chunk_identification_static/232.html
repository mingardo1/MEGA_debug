<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>232</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    232
                    <a href="231.html">prev</a>
                    <a href="233.html">next</a>
                    <a href="232_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_e3fe3f89ee956e8d7995c569948cb70765ec19b8_src/com/android/launcher3/LauncherBackupHelper.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;e3fe3f89ee956e8d7995c569948cb70765ec19b8:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;e3fe3f89ee956e8d7995c569948cb70765ec19b8^1:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;e3fe3f89ee956e8d7995c569948cb70765ec19b8^2:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;3fec14bedc03d77aa7a066a8053c6068dddda192:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [j]], subset: [[b], [j]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.app.backup.BackupDataInputStream;
  19 import android.app.backup.BackupDataOutput;
  20 import android.app.backup.BackupHelper;
  21 import android.app.backup.BackupManager;
  22 import android.content.ComponentName;
  23 import android.content.ContentResolver;
  24 import android.content.ContentValues;
  25 import android.content.Context;
  26 import android.content.Intent;
  27 import android.content.pm.ActivityInfo;
  28 import android.content.pm.PackageManager;
  29 import android.content.pm.PackageManager.NameNotFoundException;
  30 import android.content.pm.ResolveInfo;
  31 import android.content.res.XmlResourceParser;
  32 import android.database.Cursor;
  33 import android.graphics.Bitmap;
  34 import android.graphics.BitmapFactory;
  35 import android.graphics.drawable.Drawable;
  36 import android.os.ParcelFileDescriptor;
  37 import android.text.TextUtils;
  38 import android.util.Base64;
  39 import android.util.Log;
  40 
  41 import com.android.launcher3.LauncherSettings.Favorites;
  42 import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  43 import com.android.launcher3.backup.BackupProtos;
  44 import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  45 import com.android.launcher3.backup.BackupProtos.DeviceProfieData;
  46 import com.android.launcher3.backup.BackupProtos.Favorite;
  47 import com.android.launcher3.backup.BackupProtos.Journal;
  48 import com.android.launcher3.backup.BackupProtos.Key;
  49 import com.android.launcher3.backup.BackupProtos.Resource;
  50 import com.android.launcher3.backup.BackupProtos.Screen;
  51 import com.android.launcher3.backup.BackupProtos.Widget;
  52 import com.android.launcher3.compat.UserHandleCompat;
  53 import com.android.launcher3.compat.UserManagerCompat;
  54 import com.android.launcher3.util.Thunk;
  55 import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  56 import com.google.protobuf.nano.MessageNano;
  57 
  58 import org.xmlpull.v1.XmlPullParser;
  59 import org.xmlpull.v1.XmlPullParserException;
  60 
  61 import java.io.FileInputStream;
  62 import java.io.FileOutputStream;
  63 import java.io.IOException;
  64 import java.net.URISyntaxException;
  65 import java.util.ArrayList;
  66 import java.util.Arrays;
  67 import java.util.HashSet;
  68 import java.util.zip.CRC32;
  69 
  70 /**
  71  * Persist the launcher home state across calamities.
  72  */
  73 public class LauncherBackupHelper implements BackupHelper {
  74     private static final String TAG = &quot;LauncherBackupHelper&quot;;
  75     private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  76     private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  77 
  78     private static final int BACKUP_VERSION = 3;
  79     private static final int MAX_JOURNAL_SIZE = 1000000;
  80 
  81     // Journal key is such that it is always smaller than any dynamically generated
  82     // key (any Base64 encoded string).
  83     private static final String JOURNAL_KEY = &quot;#&quot;;
  84 
  85     /** icons are large, dribble them out */
  86     private static final int MAX_ICONS_PER_PASS = 10;
  87 
  88     /** widgets contain previews, which are very large, dribble them out */
  89     private static final int MAX_WIDGETS_PER_PASS = 5;
  90 
  91     private static final String[] FAVORITE_PROJECTION = {
  92         Favorites._ID,                     // 0
  93         Favorites.MODIFIED,                // 1
  94         Favorites.INTENT,                  // 2
  95         Favorites.APPWIDGET_PROVIDER,      // 3
  96         Favorites.APPWIDGET_ID,            // 4
  97         Favorites.CELLX,                   // 5
  98         Favorites.CELLY,                   // 6
  99         Favorites.CONTAINER,               // 7
 100         Favorites.ICON,                    // 8
 101         Favorites.ICON_PACKAGE,            // 9
 102         Favorites.ICON_RESOURCE,           // 10
 103         Favorites.ICON_TYPE,               // 11
 104         Favorites.ITEM_TYPE,               // 12
 105         Favorites.SCREEN,                  // 13
 106         Favorites.SPANX,                   // 14
 107         Favorites.SPANY,                   // 15
 108         Favorites.TITLE,                   // 16
 109         Favorites.PROFILE_ID,              // 17
 110     };
 111 
 112     private static final int ID_INDEX = 0;
 113     private static final int ID_MODIFIED = 1;
 114     private static final int INTENT_INDEX = 2;
 115     private static final int APPWIDGET_PROVIDER_INDEX = 3;
 116     private static final int APPWIDGET_ID_INDEX = 4;
 117     private static final int CELLX_INDEX = 5;
 118     private static final int CELLY_INDEX = 6;
 119     private static final int CONTAINER_INDEX = 7;
 120     private static final int ICON_INDEX = 8;
 121     private static final int ICON_PACKAGE_INDEX = 9;
 122     private static final int ICON_RESOURCE_INDEX = 10;
 123     private static final int ICON_TYPE_INDEX = 11;
 124     private static final int ITEM_TYPE_INDEX = 12;
 125     private static final int SCREEN_INDEX = 13;
 126     private static final int SPANX_INDEX = 14;
 127     private static final int SPANY_INDEX = 15;
 128     private static final int TITLE_INDEX = 16;
 129 
 130     private static final String[] SCREEN_PROJECTION = {
 131         WorkspaceScreens._ID,              // 0
 132         WorkspaceScreens.MODIFIED,         // 1
 133         WorkspaceScreens.SCREEN_RANK       // 2
 134     };
 135 
 136     private static final int SCREEN_RANK_INDEX = 2;
 137 
 138     @Thunk final Context mContext;
 139     private final HashSet&lt;String&gt; mExistingKeys;
 140     private final ArrayList&lt;Key&gt; mKeys;
 141     private final ItemTypeMatcher[] mItemTypeMatchers;
 142     private final long mUserSerial;
 143 
 144     private BackupManager mBackupManager;
 145     private byte[] mBuffer = new byte[512];
 146     private long mLastBackupRestoreTime;
 147     private boolean mBackupDataWasUpdated;
 148 
 149     private IconCache mIconCache;
 150     private DeviceProfieData mDeviceProfileData;
 151     private InvariantDeviceProfile mIdp;
 152 
 153     boolean restoreSuccessful;
 154     int restoredBackupVersion = 1;
 155 
 156     public LauncherBackupHelper(Context context) {
 157         mContext = context;
 158         mExistingKeys = new HashSet&lt;String&gt;();
 159         mKeys = new ArrayList&lt;Key&gt;();
 160         restoreSuccessful = true;
 161         mItemTypeMatchers = new ItemTypeMatcher[CommonAppTypeParser.SUPPORTED_TYPE_COUNT];
 162 
 163         UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 164         mUserSerial = userManager.getSerialNumberForUser(UserHandleCompat.myUserHandle());
 165     }
 166 
 167     private void dataChanged() {
 168         if (mBackupManager == null) {
 169             mBackupManager = new BackupManager(mContext);
 170         }
 171         mBackupManager.dataChanged();
 172     }
 173 
 174     private void applyJournal(Journal journal) {
 175         mLastBackupRestoreTime = journal.t;
 176         mExistingKeys.clear();
 177         if (journal.key != null) {
 178             for (Key key : journal.key) {
 179                 mExistingKeys.add(keyToBackupKey(key));
 180             }
 181         }
 182         restoredBackupVersion = journal.backupVersion;
 183     }
 184 
 185     /**
 186      * Back up launcher data so we can restore the user&#x27;s state on a new device.
 187      *
 188      * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 189      *
 190      * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 191      *
 192      * @param oldState notes from the last backup
 193      * @param data incremental key/value pairs to persist off-device
 194      * @param newState notes for the next backup
 195      */
 196     @Override
 197     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 198             ParcelFileDescriptor newState) {
 199         if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 200 
 201         Journal in = readJournal(oldState);
 202         if (!launcherIsReady()) {
 203             dataChanged();
 204             // Perform backup later.
 205             writeJournal(newState, in);
 206             return;
 207         }
 208 
 209         if (mDeviceProfileData == null) {
 210             LauncherAppState app = LauncherAppState.getInstance();
 211             mIdp = app.getInvariantDeviceProfile();
 212             mDeviceProfileData = initDeviceProfileData(mIdp);
 213             mIconCache = app.getIconCache();
 214         }
 215 
 216         Log.v(TAG, &quot;lastBackupTime = &quot; + in.t);
 217         mKeys.clear();
 218         applyJournal(in);
 219 
 220         // Record the time before performing backup so that entries edited while the backup
 221         // was going on, do not get missed in next backup.
 222         long newBackupTime = System.currentTimeMillis();
 223         mBackupDataWasUpdated = false;
 224         try {
 225             backupFavorites(data);
 226             backupScreens(data);
 227             backupIcons(data);
 228             backupWidgets(data);
 229 
 230             // Delete any key which still exist in the old backup, but is not valid anymore.
 231             HashSet&lt;String&gt; validKeys = new HashSet&lt;String&gt;();
 232             for (Key key : mKeys) {
 233                 validKeys.add(keyToBackupKey(key));
 234             }
 235             mExistingKeys.removeAll(validKeys);
 236 
 237             // Delete anything left in the existing keys.
 238             for (String deleted: mExistingKeys) {
 239                 if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
 240                 data.writeEntityHeader(deleted, -1);
 241                 mBackupDataWasUpdated = true;
 242             }
 243 
 244             mExistingKeys.clear();
 245             if (!mBackupDataWasUpdated) {
 246                 // Check if any metadata has changed
 247                 mBackupDataWasUpdated = (in.profile == null)
 248                         || !Arrays.equals(DeviceProfieData.toByteArray(in.profile),
 249                             DeviceProfieData.toByteArray(mDeviceProfileData))
 250                         || (in.backupVersion != BACKUP_VERSION)
 251                         || (in.appVersion != getAppVersion());
 252             }
 253 
 254             if (mBackupDataWasUpdated) {
 255                 mLastBackupRestoreTime = newBackupTime;
 256 
 257                 // We store the journal at two places.
 258                 //   1) Storing it in newState allows us to do partial backups by comparing old state
 259                 //   2) Storing it in backup data allows us to validate keys during restore
 260                 Journal state = getCurrentStateJournal();
 261                 writeRowToBackup(JOURNAL_KEY, state, data);
 262             } else {
 263                 if (DEBUG) Log.d(TAG, &quot;Nothing was written during backup&quot;);
 264             }
 265         } catch (IOException e) {
 266             Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 267         }
 268 
 269         writeNewStateDescription(newState);
 270     }
 271 
 272     /**
 273      * @return true if the backup corresponding to oldstate can be successfully applied
 274      * to this device.
 275      */
 276     private boolean isBackupCompatible(Journal oldState) {
 277         DeviceProfieData currentProfile = mDeviceProfileData;
 278         DeviceProfieData oldProfile = oldState.profile;
 279 
 280         if (oldProfile == null || oldProfile.desktopCols == 0) {
 281             // Profile info is not valid, ignore the check.
 282             return true;
 283         }
 284 
 285         boolean isHotsetCompatible = false;
 286         if (currentProfile.allappsRank &gt;= oldProfile.hotseatCount) {
 287             isHotsetCompatible = true;
 288         }
 289         if ((currentProfile.hotseatCount &gt;= oldProfile.hotseatCount) &amp;&amp;
 290                 (currentProfile.allappsRank == oldProfile.allappsRank)) {
 291             isHotsetCompatible = true;
 292         }
 293 
 294         return isHotsetCompatible &amp;&amp; (currentProfile.desktopCols &gt;= oldProfile.desktopCols)
 295                 &amp;&amp; (currentProfile.desktopRows &gt;= oldProfile.desktopRows);
 296     }
 297 
 298     /**
 299      * Restore launcher configuration from the restored data stream.
 300      * It assumes that the keys will arrive in lexical order. So if the journal was present in the
 301      * backup, it should arrive first.
 302      *
 303      * @param data the key/value pair from the server
 304      */
 305     @Override
 306     public void restoreEntity(BackupDataInputStream data) {
 307         if (!restoreSuccessful) {
 308             return;
 309         }
 310 
 311         if (mDeviceProfileData == null) {
 312             // This call does not happen on a looper thread. So LauncherAppState
 313             // can&#x27;t be created . Instead initialize required dependencies directly.
 314             mIdp = new InvariantDeviceProfile(mContext);
 315             mDeviceProfileData = initDeviceProfileData(mIdp);
 316             mIconCache = new IconCache(mContext, mIdp);
 317         }
 318 
 319         int dataSize = data.size();
 320         if (mBuffer.length &lt; dataSize) {
 321             mBuffer = new byte[dataSize];
 322         }
 323         try {
 324             int bytesRead = data.read(mBuffer, 0, dataSize);
 325             if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 326             String backupKey = data.getKey();
 327 
 328             if (JOURNAL_KEY.equals(backupKey)) {
 329                 if (VERBOSE) Log.v(TAG, &quot;Journal entry restored&quot;);
 330                 if (!mKeys.isEmpty()) {
 331                     // We received the journal key after a restore key.
 332                     Log.wtf(TAG, keyToBackupKey(mKeys.get(0)) + &quot; received after &quot; + JOURNAL_KEY);
 333                     restoreSuccessful = false;
 334                     return;
 335                 }
 336 
 337                 Journal journal = new Journal();
 338                 MessageNano.mergeFrom(journal, readCheckedBytes(mBuffer, dataSize));
 339                 applyJournal(journal);
 340                 restoreSuccessful = isBackupCompatible(journal);
 341                 return;
 342             }
 343 
 344             if (!mExistingKeys.isEmpty() &amp;&amp; !mExistingKeys.contains(backupKey)) {
 345                 if (DEBUG) Log.e(TAG, &quot;Ignoring key not present in the backup state &quot; + backupKey);
 346                 return;
 347             }
 348             Key key = backupKeyToKey(backupKey);
 349             mKeys.add(key);
 350             switch (key.type) {
 351                 case Key.FAVORITE:
 352                     restoreFavorite(key, mBuffer, dataSize);
 353                     break;
 354 
 355                 case Key.SCREEN:
 356                     restoreScreen(key, mBuffer, dataSize);
 357                     break;
 358 
 359                 case Key.ICON:
 360                     restoreIcon(key, mBuffer, dataSize);
 361                     break;
 362 
 363                 case Key.WIDGET:
 364                     restoreWidget(key, mBuffer, dataSize);
 365                     break;
 366 
 367                 default:
 368                     Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 369                     mKeys.remove(key);
 370                     break;
 371             }
 372         } catch (IOException e) {
 373             Log.w(TAG, &quot;ignoring unparsable backup entry&quot;, e);
 374         }
 375     }
 376 
 377     /**
 378      * Record the restore state for the next backup.
 379      *
 380      * @param newState notes about the backup state after restore.
 381      */
 382     @Override
 383     public void writeNewStateDescription(ParcelFileDescriptor newState) {
 384         writeJournal(newState, getCurrentStateJournal());
 385     }
 386 
 387     private Journal getCurrentStateJournal() {
 388         Journal journal = new Journal();
 389         journal.t = mLastBackupRestoreTime;
 390         journal.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);
 391         journal.appVersion = getAppVersion();
 392         journal.backupVersion = BACKUP_VERSION;
 393         journal.profile = mDeviceProfileData;
 394         return journal;
 395     }
 396 
 397     private int getAppVersion() {
 398         try {
 399             return mContext.getPackageManager()
 400                     .getPackageInfo(mContext.getPackageName(), 0).versionCode;
 401         } catch (NameNotFoundException e) {
 402             return 0;
 403         }
 404     }
 405 
 406     private DeviceProfieData initDeviceProfileData(InvariantDeviceProfile profile) {
 407         DeviceProfieData data = new DeviceProfieData();
 408         data.desktopRows = profile.numRows;
 409         data.desktopCols = profile.numColumns;
 410         data.hotseatCount = profile.numHotseatIcons;
 411         data.allappsRank = profile.hotseatAllAppsRank;
 412         return data;
 413     }
 414 
 415     /**
 416      * Write all modified favorites to the data stream.
 417      *
 418      * @param data output stream for key/value pairs
 419      * @throws IOException
 420      */
 421     private void backupFavorites(BackupDataOutput data) throws IOException {
 422         // persist things that have changed since the last backup
 423         ContentResolver cr = mContext.getContentResolver();
 424         // Don&#x27;t backup apps in other profiles for now.
 425         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 426                 getUserSelectionArg(), null, null);
 427         try {
 428             cursor.moveToPosition(-1);
 429             while(cursor.moveToNext()) {
 430                 final long id = cursor.getLong(ID_INDEX);
 431                 final long updateTime = cursor.getLong(ID_MODIFIED);
 432                 Key key = getKey(Key.FAVORITE, id);
 433                 mKeys.add(key);
 434                 final String backupKey = keyToBackupKey(key);
 435                 if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 436                     writeRowToBackup(key, packFavorite(cursor), data);
 437                 } else {
 438                     if (DEBUG) Log.d(TAG, &quot;favorite already backup up: &quot; + id);
 439                 }
 440             }
 441         } finally {
 442             cursor.close();
 443         }
 444     }
 445 
 446     /**
 447      * Read a favorite from the stream.
 448      *
 449      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 450      *
 451      * @param key identifier for the row
 452      * @param buffer the serialized proto from the stream, may be larger than dataSize
 453      * @param dataSize the size of the proto from the stream
 454      */
 455     private void restoreFavorite(Key key, byte[] buffer, int dataSize) throws IOException {
 456         if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 457         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 458                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 459 
 460         ContentResolver cr = mContext.getContentResolver();
 461         ContentValues values = unpackFavorite(buffer, dataSize);
 462         cr.insert(Favorites.CONTENT_URI, values);
 463     }
 464 
 465     /**
 466      * Write all modified screens to the data stream.
 467      *
 468      * @param data output stream for key/value pairs
 469      * @throws IOException
 470      */
 471     private void backupScreens(BackupDataOutput data) throws IOException {
 472         // persist things that have changed since the last backup
 473         ContentResolver cr = mContext.getContentResolver();
 474         Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 475                 null, null, null);
 476         try {
 477             cursor.moveToPosition(-1);
 478             if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + mLastBackupRestoreTime);
 479             while(cursor.moveToNext()) {
 480                 final long id = cursor.getLong(ID_INDEX);
 481                 final long updateTime = cursor.getLong(ID_MODIFIED);
 482                 Key key = getKey(Key.SCREEN, id);
 483                 mKeys.add(key);
 484                 final String backupKey = keyToBackupKey(key);
 485                 if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 486                     writeRowToBackup(key, packScreen(cursor), data);
 487                 } else {
 488                     if (VERBOSE) Log.v(TAG, &quot;screen already backup up &quot; + id);
 489                 }
 490             }
 491         } finally {
 492             cursor.close();
 493         }
 494     }
 495 
 496     /**
 497      * Read a screen from the stream.
 498      *
 499      * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 500      *
 501      * @param key identifier for the row
 502      * @param buffer the serialized proto from the stream, may be larger than dataSize
 503      * @param dataSize the size of the proto from the stream
 504      */
 505     private void restoreScreen(Key key, byte[] buffer, int dataSize) throws IOException {
 506         if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 507         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 508                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 509 
 510         ContentResolver cr = mContext.getContentResolver();
 511         ContentValues values = unpackScreen(buffer, dataSize);
 512         cr.insert(WorkspaceScreens.CONTENT_URI, values);
 513     }
 514 
 515     /**
 516      * Write all the static icon resources we need to render placeholders
 517      * for a package that is not installed.
 518      *
 519      * @param data output stream for key/value pairs
 520      */
 521     private void backupIcons(BackupDataOutput data) throws IOException {
 522         // persist icons that haven&#x27;t been persisted yet
 523         final ContentResolver cr = mContext.getContentResolver();
 524         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 525         final UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 526         int backupUpIconCount = 0;
 527 
 528         // Don&#x27;t backup apps in other profiles for now.
 529         String where = &quot;(&quot; + Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION + &quot; OR &quot; +
 530                 Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_SHORTCUT + &quot;) AND &quot; +
 531                 getUserSelectionArg();
 532         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 533                 where, null, null);
 534         try {
 535             cursor.moveToPosition(-1);
 536             while(cursor.moveToNext()) {
 537                 final long id = cursor.getLong(ID_INDEX);
 538                 final String intentDescription = cursor.getString(INTENT_INDEX);
 539                 try {
 540                     Intent intent = Intent.parseUri(intentDescription, 0);
 541                     ComponentName cn = intent.getComponent();
 542                     Key key = null;
 543                     String backupKey = null;
 544                     if (cn != null) {
 545                         key = getKey(Key.ICON, cn.flattenToShortString());
 546                         backupKey = keyToBackupKey(key);
 547                     } else {
 548                         Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 549                     }
 550                     if (mExistingKeys.contains(backupKey)) {
 551                         if (DEBUG) Log.d(TAG, &quot;already saved icon &quot; + backupKey);
 552 
 553                         // remember that we already backed this up previously
 554                         mKeys.add(key);
 555                     } else if (backupKey != null) {
 556                         if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + backupUpIconCount);
 557                         if (backupUpIconCount &lt; MAX_ICONS_PER_PASS) {
 558                             if (DEBUG) Log.d(TAG, &quot;saving icon &quot; + backupKey);
 559                             Bitmap icon = mIconCache.getIcon(intent, myUserHandle);
 560                             if (icon != null &amp;&amp; !mIconCache.isDefaultIcon(icon, myUserHandle)) {
 561                                 writeRowToBackup(key, packIcon(dpi, icon), data);
 562                                 mKeys.add(key);
 563                                 backupUpIconCount ++;
 564                             }
 565                         } else {
 566                             if (VERBOSE) Log.v(TAG, &quot;deferring icon backup &quot; + backupKey);
 567                             // too many icons for this pass, request another.
 568                             dataChanged();
 569                         }
 570                     }
 571                 } catch (URISyntaxException e) {
 572                     Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 573                 } catch (IOException e) {
 574                     Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 575                 }
 576 
 577             }
 578         } finally {
 579             cursor.close();
 580         }
 581     }
 582 
 583     /**
 584      * Read an icon from the stream.
 585      *
 586      * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 587      *
 588      * @param key identifier for the row
 589      * @param buffer the serialized proto from the stream, may be larger than dataSize
 590      * @param dataSize the size of the proto from the stream
 591      */
 592     private void restoreIcon(Key key, byte[] buffer, int dataSize) throws IOException {
 593         if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 594         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 595                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 596 
 597         Resource res = unpackProto(new Resource(), buffer, dataSize);
 598         if (DEBUG) {
 599             Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 600         }
 601         Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 602         if (icon == null) {
 603             Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 604         }
 605         if (VERBOSE) Log.v(TAG, &quot;saving restored icon as: &quot; + key.name);
 606         mIconCache.preloadIcon(ComponentName.unflattenFromString(key.name), icon, res.dpi,
 607                 &quot;&quot; /* label */, mUserSerial);
 608     }
 609 
 610     /**
 611      * Write all the static widget resources we need to render placeholders
 612      * for a package that is not installed.
 613      *
 614      * @param data output stream for key/value pairs
 615      * @throws IOException
 616      */
 617     private void backupWidgets(BackupDataOutput data) throws IOException {
 618         // persist static widget info that hasn&#x27;t been persisted yet
 619         final ContentResolver cr = mContext.getContentResolver();
 620         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 621         int backupWidgetCount = 0;
 622 
 623         String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET + &quot; AND &quot;
 624                 + getUserSelectionArg();
 625         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 626                 where, null, null);
 627         try {
 628             cursor.moveToPosition(-1);
 629             while(cursor.moveToNext()) {
 630                 final long id = cursor.getLong(ID_INDEX);
 631                 final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 632                 final ComponentName provider = ComponentName.unflattenFromString(providerName);
 633                 Key key = null;
 634                 String backupKey = null;
 635                 if (provider != null) {
 636                     key = getKey(Key.WIDGET, providerName);
 637                     backupKey = keyToBackupKey(key);
 638                 } else {
 639                     Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 640                 }
 641                 if (mExistingKeys.contains(backupKey) &amp;&amp; restoredBackupVersion &gt;= BACKUP_VERSION) {
 642                     if (DEBUG) Log.d(TAG, &quot;already saved widget &quot; + backupKey);
 643 
 644                     // remember that we already backed this up previously
 645                     mKeys.add(key);
 646                 } else if (backupKey != null) {
 647                     if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + backupWidgetCount);
 648                     if (backupWidgetCount &lt; MAX_WIDGETS_PER_PASS) {
 649                         if (DEBUG) Log.d(TAG, &quot;saving widget &quot; + backupKey);
 650                         UserHandleCompat user = UserHandleCompat.myUserHandle();
 651                         writeRowToBackup(key, packWidget(dpi, provider, user), data);
 652                         mKeys.add(key);
 653                         backupWidgetCount ++;
 654                     } else {
 655                         if (VERBOSE) Log.v(TAG, &quot;deferring widget backup &quot; + backupKey);
 656                         // too many widgets for this pass, request another.
 657                         dataChanged();
 658                     }
 659                 }
 660             }
 661         } finally {
 662             cursor.close();
 663         }
 664     }
 665 
 666     /**
 667      * Read a widget from the stream.
 668      *
 669      * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 670      *
 671      * @param key identifier for the row
 672      * @param buffer the serialized proto from the stream, may be larger than dataSize
 673      * @param dataSize the size of the proto from the stream
 674      */
 675     private void restoreWidget(Key key, byte[] buffer, int dataSize) throws IOException {
 676         if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 677         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 678                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 679         Widget widget = unpackProto(new Widget(), buffer, dataSize);
 680         if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 681         if (widget.icon.data != null)  {
 682             Bitmap icon = BitmapFactory
 683                     .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 684             if (icon == null) {
 685                 Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 686             } else {
 687                 mIconCache.preloadIcon(ComponentName.unflattenFromString(widget.provider),
 688                         icon, widget.icon.dpi, widget.label, mUserSerial);
 689             }
 690         }
 691 
 692         // future site of widget table mutation
 693     }
 694 
 695     /** create a new key, with an integer ID.
 696      *
 697      * &lt;P&gt; Keys contain their own checksum instead of using
 698      * the heavy-weight CheckedMessage wrapper.
 699      */
 700     private Key getKey(int type, long id) {
 701         Key key = new Key();
 702         key.type = type;
 703         key.id = id;
 704         key.checksum = checkKey(key);
 705         return key;
 706     }
 707 
 708     /** create a new key for a named object.
 709      *
 710      * &lt;P&gt; Keys contain their own checksum instead of using
 711      * the heavy-weight CheckedMessage wrapper.
 712      */
 713     private Key getKey(int type, String name) {
 714         Key key = new Key();
 715         key.type = type;
 716         key.name = name;
 717         key.checksum = checkKey(key);
 718         return key;
 719     }
 720 
 721     /** keys need to be strings, serialize and encode. */
 722     private String keyToBackupKey(Key key) {
 723         return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 724     }
 725 
 726     /** keys need to be strings, decode and parse. */
 727     private Key backupKeyToKey(String backupKey) throws InvalidBackupException {
 728         try {
 729             Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 730             if (key.checksum != checkKey(key)) {
 731                 key = null;
 732                 throw new InvalidBackupException(&quot;invalid key read from stream&quot; + backupKey);
 733             }
 734             return key;
 735         } catch (InvalidProtocolBufferNanoException e) {
 736             throw new InvalidBackupException(e);
 737         } catch (IllegalArgumentException e) {
 738             throw new InvalidBackupException(e);
 739         }
 740     }
 741 
 742     /** Compute the checksum over the important bits of a key. */
 743     private long checkKey(Key key) {
 744         CRC32 checksum = new CRC32();
 745         checksum.update(key.type);
 746         checksum.update((int) (key.id &amp; 0xffff));
 747         checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 748         if (!TextUtils.isEmpty(key.name)) {
 749             checksum.update(key.name.getBytes());
 750         }
 751         return checksum.getValue();
 752     }
 753 
 754     /**
 755      * @return true if its an hotseat item, that can be replaced during restore.
 756      * TODO: Extend check for folders in hotseat.
 757      */
 758     private boolean isReplaceableHotseatItem(Favorite favorite) {
 759         return favorite.container == Favorites.CONTAINER_HOTSEAT
 760                 &amp;&amp; favorite.intent != null
 761                 &amp;&amp; (favorite.itemType == Favorites.ITEM_TYPE_APPLICATION
 762                 || favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT);
 763     }
 764 
 765     /** Serialize a Favorite for persistence, including a checksum wrapper. */
 766     private Favorite packFavorite(Cursor c) {
 767         Favorite favorite = new Favorite();
 768         favorite.id = c.getLong(ID_INDEX);
 769         favorite.screen = c.getInt(SCREEN_INDEX);
 770         favorite.container = c.getInt(CONTAINER_INDEX);
 771         favorite.cellX = c.getInt(CELLX_INDEX);
 772         favorite.cellY = c.getInt(CELLY_INDEX);
 773         favorite.spanX = c.getInt(SPANX_INDEX);
 774         favorite.spanY = c.getInt(SPANY_INDEX);
 775         favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 776 
 777         String title = c.getString(TITLE_INDEX);
 778         if (!TextUtils.isEmpty(title)) {
 779             favorite.title = title;
 780         }
 781         String intentDescription = c.getString(INTENT_INDEX);
 782         Intent intent = null;
 783         if (!TextUtils.isEmpty(intentDescription)) {
 784             try {
 785                 intent = Intent.parseUri(intentDescription, 0);
 786                 intent.removeExtra(ItemInfo.EXTRA_PROFILE);
 787                 favorite.intent = intent.toUri(0);
 788             } catch (URISyntaxException e) {
 789                 Log.e(TAG, &quot;Invalid intent&quot;, e);
 790             }
 791         }
 792         favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 793         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 794             favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 795             String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 796             if (!TextUtils.isEmpty(appWidgetProvider)) {
 797                 favorite.appWidgetProvider = appWidgetProvider;
 798             }
 799         } else if (favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT) {
 800             if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 801                 String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 802                 if (!TextUtils.isEmpty(iconPackage)) {
 803                     favorite.iconPackage = iconPackage;
 804                 }
 805                 String iconResource = c.getString(ICON_RESOURCE_INDEX);
 806                 if (!TextUtils.isEmpty(iconResource)) {
 807                     favorite.iconResource = iconResource;
 808                 }
 809             }
 810 
 811             byte[] blob = c.getBlob(ICON_INDEX);
 812             if (blob != null &amp;&amp; blob.length &gt; 0) {
 813                 favorite.icon = blob;
 814             }
 815         }
 816 
 817         if (isReplaceableHotseatItem(favorite)) {
 818             if (intent != null &amp;&amp; intent.getComponent() != null) {
 819                 PackageManager pm = mContext.getPackageManager();
 820                 ActivityInfo activity = null;;
 821                 try {
 822                     activity = pm.getActivityInfo(intent.getComponent(), 0);
 823                 } catch (NameNotFoundException e) {
 824                     Log.e(TAG, &quot;Target not found&quot;, e);
 825                 }
 826                 if (activity == null) {
 827                     return favorite;
 828                 }
 829                 for (int i = 0; i &lt; mItemTypeMatchers.length; i++) {
 830                     if (mItemTypeMatchers[i] == null) {
 831                         mItemTypeMatchers[i] = new ItemTypeMatcher(
 832                                 CommonAppTypeParser.getResourceForItemType(i));
 833                     }
 834                     if (mItemTypeMatchers[i].matches(activity, pm)) {
 835                         favorite.targetType = i;
 836                         break;
 837                     }
 838                 }
 839             }
 840         }
 841 
 842         return favorite;
 843     }
 844 
 845     /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 846     private ContentValues unpackFavorite(byte[] buffer, int dataSize)
 847             throws IOException {
 848         Favorite favorite = unpackProto(new Favorite(), buffer, dataSize);
 849 
 850         ContentValues values = new ContentValues();
 851         values.put(Favorites._ID, favorite.id);
 852         values.put(Favorites.SCREEN, favorite.screen);
 853         values.put(Favorites.CONTAINER, favorite.container);
 854         values.put(Favorites.CELLX, favorite.cellX);
 855         values.put(Favorites.CELLY, favorite.cellY);
 856         values.put(Favorites.SPANX, favorite.spanX);
 857         values.put(Favorites.SPANY, favorite.spanY);
 858 
 859         if (favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT) {
 860             values.put(Favorites.ICON_TYPE, favorite.iconType);
 861             if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 862                 values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 863                 values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 864             }
 865             values.put(Favorites.ICON, favorite.icon);
 866         }
 867 
 868         if (!TextUtils.isEmpty(favorite.title)) {
 869             values.put(Favorites.TITLE, favorite.title);
 870         } else {
 871             values.put(Favorites.TITLE, &quot;&quot;);
 872         }
 873         if (!TextUtils.isEmpty(favorite.intent)) {
 874             values.put(Favorites.INTENT, favorite.intent);
 875         }
 876         values.put(Favorites.ITEM_TYPE, favorite.itemType);
 877 
 878         UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 879         long userSerialNumber =
 880                 UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHandle);
 881         values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
 882 
 883         DeviceProfieData currentProfile = mDeviceProfileData;
 884 
 885         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 886             if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 887                 values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 888             }
 889             values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 890             values.put(LauncherSettings.Favorites.RESTORED,
 891                     LauncherAppWidgetInfo.FLAG_ID_NOT_VALID |
 892                     LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY |
 893                     LauncherAppWidgetInfo.FLAG_UI_NOT_READY);
 894 
 895             // Verify placement
 896             if (((favorite.cellX + favorite.spanX) &gt; currentProfile.desktopCols)
 897                     || ((favorite.cellY + favorite.spanY) &gt; currentProfile.desktopRows)) {
 898                 restoreSuccessful = false;
 899                 throw new InvalidBackupException(&quot;Widget not in screen bounds, aborting restore&quot;);
 900             }
 901         } else {
 902             // Check if it is an hotseat item, that can be replaced.
 903             if (isReplaceableHotseatItem(favorite)
 904                     &amp;&amp; favorite.targetType != Favorite.TARGET_NONE
 905                     &amp;&amp; favorite.targetType &lt; CommonAppTypeParser.SUPPORTED_TYPE_COUNT) {
 906                 Log.e(TAG, &quot;Added item type flag&quot;);
 907                 values.put(LauncherSettings.Favorites.RESTORED,
 908                         1 | CommonAppTypeParser.encodeItemTypeToFlag(favorite.targetType));
 909             } else {
 910                 // Let LauncherModel know we&#x27;ve been here.
 911                 values.put(LauncherSettings.Favorites.RESTORED, 1);
 912             }
 913 
 914             // Verify placement
 915             if (favorite.container == Favorites.CONTAINER_HOTSEAT) {
 916                 if ((favorite.screen &gt;= currentProfile.hotseatCount)
 917                         || (favorite.screen == currentProfile.allappsRank)) {
 918                     restoreSuccessful = false;
 919                     throw new InvalidBackupException(&quot;Item not in hotseat bounds, aborting restore&quot;);
 920                 }
 921             } else {
 922                 if ((favorite.cellX &gt;= currentProfile.desktopCols)
 923                         || (favorite.cellY &gt;= currentProfile.desktopRows)) {
 924                     restoreSuccessful = false;
 925                     throw new InvalidBackupException(&quot;Item not in desktop bounds, aborting restore&quot;);
 926                 }
 927             }
 928         }
 929 
 930         return values;
 931     }
 932 
 933     /** Serialize a Screen for persistence, including a checksum wrapper. */
 934     private Screen packScreen(Cursor c) {
 935         Screen screen = new Screen();
 936         screen.id = c.getLong(ID_INDEX);
 937         screen.rank = c.getInt(SCREEN_RANK_INDEX);
 938         return screen;
 939     }
 940 
 941     /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 942     private ContentValues unpackScreen(byte[] buffer, int dataSize)
 943             throws InvalidProtocolBufferNanoException {
 944         Screen screen = unpackProto(new Screen(), buffer, dataSize);
 945         ContentValues values = new ContentValues();
 946         values.put(WorkspaceScreens._ID, screen.id);
 947         values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 948         return values;
 949     }
 950 
 951     /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 952     private Resource packIcon(int dpi, Bitmap icon) {
 953         Resource res = new Resource();
 954         res.dpi = dpi;
 955         res.data = Utilities.flattenBitmap(icon);
 956         return res;
 957     }
 958 
 959     /** Serialize a widget for persistence, including a checksum wrapper. */
 960     private Widget packWidget(int dpi, ComponentName provider, UserHandleCompat user) {
 961         final LauncherAppWidgetProviderInfo info =
 962                 LauncherModel.getProviderInfo(mContext, provider, user);
 963         Widget widget = new Widget();
 964         widget.provider = provider.flattenToShortString();
 965         widget.label = info.label;
 966         widget.configure = info.configure != null;
 967         if (info.icon != 0) {
 968             widget.icon = new Resource();
 969             Drawable fullResIcon = mIconCache.getFullResIcon(provider.getPackageName(), info.icon);
 970             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 971             widget.icon.data = Utilities.flattenBitmap(icon);
 972             widget.icon.dpi = dpi;
 973         }
 974 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 975 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 976         // Calculate the spans corresponding to any one of the orientations as it should not change</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 977         // based on orientation.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 978         int[] minSpans = CellLayout.rectToCell(</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 979                 mIdp.portraitProfile, mContext, info.minResizeWidth, info.minResizeHeight, null);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 980         widget.minSpanX = (info.resizeMode &amp; LauncherAppWidgetProviderInfo.RESIZE_HORIZONTAL) != 0</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 981                 ? minSpans[0] : -1;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 982         widget.minSpanY = (info.resizeMode &amp; LauncherAppWidgetProviderInfo.RESIZE_VERTICAL) != 0</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 983                 ? minSpans[1] : -1;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 984 </span>
 985 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 986             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 987         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 988         if (info.previewImage != 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 989             widget.preview = new Resource();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 990             Bitmap preview = previewLoader.generateWidgetPreview(info, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 991             ByteArrayOutputStream os = new ByteArrayOutputStream();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 992             if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 993                 widget.preview.data = os.toByteArray();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 994                 widget.preview.dpi = dpi;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 995             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 996         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 997         return widget;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 998     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 999 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1000     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1001      * Deserialize a proto after verifying checksum wrapper.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1002      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1003     private &lt;T extends MessageNano&gt; T unpackProto(T proto, byte[] buffer, int dataSize)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1004             throws InvalidProtocolBufferNanoException {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1005         MessageNano.mergeFrom(proto, readCheckedBytes(buffer, dataSize));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1006         if (DEBUG) Log.d(TAG, &quot;unpacked proto &quot; + proto);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1007         return proto;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1008     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1009 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1010     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1011      * Read the old journal from the input file.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1012      *</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1013      * In the event of any error, just pretend we didn&#x27;t have a journal,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1014      * in that case, do a full backup.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1015      *</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1016      * @param oldState the read-0only file descriptor pointing to the old journal</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1017      * @return a Journal protocol buffer</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1018      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1019     private Journal readJournal(ParcelFileDescriptor oldState) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1020         Journal journal = new Journal();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1021         if (oldState == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1022             return journal;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1023         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1024         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1025         try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1026             int availableBytes = inStream.available();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1027             if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1028             if (availableBytes &lt; MAX_JOURNAL_SIZE) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1029                 byte[] buffer = new byte[availableBytes];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1030                 int bytesRead = 0;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1031                 boolean valid = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1032                 InvalidProtocolBufferNanoException lastProtoException = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1033                 while (availableBytes &gt; 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1034                     try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1035                         // OMG what are you doing? This is crazy inefficient!</span>
1036 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1037         if (info.previewImage != 0) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1038             widget.preview = new Resource();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1039             Bitmap preview = previewLoader.generateWidgetPreview(info, null);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1040             ByteArrayOutputStream os = new ByteArrayOutputStream();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1041             if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1042                 widget.preview.data = os.toByteArray();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1043                 widget.preview.dpi = dpi;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1044             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1045         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1046 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1047         widget.minSpanX = (info.resizeMode &amp; LauncherAppWidgetProviderInfo.RESIZE_HORIZONTAL) != 0</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1048                 ? info.minSpanX : -1;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1049         widget.minSpanY = (info.resizeMode &amp; LauncherAppWidgetProviderInfo.RESIZE_VERTICAL) != 0</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1050                 ? info.minSpanY : -1;</span>
1051 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
1052         return widget;
1053     }
1054 
1055     /**
1056      * Deserialize a proto after verifying checksum wrapper.
1057      */
1058     private &lt;T extends MessageNano&gt; T unpackProto(T proto, byte[] buffer, int dataSize)
1059             throws InvalidProtocolBufferNanoException {
1060         MessageNano.mergeFrom(proto, readCheckedBytes(buffer, dataSize));
1061         if (DEBUG) Log.d(TAG, &quot;unpacked proto &quot; + proto);
1062         return proto;
1063     }
1064 
1065     /**
1066      * Read the old journal from the input file.
1067      *
1068      * In the event of any error, just pretend we didn&#x27;t have a journal,
1069      * in that case, do a full backup.
1070      *
1071      * @param oldState the read-0only file descriptor pointing to the old journal
1072      * @return a Journal protocol buffer
1073      */
1074     private Journal readJournal(ParcelFileDescriptor oldState) {
1075         Journal journal = new Journal();
1076         if (oldState == null) {
1077             return journal;
1078         }
1079         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
1080         try {
1081             int availableBytes = inStream.available();
1082             if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
1083             if (availableBytes &lt; MAX_JOURNAL_SIZE) {
1084                 byte[] buffer = new byte[availableBytes];
1085                 int bytesRead = 0;
1086                 boolean valid = false;
1087                 InvalidProtocolBufferNanoException lastProtoException = null;
1088                 while (availableBytes &gt; 0) {
1089                     try {
1090                         // OMG what are you doing? This is crazy inefficient!
1091                         // If we read a byte that is not ours, we will cause trouble: b/12491813
1092                         // However, we don&#x27;t know how many bytes to expect (oops).
1093                         // So we have to step through *slowly*, watching for the end.
1094                         int result = inStream.read(buffer, bytesRead, 1);
1095                         if (result &gt; 0) {
1096                             availableBytes -= result;
1097                             bytesRead += result;
1098                         } else {
1099                             Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1100                             // stop reading and see what there is to parse
1101                             availableBytes = 0;
1102                         }
1103                     } catch (IOException e) {
1104                         buffer = null;
1105                         availableBytes = 0;
1106                     }
1107 
1108                     // check the buffer to see if we have a valid journal
1109                     try {
1110                         MessageNano.mergeFrom(journal, readCheckedBytes(buffer, bytesRead));
1111                         // if we are here, then we have read a valid, checksum-verified journal
1112                         valid = true;
1113                         availableBytes = 0;
1114                         if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1115                     } catch (InvalidProtocolBufferNanoException e) {
1116                         // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1117                         lastProtoException = e;
1118                         journal.clear();
1119                     }
1120                 }
1121                 if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1122                 if (!valid) {
1123                     Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1124                 }
1125             }
1126         } catch (IOException e) {
1127             Log.w(TAG, &quot;failed to close the journal&quot;, e);
1128         } finally {
1129             try {
1130                 inStream.close();
1131             } catch (IOException e) {
1132                 Log.w(TAG, &quot;failed to close the journal&quot;, e);
1133             }
1134         }
1135         return journal;
1136     }
1137 
1138     private void writeRowToBackup(Key key, MessageNano proto, BackupDataOutput data)
1139             throws IOException {
1140         writeRowToBackup(keyToBackupKey(key), proto, data);
1141     }
1142 
1143     private void writeRowToBackup(String backupKey, MessageNano proto,
1144             BackupDataOutput data) throws IOException {
1145         byte[] blob = writeCheckedBytes(proto);
1146         data.writeEntityHeader(backupKey, blob.length);
1147         data.writeEntityData(blob, blob.length);
1148         mBackupDataWasUpdated = true;
1149         if (VERBOSE) Log.v(TAG, &quot;Writing New entry &quot; + backupKey);
1150     }
1151 
1152     /**
1153      * Write the new journal to the output file.
1154      *
1155      * In the event of any error, just pretend we didn&#x27;t have a journal,
1156      * in that case, do a full backup.
1157 
1158      * @param newState the write-only file descriptor pointing to the new journal
1159      * @param journal a Journal protocol buffer
1160      */
1161     private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1162         FileOutputStream outStream = null;
1163         try {
1164             outStream = new FileOutputStream(newState.getFileDescriptor());
1165             final byte[] journalBytes = writeCheckedBytes(journal);
1166             outStream.write(journalBytes);
1167             outStream.close();
1168             if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1169         } catch (IOException e) {
1170             Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1171         }
1172     }
1173 
1174     /** Wrap a proto in a CheckedMessage and compute the checksum. */
1175     private byte[] writeCheckedBytes(MessageNano proto) {
1176         CheckedMessage wrapper = new CheckedMessage();
1177         wrapper.payload = MessageNano.toByteArray(proto);
1178         CRC32 checksum = new CRC32();
1179         checksum.update(wrapper.payload);
1180         wrapper.checksum = checksum.getValue();
1181         return MessageNano.toByteArray(wrapper);
1182     }
1183 
1184     /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1185     private static byte[] readCheckedBytes(byte[] buffer, int dataSize)
1186             throws InvalidProtocolBufferNanoException {
1187         CheckedMessage wrapper = new CheckedMessage();
1188         MessageNano.mergeFrom(wrapper, buffer, 0, dataSize);
1189         CRC32 checksum = new CRC32();
1190         checksum.update(wrapper.payload);
1191         if (wrapper.checksum != checksum.getValue()) {
1192             throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1193         }
1194         return wrapper.payload;
1195     }
1196 
1197     /**
1198      * @return true if the launcher is in a state to support backup
1199      */
1200     private boolean launcherIsReady() {
1201         ContentResolver cr = mContext.getContentResolver();
1202         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);
1203         if (cursor == null) {
1204             // launcher data has been wiped, do nothing
1205             return false;
1206         }
1207         cursor.close();
1208 
1209         if (LauncherAppState.getInstanceNoCreate() == null) {
1210             // launcher services are unavailable, try again later
1211             return false;
1212         }
1213 
1214         return true;
1215     }
1216 
1217     private String getUserSelectionArg() {
1218         return Favorites.PROFILE_ID + &#x27;=&#x27; + UserManagerCompat.getInstance(mContext)
1219                 .getSerialNumberForUser(UserHandleCompat.myUserHandle());
1220     }
1221 
1222     @Thunk class InvalidBackupException extends IOException {
1223 
1224         private static final long serialVersionUID = 8931456637211665082L;
1225 
1226         @Thunk InvalidBackupException(Throwable cause) {
1227             super(cause);
1228         }
1229 
1230         @Thunk InvalidBackupException(String reason) {
1231             super(reason);
1232         }
1233     }
1234 
1235     /**
1236      * A class to check if an activity can handle one of the intents from a list of
1237      * predefined intents.
1238      */
1239     private class ItemTypeMatcher {
1240 
1241         private final ArrayList&lt;Intent&gt; mIntents;
1242 
1243         ItemTypeMatcher(int xml_res) {
1244             mIntents = xml_res == 0 ? new ArrayList&lt;Intent&gt;() : parseIntents(xml_res);
1245         }
1246 
1247         private ArrayList&lt;Intent&gt; parseIntents(int xml_res) {
1248             ArrayList&lt;Intent&gt; intents = new ArrayList&lt;Intent&gt;();
1249             XmlResourceParser parser = mContext.getResources().getXml(xml_res);
1250             try {
1251                 DefaultLayoutParser.beginDocument(parser, DefaultLayoutParser.TAG_RESOLVE);
1252                 final int depth = parser.getDepth();
1253                 int type;
1254                 while (((type = parser.next()) != XmlPullParser.END_TAG ||
1255                         parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {
1256                     if (type != XmlPullParser.START_TAG) {
1257                         continue;
1258                     } else if (DefaultLayoutParser.TAG_FAVORITE.equals(parser.getName())) {
1259                         final String uri = DefaultLayoutParser.getAttributeValue(
1260                                 parser, DefaultLayoutParser.ATTR_URI);
1261                         intents.add(Intent.parseUri(uri, 0));
1262                     }
1263                 }
1264             } catch (URISyntaxException | XmlPullParserException | IOException e) {
1265                 Log.e(TAG, &quot;Unable to parse &quot; + xml_res, e);
1266             } finally {
1267                 parser.close();
1268             }
1269             return intents;
1270         }
1271 
1272         public boolean matches(ActivityInfo activity, PackageManager pm) {
1273             for (Intent intent : mIntents) {
1274                 intent.setPackage(activity.packageName);
1275                 ResolveInfo info = pm.resolveActivity(intent, 0);
1276                 if (info != null &amp;&amp; (info.activityInfo.name.equals(activity.name)
1277                         || info.activityInfo.name.equals(activity.targetActivity))) {
1278                     return true;
1279                 }
1280             }
1281             return false;
1282         }
1283     }
1284 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.app.backup.BackupDataInputStream;
  19 import android.app.backup.BackupDataOutput;
  20 import android.app.backup.BackupHelper;
  21 import android.app.backup.BackupManager;
  22 import android.content.ComponentName;
  23 import android.content.ContentResolver;
  24 import android.content.ContentValues;
  25 import android.content.Context;
  26 import android.content.Intent;
  27 import android.content.pm.ActivityInfo;
  28 import android.content.pm.PackageManager;
  29 import android.content.pm.PackageManager.NameNotFoundException;
  30 import android.content.pm.ResolveInfo;
  31 import android.content.res.XmlResourceParser;
  32 import android.database.Cursor;
  33 import android.graphics.Bitmap;
  34 import android.graphics.BitmapFactory;
  35 import android.graphics.drawable.Drawable;
  36 import android.os.ParcelFileDescriptor;
  37 import android.text.TextUtils;
  38 import android.util.Base64;
  39 import android.util.Log;
  40 
  41 import com.android.launcher3.LauncherSettings.Favorites;
  42 import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  43 import com.android.launcher3.backup.BackupProtos;
  44 import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  45 import com.android.launcher3.backup.BackupProtos.DeviceProfieData;
  46 import com.android.launcher3.backup.BackupProtos.Favorite;
  47 import com.android.launcher3.backup.BackupProtos.Journal;
  48 import com.android.launcher3.backup.BackupProtos.Key;
  49 import com.android.launcher3.backup.BackupProtos.Resource;
  50 import com.android.launcher3.backup.BackupProtos.Screen;
  51 import com.android.launcher3.backup.BackupProtos.Widget;
  52 import com.android.launcher3.compat.UserHandleCompat;
  53 import com.android.launcher3.compat.UserManagerCompat;
  54 import com.android.launcher3.util.Thunk;
  55 import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  56 import com.google.protobuf.nano.MessageNano;
  57 
  58 import org.xmlpull.v1.XmlPullParser;
  59 import org.xmlpull.v1.XmlPullParserException;
  60 
  61 import java.io.FileInputStream;
  62 import java.io.FileOutputStream;
  63 import java.io.IOException;
  64 import java.net.URISyntaxException;
  65 import java.util.ArrayList;
  66 import java.util.Arrays;
  67 import java.util.HashSet;
  68 import java.util.zip.CRC32;
  69 
  70 /**
  71  * Persist the launcher home state across calamities.
  72  */
  73 public class LauncherBackupHelper implements BackupHelper {
  74     private static final String TAG = &quot;LauncherBackupHelper&quot;;
  75     private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  76     private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  77 
  78     private static final int BACKUP_VERSION = 3;
  79     private static final int MAX_JOURNAL_SIZE = 1000000;
  80 
  81     // Journal key is such that it is always smaller than any dynamically generated
  82     // key (any Base64 encoded string).
  83     private static final String JOURNAL_KEY = &quot;#&quot;;
  84 
  85     /** icons are large, dribble them out */
  86     private static final int MAX_ICONS_PER_PASS = 10;
  87 
  88     /** widgets contain previews, which are very large, dribble them out */
  89     private static final int MAX_WIDGETS_PER_PASS = 5;
  90 
  91     private static final String[] FAVORITE_PROJECTION = {
  92         Favorites._ID,                     // 0
  93         Favorites.MODIFIED,                // 1
  94         Favorites.INTENT,                  // 2
  95         Favorites.APPWIDGET_PROVIDER,      // 3
  96         Favorites.APPWIDGET_ID,            // 4
  97         Favorites.CELLX,                   // 5
  98         Favorites.CELLY,                   // 6
  99         Favorites.CONTAINER,               // 7
 100         Favorites.ICON,                    // 8
 101         Favorites.ICON_PACKAGE,            // 9
 102         Favorites.ICON_RESOURCE,           // 10
 103         Favorites.ICON_TYPE,               // 11
 104         Favorites.ITEM_TYPE,               // 12
 105         Favorites.SCREEN,                  // 13
 106         Favorites.SPANX,                   // 14
 107         Favorites.SPANY,                   // 15
 108         Favorites.TITLE,                   // 16
 109         Favorites.PROFILE_ID,              // 17
 110     };
 111 
 112     private static final int ID_INDEX = 0;
 113     private static final int ID_MODIFIED = 1;
 114     private static final int INTENT_INDEX = 2;
 115     private static final int APPWIDGET_PROVIDER_INDEX = 3;
 116     private static final int APPWIDGET_ID_INDEX = 4;
 117     private static final int CELLX_INDEX = 5;
 118     private static final int CELLY_INDEX = 6;
 119     private static final int CONTAINER_INDEX = 7;
 120     private static final int ICON_INDEX = 8;
 121     private static final int ICON_PACKAGE_INDEX = 9;
 122     private static final int ICON_RESOURCE_INDEX = 10;
 123     private static final int ICON_TYPE_INDEX = 11;
 124     private static final int ITEM_TYPE_INDEX = 12;
 125     private static final int SCREEN_INDEX = 13;
 126     private static final int SPANX_INDEX = 14;
 127     private static final int SPANY_INDEX = 15;
 128     private static final int TITLE_INDEX = 16;
 129 
 130     private static final String[] SCREEN_PROJECTION = {
 131         WorkspaceScreens._ID,              // 0
 132         WorkspaceScreens.MODIFIED,         // 1
 133         WorkspaceScreens.SCREEN_RANK       // 2
 134     };
 135 
 136     private static final int SCREEN_RANK_INDEX = 2;
 137 
 138     @Thunk final Context mContext;
 139     private final HashSet&lt;String&gt; mExistingKeys;
 140     private final ArrayList&lt;Key&gt; mKeys;
 141     private final ItemTypeMatcher[] mItemTypeMatchers;
 142     private final long mUserSerial;
 143 
 144     private IconCache mIconCache;
 145     private DeviceProfieData mDeviceProfileData;
 146     private InvariantDeviceProfile mIdp;
 147 
 148     private BackupManager mBackupManager;
 149     private byte[] mBuffer = new byte[512];
 150     private long mLastBackupRestoreTime;
 151     private boolean mBackupDataWasUpdated;
 152 
 153     boolean restoreSuccessful;
 154     int restoredBackupVersion = 1;
 155 
 156     public LauncherBackupHelper(Context context) {
 157         mContext = context;
 158         mExistingKeys = new HashSet&lt;String&gt;();
 159         mKeys = new ArrayList&lt;Key&gt;();
 160         restoreSuccessful = true;
 161         mItemTypeMatchers = new ItemTypeMatcher[CommonAppTypeParser.SUPPORTED_TYPE_COUNT];
 162 
 163         UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 164         mUserSerial = userManager.getSerialNumberForUser(UserHandleCompat.myUserHandle());
 165     }
 166 
 167     private void dataChanged() {
 168         if (mBackupManager == null) {
 169             mBackupManager = new BackupManager(mContext);
 170         }
 171         mBackupManager.dataChanged();
 172     }
 173 
 174     private void applyJournal(Journal journal) {
 175         mLastBackupRestoreTime = journal.t;
 176         mExistingKeys.clear();
 177         if (journal.key != null) {
 178             for (Key key : journal.key) {
 179                 mExistingKeys.add(keyToBackupKey(key));
 180             }
 181         }
 182         restoredBackupVersion = journal.backupVersion;
 183     }
 184 
 185     /**
 186      * Back up launcher data so we can restore the user&#x27;s state on a new device.
 187      *
 188      * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 189      *
 190      * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 191      *
 192      * @param oldState notes from the last backup
 193      * @param data incremental key/value pairs to persist off-device
 194      * @param newState notes for the next backup
 195      */
 196     @Override
 197     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 198             ParcelFileDescriptor newState) {
 199         if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 200 
 201         Journal in = readJournal(oldState);
 202         if (!launcherIsReady()) {
 203             dataChanged();
 204             // Perform backup later.
 205             writeJournal(newState, in);
 206             return;
 207         }
 208 
 209         if (mDeviceProfileData == null) {
 210             LauncherAppState app = LauncherAppState.getInstance();
 211             mIdp = app.getInvariantDeviceProfile();
 212             mDeviceProfileData = initDeviceProfileData(mIdp);
 213             mIconCache = app.getIconCache();
 214         }
 215 
 216         Log.v(TAG, &quot;lastBackupTime = &quot; + in.t);
 217         mKeys.clear();
 218         applyJournal(in);
 219 
 220         // Record the time before performing backup so that entries edited while the backup
 221         // was going on, do not get missed in next backup.
 222         long newBackupTime = System.currentTimeMillis();
 223         mBackupDataWasUpdated = false;
 224         try {
 225             backupFavorites(data);
 226             backupScreens(data);
 227             backupIcons(data);
 228             backupWidgets(data);
 229 
 230             // Delete any key which still exist in the old backup, but is not valid anymore.
 231             HashSet&lt;String&gt; validKeys = new HashSet&lt;String&gt;();
 232             for (Key key : mKeys) {
 233                 validKeys.add(keyToBackupKey(key));
 234             }
 235             mExistingKeys.removeAll(validKeys);
 236 
 237             // Delete anything left in the existing keys.
 238             for (String deleted: mExistingKeys) {
 239                 if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
 240                 data.writeEntityHeader(deleted, -1);
 241                 mBackupDataWasUpdated = true;
 242             }
 243 
 244             mExistingKeys.clear();
 245             if (!mBackupDataWasUpdated) {
 246                 // Check if any metadata has changed
 247                 mBackupDataWasUpdated = (in.profile == null)
 248                         || !Arrays.equals(DeviceProfieData.toByteArray(in.profile),
 249                             DeviceProfieData.toByteArray(mDeviceProfileData))
 250                         || (in.backupVersion != BACKUP_VERSION)
 251                         || (in.appVersion != getAppVersion());
 252             }
 253 
 254             if (mBackupDataWasUpdated) {
 255                 mLastBackupRestoreTime = newBackupTime;
 256 
 257                 // We store the journal at two places.
 258                 //   1) Storing it in newState allows us to do partial backups by comparing old state
 259                 //   2) Storing it in backup data allows us to validate keys during restore
 260                 Journal state = getCurrentStateJournal();
 261                 writeRowToBackup(JOURNAL_KEY, state, data);
 262             } else {
 263                 if (DEBUG) Log.d(TAG, &quot;Nothing was written during backup&quot;);
 264             }
 265         } catch (IOException e) {
 266             Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 267         }
 268 
 269         writeNewStateDescription(newState);
 270     }
 271 
 272     /**
 273      * @return true if the backup corresponding to oldstate can be successfully applied
 274      * to this device.
 275      */
 276     private boolean isBackupCompatible(Journal oldState) {
 277         DeviceProfieData currentProfile = mDeviceProfileData;
 278         DeviceProfieData oldProfile = oldState.profile;
 279 
 280         if (oldProfile == null || oldProfile.desktopCols == 0) {
 281             // Profile info is not valid, ignore the check.
 282             return true;
 283         }
 284 
 285         boolean isHotsetCompatible = false;
 286         if (currentProfile.allappsRank &gt;= oldProfile.hotseatCount) {
 287             isHotsetCompatible = true;
 288         }
 289         if ((currentProfile.hotseatCount &gt;= oldProfile.hotseatCount) &amp;&amp;
 290                 (currentProfile.allappsRank == oldProfile.allappsRank)) {
 291             isHotsetCompatible = true;
 292         }
 293 
 294         return isHotsetCompatible &amp;&amp; (currentProfile.desktopCols &gt;= oldProfile.desktopCols)
 295                 &amp;&amp; (currentProfile.desktopRows &gt;= oldProfile.desktopRows);
 296     }
 297 
 298     /**
 299      * Restore launcher configuration from the restored data stream.
 300      * It assumes that the keys will arrive in lexical order. So if the journal was present in the
 301      * backup, it should arrive first.
 302      *
 303      * @param data the key/value pair from the server
 304      */
 305     @Override
 306     public void restoreEntity(BackupDataInputStream data) {
 307         if (!restoreSuccessful) {
 308             return;
 309         }
 310 
 311         if (mDeviceProfileData == null) {
 312             // This call does not happen on a looper thread. So LauncherAppState
 313             // can&#x27;t be created . Instead initialize required dependencies directly.
 314             mIdp = new InvariantDeviceProfile(mContext);
 315             mDeviceProfileData = initDeviceProfileData(mIdp);
 316             mIconCache = new IconCache(mContext, mIdp);
 317         }
 318 
 319         int dataSize = data.size();
 320         if (mBuffer.length &lt; dataSize) {
 321             mBuffer = new byte[dataSize];
 322         }
 323         try {
 324             int bytesRead = data.read(mBuffer, 0, dataSize);
 325             if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 326             String backupKey = data.getKey();
 327 
 328             if (JOURNAL_KEY.equals(backupKey)) {
 329                 if (VERBOSE) Log.v(TAG, &quot;Journal entry restored&quot;);
 330                 if (!mKeys.isEmpty()) {
 331                     // We received the journal key after a restore key.
 332                     Log.wtf(TAG, keyToBackupKey(mKeys.get(0)) + &quot; received after &quot; + JOURNAL_KEY);
 333                     restoreSuccessful = false;
 334                     return;
 335                 }
 336 
 337                 Journal journal = new Journal();
 338                 MessageNano.mergeFrom(journal, readCheckedBytes(mBuffer, dataSize));
 339                 applyJournal(journal);
 340                 restoreSuccessful = isBackupCompatible(journal);
 341                 return;
 342             }
 343 
 344             if (!mExistingKeys.isEmpty() &amp;&amp; !mExistingKeys.contains(backupKey)) {
 345                 if (DEBUG) Log.e(TAG, &quot;Ignoring key not present in the backup state &quot; + backupKey);
 346                 return;
 347             }
 348             Key key = backupKeyToKey(backupKey);
 349             mKeys.add(key);
 350             switch (key.type) {
 351                 case Key.FAVORITE:
 352                     restoreFavorite(key, mBuffer, dataSize);
 353                     break;
 354 
 355                 case Key.SCREEN:
 356                     restoreScreen(key, mBuffer, dataSize);
 357                     break;
 358 
 359                 case Key.ICON:
 360                     restoreIcon(key, mBuffer, dataSize);
 361                     break;
 362 
 363                 case Key.WIDGET:
 364                     restoreWidget(key, mBuffer, dataSize);
 365                     break;
 366 
 367                 default:
 368                     Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 369                     mKeys.remove(key);
 370                     break;
 371             }
 372         } catch (IOException e) {
 373             Log.w(TAG, &quot;ignoring unparsable backup entry&quot;, e);
 374         }
 375     }
 376 
 377     /**
 378      * Record the restore state for the next backup.
 379      *
 380      * @param newState notes about the backup state after restore.
 381      */
 382     @Override
 383     public void writeNewStateDescription(ParcelFileDescriptor newState) {
 384         writeJournal(newState, getCurrentStateJournal());
 385     }
 386 
 387     private Journal getCurrentStateJournal() {
 388         Journal journal = new Journal();
 389         journal.t = mLastBackupRestoreTime;
 390         journal.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);
 391         journal.appVersion = getAppVersion();
 392         journal.backupVersion = BACKUP_VERSION;
 393         journal.profile = mDeviceProfileData;
 394         return journal;
 395     }
 396 
 397     private int getAppVersion() {
 398         try {
 399             return mContext.getPackageManager()
 400                     .getPackageInfo(mContext.getPackageName(), 0).versionCode;
 401         } catch (NameNotFoundException e) {
 402             return 0;
 403         }
 404     }
 405 
 406     private DeviceProfieData initDeviceProfileData(InvariantDeviceProfile profile) {
 407         DeviceProfieData data = new DeviceProfieData();
 408         data.desktopRows = profile.numRows;
 409         data.desktopCols = profile.numColumns;
 410         data.hotseatCount = profile.numHotseatIcons;
 411         data.allappsRank = profile.hotseatAllAppsRank;
 412         return data;
 413     }
 414 
 415     /**
 416      * Write all modified favorites to the data stream.
 417      *
 418      * @param data output stream for key/value pairs
 419      * @throws IOException
 420      */
 421     private void backupFavorites(BackupDataOutput data) throws IOException {
 422         // persist things that have changed since the last backup
 423         ContentResolver cr = mContext.getContentResolver();
 424         // Don&#x27;t backup apps in other profiles for now.
 425         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 426                 getUserSelectionArg(), null, null);
 427         try {
 428             cursor.moveToPosition(-1);
 429             while(cursor.moveToNext()) {
 430                 final long id = cursor.getLong(ID_INDEX);
 431                 final long updateTime = cursor.getLong(ID_MODIFIED);
 432                 Key key = getKey(Key.FAVORITE, id);
 433                 mKeys.add(key);
 434                 final String backupKey = keyToBackupKey(key);
 435                 if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 436                     writeRowToBackup(key, packFavorite(cursor), data);
 437                 } else {
 438                     if (DEBUG) Log.d(TAG, &quot;favorite already backup up: &quot; + id);
 439                 }
 440             }
 441         } finally {
 442             cursor.close();
 443         }
 444     }
 445 
 446     /**
 447      * Read a favorite from the stream.
 448      *
 449      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 450      *
 451      * @param key identifier for the row
 452      * @param buffer the serialized proto from the stream, may be larger than dataSize
 453      * @param dataSize the size of the proto from the stream
 454      */
 455     private void restoreFavorite(Key key, byte[] buffer, int dataSize) throws IOException {
 456         if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 457         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 458                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 459 
 460         ContentResolver cr = mContext.getContentResolver();
 461         ContentValues values = unpackFavorite(buffer, dataSize);
 462         cr.insert(Favorites.CONTENT_URI, values);
 463     }
 464 
 465     /**
 466      * Write all modified screens to the data stream.
 467      *
 468      * @param data output stream for key/value pairs
 469      * @throws IOException
 470      */
 471     private void backupScreens(BackupDataOutput data) throws IOException {
 472         // persist things that have changed since the last backup
 473         ContentResolver cr = mContext.getContentResolver();
 474         Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 475                 null, null, null);
 476         try {
 477             cursor.moveToPosition(-1);
 478             if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + mLastBackupRestoreTime);
 479             while(cursor.moveToNext()) {
 480                 final long id = cursor.getLong(ID_INDEX);
 481                 final long updateTime = cursor.getLong(ID_MODIFIED);
 482                 Key key = getKey(Key.SCREEN, id);
 483                 mKeys.add(key);
 484                 final String backupKey = keyToBackupKey(key);
 485                 if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 486                     writeRowToBackup(key, packScreen(cursor), data);
 487                 } else {
 488                     if (VERBOSE) Log.v(TAG, &quot;screen already backup up &quot; + id);
 489                 }
 490             }
 491         } finally {
 492             cursor.close();
 493         }
 494     }
 495 
 496     /**
 497      * Read a screen from the stream.
 498      *
 499      * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 500      *
 501      * @param key identifier for the row
 502      * @param buffer the serialized proto from the stream, may be larger than dataSize
 503      * @param dataSize the size of the proto from the stream
 504      */
 505     private void restoreScreen(Key key, byte[] buffer, int dataSize) throws IOException {
 506         if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 507         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 508                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 509 
 510         ContentResolver cr = mContext.getContentResolver();
 511         ContentValues values = unpackScreen(buffer, dataSize);
 512         cr.insert(WorkspaceScreens.CONTENT_URI, values);
 513     }
 514 
 515     /**
 516      * Write all the static icon resources we need to render placeholders
 517      * for a package that is not installed.
 518      *
 519      * @param data output stream for key/value pairs
 520      */
 521     private void backupIcons(BackupDataOutput data) throws IOException {
 522         // persist icons that haven&#x27;t been persisted yet
 523         final ContentResolver cr = mContext.getContentResolver();
 524         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 525         final UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 526         int backupUpIconCount = 0;
 527 
 528         // Don&#x27;t backup apps in other profiles for now.
 529         String where = &quot;(&quot; + Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION + &quot; OR &quot; +
 530                 Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_SHORTCUT + &quot;) AND &quot; +
 531                 getUserSelectionArg();
 532         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 533                 where, null, null);
 534         try {
 535             cursor.moveToPosition(-1);
 536             while(cursor.moveToNext()) {
 537                 final long id = cursor.getLong(ID_INDEX);
 538                 final String intentDescription = cursor.getString(INTENT_INDEX);
 539                 try {
 540                     Intent intent = Intent.parseUri(intentDescription, 0);
 541                     ComponentName cn = intent.getComponent();
 542                     Key key = null;
 543                     String backupKey = null;
 544                     if (cn != null) {
 545                         key = getKey(Key.ICON, cn.flattenToShortString());
 546                         backupKey = keyToBackupKey(key);
 547                     } else {
 548                         Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 549                     }
 550                     if (mExistingKeys.contains(backupKey)) {
 551                         if (DEBUG) Log.d(TAG, &quot;already saved icon &quot; + backupKey);
 552 
 553                         // remember that we already backed this up previously
 554                         mKeys.add(key);
 555                     } else if (backupKey != null) {
 556                         if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + backupUpIconCount);
 557                         if (backupUpIconCount &lt; MAX_ICONS_PER_PASS) {
 558                             if (DEBUG) Log.d(TAG, &quot;saving icon &quot; + backupKey);
 559                             Bitmap icon = mIconCache.getIcon(intent, myUserHandle);
 560                             if (icon != null &amp;&amp; !mIconCache.isDefaultIcon(icon, myUserHandle)) {
 561                                 writeRowToBackup(key, packIcon(dpi, icon), data);
 562                                 mKeys.add(key);
 563                                 backupUpIconCount ++;
 564                             }
 565                         } else {
 566                             if (VERBOSE) Log.v(TAG, &quot;deferring icon backup &quot; + backupKey);
 567                             // too many icons for this pass, request another.
 568                             dataChanged();
 569                         }
 570                     }
 571                 } catch (URISyntaxException e) {
 572                     Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 573                 } catch (IOException e) {
 574                     Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 575                 }
 576 
 577             }
 578         } finally {
 579             cursor.close();
 580         }
 581     }
 582 
 583     /**
 584      * Read an icon from the stream.
 585      *
 586      * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 587      *
 588      * @param key identifier for the row
 589      * @param buffer the serialized proto from the stream, may be larger than dataSize
 590      * @param dataSize the size of the proto from the stream
 591      */
 592     private void restoreIcon(Key key, byte[] buffer, int dataSize) throws IOException {
 593         if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 594         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 595                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 596 
 597         Resource res = unpackProto(new Resource(), buffer, dataSize);
 598         if (DEBUG) {
 599             Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 600         }
 601         Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 602         if (icon == null) {
 603             Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 604         }
 605         if (VERBOSE) Log.v(TAG, &quot;saving restored icon as: &quot; + key.name);
 606         mIconCache.preloadIcon(ComponentName.unflattenFromString(key.name), icon, res.dpi,
 607                 &quot;&quot; /* label */, mUserSerial);
 608     }
 609 
 610     /**
 611      * Write all the static widget resources we need to render placeholders
 612      * for a package that is not installed.
 613      *
 614      * @param data output stream for key/value pairs
 615      * @throws IOException
 616      */
 617     private void backupWidgets(BackupDataOutput data) throws IOException {
 618         // persist static widget info that hasn&#x27;t been persisted yet
 619         final ContentResolver cr = mContext.getContentResolver();
 620         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 621         int backupWidgetCount = 0;
 622 
 623         String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET + &quot; AND &quot;
 624                 + getUserSelectionArg();
 625         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 626                 where, null, null);
 627         try {
 628             cursor.moveToPosition(-1);
 629             while(cursor.moveToNext()) {
 630                 final long id = cursor.getLong(ID_INDEX);
 631                 final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 632                 final ComponentName provider = ComponentName.unflattenFromString(providerName);
 633                 Key key = null;
 634                 String backupKey = null;
 635                 if (provider != null) {
 636                     key = getKey(Key.WIDGET, providerName);
 637                     backupKey = keyToBackupKey(key);
 638                 } else {
 639                     Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 640                 }
 641                 if (mExistingKeys.contains(backupKey) &amp;&amp; restoredBackupVersion &gt;= BACKUP_VERSION) {
 642                     if (DEBUG) Log.d(TAG, &quot;already saved widget &quot; + backupKey);
 643 
 644                     // remember that we already backed this up previously
 645                     mKeys.add(key);
 646                 } else if (backupKey != null) {
 647                     if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + backupWidgetCount);
 648                     if (backupWidgetCount &lt; MAX_WIDGETS_PER_PASS) {
 649                         if (DEBUG) Log.d(TAG, &quot;saving widget &quot; + backupKey);
 650                         UserHandleCompat user = UserHandleCompat.myUserHandle();
 651                         writeRowToBackup(key, packWidget(dpi, provider, user), data);
 652                         mKeys.add(key);
 653                         backupWidgetCount ++;
 654                     } else {
 655                         if (VERBOSE) Log.v(TAG, &quot;deferring widget backup &quot; + backupKey);
 656                         // too many widgets for this pass, request another.
 657                         dataChanged();
 658                     }
 659                 }
 660             }
 661         } finally {
 662             cursor.close();
 663         }
 664     }
 665 
 666     /**
 667      * Read a widget from the stream.
 668      *
 669      * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 670      *
 671      * @param key identifier for the row
 672      * @param buffer the serialized proto from the stream, may be larger than dataSize
 673      * @param dataSize the size of the proto from the stream
 674      */
 675     private void restoreWidget(Key key, byte[] buffer, int dataSize) throws IOException {
 676         if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 677         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 678                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 679         Widget widget = unpackProto(new Widget(), buffer, dataSize);
 680         if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 681         if (widget.icon.data != null)  {
 682             Bitmap icon = BitmapFactory
 683                     .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 684             if (icon == null) {
 685                 Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 686             } else {
 687                 mIconCache.preloadIcon(ComponentName.unflattenFromString(widget.provider),
 688                         icon, widget.icon.dpi, widget.label, mUserSerial);
 689             }
 690         }
 691 
 692         // future site of widget table mutation
 693     }
 694 
 695     /** create a new key, with an integer ID.
 696      *
 697      * &lt;P&gt; Keys contain their own checksum instead of using
 698      * the heavy-weight CheckedMessage wrapper.
 699      */
 700     private Key getKey(int type, long id) {
 701         Key key = new Key();
 702         key.type = type;
 703         key.id = id;
 704         key.checksum = checkKey(key);
 705         return key;
 706     }
 707 
 708     /** create a new key for a named object.
 709      *
 710      * &lt;P&gt; Keys contain their own checksum instead of using
 711      * the heavy-weight CheckedMessage wrapper.
 712      */
 713     private Key getKey(int type, String name) {
 714         Key key = new Key();
 715         key.type = type;
 716         key.name = name;
 717         key.checksum = checkKey(key);
 718         return key;
 719     }
 720 
 721     /** keys need to be strings, serialize and encode. */
 722     private String keyToBackupKey(Key key) {
 723         return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 724     }
 725 
 726     /** keys need to be strings, decode and parse. */
 727     private Key backupKeyToKey(String backupKey) throws InvalidBackupException {
 728         try {
 729             Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 730             if (key.checksum != checkKey(key)) {
 731                 key = null;
 732                 throw new InvalidBackupException(&quot;invalid key read from stream&quot; + backupKey);
 733             }
 734             return key;
 735         } catch (InvalidProtocolBufferNanoException e) {
 736             throw new InvalidBackupException(e);
 737         } catch (IllegalArgumentException e) {
 738             throw new InvalidBackupException(e);
 739         }
 740     }
 741 
 742     /** Compute the checksum over the important bits of a key. */
 743     private long checkKey(Key key) {
 744         CRC32 checksum = new CRC32();
 745         checksum.update(key.type);
 746         checksum.update((int) (key.id &amp; 0xffff));
 747         checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 748         if (!TextUtils.isEmpty(key.name)) {
 749             checksum.update(key.name.getBytes());
 750         }
 751         return checksum.getValue();
 752     }
 753 
 754     /**
 755      * @return true if its an hotseat item, that can be replaced during restore.
 756      * TODO: Extend check for folders in hotseat.
 757      */
 758     private boolean isReplaceableHotseatItem(Favorite favorite) {
 759         return favorite.container == Favorites.CONTAINER_HOTSEAT
 760                 &amp;&amp; favorite.intent != null
 761                 &amp;&amp; (favorite.itemType == Favorites.ITEM_TYPE_APPLICATION
 762                 || favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT);
 763     }
 764 
 765     /** Serialize a Favorite for persistence, including a checksum wrapper. */
 766     private Favorite packFavorite(Cursor c) {
 767         Favorite favorite = new Favorite();
 768         favorite.id = c.getLong(ID_INDEX);
 769         favorite.screen = c.getInt(SCREEN_INDEX);
 770         favorite.container = c.getInt(CONTAINER_INDEX);
 771         favorite.cellX = c.getInt(CELLX_INDEX);
 772         favorite.cellY = c.getInt(CELLY_INDEX);
 773         favorite.spanX = c.getInt(SPANX_INDEX);
 774         favorite.spanY = c.getInt(SPANY_INDEX);
 775         favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 776 
 777         String title = c.getString(TITLE_INDEX);
 778         if (!TextUtils.isEmpty(title)) {
 779             favorite.title = title;
 780         }
 781         String intentDescription = c.getString(INTENT_INDEX);
 782         Intent intent = null;
 783         if (!TextUtils.isEmpty(intentDescription)) {
 784             try {
 785                 intent = Intent.parseUri(intentDescription, 0);
 786                 intent.removeExtra(ItemInfo.EXTRA_PROFILE);
 787                 favorite.intent = intent.toUri(0);
 788             } catch (URISyntaxException e) {
 789                 Log.e(TAG, &quot;Invalid intent&quot;, e);
 790             }
 791         }
 792         favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 793         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 794             favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 795             String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 796             if (!TextUtils.isEmpty(appWidgetProvider)) {
 797                 favorite.appWidgetProvider = appWidgetProvider;
 798             }
 799         } else if (favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT) {
 800             if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 801                 String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 802                 if (!TextUtils.isEmpty(iconPackage)) {
 803                     favorite.iconPackage = iconPackage;
 804                 }
 805                 String iconResource = c.getString(ICON_RESOURCE_INDEX);
 806                 if (!TextUtils.isEmpty(iconResource)) {
 807                     favorite.iconResource = iconResource;
 808                 }
 809             }
 810 
 811             byte[] blob = c.getBlob(ICON_INDEX);
 812             if (blob != null &amp;&amp; blob.length &gt; 0) {
 813                 favorite.icon = blob;
 814             }
 815         }
 816 
 817         if (isReplaceableHotseatItem(favorite)) {
 818             if (intent != null &amp;&amp; intent.getComponent() != null) {
 819                 PackageManager pm = mContext.getPackageManager();
 820                 ActivityInfo activity = null;;
 821                 try {
 822                     activity = pm.getActivityInfo(intent.getComponent(), 0);
 823                 } catch (NameNotFoundException e) {
 824                     Log.e(TAG, &quot;Target not found&quot;, e);
 825                 }
 826                 if (activity == null) {
 827                     return favorite;
 828                 }
 829                 for (int i = 0; i &lt; mItemTypeMatchers.length; i++) {
 830                     if (mItemTypeMatchers[i] == null) {
 831                         mItemTypeMatchers[i] = new ItemTypeMatcher(
 832                                 CommonAppTypeParser.getResourceForItemType(i));
 833                     }
 834                     if (mItemTypeMatchers[i].matches(activity, pm)) {
 835                         favorite.targetType = i;
 836                         break;
 837                     }
 838                 }
 839             }
 840         }
 841 
 842         return favorite;
 843     }
 844 
 845     /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 846     private ContentValues unpackFavorite(byte[] buffer, int dataSize)
 847             throws IOException {
 848         Favorite favorite = unpackProto(new Favorite(), buffer, dataSize);
 849 
 850         ContentValues values = new ContentValues();
 851         values.put(Favorites._ID, favorite.id);
 852         values.put(Favorites.SCREEN, favorite.screen);
 853         values.put(Favorites.CONTAINER, favorite.container);
 854         values.put(Favorites.CELLX, favorite.cellX);
 855         values.put(Favorites.CELLY, favorite.cellY);
 856         values.put(Favorites.SPANX, favorite.spanX);
 857         values.put(Favorites.SPANY, favorite.spanY);
 858 
 859         if (favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT) {
 860         values.put(Favorites.ICON_TYPE, favorite.iconType);
 861         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 862             values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 863             values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 864         }
 865             values.put(Favorites.ICON, favorite.icon);
 866         }
 867 
 868         if (!TextUtils.isEmpty(favorite.title)) {
 869             values.put(Favorites.TITLE, favorite.title);
 870         } else {
 871             values.put(Favorites.TITLE, &quot;&quot;);
 872         }
 873         if (!TextUtils.isEmpty(favorite.intent)) {
 874             values.put(Favorites.INTENT, favorite.intent);
 875         }
 876         values.put(Favorites.ITEM_TYPE, favorite.itemType);
 877 
 878         UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 879         long userSerialNumber =
 880                 UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHandle);
 881         values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
 882 
 883         DeviceProfieData currentProfile = mDeviceProfileData;
 884 
 885         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 886             if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 887                 values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 888             }
 889             values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 890             values.put(LauncherSettings.Favorites.RESTORED,
 891                     LauncherAppWidgetInfo.FLAG_ID_NOT_VALID |
 892                     LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY |
 893                     LauncherAppWidgetInfo.FLAG_UI_NOT_READY);
 894 
 895             // Verify placement
 896             if (((favorite.cellX + favorite.spanX) &gt; currentProfile.desktopCols)
 897                     || ((favorite.cellY + favorite.spanY) &gt; currentProfile.desktopRows)) {
 898                 restoreSuccessful = false;
 899                 throw new InvalidBackupException(&quot;Widget not in screen bounds, aborting restore&quot;);
 900             }
 901         } else {
 902             // Check if it is an hotseat item, that can be replaced.
 903             if (isReplaceableHotseatItem(favorite)
 904                     &amp;&amp; favorite.targetType != Favorite.TARGET_NONE
 905                     &amp;&amp; favorite.targetType &lt; CommonAppTypeParser.SUPPORTED_TYPE_COUNT) {
 906                 Log.e(TAG, &quot;Added item type flag&quot;);
 907                 values.put(LauncherSettings.Favorites.RESTORED,
 908                         1 | CommonAppTypeParser.encodeItemTypeToFlag(favorite.targetType));
 909             } else {
 910             // Let LauncherModel know we&#x27;ve been here.
 911             values.put(LauncherSettings.Favorites.RESTORED, 1);
 912             }
 913 
 914             // Verify placement
 915             if (favorite.container == Favorites.CONTAINER_HOTSEAT) {
 916                 if ((favorite.screen &gt;= currentProfile.hotseatCount)
 917                         || (favorite.screen == currentProfile.allappsRank)) {
 918                     restoreSuccessful = false;
 919                     throw new InvalidBackupException(&quot;Item not in hotseat bounds, aborting restore&quot;);
 920                 }
 921             } else {
 922                 if ((favorite.cellX &gt;= currentProfile.desktopCols)
 923                         || (favorite.cellY &gt;= currentProfile.desktopRows)) {
 924                     restoreSuccessful = false;
 925                     throw new InvalidBackupException(&quot;Item not in desktop bounds, aborting restore&quot;);
 926                 }
 927             }
 928         }
 929 
 930         return values;
 931     }
 932 
 933     /** Serialize a Screen for persistence, including a checksum wrapper. */
 934     private Screen packScreen(Cursor c) {
 935         Screen screen = new Screen();
 936         screen.id = c.getLong(ID_INDEX);
 937         screen.rank = c.getInt(SCREEN_RANK_INDEX);
 938         return screen;
 939     }
 940 
 941     /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 942     private ContentValues unpackScreen(byte[] buffer, int dataSize)
 943             throws InvalidProtocolBufferNanoException {
 944         Screen screen = unpackProto(new Screen(), buffer, dataSize);
 945         ContentValues values = new ContentValues();
 946         values.put(WorkspaceScreens._ID, screen.id);
 947         values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 948         return values;
 949     }
 950 
 951     /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 952     private Resource packIcon(int dpi, Bitmap icon) {
 953         Resource res = new Resource();
 954         res.dpi = dpi;
 955         res.data = Utilities.flattenBitmap(icon);
 956         return res;
 957     }
 958 
 959     /** Serialize a widget for persistence, including a checksum wrapper. */
 960     private Widget packWidget(int dpi, ComponentName provider, UserHandleCompat user) {
 961         final LauncherAppWidgetProviderInfo info =
 962                 LauncherModel.getProviderInfo(mContext, provider, user);
 963         Widget widget = new Widget();
 964         widget.provider = provider.flattenToShortString();
 965         widget.label = info.label;
 966         widget.configure = info.configure != null;
 967         if (info.icon != 0) {
 968             widget.icon = new Resource();
 969             Drawable fullResIcon = mIconCache.getFullResIcon(provider.getPackageName(), info.icon);
 970             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 971             widget.icon.data = Utilities.flattenBitmap(icon);
 972             widget.icon.dpi = dpi;
 973         }
 974 
 975         // Calculate the spans corresponding to any one of the orientations as it should not change
 976         // based on orientation.
 977         int[] minSpans = CellLayout.rectToCell(
 978                 mIdp.portraitProfile, mContext, info.minResizeWidth, info.minResizeHeight, null);
 979         widget.minSpanX = (info.resizeMode &amp; LauncherAppWidgetProviderInfo.RESIZE_HORIZONTAL) != 0
 980                 ? minSpans[0] : -1;
 981         widget.minSpanY = (info.resizeMode &amp; LauncherAppWidgetProviderInfo.RESIZE_VERTICAL) != 0
 982                 ? minSpans[1] : -1;
 983 
 984         return widget;
 985     }
 986 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
 987 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 988 private Widget packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 989             ComponentName provider, UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 990         final LauncherAppWidgetProviderInfo info =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 991                 LauncherModel.getProviderInfo(mContext, provider, user);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 992         Widget widget = new Widget();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 993         widget.provider = provider.flattenToShortString();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 994         widget.label = info.label;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 995         widget.configure = info.configure != null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 996         if (info.icon != 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 997             widget.icon = new Resource();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 998             Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 999             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1000             ByteArrayOutputStream os = new ByteArrayOutputStream();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1001             if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1002                 widget.icon.data = os.toByteArray();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1003                 widget.icon.dpi = dpi;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1004             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1005         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1006         if (info.previewImage != 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1007             widget.preview = new Resource();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1008             Bitmap preview = previewLoader.generateWidgetPreview(info, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1009             ByteArrayOutputStream os = new ByteArrayOutputStream();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1010             if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1011                 widget.preview.data = os.toByteArray();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1012                 widget.preview.dpi = dpi;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1013             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1014         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1015         return widget;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1016     }</span>
1017 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1018 private Widget packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1019             ComponentName provider, UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1020         final LauncherAppWidgetProviderInfo info =</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1021                 LauncherModel.getProviderInfo(mContext, provider, user);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1022         Widget widget = new Widget();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1023         widget.provider = provider.flattenToShortString();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1024         widget.label = info.label;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1025         widget.configure = info.configure != null;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1026         if (info.icon != 0) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1027             widget.icon = new Resource();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1028             Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1029             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1030             ByteArrayOutputStream os = new ByteArrayOutputStream();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1031             if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1032                 widget.icon.data = os.toByteArray();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1033                 widget.icon.dpi = dpi;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1034             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1035         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1036         if (info.previewImage != 0) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1037             widget.preview = new Resource();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1038             Bitmap preview = previewLoader.generateWidgetPreview(info, null);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1039             ByteArrayOutputStream os = new ByteArrayOutputStream();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1040             if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1041                 widget.preview.data = os.toByteArray();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1042                 widget.preview.dpi = dpi;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1043             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1044         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1045 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1046         widget.minSpanX = (info.resizeMode &amp; LauncherAppWidgetProviderInfo.RESIZE_HORIZONTAL) != 0</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1047                 ? info.minSpanX : -1;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1048         widget.minSpanY = (info.resizeMode &amp; LauncherAppWidgetProviderInfo.RESIZE_VERTICAL) != 0</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1049                 ? info.minSpanY : -1;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1050         return widget;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1051     }</span>
1052 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
1053 
1054 
1055     /**
1056      * Deserialize a proto after verifying checksum wrapper.
1057      */
1058     private &lt;T extends MessageNano&gt; T unpackProto(T proto, byte[] buffer, int dataSize)
1059             throws InvalidProtocolBufferNanoException {
1060         MessageNano.mergeFrom(proto, readCheckedBytes(buffer, dataSize));
1061         if (DEBUG) Log.d(TAG, &quot;unpacked proto &quot; + proto);
1062         return proto;
1063     }
1064 
1065     /**
1066      * Read the old journal from the input file.
1067      *
1068      * In the event of any error, just pretend we didn&#x27;t have a journal,
1069      * in that case, do a full backup.
1070      *
1071      * @param oldState the read-0only file descriptor pointing to the old journal
1072      * @return a Journal protocol buffer
1073      */
1074     private Journal readJournal(ParcelFileDescriptor oldState) {
1075         Journal journal = new Journal();
1076         if (oldState == null) {
1077             return journal;
1078         }
1079         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
1080         try {
1081             int availableBytes = inStream.available();
1082             if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
1083             if (availableBytes &lt; MAX_JOURNAL_SIZE) {
1084                 byte[] buffer = new byte[availableBytes];
1085                 int bytesRead = 0;
1086                 boolean valid = false;
1087                 InvalidProtocolBufferNanoException lastProtoException = null;
1088                 while (availableBytes &gt; 0) {
1089                     try {
1090                         // OMG what are you doing? This is crazy inefficient!
1091                         // If we read a byte that is not ours, we will cause trouble: b/12491813
1092                         // However, we don&#x27;t know how many bytes to expect (oops).
1093                         // So we have to step through *slowly*, watching for the end.
1094                         int result = inStream.read(buffer, bytesRead, 1);
1095                         if (result &gt; 0) {
1096                             availableBytes -= result;
1097                             bytesRead += result;
1098                         } else {
1099                             Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1100                             // stop reading and see what there is to parse
1101                             availableBytes = 0;
1102                         }
1103                     } catch (IOException e) {
1104                         buffer = null;
1105                         availableBytes = 0;
1106                     }
1107 
1108                     // check the buffer to see if we have a valid journal
1109                     try {
1110                         MessageNano.mergeFrom(journal, readCheckedBytes(buffer, bytesRead));
1111                         // if we are here, then we have read a valid, checksum-verified journal
1112                         valid = true;
1113                         availableBytes = 0;
1114                         if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1115                     } catch (InvalidProtocolBufferNanoException e) {
1116                         // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1117                         lastProtoException = e;
1118                         journal.clear();
1119                     }
1120                 }
1121                 if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1122                 if (!valid) {
1123                     Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1124                 }
1125             }
1126         } catch (IOException e) {
1127             Log.w(TAG, &quot;failed to close the journal&quot;, e);
1128         } finally {
1129             try {
1130                 inStream.close();
1131             } catch (IOException e) {
1132                 Log.w(TAG, &quot;failed to close the journal&quot;, e);
1133             }
1134         }
1135         return journal;
1136     }
1137 
1138     private void writeRowToBackup(Key key, MessageNano proto, BackupDataOutput data)
1139             throws IOException {
1140         writeRowToBackup(keyToBackupKey(key), proto, data);
1141     }
1142 
1143     private void writeRowToBackup(String backupKey, MessageNano proto,
1144             BackupDataOutput data) throws IOException {
1145         byte[] blob = writeCheckedBytes(proto);
1146         data.writeEntityHeader(backupKey, blob.length);
1147         data.writeEntityData(blob, blob.length);
1148         mBackupDataWasUpdated = true;
1149         if (VERBOSE) Log.v(TAG, &quot;Writing New entry &quot; + backupKey);
1150     }
1151 
1152     /**
1153      * Write the new journal to the output file.
1154      *
1155      * In the event of any error, just pretend we didn&#x27;t have a journal,
1156      * in that case, do a full backup.
1157 
1158      * @param newState the write-only file descriptor pointing to the new journal
1159      * @param journal a Journal protocol buffer
1160      */
1161     private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1162         FileOutputStream outStream = null;
1163         try {
1164             outStream = new FileOutputStream(newState.getFileDescriptor());
1165             final byte[] journalBytes = writeCheckedBytes(journal);
1166             outStream.write(journalBytes);
1167             outStream.close();
1168             if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1169         } catch (IOException e) {
1170             Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1171         }
1172     }
1173 
1174     /** Wrap a proto in a CheckedMessage and compute the checksum. */
1175     private byte[] writeCheckedBytes(MessageNano proto) {
1176         CheckedMessage wrapper = new CheckedMessage();
1177         wrapper.payload = MessageNano.toByteArray(proto);
1178         CRC32 checksum = new CRC32();
1179         checksum.update(wrapper.payload);
1180         wrapper.checksum = checksum.getValue();
1181         return MessageNano.toByteArray(wrapper);
1182     }
1183 
1184     /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1185     private static byte[] readCheckedBytes(byte[] buffer, int dataSize)
1186             throws InvalidProtocolBufferNanoException {
1187         CheckedMessage wrapper = new CheckedMessage();
1188         MessageNano.mergeFrom(wrapper, buffer, 0, dataSize);
1189         CRC32 checksum = new CRC32();
1190         checksum.update(wrapper.payload);
1191         if (wrapper.checksum != checksum.getValue()) {
1192             throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1193         }
1194         return wrapper.payload;
1195     }
1196 
1197     /**
1198      * @return true if the launcher is in a state to support backup
1199      */
1200     private boolean launcherIsReady() {
1201         ContentResolver cr = mContext.getContentResolver();
1202         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);
1203         if (cursor == null) {
1204             // launcher data has been wiped, do nothing
1205             return false;
1206         }
1207         cursor.close();
1208 
1209         if (LauncherAppState.getInstanceNoCreate() == null) {
1210             // launcher services are unavailable, try again later
1211             return false;
1212         }
1213 
1214         return true;
1215     }
1216 
1217     private String getUserSelectionArg() {
1218         return Favorites.PROFILE_ID + &#x27;=&#x27; + UserManagerCompat.getInstance(mContext)
1219                 .getSerialNumberForUser(UserHandleCompat.myUserHandle());
1220     }
1221 
1222     @Thunk class InvalidBackupException extends IOException {
1223 
1224         private static final long serialVersionUID = 8931456637211665082L;
1225 
1226         @Thunk InvalidBackupException(Throwable cause) {
1227             super(cause);
1228         }
1229 
1230         @Thunk InvalidBackupException(String reason) {
1231             super(reason);
1232         }
1233     }
1234 
1235     /**
1236      * A class to check if an activity can handle one of the intents from a list of
1237      * predefined intents.
1238      */
1239     private class ItemTypeMatcher {
1240 
1241         private final ArrayList&lt;Intent&gt; mIntents;
1242 
1243         ItemTypeMatcher(int xml_res) {
1244             mIntents = xml_res == 0 ? new ArrayList&lt;Intent&gt;() : parseIntents(xml_res);
1245         }
1246 
1247         private ArrayList&lt;Intent&gt; parseIntents(int xml_res) {
1248             ArrayList&lt;Intent&gt; intents = new ArrayList&lt;Intent&gt;();
1249             XmlResourceParser parser = mContext.getResources().getXml(xml_res);
1250             try {
1251                 DefaultLayoutParser.beginDocument(parser, DefaultLayoutParser.TAG_RESOLVE);
1252                 final int depth = parser.getDepth();
1253                 int type;
1254                 while (((type = parser.next()) != XmlPullParser.END_TAG ||
1255                         parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {
1256                     if (type != XmlPullParser.START_TAG) {
1257                         continue;
1258                     } else if (DefaultLayoutParser.TAG_FAVORITE.equals(parser.getName())) {
1259                         final String uri = DefaultLayoutParser.getAttributeValue(
1260                                 parser, DefaultLayoutParser.ATTR_URI);
1261                         intents.add(Intent.parseUri(uri, 0));
1262                     }
1263                 }
1264             } catch (URISyntaxException | XmlPullParserException | IOException e) {
1265                 Log.e(TAG, &quot;Unable to parse &quot; + xml_res, e);
1266             } finally {
1267                 parser.close();
1268             }
1269             return intents;
1270         }
1271 
1272         public boolean matches(ActivityInfo activity, PackageManager pm) {
1273             for (Intent intent : mIntents) {
1274                 intent.setPackage(activity.packageName);
1275                 ResolveInfo info = pm.resolveActivity(intent, 0);
1276                 if (info != null &amp;&amp; (info.activityInfo.name.equals(activity.name)
1277                         || info.activityInfo.name.equals(activity.targetActivity))) {
1278                     return true;
1279                 }
1280             }
1281             return false;
1282         }
1283     }
1284 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.app.backup.BackupDataInputStream;
  19 import android.app.backup.BackupDataOutput;
  20 import android.app.backup.BackupHelper;
  21 import android.app.backup.BackupManager;
  22 import android.content.ComponentName;
  23 import android.content.ContentResolver;
  24 import android.content.ContentValues;
  25 import android.content.Context;
  26 import android.content.Intent;
  27 import android.content.pm.ActivityInfo;
  28 import android.content.pm.PackageManager.NameNotFoundException;
  29 import android.content.pm.PackageManager;
  30 import android.content.pm.ResolveInfo;
  31 import android.content.res.XmlResourceParser;
  32 import android.database.Cursor;
  33 import android.graphics.Bitmap;
  34 import android.graphics.BitmapFactory;
  35 import android.graphics.drawable.Drawable;
  36 import android.os.ParcelFileDescriptor;
  37 import android.text.TextUtils;
  38 import android.util.Base64;
  39 import android.util.Log;
  40 import com.android.launcher3.LauncherSettings.Favorites;
  41 import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  42 import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  43 import com.android.launcher3.backup.BackupProtos.DeviceProfieData;
  44 import com.android.launcher3.backup.BackupProtos.Favorite;
  45 import com.android.launcher3.backup.BackupProtos.Journal;
  46 import com.android.launcher3.backup.BackupProtos.Key;
  47 import com.android.launcher3.backup.BackupProtos.Resource;
  48 import com.android.launcher3.backup.BackupProtos.Screen;
  49 import com.android.launcher3.backup.BackupProtos.Widget;
  50 import com.android.launcher3.backup.BackupProtos;
  51 import com.android.launcher3.compat.UserHandleCompat;
  52 import com.android.launcher3.compat.UserManagerCompat;
  53 import com.android.launcher3.util.Thunk;
  54 import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  55 import com.google.protobuf.nano.MessageNano;
  56 import java.io.FileInputStream;
  57 import java.io.FileOutputStream;
  58 import java.io.IOException;
  59 import java.net.URISyntaxException;
  60 import java.util.ArrayList;
  61 import java.util.Arrays;
  62 import java.util.HashSet;
  63 import java.util.zip.CRC32;
  64 import org.xmlpull.v1.XmlPullParser;
  65 import org.xmlpull.v1.XmlPullParserException;
  66 
  67 
  68 /**
  69  * Persist the launcher home state across calamities.
  70  */
  71 public class LauncherBackupHelper implements BackupHelper {
  72     private static final String TAG = &quot;LauncherBackupHelper&quot;;
  73 
  74     private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  75 
  76     private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  77 
  78     private static final int BACKUP_VERSION = 3;
  79 
  80     private static final int MAX_JOURNAL_SIZE = 1000000;
  81 
  82     // Journal key is such that it is always smaller than any dynamically generated
  83     // key (any Base64 encoded string).
  84     // Journal key is such that it is always smaller than any dynamically generated
  85     // key (any Base64 encoded string).
  86     private static final String JOURNAL_KEY = &quot;#&quot;;
  87 
  88     /**
  89      * icons are large, dribble them out
  90      */
  91     private static final int MAX_ICONS_PER_PASS = 10;
  92 
  93     /**
  94      * widgets contain previews, which are very large, dribble them out
  95      */
  96     private static final int MAX_WIDGETS_PER_PASS = 5;
  97 
  98     private static final String[] FAVORITE_PROJECTION = new java.lang.String[]{ Favorites._ID, // 0
  99     Favorites.MODIFIED, // 1
 100     Favorites.INTENT, // 2
 101     Favorites.APPWIDGET_PROVIDER// 3
 102     , Favorites.APPWIDGET_ID, // 4
 103     Favorites.CELLX, // 5
 104     Favorites.CELLY, // 6
 105     Favorites.CONTAINER, // 7
 106     Favorites.ICON, // 8
 107     Favorites.ICON_PACKAGE, // 9
 108     Favorites.ICON_RESOURCE, // 10
 109     Favorites.ICON_TYPE, // 11
 110     Favorites.ITEM_TYPE, // 12
 111     Favorites.SCREEN, // 13
 112     Favorites.SPANX, // 14
 113     Favorites.SPANY, // 15
 114     Favorites.TITLE, // 16
 115     Favorites.PROFILE_ID// 17
 116      };
 117 
 118     private static final int ID_INDEX = 0;
 119 
 120     private static final int ID_MODIFIED = 1;
 121 
 122     private static final int INTENT_INDEX = 2;
 123 
 124     private static final int APPWIDGET_PROVIDER_INDEX = 3;
 125 
 126     private static final int APPWIDGET_ID_INDEX = 4;
 127 
 128     private static final int CELLX_INDEX = 5;
 129 
 130     private static final int CELLY_INDEX = 6;
 131 
 132     private static final int CONTAINER_INDEX = 7;
 133 
 134     private static final int ICON_INDEX = 8;
 135 
 136     private static final int ICON_PACKAGE_INDEX = 9;
 137 
 138     private static final int ICON_RESOURCE_INDEX = 10;
 139 
 140     private static final int ICON_TYPE_INDEX = 11;
 141 
 142     private static final int ITEM_TYPE_INDEX = 12;
 143 
 144     private static final int SCREEN_INDEX = 13;
 145 
 146     private static final int SPANX_INDEX = 14;
 147 
 148     private static final int SPANY_INDEX = 15;
 149 
 150     private static final int TITLE_INDEX = 16;
 151 
 152     private static final String[] SCREEN_PROJECTION = new java.lang.String[]{ WorkspaceScreens._ID, // 0
 153     WorkspaceScreens.MODIFIED, // 1
 154     WorkspaceScreens.SCREEN_RANK// 2
 155      };
 156 
 157     private static final int SCREEN_RANK_INDEX = 2;
 158 
 159     @Thunk final Context mContext;
 160 
 161     private final HashSet&lt;String&gt; mExistingKeys;
 162 
 163     private final ArrayList&lt;Key&gt; mKeys;
 164 
 165     private final ItemTypeMatcher[] mItemTypeMatchers;
 166 
 167     private final long mUserSerial;
 168 
 169     private BackupManager mBackupManager;
 170 
 171     private byte[] mBuffer = new byte[512];
 172 
 173     private long mLastBackupRestoreTime;
 174 
 175     private boolean mBackupDataWasUpdated;
 176 
 177     private IconCache mIconCache;
 178 
 179     private DeviceProfieData mDeviceProfileData;
 180 
 181     private InvariantDeviceProfile mIdp;
 182 
 183     boolean restoreSuccessful;
 184 
 185     int restoredBackupVersion = 1;
 186 
 187     public LauncherBackupHelper(Context context) {
 188         mContext = context;
 189         mExistingKeys = new HashSet&lt;String&gt;();
 190         mKeys = new ArrayList&lt;Key&gt;();
 191         restoreSuccessful = true;
 192         mItemTypeMatchers = new ItemTypeMatcher[CommonAppTypeParser.SUPPORTED_TYPE_COUNT];
 193         UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 194         mUserSerial = userManager.getSerialNumberForUser(UserHandleCompat.myUserHandle());
 195     }
 196 
 197     private void dataChanged() {
 198         if (mBackupManager == null) {
 199             mBackupManager = new BackupManager(mContext);
 200         }
 201         mBackupManager.dataChanged();
 202     }
 203 
 204     private void applyJournal(Journal journal) {
 205         mLastBackupRestoreTime = journal.t;
 206         mExistingKeys.clear();
 207         if (journal.key != null) {
 208             for (Key key : journal.key) {
 209                 mExistingKeys.add(keyToBackupKey(key));
 210             }
 211         }
 212         restoredBackupVersion = journal.backupVersion;
 213     }
 214 
 215     /**
 216      * Back up launcher data so we can restore the user&#x27;s state on a new device.
 217      *
 218      * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 219      *
 220      * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 221      *
 222      * @param oldState notes from the last backup
 223      * @param data incremental key/value pairs to persist off-device
 224      * @param newState notes for the next backup
 225      */
 226     @Override
<abbr title=" 227     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data, ParcelFileDescriptor newState) {"> 227     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data, ParcelFileDescriptor </abbr>
 228         if (VERBOSE) {
 229             Log.v(TAG, &quot;onBackup&quot;);
 230         }
 231         Journal in = readJournal(oldState);
 232         if (!launcherIsReady()) {
 233             dataChanged();
 234             // Perform backup later.
 235             writeJournal(newState, in);
 236             return;
 237         }
 238         if (mDeviceProfileData == null) {
 239             LauncherAppState app = LauncherAppState.getInstance();
 240             mIdp = app.getInvariantDeviceProfile();
 241             mDeviceProfileData = initDeviceProfileData(mIdp);
 242             mIconCache = app.getIconCache();
 243         }
 244         Log.v(TAG, &quot;lastBackupTime = &quot; + in.t);
 245         mKeys.clear();
 246         applyJournal(in);
 247         // Record the time before performing backup so that entries edited while the backup
 248         // was going on, do not get missed in next backup.
 249         long newBackupTime = System.currentTimeMillis();
 250         mBackupDataWasUpdated = false;
 251         try {
 252             backupFavorites(data);
 253             backupScreens(data);
 254             backupIcons(data);
 255             backupWidgets(data);
 256             // Delete any key which still exist in the old backup, but is not valid anymore.
 257             HashSet&lt;String&gt; validKeys = new HashSet&lt;String&gt;();
 258             for (Key key : mKeys) {
 259                 validKeys.add(keyToBackupKey(key));
 260             }
 261             mExistingKeys.removeAll(validKeys);
 262             // Delete anything left in the existing keys.
 263             for (String deleted : mExistingKeys) {
 264                 if (VERBOSE) {
 265                     Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
 266                 }
 267                 data.writeEntityHeader(deleted, -1);
 268                 mBackupDataWasUpdated = true;
 269             }
 270             mExistingKeys.clear();
 271             if (!mBackupDataWasUpdated) {
 272                 // Check if any metadata has changed
<abbr title=" 273                 mBackupDataWasUpdated = (((in.profile == null) || (!Arrays.equals(DeviceProfieData.toByteArray(in.profile), DeviceProfieData.toByteArray(mDeviceProfileData)))) || (in.backupVersion != BACKUP_VERSION)) || (in.appVersion != getAppVersion());"> 273                 mBackupDataWasUpdated = (((in.profile == null) || (!Arrays.equals(DeviceProfieData.toByte</abbr>
 274             }
 275             if (mBackupDataWasUpdated) {
 276                 mLastBackupRestoreTime = newBackupTime;
 277                 // We store the journal at two places.
 278                 // 1) Storing it in newState allows us to do partial backups by comparing old state
 279                 // 2) Storing it in backup data allows us to validate keys during restore
 280                 Journal state = getCurrentStateJournal();
 281                 writeRowToBackup(JOURNAL_KEY, state, data);
 282             } else if (DEBUG) {
 283                 Log.d(TAG, &quot;Nothing was written during backup&quot;);
 284             }
 285         } catch (IOException e) {
 286             Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 287         }
 288         writeNewStateDescription(newState);
 289     }
 290 
 291     /**
 292      * @return true if the backup corresponding to oldstate can be successfully applied
 293      * to this device.
 294      */
 295     private boolean isBackupCompatible(Journal oldState) {
 296         DeviceProfieData currentProfile = mDeviceProfileData;
 297         DeviceProfieData oldProfile = oldState.profile;
 298         if ((oldProfile == null) || (oldProfile.desktopCols == 0)) {
 299             // Profile info is not valid, ignore the check.
 300             return true;
 301         }
 302         boolean isHotsetCompatible = false;
 303         if (currentProfile.allappsRank &gt;= oldProfile.hotseatCount) {
 304             isHotsetCompatible = true;
 305         }
<abbr title=" 306         if ((currentProfile.hotseatCount &gt;= oldProfile.hotseatCount) &amp;&amp; (currentProfile.allappsRank == oldProfile.allappsRank)) {"> 306         if ((currentProfile.hotseatCount &gt;= oldProfile.hotseatCount) &amp;&amp; (currentProfile.allappsRank == ol</abbr>
 307             isHotsetCompatible = true;
 308         }
<abbr title=" 309         return (isHotsetCompatible &amp;&amp; (currentProfile.desktopCols &gt;= oldProfile.desktopCols)) &amp;&amp; (currentProfile.desktopRows &gt;= oldProfile.desktopRows);"> 309         return (isHotsetCompatible &amp;&amp; (currentProfile.desktopCols &gt;= oldProfile.desktopCols)) &amp;&amp; (current</abbr>
 310     }
 311 
 312     /**
 313      * Restore launcher configuration from the restored data stream.
 314      * It assumes that the keys will arrive in lexical order. So if the journal was present in the
 315      * backup, it should arrive first.
 316      *
 317      * @param data the key/value pair from the server
 318      */
 319     @Override
 320     public void restoreEntity(BackupDataInputStream data) {
 321         if (!restoreSuccessful) {
 322             return;
 323         }
 324         if (mDeviceProfileData == null) {
 325             // This call does not happen on a looper thread. So LauncherAppState
 326             // can&#x27;t be created . Instead initialize required dependencies directly.
 327             mIdp = new InvariantDeviceProfile(mContext);
 328             mDeviceProfileData = initDeviceProfileData(mIdp);
 329             mIconCache = new IconCache(mContext, mIdp);
 330         }
 331         int dataSize = data.size();
 332         if (mBuffer.length &lt; dataSize) {
 333             mBuffer = new byte[dataSize];
 334         }
 335         try {
 336             int bytesRead = data.read(mBuffer, 0, dataSize);
 337             if (DEBUG) {
 338                 Log.d(TAG, (((&quot;read &quot; + bytesRead) + &quot; of &quot;) + dataSize) + &quot; available&quot;);
 339             }
 340             String backupKey = data.getKey();
 341             if (JOURNAL_KEY.equals(backupKey)) {
 342                 if (VERBOSE) {
 343                     Log.v(TAG, &quot;Journal entry restored&quot;);
 344                 }
 345                 if (!mKeys.isEmpty()) {
 346                     // We received the journal key after a restore key.
 347                     Log.wtf(TAG, (keyToBackupKey(mKeys.get(0)) + &quot; received after &quot;) + JOURNAL_KEY);
 348                     restoreSuccessful = false;
 349                     return;
 350                 }
 351                 Journal journal = new Journal();
 352                 MessageNano.mergeFrom(journal, readCheckedBytes(mBuffer, dataSize));
 353                 applyJournal(journal);
 354                 restoreSuccessful = isBackupCompatible(journal);
 355                 return;
 356             }
 357             if ((!mExistingKeys.isEmpty()) &amp;&amp; (!mExistingKeys.contains(backupKey))) {
 358                 if (DEBUG) {
 359                     Log.e(TAG, &quot;Ignoring key not present in the backup state &quot; + backupKey);
 360                 }
 361                 return;
 362             }
 363             Key key = backupKeyToKey(backupKey);
 364             mKeys.add(key);
 365             switch (key.type) {
 366                 case Key.FAVORITE :
 367                     restoreFavorite(key, mBuffer, dataSize);
 368                     break;
 369                 case Key.SCREEN :
 370                     restoreScreen(key, mBuffer, dataSize);
 371                     break;
 372                 case Key.ICON :
 373                     restoreIcon(key, mBuffer, dataSize);
 374                     break;
 375                 case Key.WIDGET :
 376                     restoreWidget(key, mBuffer, dataSize);
 377                     break;
 378                 default :
 379                     Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 380                     mKeys.remove(key);
 381                     break;
 382             }
 383         } catch (IOException e) {
 384             Log.w(TAG, &quot;ignoring unparsable backup entry&quot;, e);
 385         }
 386     }
 387 
 388     /**
 389      * Record the restore state for the next backup.
 390      *
 391      * @param newState notes about the backup state after restore.
 392      */
 393     @Override
 394     public void writeNewStateDescription(ParcelFileDescriptor newState) {
 395         writeJournal(newState, getCurrentStateJournal());
 396     }
 397 
 398     private Journal getCurrentStateJournal() {
 399         Journal journal = new Journal();
 400         journal.t = mLastBackupRestoreTime;
 401         journal.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);
 402         journal.appVersion = getAppVersion();
 403         journal.backupVersion = BACKUP_VERSION;
 404         journal.profile = mDeviceProfileData;
 405         return journal;
 406     }
 407 
 408     private int getAppVersion() {
 409         try {
 410             return mContext.getPackageManager()
 411                     .getPackageInfo(mContext.getPackageName(), 0).versionCode;
 412         } catch (NameNotFoundException e) {
 413             return 0;
 414         }
 415     }
 416 
 417     private DeviceProfieData initDeviceProfileData(InvariantDeviceProfile profile) {
 418         DeviceProfieData data = new DeviceProfieData();
 419         data.desktopRows = profile.numRows;
 420         data.desktopCols = profile.numColumns;
 421         data.hotseatCount = profile.numHotseatIcons;
 422         data.allappsRank = profile.hotseatAllAppsRank;
 423         return data;
 424     }
 425 
 426     /**
 427      * Write all modified favorites to the data stream.
 428      *
 429      * @param data output stream for key/value pairs
 430      * @throws IOException
 431      */
 432     private void backupFavorites(BackupDataOutput data) throws IOException {
 433         // persist things that have changed since the last backup
 434         ContentResolver cr = mContext.getContentResolver();
 435         // Don&#x27;t backup apps in other profiles for now.
 436         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 437                 getUserSelectionArg(), null, null);
 438         try {
 439             cursor.moveToPosition(-1);
 440             while(cursor.moveToNext()) {
 441                 final long id = cursor.getLong(ID_INDEX);
 442                 final long updateTime = cursor.getLong(ID_MODIFIED);
 443                 Key key = getKey(Key.FAVORITE, id);
 444                 mKeys.add(key);
 445                 final String backupKey = keyToBackupKey(key);
 446                 if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 447                     writeRowToBackup(key, packFavorite(cursor), data);
 448                 } else {
 449                     if (DEBUG) Log.d(TAG, &quot;favorite already backup up: &quot; + id);
 450                 }
 451             }
 452         } finally {
 453             cursor.close();
 454         }
 455     }
 456 
 457     /**
 458      * Read a favorite from the stream.
 459      *
 460      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 461      *
 462      * @param key identifier for the row
 463      * @param buffer the serialized proto from the stream, may be larger than dataSize
 464      * @param dataSize the size of the proto from the stream
 465      */
 466     private void restoreFavorite(Key key, byte[] buffer, int dataSize) throws IOException {
 467         if (VERBOSE) {
 468             Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 469         }
 470         if (DEBUG) {
<abbr title=" 471             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));"> 471             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, </abbr>
 472         }
 473         ContentResolver cr = mContext.getContentResolver();
 474         ContentValues values = unpackFavorite(buffer, dataSize);
 475         cr.insert(Favorites.CONTENT_URI, values);
 476     }
 477 
 478     /**
 479      * Write all modified screens to the data stream.
 480      *
 481      * @param data output stream for key/value pairs
 482      * @throws IOException
 483      */
 484     private void backupScreens(BackupDataOutput data) throws IOException {
 485         // persist things that have changed since the last backup
 486         ContentResolver cr = mContext.getContentResolver();
 487         Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 488                 null, null, null);
 489         try {
 490             cursor.moveToPosition(-1);
 491             if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + mLastBackupRestoreTime);
 492             while(cursor.moveToNext()) {
 493                 final long id = cursor.getLong(ID_INDEX);
 494                 final long updateTime = cursor.getLong(ID_MODIFIED);
 495                 Key key = getKey(Key.SCREEN, id);
 496                 mKeys.add(key);
 497                 final String backupKey = keyToBackupKey(key);
 498                 if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 499                     writeRowToBackup(key, packScreen(cursor), data);
 500                 } else {
 501                     if (VERBOSE) Log.v(TAG, &quot;screen already backup up &quot; + id);
 502                 }
 503             }
 504         } finally {
 505             cursor.close();
 506         }
 507     }
 508 
 509     /**
 510      * Read a screen from the stream.
 511      *
 512      * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 513      *
 514      * @param key identifier for the row
 515      * @param buffer the serialized proto from the stream, may be larger than dataSize
 516      * @param dataSize the size of the proto from the stream
 517      */
 518     private void restoreScreen(Key key, byte[] buffer, int dataSize) throws IOException {
 519         if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 520         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 521                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 522 
 523         ContentResolver cr = mContext.getContentResolver();
 524         ContentValues values = unpackScreen(buffer, dataSize);
 525         cr.insert(WorkspaceScreens.CONTENT_URI, values);
 526     }
 527 
 528     /**
 529      * Write all the static icon resources we need to render placeholders
 530      * for a package that is not installed.
 531      *
 532      * @param data output stream for key/value pairs
 533      */
 534     private void backupIcons(BackupDataOutput data) throws IOException {
 535         // persist icons that haven&#x27;t been persisted yet
 536         final ContentResolver cr = mContext.getContentResolver();
 537         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 538         final UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 539         int backupUpIconCount = 0;
 540         // Don&#x27;t backup apps in other profiles for now.
<abbr title=" 541         String where = ((((((((&quot;(&quot; + Favorites.ITEM_TYPE) + &quot;=&quot;) + Favorites.ITEM_TYPE_APPLICATION) + &quot; OR &quot;) + Favorites.ITEM_TYPE) + &quot;=&quot;) + Favorites.ITEM_TYPE_SHORTCUT) + &quot;) AND &quot;) + getUserSelectionArg();"> 541         String where = ((((((((&quot;(&quot; + Favorites.ITEM_TYPE) + &quot;=&quot;) + Favorites.ITEM_TYPE_APPLICATION) + &quot; O</abbr>
 542         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, where, null, null);
 543         try {
 544             cursor.moveToPosition(-1);
 545             while (cursor.moveToNext()) {
 546                 final long id = cursor.getLong(ID_INDEX);
 547                 final String intentDescription = cursor.getString(INTENT_INDEX);
 548                 try {
 549                     Intent intent = Intent.parseUri(intentDescription, 0);
 550                     ComponentName cn = intent.getComponent();
 551                     Key key = null;
 552                     String backupKey = null;
 553                     if (cn != null) {
 554                         key = getKey(Key.ICON, cn.flattenToShortString());
 555                         backupKey = keyToBackupKey(key);
 556                     } else {
 557                         Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 558                     }
 559                     if (mExistingKeys.contains(backupKey)) {
 560                         if (DEBUG) {
 561                             Log.d(TAG, &quot;already saved icon &quot; + backupKey);
 562                         }
 563                         // remember that we already backed this up previously
 564                         mKeys.add(key);
 565                     } else if (backupKey != null) {
 566                         if (DEBUG) {
 567                             Log.d(TAG, &quot;I can count this high: &quot; + backupUpIconCount);
 568                         }
 569                         if (backupUpIconCount &lt; MAX_ICONS_PER_PASS) {
 570                             if (DEBUG) {
 571                                 Log.d(TAG, &quot;saving icon &quot; + backupKey);
 572                             }
 573                             Bitmap icon = mIconCache.getIcon(intent, myUserHandle);
 574                             if ((icon != null) &amp;&amp; (!mIconCache.isDefaultIcon(icon, myUserHandle))) {
 575                                 writeRowToBackup(key, packIcon(dpi, icon), data);
 576                                 mKeys.add(key);
 577                                 backupUpIconCount++;
 578                             }
 579                         } else {
 580                             if (VERBOSE) {
 581                                 Log.v(TAG, &quot;deferring icon backup &quot; + backupKey);
 582                             }
 583                             // too many icons for this pass, request another.
 584                             dataChanged();
 585                         }
 586                     }
 587                 } catch (URISyntaxException e) {
 588                     Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 589                 } catch (IOException e) {
 590                     Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 591                 }
 592             }
 593         } finally {
 594             cursor.close();
 595         }
 596     }
 597 
 598     /**
 599      * Read an icon from the stream.
 600      *
 601      * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 602      *
 603      * @param key identifier for the row
 604      * @param buffer the serialized proto from the stream, may be larger than dataSize
 605      * @param dataSize the size of the proto from the stream
 606      */
 607     private void restoreIcon(Key key, byte[] buffer, int dataSize) throws IOException {
 608         if (VERBOSE) {
 609             Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 610         }
 611         if (DEBUG) {
<abbr title=" 612             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));"> 612             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, </abbr>
 613         }
 614         Resource res = unpackProto(new Resource(), buffer, dataSize);
 615         if (DEBUG) {
 616             Log.d(TAG, (&quot;unpacked &quot; + res.dpi) + &quot; dpi icon&quot;);
 617         }
 618         Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 619         if (icon == null) {
 620             Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 621         }
 622         if (VERBOSE) {
 623             Log.v(TAG, &quot;saving restored icon as: &quot; + key.name);
 624         }
 625                 /* label */
<abbr title=" 626         mIconCache.preloadIcon(ComponentName.unflattenFromString(key.name), icon, res.dpi, &quot;&quot;, mUserSerial);"> 626         mIconCache.preloadIcon(ComponentName.unflattenFromString(key.name), icon, res.dpi, &quot;&quot;, mUserSeria</abbr>
 627     }
 628 
 629     /**
 630      * Write all the static widget resources we need to render placeholders
 631      * for a package that is not installed.
 632      *
 633      * @param data output stream for key/value pairs
 634      * @throws IOException
 635      */
 636     private void backupWidgets(BackupDataOutput data) throws IOException {
 637         // persist static widget info that hasn&#x27;t been persisted yet
 638         final ContentResolver cr = mContext.getContentResolver();
 639         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 640         int backupWidgetCount = 0;
<abbr title=" 641         String where = (((Favorites.ITEM_TYPE + &quot;=&quot;) + Favorites.ITEM_TYPE_APPWIDGET) + &quot; AND &quot;) + getUserSelectionArg();"> 641         String where = (((Favorites.ITEM_TYPE + &quot;=&quot;) + Favorites.ITEM_TYPE_APPWIDGET) + &quot; AND &quot;) + getUse</abbr>
 642         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, where, null, null);
 643         try {
 644             cursor.moveToPosition(-1);
 645             while (cursor.moveToNext()) {
 646                 final long id = cursor.getLong(ID_INDEX);
 647                 final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 648                 final ComponentName provider = ComponentName.unflattenFromString(providerName);
 649                 Key key = null;
 650                 String backupKey = null;
 651                 if (provider != null) {
 652                     key = getKey(Key.WIDGET, providerName);
 653                     backupKey = keyToBackupKey(key);
 654                 } else {
 655                     Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 656                 }
 657                 if (mExistingKeys.contains(backupKey) &amp;&amp; (restoredBackupVersion &gt;= BACKUP_VERSION)) {
 658                     if (DEBUG) {
 659                         Log.d(TAG, &quot;already saved widget &quot; + backupKey);
 660                     }
 661                     // remember that we already backed this up previously
 662                     mKeys.add(key);
 663                 } else if (backupKey != null) {
 664                     if (DEBUG) {
 665                         Log.d(TAG, &quot;I can count this high: &quot; + backupWidgetCount);
 666                     }
 667                     if (backupWidgetCount &lt; MAX_WIDGETS_PER_PASS) {
 668                         if (DEBUG) {
 669                             Log.d(TAG, &quot;saving widget &quot; + backupKey);
 670                         }
 671                         UserHandleCompat user = UserHandleCompat.myUserHandle();
 672                         writeRowToBackup(key, packWidget(dpi, provider, user), data);
 673                         mKeys.add(key);
 674                         backupWidgetCount++;
 675                     } else {
 676                         if (VERBOSE) {
 677                             Log.v(TAG, &quot;deferring widget backup &quot; + backupKey);
 678                         }
 679                         // too many widgets for this pass, request another.
 680                         dataChanged();
 681                     }
 682                 }
 683             }
 684         } finally {
 685             cursor.close();
 686         }
 687     }
 688 
 689     /**
 690      * Read a widget from the stream.
 691      *
 692      * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 693      *
 694      * @param key identifier for the row
 695      * @param buffer the serialized proto from the stream, may be larger than dataSize
 696      * @param dataSize the size of the proto from the stream
 697      */
 698     private void restoreWidget(Key key, byte[] buffer, int dataSize) throws IOException {
 699         if (VERBOSE) {
 700             Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 701         }
 702         if (DEBUG) {
<abbr title=" 703             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));"> 703             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, </abbr>
 704         }
 705         Widget widget = unpackProto(new Widget(), buffer, dataSize);
 706         if (DEBUG) {
 707             Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 708         }
 709         if (widget.icon.data != null) {
 710             Bitmap icon = BitmapFactory.decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 711             if (icon == null) {
 712                 Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 713             } else {
<abbr title=" 714                 mIconCache.preloadIcon(ComponentName.unflattenFromString(widget.provider), icon, widget.icon.dpi, widget.label, mUserSerial);"> 714                 mIconCache.preloadIcon(ComponentName.unflattenFromString(widget.provider), icon, widget.i</abbr>
 715             }
 716         }
 717         // future site of widget table mutation
 718     }
 719 
 720     /** create a new key, with an integer ID.
 721      *
 722      * &lt;P&gt; Keys contain their own checksum instead of using
 723      * the heavy-weight CheckedMessage wrapper.
 724      */
 725     private Key getKey(int type, long id) {
 726         Key key = new Key();
 727         key.type = type;
 728         key.id = id;
 729         key.checksum = checkKey(key);
 730         return key;
 731     }
 732 
 733     /** create a new key for a named object.
 734      *
 735      * &lt;P&gt; Keys contain their own checksum instead of using
 736      * the heavy-weight CheckedMessage wrapper.
 737      */
 738     private Key getKey(int type, String name) {
 739         Key key = new Key();
 740         key.type = type;
 741         key.name = name;
 742         key.checksum = checkKey(key);
 743         return key;
 744     }
 745 
 746     /** keys need to be strings, serialize and encode. */
 747     private String keyToBackupKey(Key key) {
 748         return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 749     }
 750 
 751     /** keys need to be strings, decode and parse. */
 752     private Key backupKeyToKey(String backupKey) throws InvalidBackupException {
 753         try {
 754             Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 755             if (key.checksum != checkKey(key)) {
 756                 key = null;
 757                 throw new InvalidBackupException(&quot;invalid key read from stream&quot; + backupKey);
 758             }
 759             return key;
 760         } catch (InvalidProtocolBufferNanoException e) {
 761             throw new InvalidBackupException(e);
 762         } catch (IllegalArgumentException e) {
 763             throw new InvalidBackupException(e);
 764         }
 765     }
 766 
 767     /** Compute the checksum over the important bits of a key. */
 768     private long checkKey(Key key) {
 769         CRC32 checksum = new CRC32();
 770         checksum.update(key.type);
 771         checksum.update((int) (key.id &amp; 0xffff));
 772         checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 773         if (!TextUtils.isEmpty(key.name)) {
 774             checksum.update(key.name.getBytes());
 775         }
 776         return checksum.getValue();
 777     }
 778 
 779     /**
 780      * @return the current device profile information.
 781      */
 782     private boolean isReplaceableHotseatItem(Favorite favorite) {
<abbr title=" 783         return ((favorite.container == Favorites.CONTAINER_HOTSEAT) &amp;&amp; (favorite.intent != null)) &amp;&amp; ((favorite.itemType == Favorites.ITEM_TYPE_APPLICATION) || (favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT));"> 783         return ((favorite.container == Favorites.CONTAINER_HOTSEAT) &amp;&amp; (favorite.intent != null)) &amp;&amp; ((fa</abbr>
 784     }
 785 
 786     /** Serialize a Favorite for persistence, including a checksum wrapper. */
 787     private Favorite packFavorite(Cursor c) {
 788         Favorite favorite = new Favorite();
 789         favorite.id = c.getLong(ID_INDEX);
 790         favorite.screen = c.getInt(SCREEN_INDEX);
 791         favorite.container = c.getInt(CONTAINER_INDEX);
 792         favorite.cellX = c.getInt(CELLX_INDEX);
 793         favorite.cellY = c.getInt(CELLY_INDEX);
 794         favorite.spanX = c.getInt(SPANX_INDEX);
 795         favorite.spanY = c.getInt(SPANY_INDEX);
 796         favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 797         String title = c.getString(TITLE_INDEX);
 798         if (!TextUtils.isEmpty(title)) {
 799             favorite.title = title;
 800         }
 801         String intentDescription = c.getString(INTENT_INDEX);
 802         Intent intent = null;
 803         if (!TextUtils.isEmpty(intentDescription)) {
 804             try {
 805                 intent = Intent.parseUri(intentDescription, 0);
 806                 intent.removeExtra(ItemInfo.EXTRA_PROFILE);
 807                 favorite.intent = intent.toUri(0);
 808             } catch (URISyntaxException e) {
 809                 Log.e(TAG, &quot;Invalid intent&quot;, e);
 810             }
 811         }
 812         favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 813         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 814             favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 815             String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 816             if (!TextUtils.isEmpty(appWidgetProvider)) {
 817                 favorite.appWidgetProvider = appWidgetProvider;
 818             }
 819         } else if (favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT) {
 820             if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 821                 String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 822                 if (!TextUtils.isEmpty(iconPackage)) {
 823                     favorite.iconPackage = iconPackage;
 824                 }
 825                 String iconResource = c.getString(ICON_RESOURCE_INDEX);
 826                 if (!TextUtils.isEmpty(iconResource)) {
 827                     favorite.iconResource = iconResource;
 828                 }
 829             }
 830             byte[] blob = c.getBlob(ICON_INDEX);
 831             if ((blob != null) &amp;&amp; (blob.length &gt; 0)) {
 832                 favorite.icon = blob;
 833             }
 834         }
 835         if (isReplaceableHotseatItem(favorite)) {
 836             if ((intent != null) &amp;&amp; (intent.getComponent() != null)) {
 837                 PackageManager pm = mContext.getPackageManager();
 838                 ActivityInfo activity = null;
 839                 try {
 840                     activity = pm.getActivityInfo(intent.getComponent(), 0);
 841                 } catch (NameNotFoundException e) {
 842                     Log.e(TAG, &quot;Target not found&quot;, e);
 843                 }
 844                 if (activity == null) {
 845                     return favorite;
 846                 }
 847                 for (int i = 0; i &lt; mItemTypeMatchers.length; i++) {
 848                     if (mItemTypeMatchers[i] == null) {
<abbr title=" 849                         mItemTypeMatchers[i] = new ItemTypeMatcher(CommonAppTypeParser.getResourceForItemType(i));"> 849                         mItemTypeMatchers[i] = new ItemTypeMatcher(CommonAppTypeParser.getResourceForItem</abbr>
 850                     }
 851                     if (mItemTypeMatchers[i].matches(activity, pm)) {
 852                         favorite.targetType = i;
 853                         break;
 854                     }
 855                 }
 856             }
 857         }
 858         return favorite;
 859     }
 860 
 861     /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 862     private ContentValues unpackFavorite(byte[] buffer, int dataSize) throws IOException {
 863         Favorite favorite = unpackProto(new Favorite(), buffer, dataSize);
 864         ContentValues values = new ContentValues();
 865         values.put(Favorites._ID, favorite.id);
 866         values.put(Favorites.SCREEN, favorite.screen);
 867         values.put(Favorites.CONTAINER, favorite.container);
 868         values.put(Favorites.CELLX, favorite.cellX);
 869         values.put(Favorites.CELLY, favorite.cellY);
 870         values.put(Favorites.SPANX, favorite.spanX);
 871         values.put(Favorites.SPANY, favorite.spanY);
 872         if (favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT) {
 873             values.put(Favorites.ICON_TYPE, favorite.iconType);
 874             if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 875                 values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 876                 values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 877             }
 878             values.put(Favorites.ICON, favorite.icon);
 879         }
 880         if (!TextUtils.isEmpty(favorite.title)) {
 881             values.put(Favorites.TITLE, favorite.title);
 882         } else {
 883             values.put(Favorites.TITLE, &quot;&quot;);
 884         }
 885         if (!TextUtils.isEmpty(favorite.intent)) {
 886             values.put(Favorites.INTENT, favorite.intent);
 887         }
 888         values.put(Favorites.ITEM_TYPE, favorite.itemType);
 889         UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
<abbr title=" 890         long userSerialNumber = UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHandle);"> 890         long userSerialNumber = UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHand</abbr>
 891         values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
 892         DeviceProfieData currentProfile = mDeviceProfileData;
 893         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 894             if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 895                 values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 896             }
 897             values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
<abbr title=" 898             values.put(LauncherSettings.Favorites.RESTORED, (LauncherAppWidgetInfo.FLAG_ID_NOT_VALID | LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) | LauncherAppWidgetInfo.FLAG_UI_NOT_READY);"> 898             values.put(LauncherSettings.Favorites.RESTORED, (LauncherAppWidgetInfo.FLAG_ID_NOT_VALID | La</abbr>
 899             // Verify placement
<abbr title=" 900             if (((favorite.cellX + favorite.spanX) &gt; currentProfile.desktopCols) || ((favorite.cellY + favorite.spanY) &gt; currentProfile.desktopRows)) {"> 900             if (((favorite.cellX + favorite.spanX) &gt; currentProfile.desktopCols) || ((favorite.cellY + fa</abbr>
 901                 restoreSuccessful = false;
 902                 throw new InvalidBackupException(&quot;Widget not in screen bounds, aborting restore&quot;);
 903             }
 904         } else {
 905             // Check if it is an hotseat item, that can be replaced.
<abbr title=" 906             if ((isReplaceableHotseatItem(favorite) &amp;&amp; (favorite.targetType != Favorite.TARGET_NONE)) &amp;&amp; (favorite.targetType &lt; CommonAppTypeParser.SUPPORTED_TYPE_COUNT)) {"> 906             if ((isReplaceableHotseatItem(favorite) &amp;&amp; (favorite.targetType != Favorite.TARGET_NONE)) &amp;&amp; </abbr>
 907                 Log.e(TAG, &quot;Added item type flag&quot;);
<abbr title=" 908                 values.put(LauncherSettings.Favorites.RESTORED, 1 | CommonAppTypeParser.encodeItemTypeToFlag(favorite.targetType));"> 908                 values.put(LauncherSettings.Favorites.RESTORED, 1 | CommonAppTypeParser.encodeItemTypeToF</abbr>
 909             } else {
 910                 // Let LauncherModel know we&#x27;ve been here.
 911                 values.put(LauncherSettings.Favorites.RESTORED, 1);
 912             }
 913             // Verify placement
 914             if (favorite.container == Favorites.CONTAINER_HOTSEAT) {
<abbr title=" 915                 if ((favorite.screen &gt;= currentProfile.hotseatCount) || (favorite.screen == currentProfile.allappsRank)) {"> 915                 if ((favorite.screen &gt;= currentProfile.hotseatCount) || (favorite.screen == currentProfil</abbr>
 916                     restoreSuccessful = false;
 917                     throw new InvalidBackupException(&quot;Item not in hotseat bounds, aborting restore&quot;);
 918                 }
<abbr title=" 919             } else if ((favorite.cellX &gt;= currentProfile.desktopCols) || (favorite.cellY &gt;= currentProfile.desktopRows)) {"> 919             } else if ((favorite.cellX &gt;= currentProfile.desktopCols) || (favorite.cellY &gt;= currentProfil</abbr>
 920                 restoreSuccessful = false;
 921                 throw new InvalidBackupException(&quot;Item not in desktop bounds, aborting restore&quot;);
 922             }
 923         }
 924         return values;
 925     }
 926 
 927     /** Serialize a Screen for persistence, including a checksum wrapper. */
 928     private Screen packScreen(Cursor c) {
 929         Screen screen = new Screen();
 930         screen.id = c.getLong(ID_INDEX);
 931         screen.rank = c.getInt(SCREEN_RANK_INDEX);
 932         return screen;
 933     }
 934 
 935     /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 936     private ContentValues unpackScreen(byte[] buffer, int dataSize)
 937             throws InvalidProtocolBufferNanoException {
 938         Screen screen = unpackProto(new Screen(), buffer, dataSize);
 939         ContentValues values = new ContentValues();
 940         values.put(WorkspaceScreens._ID, screen.id);
 941         values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 942         return values;
 943     }
 944 
 945     /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 946     private Resource packIcon(int dpi, Bitmap icon) {
 947         Resource res = new Resource();
 948         res.dpi = dpi;
 949         res.data = Utilities.flattenBitmap(icon);
 950         return res;
 951     }
 952 
 953     /** Serialize a widget for persistence, including a checksum wrapper. */
 954     private Widget packWidget(int dpi, ComponentName provider, UserHandleCompat user) {
<abbr title=" 955         final LauncherAppWidgetProviderInfo info = LauncherModel.getProviderInfo(mContext, provider, user);"> 955         final LauncherAppWidgetProviderInfo info = LauncherModel.getProviderInfo(mContext, provider, user</abbr>
 956         Widget widget = new Widget();
 957         widget.provider = provider.flattenToShortString();
 958         widget.label = info.label;
 959         widget.configure = info.configure != null;
 960         if (info.icon != 0) {
 961             widget.icon = new Resource();
 962             Drawable fullResIcon = mIconCache.getFullResIcon(provider.getPackageName(), info.icon);
 963             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 964             widget.icon.data = Utilities.flattenBitmap(icon);
 965             widget.icon.dpi = dpi;
 966         }
 967         // Calculate the spans corresponding to any one of the orientations as it should not change
 968         // based on orientation.
<abbr title=" 969         int[] minSpans = CellLayout.rectToCell(mIdp.portraitProfile, mContext, info.minResizeWidth, info.minResizeHeight, null);"> 969         int[] minSpans = CellLayout.rectToCell(mIdp.portraitProfile, mContext, info.minResizeWidth, info.</abbr>
<abbr title=" 970         widget.minSpanX = ((info.resizeMode &amp; LauncherAppWidgetProviderInfo.RESIZE_HORIZONTAL) != 0) ? minSpans[0] : -1;"> 970         widget.minSpanX = ((info.resizeMode &amp; LauncherAppWidgetProviderInfo.RESIZE_HORIZONTAL) != 0) ? mi</abbr>
<abbr title=" 971         widget.minSpanY = ((info.resizeMode &amp; LauncherAppWidgetProviderInfo.RESIZE_VERTICAL) != 0) ? minSpans[1] : -1;"> 971         widget.minSpanY = ((info.resizeMode &amp; LauncherAppWidgetProviderInfo.RESIZE_VERTICAL) != 0) ? minS</abbr>
 972         return widget;
 973     }
 974 
 975     /**
 976      * Deserialize a proto after verifying checksum wrapper.
 977      */
 978     private &lt;T extends MessageNano&gt; T unpackProto(T proto, byte[] buffer, int dataSize)
 979             throws InvalidProtocolBufferNanoException {
 980         MessageNano.mergeFrom(proto, readCheckedBytes(buffer, dataSize));
 981         if (DEBUG) Log.d(TAG, &quot;unpacked proto &quot; + proto);
 982         return proto;
 983     }
 984 
 985     /**
 986      * Read the old journal from the input file.
 987      *
 988      * In the event of any error, just pretend we didn&#x27;t have a journal,
 989      * in that case, do a full backup.
 990      *
 991      * @param oldState the read-0only file descriptor pointing to the old journal
 992      * @return a Journal protocol buffer
 993      */
 994     private Journal readJournal(ParcelFileDescriptor oldState) {
 995         Journal journal = new Journal();
 996         if (oldState == null) {
 997             return journal;
 998         }
 999         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
1000         try {
1001             int availableBytes = inStream.available();
1002             if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
1003             if (availableBytes &lt; MAX_JOURNAL_SIZE) {
1004                 byte[] buffer = new byte[availableBytes];
1005                 int bytesRead = 0;
1006                 boolean valid = false;
1007                 InvalidProtocolBufferNanoException lastProtoException = null;
1008                 while (availableBytes &gt; 0) {
1009                     try {
1010                         // OMG what are you doing? This is crazy inefficient!
1011                         // If we read a byte that is not ours, we will cause trouble: b/12491813
1012                         // However, we don&#x27;t know how many bytes to expect (oops).
1013                         // So we have to step through *slowly*, watching for the end.
1014                         int result = inStream.read(buffer, bytesRead, 1);
1015                         if (result &gt; 0) {
1016                             availableBytes -= result;
1017                             bytesRead += result;
1018                         } else {
1019                             Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1020                             // stop reading and see what there is to parse
1021                             availableBytes = 0;
1022                         }
1023                     } catch (IOException e) {
1024                         buffer = null;
1025                         availableBytes = 0;
1026                     }
1027 
1028                     // check the buffer to see if we have a valid journal
1029                     try {
1030                         MessageNano.mergeFrom(journal, readCheckedBytes(buffer, bytesRead));
1031                         // if we are here, then we have read a valid, checksum-verified journal
1032                         valid = true;
1033                         availableBytes = 0;
1034                         if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1035                     } catch (InvalidProtocolBufferNanoException e) {
1036                         // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1037                         lastProtoException = e;
1038                         journal.clear();
1039                     }
1040                 }
1041                 if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1042                 if (!valid) {
1043                     Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1044                 }
1045             }
1046         } catch (IOException e) {
1047             Log.w(TAG, &quot;failed to close the journal&quot;, e);
1048         } finally {
1049             try {
1050                 inStream.close();
1051             } catch (IOException e) {
1052                 Log.w(TAG, &quot;failed to close the journal&quot;, e);
1053             }
1054         }
1055         return journal;
1056     }
1057 
1058     private void writeRowToBackup(Key key, MessageNano proto, BackupDataOutput data)
1059             throws IOException {
1060         writeRowToBackup(keyToBackupKey(key), proto, data);
1061     }
1062 
1063     private void writeRowToBackup(String backupKey, MessageNano proto,
1064             BackupDataOutput data) throws IOException {
1065         byte[] blob = writeCheckedBytes(proto);
1066         data.writeEntityHeader(backupKey, blob.length);
1067         data.writeEntityData(blob, blob.length);
1068         mBackupDataWasUpdated = true;
1069         if (VERBOSE) Log.v(TAG, &quot;Writing New entry &quot; + backupKey);
1070     }
1071 
1072     /**
1073      * Write the new journal to the output file.
1074      *
1075      * In the event of any error, just pretend we didn&#x27;t have a journal,
1076      * in that case, do a full backup.
1077 
1078      * @param newState the write-only file descriptor pointing to the new journal
1079      * @param journal a Journal protocol buffer
1080      */
1081     private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1082         FileOutputStream outStream = null;
1083         try {
1084             outStream = new FileOutputStream(newState.getFileDescriptor());
1085             final byte[] journalBytes = writeCheckedBytes(journal);
1086             outStream.write(journalBytes);
1087             outStream.close();
1088             if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1089         } catch (IOException e) {
1090             Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1091         }
1092     }
1093 
1094     /** Wrap a proto in a CheckedMessage and compute the checksum. */
1095     private byte[] writeCheckedBytes(MessageNano proto) {
1096         CheckedMessage wrapper = new CheckedMessage();
1097         wrapper.payload = MessageNano.toByteArray(proto);
1098         CRC32 checksum = new CRC32();
1099         checksum.update(wrapper.payload);
1100         wrapper.checksum = checksum.getValue();
1101         return MessageNano.toByteArray(wrapper);
1102     }
1103 
1104     /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1105     private static byte[] readCheckedBytes(byte[] buffer, int dataSize)
1106             throws InvalidProtocolBufferNanoException {
1107         CheckedMessage wrapper = new CheckedMessage();
1108         MessageNano.mergeFrom(wrapper, buffer, 0, dataSize);
1109         CRC32 checksum = new CRC32();
1110         checksum.update(wrapper.payload);
1111         if (wrapper.checksum != checksum.getValue()) {
1112             throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1113         }
1114         return wrapper.payload;
1115     }
1116 
1117     /**
1118      * @return true if the launcher is in a state to support backup
1119      */
1120     private boolean launcherIsReady() {
1121         ContentResolver cr = mContext.getContentResolver();
1122         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);
1123         if (cursor == null) {
1124             // launcher data has been wiped, do nothing
1125             return false;
1126         }
1127         cursor.close();
1128         if (LauncherAppState.getInstanceNoCreate() == null) {
1129             // launcher services are unavailable, try again later
1130             return false;
1131         }
1132         return true;
1133     }
1134 
1135     private String getUserSelectionArg() {
1136         return Favorites.PROFILE_ID + &#x27;=&#x27; + UserManagerCompat.getInstance(mContext)
1137                 .getSerialNumberForUser(UserHandleCompat.myUserHandle());
1138     }
1139 
1140     @Thunk
1141     class InvalidBackupException extends IOException {
1142         private static final long serialVersionUID = 8931456637211665082L;
1143 
1144         @Thunk
1145         InvalidBackupException(Throwable cause) {
1146             super(cause);
1147         }
1148 
1149         @Thunk
1150         InvalidBackupException(String reason) {
1151             super(reason);
1152         }
1153     }
1154 
1155     /**
1156      * A class to check if an activity can handle one of the intents from a list of
1157      * predefined intents.
1158      */
1159     private class ItemTypeMatcher {
1160         private final ArrayList&lt;Intent&gt; mIntents;
1161 
1162         ItemTypeMatcher(int xml_res) {
1163             mIntents = (xml_res == 0) ? new ArrayList&lt;Intent&gt;() : parseIntents(xml_res);
1164         }
1165 
1166         private ArrayList&lt;Intent&gt; parseIntents(int xml_res) {
1167             ArrayList&lt;Intent&gt; intents = new ArrayList&lt;Intent&gt;();
1168             XmlResourceParser parser = mContext.getResources().getXml(xml_res);
1169             try {
1170                 DefaultLayoutParser.beginDocument(parser, DefaultLayoutParser.TAG_RESOLVE);
1171                 final int depth = parser.getDepth();
1172                 int type;
<abbr title="1173                 while ((((type = parser.next()) != XmlPullParser.END_TAG) || (parser.getDepth() &gt; depth)) &amp;&amp; (type != XmlPullParser.END_DOCUMENT)) {">1173                 while ((((type = parser.next()) != XmlPullParser.END_TAG) || (parser.getDepth() &gt; depth))</abbr>
1174                     if (type != XmlPullParser.START_TAG) {
1175                         continue;
1176                     } else if (DefaultLayoutParser.TAG_FAVORITE.equals(parser.getName())) {
<abbr title="1177                         final String uri = DefaultLayoutParser.getAttributeValue(parser, DefaultLayoutParser.ATTR_URI);">1177                         final String uri = DefaultLayoutParser.getAttributeValue(parser, DefaultLayoutPar</abbr>
1178                         intents.add(Intent.parseUri(uri, 0));
1179                     }
1180                 }
1181             } catch (URISyntaxException | XmlPullParserException | IOException e) {
1182                 Log.e(TAG, &quot;Unable to parse &quot; + xml_res, e);
1183             } finally {
1184                 parser.close();
1185             }
1186             return intents;
1187         }
1188 
1189         public boolean matches(ActivityInfo activity, PackageManager pm) {
1190             for (Intent intent : mIntents) {
1191                 intent.setPackage(activity.packageName);
1192                 ResolveInfo info = pm.resolveActivity(intent, 0);
<abbr title="1193                 if ((info != null) &amp;&amp; (info.activityInfo.name.equals(activity.name) || info.activityInfo.name.equals(activity.targetActivity))) {">1193                 if ((info != null) &amp;&amp; (info.activityInfo.name.equals(activity.name) || info.activityInfo.</abbr>
1194                     return true;
1195                 }
1196             }
1197             return false;
1198         }
1199     }
1200 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2013 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  package com.android.launcher3;
  17  
  18  import android.app.backup.BackupDataInputStream;
  19  import android.app.backup.BackupDataOutput;
  20  import android.app.backup.BackupHelper;
  21  import android.app.backup.BackupManager;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  22 -import android.appwidget.AppWidgetProviderInfo;</span>
  23  import android.content.ComponentName;
  24  import android.content.ContentResolver;
  25  import android.content.ContentValues;
  26  import android.content.Context;
  27  import android.content.Intent;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  28 +import android.content.pm.ActivityInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 +import android.content.pm.PackageManager;</span>
  30  import android.content.pm.PackageManager.NameNotFoundException;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  31 +import android.content.pm.ResolveInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  32 +import android.content.res.XmlResourceParser;</span>
  33  import android.database.Cursor;
  34  import android.graphics.Bitmap;
  35  import android.graphics.BitmapFactory;
  36  import android.graphics.drawable.Drawable;
  37  import android.os.ParcelFileDescriptor;
  38  import android.text.TextUtils;
  39  import android.util.Base64;
  40  import android.util.Log;
  41  
  42  import com.android.launcher3.LauncherSettings.Favorites;
  43  import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  44  import com.android.launcher3.backup.BackupProtos;
  45  import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  46  import com.android.launcher3.backup.BackupProtos.DeviceProfieData;
  47  import com.android.launcher3.backup.BackupProtos.Favorite;
  48  import com.android.launcher3.backup.BackupProtos.Journal;
  49  import com.android.launcher3.backup.BackupProtos.Key;
  50  import com.android.launcher3.backup.BackupProtos.Resource;
  51  import com.android.launcher3.backup.BackupProtos.Screen;
  52  import com.android.launcher3.backup.BackupProtos.Widget;
  53  import com.android.launcher3.compat.UserHandleCompat;
  54  import com.android.launcher3.compat.UserManagerCompat;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  55 +import com.android.launcher3.util.Thunk;</span>
  56  import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  57  import com.google.protobuf.nano.MessageNano;
  58  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  59 -import java.io.ByteArrayOutputStream;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  60 +import org.xmlpull.v1.XmlPullParser;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  61 +import org.xmlpull.v1.XmlPullParserException;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  62 +</span>
  63  import java.io.FileInputStream;
  64  import java.io.FileOutputStream;
  65  import java.io.IOException;
  66  import java.net.URISyntaxException;
  67  import java.util.ArrayList;
  68  import java.util.Arrays;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  69 -import java.util.HashMap;</span>
  70  import java.util.HashSet;
  71  import java.util.zip.CRC32;
  72  
  73  /**
  74   * Persist the launcher home state across calamities.
  75   */
  76  public class LauncherBackupHelper implements BackupHelper {
  77      private static final String TAG = &quot;LauncherBackupHelper&quot;;
  78      private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  79      private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  80  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  81 -    private static final int BACKUP_VERSION = 2;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  82 +    private static final int BACKUP_VERSION = 3;</span>
  83      private static final int MAX_JOURNAL_SIZE = 1000000;
  84  
  85      // Journal key is such that it is always smaller than any dynamically generated
  86      // key (any Base64 encoded string).
  87      private static final String JOURNAL_KEY = &quot;#&quot;;
  88  
  89      /** icons are large, dribble them out */
  90      private static final int MAX_ICONS_PER_PASS = 10;
  91  
  92      /** widgets contain previews, which are very large, dribble them out */
  93      private static final int MAX_WIDGETS_PER_PASS = 5;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  94 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  95 -    private static final int IMAGE_COMPRESSION_QUALITY = 75;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  96 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  97 -    private static final Bitmap.CompressFormat IMAGE_FORMAT =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  98 -            android.graphics.Bitmap.CompressFormat.PNG;</span>
  99  
 100      private static final String[] FAVORITE_PROJECTION = {
 101          Favorites._ID,                     // 0
 102          Favorites.MODIFIED,                // 1
 103          Favorites.INTENT,                  // 2
 104          Favorites.APPWIDGET_PROVIDER,      // 3
 105          Favorites.APPWIDGET_ID,            // 4
 106          Favorites.CELLX,                   // 5
 107          Favorites.CELLY,                   // 6
 108          Favorites.CONTAINER,               // 7
 109          Favorites.ICON,                    // 8
 110          Favorites.ICON_PACKAGE,            // 9
 111          Favorites.ICON_RESOURCE,           // 10
 112          Favorites.ICON_TYPE,               // 11
 113          Favorites.ITEM_TYPE,               // 12
 114          Favorites.SCREEN,                  // 13
 115          Favorites.SPANX,                   // 14
 116          Favorites.SPANY,                   // 15
 117          Favorites.TITLE,                   // 16
 118          Favorites.PROFILE_ID,              // 17
 119      };
 120  
 121      private static final int ID_INDEX = 0;
 122      private static final int ID_MODIFIED = 1;
 123      private static final int INTENT_INDEX = 2;
 124      private static final int APPWIDGET_PROVIDER_INDEX = 3;
 125      private static final int APPWIDGET_ID_INDEX = 4;
 126      private static final int CELLX_INDEX = 5;
 127      private static final int CELLY_INDEX = 6;
 128      private static final int CONTAINER_INDEX = 7;
 129      private static final int ICON_INDEX = 8;
 130      private static final int ICON_PACKAGE_INDEX = 9;
 131      private static final int ICON_RESOURCE_INDEX = 10;
 132      private static final int ICON_TYPE_INDEX = 11;
 133      private static final int ITEM_TYPE_INDEX = 12;
 134      private static final int SCREEN_INDEX = 13;
 135      private static final int SPANX_INDEX = 14;
 136      private static final int SPANY_INDEX = 15;
 137      private static final int TITLE_INDEX = 16;
 138  
 139      private static final String[] SCREEN_PROJECTION = {
 140          WorkspaceScreens._ID,              // 0
 141          WorkspaceScreens.MODIFIED,         // 1
 142          WorkspaceScreens.SCREEN_RANK       // 2
 143      };
 144  
 145      private static final int SCREEN_RANK_INDEX = 2;
 146  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 147 -    private final Context mContext;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 148 +    @Thunk final Context mContext;</span>
 149      private final HashSet&lt;String&gt; mExistingKeys;
 150      private final ArrayList&lt;Key&gt; mKeys;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 151 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 152 -    private IconCache mIconCache;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 153 +    private final ItemTypeMatcher[] mItemTypeMatchers;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 154 +    private final long mUserSerial;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 155 +</span>
 156      private BackupManager mBackupManager;
 157      private byte[] mBuffer = new byte[512];
 158      private long mLastBackupRestoreTime;
 159      private boolean mBackupDataWasUpdated;
 160  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 161 -    private DeviceProfieData mCurrentProfile;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 162 +    private IconCache mIconCache;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 163 +    private DeviceProfieData mDeviceProfileData;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 164 +    private InvariantDeviceProfile mIdp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 165 +</span>
 166      boolean restoreSuccessful;
 167      int restoredBackupVersion = 1;
 168  
 169      public LauncherBackupHelper(Context context) {
 170          mContext = context;
 171          mExistingKeys = new HashSet&lt;String&gt;();
 172          mKeys = new ArrayList&lt;Key&gt;();
 173          restoreSuccessful = true;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 174 +        mItemTypeMatchers = new ItemTypeMatcher[CommonAppTypeParser.SUPPORTED_TYPE_COUNT];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 175 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 176 +        UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 177 +        mUserSerial = userManager.getSerialNumberForUser(UserHandleCompat.myUserHandle());</span>
 178      }
 179  
 180      private void dataChanged() {
 181          if (mBackupManager == null) {
 182              mBackupManager = new BackupManager(mContext);
 183          }
 184          mBackupManager.dataChanged();
 185      }
 186  
 187      private void applyJournal(Journal journal) {
 188          mLastBackupRestoreTime = journal.t;
 189          mExistingKeys.clear();
 190          if (journal.key != null) {
 191              for (Key key : journal.key) {
 192                  mExistingKeys.add(keyToBackupKey(key));
 193              }
 194          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 195 +        restoredBackupVersion = journal.backupVersion;</span>
 196      }
 197  
 198      /**
 199       * Back up launcher data so we can restore the user&#x27;s state on a new device.
 200       *
 201       * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 202       *
 203       * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 204       *
 205       * @param oldState notes from the last backup
 206       * @param data incremental key/value pairs to persist off-device
 207       * @param newState notes for the next backup
 208       */
 209      @Override
 210      public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 211              ParcelFileDescriptor newState) {
 212          if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 213  
 214          Journal in = readJournal(oldState);
 215          if (!launcherIsReady()) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 216 +            dataChanged();</span>
 217              // Perform backup later.
 218              writeJournal(newState, in);
 219              return;
 220          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 221 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 222 +        if (mDeviceProfileData == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 223 +            LauncherAppState app = LauncherAppState.getInstance();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 224 +            mIdp = app.getInvariantDeviceProfile();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 225 +            mDeviceProfileData = initDeviceProfileData(mIdp);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 226 +            mIconCache = app.getIconCache();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 227 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 228 +</span>
 229          Log.v(TAG, &quot;lastBackupTime = &quot; + in.t);
 230          mKeys.clear();
 231          applyJournal(in);
 232  
 233          // Record the time before performing backup so that entries edited while the backup
 234          // was going on, do not get missed in next backup.
 235          long newBackupTime = System.currentTimeMillis();
 236          mBackupDataWasUpdated = false;
 237          try {
 238              backupFavorites(data);
 239              backupScreens(data);
 240              backupIcons(data);
 241              backupWidgets(data);
 242  
 243              // Delete any key which still exist in the old backup, but is not valid anymore.
 244              HashSet&lt;String&gt; validKeys = new HashSet&lt;String&gt;();
 245              for (Key key : mKeys) {
 246                  validKeys.add(keyToBackupKey(key));
 247              }
 248              mExistingKeys.removeAll(validKeys);
 249  
 250              // Delete anything left in the existing keys.
 251              for (String deleted: mExistingKeys) {
 252                  if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
 253                  data.writeEntityHeader(deleted, -1);
 254                  mBackupDataWasUpdated = true;
 255              }
 256  
 257              mExistingKeys.clear();
 258              if (!mBackupDataWasUpdated) {
 259                  // Check if any metadata has changed
 260                  mBackupDataWasUpdated = (in.profile == null)
 261                          || !Arrays.equals(DeviceProfieData.toByteArray(in.profile),
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 262 -                            DeviceProfieData.toByteArray(getDeviceProfieData()))</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 263 +                            DeviceProfieData.toByteArray(mDeviceProfileData))</span>
 264                          || (in.backupVersion != BACKUP_VERSION)
 265                          || (in.appVersion != getAppVersion());
 266              }
 267  
 268              if (mBackupDataWasUpdated) {
 269                  mLastBackupRestoreTime = newBackupTime;
 270  
 271                  // We store the journal at two places.
 272                  //   1) Storing it in newState allows us to do partial backups by comparing old state
 273                  //   2) Storing it in backup data allows us to validate keys during restore
 274                  Journal state = getCurrentStateJournal();
 275                  writeRowToBackup(JOURNAL_KEY, state, data);
 276              } else {
 277                  if (DEBUG) Log.d(TAG, &quot;Nothing was written during backup&quot;);
 278              }
 279          } catch (IOException e) {
 280              Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 281          }
 282  
 283          writeNewStateDescription(newState);
 284      }
 285  
 286      /**
 287       * @return true if the backup corresponding to oldstate can be successfully applied
 288       * to this device.
 289       */
 290      private boolean isBackupCompatible(Journal oldState) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 291 -        DeviceProfieData currentProfile = getDeviceProfieData();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 292 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 293 +        DeviceProfieData currentProfile = mDeviceProfileData;</span>
 294          DeviceProfieData oldProfile = oldState.profile;
 295  
 296          if (oldProfile == null || oldProfile.desktopCols == 0) {
 297              // Profile info is not valid, ignore the check.
 298              return true;
 299          }
 300  
 301          boolean isHotsetCompatible = false;
 302          if (currentProfile.allappsRank &gt;= oldProfile.hotseatCount) {
 303              isHotsetCompatible = true;
 304          }
 305          if ((currentProfile.hotseatCount &gt;= oldProfile.hotseatCount) &amp;&amp;
 306                  (currentProfile.allappsRank == oldProfile.allappsRank)) {
 307              isHotsetCompatible = true;
 308          }
 309  
 310          return isHotsetCompatible &amp;&amp; (currentProfile.desktopCols &gt;= oldProfile.desktopCols)
 311                  &amp;&amp; (currentProfile.desktopRows &gt;= oldProfile.desktopRows);
 312      }
 313  
 314      /**
 315       * Restore launcher configuration from the restored data stream.
 316       * It assumes that the keys will arrive in lexical order. So if the journal was present in the
 317       * backup, it should arrive first.
 318       *
 319       * @param data the key/value pair from the server
 320       */
 321      @Override
 322      public void restoreEntity(BackupDataInputStream data) {
 323          if (!restoreSuccessful) {
 324              return;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 325 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 326 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 327 +        if (mDeviceProfileData == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 328 +            // This call does not happen on a looper thread. So LauncherAppState</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 329 +            // can&#x27;t be created . Instead initialize required dependencies directly.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 330 +            mIdp = new InvariantDeviceProfile(mContext);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 331 +            mDeviceProfileData = initDeviceProfileData(mIdp);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 332 +            mIconCache = new IconCache(mContext, mIdp);</span>
 333          }
 334  
 335          int dataSize = data.size();
 336          if (mBuffer.length &lt; dataSize) {
 337              mBuffer = new byte[dataSize];
 338          }
 339          try {
 340              int bytesRead = data.read(mBuffer, 0, dataSize);
 341              if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 342              String backupKey = data.getKey();
 343  
 344              if (JOURNAL_KEY.equals(backupKey)) {
 345                  if (VERBOSE) Log.v(TAG, &quot;Journal entry restored&quot;);
 346                  if (!mKeys.isEmpty()) {
 347                      // We received the journal key after a restore key.
 348                      Log.wtf(TAG, keyToBackupKey(mKeys.get(0)) + &quot; received after &quot; + JOURNAL_KEY);
 349                      restoreSuccessful = false;
 350                      return;
 351                  }
 352  
 353                  Journal journal = new Journal();
 354                  MessageNano.mergeFrom(journal, readCheckedBytes(mBuffer, dataSize));
 355                  applyJournal(journal);
 356                  restoreSuccessful = isBackupCompatible(journal);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 357 -                restoredBackupVersion = journal.backupVersion;</span>
 358                  return;
 359              }
 360  
 361              if (!mExistingKeys.isEmpty() &amp;&amp; !mExistingKeys.contains(backupKey)) {
 362                  if (DEBUG) Log.e(TAG, &quot;Ignoring key not present in the backup state &quot; + backupKey);
 363                  return;
 364              }
 365              Key key = backupKeyToKey(backupKey);
 366              mKeys.add(key);
 367              switch (key.type) {
 368                  case Key.FAVORITE:
 369                      restoreFavorite(key, mBuffer, dataSize);
 370                      break;
 371  
 372                  case Key.SCREEN:
 373                      restoreScreen(key, mBuffer, dataSize);
 374                      break;
 375  
 376                  case Key.ICON:
 377                      restoreIcon(key, mBuffer, dataSize);
 378                      break;
 379  
 380                  case Key.WIDGET:
 381                      restoreWidget(key, mBuffer, dataSize);
 382                      break;
 383  
 384                  default:
 385                      Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 386                      mKeys.remove(key);
 387                      break;
 388              }
 389          } catch (IOException e) {
 390              Log.w(TAG, &quot;ignoring unparsable backup entry&quot;, e);
 391          }
 392      }
 393  
 394      /**
 395       * Record the restore state for the next backup.
 396       *
 397       * @param newState notes about the backup state after restore.
 398       */
 399      @Override
 400      public void writeNewStateDescription(ParcelFileDescriptor newState) {
 401          writeJournal(newState, getCurrentStateJournal());
 402      }
 403  
 404      private Journal getCurrentStateJournal() {
 405          Journal journal = new Journal();
 406          journal.t = mLastBackupRestoreTime;
 407          journal.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);
 408          journal.appVersion = getAppVersion();
 409          journal.backupVersion = BACKUP_VERSION;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 410 -        journal.profile = getDeviceProfieData();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 411 +        journal.profile = mDeviceProfileData;</span>
 412          return journal;
 413      }
 414  
 415      private int getAppVersion() {
 416          try {
 417              return mContext.getPackageManager()
 418                      .getPackageInfo(mContext.getPackageName(), 0).versionCode;
 419          } catch (NameNotFoundException e) {
 420              return 0;
 421          }
 422      }
 423  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 424 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 425 -     * @return the current device profile information.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 426 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 427 -    private DeviceProfieData getDeviceProfieData() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 428 -        if (mCurrentProfile != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 429 -            return mCurrentProfile;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 430 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 431 -        final Context applicationContext = mContext.getApplicationContext();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 432 -        DeviceProfile profile = LauncherAppState.createDynamicGrid(applicationContext, null)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 433 -                .getDeviceProfile();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 434 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 435 -        mCurrentProfile = new DeviceProfieData();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 436 -        mCurrentProfile.desktopRows = profile.numRows;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 437 -        mCurrentProfile.desktopCols = profile.numColumns;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 438 -        mCurrentProfile.hotseatCount = profile.numHotseatIcons;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 439 -        mCurrentProfile.allappsRank = profile.hotseatAllAppsRank;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 440 -        return mCurrentProfile;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 441 +    private DeviceProfieData initDeviceProfileData(InvariantDeviceProfile profile) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 442 +        DeviceProfieData data = new DeviceProfieData();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 443 +        data.desktopRows = profile.numRows;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 444 +        data.desktopCols = profile.numColumns;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 445 +        data.hotseatCount = profile.numHotseatIcons;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 446 +        data.allappsRank = profile.hotseatAllAppsRank;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 447 +        return data;</span>
 448      }
 449  
 450      /**
 451       * Write all modified favorites to the data stream.
 452       *
 453       * @param data output stream for key/value pairs
 454       * @throws IOException
 455       */
 456      private void backupFavorites(BackupDataOutput data) throws IOException {
 457          // persist things that have changed since the last backup
 458          ContentResolver cr = mContext.getContentResolver();
 459          // Don&#x27;t backup apps in other profiles for now.
 460          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 461                  getUserSelectionArg(), null, null);
 462          try {
 463              cursor.moveToPosition(-1);
 464              while(cursor.moveToNext()) {
 465                  final long id = cursor.getLong(ID_INDEX);
 466                  final long updateTime = cursor.getLong(ID_MODIFIED);
 467                  Key key = getKey(Key.FAVORITE, id);
 468                  mKeys.add(key);
 469                  final String backupKey = keyToBackupKey(key);
 470                  if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 471                      writeRowToBackup(key, packFavorite(cursor), data);
 472                  } else {
 473                      if (DEBUG) Log.d(TAG, &quot;favorite already backup up: &quot; + id);
 474                  }
 475              }
 476          } finally {
 477              cursor.close();
 478          }
 479      }
 480  
 481      /**
 482       * Read a favorite from the stream.
 483       *
 484       * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 485       *
 486       * @param key identifier for the row
 487       * @param buffer the serialized proto from the stream, may be larger than dataSize
 488       * @param dataSize the size of the proto from the stream
 489       */
 490      private void restoreFavorite(Key key, byte[] buffer, int dataSize) throws IOException {
 491          if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 492          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 493                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 494  
 495          ContentResolver cr = mContext.getContentResolver();
 496          ContentValues values = unpackFavorite(buffer, dataSize);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 497 -        cr.insert(Favorites.CONTENT_URI_NO_NOTIFICATION, values);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 498 +        cr.insert(Favorites.CONTENT_URI, values);</span>
 499      }
 500  
 501      /**
 502       * Write all modified screens to the data stream.
 503       *
 504       * @param data output stream for key/value pairs
 505       * @throws IOException
 506       */
 507      private void backupScreens(BackupDataOutput data) throws IOException {
 508          // persist things that have changed since the last backup
 509          ContentResolver cr = mContext.getContentResolver();
 510          Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 511                  null, null, null);
 512          try {
 513              cursor.moveToPosition(-1);
 514              if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + mLastBackupRestoreTime);
 515              while(cursor.moveToNext()) {
 516                  final long id = cursor.getLong(ID_INDEX);
 517                  final long updateTime = cursor.getLong(ID_MODIFIED);
 518                  Key key = getKey(Key.SCREEN, id);
 519                  mKeys.add(key);
 520                  final String backupKey = keyToBackupKey(key);
 521                  if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 522                      writeRowToBackup(key, packScreen(cursor), data);
 523                  } else {
 524                      if (VERBOSE) Log.v(TAG, &quot;screen already backup up &quot; + id);
 525                  }
 526              }
 527          } finally {
 528              cursor.close();
 529          }
 530      }
 531  
 532      /**
 533       * Read a screen from the stream.
 534       *
 535       * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 536       *
 537       * @param key identifier for the row
 538       * @param buffer the serialized proto from the stream, may be larger than dataSize
 539       * @param dataSize the size of the proto from the stream
 540       */
 541      private void restoreScreen(Key key, byte[] buffer, int dataSize) throws IOException {
 542          if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 543          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 544                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 545  
 546          ContentResolver cr = mContext.getContentResolver();
 547          ContentValues values = unpackScreen(buffer, dataSize);
 548          cr.insert(WorkspaceScreens.CONTENT_URI, values);
 549      }
 550  
 551      /**
 552       * Write all the static icon resources we need to render placeholders
 553       * for a package that is not installed.
 554       *
 555       * @param data output stream for key/value pairs
 556       */
 557      private void backupIcons(BackupDataOutput data) throws IOException {
 558          // persist icons that haven&#x27;t been persisted yet
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 559 -        if (!initializeIconCache()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 560 -            dataChanged(); // try again later</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 561 -            if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 562 -            return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 563 -        }</span>
 564          final ContentResolver cr = mContext.getContentResolver();
 565          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 566          final UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 567          int backupUpIconCount = 0;
 568  
 569          // Don&#x27;t backup apps in other profiles for now.
 570          String where = &quot;(&quot; + Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION + &quot; OR &quot; +
 571                  Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_SHORTCUT + &quot;) AND &quot; +
 572                  getUserSelectionArg();
 573          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 574                  where, null, null);
 575          try {
 576              cursor.moveToPosition(-1);
 577              while(cursor.moveToNext()) {
 578                  final long id = cursor.getLong(ID_INDEX);
 579                  final String intentDescription = cursor.getString(INTENT_INDEX);
 580                  try {
 581                      Intent intent = Intent.parseUri(intentDescription, 0);
 582                      ComponentName cn = intent.getComponent();
 583                      Key key = null;
 584                      String backupKey = null;
 585                      if (cn != null) {
 586                          key = getKey(Key.ICON, cn.flattenToShortString());
 587                          backupKey = keyToBackupKey(key);
 588                      } else {
 589                          Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 590                      }
 591                      if (mExistingKeys.contains(backupKey)) {
 592                          if (DEBUG) Log.d(TAG, &quot;already saved icon &quot; + backupKey);
 593  
 594                          // remember that we already backed this up previously
 595                          mKeys.add(key);
 596                      } else if (backupKey != null) {
 597                          if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + backupUpIconCount);
 598                          if (backupUpIconCount &lt; MAX_ICONS_PER_PASS) {
 599                              if (DEBUG) Log.d(TAG, &quot;saving icon &quot; + backupKey);
 600                              Bitmap icon = mIconCache.getIcon(intent, myUserHandle);
 601                              if (icon != null &amp;&amp; !mIconCache.isDefaultIcon(icon, myUserHandle)) {
 602                                  writeRowToBackup(key, packIcon(dpi, icon), data);
 603                                  mKeys.add(key);
 604                                  backupUpIconCount ++;
 605                              }
 606                          } else {
 607                              if (VERBOSE) Log.v(TAG, &quot;deferring icon backup &quot; + backupKey);
 608                              // too many icons for this pass, request another.
 609                              dataChanged();
 610                          }
 611                      }
 612                  } catch (URISyntaxException e) {
 613                      Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 614                  } catch (IOException e) {
 615                      Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 616                  }
 617  
 618              }
 619          } finally {
 620              cursor.close();
 621          }
 622      }
 623  
 624      /**
 625       * Read an icon from the stream.
 626       *
 627       * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 628       *
 629       * @param key identifier for the row
 630       * @param buffer the serialized proto from the stream, may be larger than dataSize
 631       * @param dataSize the size of the proto from the stream
 632       */
 633      private void restoreIcon(Key key, byte[] buffer, int dataSize) throws IOException {
 634          if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 635          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 636                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 637  
 638          Resource res = unpackProto(new Resource(), buffer, dataSize);
 639          if (DEBUG) {
 640              Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 641          }
 642          Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 643          if (icon == null) {
 644              Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 645          }
 646          if (VERBOSE) Log.v(TAG, &quot;saving restored icon as: &quot; + key.name);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 647 -        IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(key.name), icon, res.dpi);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 648 +        mIconCache.preloadIcon(ComponentName.unflattenFromString(key.name), icon, res.dpi,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 649 +                &quot;&quot; /* label */, mUserSerial);</span>
 650      }
 651  
 652      /**
 653       * Write all the static widget resources we need to render placeholders
 654       * for a package that is not installed.
 655       *
 656       * @param data output stream for key/value pairs
 657       * @throws IOException
 658       */
 659      private void backupWidgets(BackupDataOutput data) throws IOException {
 660          // persist static widget info that hasn&#x27;t been persisted yet
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 661 -        final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 662 -        if (appState == null || !initializeIconCache()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 663 -            Log.w(TAG, &quot;Failed to get icon cache during restore&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 664 -            return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 665 -        }</span>
 666          final ContentResolver cr = mContext.getContentResolver();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 667 -        final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 668 -        final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);</span>
 669          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 670 -        final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 671 -        if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);</span>
 672          int backupWidgetCount = 0;
 673  
 674          String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET + &quot; AND &quot;
 675                  + getUserSelectionArg();
 676          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 677                  where, null, null);
 678          try {
 679              cursor.moveToPosition(-1);
 680              while(cursor.moveToNext()) {
 681                  final long id = cursor.getLong(ID_INDEX);
 682                  final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 683 -                final int spanX = cursor.getInt(SPANX_INDEX);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 684 -                final int spanY = cursor.getInt(SPANY_INDEX);</span>
 685                  final ComponentName provider = ComponentName.unflattenFromString(providerName);
 686                  Key key = null;
 687                  String backupKey = null;
 688                  if (provider != null) {
 689                      key = getKey(Key.WIDGET, providerName);
 690                      backupKey = keyToBackupKey(key);
 691                  } else {
 692                      Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 693                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 694 -                if (mExistingKeys.contains(backupKey)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 695 +                if (mExistingKeys.contains(backupKey) &amp;&amp; restoredBackupVersion &gt;= BACKUP_VERSION) {</span>
 696                      if (DEBUG) Log.d(TAG, &quot;already saved widget &quot; + backupKey);
 697  
 698                      // remember that we already backed this up previously
 699                      mKeys.add(key);
 700                  } else if (backupKey != null) {
 701                      if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + backupWidgetCount);
 702                      if (backupWidgetCount &lt; MAX_WIDGETS_PER_PASS) {
 703                          if (DEBUG) Log.d(TAG, &quot;saving widget &quot; + backupKey);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 704 -                        previewLoader.setPreviewSize(spanX * profile.cellWidthPx,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 705 -                                spanY * profile.cellHeightPx, widgetSpacingLayout);</span>
 706                          UserHandleCompat user = UserHandleCompat.myUserHandle();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 707 -                        writeRowToBackup(key,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 708 -                                packWidget(dpi, previewLoader, mIconCache, provider, user),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 709 -                                data);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 710 +                        writeRowToBackup(key, packWidget(dpi, provider, user), data);</span>
 711                          mKeys.add(key);
 712                          backupWidgetCount ++;
 713                      } else {
 714                          if (VERBOSE) Log.v(TAG, &quot;deferring widget backup &quot; + backupKey);
 715                          // too many widgets for this pass, request another.
 716                          dataChanged();
 717                      }
 718                  }
 719              }
 720          } finally {
 721              cursor.close();
 722          }
 723      }
 724  
 725      /**
 726       * Read a widget from the stream.
 727       *
 728       * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 729       *
 730       * @param key identifier for the row
 731       * @param buffer the serialized proto from the stream, may be larger than dataSize
 732       * @param dataSize the size of the proto from the stream
 733       */
 734      private void restoreWidget(Key key, byte[] buffer, int dataSize) throws IOException {
 735          if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 736          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 737                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 738          Widget widget = unpackProto(new Widget(), buffer, dataSize);
 739          if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 740          if (widget.icon.data != null)  {
 741              Bitmap icon = BitmapFactory
 742                      .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 743              if (icon == null) {
 744                  Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 745              } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 746 -                IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(widget.provider),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 747 -                        icon, widget.icon.dpi);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 748 +                mIconCache.preloadIcon(ComponentName.unflattenFromString(widget.provider),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 749 +                        icon, widget.icon.dpi, widget.label, mUserSerial);</span>
 750              }
 751          }
 752  
 753          // future site of widget table mutation
 754      }
 755  
 756      /** create a new key, with an integer ID.
 757       *
 758       * &lt;P&gt; Keys contain their own checksum instead of using
 759       * the heavy-weight CheckedMessage wrapper.
 760       */
 761      private Key getKey(int type, long id) {
 762          Key key = new Key();
 763          key.type = type;
 764          key.id = id;
 765          key.checksum = checkKey(key);
 766          return key;
 767      }
 768  
 769      /** create a new key for a named object.
 770       *
 771       * &lt;P&gt; Keys contain their own checksum instead of using
 772       * the heavy-weight CheckedMessage wrapper.
 773       */
 774      private Key getKey(int type, String name) {
 775          Key key = new Key();
 776          key.type = type;
 777          key.name = name;
 778          key.checksum = checkKey(key);
 779          return key;
 780      }
 781  
 782      /** keys need to be strings, serialize and encode. */
 783      private String keyToBackupKey(Key key) {
 784          return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 785      }
 786  
 787      /** keys need to be strings, decode and parse. */
 788      private Key backupKeyToKey(String backupKey) throws InvalidBackupException {
 789          try {
 790              Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 791              if (key.checksum != checkKey(key)) {
 792                  key = null;
 793                  throw new InvalidBackupException(&quot;invalid key read from stream&quot; + backupKey);
 794              }
 795              return key;
 796          } catch (InvalidProtocolBufferNanoException e) {
 797              throw new InvalidBackupException(e);
 798          } catch (IllegalArgumentException e) {
 799              throw new InvalidBackupException(e);
 800          }
 801      }
 802  
 803      /** Compute the checksum over the important bits of a key. */
 804      private long checkKey(Key key) {
 805          CRC32 checksum = new CRC32();
 806          checksum.update(key.type);
 807          checksum.update((int) (key.id &amp; 0xffff));
 808          checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 809          if (!TextUtils.isEmpty(key.name)) {
 810              checksum.update(key.name.getBytes());
 811          }
 812          return checksum.getValue();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 813 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 814 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 815 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 816 +     * @return true if its an hotseat item, that can be replaced during restore.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 817 +     * TODO: Extend check for folders in hotseat.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 818 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 819 +    private boolean isReplaceableHotseatItem(Favorite favorite) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 820 +        return favorite.container == Favorites.CONTAINER_HOTSEAT</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 821 +                &amp;&amp; favorite.intent != null</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 822 +                &amp;&amp; (favorite.itemType == Favorites.ITEM_TYPE_APPLICATION</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 823 +                || favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT);</span>
 824      }
 825  
 826      /** Serialize a Favorite for persistence, including a checksum wrapper. */
 827      private Favorite packFavorite(Cursor c) {
 828          Favorite favorite = new Favorite();
 829          favorite.id = c.getLong(ID_INDEX);
 830          favorite.screen = c.getInt(SCREEN_INDEX);
 831          favorite.container = c.getInt(CONTAINER_INDEX);
 832          favorite.cellX = c.getInt(CELLX_INDEX);
 833          favorite.cellY = c.getInt(CELLY_INDEX);
 834          favorite.spanX = c.getInt(SPANX_INDEX);
 835          favorite.spanY = c.getInt(SPANY_INDEX);
 836          favorite.iconType = c.getInt(ICON_TYPE_INDEX);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 837 -        if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 838 -            String iconPackage = c.getString(ICON_PACKAGE_INDEX);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 839 -            if (!TextUtils.isEmpty(iconPackage)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 840 -                favorite.iconPackage = iconPackage;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 841 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 842 -            String iconResource = c.getString(ICON_RESOURCE_INDEX);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 843 -            if (!TextUtils.isEmpty(iconResource)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 844 -                favorite.iconResource = iconResource;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 845 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 846 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 847 -        if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 848 -            byte[] blob = c.getBlob(ICON_INDEX);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 849 -            if (blob != null &amp;&amp; blob.length &gt; 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 850 -                favorite.icon = blob;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 851 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 852 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 853 +</span>
 854          String title = c.getString(TITLE_INDEX);
 855          if (!TextUtils.isEmpty(title)) {
 856              favorite.title = title;
 857          }
 858          String intentDescription = c.getString(INTENT_INDEX);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 859 +        Intent intent = null;</span>
 860          if (!TextUtils.isEmpty(intentDescription)) {
 861              try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 862 -                Intent intent = Intent.parseUri(intentDescription, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 863 +                intent = Intent.parseUri(intentDescription, 0);</span>
 864                  intent.removeExtra(ItemInfo.EXTRA_PROFILE);
 865                  favorite.intent = intent.toUri(0);
 866              } catch (URISyntaxException e) {
 867                  Log.e(TAG, &quot;Invalid intent&quot;, e);
 868              }
 869          }
 870          favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 871          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 872              favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 873              String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 874              if (!TextUtils.isEmpty(appWidgetProvider)) {
 875                  favorite.appWidgetProvider = appWidgetProvider;
 876              }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 877 +        } else if (favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 878 +            if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 879 +                String iconPackage = c.getString(ICON_PACKAGE_INDEX);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 880 +                if (!TextUtils.isEmpty(iconPackage)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 881 +                    favorite.iconPackage = iconPackage;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 882 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 883 +                String iconResource = c.getString(ICON_RESOURCE_INDEX);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 884 +                if (!TextUtils.isEmpty(iconResource)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 885 +                    favorite.iconResource = iconResource;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 886 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 887 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 888 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 889 +            byte[] blob = c.getBlob(ICON_INDEX);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 890 +            if (blob != null &amp;&amp; blob.length &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 891 +                favorite.icon = blob;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 892 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 893 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 894 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 895 +        if (isReplaceableHotseatItem(favorite)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 896 +            if (intent != null &amp;&amp; intent.getComponent() != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 897 +                PackageManager pm = mContext.getPackageManager();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 898 +                ActivityInfo activity = null;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 899 +                try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 900 +                    activity = pm.getActivityInfo(intent.getComponent(), 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 901 +                } catch (NameNotFoundException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 902 +                    Log.e(TAG, &quot;Target not found&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 903 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 904 +                if (activity == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 905 +                    return favorite;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 906 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 907 +                for (int i = 0; i &lt; mItemTypeMatchers.length; i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 908 +                    if (mItemTypeMatchers[i] == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 909 +                        mItemTypeMatchers[i] = new ItemTypeMatcher(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 910 +                                CommonAppTypeParser.getResourceForItemType(i));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 911 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 912 +                    if (mItemTypeMatchers[i].matches(activity, pm)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 913 +                        favorite.targetType = i;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 914 +                        break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 915 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 916 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 917 +            }</span>
 918          }
 919  
 920          return favorite;
 921      }
 922  
 923      /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 924      private ContentValues unpackFavorite(byte[] buffer, int dataSize)
 925              throws IOException {
 926          Favorite favorite = unpackProto(new Favorite(), buffer, dataSize);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 927 +</span>
 928          ContentValues values = new ContentValues();
 929          values.put(Favorites._ID, favorite.id);
 930          values.put(Favorites.SCREEN, favorite.screen);
 931          values.put(Favorites.CONTAINER, favorite.container);
 932          values.put(Favorites.CELLX, favorite.cellX);
 933          values.put(Favorites.CELLY, favorite.cellY);
 934          values.put(Favorites.SPANX, favorite.spanX);
 935          values.put(Favorites.SPANY, favorite.spanY);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 936 -        values.put(Favorites.ICON_TYPE, favorite.iconType);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 937 -        if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 938 -            values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 939 -            values.put(Favorites.ICON_RESOURCE, favorite.iconResource);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 940 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 941 -        if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 942 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 943 +        if (favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 944 +            values.put(Favorites.ICON_TYPE, favorite.iconType);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 945 +            if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 946 +                values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 947 +                values.put(Favorites.ICON_RESOURCE, favorite.iconResource);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 948 +            }</span>
 949              values.put(Favorites.ICON, favorite.icon);
 950          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 951 +</span>
 952          if (!TextUtils.isEmpty(favorite.title)) {
 953              values.put(Favorites.TITLE, favorite.title);
 954          } else {
 955              values.put(Favorites.TITLE, &quot;&quot;);
 956          }
 957          if (!TextUtils.isEmpty(favorite.intent)) {
 958              values.put(Favorites.INTENT, favorite.intent);
 959          }
 960          values.put(Favorites.ITEM_TYPE, favorite.itemType);
 961  
 962          UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 963          long userSerialNumber =
 964                  UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHandle);
 965          values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
 966  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 967 -        DeviceProfieData currentProfile = getDeviceProfieData();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 968 +        DeviceProfieData currentProfile = mDeviceProfileData;</span>
 969  
 970          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 971              if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 972                  values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 973              }
 974              values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 975              values.put(LauncherSettings.Favorites.RESTORED,
 976                      LauncherAppWidgetInfo.FLAG_ID_NOT_VALID |
 977                      LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY |
 978                      LauncherAppWidgetInfo.FLAG_UI_NOT_READY);
 979  
 980              // Verify placement
 981              if (((favorite.cellX + favorite.spanX) &gt; currentProfile.desktopCols)
 982                      || ((favorite.cellY + favorite.spanY) &gt; currentProfile.desktopRows)) {
 983                  restoreSuccessful = false;
 984                  throw new InvalidBackupException(&quot;Widget not in screen bounds, aborting restore&quot;);
 985              }
 986          } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 987 -            // Let LauncherModel know we&#x27;ve been here.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 988 -            values.put(LauncherSettings.Favorites.RESTORED, 1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 989 +            // Check if it is an hotseat item, that can be replaced.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 990 +            if (isReplaceableHotseatItem(favorite)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 991 +                    &amp;&amp; favorite.targetType != Favorite.TARGET_NONE</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 992 +                    &amp;&amp; favorite.targetType &lt; CommonAppTypeParser.SUPPORTED_TYPE_COUNT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 993 +                Log.e(TAG, &quot;Added item type flag&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 994 +                values.put(LauncherSettings.Favorites.RESTORED,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 995 +                        1 | CommonAppTypeParser.encodeItemTypeToFlag(favorite.targetType));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 996 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 997 +                // Let LauncherModel know we&#x27;ve been here.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 998 +                values.put(LauncherSettings.Favorites.RESTORED, 1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 999 +            }</span>
1000  
1001              // Verify placement
1002              if (favorite.container == Favorites.CONTAINER_HOTSEAT) {
1003                  if ((favorite.screen &gt;= currentProfile.hotseatCount)
1004                          || (favorite.screen == currentProfile.allappsRank)) {
1005                      restoreSuccessful = false;
1006                      throw new InvalidBackupException(&quot;Item not in hotseat bounds, aborting restore&quot;);
1007                  }
1008              } else {
1009                  if ((favorite.cellX &gt;= currentProfile.desktopCols)
1010                          || (favorite.cellY &gt;= currentProfile.desktopRows)) {
1011                      restoreSuccessful = false;
1012                      throw new InvalidBackupException(&quot;Item not in desktop bounds, aborting restore&quot;);
1013                  }
1014              }
1015          }
1016  
1017          return values;
1018      }
1019  
1020      /** Serialize a Screen for persistence, including a checksum wrapper. */
1021      private Screen packScreen(Cursor c) {
1022          Screen screen = new Screen();
1023          screen.id = c.getLong(ID_INDEX);
1024          screen.rank = c.getInt(SCREEN_RANK_INDEX);
1025          return screen;
1026      }
1027  
1028      /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
1029      private ContentValues unpackScreen(byte[] buffer, int dataSize)
1030              throws InvalidProtocolBufferNanoException {
1031          Screen screen = unpackProto(new Screen(), buffer, dataSize);
1032          ContentValues values = new ContentValues();
1033          values.put(WorkspaceScreens._ID, screen.id);
1034          values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
1035          return values;
1036      }
1037  
1038      /** Serialize an icon Resource for persistence, including a checksum wrapper. */
1039      private Resource packIcon(int dpi, Bitmap icon) {
1040          Resource res = new Resource();
1041          res.dpi = dpi;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1042 -        ByteArrayOutputStream os = new ByteArrayOutputStream();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1043 -        if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1044 -            res.data = os.toByteArray();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1045 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1046 +        res.data = Utilities.flattenBitmap(icon);</span>
1047          return res;
1048      }
1049  
1050      /** Serialize a widget for persistence, including a checksum wrapper. */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1051 -    private Widget packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1052 -            ComponentName provider, UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1053 +    private Widget packWidget(int dpi, ComponentName provider, UserHandleCompat user) {</span>
1054          final LauncherAppWidgetProviderInfo info =
1055                  LauncherModel.getProviderInfo(mContext, provider, user);
1056          Widget widget = new Widget();
1057          widget.provider = provider.flattenToShortString();
1058          widget.label = info.label;
1059          widget.configure = info.configure != null;
1060          if (info.icon != 0) {
1061              widget.icon = new Resource();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1062 -            Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1063 +            Drawable fullResIcon = mIconCache.getFullResIcon(provider.getPackageName(), info.icon);</span>
1064              Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1065 -            ByteArrayOutputStream os = new ByteArrayOutputStream();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1066 -            if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1067 -                widget.icon.data = os.toByteArray();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1068 -                widget.icon.dpi = dpi;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1069 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1070 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1071 -        if (info.previewImage != 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1072 -            widget.preview = new Resource();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1073 -            Bitmap preview = previewLoader.generateWidgetPreview(info, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1074 -            ByteArrayOutputStream os = new ByteArrayOutputStream();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1075 -            if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1076 -                widget.preview.data = os.toByteArray();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1077 -                widget.preview.dpi = dpi;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1078 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1079 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1080 +            widget.icon.data = Utilities.flattenBitmap(icon);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1081 +            widget.icon.dpi = dpi;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1082 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1083 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1084 +        // Calculate the spans corresponding to any one of the orientations as it should not change</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1085 +        // based on orientation.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1086 +        int[] minSpans = CellLayout.rectToCell(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1087 +                mIdp.portraitProfile, mContext, info.minResizeWidth, info.minResizeHeight, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1088 +        widget.minSpanX = (info.resizeMode &amp; LauncherAppWidgetProviderInfo.RESIZE_HORIZONTAL) != 0</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1089 +                ? minSpans[0] : -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1090 +        widget.minSpanY = (info.resizeMode &amp; LauncherAppWidgetProviderInfo.RESIZE_VERTICAL) != 0</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1091 +                ? minSpans[1] : -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1092 +</span>
1093          return widget;
1094      }
1095  
1096      /**
1097       * Deserialize a proto after verifying checksum wrapper.
1098       */
1099      private &lt;T extends MessageNano&gt; T unpackProto(T proto, byte[] buffer, int dataSize)
1100              throws InvalidProtocolBufferNanoException {
1101          MessageNano.mergeFrom(proto, readCheckedBytes(buffer, dataSize));
1102          if (DEBUG) Log.d(TAG, &quot;unpacked proto &quot; + proto);
1103          return proto;
1104      }
1105  
1106      /**
1107       * Read the old journal from the input file.
1108       *
1109       * In the event of any error, just pretend we didn&#x27;t have a journal,
1110       * in that case, do a full backup.
1111       *
1112       * @param oldState the read-0only file descriptor pointing to the old journal
1113       * @return a Journal protocol buffer
1114       */
1115      private Journal readJournal(ParcelFileDescriptor oldState) {
1116          Journal journal = new Journal();
1117          if (oldState == null) {
1118              return journal;
1119          }
1120          FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
1121          try {
1122              int availableBytes = inStream.available();
1123              if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
1124              if (availableBytes &lt; MAX_JOURNAL_SIZE) {
1125                  byte[] buffer = new byte[availableBytes];
1126                  int bytesRead = 0;
1127                  boolean valid = false;
1128                  InvalidProtocolBufferNanoException lastProtoException = null;
1129                  while (availableBytes &gt; 0) {
1130                      try {
1131                          // OMG what are you doing? This is crazy inefficient!
1132                          // If we read a byte that is not ours, we will cause trouble: b/12491813
1133                          // However, we don&#x27;t know how many bytes to expect (oops).
1134                          // So we have to step through *slowly*, watching for the end.
1135                          int result = inStream.read(buffer, bytesRead, 1);
1136                          if (result &gt; 0) {
1137                              availableBytes -= result;
1138                              bytesRead += result;
1139                          } else {
1140                              Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1141                              // stop reading and see what there is to parse
1142                              availableBytes = 0;
1143                          }
1144                      } catch (IOException e) {
1145                          buffer = null;
1146                          availableBytes = 0;
1147                      }
1148  
1149                      // check the buffer to see if we have a valid journal
1150                      try {
1151                          MessageNano.mergeFrom(journal, readCheckedBytes(buffer, bytesRead));
1152                          // if we are here, then we have read a valid, checksum-verified journal
1153                          valid = true;
1154                          availableBytes = 0;
1155                          if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1156                      } catch (InvalidProtocolBufferNanoException e) {
1157                          // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1158                          lastProtoException = e;
1159                          journal.clear();
1160                      }
1161                  }
1162                  if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1163                  if (!valid) {
1164                      Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1165                  }
1166              }
1167          } catch (IOException e) {
1168              Log.w(TAG, &quot;failed to close the journal&quot;, e);
1169          } finally {
1170              try {
1171                  inStream.close();
1172              } catch (IOException e) {
1173                  Log.w(TAG, &quot;failed to close the journal&quot;, e);
1174              }
1175          }
1176          return journal;
1177      }
1178  
1179      private void writeRowToBackup(Key key, MessageNano proto, BackupDataOutput data)
1180              throws IOException {
1181          writeRowToBackup(keyToBackupKey(key), proto, data);
1182      }
1183  
1184      private void writeRowToBackup(String backupKey, MessageNano proto,
1185              BackupDataOutput data) throws IOException {
1186          byte[] blob = writeCheckedBytes(proto);
1187          data.writeEntityHeader(backupKey, blob.length);
1188          data.writeEntityData(blob, blob.length);
1189          mBackupDataWasUpdated = true;
1190          if (VERBOSE) Log.v(TAG, &quot;Writing New entry &quot; + backupKey);
1191      }
1192  
1193      /**
1194       * Write the new journal to the output file.
1195       *
1196       * In the event of any error, just pretend we didn&#x27;t have a journal,
1197       * in that case, do a full backup.
1198  
1199       * @param newState the write-only file descriptor pointing to the new journal
1200       * @param journal a Journal protocol buffer
1201       */
1202      private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1203          FileOutputStream outStream = null;
1204          try {
1205              outStream = new FileOutputStream(newState.getFileDescriptor());
1206              final byte[] journalBytes = writeCheckedBytes(journal);
1207              outStream.write(journalBytes);
1208              outStream.close();
1209              if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1210          } catch (IOException e) {
1211              Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1212          }
1213      }
1214  
1215      /** Wrap a proto in a CheckedMessage and compute the checksum. */
1216      private byte[] writeCheckedBytes(MessageNano proto) {
1217          CheckedMessage wrapper = new CheckedMessage();
1218          wrapper.payload = MessageNano.toByteArray(proto);
1219          CRC32 checksum = new CRC32();
1220          checksum.update(wrapper.payload);
1221          wrapper.checksum = checksum.getValue();
1222          return MessageNano.toByteArray(wrapper);
1223      }
1224  
1225      /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1226      private static byte[] readCheckedBytes(byte[] buffer, int dataSize)
1227              throws InvalidProtocolBufferNanoException {
1228          CheckedMessage wrapper = new CheckedMessage();
1229          MessageNano.mergeFrom(wrapper, buffer, 0, dataSize);
1230          CRC32 checksum = new CRC32();
1231          checksum.update(wrapper.payload);
1232          if (wrapper.checksum != checksum.getValue()) {
1233              throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1234          }
1235          return wrapper.payload;
1236      }
1237  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1238 -    private boolean initializeIconCache() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1239 -        if (mIconCache != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1240 -            return true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1241 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1242 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1243 -        final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1244 -        if (appState == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1245 -            Throwable stackTrace = new Throwable();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1246 -            stackTrace.fillInStackTrace();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1247 -            Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1248 -            return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1249 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1250 -        mIconCache = appState.getIconCache();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1251 -        return mIconCache != null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1252 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1253 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1254 -</span>
1255      /**
1256       * @return true if the launcher is in a state to support backup
1257       */
1258      private boolean launcherIsReady() {
1259          ContentResolver cr = mContext.getContentResolver();
1260          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);
1261          if (cursor == null) {
1262              // launcher data has been wiped, do nothing
1263              return false;
1264          }
1265          cursor.close();
1266  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1267 -        if (!initializeIconCache()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1268 +        if (LauncherAppState.getInstanceNoCreate() == null) {</span>
1269              // launcher services are unavailable, try again later
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1270 -            dataChanged();</span>
1271              return false;
1272          }
1273  
1274          return true;
1275      }
1276  
1277      private String getUserSelectionArg() {
1278          return Favorites.PROFILE_ID + &#x27;=&#x27; + UserManagerCompat.getInstance(mContext)
1279                  .getSerialNumberForUser(UserHandleCompat.myUserHandle());
1280      }
1281  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1282 -    private class InvalidBackupException extends IOException {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1283 -        private InvalidBackupException(Throwable cause) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1284 +    @Thunk class InvalidBackupException extends IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1285 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1286 +        private static final long serialVersionUID = 8931456637211665082L;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1287 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1288 +        @Thunk InvalidBackupException(Throwable cause) {</span>
1289              super(cause);
1290          }
1291  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1292 -        public InvalidBackupException(String reason) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1293 +        @Thunk InvalidBackupException(String reason) {</span>
1294              super(reason);
1295          }
1296      }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1297 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1298 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1299 +     * A class to check if an activity can handle one of the intents from a list of</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1300 +     * predefined intents.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1301 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1302 +    private class ItemTypeMatcher {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1303 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1304 +        private final ArrayList&lt;Intent&gt; mIntents;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1305 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1306 +        ItemTypeMatcher(int xml_res) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1307 +            mIntents = xml_res == 0 ? new ArrayList&lt;Intent&gt;() : parseIntents(xml_res);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1308 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1309 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1310 +        private ArrayList&lt;Intent&gt; parseIntents(int xml_res) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1311 +            ArrayList&lt;Intent&gt; intents = new ArrayList&lt;Intent&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1312 +            XmlResourceParser parser = mContext.getResources().getXml(xml_res);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1313 +            try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1314 +                DefaultLayoutParser.beginDocument(parser, DefaultLayoutParser.TAG_RESOLVE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1315 +                final int depth = parser.getDepth();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1316 +                int type;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1317 +                while (((type = parser.next()) != XmlPullParser.END_TAG ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1318 +                        parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1319 +                    if (type != XmlPullParser.START_TAG) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1320 +                        continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1321 +                    } else if (DefaultLayoutParser.TAG_FAVORITE.equals(parser.getName())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1322 +                        final String uri = DefaultLayoutParser.getAttributeValue(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1323 +                                parser, DefaultLayoutParser.ATTR_URI);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1324 +                        intents.add(Intent.parseUri(uri, 0));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1325 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1326 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1327 +            } catch (URISyntaxException | XmlPullParserException | IOException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1328 +                Log.e(TAG, &quot;Unable to parse &quot; + xml_res, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1329 +            } finally {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1330 +                parser.close();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1331 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1332 +            return intents;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1333 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1334 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1335 +        public boolean matches(ActivityInfo activity, PackageManager pm) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1336 +            for (Intent intent : mIntents) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1337 +                intent.setPackage(activity.packageName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1338 +                ResolveInfo info = pm.resolveActivity(intent, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1339 +                if (info != null &amp;&amp; (info.activityInfo.name.equals(activity.name)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1340 +                        || info.activityInfo.name.equals(activity.targetActivity))) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1341 +                    return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1342 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1343 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1344 +            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1345 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1346 +    }</span>
1347  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2013 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  package com.android.launcher3;
  17  
  18  import android.app.backup.BackupDataInputStream;
  19  import android.app.backup.BackupDataOutput;
  20  import android.app.backup.BackupHelper;
  21  import android.app.backup.BackupManager;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  22 -import android.appwidget.AppWidgetProviderInfo;</span>
  23  import android.content.ComponentName;
  24  import android.content.ContentResolver;
  25  import android.content.ContentValues;
  26  import android.content.Context;
  27  import android.content.Intent;


  28  import android.content.pm.PackageManager.NameNotFoundException;


  29  import android.database.Cursor;
  30  import android.graphics.Bitmap;
  31  import android.graphics.BitmapFactory;
  32  import android.graphics.drawable.Drawable;
  33  import android.os.ParcelFileDescriptor;
  34  import android.text.TextUtils;
  35  import android.util.Base64;
  36  import android.util.Log;
  37  
  38  import com.android.launcher3.LauncherSettings.Favorites;
  39  import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  40  import com.android.launcher3.backup.BackupProtos;
  41  import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  42  import com.android.launcher3.backup.BackupProtos.DeviceProfieData;
  43  import com.android.launcher3.backup.BackupProtos.Favorite;
  44  import com.android.launcher3.backup.BackupProtos.Journal;
  45  import com.android.launcher3.backup.BackupProtos.Key;
  46  import com.android.launcher3.backup.BackupProtos.Resource;
  47  import com.android.launcher3.backup.BackupProtos.Screen;
  48  import com.android.launcher3.backup.BackupProtos.Widget;
  49  import com.android.launcher3.compat.UserHandleCompat;
  50  import com.android.launcher3.compat.UserManagerCompat;

  51  import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  52  import com.google.protobuf.nano.MessageNano;
  53  
  54  import java.io.ByteArrayOutputStream;



  55  import java.io.FileInputStream;
  56  import java.io.FileOutputStream;
  57  import java.io.IOException;
  58  import java.net.URISyntaxException;
  59  import java.util.ArrayList;
  60  import java.util.Arrays;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  61 -import java.util.HashMap;</span>
  62  import java.util.HashSet;
  63  import java.util.zip.CRC32;
  64  
  65  /**
  66   * Persist the launcher home state across calamities.
  67   */
  68  public class LauncherBackupHelper implements BackupHelper {
  69      private static final String TAG = &quot;LauncherBackupHelper&quot;;
  70      private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  71      private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  72  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  73 -    private static final int BACKUP_VERSION = 2;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  74 +    private static final int BACKUP_VERSION = 3;</span>
  75      private static final int MAX_JOURNAL_SIZE = 1000000;
  76  
  77      // Journal key is such that it is always smaller than any dynamically generated
  78      // key (any Base64 encoded string).
  79      private static final String JOURNAL_KEY = &quot;#&quot;;
  80  
  81      /** icons are large, dribble them out */
  82      private static final int MAX_ICONS_PER_PASS = 10;
  83  
  84      /** widgets contain previews, which are very large, dribble them out */
  85      private static final int MAX_WIDGETS_PER_PASS = 5;
  86  
  87      private static final int IMAGE_COMPRESSION_QUALITY = 75;
  88  
  89      private static final Bitmap.CompressFormat IMAGE_FORMAT =
  90              android.graphics.Bitmap.CompressFormat.PNG;
  91  
  92      private static final String[] FAVORITE_PROJECTION = {
  93          Favorites._ID,                     // 0
  94          Favorites.MODIFIED,                // 1
  95          Favorites.INTENT,                  // 2
  96          Favorites.APPWIDGET_PROVIDER,      // 3
  97          Favorites.APPWIDGET_ID,            // 4
  98          Favorites.CELLX,                   // 5
  99          Favorites.CELLY,                   // 6
 100          Favorites.CONTAINER,               // 7
 101          Favorites.ICON,                    // 8
 102          Favorites.ICON_PACKAGE,            // 9
 103          Favorites.ICON_RESOURCE,           // 10
 104          Favorites.ICON_TYPE,               // 11
 105          Favorites.ITEM_TYPE,               // 12
 106          Favorites.SCREEN,                  // 13
 107          Favorites.SPANX,                   // 14
 108          Favorites.SPANY,                   // 15
 109          Favorites.TITLE,                   // 16
 110          Favorites.PROFILE_ID,              // 17
 111      };
 112  
 113      private static final int ID_INDEX = 0;
 114      private static final int ID_MODIFIED = 1;
 115      private static final int INTENT_INDEX = 2;
 116      private static final int APPWIDGET_PROVIDER_INDEX = 3;
 117      private static final int APPWIDGET_ID_INDEX = 4;
 118      private static final int CELLX_INDEX = 5;
 119      private static final int CELLY_INDEX = 6;
 120      private static final int CONTAINER_INDEX = 7;
 121      private static final int ICON_INDEX = 8;
 122      private static final int ICON_PACKAGE_INDEX = 9;
 123      private static final int ICON_RESOURCE_INDEX = 10;
 124      private static final int ICON_TYPE_INDEX = 11;
 125      private static final int ITEM_TYPE_INDEX = 12;
 126      private static final int SCREEN_INDEX = 13;
 127      private static final int SPANX_INDEX = 14;
 128      private static final int SPANY_INDEX = 15;
 129      private static final int TITLE_INDEX = 16;
 130  
 131      private static final String[] SCREEN_PROJECTION = {
 132          WorkspaceScreens._ID,              // 0
 133          WorkspaceScreens.MODIFIED,         // 1
 134          WorkspaceScreens.SCREEN_RANK       // 2
 135      };
 136  
 137      private static final int SCREEN_RANK_INDEX = 2;
 138  
 139      private final Context mContext;

 140      private final HashSet&lt;String&gt; mExistingKeys;
 141      private final ArrayList&lt;Key&gt; mKeys;
 142  
 143      private IconCache mIconCache;



 144      private BackupManager mBackupManager;
 145      private byte[] mBuffer = new byte[512];
 146      private long mLastBackupRestoreTime;
 147      private boolean mBackupDataWasUpdated;
 148  
 149      private DeviceProfieData mCurrentProfile;




 150      boolean restoreSuccessful;
 151      int restoredBackupVersion = 1;
 152  
 153      public LauncherBackupHelper(Context context) {
 154          mContext = context;
 155          mExistingKeys = new HashSet&lt;String&gt;();
 156          mKeys = new ArrayList&lt;Key&gt;();
 157          restoreSuccessful = true;




 158      }
 159  
 160      private void dataChanged() {
 161          if (mBackupManager == null) {
 162              mBackupManager = new BackupManager(mContext);
 163          }
 164          mBackupManager.dataChanged();
 165      }
 166  
 167      private void applyJournal(Journal journal) {
 168          mLastBackupRestoreTime = journal.t;
 169          mExistingKeys.clear();
 170          if (journal.key != null) {
 171              for (Key key : journal.key) {
 172                  mExistingKeys.add(keyToBackupKey(key));
 173              }
 174          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 175 +        restoredBackupVersion = journal.backupVersion;</span>
 176      }
 177  
 178      /**
 179       * Back up launcher data so we can restore the user&#x27;s state on a new device.
 180       *
 181       * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 182       *
 183       * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 184       *
 185       * @param oldState notes from the last backup
 186       * @param data incremental key/value pairs to persist off-device
 187       * @param newState notes for the next backup
 188       */
 189      @Override
 190      public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 191              ParcelFileDescriptor newState) {
 192          if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 193  
 194          Journal in = readJournal(oldState);
 195          if (!launcherIsReady()) {

 196              // Perform backup later.
 197              writeJournal(newState, in);
 198              return;
 199          }








 200          Log.v(TAG, &quot;lastBackupTime = &quot; + in.t);
 201          mKeys.clear();
 202          applyJournal(in);
 203  
 204          // Record the time before performing backup so that entries edited while the backup
 205          // was going on, do not get missed in next backup.
 206          long newBackupTime = System.currentTimeMillis();
 207          mBackupDataWasUpdated = false;
 208          try {
 209              backupFavorites(data);
 210              backupScreens(data);
 211              backupIcons(data);
 212              backupWidgets(data);
 213  
 214              // Delete any key which still exist in the old backup, but is not valid anymore.
 215              HashSet&lt;String&gt; validKeys = new HashSet&lt;String&gt;();
 216              for (Key key : mKeys) {
 217                  validKeys.add(keyToBackupKey(key));
 218              }
 219              mExistingKeys.removeAll(validKeys);
 220  
 221              // Delete anything left in the existing keys.
 222              for (String deleted: mExistingKeys) {
 223                  if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
 224                  data.writeEntityHeader(deleted, -1);
 225                  mBackupDataWasUpdated = true;
 226              }
 227  
 228              mExistingKeys.clear();
 229              if (!mBackupDataWasUpdated) {
 230                  // Check if any metadata has changed
 231                  mBackupDataWasUpdated = (in.profile == null)
 232                          || !Arrays.equals(DeviceProfieData.toByteArray(in.profile),
 233                              DeviceProfieData.toByteArray(getDeviceProfieData()))

 234                          || (in.backupVersion != BACKUP_VERSION)
 235                          || (in.appVersion != getAppVersion());
 236              }
 237  
 238              if (mBackupDataWasUpdated) {
 239                  mLastBackupRestoreTime = newBackupTime;
 240  
 241                  // We store the journal at two places.
 242                  //   1) Storing it in newState allows us to do partial backups by comparing old state
 243                  //   2) Storing it in backup data allows us to validate keys during restore
 244                  Journal state = getCurrentStateJournal();
 245                  writeRowToBackup(JOURNAL_KEY, state, data);
 246              } else {
 247                  if (DEBUG) Log.d(TAG, &quot;Nothing was written during backup&quot;);
 248              }
 249          } catch (IOException e) {
 250              Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 251          }
 252  
 253          writeNewStateDescription(newState);
 254      }
 255  
 256      /**
 257       * @return true if the backup corresponding to oldstate can be successfully applied
 258       * to this device.
 259       */
 260      private boolean isBackupCompatible(Journal oldState) {
 261          DeviceProfieData currentProfile = getDeviceProfieData();
 262  

 263          DeviceProfieData oldProfile = oldState.profile;
 264  
 265          if (oldProfile == null || oldProfile.desktopCols == 0) {
 266              // Profile info is not valid, ignore the check.
 267              return true;
 268          }
 269  
 270          boolean isHotsetCompatible = false;
 271          if (currentProfile.allappsRank &gt;= oldProfile.hotseatCount) {
 272              isHotsetCompatible = true;
 273          }
 274          if ((currentProfile.hotseatCount &gt;= oldProfile.hotseatCount) &amp;&amp;
 275                  (currentProfile.allappsRank == oldProfile.allappsRank)) {
 276              isHotsetCompatible = true;
 277          }
 278  
 279          return isHotsetCompatible &amp;&amp; (currentProfile.desktopCols &gt;= oldProfile.desktopCols)
 280                  &amp;&amp; (currentProfile.desktopRows &gt;= oldProfile.desktopRows);
 281      }
 282  
 283      /**
 284       * Restore launcher configuration from the restored data stream.
 285       * It assumes that the keys will arrive in lexical order. So if the journal was present in the
 286       * backup, it should arrive first.
 287       *
 288       * @param data the key/value pair from the server
 289       */
 290      @Override
 291      public void restoreEntity(BackupDataInputStream data) {
 292          if (!restoreSuccessful) {
 293              return;








 294          }
 295  
 296          int dataSize = data.size();
 297          if (mBuffer.length &lt; dataSize) {
 298              mBuffer = new byte[dataSize];
 299          }
 300          try {
 301              int bytesRead = data.read(mBuffer, 0, dataSize);
 302              if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 303              String backupKey = data.getKey();
 304  
 305              if (JOURNAL_KEY.equals(backupKey)) {
 306                  if (VERBOSE) Log.v(TAG, &quot;Journal entry restored&quot;);
 307                  if (!mKeys.isEmpty()) {
 308                      // We received the journal key after a restore key.
 309                      Log.wtf(TAG, keyToBackupKey(mKeys.get(0)) + &quot; received after &quot; + JOURNAL_KEY);
 310                      restoreSuccessful = false;
 311                      return;
 312                  }
 313  
 314                  Journal journal = new Journal();
 315                  MessageNano.mergeFrom(journal, readCheckedBytes(mBuffer, dataSize));
 316                  applyJournal(journal);
 317                  restoreSuccessful = isBackupCompatible(journal);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 318 -                restoredBackupVersion = journal.backupVersion;</span>
 319                  return;
 320              }
 321  
 322              if (!mExistingKeys.isEmpty() &amp;&amp; !mExistingKeys.contains(backupKey)) {
 323                  if (DEBUG) Log.e(TAG, &quot;Ignoring key not present in the backup state &quot; + backupKey);
 324                  return;
 325              }
 326              Key key = backupKeyToKey(backupKey);
 327              mKeys.add(key);
 328              switch (key.type) {
 329                  case Key.FAVORITE:
 330                      restoreFavorite(key, mBuffer, dataSize);
 331                      break;
 332  
 333                  case Key.SCREEN:
 334                      restoreScreen(key, mBuffer, dataSize);
 335                      break;
 336  
 337                  case Key.ICON:
 338                      restoreIcon(key, mBuffer, dataSize);
 339                      break;
 340  
 341                  case Key.WIDGET:
 342                      restoreWidget(key, mBuffer, dataSize);
 343                      break;
 344  
 345                  default:
 346                      Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 347                      mKeys.remove(key);
 348                      break;
 349              }
 350          } catch (IOException e) {
 351              Log.w(TAG, &quot;ignoring unparsable backup entry&quot;, e);
 352          }
 353      }
 354  
 355      /**
 356       * Record the restore state for the next backup.
 357       *
 358       * @param newState notes about the backup state after restore.
 359       */
 360      @Override
 361      public void writeNewStateDescription(ParcelFileDescriptor newState) {
 362          writeJournal(newState, getCurrentStateJournal());
 363      }
 364  
 365      private Journal getCurrentStateJournal() {
 366          Journal journal = new Journal();
 367          journal.t = mLastBackupRestoreTime;
 368          journal.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);
 369          journal.appVersion = getAppVersion();
 370          journal.backupVersion = BACKUP_VERSION;
 371          journal.profile = getDeviceProfieData();

 372          return journal;
 373      }
 374  
 375      private int getAppVersion() {
 376          try {
 377              return mContext.getPackageManager()
 378                      .getPackageInfo(mContext.getPackageName(), 0).versionCode;
 379          } catch (NameNotFoundException e) {
 380              return 0;
 381          }
 382      }
 383  
 384      /**
 385       * @return the current device profile information.
 386       */
 387      private DeviceProfieData getDeviceProfieData() {
 388          if (mCurrentProfile != null) {
 389              return mCurrentProfile;
 390          }
 391          final Context applicationContext = mContext.getApplicationContext();
 392          DeviceProfile profile = LauncherAppState.createDynamicGrid(applicationContext, null)
 393                  .getDeviceProfile();
 394  
 395          mCurrentProfile = new DeviceProfieData();
 396          mCurrentProfile.desktopRows = profile.numRows;
 397          mCurrentProfile.desktopCols = profile.numColumns;
 398          mCurrentProfile.hotseatCount = profile.numHotseatIcons;
 399          mCurrentProfile.allappsRank = profile.hotseatAllAppsRank;
 400          return mCurrentProfile;







 401      }
 402  
 403      /**
 404       * Write all modified favorites to the data stream.
 405       *
 406       * @param data output stream for key/value pairs
 407       * @throws IOException
 408       */
 409      private void backupFavorites(BackupDataOutput data) throws IOException {
 410          // persist things that have changed since the last backup
 411          ContentResolver cr = mContext.getContentResolver();
 412          // Don&#x27;t backup apps in other profiles for now.
 413          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 414                  getUserSelectionArg(), null, null);
 415          try {
 416              cursor.moveToPosition(-1);
 417              while(cursor.moveToNext()) {
 418                  final long id = cursor.getLong(ID_INDEX);
 419                  final long updateTime = cursor.getLong(ID_MODIFIED);
 420                  Key key = getKey(Key.FAVORITE, id);
 421                  mKeys.add(key);
 422                  final String backupKey = keyToBackupKey(key);
 423                  if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 424                      writeRowToBackup(key, packFavorite(cursor), data);
 425                  } else {
 426                      if (DEBUG) Log.d(TAG, &quot;favorite already backup up: &quot; + id);
 427                  }
 428              }
 429          } finally {
 430              cursor.close();
 431          }
 432      }
 433  
 434      /**
 435       * Read a favorite from the stream.
 436       *
 437       * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 438       *
 439       * @param key identifier for the row
 440       * @param buffer the serialized proto from the stream, may be larger than dataSize
 441       * @param dataSize the size of the proto from the stream
 442       */
 443      private void restoreFavorite(Key key, byte[] buffer, int dataSize) throws IOException {
 444          if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 445          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 446                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 447  
 448          ContentResolver cr = mContext.getContentResolver();
 449          ContentValues values = unpackFavorite(buffer, dataSize);
 450          cr.insert(Favorites.CONTENT_URI_NO_NOTIFICATION, values);

 451      }
 452  
 453      /**
 454       * Write all modified screens to the data stream.
 455       *
 456       * @param data output stream for key/value pairs
 457       * @throws IOException
 458       */
 459      private void backupScreens(BackupDataOutput data) throws IOException {
 460          // persist things that have changed since the last backup
 461          ContentResolver cr = mContext.getContentResolver();
 462          Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 463                  null, null, null);
 464          try {
 465              cursor.moveToPosition(-1);
 466              if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + mLastBackupRestoreTime);
 467              while(cursor.moveToNext()) {
 468                  final long id = cursor.getLong(ID_INDEX);
 469                  final long updateTime = cursor.getLong(ID_MODIFIED);
 470                  Key key = getKey(Key.SCREEN, id);
 471                  mKeys.add(key);
 472                  final String backupKey = keyToBackupKey(key);
 473                  if (!mExistingKeys.contains(backupKey) || updateTime &gt;= mLastBackupRestoreTime) {
 474                      writeRowToBackup(key, packScreen(cursor), data);
 475                  } else {
 476                      if (VERBOSE) Log.v(TAG, &quot;screen already backup up &quot; + id);
 477                  }
 478              }
 479          } finally {
 480              cursor.close();
 481          }
 482      }
 483  
 484      /**
 485       * Read a screen from the stream.
 486       *
 487       * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 488       *
 489       * @param key identifier for the row
 490       * @param buffer the serialized proto from the stream, may be larger than dataSize
 491       * @param dataSize the size of the proto from the stream
 492       */
 493      private void restoreScreen(Key key, byte[] buffer, int dataSize) throws IOException {
 494          if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 495          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 496                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 497  
 498          ContentResolver cr = mContext.getContentResolver();
 499          ContentValues values = unpackScreen(buffer, dataSize);
 500          cr.insert(WorkspaceScreens.CONTENT_URI, values);
 501      }
 502  
 503      /**
 504       * Write all the static icon resources we need to render placeholders
 505       * for a package that is not installed.
 506       *
 507       * @param data output stream for key/value pairs
 508       */
 509      private void backupIcons(BackupDataOutput data) throws IOException {
 510          // persist icons that haven&#x27;t been persisted yet
 511          if (!initializeIconCache()) {
 512              dataChanged(); // try again later
 513              if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 514              return;
 515          }
 516          final ContentResolver cr = mContext.getContentResolver();
 517          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 518          final UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 519          int backupUpIconCount = 0;
 520  
 521          // Don&#x27;t backup apps in other profiles for now.
 522          String where = &quot;(&quot; + Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION + &quot; OR &quot; +
 523                  Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_SHORTCUT + &quot;) AND &quot; +
 524                  getUserSelectionArg();
 525          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 526                  where, null, null);
 527          try {
 528              cursor.moveToPosition(-1);
 529              while(cursor.moveToNext()) {
 530                  final long id = cursor.getLong(ID_INDEX);
 531                  final String intentDescription = cursor.getString(INTENT_INDEX);
 532                  try {
 533                      Intent intent = Intent.parseUri(intentDescription, 0);
 534                      ComponentName cn = intent.getComponent();
 535                      Key key = null;
 536                      String backupKey = null;
 537                      if (cn != null) {
 538                          key = getKey(Key.ICON, cn.flattenToShortString());
 539                          backupKey = keyToBackupKey(key);
 540                      } else {
 541                          Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 542                      }
 543                      if (mExistingKeys.contains(backupKey)) {
 544                          if (DEBUG) Log.d(TAG, &quot;already saved icon &quot; + backupKey);
 545  
 546                          // remember that we already backed this up previously
 547                          mKeys.add(key);
 548                      } else if (backupKey != null) {
 549                          if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + backupUpIconCount);
 550                          if (backupUpIconCount &lt; MAX_ICONS_PER_PASS) {
 551                              if (DEBUG) Log.d(TAG, &quot;saving icon &quot; + backupKey);
 552                              Bitmap icon = mIconCache.getIcon(intent, myUserHandle);
 553                              if (icon != null &amp;&amp; !mIconCache.isDefaultIcon(icon, myUserHandle)) {
 554                                  writeRowToBackup(key, packIcon(dpi, icon), data);
 555                                  mKeys.add(key);
 556                                  backupUpIconCount ++;
 557                              }
 558                          } else {
 559                              if (VERBOSE) Log.v(TAG, &quot;deferring icon backup &quot; + backupKey);
 560                              // too many icons for this pass, request another.
 561                              dataChanged();
 562                          }
 563                      }
 564                  } catch (URISyntaxException e) {
 565                      Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 566                  } catch (IOException e) {
 567                      Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 568                  }
 569  
 570              }
 571          } finally {
 572              cursor.close();
 573          }
 574      }
 575  
 576      /**
 577       * Read an icon from the stream.
 578       *
 579       * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 580       *
 581       * @param key identifier for the row
 582       * @param buffer the serialized proto from the stream, may be larger than dataSize
 583       * @param dataSize the size of the proto from the stream
 584       */
 585      private void restoreIcon(Key key, byte[] buffer, int dataSize) throws IOException {
 586          if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 587          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 588                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 589  
 590          Resource res = unpackProto(new Resource(), buffer, dataSize);
 591          if (DEBUG) {
 592              Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 593          }
 594          Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 595          if (icon == null) {
 596              Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 597          }
 598          if (VERBOSE) Log.v(TAG, &quot;saving restored icon as: &quot; + key.name);
 599          IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(key.name), icon, res.dpi);


 600      }
 601  
 602      /**
 603       * Write all the static widget resources we need to render placeholders
 604       * for a package that is not installed.
 605       *
 606       * @param data output stream for key/value pairs
 607       * @throws IOException
 608       */
 609      private void backupWidgets(BackupDataOutput data) throws IOException {
 610          // persist static widget info that hasn&#x27;t been persisted yet
 611          final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 612          if (appState == null || !initializeIconCache()) {
 613              Log.w(TAG, &quot;Failed to get icon cache during restore&quot;);
 614              return;
 615          }
 616          final ContentResolver cr = mContext.getContentResolver();
 617          final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 618          final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
 619          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 620          final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 621          if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 622          int backupWidgetCount = 0;
 623  
 624          String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET + &quot; AND &quot;
 625                  + getUserSelectionArg();
 626          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 627                  where, null, null);
 628          try {
 629              cursor.moveToPosition(-1);
 630              while(cursor.moveToNext()) {
 631                  final long id = cursor.getLong(ID_INDEX);
 632                  final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 633                  final int spanX = cursor.getInt(SPANX_INDEX);
 634                  final int spanY = cursor.getInt(SPANY_INDEX);
 635                  final ComponentName provider = ComponentName.unflattenFromString(providerName);
 636                  Key key = null;
 637                  String backupKey = null;
 638                  if (provider != null) {
 639                      key = getKey(Key.WIDGET, providerName);
 640                      backupKey = keyToBackupKey(key);
 641                  } else {
 642                      Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 643                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 644 -                if (mExistingKeys.contains(backupKey)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 645 +                if (mExistingKeys.contains(backupKey) &amp;&amp; restoredBackupVersion &gt;= BACKUP_VERSION) {</span>
 646                      if (DEBUG) Log.d(TAG, &quot;already saved widget &quot; + backupKey);
 647  
 648                      // remember that we already backed this up previously
 649                      mKeys.add(key);
 650                  } else if (backupKey != null) {
 651                      if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + backupWidgetCount);
 652                      if (backupWidgetCount &lt; MAX_WIDGETS_PER_PASS) {
 653                          if (DEBUG) Log.d(TAG, &quot;saving widget &quot; + backupKey);
 654                          previewLoader.setPreviewSize(spanX * profile.cellWidthPx,
 655                                  spanY * profile.cellHeightPx, widgetSpacingLayout);
 656                          UserHandleCompat user = UserHandleCompat.myUserHandle();
 657                          writeRowToBackup(key,
 658                                  packWidget(dpi, previewLoader, mIconCache, provider, user),
 659                                  data);

 660                          mKeys.add(key);
 661                          backupWidgetCount ++;
 662                      } else {
 663                          if (VERBOSE) Log.v(TAG, &quot;deferring widget backup &quot; + backupKey);
 664                          // too many widgets for this pass, request another.
 665                          dataChanged();
 666                      }
 667                  }
 668              }
 669          } finally {
 670              cursor.close();
 671          }
 672      }
 673  
 674      /**
 675       * Read a widget from the stream.
 676       *
 677       * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 678       *
 679       * @param key identifier for the row
 680       * @param buffer the serialized proto from the stream, may be larger than dataSize
 681       * @param dataSize the size of the proto from the stream
 682       */
 683      private void restoreWidget(Key key, byte[] buffer, int dataSize) throws IOException {
 684          if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 685          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 686                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 687          Widget widget = unpackProto(new Widget(), buffer, dataSize);
 688          if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 689          if (widget.icon.data != null)  {
 690              Bitmap icon = BitmapFactory
 691                      .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 692              if (icon == null) {
 693                  Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 694              } else {
 695                  IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(widget.provider),
 696                          icon, widget.icon.dpi);


 697              }
 698          }
 699  
 700          // future site of widget table mutation
 701      }
 702  
 703      /** create a new key, with an integer ID.
 704       *
 705       * &lt;P&gt; Keys contain their own checksum instead of using
 706       * the heavy-weight CheckedMessage wrapper.
 707       */
 708      private Key getKey(int type, long id) {
 709          Key key = new Key();
 710          key.type = type;
 711          key.id = id;
 712          key.checksum = checkKey(key);
 713          return key;
 714      }
 715  
 716      /** create a new key for a named object.
 717       *
 718       * &lt;P&gt; Keys contain their own checksum instead of using
 719       * the heavy-weight CheckedMessage wrapper.
 720       */
 721      private Key getKey(int type, String name) {
 722          Key key = new Key();
 723          key.type = type;
 724          key.name = name;
 725          key.checksum = checkKey(key);
 726          return key;
 727      }
 728  
 729      /** keys need to be strings, serialize and encode. */
 730      private String keyToBackupKey(Key key) {
 731          return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 732      }
 733  
 734      /** keys need to be strings, decode and parse. */
 735      private Key backupKeyToKey(String backupKey) throws InvalidBackupException {
 736          try {
 737              Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 738              if (key.checksum != checkKey(key)) {
 739                  key = null;
 740                  throw new InvalidBackupException(&quot;invalid key read from stream&quot; + backupKey);
 741              }
 742              return key;
 743          } catch (InvalidProtocolBufferNanoException e) {
 744              throw new InvalidBackupException(e);
 745          } catch (IllegalArgumentException e) {
 746              throw new InvalidBackupException(e);
 747          }
 748      }
 749  
 750      /** Compute the checksum over the important bits of a key. */
 751      private long checkKey(Key key) {
 752          CRC32 checksum = new CRC32();
 753          checksum.update(key.type);
 754          checksum.update((int) (key.id &amp; 0xffff));
 755          checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 756          if (!TextUtils.isEmpty(key.name)) {
 757              checksum.update(key.name.getBytes());
 758          }
 759          return checksum.getValue();











 760      }
 761  
 762      /** Serialize a Favorite for persistence, including a checksum wrapper. */
 763      private Favorite packFavorite(Cursor c) {
 764          Favorite favorite = new Favorite();
 765          favorite.id = c.getLong(ID_INDEX);
 766          favorite.screen = c.getInt(SCREEN_INDEX);
 767          favorite.container = c.getInt(CONTAINER_INDEX);
 768          favorite.cellX = c.getInt(CELLX_INDEX);
 769          favorite.cellY = c.getInt(CELLY_INDEX);
 770          favorite.spanX = c.getInt(SPANX_INDEX);
 771          favorite.spanY = c.getInt(SPANY_INDEX);
 772          favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 773          if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 774              String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 775              if (!TextUtils.isEmpty(iconPackage)) {
 776                  favorite.iconPackage = iconPackage;
 777              }
 778              String iconResource = c.getString(ICON_RESOURCE_INDEX);
 779              if (!TextUtils.isEmpty(iconResource)) {
 780                  favorite.iconResource = iconResource;
 781              }
 782          }
 783          if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 784              byte[] blob = c.getBlob(ICON_INDEX);
 785              if (blob != null &amp;&amp; blob.length &gt; 0) {
 786                  favorite.icon = blob;
 787              }
 788          }

 789          String title = c.getString(TITLE_INDEX);
 790          if (!TextUtils.isEmpty(title)) {
 791              favorite.title = title;
 792          }
 793          String intentDescription = c.getString(INTENT_INDEX);

 794          if (!TextUtils.isEmpty(intentDescription)) {
 795              try {
 796                  Intent intent = Intent.parseUri(intentDescription, 0);

 797                  intent.removeExtra(ItemInfo.EXTRA_PROFILE);
 798                  favorite.intent = intent.toUri(0);
 799              } catch (URISyntaxException e) {
 800                  Log.e(TAG, &quot;Invalid intent&quot;, e);
 801              }
 802          }
 803          favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 804          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 805              favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 806              String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 807              if (!TextUtils.isEmpty(appWidgetProvider)) {
 808                  favorite.appWidgetProvider = appWidgetProvider;
 809              }









































 810          }
 811  
 812          return favorite;
 813      }
 814  
 815      /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 816      private ContentValues unpackFavorite(byte[] buffer, int dataSize)
 817              throws IOException {
 818          Favorite favorite = unpackProto(new Favorite(), buffer, dataSize);

 819          ContentValues values = new ContentValues();
 820          values.put(Favorites._ID, favorite.id);
 821          values.put(Favorites.SCREEN, favorite.screen);
 822          values.put(Favorites.CONTAINER, favorite.container);
 823          values.put(Favorites.CELLX, favorite.cellX);
 824          values.put(Favorites.CELLY, favorite.cellY);
 825          values.put(Favorites.SPANX, favorite.spanX);
 826          values.put(Favorites.SPANY, favorite.spanY);
 827          values.put(Favorites.ICON_TYPE, favorite.iconType);
 828          if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 829              values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 830              values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 831          }
 832          if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {







 833              values.put(Favorites.ICON, favorite.icon);
 834          }

 835          if (!TextUtils.isEmpty(favorite.title)) {
 836              values.put(Favorites.TITLE, favorite.title);
 837          } else {
 838              values.put(Favorites.TITLE, &quot;&quot;);
 839          }
 840          if (!TextUtils.isEmpty(favorite.intent)) {
 841              values.put(Favorites.INTENT, favorite.intent);
 842          }
 843          values.put(Favorites.ITEM_TYPE, favorite.itemType);
 844  
 845          UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 846          long userSerialNumber =
 847                  UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHandle);
 848          values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
 849  
 850          DeviceProfieData currentProfile = getDeviceProfieData();

 851  
 852          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 853              if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 854                  values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 855              }
 856              values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 857              values.put(LauncherSettings.Favorites.RESTORED,
 858                      LauncherAppWidgetInfo.FLAG_ID_NOT_VALID |
 859                      LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY |
 860                      LauncherAppWidgetInfo.FLAG_UI_NOT_READY);
 861  
 862              // Verify placement
 863              if (((favorite.cellX + favorite.spanX) &gt; currentProfile.desktopCols)
 864                      || ((favorite.cellY + favorite.spanY) &gt; currentProfile.desktopRows)) {
 865                  restoreSuccessful = false;
 866                  throw new InvalidBackupException(&quot;Widget not in screen bounds, aborting restore&quot;);
 867              }
 868          } else {
 869              // Let LauncherModel know we&#x27;ve been here.
 870              values.put(LauncherSettings.Favorites.RESTORED, 1);











 871  
 872              // Verify placement
 873              if (favorite.container == Favorites.CONTAINER_HOTSEAT) {
 874                  if ((favorite.screen &gt;= currentProfile.hotseatCount)
 875                          || (favorite.screen == currentProfile.allappsRank)) {
 876                      restoreSuccessful = false;
 877                      throw new InvalidBackupException(&quot;Item not in hotseat bounds, aborting restore&quot;);
 878                  }
 879              } else {
 880                  if ((favorite.cellX &gt;= currentProfile.desktopCols)
 881                          || (favorite.cellY &gt;= currentProfile.desktopRows)) {
 882                      restoreSuccessful = false;
 883                      throw new InvalidBackupException(&quot;Item not in desktop bounds, aborting restore&quot;);
 884                  }
 885              }
 886          }
 887  
 888          return values;
 889      }
 890  
 891      /** Serialize a Screen for persistence, including a checksum wrapper. */
 892      private Screen packScreen(Cursor c) {
 893          Screen screen = new Screen();
 894          screen.id = c.getLong(ID_INDEX);
 895          screen.rank = c.getInt(SCREEN_RANK_INDEX);
 896          return screen;
 897      }
 898  
 899      /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 900      private ContentValues unpackScreen(byte[] buffer, int dataSize)
 901              throws InvalidProtocolBufferNanoException {
 902          Screen screen = unpackProto(new Screen(), buffer, dataSize);
 903          ContentValues values = new ContentValues();
 904          values.put(WorkspaceScreens._ID, screen.id);
 905          values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 906          return values;
 907      }
 908  
 909      /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 910      private Resource packIcon(int dpi, Bitmap icon) {
 911          Resource res = new Resource();
 912          res.dpi = dpi;
 913          ByteArrayOutputStream os = new ByteArrayOutputStream();
 914          if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 915              res.data = os.toByteArray();
 916          }

 917          return res;
 918      }
 919  
 920      /** Serialize a widget for persistence, including a checksum wrapper. */
 921      private Widget packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 922              ComponentName provider, UserHandleCompat user) {

 923          final LauncherAppWidgetProviderInfo info =
 924                  LauncherModel.getProviderInfo(mContext, provider, user);
 925          Widget widget = new Widget();
 926          widget.provider = provider.flattenToShortString();
 927          widget.label = info.label;
 928          widget.configure = info.configure != null;
 929          if (info.icon != 0) {
 930              widget.icon = new Resource();
 931              Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);

 932              Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 933              ByteArrayOutputStream os = new ByteArrayOutputStream();
 934              if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 935                  widget.icon.data = os.toByteArray();
 936                  widget.icon.dpi = dpi;
 937              }
 938          }
 939          if (info.previewImage != 0) {
 940              widget.preview = new Resource();
 941              Bitmap preview = previewLoader.generateWidgetPreview(info, null);
 942              ByteArrayOutputStream os = new ByteArrayOutputStream();
 943              if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 944                  widget.preview.data = os.toByteArray();
 945                  widget.preview.dpi = dpi;
 946              }
 947          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 948 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 949 +        widget.minSpanX = (info.resizeMode &amp; LauncherAppWidgetProviderInfo.RESIZE_HORIZONTAL) != 0</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 950 +                ? info.minSpanX : -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 951 +        widget.minSpanY = (info.resizeMode &amp; LauncherAppWidgetProviderInfo.RESIZE_VERTICAL) != 0</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 952 +                ? info.minSpanY : -1;</span>








 953          return widget;
 954      }
 955  
 956      /**
 957       * Deserialize a proto after verifying checksum wrapper.
 958       */
 959      private &lt;T extends MessageNano&gt; T unpackProto(T proto, byte[] buffer, int dataSize)
 960              throws InvalidProtocolBufferNanoException {
 961          MessageNano.mergeFrom(proto, readCheckedBytes(buffer, dataSize));
 962          if (DEBUG) Log.d(TAG, &quot;unpacked proto &quot; + proto);
 963          return proto;
 964      }
 965  
 966      /**
 967       * Read the old journal from the input file.
 968       *
 969       * In the event of any error, just pretend we didn&#x27;t have a journal,
 970       * in that case, do a full backup.
 971       *
 972       * @param oldState the read-0only file descriptor pointing to the old journal
 973       * @return a Journal protocol buffer
 974       */
 975      private Journal readJournal(ParcelFileDescriptor oldState) {
 976          Journal journal = new Journal();
 977          if (oldState == null) {
 978              return journal;
 979          }
 980          FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
 981          try {
 982              int availableBytes = inStream.available();
 983              if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
 984              if (availableBytes &lt; MAX_JOURNAL_SIZE) {
 985                  byte[] buffer = new byte[availableBytes];
 986                  int bytesRead = 0;
 987                  boolean valid = false;
 988                  InvalidProtocolBufferNanoException lastProtoException = null;
 989                  while (availableBytes &gt; 0) {
 990                      try {
 991                          // OMG what are you doing? This is crazy inefficient!
 992                          // If we read a byte that is not ours, we will cause trouble: b/12491813
 993                          // However, we don&#x27;t know how many bytes to expect (oops).
 994                          // So we have to step through *slowly*, watching for the end.
 995                          int result = inStream.read(buffer, bytesRead, 1);
 996                          if (result &gt; 0) {
 997                              availableBytes -= result;
 998                              bytesRead += result;
 999                          } else {
1000                              Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1001                              // stop reading and see what there is to parse
1002                              availableBytes = 0;
1003                          }
1004                      } catch (IOException e) {
1005                          buffer = null;
1006                          availableBytes = 0;
1007                      }
1008  
1009                      // check the buffer to see if we have a valid journal
1010                      try {
1011                          MessageNano.mergeFrom(journal, readCheckedBytes(buffer, bytesRead));
1012                          // if we are here, then we have read a valid, checksum-verified journal
1013                          valid = true;
1014                          availableBytes = 0;
1015                          if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1016                      } catch (InvalidProtocolBufferNanoException e) {
1017                          // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1018                          lastProtoException = e;
1019                          journal.clear();
1020                      }
1021                  }
1022                  if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1023                  if (!valid) {
1024                      Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1025                  }
1026              }
1027          } catch (IOException e) {
1028              Log.w(TAG, &quot;failed to close the journal&quot;, e);
1029          } finally {
1030              try {
1031                  inStream.close();
1032              } catch (IOException e) {
1033                  Log.w(TAG, &quot;failed to close the journal&quot;, e);
1034              }
1035          }
1036          return journal;
1037      }
1038  
1039      private void writeRowToBackup(Key key, MessageNano proto, BackupDataOutput data)
1040              throws IOException {
1041          writeRowToBackup(keyToBackupKey(key), proto, data);
1042      }
1043  
1044      private void writeRowToBackup(String backupKey, MessageNano proto,
1045              BackupDataOutput data) throws IOException {
1046          byte[] blob = writeCheckedBytes(proto);
1047          data.writeEntityHeader(backupKey, blob.length);
1048          data.writeEntityData(blob, blob.length);
1049          mBackupDataWasUpdated = true;
1050          if (VERBOSE) Log.v(TAG, &quot;Writing New entry &quot; + backupKey);
1051      }
1052  
1053      /**
1054       * Write the new journal to the output file.
1055       *
1056       * In the event of any error, just pretend we didn&#x27;t have a journal,
1057       * in that case, do a full backup.
1058  
1059       * @param newState the write-only file descriptor pointing to the new journal
1060       * @param journal a Journal protocol buffer
1061       */
1062      private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1063          FileOutputStream outStream = null;
1064          try {
1065              outStream = new FileOutputStream(newState.getFileDescriptor());
1066              final byte[] journalBytes = writeCheckedBytes(journal);
1067              outStream.write(journalBytes);
1068              outStream.close();
1069              if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1070          } catch (IOException e) {
1071              Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1072          }
1073      }
1074  
1075      /** Wrap a proto in a CheckedMessage and compute the checksum. */
1076      private byte[] writeCheckedBytes(MessageNano proto) {
1077          CheckedMessage wrapper = new CheckedMessage();
1078          wrapper.payload = MessageNano.toByteArray(proto);
1079          CRC32 checksum = new CRC32();
1080          checksum.update(wrapper.payload);
1081          wrapper.checksum = checksum.getValue();
1082          return MessageNano.toByteArray(wrapper);
1083      }
1084  
1085      /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1086      private static byte[] readCheckedBytes(byte[] buffer, int dataSize)
1087              throws InvalidProtocolBufferNanoException {
1088          CheckedMessage wrapper = new CheckedMessage();
1089          MessageNano.mergeFrom(wrapper, buffer, 0, dataSize);
1090          CRC32 checksum = new CRC32();
1091          checksum.update(wrapper.payload);
1092          if (wrapper.checksum != checksum.getValue()) {
1093              throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1094          }
1095          return wrapper.payload;
1096      }
1097  
1098      private boolean initializeIconCache() {
1099          if (mIconCache != null) {
1100              return true;
1101          }
1102  
1103          final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
1104          if (appState == null) {
1105              Throwable stackTrace = new Throwable();
1106              stackTrace.fillInStackTrace();
1107              Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);
1108              return false;
1109          }
1110          mIconCache = appState.getIconCache();
1111          return mIconCache != null;
1112      }
1113  
1114  
1115      /**
1116       * @return true if the launcher is in a state to support backup
1117       */
1118      private boolean launcherIsReady() {
1119          ContentResolver cr = mContext.getContentResolver();
1120          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);
1121          if (cursor == null) {
1122              // launcher data has been wiped, do nothing
1123              return false;
1124          }
1125          cursor.close();
1126  
1127          if (!initializeIconCache()) {

1128              // launcher services are unavailable, try again later
1129              dataChanged();
1130              return false;
1131          }
1132  
1133          return true;
1134      }
1135  
1136      private String getUserSelectionArg() {
1137          return Favorites.PROFILE_ID + &#x27;=&#x27; + UserManagerCompat.getInstance(mContext)
1138                  .getSerialNumberForUser(UserHandleCompat.myUserHandle());
1139      }
1140  
1141      private class InvalidBackupException extends IOException {
1142          private InvalidBackupException(Throwable cause) {





1143              super(cause);
1144          }
1145  
1146          public InvalidBackupException(String reason) {

1147              super(reason);
1148          }
1149      }


















































1150  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            