<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>25 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;public class ThreadStateManager implements &#x27;
                         &#x27;IThreadState {\n&#x27;
                         &#x27;  private final String TAG = &#x27;
                         &#x27;&quot;ThreadTaskStateManager&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 任务状态回调\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private IEventListener mListener;\n&#x27;
                         &#x27;  private int mThreadNum;    // 启动的线程总数\n&#x27;
                         &#x27;  private int mCancelNum = 0; // 已经取消的线程的数\n&#x27;
                         &#x27;  private int mStopNum = 0;  // 已经停止的线程数\n&#x27;
                         &#x27;  private int mFailNum = 0;  // 失败的线程数\n&#x27;
                         &#x27;  private int mCompleteNum = 0;  // 完成的线程数\n&#x27;
                         &#x27;  private long mProgress; //当前总进度\n&#x27;
                         &#x27;  private TaskRecord mTaskRecord; // 任务记录\n&#x27;
                         &#x27;  private Looper mLooper;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * @param taskRecord 任务记录\n&#x27;
                         &#x27;   * @param listener 任务事件\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  ThreadStateManager(Looper looper, TaskRecord &#x27;
                         &#x27;taskRecord, IEventListener listener) {\n&#x27;
                         &#x27;    mLooper = looper;\n&#x27;
                         &#x27;    mTaskRecord = taskRecord;\n&#x27;
                         &#x27;    mThreadNum = mTaskRecord.threadNum;\n&#x27;
                         &#x27;    mListener = listener;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public boolean handleMessage(Message &#x27;
                         &#x27;msg) {\n&#x27;
                         &#x27;    switch (msg.what) {\n&#x27;
                         &#x27;      case STATE_STOP:\n&#x27;
                         &#x27;        mStopNum++;\n&#x27;
                         &#x27;        if (isStop()) {\n&#x27;
                         &#x27;          mListener.onStop(mProgress);\n&#x27;
                         &#x27;          quitLooper();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_CANCEL:\n&#x27;
                         &#x27;        mCancelNum++;\n&#x27;
                         &#x27;        if (isCancel()) {\n&#x27;
                         &#x27;          ALog.d(TAG, &quot;icCancel&quot;);\n&#x27;
                         &#x27;          mListener.onCancel();\n&#x27;
                         &#x27;          quitLooper();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_FAIL:\n&#x27;
                         &#x27;        mFailNum++;\n&#x27;
                         &#x27;        if (isFail()) {\n&#x27;
                         &#x27;          Bundle b = msg.getData();\n&#x27;
                         &#x27;          mListener.onFail(b.getBoolean(KEY_RETRY, &#x27;
                         &#x27;true),\n&#x27;
                         &#x27;              (BaseException) &#x27;
                         &#x27;b.getSerializable(KEY_ERROR_INFO));\n&#x27;
                         &#x27;          quitLooper();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_COMPLETE:\n&#x27;
                         &#x27;        mCompleteNum++;\n&#x27;
                         &#x27;        if (isComplete()) {\n&#x27;
                         &#x27;          ALog.d(TAG, &quot;isComplete, completeNum = &quot; + &#x27;
                         &#x27;mCompleteNum);\n&#x27;
                         &#x27;          if (mTaskRecord.isBlock) {\n&#x27;
                         &#x27;            if (mergeFile()) {\n&#x27;
                         &#x27;              mListener.onComplete();\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;              mListener.onFail(false, null);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;          } else {\n&#x27;
                         &#x27;            mListener.onComplete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          quitLooper();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_RUNNING:\n&#x27;
                         &#x27;        mProgress += (long) msg.obj;\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_UPDATE_PROGRESS:\n&#x27;
                         &#x27;        if (msg.obj == null) {\n&#x27;
                         &#x27;          mProgress = updateBlockProgress();\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          mProgress = (long) msg.obj;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    return false;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 退出looper循环\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void quitLooper() {\n&#x27;
                         &#x27;    mLooper.quit();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取当前任务下载进度\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @return 当前任务下载进度\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;
                         &#x27;  public long getCurrentProgress() {\n&#x27;
                         &#x27;    return mProgress;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 所有子线程是否都已经停止\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;
                         &#x27;  public boolean isStop() {\n&#x27;
                         &#x27;    //ALog.d(TAG,\n&#x27;
                         &#x27;    //    String.format(&quot;isStop; stopNum: %s, &#x27;
                         &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;, &#x27;
                         &#x27;mStopNum,\n&#x27;
                         &#x27;    //        mCancelNum, mFailNum, mCompleteNum));\n&#x27;
                         &#x27;    return mStopNum == mThreadNum || mStopNum + &#x27;
                         &#x27;mCompleteNum == mThreadNum;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 所有子线程是否都已经失败\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;
                         &#x27;  public boolean isFail() {\n&#x27;
                         &#x27;    //ALog.d(TAG,\n&#x27;
                         &#x27;    //    String.format(&quot;isFail; stopNum: %s, &#x27;
                         &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;, &#x27;
                         &#x27;mStopNum,\n&#x27;
                         &#x27;    //        mCancelNum, mFailNum, mCompleteNum));\n&#x27;
                         &#x27;    return mCompleteNum != mThreadNum\n&#x27;
                         &#x27;        &amp;&amp; (mFailNum == mThreadNum || mFailNum + &#x27;
                         &#x27;mCompleteNum == mThreadNum);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 所有子线程是否都已经完成\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;
                         &#x27;  public boolean isComplete() {\n&#x27;
                         &#x27;    //ALog.d(TAG,\n&#x27;
                         &#x27;    //    String.format(&quot;isComplete; stopNum: %s, &#x27;
                         &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;,\n&#x27;
                         &#x27;    //        mStopNum,\n&#x27;
                         &#x27;    //        mCancelNum, mFailNum, mCompleteNum));\n&#x27;
                         &#x27;    return mCompleteNum == mThreadNum;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 所有子线程是否都已经取消\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;public class ThreadStateManager implements &#x27;
                           &#x27;Handler.Callback {\n&#x27;
                           &#x27;  private final String TAG = &#x27;
                           &#x27;&quot;ThreadTaskStateManager&quot;;\n&#x27;
                           &#x27;  public static final int STATE_STOP = 0x01;\n&#x27;
                           &#x27;  public static final int STATE_FAIL = 0x02;\n&#x27;
                           &#x27;  public static final int STATE_CANCEL = 0x03;\n&#x27;
                           &#x27;  public static final int STATE_COMPLETE = 0x04;\n&#x27;
                           &#x27;  public static final int STATE_RUNNING = 0x05;\n&#x27;
                           &#x27;  public static final int STATE_UPDATE_PROGRESS = &#x27;
                           &#x27;0x06;\n&#x27;
                           &#x27;  public static final String KEY_RETRY = &#x27;
                           &#x27;&quot;KEY_RETRY&quot;;\n&#x27;
                           &#x27;  public static final String KEY_ERROR_INFO = &#x27;
                           &#x27;&quot;KEY_ERROR_INFO&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 任务状态回调\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private IEventListener mListener;\n&#x27;
                           &#x27;  private int mThreadNum;    // 启动的线程总数\n&#x27;
                           &#x27;  private int mCancelNum = 0; // 已经取消的线程的数\n&#x27;
                           &#x27;  private int mStopNum = 0;  // 已经停止的线程数\n&#x27;
                           &#x27;  private int mFailNum = 0;  // 失败的线程数\n&#x27;
                           &#x27;  private int mCompleteNum = 0;  // 完成的线程数\n&#x27;
                           &#x27;  private long mProgress; //当前总进度\n&#x27;
                           &#x27;  private TaskRecord mTaskRecord; // 任务记录\n&#x27;
                           &#x27;  private Looper mLooper;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * @param taskRecord 任务记录\n&#x27;
                           &#x27;   * @param listener 任务事件\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  ThreadStateManager(Looper looper, TaskRecord &#x27;
                           &#x27;taskRecord, IEventListener listener) {\n&#x27;
                           &#x27;    mLooper = looper;\n&#x27;
                           &#x27;    mTaskRecord = taskRecord;\n&#x27;
                           &#x27;    mThreadNum = mTaskRecord.threadNum;\n&#x27;
                           &#x27;    mListener = listener;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public boolean handleMessage(Message &#x27;
                           &#x27;msg) {\n&#x27;
                           &#x27;    switch (msg.what) {\n&#x27;
                           &#x27;      case STATE_STOP:\n&#x27;
                           &#x27;        mStopNum++;\n&#x27;
                           &#x27;        if (isStop()) {\n&#x27;
                           &#x27;          mListener.onStop(mProgress);\n&#x27;
                           &#x27;          quitLooper();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_CANCEL:\n&#x27;
                           &#x27;        mCancelNum++;\n&#x27;
                           &#x27;        if (isCancel()) {\n&#x27;
                           &#x27;          ALog.d(TAG, &quot;icCancel&quot;);\n&#x27;
                           &#x27;          mListener.onCancel();\n&#x27;
                           &#x27;          quitLooper();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_FAIL:\n&#x27;
                           &#x27;        mFailNum++;\n&#x27;
                           &#x27;        if (isFail()) {\n&#x27;
                           &#x27;          Bundle b = msg.getData();\n&#x27;
                           &#x27;          mListener.onFail(b.getBoolean(KEY_RETRY, &#x27;
                           &#x27;true),\n&#x27;
                           &#x27;              (BaseException) &#x27;
                           &#x27;b.getSerializable(KEY_ERROR_INFO));\n&#x27;
                           &#x27;          quitLooper();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_COMPLETE:\n&#x27;
                           &#x27;        mCompleteNum++;\n&#x27;
                           &#x27;        if (isComplete()) {\n&#x27;
                           &#x27;          ALog.d(TAG, &quot;isComplete, completeNum = &quot; &#x27;
                           &#x27;+ mCompleteNum);\n&#x27;
                           &#x27;          if (mTaskRecord.isBlock) {\n&#x27;
                           &#x27;            if (mergeFile()) {\n&#x27;
                           &#x27;              mListener.onComplete();\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;              mListener.onFail(false, null);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;          } else {\n&#x27;
                           &#x27;            mListener.onComplete();\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;          quitLooper();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_RUNNING:\n&#x27;
                           &#x27;        mProgress += (long) msg.obj;\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_UPDATE_PROGRESS:\n&#x27;
                           &#x27;        if (msg.obj == null) {\n&#x27;
                           &#x27;          mProgress = updateBlockProgress();\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          mProgress = (long) msg.obj;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    return false;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 退出looper循环\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void quitLooper() {\n&#x27;
                           &#x27;    mLooper.quit();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 获取当前任务下载进度\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return 当前任务下载进度\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public long getCurrentProgress() {\n&#x27;
                           &#x27;    return mProgress;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 所有子线程是否都已经停止\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public boolean isStop() {\n&#x27;
                           &#x27;    //ALog.d(TAG,\n&#x27;
                           &#x27;    //    String.format(&quot;isStop; stopNum: %s, &#x27;
                           &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;, &#x27;
                           &#x27;mStopNum,\n&#x27;
                           &#x27;    //        mCancelNum, mFailNum, &#x27;
                           &#x27;mCompleteNum));\n&#x27;
                           &#x27;    return mStopNum == mThreadNum || mStopNum + &#x27;
                           &#x27;mCompleteNum == mThreadNum;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 所有子线程是否都已经失败\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public boolean isFail() {\n&#x27;
                           &#x27;    //ALog.d(TAG,\n&#x27;
                           &#x27;    //    String.format(&quot;isFail; stopNum: %s, &#x27;
                           &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;, &#x27;
                           &#x27;mStopNum,\n&#x27;
                           &#x27;    //        mCancelNum, mFailNum, &#x27;
                           &#x27;mCompleteNum));\n&#x27;
                           &#x27;    return mCompleteNum != mThreadNum\n&#x27;
                           &#x27;        &amp;&amp; (mFailNum == mThreadNum || mFailNum + &#x27;
                           &#x27;mCompleteNum == mThreadNum);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 所有子线程是否都已经完成\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public boolean isComplete() {\n&#x27;
                           &#x27;    //ALog.d(TAG,\n&#x27;
                           &#x27;    //    String.format(&quot;isComplete; stopNum: %s, &#x27;
                           &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;,\n&#x27;
                           &#x27;    //        mStopNum,\n&#x27;
                           &#x27;    //        mCancelNum, mFailNum, &#x27;
                           &#x27;mCompleteNum));\n&#x27;
                           &#x27;    return mCompleteNum == mThreadNum;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 所有子线程是否都已经取消\n&#x27;
                           &#x27;   */\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;public class ThreadStateManager implements &#x27;
                         &#x27;IThreadState {\n&#x27;
                         &#x27;  private final String TAG = &#x27;
                         &#x27;&quot;ThreadTaskStateManager&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 任务状态回调\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private IEventListener mListener;\n&#x27;
                         &#x27;  private int mThreadNum;    // 启动的线程总数\n&#x27;
                         &#x27;  private int mCancelNum = 0; // 已经取消的线程的数\n&#x27;
                         &#x27;  private int mStopNum = 0;  // 已经停止的线程数\n&#x27;
                         &#x27;  private int mFailNum = 0;  // 失败的线程数\n&#x27;
                         &#x27;  private int mCompleteNum = 0;  // 完成的线程数\n&#x27;
                         &#x27;  private long mProgress; //当前总进度\n&#x27;
                         &#x27;  private TaskRecord mTaskRecord; // 任务记录\n&#x27;
                         &#x27;  private Looper mLooper;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * @param taskRecord 任务记录\n&#x27;
                         &#x27;   * @param listener 任务事件\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  ThreadStateManager(Looper looper, TaskRecord &#x27;
                         &#x27;taskRecord, IEventListener listener) {\n&#x27;
                         &#x27;    mLooper = looper;\n&#x27;
                         &#x27;    mTaskRecord = taskRecord;\n&#x27;
                         &#x27;    mThreadNum = mTaskRecord.threadNum;\n&#x27;
                         &#x27;    mListener = listener;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public boolean handleMessage(Message &#x27;
                         &#x27;msg) {\n&#x27;
                         &#x27;    switch (msg.what) {\n&#x27;
                         &#x27;      case STATE_STOP:\n&#x27;
                         &#x27;        mStopNum++;\n&#x27;
                         &#x27;        if (isStop()) {\n&#x27;
                         &#x27;          mListener.onStop(mProgress);\n&#x27;
                         &#x27;          quitLooper();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_CANCEL:\n&#x27;
                         &#x27;        mCancelNum++;\n&#x27;
                         &#x27;        if (isCancel()) {\n&#x27;
                         &#x27;          ALog.d(TAG, &quot;icCancel&quot;);\n&#x27;
                         &#x27;          mListener.onCancel();\n&#x27;
                         &#x27;          quitLooper();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_FAIL:\n&#x27;
                         &#x27;        mFailNum++;\n&#x27;
                         &#x27;        if (isFail()) {\n&#x27;
                         &#x27;          Bundle b = msg.getData();\n&#x27;
                         &#x27;          mListener.onFail(b.getBoolean(KEY_RETRY, &#x27;
                         &#x27;true),\n&#x27;
                         &#x27;              (BaseException) &#x27;
                         &#x27;b.getSerializable(KEY_ERROR_INFO));\n&#x27;
                         &#x27;          quitLooper();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_COMPLETE:\n&#x27;
                         &#x27;        mCompleteNum++;\n&#x27;
                         &#x27;        if (isComplete()) {\n&#x27;
                         &#x27;          ALog.d(TAG, &quot;isComplete, completeNum = &quot; + &#x27;
                         &#x27;mCompleteNum);\n&#x27;
                         &#x27;          if (mTaskRecord.isBlock) {\n&#x27;
                         &#x27;            if (mergeFile()) {\n&#x27;
                         &#x27;              mListener.onComplete();\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;              mListener.onFail(false, null);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;          } else {\n&#x27;
                         &#x27;            mListener.onComplete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          quitLooper();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_RUNNING:\n&#x27;
                         &#x27;        mProgress += (long) msg.obj;\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_UPDATE_PROGRESS:\n&#x27;
                         &#x27;        if (msg.obj == null) {\n&#x27;
                         &#x27;          mProgress = updateBlockProgress();\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          mProgress = (long) msg.obj;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    return false;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 退出looper循环\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void quitLooper() {\n&#x27;
                         &#x27;    mLooper.quit();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取当前任务下载进度\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @return 当前任务下载进度\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;
                         &#x27;  public long getCurrentProgress() {\n&#x27;
                         &#x27;    return mProgress;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 所有子线程是否都已经停止\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;
                         &#x27;  public boolean isStop() {\n&#x27;
                         &#x27;    //ALog.d(TAG,\n&#x27;
                         &#x27;    //    String.format(&quot;isStop; stopNum: %s, &#x27;
                         &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;, &#x27;
                         &#x27;mStopNum,\n&#x27;
                         &#x27;    //        mCancelNum, mFailNum, mCompleteNum));\n&#x27;
                         &#x27;    return mStopNum == mThreadNum || mStopNum + &#x27;
                         &#x27;mCompleteNum == mThreadNum;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 所有子线程是否都已经失败\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;
                         &#x27;  public boolean isFail() {\n&#x27;
                         &#x27;    //ALog.d(TAG,\n&#x27;
                         &#x27;    //    String.format(&quot;isFail; stopNum: %s, &#x27;
                         &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;, &#x27;
                         &#x27;mStopNum,\n&#x27;
                         &#x27;    //        mCancelNum, mFailNum, mCompleteNum));\n&#x27;
                         &#x27;    return mCompleteNum != mThreadNum\n&#x27;
                         &#x27;        &amp;&amp; (mFailNum == mThreadNum || mFailNum + &#x27;
                         &#x27;mCompleteNum == mThreadNum);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 所有子线程是否都已经完成\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;
                         &#x27;  public boolean isComplete() {\n&#x27;
                         &#x27;    //ALog.d(TAG,\n&#x27;
                         &#x27;    //    String.format(&quot;isComplete; stopNum: %s, &#x27;
                         &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;,\n&#x27;
                         &#x27;    //        mStopNum,\n&#x27;
                         &#x27;    //        mCancelNum, mFailNum, mCompleteNum));\n&#x27;
                         &#x27;    return mCompleteNum == mThreadNum;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 所有子线程是否都已经取消\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;public class ThreadStateManager implements &#x27;
                           &#x27;Handler.Callback {\n&#x27;
                           &#x27;  private final String TAG = &#x27;
                           &#x27;&quot;ThreadTaskStateManager&quot;;\n&#x27;
                           &#x27;  public static final int STATE_STOP = 0x01;\n&#x27;
                           &#x27;  public static final int STATE_FAIL = 0x02;\n&#x27;
                           &#x27;  public static final int STATE_CANCEL = 0x03;\n&#x27;
                           &#x27;  public static final int STATE_COMPLETE = 0x04;\n&#x27;
                           &#x27;  public static final int STATE_RUNNING = 0x05;\n&#x27;
                           &#x27;  public static final int STATE_UPDATE_PROGRESS = &#x27;
                           &#x27;0x06;\n&#x27;
                           &#x27;  public static final String KEY_RETRY = &#x27;
                           &#x27;&quot;KEY_RETRY&quot;;\n&#x27;
                           &#x27;  public static final String KEY_ERROR_INFO = &#x27;
                           &#x27;&quot;KEY_ERROR_INFO&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 任务状态回调\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private IEventListener mListener;\n&#x27;
                           &#x27;  private int mThreadNum;    // 启动的线程总数\n&#x27;
                           &#x27;  private int mCancelNum = 0; // 已经取消的线程的数\n&#x27;
                           &#x27;  private int mStopNum = 0;  // 已经停止的线程数\n&#x27;
                           &#x27;  private int mFailNum = 0;  // 失败的线程数\n&#x27;
                           &#x27;  private int mCompleteNum = 0;  // 完成的线程数\n&#x27;
                           &#x27;  private long mProgress; //当前总进度\n&#x27;
                           &#x27;  private TaskRecord mTaskRecord; // 任务记录\n&#x27;
                           &#x27;  private Looper mLooper;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * @param taskRecord 任务记录\n&#x27;
                           &#x27;   * @param listener 任务事件\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  ThreadStateManager(Looper looper, TaskRecord &#x27;
                           &#x27;taskRecord, IEventListener listener) {\n&#x27;
                           &#x27;    mLooper = looper;\n&#x27;
                           &#x27;    mTaskRecord = taskRecord;\n&#x27;
                           &#x27;    mThreadNum = mTaskRecord.threadNum;\n&#x27;
                           &#x27;    mListener = listener;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public boolean handleMessage(Message &#x27;
                           &#x27;msg) {\n&#x27;
                           &#x27;    switch (msg.what) {\n&#x27;
                           &#x27;      case STATE_STOP:\n&#x27;
                           &#x27;        mStopNum++;\n&#x27;
                           &#x27;        if (isStop()) {\n&#x27;
                           &#x27;          mListener.onStop(mProgress);\n&#x27;
                           &#x27;          quitLooper();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_CANCEL:\n&#x27;
                           &#x27;        mCancelNum++;\n&#x27;
                           &#x27;        if (isCancel()) {\n&#x27;
                           &#x27;          ALog.d(TAG, &quot;icCancel&quot;);\n&#x27;
                           &#x27;          mListener.onCancel();\n&#x27;
                           &#x27;          quitLooper();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_FAIL:\n&#x27;
                           &#x27;        mFailNum++;\n&#x27;
                           &#x27;        if (isFail()) {\n&#x27;
                           &#x27;          Bundle b = msg.getData();\n&#x27;
                           &#x27;          mListener.onFail(b.getBoolean(KEY_RETRY, &#x27;
                           &#x27;true),\n&#x27;
                           &#x27;              (BaseException) &#x27;
                           &#x27;b.getSerializable(KEY_ERROR_INFO));\n&#x27;
                           &#x27;          quitLooper();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_COMPLETE:\n&#x27;
                           &#x27;        mCompleteNum++;\n&#x27;
                           &#x27;        if (isComplete()) {\n&#x27;
                           &#x27;          ALog.d(TAG, &quot;isComplete, completeNum = &quot; &#x27;
                           &#x27;+ mCompleteNum);\n&#x27;
                           &#x27;          if (mTaskRecord.isBlock) {\n&#x27;
                           &#x27;            if (mergeFile()) {\n&#x27;
                           &#x27;              mListener.onComplete();\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;              mListener.onFail(false, null);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;          } else {\n&#x27;
                           &#x27;            mListener.onComplete();\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;          quitLooper();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_RUNNING:\n&#x27;
                           &#x27;        mProgress += (long) msg.obj;\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_UPDATE_PROGRESS:\n&#x27;
                           &#x27;        if (msg.obj == null) {\n&#x27;
                           &#x27;          mProgress = updateBlockProgress();\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          mProgress = (long) msg.obj;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    return false;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 退出looper循环\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void quitLooper() {\n&#x27;
                           &#x27;    mLooper.quit();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 获取当前任务下载进度\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return 当前任务下载进度\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public long getCurrentProgress() {\n&#x27;
                           &#x27;    return mProgress;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 所有子线程是否都已经停止\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public boolean isStop() {\n&#x27;
                           &#x27;    //ALog.d(TAG,\n&#x27;
                           &#x27;    //    String.format(&quot;isStop; stopNum: %s, &#x27;
                           &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;, &#x27;
                           &#x27;mStopNum,\n&#x27;
                           &#x27;    //        mCancelNum, mFailNum, &#x27;
                           &#x27;mCompleteNum));\n&#x27;
                           &#x27;    return mStopNum == mThreadNum || mStopNum + &#x27;
                           &#x27;mCompleteNum == mThreadNum;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 所有子线程是否都已经失败\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public boolean isFail() {\n&#x27;
                           &#x27;    //ALog.d(TAG,\n&#x27;
                           &#x27;    //    String.format(&quot;isFail; stopNum: %s, &#x27;
                           &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;, &#x27;
                           &#x27;mStopNum,\n&#x27;
                           &#x27;    //        mCancelNum, mFailNum, &#x27;
                           &#x27;mCompleteNum));\n&#x27;
                           &#x27;    return mCompleteNum != mThreadNum\n&#x27;
                           &#x27;        &amp;&amp; (mFailNum == mThreadNum || mFailNum + &#x27;
                           &#x27;mCompleteNum == mThreadNum);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 所有子线程是否都已经完成\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public boolean isComplete() {\n&#x27;
                           &#x27;    //ALog.d(TAG,\n&#x27;
                           &#x27;    //    String.format(&quot;isComplete; stopNum: %s, &#x27;
                           &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;,\n&#x27;
                           &#x27;    //        mStopNum,\n&#x27;
                           &#x27;    //        mCancelNum, mFailNum, &#x27;
                           &#x27;mCompleteNum));\n&#x27;
                           &#x27;    return mCompleteNum == mThreadNum;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 所有子线程是否都已经取消\n&#x27;
                           &#x27;   */\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;public class ThreadStateManager implements &#x27;
                         &#x27;IThreadState {\n&#x27;
                         &#x27;  private final String TAG = &#x27;
                         &#x27;&quot;ThreadTaskStateManager&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 任务状态回调\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private IEventListener mListener;\n&#x27;
                         &#x27;  private int mThreadNum;    // 启动的线程总数\n&#x27;
                         &#x27;  private int mCancelNum = 0; // 已经取消的线程的数\n&#x27;
                         &#x27;  private int mStopNum = 0;  // 已经停止的线程数\n&#x27;
                         &#x27;  private int mFailNum = 0;  // 失败的线程数\n&#x27;
                         &#x27;  private int mCompleteNum = 0;  // 完成的线程数\n&#x27;
                         &#x27;  private long mProgress; //当前总进度\n&#x27;
                         &#x27;  private TaskRecord mTaskRecord; // 任务记录\n&#x27;
                         &#x27;  private Looper mLooper;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * @param taskRecord 任务记录\n&#x27;
                         &#x27;   * @param listener 任务事件\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  ThreadStateManager(Looper looper, TaskRecord &#x27;
                         &#x27;taskRecord, IEventListener listener) {\n&#x27;
                         &#x27;    mLooper = looper;\n&#x27;
                         &#x27;    mTaskRecord = taskRecord;\n&#x27;
                         &#x27;    mThreadNum = mTaskRecord.threadNum;\n&#x27;
                         &#x27;    mListener = listener;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public boolean handleMessage(Message &#x27;
                         &#x27;msg) {\n&#x27;
                         &#x27;    switch (msg.what) {\n&#x27;
                         &#x27;      case STATE_STOP:\n&#x27;
                         &#x27;        mStopNum++;\n&#x27;
                         &#x27;        if (isStop()) {\n&#x27;
                         &#x27;          mListener.onStop(mProgress);\n&#x27;
                         &#x27;          quitLooper();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_CANCEL:\n&#x27;
                         &#x27;        mCancelNum++;\n&#x27;
                         &#x27;        if (isCancel()) {\n&#x27;
                         &#x27;          ALog.d(TAG, &quot;icCancel&quot;);\n&#x27;
                         &#x27;          mListener.onCancel();\n&#x27;
                         &#x27;          quitLooper();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_FAIL:\n&#x27;
                         &#x27;        mFailNum++;\n&#x27;
                         &#x27;        if (isFail()) {\n&#x27;
                         &#x27;          Bundle b = msg.getData();\n&#x27;
                         &#x27;          mListener.onFail(b.getBoolean(KEY_RETRY, &#x27;
                         &#x27;true),\n&#x27;
                         &#x27;              (BaseException) &#x27;
                         &#x27;b.getSerializable(KEY_ERROR_INFO));\n&#x27;
                         &#x27;          quitLooper();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_COMPLETE:\n&#x27;
                         &#x27;        mCompleteNum++;\n&#x27;
                         &#x27;        if (isComplete()) {\n&#x27;
                         &#x27;          ALog.d(TAG, &quot;isComplete, completeNum = &quot; + &#x27;
                         &#x27;mCompleteNum);\n&#x27;
                         &#x27;          if (mTaskRecord.isBlock) {\n&#x27;
                         &#x27;            if (mergeFile()) {\n&#x27;
                         &#x27;              mListener.onComplete();\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;              mListener.onFail(false, null);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;          } else {\n&#x27;
                         &#x27;            mListener.onComplete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          quitLooper();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_RUNNING:\n&#x27;
                         &#x27;        mProgress += (long) msg.obj;\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_UPDATE_PROGRESS:\n&#x27;
                         &#x27;        if (msg.obj == null) {\n&#x27;
                         &#x27;          mProgress = updateBlockProgress();\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          mProgress = (long) msg.obj;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    return false;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 退出looper循环\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void quitLooper() {\n&#x27;
                         &#x27;    mLooper.quit();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取当前任务下载进度\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @return 当前任务下载进度\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;
                         &#x27;  public long getCurrentProgress() {\n&#x27;
                         &#x27;    return mProgress;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 所有子线程是否都已经停止\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;
                         &#x27;  public boolean isStop() {\n&#x27;
                         &#x27;    //ALog.d(TAG,\n&#x27;
                         &#x27;    //    String.format(&quot;isStop; stopNum: %s, &#x27;
                         &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;, &#x27;
                         &#x27;mStopNum,\n&#x27;
                         &#x27;    //        mCancelNum, mFailNum, mCompleteNum));\n&#x27;
                         &#x27;    return mStopNum == mThreadNum || mStopNum + &#x27;
                         &#x27;mCompleteNum == mThreadNum;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 所有子线程是否都已经失败\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;
                         &#x27;  public boolean isFail() {\n&#x27;
                         &#x27;    //ALog.d(TAG,\n&#x27;
                         &#x27;    //    String.format(&quot;isFail; stopNum: %s, &#x27;
                         &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;, &#x27;
                         &#x27;mStopNum,\n&#x27;
                         &#x27;    //        mCancelNum, mFailNum, mCompleteNum));\n&#x27;
                         &#x27;    return mCompleteNum != mThreadNum\n&#x27;
                         &#x27;        &amp;&amp; (mFailNum == mThreadNum || mFailNum + &#x27;
                         &#x27;mCompleteNum == mThreadNum);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 所有子线程是否都已经完成\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;
                         &#x27;  public boolean isComplete() {\n&#x27;
                         &#x27;    //ALog.d(TAG,\n&#x27;
                         &#x27;    //    String.format(&quot;isComplete; stopNum: %s, &#x27;
                         &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;,\n&#x27;
                         &#x27;    //        mStopNum,\n&#x27;
                         &#x27;    //        mCancelNum, mFailNum, mCompleteNum));\n&#x27;
                         &#x27;    return mCompleteNum == mThreadNum;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 所有子线程是否都已经取消\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;public class ThreadStateManager implements &#x27;
                           &#x27;Handler.Callback {\n&#x27;
                           &#x27;  private final String TAG = &#x27;
                           &#x27;&quot;ThreadTaskStateManager&quot;;\n&#x27;
                           &#x27;  public static final int STATE_STOP = 0x01;\n&#x27;
                           &#x27;  public static final int STATE_FAIL = 0x02;\n&#x27;
                           &#x27;  public static final int STATE_CANCEL = 0x03;\n&#x27;
                           &#x27;  public static final int STATE_COMPLETE = 0x04;\n&#x27;
                           &#x27;  public static final int STATE_RUNNING = 0x05;\n&#x27;
                           &#x27;  public static final int STATE_UPDATE_PROGRESS = &#x27;
                           &#x27;0x06;\n&#x27;
                           &#x27;  public static final String KEY_RETRY = &#x27;
                           &#x27;&quot;KEY_RETRY&quot;;\n&#x27;
                           &#x27;  public static final String KEY_ERROR_INFO = &#x27;
                           &#x27;&quot;KEY_ERROR_INFO&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 任务状态回调\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private IEventListener mListener;\n&#x27;
                           &#x27;  private int mThreadNum;    // 启动的线程总数\n&#x27;
                           &#x27;  private int mCancelNum = 0; // 已经取消的线程的数\n&#x27;
                           &#x27;  private int mStopNum = 0;  // 已经停止的线程数\n&#x27;
                           &#x27;  private int mFailNum = 0;  // 失败的线程数\n&#x27;
                           &#x27;  private int mCompleteNum = 0;  // 完成的线程数\n&#x27;
                           &#x27;  private long mProgress; //当前总进度\n&#x27;
                           &#x27;  private TaskRecord mTaskRecord; // 任务记录\n&#x27;
                           &#x27;  private Looper mLooper;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * @param taskRecord 任务记录\n&#x27;
                           &#x27;   * @param listener 任务事件\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  ThreadStateManager(Looper looper, TaskRecord &#x27;
                           &#x27;taskRecord, IEventListener listener) {\n&#x27;
                           &#x27;    mLooper = looper;\n&#x27;
                           &#x27;    mTaskRecord = taskRecord;\n&#x27;
                           &#x27;    mThreadNum = mTaskRecord.threadNum;\n&#x27;
                           &#x27;    mListener = listener;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public boolean handleMessage(Message &#x27;
                           &#x27;msg) {\n&#x27;
                           &#x27;    switch (msg.what) {\n&#x27;
                           &#x27;      case STATE_STOP:\n&#x27;
                           &#x27;        mStopNum++;\n&#x27;
                           &#x27;        if (isStop()) {\n&#x27;
                           &#x27;          mListener.onStop(mProgress);\n&#x27;
                           &#x27;          quitLooper();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_CANCEL:\n&#x27;
                           &#x27;        mCancelNum++;\n&#x27;
                           &#x27;        if (isCancel()) {\n&#x27;
                           &#x27;          ALog.d(TAG, &quot;icCancel&quot;);\n&#x27;
                           &#x27;          mListener.onCancel();\n&#x27;
                           &#x27;          quitLooper();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_FAIL:\n&#x27;
                           &#x27;        mFailNum++;\n&#x27;
                           &#x27;        if (isFail()) {\n&#x27;
                           &#x27;          Bundle b = msg.getData();\n&#x27;
                           &#x27;          mListener.onFail(b.getBoolean(KEY_RETRY, &#x27;
                           &#x27;true),\n&#x27;
                           &#x27;              (BaseException) &#x27;
                           &#x27;b.getSerializable(KEY_ERROR_INFO));\n&#x27;
                           &#x27;          quitLooper();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_COMPLETE:\n&#x27;
                           &#x27;        mCompleteNum++;\n&#x27;
                           &#x27;        if (isComplete()) {\n&#x27;
                           &#x27;          ALog.d(TAG, &quot;isComplete, completeNum = &quot; &#x27;
                           &#x27;+ mCompleteNum);\n&#x27;
                           &#x27;          if (mTaskRecord.isBlock) {\n&#x27;
                           &#x27;            if (mergeFile()) {\n&#x27;
                           &#x27;              mListener.onComplete();\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;              mListener.onFail(false, null);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;          } else {\n&#x27;
                           &#x27;            mListener.onComplete();\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;          quitLooper();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_RUNNING:\n&#x27;
                           &#x27;        mProgress += (long) msg.obj;\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_UPDATE_PROGRESS:\n&#x27;
                           &#x27;        if (msg.obj == null) {\n&#x27;
                           &#x27;          mProgress = updateBlockProgress();\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          mProgress = (long) msg.obj;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    return false;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 退出looper循环\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void quitLooper() {\n&#x27;
                           &#x27;    mLooper.quit();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 获取当前任务下载进度\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return 当前任务下载进度\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public long getCurrentProgress() {\n&#x27;
                           &#x27;    return mProgress;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 所有子线程是否都已经停止\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public boolean isStop() {\n&#x27;
                           &#x27;    //ALog.d(TAG,\n&#x27;
                           &#x27;    //    String.format(&quot;isStop; stopNum: %s, &#x27;
                           &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;, &#x27;
                           &#x27;mStopNum,\n&#x27;
                           &#x27;    //        mCancelNum, mFailNum, &#x27;
                           &#x27;mCompleteNum));\n&#x27;
                           &#x27;    return mStopNum == mThreadNum || mStopNum + &#x27;
                           &#x27;mCompleteNum == mThreadNum;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 所有子线程是否都已经失败\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public boolean isFail() {\n&#x27;
                           &#x27;    //ALog.d(TAG,\n&#x27;
                           &#x27;    //    String.format(&quot;isFail; stopNum: %s, &#x27;
                           &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;, &#x27;
                           &#x27;mStopNum,\n&#x27;
                           &#x27;    //        mCancelNum, mFailNum, &#x27;
                           &#x27;mCompleteNum));\n&#x27;
                           &#x27;    return mCompleteNum != mThreadNum\n&#x27;
                           &#x27;        &amp;&amp; (mFailNum == mThreadNum || mFailNum + &#x27;
                           &#x27;mCompleteNum == mThreadNum);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 所有子线程是否都已经完成\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public boolean isComplete() {\n&#x27;
                           &#x27;    //ALog.d(TAG,\n&#x27;
                           &#x27;    //    String.format(&quot;isComplete; stopNum: %s, &#x27;
                           &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;,\n&#x27;
                           &#x27;    //        mStopNum,\n&#x27;
                           &#x27;    //        mCancelNum, mFailNum, &#x27;
                           &#x27;mCompleteNum));\n&#x27;
                           &#x27;    return mCompleteNum == mThreadNum;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 所有子线程是否都已经取消\n&#x27;
                           &#x27;   */\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;public class ThreadStateManager implements &#x27;
                         &#x27;IThreadState {\n&#x27;
                         &#x27;  private final String TAG = &#x27;
                         &#x27;&quot;ThreadTaskStateManager&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 任务状态回调\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private IEventListener mListener;\n&#x27;
                         &#x27;  private int mThreadNum;    // 启动的线程总数\n&#x27;
                         &#x27;  private int mCancelNum = 0; // 已经取消的线程的数\n&#x27;
                         &#x27;  private int mStopNum = 0;  // 已经停止的线程数\n&#x27;
                         &#x27;  private int mFailNum = 0;  // 失败的线程数\n&#x27;
                         &#x27;  private int mCompleteNum = 0;  // 完成的线程数\n&#x27;
                         &#x27;  private long mProgress; //当前总进度\n&#x27;
                         &#x27;  private TaskRecord mTaskRecord; // 任务记录\n&#x27;
                         &#x27;  private Looper mLooper;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * @param taskRecord 任务记录\n&#x27;
                         &#x27;   * @param listener 任务事件\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  ThreadStateManager(Looper looper, TaskRecord &#x27;
                         &#x27;taskRecord, IEventListener listener) {\n&#x27;
                         &#x27;    mLooper = looper;\n&#x27;
                         &#x27;    mTaskRecord = taskRecord;\n&#x27;
                         &#x27;    mThreadNum = mTaskRecord.threadNum;\n&#x27;
                         &#x27;    mListener = listener;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public boolean handleMessage(Message &#x27;
                         &#x27;msg) {\n&#x27;
                         &#x27;    switch (msg.what) {\n&#x27;
                         &#x27;      case STATE_STOP:\n&#x27;
                         &#x27;        mStopNum++;\n&#x27;
                         &#x27;        if (isStop()) {\n&#x27;
                         &#x27;          mListener.onStop(mProgress);\n&#x27;
                         &#x27;          quitLooper();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_CANCEL:\n&#x27;
                         &#x27;        mCancelNum++;\n&#x27;
                         &#x27;        if (isCancel()) {\n&#x27;
                         &#x27;          ALog.d(TAG, &quot;icCancel&quot;);\n&#x27;
                         &#x27;          mListener.onCancel();\n&#x27;
                         &#x27;          quitLooper();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_FAIL:\n&#x27;
                         &#x27;        mFailNum++;\n&#x27;
                         &#x27;        if (isFail()) {\n&#x27;
                         &#x27;          Bundle b = msg.getData();\n&#x27;
                         &#x27;          mListener.onFail(b.getBoolean(KEY_RETRY, &#x27;
                         &#x27;true),\n&#x27;
                         &#x27;              (BaseException) &#x27;
                         &#x27;b.getSerializable(KEY_ERROR_INFO));\n&#x27;
                         &#x27;          quitLooper();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_COMPLETE:\n&#x27;
                         &#x27;        mCompleteNum++;\n&#x27;
                         &#x27;        if (isComplete()) {\n&#x27;
                         &#x27;          ALog.d(TAG, &quot;isComplete, completeNum = &quot; + &#x27;
                         &#x27;mCompleteNum);\n&#x27;
                         &#x27;          if (mTaskRecord.isBlock) {\n&#x27;
                         &#x27;            if (mergeFile()) {\n&#x27;
                         &#x27;              mListener.onComplete();\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;              mListener.onFail(false, null);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;          } else {\n&#x27;
                         &#x27;            mListener.onComplete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          quitLooper();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_RUNNING:\n&#x27;
                         &#x27;        mProgress += (long) msg.obj;\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_UPDATE_PROGRESS:\n&#x27;
                         &#x27;        if (msg.obj == null) {\n&#x27;
                         &#x27;          mProgress = updateBlockProgress();\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          mProgress = (long) msg.obj;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    return false;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 退出looper循环\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void quitLooper() {\n&#x27;
                         &#x27;    mLooper.quit();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取当前任务下载进度\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @return 当前任务下载进度\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;
                         &#x27;  public long getCurrentProgress() {\n&#x27;
                         &#x27;    return mProgress;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 所有子线程是否都已经停止\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;
                         &#x27;  public boolean isStop() {\n&#x27;
                         &#x27;    //ALog.d(TAG,\n&#x27;
                         &#x27;    //    String.format(&quot;isStop; stopNum: %s, &#x27;
                         &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;, &#x27;
                         &#x27;mStopNum,\n&#x27;
                         &#x27;    //        mCancelNum, mFailNum, mCompleteNum));\n&#x27;
                         &#x27;    return mStopNum == mThreadNum || mStopNum + &#x27;
                         &#x27;mCompleteNum == mThreadNum;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 所有子线程是否都已经失败\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;
                         &#x27;  public boolean isFail() {\n&#x27;
                         &#x27;    //ALog.d(TAG,\n&#x27;
                         &#x27;    //    String.format(&quot;isFail; stopNum: %s, &#x27;
                         &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;, &#x27;
                         &#x27;mStopNum,\n&#x27;
                         &#x27;    //        mCancelNum, mFailNum, mCompleteNum));\n&#x27;
                         &#x27;    return mCompleteNum != mThreadNum\n&#x27;
                         &#x27;        &amp;&amp; (mFailNum == mThreadNum || mFailNum + &#x27;
                         &#x27;mCompleteNum == mThreadNum);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 所有子线程是否都已经完成\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;
                         &#x27;  public boolean isComplete() {\n&#x27;
                         &#x27;    //ALog.d(TAG,\n&#x27;
                         &#x27;    //    String.format(&quot;isComplete; stopNum: %s, &#x27;
                         &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;,\n&#x27;
                         &#x27;    //        mStopNum,\n&#x27;
                         &#x27;    //        mCancelNum, mFailNum, mCompleteNum));\n&#x27;
                         &#x27;    return mCompleteNum == mThreadNum;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 所有子线程是否都已经取消\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;public class ThreadStateManager implements &#x27;
                           &#x27;Handler.Callback {\n&#x27;
                           &#x27;  private final String TAG = &#x27;
                           &#x27;&quot;ThreadTaskStateManager&quot;;\n&#x27;
                           &#x27;  public static final int STATE_STOP = 0x01;\n&#x27;
                           &#x27;  public static final int STATE_FAIL = 0x02;\n&#x27;
                           &#x27;  public static final int STATE_CANCEL = 0x03;\n&#x27;
                           &#x27;  public static final int STATE_COMPLETE = 0x04;\n&#x27;
                           &#x27;  public static final int STATE_RUNNING = 0x05;\n&#x27;
                           &#x27;  public static final int STATE_UPDATE_PROGRESS = &#x27;
                           &#x27;0x06;\n&#x27;
                           &#x27;  public static final String KEY_RETRY = &#x27;
                           &#x27;&quot;KEY_RETRY&quot;;\n&#x27;
                           &#x27;  public static final String KEY_ERROR_INFO = &#x27;
                           &#x27;&quot;KEY_ERROR_INFO&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 任务状态回调\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private IEventListener mListener;\n&#x27;
                           &#x27;  private int mThreadNum;    // 启动的线程总数\n&#x27;
                           &#x27;  private int mCancelNum = 0; // 已经取消的线程的数\n&#x27;
                           &#x27;  private int mStopNum = 0;  // 已经停止的线程数\n&#x27;
                           &#x27;  private int mFailNum = 0;  // 失败的线程数\n&#x27;
                           &#x27;  private int mCompleteNum = 0;  // 完成的线程数\n&#x27;
                           &#x27;  private long mProgress; //当前总进度\n&#x27;
                           &#x27;  private TaskRecord mTaskRecord; // 任务记录\n&#x27;
                           &#x27;  private Looper mLooper;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * @param taskRecord 任务记录\n&#x27;
                           &#x27;   * @param listener 任务事件\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  ThreadStateManager(Looper looper, TaskRecord &#x27;
                           &#x27;taskRecord, IEventListener listener) {\n&#x27;
                           &#x27;    mLooper = looper;\n&#x27;
                           &#x27;    mTaskRecord = taskRecord;\n&#x27;
                           &#x27;    mThreadNum = mTaskRecord.threadNum;\n&#x27;
                           &#x27;    mListener = listener;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public boolean handleMessage(Message &#x27;
                           &#x27;msg) {\n&#x27;
                           &#x27;    switch (msg.what) {\n&#x27;
                           &#x27;      case STATE_STOP:\n&#x27;
                           &#x27;        mStopNum++;\n&#x27;
                           &#x27;        if (isStop()) {\n&#x27;
                           &#x27;          mListener.onStop(mProgress);\n&#x27;
                           &#x27;          quitLooper();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_CANCEL:\n&#x27;
                           &#x27;        mCancelNum++;\n&#x27;
                           &#x27;        if (isCancel()) {\n&#x27;
                           &#x27;          ALog.d(TAG, &quot;icCancel&quot;);\n&#x27;
                           &#x27;          mListener.onCancel();\n&#x27;
                           &#x27;          quitLooper();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_FAIL:\n&#x27;
                           &#x27;        mFailNum++;\n&#x27;
                           &#x27;        if (isFail()) {\n&#x27;
                           &#x27;          Bundle b = msg.getData();\n&#x27;
                           &#x27;          mListener.onFail(b.getBoolean(KEY_RETRY, &#x27;
                           &#x27;true),\n&#x27;
                           &#x27;              (BaseException) &#x27;
                           &#x27;b.getSerializable(KEY_ERROR_INFO));\n&#x27;
                           &#x27;          quitLooper();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_COMPLETE:\n&#x27;
                           &#x27;        mCompleteNum++;\n&#x27;
                           &#x27;        if (isComplete()) {\n&#x27;
                           &#x27;          ALog.d(TAG, &quot;isComplete, completeNum = &quot; &#x27;
                           &#x27;+ mCompleteNum);\n&#x27;
                           &#x27;          if (mTaskRecord.isBlock) {\n&#x27;
                           &#x27;            if (mergeFile()) {\n&#x27;
                           &#x27;              mListener.onComplete();\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;              mListener.onFail(false, null);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;          } else {\n&#x27;
                           &#x27;            mListener.onComplete();\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;          quitLooper();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_RUNNING:\n&#x27;
                           &#x27;        mProgress += (long) msg.obj;\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_UPDATE_PROGRESS:\n&#x27;
                           &#x27;        if (msg.obj == null) {\n&#x27;
                           &#x27;          mProgress = updateBlockProgress();\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          mProgress = (long) msg.obj;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    return false;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 退出looper循环\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void quitLooper() {\n&#x27;
                           &#x27;    mLooper.quit();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 获取当前任务下载进度\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return 当前任务下载进度\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public long getCurrentProgress() {\n&#x27;
                           &#x27;    return mProgress;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 所有子线程是否都已经停止\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public boolean isStop() {\n&#x27;
                           &#x27;    //ALog.d(TAG,\n&#x27;
                           &#x27;    //    String.format(&quot;isStop; stopNum: %s, &#x27;
                           &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;, &#x27;
                           &#x27;mStopNum,\n&#x27;
                           &#x27;    //        mCancelNum, mFailNum, &#x27;
                           &#x27;mCompleteNum));\n&#x27;
                           &#x27;    return mStopNum == mThreadNum || mStopNum + &#x27;
                           &#x27;mCompleteNum == mThreadNum;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 所有子线程是否都已经失败\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public boolean isFail() {\n&#x27;
                           &#x27;    //ALog.d(TAG,\n&#x27;
                           &#x27;    //    String.format(&quot;isFail; stopNum: %s, &#x27;
                           &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;, &#x27;
                           &#x27;mStopNum,\n&#x27;
                           &#x27;    //        mCancelNum, mFailNum, &#x27;
                           &#x27;mCompleteNum));\n&#x27;
                           &#x27;    return mCompleteNum != mThreadNum\n&#x27;
                           &#x27;        &amp;&amp; (mFailNum == mThreadNum || mFailNum + &#x27;
                           &#x27;mCompleteNum == mThreadNum);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 所有子线程是否都已经完成\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public boolean isComplete() {\n&#x27;
                           &#x27;    //ALog.d(TAG,\n&#x27;
                           &#x27;    //    String.format(&quot;isComplete; stopNum: %s, &#x27;
                           &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;,\n&#x27;
                           &#x27;    //        mStopNum,\n&#x27;
                           &#x27;    //        mCancelNum, mFailNum, &#x27;
                           &#x27;mCompleteNum));\n&#x27;
                           &#x27;    return mCompleteNum == mThreadNum;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 所有子线程是否都已经取消\n&#x27;
                           &#x27;   */\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;public class ThreadStateManager implements &#x27;
                         &#x27;IThreadState {\n&#x27;
                         &#x27;  private final String TAG = &#x27;
                         &#x27;&quot;ThreadTaskStateManager&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 任务状态回调\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private IEventListener mListener;\n&#x27;
                         &#x27;  private int mThreadNum;    // 启动的线程总数\n&#x27;
                         &#x27;  private int mCancelNum = 0; // 已经取消的线程的数\n&#x27;
                         &#x27;  private int mStopNum = 0;  // 已经停止的线程数\n&#x27;
                         &#x27;  private int mFailNum = 0;  // 失败的线程数\n&#x27;
                         &#x27;  private int mCompleteNum = 0;  // 完成的线程数\n&#x27;
                         &#x27;  private long mProgress; //当前总进度\n&#x27;
                         &#x27;  private TaskRecord mTaskRecord; // 任务记录\n&#x27;
                         &#x27;  private Looper mLooper;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * @param taskRecord 任务记录\n&#x27;
                         &#x27;   * @param listener 任务事件\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  ThreadStateManager(Looper looper, TaskRecord &#x27;
                         &#x27;taskRecord, IEventListener listener) {\n&#x27;
                         &#x27;    mLooper = looper;\n&#x27;
                         &#x27;    mTaskRecord = taskRecord;\n&#x27;
                         &#x27;    mThreadNum = mTaskRecord.threadNum;\n&#x27;
                         &#x27;    mListener = listener;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public boolean handleMessage(Message &#x27;
                         &#x27;msg) {\n&#x27;
                         &#x27;    switch (msg.what) {\n&#x27;
                         &#x27;      case STATE_STOP:\n&#x27;
                         &#x27;        mStopNum++;\n&#x27;
                         &#x27;        if (isStop()) {\n&#x27;
                         &#x27;          mListener.onStop(mProgress);\n&#x27;
                         &#x27;          quitLooper();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_CANCEL:\n&#x27;
                         &#x27;        mCancelNum++;\n&#x27;
                         &#x27;        if (isCancel()) {\n&#x27;
                         &#x27;          ALog.d(TAG, &quot;icCancel&quot;);\n&#x27;
                         &#x27;          mListener.onCancel();\n&#x27;
                         &#x27;          quitLooper();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_FAIL:\n&#x27;
                         &#x27;        mFailNum++;\n&#x27;
                         &#x27;        if (isFail()) {\n&#x27;
                         &#x27;          Bundle b = msg.getData();\n&#x27;
                         &#x27;          mListener.onFail(b.getBoolean(KEY_RETRY, &#x27;
                         &#x27;true),\n&#x27;
                         &#x27;              (BaseException) &#x27;
                         &#x27;b.getSerializable(KEY_ERROR_INFO));\n&#x27;
                         &#x27;          quitLooper();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_COMPLETE:\n&#x27;
                         &#x27;        mCompleteNum++;\n&#x27;
                         &#x27;        if (isComplete()) {\n&#x27;
                         &#x27;          ALog.d(TAG, &quot;isComplete, completeNum = &quot; + &#x27;
                         &#x27;mCompleteNum);\n&#x27;
                         &#x27;          if (mTaskRecord.isBlock) {\n&#x27;
                         &#x27;            if (mergeFile()) {\n&#x27;
                         &#x27;              mListener.onComplete();\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;              mListener.onFail(false, null);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;          } else {\n&#x27;
                         &#x27;            mListener.onComplete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          quitLooper();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_RUNNING:\n&#x27;
                         &#x27;        mProgress += (long) msg.obj;\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_UPDATE_PROGRESS:\n&#x27;
                         &#x27;        if (msg.obj == null) {\n&#x27;
                         &#x27;          mProgress = updateBlockProgress();\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          mProgress = (long) msg.obj;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    return false;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 退出looper循环\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void quitLooper() {\n&#x27;
                         &#x27;    mLooper.quit();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取当前任务下载进度\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @return 当前任务下载进度\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;
                         &#x27;  public long getCurrentProgress() {\n&#x27;
                         &#x27;    return mProgress;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 所有子线程是否都已经停止\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;
                         &#x27;  public boolean isStop() {\n&#x27;
                         &#x27;    //ALog.d(TAG,\n&#x27;
                         &#x27;    //    String.format(&quot;isStop; stopNum: %s, &#x27;
                         &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;, &#x27;
                         &#x27;mStopNum,\n&#x27;
                         &#x27;    //        mCancelNum, mFailNum, mCompleteNum));\n&#x27;
                         &#x27;    return mStopNum == mThreadNum || mStopNum + &#x27;
                         &#x27;mCompleteNum == mThreadNum;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 所有子线程是否都已经失败\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;
                         &#x27;  public boolean isFail() {\n&#x27;
                         &#x27;    //ALog.d(TAG,\n&#x27;
                         &#x27;    //    String.format(&quot;isFail; stopNum: %s, &#x27;
                         &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;, &#x27;
                         &#x27;mStopNum,\n&#x27;
                         &#x27;    //        mCancelNum, mFailNum, mCompleteNum));\n&#x27;
                         &#x27;    return mCompleteNum != mThreadNum\n&#x27;
                         &#x27;        &amp;&amp; (mFailNum == mThreadNum || mFailNum + &#x27;
                         &#x27;mCompleteNum == mThreadNum);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 所有子线程是否都已经完成\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;
                         &#x27;  public boolean isComplete() {\n&#x27;
                         &#x27;    //ALog.d(TAG,\n&#x27;
                         &#x27;    //    String.format(&quot;isComplete; stopNum: %s, &#x27;
                         &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;,\n&#x27;
                         &#x27;    //        mStopNum,\n&#x27;
                         &#x27;    //        mCancelNum, mFailNum, mCompleteNum));\n&#x27;
                         &#x27;    return mCompleteNum == mThreadNum;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 所有子线程是否都已经取消\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;public class ThreadStateManager implements &#x27;
                           &#x27;Handler.Callback {\n&#x27;
                           &#x27;  private final String TAG = &#x27;
                           &#x27;&quot;ThreadTaskStateManager&quot;;\n&#x27;
                           &#x27;  public static final int STATE_STOP = 0x01;\n&#x27;
                           &#x27;  public static final int STATE_FAIL = 0x02;\n&#x27;
                           &#x27;  public static final int STATE_CANCEL = 0x03;\n&#x27;
                           &#x27;  public static final int STATE_COMPLETE = 0x04;\n&#x27;
                           &#x27;  public static final int STATE_RUNNING = 0x05;\n&#x27;
                           &#x27;  public static final int STATE_UPDATE_PROGRESS = &#x27;
                           &#x27;0x06;\n&#x27;
                           &#x27;  public static final String KEY_RETRY = &#x27;
                           &#x27;&quot;KEY_RETRY&quot;;\n&#x27;
                           &#x27;  public static final String KEY_ERROR_INFO = &#x27;
                           &#x27;&quot;KEY_ERROR_INFO&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 任务状态回调\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private IEventListener mListener;\n&#x27;
                           &#x27;  private int mThreadNum;    // 启动的线程总数\n&#x27;
                           &#x27;  private int mCancelNum = 0; // 已经取消的线程的数\n&#x27;
                           &#x27;  private int mStopNum = 0;  // 已经停止的线程数\n&#x27;
                           &#x27;  private int mFailNum = 0;  // 失败的线程数\n&#x27;
                           &#x27;  private int mCompleteNum = 0;  // 完成的线程数\n&#x27;
                           &#x27;  private long mProgress; //当前总进度\n&#x27;
                           &#x27;  private TaskRecord mTaskRecord; // 任务记录\n&#x27;
                           &#x27;  private Looper mLooper;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * @param taskRecord 任务记录\n&#x27;
                           &#x27;   * @param listener 任务事件\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  ThreadStateManager(Looper looper, TaskRecord &#x27;
                           &#x27;taskRecord, IEventListener listener) {\n&#x27;
                           &#x27;    mLooper = looper;\n&#x27;
                           &#x27;    mTaskRecord = taskRecord;\n&#x27;
                           &#x27;    mThreadNum = mTaskRecord.threadNum;\n&#x27;
                           &#x27;    mListener = listener;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public boolean handleMessage(Message &#x27;
                           &#x27;msg) {\n&#x27;
                           &#x27;    switch (msg.what) {\n&#x27;
                           &#x27;      case STATE_STOP:\n&#x27;
                           &#x27;        mStopNum++;\n&#x27;
                           &#x27;        if (isStop()) {\n&#x27;
                           &#x27;          mListener.onStop(mProgress);\n&#x27;
                           &#x27;          quitLooper();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_CANCEL:\n&#x27;
                           &#x27;        mCancelNum++;\n&#x27;
                           &#x27;        if (isCancel()) {\n&#x27;
                           &#x27;          ALog.d(TAG, &quot;icCancel&quot;);\n&#x27;
                           &#x27;          mListener.onCancel();\n&#x27;
                           &#x27;          quitLooper();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_FAIL:\n&#x27;
                           &#x27;        mFailNum++;\n&#x27;
                           &#x27;        if (isFail()) {\n&#x27;
                           &#x27;          Bundle b = msg.getData();\n&#x27;
                           &#x27;          mListener.onFail(b.getBoolean(KEY_RETRY, &#x27;
                           &#x27;true),\n&#x27;
                           &#x27;              (BaseException) &#x27;
                           &#x27;b.getSerializable(KEY_ERROR_INFO));\n&#x27;
                           &#x27;          quitLooper();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_COMPLETE:\n&#x27;
                           &#x27;        mCompleteNum++;\n&#x27;
                           &#x27;        if (isComplete()) {\n&#x27;
                           &#x27;          ALog.d(TAG, &quot;isComplete, completeNum = &quot; &#x27;
                           &#x27;+ mCompleteNum);\n&#x27;
                           &#x27;          if (mTaskRecord.isBlock) {\n&#x27;
                           &#x27;            if (mergeFile()) {\n&#x27;
                           &#x27;              mListener.onComplete();\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;              mListener.onFail(false, null);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;          } else {\n&#x27;
                           &#x27;            mListener.onComplete();\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;          quitLooper();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_RUNNING:\n&#x27;
                           &#x27;        mProgress += (long) msg.obj;\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_UPDATE_PROGRESS:\n&#x27;
                           &#x27;        if (msg.obj == null) {\n&#x27;
                           &#x27;          mProgress = updateBlockProgress();\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          mProgress = (long) msg.obj;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    return false;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 退出looper循环\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void quitLooper() {\n&#x27;
                           &#x27;    mLooper.quit();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 获取当前任务下载进度\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return 当前任务下载进度\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public long getCurrentProgress() {\n&#x27;
                           &#x27;    return mProgress;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 所有子线程是否都已经停止\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public boolean isStop() {\n&#x27;
                           &#x27;    //ALog.d(TAG,\n&#x27;
                           &#x27;    //    String.format(&quot;isStop; stopNum: %s, &#x27;
                           &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;, &#x27;
                           &#x27;mStopNum,\n&#x27;
                           &#x27;    //        mCancelNum, mFailNum, &#x27;
                           &#x27;mCompleteNum));\n&#x27;
                           &#x27;    return mStopNum == mThreadNum || mStopNum + &#x27;
                           &#x27;mCompleteNum == mThreadNum;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 所有子线程是否都已经失败\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public boolean isFail() {\n&#x27;
                           &#x27;    //ALog.d(TAG,\n&#x27;
                           &#x27;    //    String.format(&quot;isFail; stopNum: %s, &#x27;
                           &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;, &#x27;
                           &#x27;mStopNum,\n&#x27;
                           &#x27;    //        mCancelNum, mFailNum, &#x27;
                           &#x27;mCompleteNum));\n&#x27;
                           &#x27;    return mCompleteNum != mThreadNum\n&#x27;
                           &#x27;        &amp;&amp; (mFailNum == mThreadNum || mFailNum + &#x27;
                           &#x27;mCompleteNum == mThreadNum);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 所有子线程是否都已经完成\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public boolean isComplete() {\n&#x27;
                           &#x27;    //ALog.d(TAG,\n&#x27;
                           &#x27;    //    String.format(&quot;isComplete; stopNum: %s, &#x27;
                           &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;,\n&#x27;
                           &#x27;    //        mStopNum,\n&#x27;
                           &#x27;    //        mCancelNum, mFailNum, &#x27;
                           &#x27;mCompleteNum));\n&#x27;
                           &#x27;    return mCompleteNum == mThreadNum;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 所有子线程是否都已经取消\n&#x27;
                           &#x27;   */\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;public class ThreadStateManager implements &#x27;
                         &#x27;IThreadState {\n&#x27;
                         &#x27;  private final String TAG = &#x27;
                         &#x27;&quot;ThreadTaskStateManager&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 任务状态回调\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private IEventListener mListener;\n&#x27;
                         &#x27;  private int mThreadNum;    // 启动的线程总数\n&#x27;
                         &#x27;  private int mCancelNum = 0; // 已经取消的线程的数\n&#x27;
                         &#x27;  private int mStopNum = 0;  // 已经停止的线程数\n&#x27;
                         &#x27;  private int mFailNum = 0;  // 失败的线程数\n&#x27;
                         &#x27;  private int mCompleteNum = 0;  // 完成的线程数\n&#x27;
                         &#x27;  private long mProgress; //当前总进度\n&#x27;
                         &#x27;  private TaskRecord mTaskRecord; // 任务记录\n&#x27;
                         &#x27;  private Looper mLooper;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * @param taskRecord 任务记录\n&#x27;
                         &#x27;   * @param listener 任务事件\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  ThreadStateManager(Looper looper, TaskRecord &#x27;
                         &#x27;taskRecord, IEventListener listener) {\n&#x27;
                         &#x27;    mLooper = looper;\n&#x27;
                         &#x27;    mTaskRecord = taskRecord;\n&#x27;
                         &#x27;    mThreadNum = mTaskRecord.threadNum;\n&#x27;
                         &#x27;    mListener = listener;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public boolean handleMessage(Message &#x27;
                         &#x27;msg) {\n&#x27;
                         &#x27;    switch (msg.what) {\n&#x27;
                         &#x27;      case STATE_STOP:\n&#x27;
                         &#x27;        mStopNum++;\n&#x27;
                         &#x27;        if (isStop()) {\n&#x27;
                         &#x27;          mListener.onStop(mProgress);\n&#x27;
                         &#x27;          quitLooper();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_CANCEL:\n&#x27;
                         &#x27;        mCancelNum++;\n&#x27;
                         &#x27;        if (isCancel()) {\n&#x27;
                         &#x27;          ALog.d(TAG, &quot;icCancel&quot;);\n&#x27;
                         &#x27;          mListener.onCancel();\n&#x27;
                         &#x27;          quitLooper();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_FAIL:\n&#x27;
                         &#x27;        mFailNum++;\n&#x27;
                         &#x27;        if (isFail()) {\n&#x27;
                         &#x27;          Bundle b = msg.getData();\n&#x27;
                         &#x27;          mListener.onFail(b.getBoolean(KEY_RETRY, &#x27;
                         &#x27;true),\n&#x27;
                         &#x27;              (BaseException) &#x27;
                         &#x27;b.getSerializable(KEY_ERROR_INFO));\n&#x27;
                         &#x27;          quitLooper();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_COMPLETE:\n&#x27;
                         &#x27;        mCompleteNum++;\n&#x27;
                         &#x27;        if (isComplete()) {\n&#x27;
                         &#x27;          ALog.d(TAG, &quot;isComplete, completeNum = &quot; + &#x27;
                         &#x27;mCompleteNum);\n&#x27;
                         &#x27;          if (mTaskRecord.isBlock) {\n&#x27;
                         &#x27;            if (mergeFile()) {\n&#x27;
                         &#x27;              mListener.onComplete();\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;              mListener.onFail(false, null);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;          } else {\n&#x27;
                         &#x27;            mListener.onComplete();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;          quitLooper();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_RUNNING:\n&#x27;
                         &#x27;        mProgress += (long) msg.obj;\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;      case STATE_UPDATE_PROGRESS:\n&#x27;
                         &#x27;        if (msg.obj == null) {\n&#x27;
                         &#x27;          mProgress = updateBlockProgress();\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          mProgress = (long) msg.obj;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        break;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    return false;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 退出looper循环\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void quitLooper() {\n&#x27;
                         &#x27;    mLooper.quit();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取当前任务下载进度\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @return 当前任务下载进度\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;
                         &#x27;  public long getCurrentProgress() {\n&#x27;
                         &#x27;    return mProgress;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 所有子线程是否都已经停止\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;
                         &#x27;  public boolean isStop() {\n&#x27;
                         &#x27;    //ALog.d(TAG,\n&#x27;
                         &#x27;    //    String.format(&quot;isStop; stopNum: %s, &#x27;
                         &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;, &#x27;
                         &#x27;mStopNum,\n&#x27;
                         &#x27;    //        mCancelNum, mFailNum, mCompleteNum));\n&#x27;
                         &#x27;    return mStopNum == mThreadNum || mStopNum + &#x27;
                         &#x27;mCompleteNum == mThreadNum;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 所有子线程是否都已经失败\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;
                         &#x27;  public boolean isFail() {\n&#x27;
                         &#x27;    //ALog.d(TAG,\n&#x27;
                         &#x27;    //    String.format(&quot;isFail; stopNum: %s, &#x27;
                         &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;, &#x27;
                         &#x27;mStopNum,\n&#x27;
                         &#x27;    //        mCancelNum, mFailNum, mCompleteNum));\n&#x27;
                         &#x27;    return mCompleteNum != mThreadNum\n&#x27;
                         &#x27;        &amp;&amp; (mFailNum == mThreadNum || mFailNum + &#x27;
                         &#x27;mCompleteNum == mThreadNum);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 所有子线程是否都已经完成\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;
                         &#x27;  public boolean isComplete() {\n&#x27;
                         &#x27;    //ALog.d(TAG,\n&#x27;
                         &#x27;    //    String.format(&quot;isComplete; stopNum: %s, &#x27;
                         &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;,\n&#x27;
                         &#x27;    //        mStopNum,\n&#x27;
                         &#x27;    //        mCancelNum, mFailNum, mCompleteNum));\n&#x27;
                         &#x27;    return mCompleteNum == mThreadNum;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 所有子线程是否都已经取消\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  @Override\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;public class ThreadStateManager implements &#x27;
                           &#x27;Handler.Callback {\n&#x27;
                           &#x27;  private final String TAG = &#x27;
                           &#x27;&quot;ThreadTaskStateManager&quot;;\n&#x27;
                           &#x27;  public static final int STATE_STOP = 0x01;\n&#x27;
                           &#x27;  public static final int STATE_FAIL = 0x02;\n&#x27;
                           &#x27;  public static final int STATE_CANCEL = 0x03;\n&#x27;
                           &#x27;  public static final int STATE_COMPLETE = 0x04;\n&#x27;
                           &#x27;  public static final int STATE_RUNNING = 0x05;\n&#x27;
                           &#x27;  public static final int STATE_UPDATE_PROGRESS = &#x27;
                           &#x27;0x06;\n&#x27;
                           &#x27;  public static final String KEY_RETRY = &#x27;
                           &#x27;&quot;KEY_RETRY&quot;;\n&#x27;
                           &#x27;  public static final String KEY_ERROR_INFO = &#x27;
                           &#x27;&quot;KEY_ERROR_INFO&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 任务状态回调\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private IEventListener mListener;\n&#x27;
                           &#x27;  private int mThreadNum;    // 启动的线程总数\n&#x27;
                           &#x27;  private int mCancelNum = 0; // 已经取消的线程的数\n&#x27;
                           &#x27;  private int mStopNum = 0;  // 已经停止的线程数\n&#x27;
                           &#x27;  private int mFailNum = 0;  // 失败的线程数\n&#x27;
                           &#x27;  private int mCompleteNum = 0;  // 完成的线程数\n&#x27;
                           &#x27;  private long mProgress; //当前总进度\n&#x27;
                           &#x27;  private TaskRecord mTaskRecord; // 任务记录\n&#x27;
                           &#x27;  private Looper mLooper;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * @param taskRecord 任务记录\n&#x27;
                           &#x27;   * @param listener 任务事件\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  ThreadStateManager(Looper looper, TaskRecord &#x27;
                           &#x27;taskRecord, IEventListener listener) {\n&#x27;
                           &#x27;    mLooper = looper;\n&#x27;
                           &#x27;    mTaskRecord = taskRecord;\n&#x27;
                           &#x27;    mThreadNum = mTaskRecord.threadNum;\n&#x27;
                           &#x27;    mListener = listener;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public boolean handleMessage(Message &#x27;
                           &#x27;msg) {\n&#x27;
                           &#x27;    switch (msg.what) {\n&#x27;
                           &#x27;      case STATE_STOP:\n&#x27;
                           &#x27;        mStopNum++;\n&#x27;
                           &#x27;        if (isStop()) {\n&#x27;
                           &#x27;          mListener.onStop(mProgress);\n&#x27;
                           &#x27;          quitLooper();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_CANCEL:\n&#x27;
                           &#x27;        mCancelNum++;\n&#x27;
                           &#x27;        if (isCancel()) {\n&#x27;
                           &#x27;          ALog.d(TAG, &quot;icCancel&quot;);\n&#x27;
                           &#x27;          mListener.onCancel();\n&#x27;
                           &#x27;          quitLooper();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_FAIL:\n&#x27;
                           &#x27;        mFailNum++;\n&#x27;
                           &#x27;        if (isFail()) {\n&#x27;
                           &#x27;          Bundle b = msg.getData();\n&#x27;
                           &#x27;          mListener.onFail(b.getBoolean(KEY_RETRY, &#x27;
                           &#x27;true),\n&#x27;
                           &#x27;              (BaseException) &#x27;
                           &#x27;b.getSerializable(KEY_ERROR_INFO));\n&#x27;
                           &#x27;          quitLooper();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_COMPLETE:\n&#x27;
                           &#x27;        mCompleteNum++;\n&#x27;
                           &#x27;        if (isComplete()) {\n&#x27;
                           &#x27;          ALog.d(TAG, &quot;isComplete, completeNum = &quot; &#x27;
                           &#x27;+ mCompleteNum);\n&#x27;
                           &#x27;          if (mTaskRecord.isBlock) {\n&#x27;
                           &#x27;            if (mergeFile()) {\n&#x27;
                           &#x27;              mListener.onComplete();\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;              mListener.onFail(false, null);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;          } else {\n&#x27;
                           &#x27;            mListener.onComplete();\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;          quitLooper();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_RUNNING:\n&#x27;
                           &#x27;        mProgress += (long) msg.obj;\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;      case STATE_UPDATE_PROGRESS:\n&#x27;
                           &#x27;        if (msg.obj == null) {\n&#x27;
                           &#x27;          mProgress = updateBlockProgress();\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          mProgress = (long) msg.obj;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        break;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    return false;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 退出looper循环\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void quitLooper() {\n&#x27;
                           &#x27;    mLooper.quit();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 获取当前任务下载进度\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return 当前任务下载进度\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public long getCurrentProgress() {\n&#x27;
                           &#x27;    return mProgress;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 所有子线程是否都已经停止\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public boolean isStop() {\n&#x27;
                           &#x27;    //ALog.d(TAG,\n&#x27;
                           &#x27;    //    String.format(&quot;isStop; stopNum: %s, &#x27;
                           &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;, &#x27;
                           &#x27;mStopNum,\n&#x27;
                           &#x27;    //        mCancelNum, mFailNum, &#x27;
                           &#x27;mCompleteNum));\n&#x27;
                           &#x27;    return mStopNum == mThreadNum || mStopNum + &#x27;
                           &#x27;mCompleteNum == mThreadNum;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 所有子线程是否都已经失败\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public boolean isFail() {\n&#x27;
                           &#x27;    //ALog.d(TAG,\n&#x27;
                           &#x27;    //    String.format(&quot;isFail; stopNum: %s, &#x27;
                           &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;, &#x27;
                           &#x27;mStopNum,\n&#x27;
                           &#x27;    //        mCancelNum, mFailNum, &#x27;
                           &#x27;mCompleteNum));\n&#x27;
                           &#x27;    return mCompleteNum != mThreadNum\n&#x27;
                           &#x27;        &amp;&amp; (mFailNum == mThreadNum || mFailNum + &#x27;
                           &#x27;mCompleteNum == mThreadNum);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 所有子线程是否都已经完成\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public boolean isComplete() {\n&#x27;
                           &#x27;    //ALog.d(TAG,\n&#x27;
                           &#x27;    //    String.format(&quot;isComplete; stopNum: %s, &#x27;
                           &#x27;cancelNum: %s, failNum: %s, completeNum: %s&quot;,\n&#x27;
                           &#x27;    //        mStopNum,\n&#x27;
                           &#x27;    //        mCancelNum, mFailNum, &#x27;
                           &#x27;mCompleteNum));\n&#x27;
                           &#x27;    return mCompleteNum == mThreadNum;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 所有子线程是否都已经取消\n&#x27;
                           &#x27;   */\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        