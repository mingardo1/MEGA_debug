<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>8</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    8
                    <a href="7.html">prev</a>
                    <a href="9.html">next</a>
                    <a href="8_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    AriaLyy/Aria_1469ca1ceaae9c691eee7790de89a3ee1f571403_Aria/src/main/java/com/arialyy/aria/core/common/AbsThreadTask.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\AriaLyy\Aria show &quot;1469ca1ceaae9c691eee7790de89a3ee1f571403:Aria/src/main/java/com/arialyy/aria/core/common/AbsThreadTask.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\AriaLyy\Aria show &quot;1469ca1ceaae9c691eee7790de89a3ee1f571403^1:Aria/src/main/java/com/arialyy/aria/core/common/AbsThreadTask.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\AriaLyy\Aria show &quot;1469ca1ceaae9c691eee7790de89a3ee1f571403^2:Aria/src/main/java/com/arialyy/aria/core/common/AbsThreadTask.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\AriaLyy\Aria show &quot;39a43c836d3309cbbf82de6d51309fe71fc25292:Aria/src/main/java/com/arialyy/aria/core/common/AbsThreadTask.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bs], [sbj], [sbj], [sbj], [sbj], [sbj], [bs], [sbj], [sbj], [sbj], [sbj], [j], [j]], subset: [[bs], [sbj], [sbj], [sbj], [sbj], [sbj], [bj], [sbj], [sbj], [sbj], [bj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2016 AriaLyy(https://github.com/AriaLyy/Aria)
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.arialyy.aria.core.common;
  17 
  18 import android.net.TrafficStats;
  19 import android.os.Bundle;
  20 import android.os.Handler;
  21 import android.os.Message;
  22 import android.os.Process;
  23 import android.support.annotation.Nullable;
  24 import com.arialyy.aria.core.AriaManager;
  25 import com.arialyy.aria.core.config.BaseTaskConfig;
  26 import com.arialyy.aria.core.config.DGroupConfig;
  27 import com.arialyy.aria.core.config.DownloadConfig;
  28 import com.arialyy.aria.core.config.UploadConfig;
  29 import com.arialyy.aria.core.inf.AbsNormalEntity;
  30 import com.arialyy.aria.core.inf.AbsTaskWrapper;
  31 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  32 import com.arialyy.aria.core.inf.ITaskWrapper;</span>
  33 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  34 import com.arialyy.aria.exception.BaseException;</span>
  35 =======
  36 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  37 import com.arialyy.aria.core.manager.ThreadTaskManager;
  38 import com.arialyy.aria.exception.BaseException;
  39 import com.arialyy.aria.util.ALog;
  40 import com.arialyy.aria.util.BufferedRandomAccessFile;
  41 import com.arialyy.aria.util.ErrorHelp;
  42 import com.arialyy.aria.util.NetUtils;
  43 import java.io.File;
  44 import java.util.UUID;
  45 import java.util.concurrent.Callable;
  46 import java.util.concurrent.ExecutorService;
  47 import java.util.concurrent.Executors;
  48 
  49 /**
  50  * Created by lyy on 2017/1/18. 任务线程
  51  */
<abbr title="  52 public abstract class AbsThreadTask&lt;ENTITY extends AbsNormalEntity, TASK_WRAPPER extends AbsTaskWrapper&lt;ENTITY&gt;&gt;">  52 public abstract class AbsThreadTask&lt;ENTITY extends AbsNormalEntity, TASK_WRAPPER extends AbsTaskWrapper&lt;E🔵</abbr>
  53     implements Callable&lt;AbsThreadTask&gt; {
  54   /**
  55    * 线程重试次数
  56    */
  57   private final int RETRY_NUM = 2;
  58 
  59   private final String TAG = &quot;AbsThreadTask&quot;;
  60   /**
  61    * 当前子线程相对于总长度的位置
  62    */
  63   protected long mChildCurrentLocation = 0;
  64   private ENTITY mEntity;
  65   protected TASK_WRAPPER mTaskWrapper;
  66   private int mFailTimes = 0;
  67   private long mLastSaveTime;
  68   private ExecutorService mConfigThreadPool;
  69   private boolean isNotNetRetry;  //断网情况是否重试
  70   private boolean taskBreak = false;  //任务跳出
  71   protected BandwidthLimiter mSpeedBandUtil; //速度限制工具
  72   protected AriaManager mAridManager;
  73   private boolean isInterrupted = false;
  74   protected boolean isCancel = false, isStop = false;
  75   protected ThreadRecord mRecord;
  76   private Handler mStateHandler;
  77   private SubThreadConfig&lt;TASK_WRAPPER&gt; mConfig;
  78 
  79   private Thread mConfigThread = new Thread(new Runnable() {
  80     @Override public void run() {
  81       Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
  82       final long currentTemp = mChildCurrentLocation;
  83       writeConfig(false, currentTemp);
  84     }
  85   });
  86 
  87   protected AbsThreadTask(SubThreadConfig&lt;TASK_WRAPPER&gt; config) {
  88     mConfig = config;
  89     mTaskWrapper = config.taskWrapper;
  90     mRecord = config.record;
  91     mStateHandler = config.stateHandler;
  92     mEntity = mTaskWrapper.getEntity();
  93     mLastSaveTime = System.currentTimeMillis();
  94     mConfigThreadPool = Executors.newCachedThreadPool();
  95     mAridManager = AriaManager.getInstance(AriaManager.APP);
  96     if (getMaxSpeed() &gt; 0) {
  97       mSpeedBandUtil = new BandwidthLimiter(getMaxSpeed(), config.startThreadNum);
  98     }
  99     isNotNetRetry = mAridManager.getAppConfig().isNotNetRetry();
 100     mChildCurrentLocation = mRecord.startLocation;
 101   }
 102 
 103   /**
 104    * 当前线程处理的文件名
 105    */
 106   protected String getFileName() {
 107     return mConfig.tempFile.getName();
 108   }
 109 
 110   protected SubThreadConfig&lt;TASK_WRAPPER&gt; getConfig() {
 111     return mConfig;
 112   }
 113 
 114   /**
 115    * 设置线程是否中断
 116    *
 117    * @param isInterrupted {@code true} 中断
 118    */
 119   public void setInterrupted(boolean isInterrupted) {
 120     this.isInterrupted = isInterrupted;
 121   }
 122 
 123   /**
 124    * 线程是否存活
 125    *
 126    * @return {@code true}存活
 127    */
 128   protected boolean isLive() {
 129     return !Thread.currentThread().isInterrupted() &amp;&amp; !isInterrupted;
 130   }
 131 
 132   /**
 133    * 当前线程是否完成，对于不支持断点的任务，一律未完成 {@code true} 完成；{@code false} 未完成
 134    */
 135   boolean isThreadComplete() {
 136     return mRecord.isComplete;
 137   }
 138 
 139   /**
 140    * 获取实体
 141    */
 142   protected ENTITY getEntity() {
 143     return mEntity;
 144   }
 145 
 146   /**
 147    * 获取任务驱动对象
 148    */
 149   protected TASK_WRAPPER getTaskWrapper() {
 150     return mTaskWrapper;
 151   }
 152 
 153   /**
 154    * 获取配置的最大上传/下载速度
 155    *
 156    * @return 单位为：kb
 157    */
 158   public abstract int getMaxSpeed();
 159 
 160   /**
 161    * 读取任务配置
 162    *
 163    * @return {@link DownloadConfig}、{@link UploadConfig}、{@link DGroupConfig}
 164    */
 165   protected abstract BaseTaskConfig getTaskConfig();
 166 
 167   /**
 168    * 设置最大下载速度
 169    *
 170    * @param speed 单位为：kb
 171    */
 172   public void setMaxSpeed(int speed) {
 173     if (mSpeedBandUtil != null) {
 174       mSpeedBandUtil.setMaxRate(speed / mConfig.startThreadNum);
 175     }
 176   }
 177 
 178   /**
 179    * 中断任务
 180    */
 181   void breakTask() {
 182     synchronized (AriaManager.LOCK) {
 183       taskBreak = true;
 184       if (mTaskWrapper.isSupportBP()) {
 185         final long currentTemp = mChildCurrentLocation;
 186 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 187         sendState(IThreadState.STATE_STOP, null);</span>
 188 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 189    */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 190   public void setMaxSpeed(int speed) {</span>
 191 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 192         sendState(ThreadStateManager.STATE_STOP, null);</span>
 193 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 194         ALog.d(TAG, String.format(&quot;任务【%s】thread__%s__中断【停止位置：%s】&quot;, getFileName(),
 195             mRecord.threadId, currentTemp));
 196         writeConfig(false, currentTemp);
 197       } else {
 198         ALog.i(TAG, String.format(&quot;任务【%s】已中断&quot;, getFileName()));
 199       }
 200     }
 201   }
 202 
 203   /**
 204    * 发送状态给状态处理器
 205    *
 206 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 207    * @param state {@link IThreadState#STATE_STOP}..</span>
 208 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 209       if (getConfig().SUPPORT_BP) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 210         final long currentTemp = mChildCurrentLocation;</span>
 211 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 212    * @param state {@link ThreadStateManager#STATE_STOP}..</span>
 213 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 214    * @param bundle 而外数据
 215    */
 216   void sendState(int state, @Nullable Bundle bundle) {
 217     Message msg = mStateHandler.obtainMessage();
 218     msg.what = state;
 219     if (bundle != null) {
 220       msg.setData(bundle);
 221     }
 222     msg.sendToTarget();
 223   }
 224 
 225   public boolean isInterrupted() {
 226     return Thread.currentThread().isInterrupted();
 227   }
 228 
 229   @Override protected void finalize() throws Throwable {
 230     super.finalize();
 231     if (mConfigThreadPool != null) {
 232       mConfigThreadPool.shutdown();
 233     }
 234   }
 235 
 236   /**
 237    * 任务是否中断，中断条件： 1、任务取消 2、任务停止 3、手动中断 {@link #taskBreak}
 238    *
 239    * @return {@code true} 中断，{@code false} 不是中断
 240    */
 241   protected boolean isBreak() {
 242     return isCancel || isStop || taskBreak;
 243   }
 244 
 245   /**
 246    * 检查下载完成的分块大小，如果下载完成的分块大小大于或小于分配的大小，则需要重新下载该分块 如果是非分块任务，直接返回{@code true}
 247    *
 248    * @return {@code true} 分块分大小正常，{@code false} 分块大小错误
 249    */
 250   protected boolean checkBlock() {
 251     if (!mConfig.isBlock) {
 252       return true;
 253     }
 254     File blockFile = mConfig.tempFile;
 255     if (!blockFile.exists() || blockFile.length() != mRecord.blockLen) {
 256       ALog.i(TAG,
 257           String.format(&quot;分块【%s】错误，blockFileLen: %s, threadRect: %s; 即将重新下载该分块，开始位置：%s，结束位置：%s&quot;,
 258               blockFile.getName(), blockFile.length(), mRecord.blockLen, mRecord.startLocation,
 259               mRecord.endLocation));
 260       if (blockFile.exists()) {
 261         blockFile.delete();
 262         ALog.i(TAG, String.format(&quot;删除分块【%s】成功&quot;, blockFile.getName()));
 263       }
 264       retryThis(isBreak());
 265       return false;
 266     }
 267     return true;
 268   }
 269 
 270   /**
 271    * 停止任务
 272    */
 273   public void stop() {
 274     synchronized (AriaManager.LOCK) {
 275       isStop = true;
 276       if (mTaskWrapper.isSupportBP()) {
 277         final long stopLocation = mChildCurrentLocation;
 278 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 279         sendState(IThreadState.STATE_STOP, null);</span>
 280 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 281       }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 282       return true;</span>
 283 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 284         sendState(ThreadStateManager.STATE_STOP, null);</span>
 285 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 286         ALog.d(TAG,
 287             String.format(&quot;任务【%s】thread__%s__停止【当前线程停止位置：%s】&quot;, getFileName(),
 288                 mRecord.threadId, stopLocation));
 289         writeConfig(false, stopLocation);
 290       } else {
 291         ALog.i(TAG, String.format(&quot;任务【%s】已停止&quot;, getFileName()));
 292 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 293         sendState(IThreadState.STATE_STOP, null);</span>
 294 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 295   /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 296    * 检查下载完成的分块大小，如果下载完成的分块大小大于或小于分配的大小，则需要重新下载该分块 如果是非分块任务，直接返回{@code true}</span>
 297 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 298         sendState(ThreadStateManager.STATE_STOP, null);</span>
 299 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 300       }
 301     }
 302   }
 303 
 304   /**
 305    * 执行中
 306    */
 307   protected void progress(long len) {
 308     synchronized (AriaManager.LOCK) {
 309       //if (getState().CURRENT_LOCATION &gt; getEntity().getFileSize() &amp;&amp; !getTaskWrapper().asHttp()
 310       //    .isChunked()) {
 311       //  String errorMsg =
 312       //      String.format(&quot;下载失败，下载长度超出文件真实长度；currentLocation=%s, fileSize=%s&quot;,
 313       //          getState().CURRENT_LOCATION,
 314       //          getEntity().getFileSize());
 315       //  taskBreak = true;
 316       //  fail(mChildCurrentLocation, new FileException(TAG, errorMsg), false);
 317       //  return;
 318       //}
 319       mChildCurrentLocation += len;
 320       if (!mStateHandler.getLooper().getThread().isAlive()) {
 321         return;
 322       }
 323 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 324       mStateHandler.obtainMessage(IThreadState.STATE_RUNNING, len).sendToTarget();</span>
 325 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 326   }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 327 </span>
 328 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 329       mStateHandler.obtainMessage(ThreadStateManager.STATE_RUNNING, len).sendToTarget();</span>
 330 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 331       if (System.currentTimeMillis() - mLastSaveTime &gt; 5000
 332           &amp;&amp; mChildCurrentLocation &lt; mRecord.endLocation) {
 333         mLastSaveTime = System.currentTimeMillis();
 334         if (!mConfigThreadPool.isShutdown()) {
 335           mConfigThreadPool.execute(mConfigThread);
 336         }
 337       }
 338     }
 339   }
 340 
 341   /**
 342    * 取消任务
 343    */
 344   public void cancel() {
 345     synchronized (AriaManager.LOCK) {
 346       isCancel = true;
 347 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 348       sendState(IThreadState.STATE_CANCEL, null);</span>
 349 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 350         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 351         getState().STOP_NUM++;</span>
 352 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 353       sendState(ThreadStateManager.STATE_CANCEL, null);</span>
 354 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 355       ALog.d(TAG,
 356           String.format(&quot;任务【%s】thread__%s__取消&quot;, getFileName(), mRecord.threadId));
 357     }
 358   }
 359 
 360   /**
 361    * 线程任务失败
 362    *
 363    * @param subCurrentLocation 当前线程下载进度
 364    * @param ex 异常信息
 365    */
 366   protected void fail(final long subCurrentLocation, BaseException ex) {
 367     fail(subCurrentLocation, ex, true);
 368   }
 369 
 370   /**
 371    * 任务失败
 372    *
 373    * @param subCurrentLocation 当前子线程进度
 374    */
 375   protected void fail(final long subCurrentLocation, BaseException ex, boolean needRetry) {
 376     if (ex != null) {
 377       ALog.e(TAG, ALog.getExceptionString(ex));
 378     }
 379 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 380     if (mTaskWrapper.getRequestType() == ITaskWrapper.M3U8_FILE) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 381       writeConfig(false, 0);</span>
 382 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 383           .isChunked()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 384         String errorMsg =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 385             String.format(&quot;下载失败，下载长度超出文件真实长度；currentLocation=%s, fileSize=%s&quot;,</span>
 386 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 387     if (mTaskWrapper.isSupportBP()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 388       writeConfig(false, subCurrentLocation);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 389       retryThis(needRetry &amp;&amp; mConfig.startThreadNum != 1);</span>
 390 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 391     } else {
 392 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 393       if (mTaskWrapper.isSupportBP()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 394         writeConfig(false, subCurrentLocation);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 395         retryThis(needRetry &amp;&amp; mConfig.startThreadNum != 1);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 396       } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 397         ALog.e(TAG, String.format(&quot;任务【%s】执行失败&quot;, getFileName()));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 398         ErrorHelp.saveError(TAG, &quot;&quot;, ALog.getExceptionString(ex));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 399         sendFailMsg(null);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 400       }</span>
 401 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 402                 getEntity().getFileSize());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 403         taskBreak = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 404         fail(mChildCurrentLocation, new FileException(TAG, errorMsg), false);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 405         return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 406       }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 407       mChildCurrentLocation += len;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 408       getState().CURRENT_LOCATION += len;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 409       if (System.currentTimeMillis() - mLastSaveTime &gt; 5000</span>
 410 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 411       ALog.e(TAG, String.format(&quot;任务【%s】执行失败&quot;, getFileName()));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 412       ErrorHelp.saveError(TAG, &quot;&quot;, ALog.getExceptionString(ex));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 413       sendFailMsg(null);</span>
 414 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 415     }
 416   }
 417 
 418   /**
 419    * 重试当前线程，如果其中一条线程已经下载失败，则任务该任务下载失败，并且停止该任务的所有线程
 420    *
 421    * @param needRetry 是否可以重试
 422    */
 423   private void retryThis(boolean needRetry) {
 424     if (!NetUtils.isConnected(AriaManager.APP) &amp;&amp; !isNotNetRetry) {
 425       ALog.w(TAG, String.format(&quot;任务【%s】重试失败，网络未连接&quot;, getFileName()));
 426     }
 427     if (mFailTimes &lt; RETRY_NUM &amp;&amp; needRetry &amp;&amp; (NetUtils.isConnected(AriaManager.APP)
 428         || isNotNetRetry) &amp;&amp; !isBreak()) {
 429       ALog.w(TAG, String.format(&quot;任务【%s】正在重试&quot;, getFileName()));
 430       mFailTimes++;
 431       handleRetryRecord();
 432       ThreadTaskManager.getInstance().retryThread(AbsThreadTask.this);
 433     } else {
 434       sendFailMsg(null);
 435     }
 436   }
 437 
 438   /**
 439    * 处理线程重试的记录，只有多线程任务才会执行
 440    * 如果是以前版本{@link BufferedRandomAccessFile}创建的下载，那么 record.startLocation不用修改
 441    */
 442   private void handleRetryRecord() {
 443     if (mConfig.isBlock) {
 444       // 默认线程分块长度
 445       File temp = mConfig.tempFile;
 446 
 447       long blockFileLen = temp.length(); // 磁盘中的分块文件长度
 448       long threadRect = mRecord.blockLen;     // 当前线程的区间
 449 
 450       if (!temp.exists()) {
 451         ALog.i(TAG, String.format(&quot;分块文件【%s】不存在，该分块将重新开始&quot;, temp.getName()));
 452         mRecord.isComplete = false;
 453         mRecord.startLocation = mRecord.endLocation - threadRect;
 454       } else {
 455         /*
 456          * 检查磁盘中的分块文件
 457          */
 458         if (blockFileLen &gt; threadRect) {
 459           ALog.i(TAG, String.format(&quot;分块【%s】错误，将重新下载该分块&quot;, temp.getName()));
 460           temp.delete();
 461           mRecord.startLocation = mRecord.endLocation - mRecord.blockLen;
 462           mRecord.isComplete = false;
 463         } else if (blockFileLen &lt; mRecord.blockLen) {
 464           mRecord.startLocation = mRecord.endLocation - mRecord.blockLen + blockFileLen;
 465           mRecord.isComplete = false;
 466 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 467           sendState(IThreadState.STATE_UPDATE_PROGRESS, null);</span>
 468 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 469 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 470   /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 471    * 任务失败</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 472    *</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 473    * @param subCurrentLocation 当前子线程进度</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 474    */</span>
 475 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 476           sendState(ThreadStateManager.STATE_UPDATE_PROGRESS, null);</span>
 477 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 478           ALog.i(TAG,
 479 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 480               String.format(&quot;修正分块【%s】记录，开始位置：%s，结束位置：%s&quot;, temp.getName(), mRecord.startLocation,</span>
 481 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 482    * 任务失败</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 483    *</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 484    * @param subCurrentLocation 当前子线程进度</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 485    */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 486   protected void fail(final long subCurrentLocation, BaseException ex, boolean needRetry) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 487     if (ex != null) {</span>
 488 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 489               String.format(&quot;修正分块【%s】，开始位置：%s，结束位置：%s&quot;, temp.getName(), mRecord.startLocation,</span>
 490 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 491                   mRecord.endLocation));
 492         } else {
 493           ALog.i(TAG, String.format(&quot;分块【%s】已完成，更新记录&quot;, temp.getName()));
 494           mRecord.isComplete = true;
 495         }
 496       }
 497       mRecord.update();
 498     }
 499   }
 500 
 501   /**
 502    * 发送任务完成的消息，并删除任务记录
 503    */
 504   protected synchronized void sendCompleteMsg() {
 505     ALog.i(TAG, String.format(&quot;任务【%s】完成&quot;, getFileName()));
 506 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 507     sendState(IThreadState.STATE_COMPLETE, null);</span>
 508 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 509   }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 510 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 511   /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 512    * 重试当前线程，如果其中一条线程已经下载失败，则任务该任务下载失败，并且停止该任务的所有线程</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 513    *</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 514    * @param needRetry 是否可以重试</span>
 515 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 516     sendState(ThreadStateManager.STATE_COMPLETE, null);</span>
 517 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 518   }
 519 
 520   /**
 521    * 发送失败信息
 522    */
 523   protected void sendFailMsg(@Nullable BaseException e) {
 524     if (e != null) {
 525       Bundle b = new Bundle();
 526 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 527       b.putSerializable(IThreadState.KEY_ERROR_INFO, e);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 528       sendState(IThreadState.STATE_FAIL, b);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 529     } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 530       sendState(IThreadState.STATE_FAIL, null);</span>
 531 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 532       ALog.w(TAG, String.format(&quot;任务【%s】重试失败，网络未连接&quot;, getConfig().TEMP_FILE.getName()));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 533     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 534     if (mFailTimes &lt; RETRY_NUM &amp;&amp; needRetry &amp;&amp; (NetUtils.isConnected(AriaManager.APP)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 535         || isNotNetRetry) &amp;&amp; !isBreak()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 536       ALog.d(TAG, String.format(&quot;isCancel: %s, isStop: %s, isBreak: %s&quot;, getState().isCancel,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 537           getState().isStop, taskBreak));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 538       ALog.w(TAG, String.format(&quot;任务【%s】正在重试&quot;, getConfig().TEMP_FILE.getName()));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 539       mFailTimes++;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 540       handleRetryRecord();</span>
 541 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 542       b.putSerializable(ThreadStateManager.KEY_ERROR_INFO, e);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 543       sendState(ThreadStateManager.STATE_FAIL, b);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 544     } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 545       sendState(ThreadStateManager.STATE_FAIL, null);</span>
 546 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 547     }
 548   }
 549 
 550   /**
 551    * 将记录写入到配置文件
 552    *
 553    * @param isComplete 当前线程是否完成 {@code true}完成
 554    * @param record 当前下载进度
 555    */
 556   protected void writeConfig(boolean isComplete, final long record) {
 557     if (mRecord != null) {
 558       mRecord.isComplete = isComplete;
 559       if (mConfig.isBlock) {
 560         mRecord.startLocation = record;
 561       } else if (mConfig.isOpenDynamicFile) {
 562         mRecord.startLocation = mConfig.tempFile.length();
 563       } else {
 564         if (0 &lt; record &amp;&amp; record &lt; mRecord.endLocation) {
 565           mRecord.startLocation = record;
 566         }
 567       }
 568       mRecord.update();
 569     }
 570   }
 571 
 572   @Override public AbsThreadTask call() throws Exception {
 573     isInterrupted = false;
 574     Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
 575     TrafficStats.setThreadStatsTag(UUID.randomUUID().toString().hashCode());
 576     return this;
 577   }
 578 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2016 AriaLyy(https://github.com/AriaLyy/Aria)
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.arialyy.aria.core.common;
  17 
  18 import android.net.TrafficStats;
  19 import android.os.Bundle;
  20 import android.os.Handler;
  21 import android.os.Message;
  22 import android.os.Process;
  23 import android.support.annotation.Nullable;
  24 import com.arialyy.aria.core.AriaManager;
  25 import com.arialyy.aria.core.config.BaseTaskConfig;
  26 import com.arialyy.aria.core.config.DGroupConfig;
  27 import com.arialyy.aria.core.config.DownloadConfig;
  28 import com.arialyy.aria.core.config.UploadConfig;
  29 import com.arialyy.aria.core.inf.AbsNormalEntity;
  30 import com.arialyy.aria.core.inf.AbsTaskWrapper;
  31 import com.arialyy.aria.core.inf.ITaskWrapper;
  32 import com.arialyy.aria.core.manager.ThreadTaskManager;
  33 import com.arialyy.aria.exception.BaseException;
  34 import com.arialyy.aria.util.ALog;
  35 import com.arialyy.aria.util.BufferedRandomAccessFile;
  36 import com.arialyy.aria.util.ErrorHelp;
  37 import com.arialyy.aria.util.NetUtils;
  38 import java.io.File;
  39 import java.util.UUID;
  40 import java.util.concurrent.Callable;
  41 import java.util.concurrent.ExecutorService;
  42 import java.util.concurrent.Executors;
  43 
  44 /**
  45  * Created by lyy on 2017/1/18. 任务线程
  46  */
<abbr title="  47 public abstract class AbsThreadTask&lt;ENTITY extends AbsNormalEntity, TASK_WRAPPER extends AbsTaskWrapper&lt;ENTITY&gt;&gt;">  47 public abstract class AbsThreadTask&lt;ENTITY extends AbsNormalEntity, TASK_WRAPPER extends AbsTaskWrapper&lt;E🔵</abbr>
  48     implements Callable&lt;AbsThreadTask&gt; {
  49   /**
  50    * 线程重试次数
  51    */
  52   private final int RETRY_NUM = 2;
  53 
  54   private final String TAG = &quot;AbsThreadTask&quot;;
  55   /**
  56    * 当前子线程相对于总长度的位置
  57    */
  58   protected long mChildCurrentLocation = 0;
  59   private ENTITY mEntity;
  60   protected TASK_WRAPPER mTaskWrapper;
  61   private int mFailTimes = 0;
  62   private long mLastSaveTime;
  63   private ExecutorService mConfigThreadPool;
  64   private boolean isNotNetRetry;  //断网情况是否重试
  65   private boolean taskBreak = false;  //任务跳出
  66   protected BandwidthLimiter mSpeedBandUtil; //速度限制工具
  67   protected AriaManager mAridManager;
  68   private boolean isInterrupted = false;
  69   protected boolean isCancel = false, isStop = false;
  70   protected ThreadRecord mRecord;
  71   private Handler mStateHandler;
  72   private SubThreadConfig&lt;TASK_WRAPPER&gt; mConfig;
  73 
  74   private Thread mConfigThread = new Thread(new Runnable() {
  75     @Override public void run() {
  76       Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
  77       final long currentTemp = mChildCurrentLocation;
  78       writeConfig(false, currentTemp);
  79     }
  80   });
  81 
  82   protected AbsThreadTask(SubThreadConfig&lt;TASK_WRAPPER&gt; config) {
  83     mConfig = config;
  84     mTaskWrapper = config.taskWrapper;
  85     mRecord = config.record;
  86     mStateHandler = config.stateHandler;
  87     mEntity = mTaskWrapper.getEntity();
  88     mLastSaveTime = System.currentTimeMillis();
  89     mConfigThreadPool = Executors.newCachedThreadPool();
  90     mAridManager = AriaManager.getInstance(AriaManager.APP);
  91     if (getMaxSpeed() &gt; 0) {
  92       mSpeedBandUtil = new BandwidthLimiter(getMaxSpeed(), config.startThreadNum);
  93     }
  94     isNotNetRetry = mAridManager.getAppConfig().isNotNetRetry();
  95     mChildCurrentLocation = mRecord.startLocation;
  96   }
  97 
  98   /**
  99    * 当前线程处理的文件名
 100    */
 101   protected String getFileName() {
 102     return mConfig.tempFile.getName();
 103   }
 104 
 105   protected SubThreadConfig&lt;TASK_WRAPPER&gt; getConfig() {
 106     return mConfig;
 107   }
 108 
 109   /**
 110    * 设置线程是否中断
 111    *
 112    * @param isInterrupted {@code true} 中断
 113    */
 114   public void setInterrupted(boolean isInterrupted) {
 115     this.isInterrupted = isInterrupted;
 116   }
 117 
 118   /**
 119    * 线程是否存活
 120    *
 121    * @return {@code true}存活
 122    */
 123   protected boolean isLive() {
 124     return !Thread.currentThread().isInterrupted() &amp;&amp; !isInterrupted;
 125   }
 126 
 127   /**
 128    * 当前线程是否完成，对于不支持断点的任务，一律未完成 {@code true} 完成；{@code false} 未完成
 129    */
 130   boolean isThreadComplete() {
 131     return mRecord.isComplete;
 132   }
 133 
 134   /**
 135    * 获取实体
 136    */
 137   protected ENTITY getEntity() {
 138     return mEntity;
 139   }
 140 
 141   /**
 142    * 获取任务驱动对象
 143    */
 144   protected TASK_WRAPPER getTaskWrapper() {
 145     return mTaskWrapper;
 146   }
 147 
 148   /**
 149    * 获取配置的最大上传/下载速度
 150    *
 151    * @return 单位为：kb
 152    */
 153   public abstract int getMaxSpeed();
 154 
 155   /**
 156    * 读取任务配置
 157    *
 158    * @return {@link DownloadConfig}、{@link UploadConfig}、{@link DGroupConfig}
 159    */
 160   protected abstract BaseTaskConfig getTaskConfig();
 161 
 162   /**
 163    * 设置最大下载速度
 164    *
 165    * @param speed 单位为：kb
 166    */
 167   public void setMaxSpeed(int speed) {
 168     if (mSpeedBandUtil != null) {
 169       mSpeedBandUtil.setMaxRate(speed / mConfig.startThreadNum);
 170     }
 171   }
 172 
 173   /**
 174    * 中断任务
 175    */
 176   void breakTask() {
 177     synchronized (AriaManager.LOCK) {
 178       taskBreak = true;
 179       if (mTaskWrapper.isSupportBP()) {
 180         final long currentTemp = mChildCurrentLocation;
 181 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 182         sendState(IThreadState.STATE_STOP, null);</span>
 183 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 184         getState().STOP_NUM++;</span>
 185 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 186         sendState(ThreadStateManager.STATE_STOP, null);</span>
 187 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 188         ALog.d(TAG, String.format(&quot;任务【%s】thread__%s__中断【停止位置：%s】&quot;, getFileName(),
 189             mRecord.threadId, currentTemp));
 190         writeConfig(false, currentTemp);
 191       } else {
 192         ALog.i(TAG, String.format(&quot;任务【%s】已中断&quot;, getFileName()));
 193       }
 194     }
 195   }
 196 
 197   /**
 198    * 发送状态给状态处理器
 199    *
 200 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 201    * @param state {@link IThreadState#STATE_STOP}..</span>
 202 ||||||| BASE
 203 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 204    * @param state {@link ThreadStateManager#STATE_STOP}..</span>
 205 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 206    * @param bundle 而外数据
 207    */
 208   void sendState(int state, @Nullable Bundle bundle) {
 209     Message msg = mStateHandler.obtainMessage();
 210     msg.what = state;
 211     if (bundle != null) {
 212       msg.setData(bundle);
 213     }
 214     msg.sendToTarget();
 215   }
 216 
 217   public boolean isInterrupted() {
 218     return Thread.currentThread().isInterrupted();
 219   }
 220 
 221   @Override protected void finalize() throws Throwable {
 222     super.finalize();
 223     if (mConfigThreadPool != null) {
 224       mConfigThreadPool.shutdown();
 225     }
 226   }
 227 
 228   /**
 229    * 任务是否中断，中断条件： 1、任务取消 2、任务停止 3、手动中断 {@link #taskBreak}
 230    *
 231    * @return {@code true} 中断，{@code false} 不是中断
 232    */
 233   protected boolean isBreak() {
 234     return isCancel || isStop || taskBreak;
 235   }
 236 
 237   /**
 238    * 检查下载完成的分块大小，如果下载完成的分块大小大于或小于分配的大小，则需要重新下载该分块 如果是非分块任务，直接返回{@code true}
 239    *
 240    * @return {@code true} 分块分大小正常，{@code false} 分块大小错误
 241    */
 242   protected boolean checkBlock() {
 243     if (!mConfig.isBlock) {
 244       return true;
 245     }
 246     File blockFile = mConfig.tempFile;
 247     if (!blockFile.exists() || blockFile.length() != mRecord.blockLen) {
 248       ALog.i(TAG,
 249           String.format(&quot;分块【%s】错误，blockFileLen: %s, threadRect: %s; 即将重新下载该分块，开始位置：%s，结束位置：%s&quot;,
 250               blockFile.getName(), blockFile.length(), mRecord.blockLen, mRecord.startLocation,
 251               mRecord.endLocation));
 252       if (blockFile.exists()) {
 253         blockFile.delete();
 254         ALog.i(TAG, String.format(&quot;删除分块【%s】成功&quot;, blockFile.getName()));
 255       }
 256       retryThis(isBreak());
 257       return false;
 258     }
 259     return true;
 260   }
 261 
 262   /**
 263    * 停止任务
 264    */
 265   public void stop() {
 266     synchronized (AriaManager.LOCK) {
 267       isStop = true;
 268       if (mTaskWrapper.isSupportBP()) {
 269         final long stopLocation = mChildCurrentLocation;
 270 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 271         sendState(IThreadState.STATE_STOP, null);</span>
 272 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 273           File blockFile = getBockFile();</span>
 274 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 275         sendState(ThreadStateManager.STATE_STOP, null);</span>
 276 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 277         ALog.d(TAG,
 278             String.format(&quot;任务【%s】thread__%s__停止【当前线程停止位置：%s】&quot;, getFileName(),
 279                 mRecord.threadId, stopLocation));
 280         writeConfig(false, stopLocation);
 281       } else {
 282         ALog.i(TAG, String.format(&quot;任务【%s】已停止&quot;, getFileName()));
 283 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 284         sendState(IThreadState.STATE_STOP, null);</span>
 285 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 286         }</span>
 287 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 288         sendState(ThreadStateManager.STATE_STOP, null);</span>
 289 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 290       }
 291     }
 292   }
 293 
 294   /**
 295    * 执行中
 296    */
 297   protected void progress(long len) {
 298     synchronized (AriaManager.LOCK) {
 299       //if (getState().CURRENT_LOCATION &gt; getEntity().getFileSize() &amp;&amp; !getTaskWrapper().asHttp()
 300       //    .isChunked()) {
 301       //  String errorMsg =
 302       //      String.format(&quot;下载失败，下载长度超出文件真实长度；currentLocation=%s, fileSize=%s&quot;,
 303       //          getState().CURRENT_LOCATION,
 304       //          getEntity().getFileSize());
 305       //  taskBreak = true;
 306       //  fail(mChildCurrentLocation, new FileException(TAG, errorMsg), false);
 307       //  return;
 308       //}
 309       mChildCurrentLocation += len;
 310       if (!mStateHandler.getLooper().getThread().isAlive()) {
 311         return;
 312       }
 313 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 314       mStateHandler.obtainMessage(IThreadState.STATE_RUNNING, len).sendToTarget();</span>
 315 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 316         mLastSaveTime = System.currentTimeMillis();</span>
 317 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 318       mStateHandler.obtainMessage(ThreadStateManager.STATE_RUNNING, len).sendToTarget();</span>
 319 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 320       if (System.currentTimeMillis() - mLastSaveTime &gt; 5000
 321           &amp;&amp; mChildCurrentLocation &lt; mRecord.endLocation) {
 322         mLastSaveTime = System.currentTimeMillis();
 323         if (!mConfigThreadPool.isShutdown()) {
 324           mConfigThreadPool.execute(mConfigThread);
 325         }
 326       }
 327     }
 328   }
 329 
 330   /**
 331    * 取消任务
 332    */
 333   public void cancel() {
 334     synchronized (AriaManager.LOCK) {
 335       isCancel = true;
 336 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 337       sendState(IThreadState.STATE_CANCEL, null);</span>
 338 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 339         getState().CANCEL_NUM++;</span>
 340 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 341       sendState(ThreadStateManager.STATE_CANCEL, null);</span>
 342 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 343         ALog.d(TAG,
 344           String.format(&quot;任务【%s】thread__%s__取消&quot;, getFileName(), mRecord.threadId));
 345     }
 346   }
 347 
 348   /**
 349    * 线程任务失败
 350    *
 351    * @param subCurrentLocation 当前线程下载进度
 352    * @param ex 异常信息
 353    */
 354   protected void fail(final long subCurrentLocation, BaseException ex) {
 355     fail(subCurrentLocation, ex, true);
 356   }
 357 
 358   /**
 359    * 任务失败
 360    *
 361    * @param subCurrentLocation 当前子线程进度
 362    */
 363   protected void fail(final long subCurrentLocation, BaseException ex, boolean needRetry) {
 364     if (ex != null) {
 365       ALog.e(TAG, ALog.getExceptionString(ex));
 366     }
 367 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 368     if (mTaskWrapper.getRequestType() == ITaskWrapper.M3U8_FILE) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 369       writeConfig(false, 0);</span>
 370 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 371     if (getConfig().SUPPORT_BP) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 372       writeConfig(false, subCurrentLocation);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 373       retryThis(needRetry &amp;&amp; getState().START_THREAD_NUM != 1);</span>
 374 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 375     if (mTaskWrapper.isSupportBP()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 376       writeConfig(false, subCurrentLocation);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 377       retryThis(needRetry &amp;&amp; mConfig.startThreadNum != 1);</span>
 378 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 379     } else {
 380 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 381       if (mTaskWrapper.isSupportBP()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 382         writeConfig(false, subCurrentLocation);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 383         retryThis(needRetry &amp;&amp; mConfig.startThreadNum != 1);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 384       } else {</span>
 385 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 386     } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 387       ALog.e(TAG, String.format(&quot;任务【%s】执行失败&quot;, getConfig().TEMP_FILE.getName()));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 388       ErrorHelp.saveError(TAG, &quot;&quot;, ALog.getExceptionString(ex));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 389       handleFailState(!isBreak());</span>
 390 =======
 391 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 392         ALog.e(TAG, String.format(&quot;任务【%s】执行失败&quot;, getFileName()));
 393       ErrorHelp.saveError(TAG, &quot;&quot;, ALog.getExceptionString(ex));
 394         sendFailMsg(null);
 395 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 396       }</span>
 397 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 398     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 399   }</span>
 400 =======
 401 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 402     }
 403   }
 404 
 405   /**
 406    * 重试当前线程，如果其中一条线程已经下载失败，则任务该任务下载失败，并且停止该任务的所有线程
 407    *
 408    * @param needRetry 是否可以重试
 409    */
 410   private void retryThis(boolean needRetry) {
 411     if (!NetUtils.isConnected(AriaManager.APP) &amp;&amp; !isNotNetRetry) {
 412       ALog.w(TAG, String.format(&quot;任务【%s】重试失败，网络未连接&quot;, getFileName()));
 413     }
 414     if (mFailTimes &lt; RETRY_NUM &amp;&amp; needRetry &amp;&amp; (NetUtils.isConnected(AriaManager.APP)
 415         || isNotNetRetry) &amp;&amp; !isBreak()) {
 416       ALog.w(TAG, String.format(&quot;任务【%s】正在重试&quot;, getFileName()));
 417       mFailTimes++;
 418       handleRetryRecord();
 419       ThreadTaskManager.getInstance().retryThread(AbsThreadTask.this);
 420     } else {
 421       sendFailMsg(null);
 422     }
 423   }
 424 
 425   /**
 426    * 处理线程重试的记录，只有多线程任务才会执行
 427    * 如果是以前版本{@link BufferedRandomAccessFile}创建的下载，那么 record.startLocation不用修改
 428    */
 429   private void handleRetryRecord() {
 430     if (mConfig.isBlock) {
 431       // 默认线程分块长度
 432       File temp = mConfig.tempFile;
 433 
 434       long blockFileLen = temp.length(); // 磁盘中的分块文件长度
 435       long threadRect = mRecord.blockLen;     // 当前线程的区间
 436 
 437       if (!temp.exists()) {
 438         ALog.i(TAG, String.format(&quot;分块文件【%s】不存在，该分块将重新开始&quot;, temp.getName()));
 439         mRecord.isComplete = false;
 440         mRecord.startLocation = mRecord.endLocation - threadRect;
 441       } else {
 442         /*
 443          * 检查磁盘中的分块文件
 444          */
 445         if (blockFileLen &gt; threadRect) {
 446           ALog.i(TAG, String.format(&quot;分块【%s】错误，将重新下载该分块&quot;, temp.getName()));
 447           temp.delete();
 448           mRecord.startLocation = mRecord.endLocation - mRecord.blockLen;
 449           mRecord.isComplete = false;
 450         } else if (blockFileLen &lt; mRecord.blockLen) {
 451           mRecord.startLocation = mRecord.endLocation - mRecord.blockLen + blockFileLen;
 452           mRecord.isComplete = false;
 453 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 454           sendState(IThreadState.STATE_UPDATE_PROGRESS, null);</span>
 455 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 456         } else if (blockFileLen &lt; tr.blockLen) {</span>
 457 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 458           sendState(ThreadStateManager.STATE_UPDATE_PROGRESS, null);</span>
 459 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 460           ALog.i(TAG,
 461 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 462               String.format(&quot;修正分块【%s】记录，开始位置：%s，结束位置：%s&quot;, temp.getName(), mRecord.startLocation,</span>
 463 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 464           tr.isComplete = false;</span>
 465 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 466               String.format(&quot;修正分块【%s】，开始位置：%s，结束位置：%s&quot;, temp.getName(), mRecord.startLocation,</span>
 467 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 468                   mRecord.endLocation));
 469         } else {
 470           ALog.i(TAG, String.format(&quot;分块【%s】已完成，更新记录&quot;, temp.getName()));
 471           mRecord.isComplete = true;
 472         }
 473       }
 474       mRecord.update();
 475     }
 476   }
 477 
 478   /**
 479    * 发送任务完成的消息，并删除任务记录
 480    */
 481   protected synchronized void sendCompleteMsg() {
 482     ALog.i(TAG, String.format(&quot;任务【%s】完成&quot;, getFileName()));
 483 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 484     sendState(IThreadState.STATE_COMPLETE, null);</span>
 485 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 486     CommonUtil.delTaskRecord(mEntity.getKey(), mEntity instanceof DownloadEntity ? 1 : 2, false,</span>
 487 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 488     sendState(ThreadStateManager.STATE_COMPLETE, null);</span>
 489 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 490   }
 491 
 492   /**
 493    * 发送失败信息
 494    */
 495   protected void sendFailMsg(@Nullable BaseException e) {
 496     if (e != null) {
 497       Bundle b = new Bundle();
 498 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 499       b.putSerializable(IThreadState.KEY_ERROR_INFO, e);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 500       sendState(IThreadState.STATE_FAIL, b);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 501     } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 502       sendState(IThreadState.STATE_FAIL, null);</span>
 503 ||||||| BASE
 504 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 505       b.putSerializable(ThreadStateManager.KEY_ERROR_INFO, e);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 506       sendState(ThreadStateManager.STATE_FAIL, b);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 507     } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 508       sendState(ThreadStateManager.STATE_FAIL, null);</span>
 509 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 510     }
 511   }
 512 
 513   /**
 514    * 将记录写入到配置文件
 515    *
 516    * @param isComplete 当前线程是否完成 {@code true}完成
 517    * @param record 当前下载进度
 518    */
 519   protected void writeConfig(boolean isComplete, final long record) {
 520     if (mRecord != null) {
 521       mRecord.isComplete = isComplete;
 522       if (mConfig.isBlock) {
 523         mRecord.startLocation = record;
 524       } else if (mConfig.isOpenDynamicFile) {
 525         mRecord.startLocation = mConfig.tempFile.length();
 526       } else {
 527         if (0 &lt; record &amp;&amp; record &lt; mRecord.endLocation) {
 528           mRecord.startLocation = record;
 529         }
 530       }
 531       mRecord.update();
 532     }
 533   }
 534 
 535   @Override public AbsThreadTask call() throws Exception {
 536     isInterrupted = false;
 537     Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
 538     TrafficStats.setThreadStatsTag(UUID.randomUUID().toString().hashCode());
 539     return this;
 540   }
 541 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2016 AriaLyy(https://github.com/AriaLyy/Aria)
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.arialyy.aria.core.common;
  17 
  18 import android.net.TrafficStats;
  19 import android.os.Bundle;
  20 import android.os.Handler;
  21 import android.os.Message;
  22 import android.os.Process;
  23 import android.support.annotation.Nullable;
  24 import com.arialyy.aria.core.AriaManager;
  25 import com.arialyy.aria.core.config.BaseTaskConfig;
  26 import com.arialyy.aria.core.config.DGroupConfig;
  27 import com.arialyy.aria.core.config.DownloadConfig;
  28 import com.arialyy.aria.core.config.UploadConfig;
  29 import com.arialyy.aria.core.inf.AbsNormalEntity;
  30 import com.arialyy.aria.core.inf.AbsTaskWrapper;
  31 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  32 import com.arialyy.aria.core.inf.ITaskWrapper;</span>
  33 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="  34 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/">  34 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
  35 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  36 </span>
  37 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
  38 import com.arialyy.aria.core.manager.ThreadTaskManager;
  39 import com.arialyy.aria.exception.BaseException;
  40 import com.arialyy.aria.util.ALog;
  41 import com.arialyy.aria.util.BufferedRandomAccessFile;
  42 import com.arialyy.aria.util.ErrorHelp;
  43 import com.arialyy.aria.util.NetUtils;
  44 import java.io.File;
  45 import java.util.UUID;
  46 import java.util.concurrent.Callable;
  47 import java.util.concurrent.ExecutorService;
  48 import java.util.concurrent.Executors;
  49 
  50 /**
  51  * Created by lyy on 2017/1/18. 任务线程
  52  */
<abbr title="  53 public abstract class AbsThreadTask&lt;ENTITY extends AbsNormalEntity, TASK_WRAPPER extends AbsTaskWrapper&lt;ENTITY&gt;&gt;">  53 public abstract class AbsThreadTask&lt;ENTITY extends AbsNormalEntity, TASK_WRAPPER extends AbsTaskWrapper&lt;E🔵</abbr>
  54     implements Callable&lt;AbsThreadTask&gt; {
  55   /**
  56    * 线程重试次数
  57    */
  58   private final int RETRY_NUM = 2;
  59 
  60   private final String TAG = &quot;AbsThreadTask&quot;;
  61   /**
  62    * 当前子线程相对于总长度的位置
  63    */
  64   protected long mChildCurrentLocation = 0;
  65   private ENTITY mEntity;
  66   protected TASK_WRAPPER mTaskWrapper;
  67   private int mFailTimes = 0;
  68   private long mLastSaveTime;
  69   private ExecutorService mConfigThreadPool;
  70   private boolean isNotNetRetry;  //断网情况是否重试
  71   private boolean taskBreak = false;  //任务跳出
  72   protected BandwidthLimiter mSpeedBandUtil; //速度限制工具
  73   protected AriaManager mAridManager;
  74   private boolean isInterrupted = false;
  75   protected boolean isCancel = false, isStop = false;
  76   protected ThreadRecord mRecord;
  77   private Handler mStateHandler;
  78   private SubThreadConfig&lt;TASK_WRAPPER&gt; mConfig;
  79 
  80   private Thread mConfigThread = new Thread(new Runnable() {
  81     @Override public void run() {
  82       Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
  83       final long currentTemp = mChildCurrentLocation;
  84       writeConfig(false, currentTemp);
  85     }
  86   });
  87 
  88   protected AbsThreadTask(SubThreadConfig&lt;TASK_WRAPPER&gt; config) {
  89     mConfig = config;
  90     mTaskWrapper = config.taskWrapper;
  91     mRecord = config.record;
  92     mStateHandler = config.stateHandler;
  93     mEntity = mTaskWrapper.getEntity();
  94     mLastSaveTime = System.currentTimeMillis();
  95     mConfigThreadPool = Executors.newCachedThreadPool();
  96     mAridManager = AriaManager.getInstance(AriaManager.APP);
  97     if (getMaxSpeed() &gt; 0) {
  98       mSpeedBandUtil = new BandwidthLimiter(getMaxSpeed(), config.startThreadNum);
  99     }
 100     isNotNetRetry = mAridManager.getAppConfig().isNotNetRetry();
 101     mChildCurrentLocation = mRecord.startLocation;
 102   }
 103 
 104   /**
 105    * 当前线程处理的文件名
 106    */
 107   protected String getFileName() {
 108     return mConfig.tempFile.getName();
 109   }
 110 
 111   protected SubThreadConfig&lt;TASK_WRAPPER&gt; getConfig() {
 112     return mConfig;
 113   }
 114 
 115   /**
 116    * 设置线程是否中断
 117    *
 118    * @param isInterrupted {@code true} 中断
 119    */
 120   public void setInterrupted(boolean isInterrupted) {
 121     this.isInterrupted = isInterrupted;
 122   }
 123 
 124   /**
 125    * 线程是否存活
 126    *
 127    * @return {@code true}存活
 128    */
 129   protected boolean isLive() {
 130     return !Thread.currentThread().isInterrupted() &amp;&amp; !isInterrupted;
 131   }
 132 
 133   /**
 134    * 当前线程是否完成，对于不支持断点的任务，一律未完成 {@code true} 完成；{@code false} 未完成
 135    */
 136   boolean isThreadComplete() {
 137     return mRecord.isComplete;
 138   }
 139 
 140   /**
 141    * 获取实体
 142    */
 143   protected ENTITY getEntity() {
 144     return mEntity;
 145   }
 146 
 147   /**
 148    * 获取任务驱动对象
 149    */
 150   protected TASK_WRAPPER getTaskWrapper() {
 151     return mTaskWrapper;
 152   }
 153 
 154   /**
 155    * 获取配置的最大上传/下载速度
 156    *
 157    * @return 单位为：kb
 158    */
 159   public abstract int getMaxSpeed();
 160 
 161   /**
 162    * 读取任务配置
 163    *
 164    * @return {@link DownloadConfig}、{@link UploadConfig}、{@link DGroupConfig}
 165    */
 166   protected abstract BaseTaskConfig getTaskConfig();
 167 
 168   /**
 169    * 设置最大下载速度
 170    *
 171    * @param speed 单位为：kb
 172    */
 173   public void setMaxSpeed(int speed) {
 174     if (mSpeedBandUtil != null) {
 175       mSpeedBandUtil.setMaxRate(speed / mConfig.startThreadNum);
 176     }
 177   }
 178 
 179   /**
 180    * 中断任务
 181    */
 182   void breakTask() {
 183     synchronized (AriaManager.LOCK) {
 184       taskBreak = true;
 185       if (mTaskWrapper.isSupportBP()) {
 186         final long currentTemp = mChildCurrentLocation;
 187 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 188         sendState(IThreadState.STATE_STOP, null);</span>
 189 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 190 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 190 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
 191 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 192 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 193         sendState(ThreadStateManager.STATE_STOP, null);</span>
 194 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 195         ALog.d(TAG, String.format(&quot;任务【%s】thread__%s__中断【停止位置：%s】&quot;, getFileName(),
 196             mRecord.threadId, currentTemp));
 197         writeConfig(false, currentTemp);
 198       } else {
 199         ALog.i(TAG, String.format(&quot;任务【%s】已中断&quot;, getFileName()));
 200       }
 201     }
 202   }
 203 
 204   /**
 205    * 发送状态给状态处理器
 206    *
 207 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 208    * @param state {@link IThreadState#STATE_STOP}..</span>
 209 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 210 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 210 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
 211 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 212 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 213    * @param state {@link ThreadStateManager#STATE_STOP}..</span>
 214 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 215    * @param bundle 而外数据
 216    */
 217   void sendState(int state, @Nullable Bundle bundle) {
 218     Message msg = mStateHandler.obtainMessage();
 219     msg.what = state;
 220     if (bundle != null) {
 221       msg.setData(bundle);
 222     }
 223     msg.sendToTarget();
 224   }
 225 
 226   public boolean isInterrupted() {
 227     return Thread.currentThread().isInterrupted();
 228   }
 229 
 230   @Override protected void finalize() throws Throwable {
 231     super.finalize();
 232     if (mConfigThreadPool != null) {
 233       mConfigThreadPool.shutdown();
 234     }
 235   }
 236 
 237   /**
 238    * 任务是否中断，中断条件： 1、任务取消 2、任务停止 3、手动中断 {@link #taskBreak}
 239    *
 240    * @return {@code true} 中断，{@code false} 不是中断
 241    */
 242   protected boolean isBreak() {
 243     return isCancel || isStop || taskBreak;
 244   }
 245 
 246   /**
 247    * 检查下载完成的分块大小，如果下载完成的分块大小大于或小于分配的大小，则需要重新下载该分块 如果是非分块任务，直接返回{@code true}
 248    *
 249    * @return {@code true} 分块分大小正常，{@code false} 分块大小错误
 250    */
 251   protected boolean checkBlock() {
 252     if (!mConfig.isBlock) {
 253       return true;
 254     }
 255     File blockFile = mConfig.tempFile;
 256     if (!blockFile.exists() || blockFile.length() != mRecord.blockLen) {
 257       ALog.i(TAG,
 258           String.format(&quot;分块【%s】错误，blockFileLen: %s, threadRect: %s; 即将重新下载该分块，开始位置：%s，结束位置：%s&quot;,
 259               blockFile.getName(), blockFile.length(), mRecord.blockLen, mRecord.startLocation,
 260               mRecord.endLocation));
 261       if (blockFile.exists()) {
 262         blockFile.delete();
 263         ALog.i(TAG, String.format(&quot;删除分块【%s】成功&quot;, blockFile.getName()));
 264       }
 265       retryThis(isBreak());
 266       return false;
 267     }
 268     return true;
 269   }
 270 
 271   /**
 272    * 停止任务
 273    */
 274   public void stop() {
 275     synchronized (AriaManager.LOCK) {
 276       isStop = true;
 277       if (mTaskWrapper.isSupportBP()) {
 278         final long stopLocation = mChildCurrentLocation;
 279 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 280         sendState(IThreadState.STATE_STOP, null);</span>
 281 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 282 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 282 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
 283 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 284 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 285         sendState(ThreadStateManager.STATE_STOP, null);</span>
 286 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 287         ALog.d(TAG,
 288             String.format(&quot;任务【%s】thread__%s__停止【当前线程停止位置：%s】&quot;, getFileName(),
 289                 mRecord.threadId, stopLocation));
 290         writeConfig(false, stopLocation);
 291       } else {
 292         ALog.i(TAG, String.format(&quot;任务【%s】已停止&quot;, getFileName()));
 293 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 294         sendState(IThreadState.STATE_STOP, null);</span>
 295 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 296 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 296 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
 297 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 298 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 299         sendState(ThreadStateManager.STATE_STOP, null);</span>
 300 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 301       }
 302     }
 303   }
 304 
 305   /**
 306    * 执行中
 307    */
 308   protected void progress(long len) {
 309     synchronized (AriaManager.LOCK) {
 310       //if (getState().CURRENT_LOCATION &gt; getEntity().getFileSize() &amp;&amp; !getTaskWrapper().asHttp()
 311       //    .isChunked()) {
 312       //  String errorMsg =
 313       //      String.format(&quot;下载失败，下载长度超出文件真实长度；currentLocation=%s, fileSize=%s&quot;,
 314       //          getState().CURRENT_LOCATION,
 315       //          getEntity().getFileSize());
 316       //  taskBreak = true;
 317       //  fail(mChildCurrentLocation, new FileException(TAG, errorMsg), false);
 318       //  return;
 319       //}
 320       mChildCurrentLocation += len;
 321       if (!mStateHandler.getLooper().getThread().isAlive()) {
 322         return;
 323       }
 324 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 325       mStateHandler.obtainMessage(IThreadState.STATE_RUNNING, len).sendToTarget();</span>
 326 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 327 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 327 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
 328 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 329 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 330       mStateHandler.obtainMessage(ThreadStateManager.STATE_RUNNING, len).sendToTarget();</span>
 331 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 332       if (System.currentTimeMillis() - mLastSaveTime &gt; 5000
 333           &amp;&amp; mChildCurrentLocation &lt; mRecord.endLocation) {
 334         mLastSaveTime = System.currentTimeMillis();
 335         if (!mConfigThreadPool.isShutdown()) {
 336           mConfigThreadPool.execute(mConfigThread);
 337         }
 338       }
 339     }
 340   }
 341 
 342   /**
 343    * 取消任务
 344    */
 345   public void cancel() {
 346     synchronized (AriaManager.LOCK) {
 347       isCancel = true;
 348 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 349       sendState(IThreadState.STATE_CANCEL, null);</span>
 350 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 351 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 351 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
 352 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 353 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 354       sendState(ThreadStateManager.STATE_CANCEL, null);</span>
 355 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 356       ALog.d(TAG,
 357           String.format(&quot;任务【%s】thread__%s__取消&quot;, getFileName(), mRecord.threadId));
 358     }
 359   }
 360 
 361   /**
 362    * 线程任务失败
 363    *
 364    * @param subCurrentLocation 当前线程下载进度
 365    * @param ex 异常信息
 366    */
 367   protected void fail(final long subCurrentLocation, BaseException ex) {
 368     fail(subCurrentLocation, ex, true);
 369   }
 370 
 371   /**
 372    * 任务失败
 373    *
 374    * @param subCurrentLocation 当前子线程进度
 375    */
 376   protected void fail(final long subCurrentLocation, BaseException ex, boolean needRetry) {
 377     if (ex != null) {
 378       ALog.e(TAG, ALog.getExceptionString(ex));
 379     }
 380 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 381     if (mTaskWrapper.getRequestType() == ITaskWrapper.M3U8_FILE) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 382       writeConfig(false, 0);</span>
 383 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 384 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 384 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
 385 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 386 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 387     if (mTaskWrapper.isSupportBP()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 388       writeConfig(false, subCurrentLocation);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 389       retryThis(needRetry &amp;&amp; mConfig.startThreadNum != 1);</span>
 390 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 391     } else {
 392 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 393       if (mTaskWrapper.isSupportBP()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 394         writeConfig(false, subCurrentLocation);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 395         retryThis(needRetry &amp;&amp; mConfig.startThreadNum != 1);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 396       } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 397         ALog.e(TAG, String.format(&quot;任务【%s】执行失败&quot;, getFileName()));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 398         ErrorHelp.saveError(TAG, &quot;&quot;, ALog.getExceptionString(ex));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 399         sendFailMsg(null);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 400       }</span>
 401 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 402 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 402 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
 403 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 404 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 405       ALog.e(TAG, String.format(&quot;任务【%s】执行失败&quot;, getFileName()));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 406       ErrorHelp.saveError(TAG, &quot;&quot;, ALog.getExceptionString(ex));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 407       sendFailMsg(null);</span>
 408 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 409     }
 410   }
 411 
 412   /**
 413    * 重试当前线程，如果其中一条线程已经下载失败，则任务该任务下载失败，并且停止该任务的所有线程
 414    *
 415    * @param needRetry 是否可以重试
 416    */
 417   private void retryThis(boolean needRetry) {
 418     if (!NetUtils.isConnected(AriaManager.APP) &amp;&amp; !isNotNetRetry) {
 419       ALog.w(TAG, String.format(&quot;任务【%s】重试失败，网络未连接&quot;, getFileName()));
 420     }
 421     if (mFailTimes &lt; RETRY_NUM &amp;&amp; needRetry &amp;&amp; (NetUtils.isConnected(AriaManager.APP)
 422         || isNotNetRetry) &amp;&amp; !isBreak()) {
 423       ALog.w(TAG, String.format(&quot;任务【%s】正在重试&quot;, getFileName()));
 424       mFailTimes++;
 425       handleRetryRecord();
 426       ThreadTaskManager.getInstance().retryThread(AbsThreadTask.this);
 427     } else {
 428       sendFailMsg(null);
 429     }
 430   }
 431 
 432   /**
 433    * 处理线程重试的记录，只有多线程任务才会执行
 434    * 如果是以前版本{@link BufferedRandomAccessFile}创建的下载，那么 record.startLocation不用修改
 435    */
 436   private void handleRetryRecord() {
 437     if (mConfig.isBlock) {
 438       // 默认线程分块长度
 439       File temp = mConfig.tempFile;
 440 
 441       long blockFileLen = temp.length(); // 磁盘中的分块文件长度
 442       long threadRect = mRecord.blockLen;     // 当前线程的区间
 443 
 444       if (!temp.exists()) {
 445         ALog.i(TAG, String.format(&quot;分块文件【%s】不存在，该分块将重新开始&quot;, temp.getName()));
 446         mRecord.isComplete = false;
 447         mRecord.startLocation = mRecord.endLocation - threadRect;
 448       } else {
 449         /*
 450          * 检查磁盘中的分块文件
 451          */
 452         if (blockFileLen &gt; threadRect) {
 453           ALog.i(TAG, String.format(&quot;分块【%s】错误，将重新下载该分块&quot;, temp.getName()));
 454           temp.delete();
 455           mRecord.startLocation = mRecord.endLocation - mRecord.blockLen;
 456           mRecord.isComplete = false;
 457         } else if (blockFileLen &lt; mRecord.blockLen) {
 458           mRecord.startLocation = mRecord.endLocation - mRecord.blockLen + blockFileLen;
 459           mRecord.isComplete = false;
 460 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 461           sendState(IThreadState.STATE_UPDATE_PROGRESS, null);</span>
 462 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 463 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 463 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
 464 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 465 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 466           sendState(ThreadStateManager.STATE_UPDATE_PROGRESS, null);</span>
 467 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 468           ALog.i(TAG,
 469 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 470               String.format(&quot;修正分块【%s】记录，开始位置：%s，结束位置：%s&quot;, temp.getName(), mRecord.startLocation,</span>
 471 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 472 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 472 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
 473 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 474 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 475               String.format(&quot;修正分块【%s】，开始位置：%s，结束位置：%s&quot;, temp.getName(), mRecord.startLocation,</span>
 476 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 477                   mRecord.endLocation));
 478         } else {
 479           ALog.i(TAG, String.format(&quot;分块【%s】已完成，更新记录&quot;, temp.getName()));
 480           mRecord.isComplete = true;
 481         }
 482       }
 483       mRecord.update();
 484     }
 485   }
 486 
 487   /**
 488    * 发送任务完成的消息，并删除任务记录
 489    */
 490   protected synchronized void sendCompleteMsg() {
 491     ALog.i(TAG, String.format(&quot;任务【%s】完成&quot;, getFileName()));
 492 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 493     sendState(IThreadState.STATE_COMPLETE, null);</span>
 494 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 495 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 495 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
 496 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 497 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 498     sendState(ThreadStateManager.STATE_COMPLETE, null);</span>
 499 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 500   }
 501 
 502   /**
 503    * 发送失败信息
 504    */
 505   protected void sendFailMsg(@Nullable BaseException e) {
 506     if (e != null) {
 507       Bundle b = new Bundle();
 508 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 509       b.putSerializable(IThreadState.KEY_ERROR_INFO, e);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 510       sendState(IThreadState.STATE_FAIL, b);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 511     } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 512       sendState(IThreadState.STATE_FAIL, null);</span>
 513 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 514 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 514 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
 515 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 516 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 517       b.putSerializable(ThreadStateManager.KEY_ERROR_INFO, e);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 518       sendState(ThreadStateManager.STATE_FAIL, b);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 519     } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 520       sendState(ThreadStateManager.STATE_FAIL, null);</span>
 521 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 522     }
 523   }
 524 
 525   /**
 526    * 将记录写入到配置文件
 527    *
 528    * @param isComplete 当前线程是否完成 {@code true}完成
 529    * @param record 当前下载进度
 530    */
 531   protected void writeConfig(boolean isComplete, final long record) {
 532     if (mRecord != null) {
 533       mRecord.isComplete = isComplete;
 534       if (mConfig.isBlock) {
 535         mRecord.startLocation = record;
 536       } else if (mConfig.isOpenDynamicFile) {
 537         mRecord.startLocation = mConfig.tempFile.length();
 538       } else {
 539         if (0 &lt; record &amp;&amp; record &lt; mRecord.endLocation) {
 540           mRecord.startLocation = record;
 541         }
 542       }
 543       mRecord.update();
 544     }
 545   }
 546 
 547   @Override public AbsThreadTask call() throws Exception {
 548     isInterrupted = false;
 549     Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
 550     TrafficStats.setThreadStatsTag(UUID.randomUUID().toString().hashCode());
 551     return this;
 552   }
 553 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2016 AriaLyy(https://github.com/AriaLyy/Aria)
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  package com.arialyy.aria.core.common;
  17  
  18  import android.net.TrafficStats;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  19 +import android.os.Bundle;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  20 +import android.os.Handler;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  21 +import android.os.Message;</span>
  22  import android.os.Process;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  23 +import android.support.annotation.Nullable;</span>
  24  import com.arialyy.aria.core.AriaManager;
  25  import com.arialyy.aria.core.config.BaseTaskConfig;
  26  import com.arialyy.aria.core.config.DGroupConfig;
  27  import com.arialyy.aria.core.config.DownloadConfig;
  28  import com.arialyy.aria.core.config.UploadConfig;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  29 -import com.arialyy.aria.core.download.DownloadEntity;</span>
  30  import com.arialyy.aria.core.inf.AbsNormalEntity;
  31  import com.arialyy.aria.core.inf.AbsTaskWrapper;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  32 -import com.arialyy.aria.core.inf.IEventListener;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  33 +import com.arialyy.aria.core.inf.ITaskWrapper;</span>
  34  import com.arialyy.aria.core.manager.ThreadTaskManager;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  35 -import com.arialyy.aria.core.upload.UploadEntity;</span>
  36  import com.arialyy.aria.exception.BaseException;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  37 -import com.arialyy.aria.exception.FileException;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  38 -import com.arialyy.aria.exception.TaskException;</span>
  39  import com.arialyy.aria.util.ALog;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  40 -import com.arialyy.aria.util.CommonUtil;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  41 +import com.arialyy.aria.util.BufferedRandomAccessFile;</span>
  42  import com.arialyy.aria.util.ErrorHelp;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  43 -import com.arialyy.aria.util.FileUtil;</span>
  44  import com.arialyy.aria.util.NetUtils;
  45  import java.io.File;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  46 -import java.util.ArrayList;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  47 -import java.util.List;</span>
  48  import java.util.UUID;
  49  import java.util.concurrent.Callable;
  50  import java.util.concurrent.ExecutorService;
  51  import java.util.concurrent.Executors;
  52  
  53  /**
  54   * Created by lyy on 2017/1/18. 任务线程
  55   */
  56  public abstract class AbsThreadTask&lt;ENTITY extends AbsNormalEntity, TASK_WRAPPER extends AbsTaskWrapper&lt;ENTITY&gt;&gt;
  57      implements Callable&lt;AbsThreadTask&gt; {
  58    /**
  59     * 线程重试次数
  60     */
  61    private final int RETRY_NUM = 2;
  62  
  63    private final String TAG = &quot;AbsThreadTask&quot;;
  64    /**
  65     * 当前子线程相对于总长度的位置
  66     */
  67    protected long mChildCurrentLocation = 0;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  68 -  protected IEventListener mListener;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  69 -  private StateConstance sState;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  70 -  private SubThreadConfig&lt;TASK_WRAPPER&gt; sConfig;</span>
  71    private ENTITY mEntity;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  72 -  private TASK_WRAPPER mTaskWrapper;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  73 +  protected TASK_WRAPPER mTaskWrapper;</span>
  74    private int mFailTimes = 0;
  75    private long mLastSaveTime;
  76    private ExecutorService mConfigThreadPool;
  77    private boolean isNotNetRetry;  //断网情况是否重试
  78    private boolean taskBreak = false;  //任务跳出
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  79 -  private int mThreadNum;</span>
  80    protected BandwidthLimiter mSpeedBandUtil; //速度限制工具
  81    protected AriaManager mAridManager;
  82    private boolean isInterrupted = false;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  83 +  protected boolean isCancel = false, isStop = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  84 +  protected ThreadRecord mRecord;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  85 +  private Handler mStateHandler;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  86 +  private SubThreadConfig&lt;TASK_WRAPPER&gt; mConfig;</span>
  87  
  88    private Thread mConfigThread = new Thread(new Runnable() {
  89      @Override public void run() {
  90        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
  91        final long currentTemp = mChildCurrentLocation;
  92        writeConfig(false, currentTemp);
  93      }
  94    });
  95  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  96 -  protected AbsThreadTask(StateConstance constance, IEventListener listener,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  97 -      SubThreadConfig&lt;TASK_WRAPPER&gt; config) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  98 -    sState = constance;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  99 -    sConfig = config;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 100 -    mListener = listener;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 101 -    mTaskWrapper = getConfig().TASK_WRAPPER;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 102 +  protected AbsThreadTask(SubThreadConfig&lt;TASK_WRAPPER&gt; config) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 103 +    mConfig = config;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 104 +    mTaskWrapper = config.taskWrapper;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 105 +    mRecord = config.record;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 106 +    mStateHandler = config.stateHandler;</span>
 107      mEntity = mTaskWrapper.getEntity();
 108      mLastSaveTime = System.currentTimeMillis();
 109      mConfigThreadPool = Executors.newCachedThreadPool();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 110 -    mThreadNum = getState().TASK_RECORD.threadRecords.size();</span>
 111      mAridManager = AriaManager.getInstance(AriaManager.APP);
 112      if (getMaxSpeed() &gt; 0) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 113 -      mSpeedBandUtil = new BandwidthLimiter(getMaxSpeed(), mThreadNum);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 114 +      mSpeedBandUtil = new BandwidthLimiter(getMaxSpeed(), config.startThreadNum);</span>
 115      }
 116      isNotNetRetry = mAridManager.getAppConfig().isNotNetRetry();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 117 +    mChildCurrentLocation = mRecord.startLocation;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 118 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 119 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 120 +  /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 121 +   * 当前线程处理的文件名</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 122 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 123 +  protected String getFileName() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 124 +    return mConfig.tempFile.getName();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 125 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 126 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 127 +  protected SubThreadConfig&lt;TASK_WRAPPER&gt; getConfig() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 128 +    return mConfig;</span>
 129    }
 130  
 131    /**
 132     * 设置线程是否中断
 133     *
 134     * @param isInterrupted {@code true} 中断
 135     */
 136    public void setInterrupted(boolean isInterrupted) {
 137      this.isInterrupted = isInterrupted;
 138    }
 139  
 140    /**
 141     * 线程是否存活
 142     *
 143     * @return {@code true}存活
 144     */
 145    protected boolean isLive() {
 146      return !Thread.currentThread().isInterrupted() &amp;&amp; !isInterrupted;
 147    }
 148  
 149    /**
 150     * 当前线程是否完成，对于不支持断点的任务，一律未完成 {@code true} 完成；{@code false} 未完成
 151     */
 152    boolean isThreadComplete() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 153 -    return getConfig().THREAD_RECORD.isComplete;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 154 -  }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 155 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 156 -  /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 157 -   * 获取状态信息</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 158 -   */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 159 -  protected StateConstance getState() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 160 -    return sState;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 161 +    return mRecord.isComplete;</span>
 162    }
 163  
 164    /**
 165     * 获取实体
 166     */
 167    protected ENTITY getEntity() {
 168      return mEntity;
 169    }
 170  
 171    /**
 172     * 获取任务驱动对象
 173     */
 174    protected TASK_WRAPPER getTaskWrapper() {
 175      return mTaskWrapper;
 176    }
 177  
 178    /**
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 179 -   * 获取任务记录</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 180 -   */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 181 -  private TaskRecord getTaskRecord() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 182 -    return getState().TASK_RECORD;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 183 -  }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 184 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 185 -  /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 186 -   * 获取线程记录</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 187 -   */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 188 -  protected ThreadRecord getThreadRecord() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 189 -    return getConfig().THREAD_RECORD;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 190 -  }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 191 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 192 -  /**</span>
 193     * 获取配置的最大上传/下载速度
 194     *
 195     * @return 单位为：kb
 196     */
 197    public abstract int getMaxSpeed();
 198  
 199    /**
 200     * 读取任务配置
 201     *
 202     * @return {@link DownloadConfig}、{@link UploadConfig}、{@link DGroupConfig}
 203     */
 204    protected abstract BaseTaskConfig getTaskConfig();
 205  
 206    /**
 207     * 设置最大下载速度
 208     *
 209     * @param speed 单位为：kb
 210     */
 211    public void setMaxSpeed(int speed) {
 212      if (mSpeedBandUtil != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 213 -      mSpeedBandUtil.setMaxRate(speed / mThreadNum);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 214 +      mSpeedBandUtil.setMaxRate(speed / mConfig.startThreadNum);</span>
 215      }
 216    }
 217  
 218    /**
 219     * 中断任务
 220     */
 221    void breakTask() {
 222      synchronized (AriaManager.LOCK) {
 223        taskBreak = true;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 224 -      if (getConfig().SUPPORT_BP) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 225 +      if (mTaskWrapper.isSupportBP()) {</span>
 226          final long currentTemp = mChildCurrentLocation;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 227 -        getState().STOP_NUM++;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 228 -        ALog.d(TAG, String.format(&quot;任务【%s】thread__%s__中断【停止位置：%s】&quot;, getConfig().TEMP_FILE.getName(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 229 -            getConfig().THREAD_ID, currentTemp));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 230 +        sendState(IThreadState.STATE_STOP, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 231 +        ALog.d(TAG, String.format(&quot;任务【%s】thread__%s__中断【停止位置：%s】&quot;, getFileName(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 232 +            mRecord.threadId, currentTemp));</span>
 233          writeConfig(false, currentTemp);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 234 -        if (getState().isStop()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 235 -          ALog.i(TAG, String.format(&quot;任务【%s】已中断&quot;, getConfig().TEMP_FILE.getName()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 236 -        }</span>
 237        } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 238 -        ALog.i(TAG, String.format(&quot;任务【%s】已中断&quot;, getConfig().TEMP_FILE.getName()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 239 -      }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 240 -    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 241 +        ALog.i(TAG, String.format(&quot;任务【%s】已中断&quot;, getFileName()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 242 +      }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 243 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 244 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 245 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 246 +  /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 247 +   * 发送状态给状态处理器</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 248 +   *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 249 +   * @param state {@link IThreadState#STATE_STOP}..</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 250 +   * @param bundle 而外数据</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 251 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 252 +  void sendState(int state, @Nullable Bundle bundle) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 253 +    Message msg = mStateHandler.obtainMessage();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 254 +    msg.what = state;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 255 +    if (bundle != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 256 +      msg.setData(bundle);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 257 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 258 +    msg.sendToTarget();</span>
 259    }
 260  
 261    public boolean isInterrupted() {
 262      return Thread.currentThread().isInterrupted();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 263 -  }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 264 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 265 -  /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 266 -   * 获取线程配置信息</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 267 -   */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 268 -  protected SubThreadConfig&lt;TASK_WRAPPER&gt; getConfig() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 269 -    return sConfig;</span>
 270    }
 271  
 272    @Override protected void finalize() throws Throwable {
 273      super.finalize();
 274      if (mConfigThreadPool != null) {
 275        mConfigThreadPool.shutdown();
 276      }
 277    }
 278  
 279    /**
 280     * 任务是否中断，中断条件： 1、任务取消 2、任务停止 3、手动中断 {@link #taskBreak}
 281     *
 282     * @return {@code true} 中断，{@code false} 不是中断
 283     */
 284    protected boolean isBreak() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 285 -    return getState().isCancel || getState().isStop || taskBreak;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 286 -  }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 287 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 288 -  /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 289 -   * 合并文件</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 290 -   *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 291 -   * @return {@code true} 合并成功，{@code false}合并失败</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 292 -   */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 293 -  protected boolean mergeFile() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 294 -    List&lt;String&gt; partPath = new ArrayList&lt;&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 295 -    for (int i = 0, len = getState().TASK_RECORD.threadNum; i &lt; len; i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 296 -      partPath.add(String.format(AbsFileer.SUB_PATH, getState().TASK_RECORD.filePath, i));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 297 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 298 -    boolean isSuccess = FileUtil.mergeFile(getState().TASK_RECORD.filePath, partPath);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 299 -    if (isSuccess) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 300 -      for (String pp : partPath) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 301 -        File f = new File(pp);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 302 -        if (f.exists()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 303 -          f.delete();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 304 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 305 -      }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 306 -      File targetFile = new File(getState().TASK_RECORD.filePath);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 307 -      if (targetFile.exists() &amp;&amp; targetFile.length() &gt; getEntity().getFileSize()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 308 -        ALog.e(TAG, String.format(&quot;任务【%s】分块文件合并失败，下载长度超出文件真实长度，downloadLen: %s，fileSize: %s&quot;,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 309 -            getConfig().TEMP_FILE.getName(), targetFile.length(), getEntity().getFileSize()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 310 -        return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 311 -      }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 312 +    return isCancel || isStop || taskBreak;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 313 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 314 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 315 +  /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 316 +   * 检查下载完成的分块大小，如果下载完成的分块大小大于或小于分配的大小，则需要重新下载该分块 如果是非分块任务，直接返回{@code true}</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 317 +   *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 318 +   * @return {@code true} 分块分大小正常，{@code false} 分块大小错误</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 319 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 320 +  protected boolean checkBlock() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 321 +    if (!mConfig.isBlock) {</span>
 322        return true;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 323 -    } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 324 -      return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 325 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 326 -  }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 327 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 328 -  /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 329 -   * 检查下载完成的分块大小，如果下载完成的分块大小大于或小于分配的大小，则需要重新下载该分块 如果是非分块任务，直接返回{@code true}</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 330 -   *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 331 -   * @return {@code true} 分块分大小正常，{@code false} 分块大小错误</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 332 -   */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 333 -  protected boolean checkBlock() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 334 -    if (!getTaskRecord().isBlock) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 335 -      return true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 336 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 337 -    ThreadRecord tr = getThreadRecord();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 338 -    File blockFile = getBockFile();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 339 -    if (!blockFile.exists() || blockFile.length() != tr.blockLen) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 340 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 341 +    File blockFile = mConfig.tempFile;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 342 +    if (!blockFile.exists() || blockFile.length() != mRecord.blockLen) {</span>
 343        ALog.i(TAG,
 344            String.format(&quot;分块【%s】错误，blockFileLen: %s, threadRect: %s; 即将重新下载该分块，开始位置：%s，结束位置：%s&quot;,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 345 -              blockFile.getName(), blockFile.length(), tr.blockLen, tr.startLocation,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 346 -              tr.endLocation));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 347 +              blockFile.getName(), blockFile.length(), mRecord.blockLen, mRecord.startLocation,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 348 +              mRecord.endLocation));</span>
 349        if (blockFile.exists()) {
 350          blockFile.delete();
 351          ALog.i(TAG, String.format(&quot;删除分块【%s】成功&quot;, blockFile.getName()));
 352        }
 353        retryThis(isBreak());
 354        return false;
 355      }
 356      return true;
 357    }
 358  
 359    /**
 360     * 停止任务
 361     */
 362    public void stop() {
 363      synchronized (AriaManager.LOCK) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 364 -      if (getConfig().SUPPORT_BP) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 365 -        final long stopLocation;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 366 -        if (getTaskRecord().isBlock) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 367 -          File blockFile = getBockFile();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 368 -          ThreadRecord tr = getThreadRecord();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 369 -          long block = getEntity().getFileSize() / getTaskRecord().threadRecords.size();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 370 -          stopLocation =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 371 -              blockFile.exists() ? (tr.threadId * block + blockFile.length()) : tr.threadId * block;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 372 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 373 -          stopLocation = mChildCurrentLocation;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 374 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 375 -        getState().STOP_NUM++;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 376 +      isStop = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 377 +      if (mTaskWrapper.isSupportBP()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 378 +        final long stopLocation = mChildCurrentLocation;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 379 +        sendState(IThreadState.STATE_STOP, null);</span>
 380          ALog.d(TAG,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 381 -            String.format(&quot;任务【%s】thread__%s__停止【当前线程停止位置：%s】&quot;, getConfig().TEMP_FILE.getName(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 382 -                getConfig().THREAD_ID, stopLocation));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 383 +            String.format(&quot;任务【%s】thread__%s__停止【当前线程停止位置：%s】&quot;, getFileName(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 384 +                mRecord.threadId, stopLocation));</span>
 385          writeConfig(false, stopLocation);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 386 -        //ALog.d(TAG, String.format(&quot;stop_thread_num=%s; start_thread_num=%s; complete_thread_num=%s&quot;,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 387 -        //    getState().STOP_NUM, getState().START_THREAD_NUM, getState().COMPLETE_THREAD_NUM));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 388 -        if (getState().isStop()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 389 -          ALog.i(TAG, String.format(&quot;任务【%s】已停止&quot;, getConfig().TEMP_FILE.getName()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 390 -          mListener.onStop(getState().CURRENT_LOCATION);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 391 -        }</span>
 392        } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 393 -        ALog.i(TAG, String.format(&quot;任务【%s】已停止&quot;, getConfig().TEMP_FILE.getName()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 394 -        mListener.onStop(getState().CURRENT_LOCATION);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 395 +        ALog.i(TAG, String.format(&quot;任务【%s】已停止&quot;, getFileName()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 396 +        sendState(IThreadState.STATE_STOP, null);</span>
 397        }
 398      }
 399    }
 400  
 401    /**
 402     * 执行中
 403     */
 404    protected void progress(long len) {
 405      synchronized (AriaManager.LOCK) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 406 -      if (getState().CURRENT_LOCATION &gt; getEntity().getFileSize() &amp;&amp; !getTaskWrapper().asHttp()</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 407 -          .isChunked()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 408 -        String errorMsg =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 409 -            String.format(&quot;下载失败，下载长度超出文件真实长度；currentLocation=%s, fileSize=%s&quot;,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 410 -                getState().CURRENT_LOCATION,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 411 -                getEntity().getFileSize());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 412 -        taskBreak = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 413 -        fail(mChildCurrentLocation, new FileException(TAG, errorMsg), false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 414 +      //if (getState().CURRENT_LOCATION &gt; getEntity().getFileSize() &amp;&amp; !getTaskWrapper().asHttp()</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 415 +      //    .isChunked()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 416 +      //  String errorMsg =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 417 +      //      String.format(&quot;下载失败，下载长度超出文件真实长度；currentLocation=%s, fileSize=%s&quot;,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 418 +      //          getState().CURRENT_LOCATION,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 419 +      //          getEntity().getFileSize());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 420 +      //  taskBreak = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 421 +      //  fail(mChildCurrentLocation, new FileException(TAG, errorMsg), false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 422 +      //  return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 423 +      //}</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 424 +      mChildCurrentLocation += len;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 425 +      if (!mStateHandler.getLooper().getThread().isAlive()) {</span>
 426          return;
 427        }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 428 -      mChildCurrentLocation += len;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 429 -      getState().CURRENT_LOCATION += len;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 430 +      mStateHandler.obtainMessage(IThreadState.STATE_RUNNING, len).sendToTarget();</span>
 431        if (System.currentTimeMillis() - mLastSaveTime &gt; 5000
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 432 -          &amp;&amp; mChildCurrentLocation &lt; getConfig().END_LOCATION) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 433 +          &amp;&amp; mChildCurrentLocation &lt; mRecord.endLocation) {</span>
 434          mLastSaveTime = System.currentTimeMillis();
 435          if (!mConfigThreadPool.isShutdown()) {
 436            mConfigThreadPool.execute(mConfigThread);
 437          }
 438        }
 439      }
 440    }
 441  
 442    /**
 443     * 取消任务
 444     */
 445    public void cancel() {
 446      synchronized (AriaManager.LOCK) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 447 -      if (getConfig().SUPPORT_BP) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 448 -        getState().CANCEL_NUM++;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 449 -        ALog.d(TAG,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 450 -            String.format(&quot;任务【%s】thread__%s__取消&quot;, getConfig().TEMP_FILE.getName(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 451 -                getConfig().THREAD_ID));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 452 -        //ALog.d(TAG, &quot;cancel_num = &quot;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 453 -        //    + getState().CANCEL_NUM</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 454 -        //    + &quot;, start_thread_num = &quot;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 455 -        //    + getState().START_THREAD_NUM);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 456 -        if (getState().isCancel()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 457 -          if (getConfig().TEMP_FILE.exists() &amp;&amp; !(getEntity() instanceof UploadEntity)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 458 -            getConfig().TEMP_FILE.delete();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 459 -          }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 460 -          ALog.d(TAG, String.format(&quot;任务【%s】已取消&quot;, getConfig().TEMP_FILE.getName()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 461 -          mListener.onCancel();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 462 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 463 -      } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 464 -        ALog.d(TAG, String.format(&quot;任务【%s】已取消&quot;, getConfig().TEMP_FILE.getName()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 465 -        mListener.onCancel();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 466 -      }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 467 +      isCancel = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 468 +      sendState(IThreadState.STATE_CANCEL, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 469 +      ALog.d(TAG,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 470 +          String.format(&quot;任务【%s】thread__%s__取消&quot;, getFileName(), mRecord.threadId));</span>
 471      }
 472    }
 473  
 474    /**
 475     * 线程任务失败
 476     *
 477     * @param subCurrentLocation 当前线程下载进度
 478     * @param ex 异常信息
 479     */
 480    protected void fail(final long subCurrentLocation, BaseException ex) {
 481      fail(subCurrentLocation, ex, true);
 482    }
 483  
 484    /**
 485     * 任务失败
 486     *
 487     * @param subCurrentLocation 当前子线程进度
 488     */
 489    protected void fail(final long subCurrentLocation, BaseException ex, boolean needRetry) {
 490      if (ex != null) {
 491        ALog.e(TAG, ALog.getExceptionString(ex));
 492      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 493 -    if (getConfig().SUPPORT_BP) {</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 494 -      writeConfig(false, subCurrentLocation);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 495 -      retryThis(needRetry &amp;&amp; getState().START_THREAD_NUM != 1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 496 +    if (mTaskWrapper.getRequestType() == ITaskWrapper.M3U8_FILE) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 497 +      writeConfig(false, 0);</span>
 498      } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 499 -      ALog.e(TAG, String.format(&quot;任务【%s】执行失败&quot;, getConfig().TEMP_FILE.getName()));</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 500 -      ErrorHelp.saveError(TAG, &quot;&quot;, ALog.getExceptionString(ex));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 501 -      handleFailState(!isBreak());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 502 +      if (mTaskWrapper.isSupportBP()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 503 +        writeConfig(false, subCurrentLocation);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 504 +        retryThis(needRetry &amp;&amp; mConfig.startThreadNum != 1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 505 +      } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 506 +        ALog.e(TAG, String.format(&quot;任务【%s】执行失败&quot;, getFileName()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 507 +        ErrorHelp.saveError(TAG, &quot;&quot;, ALog.getExceptionString(ex));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 508 +        sendFailMsg(null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 509 +      }</span>
 510      }
 511    }
 512  
 513    /**
 514     * 重试当前线程，如果其中一条线程已经下载失败，则任务该任务下载失败，并且停止该任务的所有线程
 515     *
 516     * @param needRetry 是否可以重试
 517     */
 518    private void retryThis(boolean needRetry) {
 519      if (!NetUtils.isConnected(AriaManager.APP) &amp;&amp; !isNotNetRetry) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 520 -      ALog.w(TAG, String.format(&quot;任务【%s】重试失败，网络未连接&quot;, getConfig().TEMP_FILE.getName()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 521 +      ALog.w(TAG, String.format(&quot;任务【%s】重试失败，网络未连接&quot;, getFileName()));</span>
 522      }
 523      if (mFailTimes &lt; RETRY_NUM &amp;&amp; needRetry &amp;&amp; (NetUtils.isConnected(AriaManager.APP)
 524          || isNotNetRetry) &amp;&amp; !isBreak()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 525 -      ALog.d(TAG, String.format(&quot;isCancel: %s, isStop: %s, isBreak: %s&quot;, getState().isCancel,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 526 -          getState().isStop, taskBreak));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 527 -      ALog.w(TAG, String.format(&quot;任务【%s】正在重试&quot;, getConfig().TEMP_FILE.getName()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 528 +      ALog.w(TAG, String.format(&quot;任务【%s】正在重试&quot;, getFileName()));</span>
 529        mFailTimes++;
 530        handleRetryRecord();
 531        ThreadTaskManager.getInstance().retryThread(AbsThreadTask.this);
 532      } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 533 -      handleFailState(!isBreak());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 534 +      sendFailMsg(null);</span>
 535      }
 536    }
 537  
 538    /**
 539     * 处理线程重试的记录，只有多线程任务才会执行
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 540 +   * 如果是以前版本{@link BufferedRandomAccessFile}创建的下载，那么 record.startLocation不用修改</span>
 541     */
 542    private void handleRetryRecord() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 543 -    if (getTaskRecord().isBlock) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 544 -      ThreadRecord tr = getThreadRecord();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 545 +    if (mConfig.isBlock) {</span>
 546        // 默认线程分块长度
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 547 -      long normalRectLen = getEntity().getFileSize() / getTaskRecord().threadRecords.size();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 548 -      File temp = getBockFile();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 549 +      File temp = mConfig.tempFile;</span>
 550  
 551        long blockFileLen = temp.length(); // 磁盘中的分块文件长度
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 552 -      long threadRect = tr.blockLen;     // 当前线程的区间</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 553 +      long threadRect = mRecord.blockLen;     // 当前线程的区间</span>
 554  
 555        if (!temp.exists()) {
 556          ALog.i(TAG, String.format(&quot;分块文件【%s】不存在，该分块将重新开始&quot;, temp.getName()));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 557 -        tr.isComplete = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 558 -        getConfig().START_LOCATION = tr.startLocation;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 559 +        mRecord.isComplete = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 560 +        mRecord.startLocation = mRecord.endLocation - threadRect;</span>
 561        } else {
 562          /*
 563           * 检查磁盘中的分块文件
 564           */
 565          if (blockFileLen &gt; threadRect) {
 566            ALog.i(TAG, String.format(&quot;分块【%s】错误，将重新下载该分块&quot;, temp.getName()));
 567            temp.delete();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 568 -          tr.startLocation = normalRectLen * tr.threadId;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 569 -          tr.isComplete = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 570 -          getConfig().START_LOCATION = tr.startLocation;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 571 -        } else if (blockFileLen &lt; tr.blockLen) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 572 -          tr.startLocation = normalRectLen * tr.threadId + blockFileLen;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 573 -          tr.isComplete = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 574 -          getConfig().START_LOCATION = tr.startLocation;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 575 -          getState().CURRENT_LOCATION = getBlockRealTotalSize();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 576 +          mRecord.startLocation = mRecord.endLocation - mRecord.blockLen;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 577 +          mRecord.isComplete = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 578 +        } else if (blockFileLen &lt; mRecord.blockLen) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 579 +          mRecord.startLocation = mRecord.endLocation - mRecord.blockLen + blockFileLen;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 580 +          mRecord.isComplete = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 581 +          sendState(IThreadState.STATE_UPDATE_PROGRESS, null);</span>
 582            ALog.i(TAG,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 583 -              String.format(&quot;修正分块【%s】，开始位置：%s，当前进度：%s&quot;, temp.getName(), tr.startLocation,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 584 -                  getState().CURRENT_LOCATION));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 585 +              String.format(&quot;修正分块【%s】记录，开始位置：%s，结束位置：%s&quot;, temp.getName(), mRecord.startLocation,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 586 +                  mRecord.endLocation));</span>
 587          } else {
 588            ALog.i(TAG, String.format(&quot;分块【%s】已完成，更新记录&quot;, temp.getName()));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 589 -          getState().COMPLETE_THREAD_NUM++;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 590 -          tr.isComplete = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 591 +          mRecord.isComplete = true;</span>
 592          }
 593        }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 594 -      tr.update();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 595 +      mRecord.update();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 596 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 597 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 598 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 599 +  /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 600 +   * 发送任务完成的消息，并删除任务记录</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 601 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 602 +  protected synchronized void sendCompleteMsg() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 603 +    ALog.i(TAG, String.format(&quot;任务【%s】完成&quot;, getFileName()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 604 +    sendState(IThreadState.STATE_COMPLETE, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 605 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 606 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 607 +  /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 608 +   * 发送失败信息</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 609 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 610 +  protected void sendFailMsg(@Nullable BaseException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 611 +    if (e != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 612 +      Bundle b = new Bundle();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 613 +      b.putSerializable(IThreadState.KEY_ERROR_INFO, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 614 +      sendState(IThreadState.STATE_FAIL, b);</span>
 615      } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 616 -      getConfig().START_LOCATION = mChildCurrentLocation == 0 ? getConfig().START_LOCATION</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 617 -          : getConfig().THREAD_RECORD.startLocation;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 618 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 619 -  }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 620 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 621 -  /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 622 -   * 发送任务完成的消息，并删除任务记录</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 623 -   */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 624 -  protected synchronized void sendCompleteMsg() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 625 -    ALog.i(TAG, String.format(&quot;任务【%s】完成&quot;, mEntity.getFileName()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 626 -    CommonUtil.delTaskRecord(mEntity.getKey(), mEntity instanceof DownloadEntity ? 1 : 2, false,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 627 -        false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 628 -    mListener.onComplete();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 629 -  }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 630 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 631 -  /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 632 -   * 获取分块文件</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 633 -   *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 634 -   * @return 分块文件</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 635 -   */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 636 -  private File getBockFile() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 637 -    return new File(String.format(AbsFileer.SUB_PATH, getState().TASK_RECORD.filePath,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 638 -        getThreadRecord().threadId));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 639 -  }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 640 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 641 -  /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 642 -   * 获取分块任务真实的进度</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 643 -   *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 644 -   * @return 进度</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 645 -   */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 646 -  private long getBlockRealTotalSize() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 647 -    long size = 0;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 648 -    for (int i = 0, len = getTaskRecord().threadRecords.size(); i &lt; len; i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 649 -      File temp = new File(String.format(AbsFileer.SUB_PATH, getTaskRecord().filePath, i));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 650 -      if (temp.exists()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 651 -        size += temp.length();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 652 -      }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 653 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 654 -    return size;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 655 -  }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 656 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 657 -  /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 658 -   * 处理失败状态</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 659 -   *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 660 -   * @param taskNeedReTry 任务是否需要重试{@code true} 需要</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 661 -   */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 662 -  private void handleFailState(boolean taskNeedReTry) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 663 -    getState().FAIL_NUM++;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 664 -    if (getState().isFail()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 665 -      // 手动停止不进行fail回调</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 666 -      if (!getState().isStop) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 667 -        String errorMsg = String.format(&quot;任务【%s】执行失败&quot;, getConfig().TEMP_FILE.getName());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 668 -        mListener.onFail(taskNeedReTry, new TaskException(TAG, errorMsg));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 669 -      }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 670 +      sendState(IThreadState.STATE_FAIL, null);</span>
 671      }
 672    }
 673  
 674    /**
 675     * 将记录写入到配置文件
 676     *
 677     * @param isComplete 当前线程是否完成 {@code true}完成
 678     * @param record 当前下载进度
 679     */
 680    protected void writeConfig(boolean isComplete, final long record) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 681 -    ThreadRecord tr = getThreadRecord();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 682 -    if (tr != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 683 -      tr.isComplete = isComplete;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 684 -      if (getTaskRecord().isBlock) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 685 -        tr.startLocation = record;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 686 -      } else if (getTaskRecord().isOpenDynamicFile) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 687 -        tr.startLocation = getConfig().TEMP_FILE.length();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 688 +    if (mRecord != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 689 +      mRecord.isComplete = isComplete;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 690 +      if (mConfig.isBlock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 691 +        mRecord.startLocation = record;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 692 +      } else if (mConfig.isOpenDynamicFile) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 693 +        mRecord.startLocation = mConfig.tempFile.length();</span>
 694        } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 695 -        if (0 &lt; record &amp;&amp; record &lt; getConfig().END_LOCATION) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 696 -          tr.startLocation = record;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 697 +        if (0 &lt; record &amp;&amp; record &lt; mRecord.endLocation) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 698 +          mRecord.startLocation = record;</span>
 699          }
 700        }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 701 -      tr.update();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 702 +      mRecord.update();</span>
 703      }
 704    }
 705  
 706    @Override public AbsThreadTask call() throws Exception {
 707      isInterrupted = false;
 708      Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
 709      TrafficStats.setThreadStatsTag(UUID.randomUUID().toString().hashCode());
 710      return this;
 711    }
 712  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2016 AriaLyy(https://github.com/AriaLyy/Aria)
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  package com.arialyy.aria.core.common;
  17  
  18  import android.net.TrafficStats;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  19 +import android.os.Bundle;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  20 +import android.os.Handler;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  21 +import android.os.Message;</span>
  22  import android.os.Process;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  23 +import android.support.annotation.Nullable;</span>
  24  import com.arialyy.aria.core.AriaManager;
  25  import com.arialyy.aria.core.config.BaseTaskConfig;
  26  import com.arialyy.aria.core.config.DGroupConfig;
  27  import com.arialyy.aria.core.config.DownloadConfig;
  28  import com.arialyy.aria.core.config.UploadConfig;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  29 -import com.arialyy.aria.core.download.DownloadEntity;</span>
  30  import com.arialyy.aria.core.inf.AbsNormalEntity;
  31  import com.arialyy.aria.core.inf.AbsTaskWrapper;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  32 -import com.arialyy.aria.core.inf.IEventListener;</span>

  33  import com.arialyy.aria.core.manager.ThreadTaskManager;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  34 -import com.arialyy.aria.core.upload.UploadEntity;</span>
  35  import com.arialyy.aria.exception.BaseException;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  36 -import com.arialyy.aria.exception.FileException;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  37 -import com.arialyy.aria.exception.TaskException;</span>
  38  import com.arialyy.aria.util.ALog;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  39 -import com.arialyy.aria.util.CommonUtil;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  40 +import com.arialyy.aria.util.BufferedRandomAccessFile;</span>
  41  import com.arialyy.aria.util.ErrorHelp;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  42 -import com.arialyy.aria.util.FileUtil;</span>
  43  import com.arialyy.aria.util.NetUtils;
  44  import java.io.File;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  45 -import java.util.ArrayList;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  46 -import java.util.List;</span>
  47  import java.util.UUID;
  48  import java.util.concurrent.Callable;
  49  import java.util.concurrent.ExecutorService;
  50  import java.util.concurrent.Executors;
  51  
  52  /**
  53   * Created by lyy on 2017/1/18. 任务线程
  54   */
  55  public abstract class AbsThreadTask&lt;ENTITY extends AbsNormalEntity, TASK_WRAPPER extends AbsTaskWrapper&lt;ENTITY&gt;&gt;
  56      implements Callable&lt;AbsThreadTask&gt; {
  57    /**
  58     * 线程重试次数
  59     */
  60    private final int RETRY_NUM = 2;
  61  
  62    private final String TAG = &quot;AbsThreadTask&quot;;
  63    /**
  64     * 当前子线程相对于总长度的位置
  65     */
  66    protected long mChildCurrentLocation = 0;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  67 -  protected IEventListener mListener;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  68 -  private StateConstance sState;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  69 -  private SubThreadConfig&lt;TASK_WRAPPER&gt; sConfig;</span>
  70    private ENTITY mEntity;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  71 -  private TASK_WRAPPER mTaskWrapper;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  72 +  protected TASK_WRAPPER mTaskWrapper;</span>
  73    private int mFailTimes = 0;
  74    private long mLastSaveTime;
  75    private ExecutorService mConfigThreadPool;
  76    private boolean isNotNetRetry;  //断网情况是否重试
  77    private boolean taskBreak = false;  //任务跳出
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  78 -  private int mThreadNum;</span>
  79    protected BandwidthLimiter mSpeedBandUtil; //速度限制工具
  80    protected AriaManager mAridManager;
  81    private boolean isInterrupted = false;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  82 +  protected boolean isCancel = false, isStop = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  83 +  protected ThreadRecord mRecord;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  84 +  private Handler mStateHandler;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  85 +  private SubThreadConfig&lt;TASK_WRAPPER&gt; mConfig;</span>
  86  
  87    private Thread mConfigThread = new Thread(new Runnable() {
  88      @Override public void run() {
  89        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
  90        final long currentTemp = mChildCurrentLocation;
  91        writeConfig(false, currentTemp);
  92      }
  93    });
  94  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  95 -  protected AbsThreadTask(StateConstance constance, IEventListener listener,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  96 -      SubThreadConfig&lt;TASK_WRAPPER&gt; config) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  97 -    sState = constance;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  98 -    sConfig = config;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  99 -    mListener = listener;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 100 -    mTaskWrapper = getConfig().TASK_WRAPPER;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 101 +  protected AbsThreadTask(SubThreadConfig&lt;TASK_WRAPPER&gt; config) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 102 +    mConfig = config;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 103 +    mTaskWrapper = config.taskWrapper;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 104 +    mRecord = config.record;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 105 +    mStateHandler = config.stateHandler;</span>
 106      mEntity = mTaskWrapper.getEntity();
 107      mLastSaveTime = System.currentTimeMillis();
 108      mConfigThreadPool = Executors.newCachedThreadPool();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 109 -    mThreadNum = getState().TASK_RECORD.threadRecords.size();</span>
 110      mAridManager = AriaManager.getInstance(AriaManager.APP);
 111      if (getMaxSpeed() &gt; 0) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 112 -      mSpeedBandUtil = new BandwidthLimiter(getMaxSpeed(), mThreadNum);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 113 +      mSpeedBandUtil = new BandwidthLimiter(getMaxSpeed(), config.startThreadNum);</span>
 114      }
 115      isNotNetRetry = mAridManager.getAppConfig().isNotNetRetry();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 116 +    mChildCurrentLocation = mRecord.startLocation;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 117 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 118 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 119 +  /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 120 +   * 当前线程处理的文件名</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 121 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 122 +  protected String getFileName() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 123 +    return mConfig.tempFile.getName();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 124 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 125 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 126 +  protected SubThreadConfig&lt;TASK_WRAPPER&gt; getConfig() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 127 +    return mConfig;</span>
 128    }
 129  
 130    /**
 131     * 设置线程是否中断
 132     *
 133     * @param isInterrupted {@code true} 中断
 134     */
 135    public void setInterrupted(boolean isInterrupted) {
 136      this.isInterrupted = isInterrupted;
 137    }
 138  
 139    /**
 140     * 线程是否存活
 141     *
 142     * @return {@code true}存活
 143     */
 144    protected boolean isLive() {
 145      return !Thread.currentThread().isInterrupted() &amp;&amp; !isInterrupted;
 146    }
 147  
 148    /**
 149     * 当前线程是否完成，对于不支持断点的任务，一律未完成 {@code true} 完成；{@code false} 未完成
 150     */
 151    boolean isThreadComplete() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 152 -    return getConfig().THREAD_RECORD.isComplete;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 153 -  }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 154 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 155 -  /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 156 -   * 获取状态信息</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 157 -   */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 158 -  protected StateConstance getState() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 159 -    return sState;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 160 +    return mRecord.isComplete;</span>
 161    }
 162  
 163    /**
 164     * 获取实体
 165     */
 166    protected ENTITY getEntity() {
 167      return mEntity;
 168    }
 169  
 170    /**
 171     * 获取任务驱动对象
 172     */
 173    protected TASK_WRAPPER getTaskWrapper() {
 174      return mTaskWrapper;
 175    }
 176  
 177    /**
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 178 -   * 获取任务记录</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 179 -   */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 180 -  private TaskRecord getTaskRecord() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 181 -    return getState().TASK_RECORD;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 182 -  }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 183 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 184 -  /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 185 -   * 获取线程记录</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 186 -   */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 187 -  protected ThreadRecord getThreadRecord() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 188 -    return getConfig().THREAD_RECORD;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 189 -  }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 190 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 191 -  /**</span>
 192     * 获取配置的最大上传/下载速度
 193     *
 194     * @return 单位为：kb
 195     */
 196    public abstract int getMaxSpeed();
 197  
 198    /**
 199     * 读取任务配置
 200     *
 201     * @return {@link DownloadConfig}、{@link UploadConfig}、{@link DGroupConfig}
 202     */
 203    protected abstract BaseTaskConfig getTaskConfig();
 204  
 205    /**
 206     * 设置最大下载速度
 207     *
 208     * @param speed 单位为：kb
 209     */
 210    public void setMaxSpeed(int speed) {
 211      if (mSpeedBandUtil != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 212 -      mSpeedBandUtil.setMaxRate(speed / mThreadNum);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 213 +      mSpeedBandUtil.setMaxRate(speed / mConfig.startThreadNum);</span>
 214      }
 215    }
 216  
 217    /**
 218     * 中断任务
 219     */
 220    void breakTask() {
 221      synchronized (AriaManager.LOCK) {
 222        taskBreak = true;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 223 -      if (getConfig().SUPPORT_BP) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 224 +      if (mTaskWrapper.isSupportBP()) {</span>
 225          final long currentTemp = mChildCurrentLocation;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 226 -        getState().STOP_NUM++;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 227 -        ALog.d(TAG, String.format(&quot;任务【%s】thread__%s__中断【停止位置：%s】&quot;, getConfig().TEMP_FILE.getName(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 228 -            getConfig().THREAD_ID, currentTemp));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 229 +        sendState(ThreadStateManager.STATE_STOP, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 230 +        ALog.d(TAG, String.format(&quot;任务【%s】thread__%s__中断【停止位置：%s】&quot;, getFileName(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 231 +            mRecord.threadId, currentTemp));</span>
 232          writeConfig(false, currentTemp);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 233 -        if (getState().isStop()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 234 -          ALog.i(TAG, String.format(&quot;任务【%s】已中断&quot;, getConfig().TEMP_FILE.getName()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 235 -        }</span>
 236        } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 237 -        ALog.i(TAG, String.format(&quot;任务【%s】已中断&quot;, getConfig().TEMP_FILE.getName()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 238 -      }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 239 -    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 240 +        ALog.i(TAG, String.format(&quot;任务【%s】已中断&quot;, getFileName()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 241 +      }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 242 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 243 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 244 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 245 +  /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 246 +   * 发送状态给状态处理器</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 247 +   *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 248 +   * @param state {@link ThreadStateManager#STATE_STOP}..</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 249 +   * @param bundle 而外数据</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 250 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 251 +  void sendState(int state, @Nullable Bundle bundle) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 252 +    Message msg = mStateHandler.obtainMessage();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 253 +    msg.what = state;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 254 +    if (bundle != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 255 +      msg.setData(bundle);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 256 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 257 +    msg.sendToTarget();</span>
 258    }
 259  
 260    public boolean isInterrupted() {
 261      return Thread.currentThread().isInterrupted();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 262 -  }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 263 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 264 -  /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 265 -   * 获取线程配置信息</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 266 -   */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 267 -  protected SubThreadConfig&lt;TASK_WRAPPER&gt; getConfig() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 268 -    return sConfig;</span>
 269    }
 270  
 271    @Override protected void finalize() throws Throwable {
 272      super.finalize();
 273      if (mConfigThreadPool != null) {
 274        mConfigThreadPool.shutdown();
 275      }
 276    }
 277  
 278    /**
 279     * 任务是否中断，中断条件： 1、任务取消 2、任务停止 3、手动中断 {@link #taskBreak}
 280     *
 281     * @return {@code true} 中断，{@code false} 不是中断
 282     */
 283    protected boolean isBreak() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 284 -    return getState().isCancel || getState().isStop || taskBreak;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 285 -  }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 286 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 287 -  /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 288 -   * 合并文件</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 289 -   *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 290 -   * @return {@code true} 合并成功，{@code false}合并失败</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 291 -   */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 292 -  protected boolean mergeFile() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 293 -    List&lt;String&gt; partPath = new ArrayList&lt;&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 294 -    for (int i = 0, len = getState().TASK_RECORD.threadNum; i &lt; len; i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 295 -      partPath.add(String.format(AbsFileer.SUB_PATH, getState().TASK_RECORD.filePath, i));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 296 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 297 -    boolean isSuccess = FileUtil.mergeFile(getState().TASK_RECORD.filePath, partPath);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 298 -    if (isSuccess) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 299 -      for (String pp : partPath) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 300 -        File f = new File(pp);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 301 -        if (f.exists()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 302 -          f.delete();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 303 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 304 -      }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 305 -      File targetFile = new File(getState().TASK_RECORD.filePath);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 306 -      if (targetFile.exists() &amp;&amp; targetFile.length() &gt; getEntity().getFileSize()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 307 -        ALog.e(TAG, String.format(&quot;任务【%s】分块文件合并失败，下载长度超出文件真实长度，downloadLen: %s，fileSize: %s&quot;,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 308 -            getConfig().TEMP_FILE.getName(), targetFile.length(), getEntity().getFileSize()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 309 -        return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 310 -      }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 311 +    return isCancel || isStop || taskBreak;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 312 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 313 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 314 +  /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 315 +   * 检查下载完成的分块大小，如果下载完成的分块大小大于或小于分配的大小，则需要重新下载该分块 如果是非分块任务，直接返回{@code true}</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 316 +   *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 317 +   * @return {@code true} 分块分大小正常，{@code false} 分块大小错误</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 318 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 319 +  protected boolean checkBlock() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 320 +    if (!mConfig.isBlock) {</span>
 321        return true;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 322 -    } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 323 -      return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 324 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 325 -  }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 326 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 327 -  /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 328 -   * 检查下载完成的分块大小，如果下载完成的分块大小大于或小于分配的大小，则需要重新下载该分块 如果是非分块任务，直接返回{@code true}</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 329 -   *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 330 -   * @return {@code true} 分块分大小正常，{@code false} 分块大小错误</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 331 -   */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 332 -  protected boolean checkBlock() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 333 -    if (!getTaskRecord().isBlock) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 334 -      return true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 335 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 336 -    ThreadRecord tr = getThreadRecord();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 337 -    File blockFile = getBockFile();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 338 -    if (!blockFile.exists() || blockFile.length() != tr.blockLen) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 339 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 340 +    File blockFile = mConfig.tempFile;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 341 +    if (!blockFile.exists() || blockFile.length() != mRecord.blockLen) {</span>
 342        ALog.i(TAG,
 343            String.format(&quot;分块【%s】错误，blockFileLen: %s, threadRect: %s; 即将重新下载该分块，开始位置：%s，结束位置：%s&quot;,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 344 -              blockFile.getName(), blockFile.length(), tr.blockLen, tr.startLocation,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 345 -              tr.endLocation));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 346 +              blockFile.getName(), blockFile.length(), mRecord.blockLen, mRecord.startLocation,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 347 +              mRecord.endLocation));</span>
 348        if (blockFile.exists()) {
 349          blockFile.delete();
 350          ALog.i(TAG, String.format(&quot;删除分块【%s】成功&quot;, blockFile.getName()));
 351        }
 352        retryThis(isBreak());
 353        return false;
 354      }
 355      return true;
 356    }
 357  
 358    /**
 359     * 停止任务
 360     */
 361    public void stop() {
 362      synchronized (AriaManager.LOCK) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 363 -      if (getConfig().SUPPORT_BP) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 364 -        final long stopLocation;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 365 -        if (getTaskRecord().isBlock) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 366 -          File blockFile = getBockFile();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 367 -          ThreadRecord tr = getThreadRecord();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 368 -          long block = getEntity().getFileSize() / getTaskRecord().threadRecords.size();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 369 -          stopLocation =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 370 -              blockFile.exists() ? (tr.threadId * block + blockFile.length()) : tr.threadId * block;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 371 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 372 -          stopLocation = mChildCurrentLocation;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 373 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 374 -        getState().STOP_NUM++;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 375 +      isStop = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 376 +      if (mTaskWrapper.isSupportBP()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 377 +        final long stopLocation = mChildCurrentLocation;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 378 +        sendState(ThreadStateManager.STATE_STOP, null);</span>
 379          ALog.d(TAG,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 380 -            String.format(&quot;任务【%s】thread__%s__停止【当前线程停止位置：%s】&quot;, getConfig().TEMP_FILE.getName(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 381 -                getConfig().THREAD_ID, stopLocation));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 382 +            String.format(&quot;任务【%s】thread__%s__停止【当前线程停止位置：%s】&quot;, getFileName(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 383 +                mRecord.threadId, stopLocation));</span>
 384          writeConfig(false, stopLocation);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 385 -        //ALog.d(TAG, String.format(&quot;stop_thread_num=%s; start_thread_num=%s; complete_thread_num=%s&quot;,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 386 -        //    getState().STOP_NUM, getState().START_THREAD_NUM, getState().COMPLETE_THREAD_NUM));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 387 -        if (getState().isStop()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 388 -          ALog.i(TAG, String.format(&quot;任务【%s】已停止&quot;, getConfig().TEMP_FILE.getName()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 389 -          mListener.onStop(getState().CURRENT_LOCATION);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 390 -        }</span>
 391        } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 392 -        ALog.i(TAG, String.format(&quot;任务【%s】已停止&quot;, getConfig().TEMP_FILE.getName()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 393 -        mListener.onStop(getState().CURRENT_LOCATION);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 394 +        ALog.i(TAG, String.format(&quot;任务【%s】已停止&quot;, getFileName()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 395 +        sendState(ThreadStateManager.STATE_STOP, null);</span>
 396        }
 397      }
 398    }
 399  
 400    /**
 401     * 执行中
 402     */
 403    protected void progress(long len) {
 404      synchronized (AriaManager.LOCK) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 405 -      if (getState().CURRENT_LOCATION &gt; getEntity().getFileSize() &amp;&amp; !getTaskWrapper().asHttp()</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 406 -          .isChunked()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 407 -        String errorMsg =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 408 -            String.format(&quot;下载失败，下载长度超出文件真实长度；currentLocation=%s, fileSize=%s&quot;,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 409 -                getState().CURRENT_LOCATION,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 410 -                getEntity().getFileSize());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 411 -        taskBreak = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 412 -        fail(mChildCurrentLocation, new FileException(TAG, errorMsg), false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 413 +      //if (getState().CURRENT_LOCATION &gt; getEntity().getFileSize() &amp;&amp; !getTaskWrapper().asHttp()</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 414 +      //    .isChunked()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 415 +      //  String errorMsg =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 416 +      //      String.format(&quot;下载失败，下载长度超出文件真实长度；currentLocation=%s, fileSize=%s&quot;,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 417 +      //          getState().CURRENT_LOCATION,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 418 +      //          getEntity().getFileSize());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 419 +      //  taskBreak = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 420 +      //  fail(mChildCurrentLocation, new FileException(TAG, errorMsg), false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 421 +      //  return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 422 +      //}</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 423 +      mChildCurrentLocation += len;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 424 +      if (!mStateHandler.getLooper().getThread().isAlive()) {</span>
 425          return;
 426        }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 427 -      mChildCurrentLocation += len;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 428 -      getState().CURRENT_LOCATION += len;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 429 +      mStateHandler.obtainMessage(ThreadStateManager.STATE_RUNNING, len).sendToTarget();</span>
 430        if (System.currentTimeMillis() - mLastSaveTime &gt; 5000
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 431 -          &amp;&amp; mChildCurrentLocation &lt; getConfig().END_LOCATION) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 432 +          &amp;&amp; mChildCurrentLocation &lt; mRecord.endLocation) {</span>
 433          mLastSaveTime = System.currentTimeMillis();
 434          if (!mConfigThreadPool.isShutdown()) {
 435            mConfigThreadPool.execute(mConfigThread);
 436          }
 437        }
 438      }
 439    }
 440  
 441    /**
 442     * 取消任务
 443     */
 444    public void cancel() {
 445      synchronized (AriaManager.LOCK) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 446 -      if (getConfig().SUPPORT_BP) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 447 -        getState().CANCEL_NUM++;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 448 -        ALog.d(TAG,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 449 -            String.format(&quot;任务【%s】thread__%s__取消&quot;, getConfig().TEMP_FILE.getName(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 450 -                getConfig().THREAD_ID));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 451 -        //ALog.d(TAG, &quot;cancel_num = &quot;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 452 -        //    + getState().CANCEL_NUM</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 453 -        //    + &quot;, start_thread_num = &quot;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 454 -        //    + getState().START_THREAD_NUM);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 455 -        if (getState().isCancel()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 456 -          if (getConfig().TEMP_FILE.exists() &amp;&amp; !(getEntity() instanceof UploadEntity)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 457 -            getConfig().TEMP_FILE.delete();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 458 -          }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 459 -          ALog.d(TAG, String.format(&quot;任务【%s】已取消&quot;, getConfig().TEMP_FILE.getName()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 460 -          mListener.onCancel();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 461 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 462 -      } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 463 -        ALog.d(TAG, String.format(&quot;任务【%s】已取消&quot;, getConfig().TEMP_FILE.getName()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 464 -        mListener.onCancel();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 465 -      }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 466 +      isCancel = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 467 +      sendState(ThreadStateManager.STATE_CANCEL, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 468 +      ALog.d(TAG,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 469 +          String.format(&quot;任务【%s】thread__%s__取消&quot;, getFileName(), mRecord.threadId));</span>
 470      }
 471    }
 472  
 473    /**
 474     * 线程任务失败
 475     *
 476     * @param subCurrentLocation 当前线程下载进度
 477     * @param ex 异常信息
 478     */
 479    protected void fail(final long subCurrentLocation, BaseException ex) {
 480      fail(subCurrentLocation, ex, true);
 481    }
 482  
 483    /**
 484     * 任务失败
 485     *
 486     * @param subCurrentLocation 当前子线程进度
 487     */
 488    protected void fail(final long subCurrentLocation, BaseException ex, boolean needRetry) {
 489      if (ex != null) {
 490        ALog.e(TAG, ALog.getExceptionString(ex));
 491      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 492 -    if (getConfig().SUPPORT_BP) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 493 +    if (mTaskWrapper.isSupportBP()) {</span>
 494        writeConfig(false, subCurrentLocation);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 495 -      retryThis(needRetry &amp;&amp; getState().START_THREAD_NUM != 1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 496 +      retryThis(needRetry &amp;&amp; mConfig.startThreadNum != 1);</span>

 497      } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 498 -      ALog.e(TAG, String.format(&quot;任务【%s】执行失败&quot;, getConfig().TEMP_FILE.getName()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 499 +      ALog.e(TAG, String.format(&quot;任务【%s】执行失败&quot;, getFileName()));</span>
 500        ErrorHelp.saveError(TAG, &quot;&quot;, ALog.getExceptionString(ex));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 501 -      handleFailState(!isBreak());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 502 +      sendFailMsg(null);</span>







 503      }
 504    }
 505  
 506    /**
 507     * 重试当前线程，如果其中一条线程已经下载失败，则任务该任务下载失败，并且停止该任务的所有线程
 508     *
 509     * @param needRetry 是否可以重试
 510     */
 511    private void retryThis(boolean needRetry) {
 512      if (!NetUtils.isConnected(AriaManager.APP) &amp;&amp; !isNotNetRetry) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 513 -      ALog.w(TAG, String.format(&quot;任务【%s】重试失败，网络未连接&quot;, getConfig().TEMP_FILE.getName()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 514 +      ALog.w(TAG, String.format(&quot;任务【%s】重试失败，网络未连接&quot;, getFileName()));</span>
 515      }
 516      if (mFailTimes &lt; RETRY_NUM &amp;&amp; needRetry &amp;&amp; (NetUtils.isConnected(AriaManager.APP)
 517          || isNotNetRetry) &amp;&amp; !isBreak()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 518 -      ALog.d(TAG, String.format(&quot;isCancel: %s, isStop: %s, isBreak: %s&quot;, getState().isCancel,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 519 -          getState().isStop, taskBreak));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 520 -      ALog.w(TAG, String.format(&quot;任务【%s】正在重试&quot;, getConfig().TEMP_FILE.getName()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 521 +      ALog.w(TAG, String.format(&quot;任务【%s】正在重试&quot;, getFileName()));</span>
 522        mFailTimes++;
 523        handleRetryRecord();
 524        ThreadTaskManager.getInstance().retryThread(AbsThreadTask.this);
 525      } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 526 -      handleFailState(!isBreak());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 527 +      sendFailMsg(null);</span>
 528      }
 529    }
 530  
 531    /**
 532     * 处理线程重试的记录，只有多线程任务才会执行
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 533 +   * 如果是以前版本{@link BufferedRandomAccessFile}创建的下载，那么 record.startLocation不用修改</span>
 534     */
 535    private void handleRetryRecord() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 536 -    if (getTaskRecord().isBlock) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 537 -      ThreadRecord tr = getThreadRecord();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 538 +    if (mConfig.isBlock) {</span>
 539        // 默认线程分块长度
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 540 -      long normalRectLen = getEntity().getFileSize() / getTaskRecord().threadRecords.size();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 541 -      File temp = getBockFile();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 542 +      File temp = mConfig.tempFile;</span>
 543  
 544        long blockFileLen = temp.length(); // 磁盘中的分块文件长度
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 545 -      long threadRect = tr.blockLen;     // 当前线程的区间</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 546 +      long threadRect = mRecord.blockLen;     // 当前线程的区间</span>
 547  
 548        if (!temp.exists()) {
 549          ALog.i(TAG, String.format(&quot;分块文件【%s】不存在，该分块将重新开始&quot;, temp.getName()));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 550 -        tr.isComplete = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 551 -        getConfig().START_LOCATION = tr.startLocation;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 552 +        mRecord.isComplete = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 553 +        mRecord.startLocation = mRecord.endLocation - threadRect;</span>
 554        } else {
 555          /*
 556           * 检查磁盘中的分块文件
 557           */
 558          if (blockFileLen &gt; threadRect) {
 559            ALog.i(TAG, String.format(&quot;分块【%s】错误，将重新下载该分块&quot;, temp.getName()));
 560            temp.delete();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 561 -          tr.startLocation = normalRectLen * tr.threadId;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 562 -          tr.isComplete = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 563 -          getConfig().START_LOCATION = tr.startLocation;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 564 -        } else if (blockFileLen &lt; tr.blockLen) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 565 -          tr.startLocation = normalRectLen * tr.threadId + blockFileLen;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 566 -          tr.isComplete = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 567 -          getConfig().START_LOCATION = tr.startLocation;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 568 -          getState().CURRENT_LOCATION = getBlockRealTotalSize();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 569 +          mRecord.startLocation = mRecord.endLocation - mRecord.blockLen;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 570 +          mRecord.isComplete = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 571 +        } else if (blockFileLen &lt; mRecord.blockLen) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 572 +          mRecord.startLocation = mRecord.endLocation - mRecord.blockLen + blockFileLen;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 573 +          mRecord.isComplete = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 574 +          sendState(ThreadStateManager.STATE_UPDATE_PROGRESS, null);</span>
 575            ALog.i(TAG,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 576 -              String.format(&quot;修正分块【%s】，开始位置：%s，当前进度：%s&quot;, temp.getName(), tr.startLocation,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 577 -                  getState().CURRENT_LOCATION));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 578 +              String.format(&quot;修正分块【%s】，开始位置：%s，结束位置：%s&quot;, temp.getName(), mRecord.startLocation,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 579 +                  mRecord.endLocation));</span>
 580          } else {
 581            ALog.i(TAG, String.format(&quot;分块【%s】已完成，更新记录&quot;, temp.getName()));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 582 -          getState().COMPLETE_THREAD_NUM++;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 583 -          tr.isComplete = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 584 +          mRecord.isComplete = true;</span>
 585          }
 586        }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 587 -      tr.update();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 588 +      mRecord.update();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 589 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 590 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 591 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 592 +  /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 593 +   * 发送任务完成的消息，并删除任务记录</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 594 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 595 +  protected synchronized void sendCompleteMsg() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 596 +    ALog.i(TAG, String.format(&quot;任务【%s】完成&quot;, getFileName()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 597 +    sendState(ThreadStateManager.STATE_COMPLETE, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 598 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 599 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 600 +  /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 601 +   * 发送失败信息</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 602 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 603 +  protected void sendFailMsg(@Nullable BaseException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 604 +    if (e != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 605 +      Bundle b = new Bundle();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 606 +      b.putSerializable(ThreadStateManager.KEY_ERROR_INFO, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 607 +      sendState(ThreadStateManager.STATE_FAIL, b);</span>
 608      } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 609 -      getConfig().START_LOCATION = mChildCurrentLocation == 0 ? getConfig().START_LOCATION</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 610 -          : getConfig().THREAD_RECORD.startLocation;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 611 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 612 -  }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 613 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 614 -  /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 615 -   * 发送任务完成的消息，并删除任务记录</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 616 -   */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 617 -  protected synchronized void sendCompleteMsg() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 618 -    ALog.i(TAG, String.format(&quot;任务【%s】完成&quot;, mEntity.getFileName()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 619 -    CommonUtil.delTaskRecord(mEntity.getKey(), mEntity instanceof DownloadEntity ? 1 : 2, false,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 620 -        false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 621 -    mListener.onComplete();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 622 -  }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 623 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 624 -  /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 625 -   * 获取分块文件</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 626 -   *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 627 -   * @return 分块文件</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 628 -   */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 629 -  private File getBockFile() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 630 -    return new File(String.format(AbsFileer.SUB_PATH, getState().TASK_RECORD.filePath,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 631 -        getThreadRecord().threadId));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 632 -  }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 633 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 634 -  /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 635 -   * 获取分块任务真实的进度</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 636 -   *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 637 -   * @return 进度</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 638 -   */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 639 -  private long getBlockRealTotalSize() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 640 -    long size = 0;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 641 -    for (int i = 0, len = getTaskRecord().threadRecords.size(); i &lt; len; i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 642 -      File temp = new File(String.format(AbsFileer.SUB_PATH, getTaskRecord().filePath, i));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 643 -      if (temp.exists()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 644 -        size += temp.length();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 645 -      }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 646 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 647 -    return size;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 648 -  }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 649 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 650 -  /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 651 -   * 处理失败状态</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 652 -   *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 653 -   * @param taskNeedReTry 任务是否需要重试{@code true} 需要</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 654 -   */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 655 -  private void handleFailState(boolean taskNeedReTry) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 656 -    getState().FAIL_NUM++;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 657 -    if (getState().isFail()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 658 -      // 手动停止不进行fail回调</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 659 -      if (!getState().isStop) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 660 -        String errorMsg = String.format(&quot;任务【%s】执行失败&quot;, getConfig().TEMP_FILE.getName());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 661 -        mListener.onFail(taskNeedReTry, new TaskException(TAG, errorMsg));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 662 -      }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 663 +      sendState(ThreadStateManager.STATE_FAIL, null);</span>
 664      }
 665    }
 666  
 667    /**
 668     * 将记录写入到配置文件
 669     *
 670     * @param isComplete 当前线程是否完成 {@code true}完成
 671     * @param record 当前下载进度
 672     */
 673    protected void writeConfig(boolean isComplete, final long record) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 674 -    ThreadRecord tr = getThreadRecord();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 675 -    if (tr != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 676 -      tr.isComplete = isComplete;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 677 -      if (getTaskRecord().isBlock) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 678 -        tr.startLocation = record;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 679 -      } else if (getTaskRecord().isOpenDynamicFile) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 680 -        tr.startLocation = getConfig().TEMP_FILE.length();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 681 +    if (mRecord != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 682 +      mRecord.isComplete = isComplete;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 683 +      if (mConfig.isBlock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 684 +        mRecord.startLocation = record;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 685 +      } else if (mConfig.isOpenDynamicFile) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 686 +        mRecord.startLocation = mConfig.tempFile.length();</span>
 687        } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 688 -        if (0 &lt; record &amp;&amp; record &lt; getConfig().END_LOCATION) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 689 -          tr.startLocation = record;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 690 +        if (0 &lt; record &amp;&amp; record &lt; mRecord.endLocation) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 691 +          mRecord.startLocation = record;</span>
 692          }
 693        }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 694 -      tr.update();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 695 +      mRecord.update();</span>
 696      }
 697    }
 698  
 699    @Override public AbsThreadTask call() throws Exception {
 700      isInterrupted = false;
 701      Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
 702      TrafficStats.setThreadStatsTag(UUID.randomUUID().toString().hashCode());
 703      return this;
 704    }
 705  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            