<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>494</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    494
                    <a href="493.html">prev</a>
                    <a href="495.html">next</a>
                    <a href="494_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_cb68efb9e51ba697e771581059b9c11c3fe66ccb_core/src/main/java/com/dtstack/flink/sql/side/BaseAsyncReqRow.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;cb68efb9e51ba697e771581059b9c11c3fe66ccb:core/src/main/java/com/dtstack/flink/sql/side/BaseAsyncReqRow.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;cb68efb9e51ba697e771581059b9c11c3fe66ccb^1:core/src/main/java/com/dtstack/flink/sql/side/BaseAsyncReqRow.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;cb68efb9e51ba697e771581059b9c11c3fe66ccb^2:core/src/main/java/com/dtstack/flink/sql/side/BaseAsyncReqRow.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;828062ef514a8028632086b1c19ef248140da519:core/src/main/java/com/dtstack/flink/sql/side/BaseAsyncReqRow.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [j]], subset: [[b], [j]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.side;
  22 
  23 import com.dtstack.flink.sql.enums.ECacheContentType;
  24 import com.dtstack.flink.sql.enums.ECacheType;
  25 import com.dtstack.flink.sql.factory.DTThreadFactory;
  26 import com.dtstack.flink.sql.metric.MetricConstant;
  27 import com.dtstack.flink.sql.side.cache.AbstractSideCache;
  28 import com.dtstack.flink.sql.side.cache.CacheObj;
  29 import com.dtstack.flink.sql.side.cache.LRUSideCache;
  30 import com.dtstack.flink.sql.util.ReflectionUtils;
  31 import com.google.common.collect.Lists;
  32 import com.google.common.collect.Maps;
  33 import org.apache.calcite.sql.JoinType;
  34 import org.apache.commons.collections.MapUtils;
  35 import org.apache.flink.api.common.functions.RuntimeContext;
  36 import org.apache.flink.api.java.tuple.Tuple2;
  37 import org.apache.flink.configuration.Configuration;
  38 import org.apache.flink.metrics.Counter;
  39 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  40 import org.apache.flink.streaming.api.functions.async.RichAsyncFunction;
  41 import org.apache.flink.streaming.api.operators.StreamingRuntimeContext;
  42 import org.apache.flink.streaming.api.operators.async.AsyncWaitOperator;
  43 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeCallback;
  44 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;
  45 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  46 import org.apache.flink.types.Row;
  47 import org.slf4j.Logger;
  48 import org.slf4j.LoggerFactory;
  49 
  50 import java.lang.reflect.InvocationTargetException;
  51 import java.lang.reflect.Method;
  52 import java.sql.Timestamp;
  53 import java.time.LocalDateTime;
  54 import java.util.Collections;
  55 import java.util.List;
  56 import java.util.Map;
  57 import java.util.concurrent.LinkedBlockingQueue;
  58 import java.util.concurrent.ScheduledFuture;
  59 import java.util.concurrent.ThreadPoolExecutor;
  60 import java.util.concurrent.TimeUnit;
  61 
  62 /**
  63  * All interfaces inherit naming rules: type + &quot;AsyncReqRow&quot; such as == &quot;MysqlAsyncReqRow
  64  * only support Left join / inner join(join),not support right join
  65  * Date: 2018/7/9
  66  * Company: www.dtstack.com
  67  * @author xuchao
  68  */
  69 
<abbr title="  70 public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;Tuple2&lt;Boolean,Row&gt;, Tuple2&lt;Boolean,Row&gt;&gt; implements ISideReqRow {">  70 public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;Tuple2&lt;Boolean,Row&gt;, Tuple2&lt;Boolean,Row&gt;&gt;ðŸ”µ</abbr>
  71     private static final Logger LOG = LoggerFactory.getLogger(BaseAsyncReqRow.class);
  72     private static final long serialVersionUID = 2098635244857937717L;
  73     private RuntimeContext runtimeContext;
  74     private static int TIMEOUT_LOG_FLUSH_NUM = 10;
  75     private int timeOutNum = 0;
  76     protected BaseSideInfo sideInfo;
  77     protected transient Counter parseErrorRecords;
  78     private transient ThreadPoolExecutor cancelExecutor;
  79 
  80     public BaseAsyncReqRow(BaseSideInfo sideInfo){
  81         this.sideInfo = sideInfo;
  82     }
  83     @Override
  84     public void setRuntimeContext(RuntimeContext runtimeContext) {
  85         super.setRuntimeContext(runtimeContext);
  86         this.runtimeContext = runtimeContext;
  87     }
  88     @Override
  89     public void open(Configuration parameters) throws Exception {
  90         super.open(parameters);
  91         initCache();
  92         initMetric();
<abbr title="  93         cancelExecutor = new ThreadPoolExecutor(1, 1, 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;(100000),">  93         cancelExecutor = new ThreadPoolExecutor(1, 1, 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;ðŸ”µ</abbr>
  94                 new DTThreadFactory(&quot;cancel-timer-executor&quot;));
  95         LOG.info(&quot;async dim table config info: {} &quot;, sideInfo.getSideTableInfo().toString());
  96     }
  97 
  98     private void initCache(){
  99         AbstractSideTableInfo sideTableInfo = sideInfo.getSideTableInfo();
<abbr title=" 100         if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheType())){"> 100         if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.ðŸ”µ</abbr>
 101             return;
 102         }
 103 
 104         AbstractSideCache sideCache;
 105         if(ECacheType.LRU.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
 106             sideCache = new LRUSideCache(sideTableInfo);
 107             sideInfo.setSideCache(sideCache);
 108         }else{
<abbr title=" 109             throw new RuntimeException(&quot;not support side cache with type:&quot; + sideTableInfo.getCacheType());"> 109             throw new RuntimeException(&quot;not support side cache with type:&quot; + sideTableInfo.getCacheType()ðŸ”µ</abbr>
 110         }
 111 
 112         sideCache.initCache();
 113     }
 114 
 115     private void initMetric() {
<abbr title=" 116         parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_RECORDS);"> 116         parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSEðŸ”µ</abbr>
 117     }
 118 
 119 
 120     protected Object convertTimeIndictorTypeInfo(Integer index, Object obj) {
<abbr title=" 121         boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(index).getClass());"> 121         boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypðŸ”µ</abbr>
 122 
<abbr title=" 123         //Type information for indicating event or processing time. However, it behaves like a regular SQL timestamp but is serialized as Long."> 123         //Type information for indicating event or processing time. However, it behaves like a regular SQðŸ”µ</abbr>
 124         if (obj instanceof LocalDateTime &amp;&amp; isTimeIndicatorTypeInfo) {
 125             obj = Timestamp.valueOf(((LocalDateTime) obj));
 126         }
 127         return obj;
 128     }
 129 
 130     protected CacheObj getFromCache(String key){
 131         return sideInfo.getSideCache().getFromCache(key);
 132     }
 133 
 134     protected void putCache(String key, CacheObj value){
 135         sideInfo.getSideCache().putCache(key, value);
 136     }
 137 
 138     protected boolean openCache(){
 139         return sideInfo.getSideCache() != null;
 140     }
 141 
<abbr title=" 142     protected void dealMissKey(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture){"> 142     protected void dealMissKey(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture)ðŸ”µ</abbr>
 143         if(sideInfo.getJoinType() == JoinType.LEFT){
 144             //Reserved left table data
 145             try {
 146                 Row row = fillData(input.f1, null);
 147                 resultFuture.complete(Collections.singleton(new Tuple2&lt;&gt;(input.f0, row)));
 148             } catch (Exception e) {
 149                 dealFillDataError(input, resultFuture, e);
 150             }
 151         }else{
 152             resultFuture.complete(null);
 153         }
 154     }
 155 
 156     protected void dealCacheData(String key, CacheObj missKeyObj) {
 157         if (openCache()) {
 158             putCache(key, missKeyObj);
 159         }
 160     }
 161 
 162     @Override
<abbr title=" 163     public void timeout(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws Exception {"> 163     public void timeout(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throwsðŸ”µ</abbr>
 164 
 165         if(timeOutNum % TIMEOUT_LOG_FLUSH_NUM == 0){
<abbr title=" 166             LOG.info(&quot;Async function call has timed out. input:{}, timeOutNum:{}&quot;,input.toString(), timeOutNum);"> 166             LOG.info(&quot;Async function call has timed out. input:{}, timeOutNum:{}&quot;,input.toString(), timeOðŸ”µ</abbr>
 167         }
 168         timeOutNum ++;
 169         if(sideInfo.getJoinType() == JoinType.LEFT){
 170             resultFuture.complete(null);
 171             return;
 172         }
 173         if(timeOutNum &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)){
<abbr title=" 174             resultFuture.completeExceptionally(new Exception(&quot;Async function call timedoutNum beyond limit.&quot;));"> 174             resultFuture.completeExceptionally(new Exception(&quot;Async function call timedoutNum beyond limiðŸ”µ</abbr>
 175             return;
 176         }
 177         resultFuture.complete(null);
 178     }
 179 
 180     protected void preInvoke(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture)
 181             throws InvocationTargetException, IllegalAccessException {
 182         registerTimerAndAddToHandler(input, resultFuture);
 183     }
 184 
 185     @Override
<abbr title=" 186     public void asyncInvoke(Tuple2&lt;Boolean,Row&gt; row, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws Exception {"> 186     public void asyncInvoke(Tuple2&lt;Boolean,Row&gt; row, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throðŸ”µ</abbr>
 187         Tuple2&lt;Boolean,Row&gt; input = Tuple2.of(row.f0, Row.copy(row.f1));
 188         preInvoke(input, resultFuture);
 189         Map&lt;String, Object&gt; inputParams = parseInputParam(input);
 190         if(MapUtils.isEmpty(inputParams)){
 191             dealMissKey(input, resultFuture);
 192             return;
 193         }
 194         if(isUseCache(inputParams)){
 195             invokeWithCache(inputParams, input, resultFuture);
 196             return;
 197         }
 198         handleAsyncInvoke(inputParams, input, resultFuture);
 199     }
 200 
 201     private Map&lt;String, Object&gt; parseInputParam(Tuple2&lt;Boolean,Row&gt; input){
 202         Map&lt;String, Object&gt; inputParams = Maps.newHashMap();
 203         for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 204             Integer conValIndex = sideInfo.getEqualValIndex().get(i);
 205             Object equalObj = input.f1.getField(conValIndex);
 206             if(equalObj == null){
 207                 return inputParams;
 208             }
 209             String columnName = sideInfo.getEqualFieldList().get(i);
 210             inputParams.put(columnName, equalObj);
 211         }
 212         return inputParams;
 213     }
 214 
 215     protected boolean isUseCache(Map&lt;String, Object&gt; inputParams){
 216         return openCache() &amp;&amp; getFromCache(buildCacheKey(inputParams)) != null;
 217     }
 218 
<abbr title=" 219     private void invokeWithCache(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture){"> 219     private void invokeWithCache(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean,Row&gt; input, ResultFutureðŸ”µ</abbr>
 220         if (openCache()) {
 221             CacheObj val = getFromCache(buildCacheKey(inputParams));
 222             if (val != null) {
 223                 if (ECacheContentType.MissVal == val.getType()) {
 224                     dealMissKey(input, resultFuture);
 225                     return;
 226                 }else if(ECacheContentType.SingleLine == val.getType()){
 227                     try {
 228                         Row row = fillData(input.f1, val.getContent());
 229                         resultFuture.complete(Collections.singleton(Tuple2.of(input.f0, row)));
 230                     } catch (Exception e) {
 231                         dealFillDataError(input, resultFuture, e);
 232                     }
 233                 } else if (ECacheContentType.MultiLine == val.getType()) {
 234                     try {
 235                         List&lt;Tuple2&lt;Boolean,Row&gt;&gt; rowList = Lists.newArrayList();
 236                         for (Object one : (List) val.getContent()) {
 237                             Row row = fillData(input.f1, one);
 238                             rowList.add(Tuple2.of(input.f0, row));
 239                         }
 240                         resultFuture.complete(rowList);
 241                     } catch (Exception e) {
 242                         dealFillDataError(input, resultFuture, e);
 243                     }
 244                 } else {
<abbr title=" 245                     resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot; + val.getType()));"> 245                     resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot;ðŸ”µ</abbr>
 246                 }
 247                 return;
 248             }
 249         }
 250     }
 251 
<abbr title=" 252     public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws Exception;"> 252     public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, Tuple2&lt;Boolean,Row&gt; input, RðŸ”µ</abbr>
 253 
 254     public abstract String buildCacheKey(Map&lt;String, Object&gt; inputParams);
 255 
 256     private ProcessingTimeService getProcessingTimeService(){
 257         return ((StreamingRuntimeContext)this.runtimeContext).getProcessingTimeService();
 258     }
 259 
<abbr title=" 260     protected ScheduledFuture&lt;?&gt; registerTimer(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture){"> 260     protected ScheduledFuture&lt;?&gt; registerTimer(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,RowðŸ”µ</abbr>
<abbr title=" 261         long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService().getCurrentProcessingTime();"> 261         long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService(ðŸ”µ</abbr>
 262         return getProcessingTimeService().registerTimer(
 263                 timeoutTimestamp,
 264                 new ProcessingTimeCallback() {
 265                     @Override
 266                     public void onProcessingTime(long timestamp) throws Exception {
 267                         timeout(input, resultFuture);
 268                     }
 269                 });
 270     }
 271 
 272 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 273     protected void registerTimerAndAddToHandler(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture)"> 273     protected void registerTimerAndAddToHandler(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,RoðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 274             throws InvocationTargetException, IllegalAccessException {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 275         ScheduledFuture&lt;?&gt; timeFuture = registerTimer(input, resultFuture);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 276         // resultFuture æ˜¯ResultHandler çš„å®žä¾‹</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 277         Method setTimeoutTimer = ReflectionUtils.getDeclaredMethod(resultFuture, &quot;setTimeoutTimer&quot;, ScheduledFuture.class);"> 277         Method setTimeoutTimer = ReflectionUtils.getDeclaredMethod(resultFuture, &quot;setTimeoutTimer&quot;, SchedðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 278         setTimeoutTimer.invoke(resultFuture, timeFuture);</span>
 279 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 280             streamRecordBufferEntry.onComplete((Object value) -&gt; {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 281                 timerFuture.cancel(true);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 282             },executors);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 283         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 284     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 285 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 286     protected void dealFillDataError(CRow input, ResultFuture&lt;CRow&gt; resultFuture, Throwable e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 287         parseErrorRecords.inc();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 288         if(parseErrorRecords.getCount() &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)){"> 288         if(parseErrorRecords.getCount() &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE))ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 289             LOG.info(&quot;dealFillDataError&quot;, e);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 290             resultFuture.completeExceptionally(e);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 291         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 292             dealMissKey(input, resultFuture);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 293         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 294     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 295 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 296     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 297     public void close() throws Exception {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 298         super.close();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 299     }</span>
 300 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 301     protected void cancelTimerWhenComplete(ResultFuture&lt;CRow&gt; resultFuture, ScheduledFuture&lt;?&gt; timerFuture){"> 301     protected void cancelTimerWhenComplete(ResultFuture&lt;CRow&gt; resultFuture, ScheduledFuture&lt;?&gt; timerFuturðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 302         if(resultFuture instanceof StreamRecordQueueEntry){</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 303             StreamRecordQueueEntry streamRecordBufferEntry = (StreamRecordQueueEntry) resultFuture;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 304             streamRecordBufferEntry.onComplete((Object value) -&gt; {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 305                 timerFuture.cancel(true);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 306             }, cancelExecutor);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 307         }</span>
 308 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 309     }
 310 
 311 
<abbr title=" 312     protected void dealFillDataError(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture, Throwable e) {"> 312     protected void dealFillDataError(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFðŸ”µ</abbr>
 313         parseErrorRecords.inc();
<abbr title=" 314         if(parseErrorRecords.getCount() &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)){"> 314         if(parseErrorRecords.getCount() &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE))ðŸ”µ</abbr>
 315             LOG.info(&quot;dealFillDataError&quot;, e);
 316             resultFuture.completeExceptionally(e);
 317         } else {
 318             dealMissKey(input, resultFuture);
 319         }
 320     }
 321 
 322     @Override
 323     public void close() throws Exception {
 324         super.close();
 325     }
 326 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.side;
  22 
  23 import com.dtstack.flink.sql.enums.ECacheContentType;
  24 import com.dtstack.flink.sql.enums.ECacheType;
  25 import com.dtstack.flink.sql.factory.DTThreadFactory;
  26 import com.dtstack.flink.sql.metric.MetricConstant;
  27 import com.dtstack.flink.sql.side.cache.AbstractSideCache;
  28 import com.dtstack.flink.sql.side.cache.CacheObj;
  29 import com.dtstack.flink.sql.side.cache.LRUSideCache;
  30 import com.dtstack.flink.sql.util.ReflectionUtils;
  31 import com.google.common.collect.Lists;
  32 import com.google.common.collect.Maps;
  33 import org.apache.calcite.sql.JoinType;
  34 import org.apache.commons.collections.MapUtils;
  35 import org.apache.flink.api.common.functions.RuntimeContext;
  36 import org.apache.flink.api.java.tuple.Tuple2;
  37 import org.apache.flink.configuration.Configuration;
  38 import org.apache.flink.metrics.Counter;
  39 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  40 import org.apache.flink.streaming.api.functions.async.RichAsyncFunction;
  41 import org.apache.flink.streaming.api.operators.StreamingRuntimeContext;
  42 import org.apache.flink.streaming.api.operators.async.AsyncWaitOperator;
  43 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeCallback;
  44 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;
  45 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  46 import org.apache.flink.types.Row;
  47 import org.slf4j.Logger;
  48 import org.slf4j.LoggerFactory;
  49 
  50 import java.lang.reflect.InvocationTargetException;
  51 import java.lang.reflect.Method;
  52 import java.sql.Timestamp;
  53 import java.time.LocalDateTime;
  54 import java.util.Collections;
  55 import java.util.List;
  56 import java.util.Map;
  57 import java.util.concurrent.LinkedBlockingQueue;
  58 import java.util.concurrent.ScheduledFuture;
  59 import java.util.concurrent.ThreadPoolExecutor;
  60 import java.util.concurrent.TimeUnit;
  61 
  62 /**
  63  * All interfaces inherit naming rules: type + &quot;AsyncReqRow&quot; such as == &quot;MysqlAsyncReqRow
  64  * only support Left join / inner join(join),not support right join
  65  * Date: 2018/7/9
  66  * Company: www.dtstack.com
  67  * @author xuchao
  68  */
  69 
<abbr title="  70 public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;Tuple2&lt;Boolean,Row&gt;, Tuple2&lt;Boolean,Row&gt;&gt; implements ISideReqRow {">  70 public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;Tuple2&lt;Boolean,Row&gt;, Tuple2&lt;Boolean,Row&gt;&gt;ðŸ”µ</abbr>
  71     private static final Logger LOG = LoggerFactory.getLogger(BaseAsyncReqRow.class);
  72     private static final long serialVersionUID = 2098635244857937717L;
  73     private RuntimeContext runtimeContext;
  74     private static int TIMEOUT_LOG_FLUSH_NUM = 10;
  75     private int timeOutNum = 0;
  76     protected BaseSideInfo sideInfo;
  77     protected transient Counter parseErrorRecords;
  78     private transient ThreadPoolExecutor cancelExecutor;
  79 
  80     public BaseAsyncReqRow(BaseSideInfo sideInfo){
  81         this.sideInfo = sideInfo;
  82     }
  83     @Override
  84     public void setRuntimeContext(RuntimeContext runtimeContext) {
  85         super.setRuntimeContext(runtimeContext);
  86         this.runtimeContext = runtimeContext;
  87     }
  88     @Override
  89     public void open(Configuration parameters) throws Exception {
  90         super.open(parameters);
  91         initCache();
  92         initMetric();
<abbr title="  93         cancelExecutor = new ThreadPoolExecutor(1, 1, 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;(100000),">  93         cancelExecutor = new ThreadPoolExecutor(1, 1, 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;ðŸ”µ</abbr>
  94                 new DTThreadFactory(&quot;cancel-timer-executor&quot;));
  95         LOG.info(&quot;async dim table config info: {} &quot;, sideInfo.getSideTableInfo().toString());
  96     }
  97 
  98     private void initCache(){
  99         AbstractSideTableInfo sideTableInfo = sideInfo.getSideTableInfo();
<abbr title=" 100         if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheType())){"> 100         if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.ðŸ”µ</abbr>
 101             return;
 102         }
 103 
 104         AbstractSideCache sideCache;
 105         if(ECacheType.LRU.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
 106             sideCache = new LRUSideCache(sideTableInfo);
 107             sideInfo.setSideCache(sideCache);
 108         }else{
<abbr title=" 109             throw new RuntimeException(&quot;not support side cache with type:&quot; + sideTableInfo.getCacheType());"> 109             throw new RuntimeException(&quot;not support side cache with type:&quot; + sideTableInfo.getCacheType()ðŸ”µ</abbr>
 110         }
 111 
 112         sideCache.initCache();
 113     }
 114 
 115     private void initMetric() {
<abbr title=" 116         parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_RECORDS);"> 116         parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSEðŸ”µ</abbr>
 117     }
 118 
 119 
 120     protected Object convertTimeIndictorTypeInfo(Integer index, Object obj) {
<abbr title=" 121         boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(index).getClass());"> 121         boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypðŸ”µ</abbr>
 122 
<abbr title=" 123         //Type information for indicating event or processing time. However, it behaves like a regular SQL timestamp but is serialized as Long."> 123         //Type information for indicating event or processing time. However, it behaves like a regular SQðŸ”µ</abbr>
 124         if (obj instanceof LocalDateTime &amp;&amp; isTimeIndicatorTypeInfo) {
 125             obj = Timestamp.valueOf(((LocalDateTime) obj));
 126         }
 127         return obj;
 128     }
 129 
 130     protected CacheObj getFromCache(String key){
 131         return sideInfo.getSideCache().getFromCache(key);
 132     }
 133 
 134     protected void putCache(String key, CacheObj value){
 135         sideInfo.getSideCache().putCache(key, value);
 136     }
 137 
 138     protected boolean openCache(){
 139         return sideInfo.getSideCache() != null;
 140     }
 141 
<abbr title=" 142     protected void dealMissKey(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture){"> 142     protected void dealMissKey(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture)ðŸ”µ</abbr>
 143         if(sideInfo.getJoinType() == JoinType.LEFT){
 144             //Reserved left table data
 145             try {
 146                 Row row = fillData(input.f1, null);
 147                 resultFuture.complete(Collections.singleton(new Tuple2&lt;&gt;(input.f0, row)));
 148             } catch (Exception e) {
 149                 dealFillDataError(input, resultFuture, e);
 150             }
 151         }else{
 152             resultFuture.complete(null);
 153         }
 154     }
 155 
 156     protected void dealCacheData(String key, CacheObj missKeyObj) {
 157         if (openCache()) {
 158             putCache(key, missKeyObj);
 159         }
 160     }
 161 
 162     @Override
<abbr title=" 163     public void timeout(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws Exception {"> 163     public void timeout(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throwsðŸ”µ</abbr>
 164 
 165         if(timeOutNum % TIMEOUT_LOG_FLUSH_NUM == 0){
<abbr title=" 166             LOG.info(&quot;Async function call has timed out. input:{}, timeOutNum:{}&quot;,input.toString(), timeOutNum);"> 166             LOG.info(&quot;Async function call has timed out. input:{}, timeOutNum:{}&quot;,input.toString(), timeOðŸ”µ</abbr>
 167         }
 168         timeOutNum ++;
 169         if(sideInfo.getJoinType() == JoinType.LEFT){
 170             resultFuture.complete(null);
 171             return;
 172         }
 173         if(timeOutNum &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)){
<abbr title=" 174             resultFuture.completeExceptionally(new Exception(&quot;Async function call timedoutNum beyond limit.&quot;));"> 174             resultFuture.completeExceptionally(new Exception(&quot;Async function call timedoutNum beyond limiðŸ”µ</abbr>
 175             return;
 176         }
 177         resultFuture.complete(null);
 178     }
 179 
 180     protected void preInvoke(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture)
 181             throws InvocationTargetException, IllegalAccessException {
 182         registerTimerAndAddToHandler(input, resultFuture);
 183     }
 184 
 185     @Override
<abbr title=" 186     public void asyncInvoke(Tuple2&lt;Boolean,Row&gt; row, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws Exception {"> 186     public void asyncInvoke(Tuple2&lt;Boolean,Row&gt; row, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throðŸ”µ</abbr>
 187         Tuple2&lt;Boolean,Row&gt; input = Tuple2.of(row.f0, Row.copy(row.f1));
 188         preInvoke(input, resultFuture);
 189         Map&lt;String, Object&gt; inputParams = parseInputParam(input);
 190         if(MapUtils.isEmpty(inputParams)){
 191             dealMissKey(input, resultFuture);
 192             return;
 193         }
 194         if(isUseCache(inputParams)){
 195             invokeWithCache(inputParams, input, resultFuture);
 196             return;
 197         }
 198         handleAsyncInvoke(inputParams, input, resultFuture);
 199     }
 200 
 201     private Map&lt;String, Object&gt; parseInputParam(Tuple2&lt;Boolean,Row&gt; input){
 202         Map&lt;String, Object&gt; inputParams = Maps.newHashMap();
 203         for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 204             Integer conValIndex = sideInfo.getEqualValIndex().get(i);
 205             Object equalObj = input.f1.getField(conValIndex);
 206             if(equalObj == null){
 207                 return inputParams;
 208             }
 209             String columnName = sideInfo.getEqualFieldList().get(i);
 210             inputParams.put(columnName, equalObj);
 211         }
 212         return inputParams;
 213     }
 214 
 215     protected boolean isUseCache(Map&lt;String, Object&gt; inputParams){
 216         return openCache() &amp;&amp; getFromCache(buildCacheKey(inputParams)) != null;
 217     }
 218 
<abbr title=" 219     private void invokeWithCache(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture){"> 219     private void invokeWithCache(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean,Row&gt; input, ResultFutureðŸ”µ</abbr>
 220         if (openCache()) {
 221             CacheObj val = getFromCache(buildCacheKey(inputParams));
 222             if (val != null) {
 223                 if (ECacheContentType.MissVal == val.getType()) {
 224                     dealMissKey(input, resultFuture);
 225                     return;
 226                 }else if(ECacheContentType.SingleLine == val.getType()){
 227                     try {
 228                         Row row = fillData(input.f1, val.getContent());
 229                         resultFuture.complete(Collections.singleton(Tuple2.of(input.f0, row)));
 230                     } catch (Exception e) {
 231                         dealFillDataError(input, resultFuture, e);
 232                     }
 233                 } else if (ECacheContentType.MultiLine == val.getType()) {
 234                     try {
 235                         List&lt;Tuple2&lt;Boolean,Row&gt;&gt; rowList = Lists.newArrayList();
 236                         for (Object one : (List) val.getContent()) {
 237                             Row row = fillData(input.f1, one);
 238                             rowList.add(Tuple2.of(input.f0, row));
 239                         }
 240                         resultFuture.complete(rowList);
 241                     } catch (Exception e) {
 242                         dealFillDataError(input, resultFuture, e);
 243                     }
 244                 } else {
<abbr title=" 245                     resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot; + val.getType()));"> 245                     resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot;ðŸ”µ</abbr>
 246                 }
 247                 return;
 248             }
 249         }
 250     }
 251 
<abbr title=" 252     public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws Exception;"> 252     public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, Tuple2&lt;Boolean,Row&gt; input, RðŸ”µ</abbr>
 253 
 254     public abstract String buildCacheKey(Map&lt;String, Object&gt; inputParams);
 255 
 256     private ProcessingTimeService getProcessingTimeService(){
 257         return ((StreamingRuntimeContext)this.runtimeContext).getProcessingTimeService();
 258     }
 259 
<abbr title=" 260     protected ScheduledFuture&lt;?&gt; registerTimer(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture){"> 260     protected ScheduledFuture&lt;?&gt; registerTimer(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,RowðŸ”µ</abbr>
<abbr title=" 261         long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService().getCurrentProcessingTime();"> 261         long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService(ðŸ”µ</abbr>
 262         return getProcessingTimeService().registerTimer(
 263                 timeoutTimestamp,
 264                 new ProcessingTimeCallback() {
 265                     @Override
 266                     public void onProcessingTime(long timestamp) throws Exception {
 267                         timeout(input, resultFuture);
 268                     }
 269                 });
 270     }
 271 
<abbr title=" 272     protected void registerTimerAndAddToHandler(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture)"> 272     protected void registerTimerAndAddToHandler(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,RoðŸ”µ</abbr>
 273             throws InvocationTargetException, IllegalAccessException {
 274         ScheduledFuture&lt;?&gt; timeFuture = registerTimer(input, resultFuture);
 275         // resultFuture æ˜¯ResultHandler çš„å®žä¾‹
<abbr title=" 276         Method setTimeoutTimer = ReflectionUtils.getDeclaredMethod(resultFuture, &quot;setTimeoutTimer&quot;, ScheduledFuture.class);"> 276         Method setTimeoutTimer = ReflectionUtils.getDeclaredMethod(resultFuture, &quot;setTimeoutTimer&quot;, SchedðŸ”µ</abbr>
 277         setTimeoutTimer.invoke(resultFuture, timeFuture);
 278     }
 279 
 280 
<abbr title=" 281     protected void dealFillDataError(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture, Throwable e) {"> 281     protected void dealFillDataError(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFðŸ”µ</abbr>
 282         parseErrorRecords.inc();
<abbr title=" 283         if(parseErrorRecords.getCount() &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)){"> 283         if(parseErrorRecords.getCount() &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE))ðŸ”µ</abbr>
 284             LOG.info(&quot;dealFillDataError&quot;, e);
 285             resultFuture.completeExceptionally(e);
 286         } else {
 287             dealMissKey(input, resultFuture);
 288         }
 289     }
 290 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
 291 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 292 protected void cancelTimerWhenComplete(ResultFuture&lt;CRow&gt; resultFuture, ScheduledFuture&lt;?&gt; timerFuture){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 293         ThreadPoolExecutor executors = new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());"> 293         ThreadPoolExecutor executors = new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 294         if(resultFuture instanceof StreamRecordQueueEntry){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 295             StreamRecordQueueEntry streamRecordBufferEntry = (StreamRecordQueueEntry) resultFuture;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 296             streamRecordBufferEntry.onComplete((Object value) -&gt; {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 297                 timerFuture.cancel(true);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 298             },executors);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 299         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 300     }</span>
 301 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 302 protected void cancelTimerWhenComplete(ResultFuture&lt;CRow&gt; resultFuture, ScheduledFuture&lt;?&gt; timerFuture){</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 303         if(resultFuture instanceof StreamRecordQueueEntry){</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 304             StreamRecordQueueEntry streamRecordBufferEntry = (StreamRecordQueueEntry) resultFuture;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 305             streamRecordBufferEntry.onComplete((Object value) -&gt; {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 306                 timerFuture.cancel(true);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 307             }, cancelExecutor);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 308         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 309     }</span>
 310 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 311 
 312 
 313     @Override
 314     public void close() throws Exception {
 315         super.close();
 316     }
 317 }
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side;
  19 
  20 import com.dtstack.flink.sql.enums.ECacheContentType;
  21 import com.dtstack.flink.sql.enums.ECacheType;
  22 import com.dtstack.flink.sql.factory.DTThreadFactory;
  23 import com.dtstack.flink.sql.metric.MetricConstant;
  24 import com.dtstack.flink.sql.side.cache.AbstractSideCache;
  25 import com.dtstack.flink.sql.side.cache.CacheObj;
  26 import com.dtstack.flink.sql.side.cache.LRUSideCache;
  27 import com.dtstack.flink.sql.util.ReflectionUtils;
  28 import com.google.common.collect.Lists;
  29 import com.google.common.collect.Maps;
  30 import java.lang.reflect.InvocationTargetException;
  31 import java.lang.reflect.Method;
  32 import java.sql.Timestamp;
  33 import java.time.LocalDateTime;
  34 import java.util.Collections;
  35 import java.util.List;
  36 import java.util.Map;
  37 import java.util.concurrent.LinkedBlockingQueue;
  38 import java.util.concurrent.ScheduledFuture;
  39 import java.util.concurrent.ThreadPoolExecutor;
  40 import java.util.concurrent.TimeUnit;
  41 import org.apache.calcite.sql.JoinType;
  42 import org.apache.commons.collections.MapUtils;
  43 import org.apache.flink.api.common.functions.RuntimeContext;
  44 import org.apache.flink.api.java.tuple.Tuple2;
  45 import org.apache.flink.configuration.Configuration;
  46 import org.apache.flink.metrics.Counter;
  47 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  48 import org.apache.flink.streaming.api.functions.async.RichAsyncFunction;
  49 import org.apache.flink.streaming.api.operators.StreamingRuntimeContext;
  50 import org.apache.flink.streaming.api.operators.async.AsyncWaitOperator;
  51 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeCallback;
  52 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;
  53 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  54 import org.apache.flink.types.Row;
  55 import org.slf4j.Logger;
  56 import org.slf4j.LoggerFactory;
  57 
  58 
  59 /**
  60  * All interfaces inherit naming rules: type + &quot;AsyncReqRow&quot; such as == &quot;MysqlAsyncReqRow
  61  * only support Left join / inner join(join),not support right join
  62  * Date: 2018/7/9
  63  * Company: www.dtstack.com
  64  * @author xuchao
  65  */
<abbr title="  66 public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;Tuple2&lt;Boolean, Row&gt;, Tuple2&lt;Boolean, Row&gt;&gt; implements ISideReqRow {">  66 public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;Tuple2&lt;Boolean, Row&gt;, Tuple2&lt;Boolean, RowðŸ”µ</abbr>
  67     private static final Logger LOG = LoggerFactory.getLogger(BaseAsyncReqRow.class);
  68 
  69     private static final long serialVersionUID = 2098635244857937717L;
  70 
  71     private RuntimeContext runtimeContext;
  72 
  73     private static int TIMEOUT_LOG_FLUSH_NUM = 10;
  74 
  75     private int timeOutNum = 0;
  76 
  77     protected BaseSideInfo sideInfo;
  78 
  79     protected transient Counter parseErrorRecords;
  80 
  81     private transient ThreadPoolExecutor cancelExecutor;
  82 
  83     public BaseAsyncReqRow(BaseSideInfo sideInfo) {
  84         this.sideInfo = sideInfo;
  85     }
  86 
  87     @Override
  88     public void setRuntimeContext(RuntimeContext runtimeContext) {
  89         super.setRuntimeContext(runtimeContext);
  90         this.runtimeContext = runtimeContext;
  91     }
  92 
  93     @Override
  94     public void open(Configuration parameters) throws Exception {
  95         super.open(parameters);
  96         initCache();
  97         initMetric();
<abbr title="  98         cancelExecutor = new ThreadPoolExecutor(1, 1, 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;(100000),">  98         cancelExecutor = new ThreadPoolExecutor(1, 1, 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;ðŸ”µ</abbr>
  99                 new DTThreadFactory(&quot;cancel-timer-executor&quot;));
 100         LOG.info(&quot;async dim table config info: {} &quot;, sideInfo.getSideTableInfo().toString());
 101     }
 102 
 103     private void initCache(){
 104         AbstractSideTableInfo sideTableInfo = sideInfo.getSideTableInfo();
<abbr title=" 105         if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheType())){"> 105         if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.ðŸ”µ</abbr>
 106             return;
 107         }
 108 
 109         AbstractSideCache sideCache;
 110         if(ECacheType.LRU.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
 111             sideCache = new LRUSideCache(sideTableInfo);
 112             sideInfo.setSideCache(sideCache);
 113         }else{
<abbr title=" 114             throw new RuntimeException(&quot;not support side cache with type:&quot; + sideTableInfo.getCacheType());"> 114             throw new RuntimeException(&quot;not support side cache with type:&quot; + sideTableInfo.getCacheType()ðŸ”µ</abbr>
 115         }
 116         sideCache.initCache();
 117     }
 118 
 119     private void initMetric() {
<abbr title=" 120         parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_RECORDS);"> 120         parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSEðŸ”µ</abbr>
 121     }
 122 
 123     protected Object convertTimeIndictorTypeInfo(Integer index, Object obj) {
<abbr title=" 124         boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(index).getClass());"> 124         boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypðŸ”µ</abbr>
 125 
<abbr title=" 126         //Type information for indicating event or processing time. However, it behaves like a regular SQL timestamp but is serialized as Long."> 126         //Type information for indicating event or processing time. However, it behaves like a regular SQðŸ”µ</abbr>
 127         if (obj instanceof LocalDateTime &amp;&amp; isTimeIndicatorTypeInfo) {
 128             obj = Timestamp.valueOf(((LocalDateTime) obj));
 129         }
 130         return obj;
 131     }
 132 
 133     protected CacheObj getFromCache(String key){
 134         return sideInfo.getSideCache().getFromCache(key);
 135     }
 136 
 137     protected void putCache(String key, CacheObj value){
 138         sideInfo.getSideCache().putCache(key, value);
 139     }
 140 
 141     protected boolean openCache(){
 142         return sideInfo.getSideCache() != null;
 143     }
 144 
<abbr title=" 145     protected void dealMissKey(Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture) {"> 145     protected void dealMissKey(Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuturðŸ”µ</abbr>
 146         if (sideInfo.getJoinType() == JoinType.LEFT) {
 147             //Reserved left table data
 148             try {
 149                 Row row = fillData(input.f1, null);
 150                 resultFuture.complete(Collections.singleton(new Tuple2&lt;&gt;(input.f0, row)));
 151             } catch (java.lang.Exception e) {
 152                 dealFillDataError(input, resultFuture, e);
 153             }
 154         } else {
 155             resultFuture.complete(null);
 156         }
 157     }
 158 
 159     protected void dealCacheData(String key, CacheObj missKeyObj) {
 160         if (openCache()) {
 161             putCache(key, missKeyObj);
 162         }
 163     }
 164 
 165     @Override
<abbr title=" 166     public void timeout(Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture) throws Exception {"> 166     public void timeout(Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture) throðŸ”µ</abbr>
 167         if ((timeOutNum % TIMEOUT_LOG_FLUSH_NUM) == 0) {
<abbr title=" 168             LOG.info(&quot;Async function call has timed out. input:{}, timeOutNum:{}&quot;, input.toString(), timeOutNum);"> 168             LOG.info(&quot;Async function call has timed out. input:{}, timeOutNum:{}&quot;, input.toString(), timeðŸ”µ</abbr>
 169         }
 170         timeOutNum++;
 171         if (sideInfo.getJoinType() == JoinType.LEFT) {
 172             resultFuture.complete(null);
 173             return;
 174         }
 175         if (timeOutNum &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)) {
<abbr title=" 176             resultFuture.completeExceptionally(new Exception(&quot;Async function call timedoutNum beyond limit.&quot;));"> 176             resultFuture.completeExceptionally(new Exception(&quot;Async function call timedoutNum beyond limiðŸ”µ</abbr>
 177             return;
 178         }
 179         resultFuture.complete(null);
 180     }
 181 
<abbr title=" 182     protected void preInvoke(Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture) throws InvocationTargetException, IllegalAccessException {"> 182     protected void preInvoke(Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture)ðŸ”µ</abbr>
 183         registerTimerAndAddToHandler(input, resultFuture);
 184     }
 185 
 186     @Override
<abbr title=" 187     public void asyncInvoke(Tuple2&lt;Boolean, Row&gt; row, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture) throws Exception {"> 187     public void asyncInvoke(Tuple2&lt;Boolean, Row&gt; row, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture) thðŸ”µ</abbr>
 188         Tuple2&lt;Boolean, Row&gt; input = Tuple2.of(row.f0, Row.copy(row.f1));
 189         preInvoke(input, resultFuture);
 190         Map&lt;String, Object&gt; inputParams = parseInputParam(input);
 191         if (MapUtils.isEmpty(inputParams)) {
 192             dealMissKey(input, resultFuture);
 193             return;
 194         }
 195         if (isUseCache(inputParams)) {
 196             invokeWithCache(inputParams, input, resultFuture);
 197             return;
 198         }
 199         handleAsyncInvoke(inputParams, input, resultFuture);
 200     }
 201 
 202     private Map&lt;String, Object&gt; parseInputParam(Tuple2&lt;Boolean, Row&gt; input) {
 203         Map&lt;String, Object&gt; inputParams = Maps.newHashMap();
 204         for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 205             Integer conValIndex = sideInfo.getEqualValIndex().get(i);
 206             Object equalObj = input.f1.getField(conValIndex);
 207             if (equalObj == null) {
 208                 return inputParams;
 209             }
 210             String columnName = sideInfo.getEqualFieldList().get(i);
 211             inputParams.put(columnName, equalObj);
 212         }
 213         return inputParams;
 214     }
 215 
 216     protected boolean isUseCache(Map&lt;String, Object&gt; inputParams){
 217         return openCache() &amp;&amp; getFromCache(buildCacheKey(inputParams)) != null;
 218     }
 219 
<abbr title=" 220     private void invokeWithCache(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture) {"> 220     private void invokeWithCache(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFuturðŸ”µ</abbr>
 221         if (openCache()) {
 222             CacheObj val = getFromCache(buildCacheKey(inputParams));
 223             if (val != null) {
 224                 if (ECacheContentType.MissVal == val.getType()) {
 225                     dealMissKey(input, resultFuture);
 226                     return;
 227                 } else if (ECacheContentType.SingleLine == val.getType()) {
 228                     try {
 229                         Row row = fillData(input.f1, val.getContent());
 230                         resultFuture.complete(Collections.singleton(Tuple2.of(input.f0, row)));
 231                     } catch (java.lang.Exception e) {
 232                         dealFillDataError(input, resultFuture, e);
 233                     }
 234                 } else if (ECacheContentType.MultiLine == val.getType()) {
 235                     try {
 236                         List&lt;Tuple2&lt;Boolean, Row&gt;&gt; rowList = Lists.newArrayList();
 237                         for (Object one : ((List) (val.getContent()))) {
 238                             Row row = fillData(input.f1, one);
 239                             rowList.add(Tuple2.of(input.f0, row));
 240                         }
 241                         resultFuture.complete(rowList);
 242                     } catch (java.lang.Exception e) {
 243                         dealFillDataError(input, resultFuture, e);
 244                     }
 245                 } else {
<abbr title=" 246                     resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot; + val.getType()));"> 246                     resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot;ðŸ”µ</abbr>
 247                 }
 248                 return;
 249             }
 250         }
 251     }
 252 
<abbr title=" 253     public abstract void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture) throws Exception;"> 253     public abstract void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, RðŸ”µ</abbr>
 254 
 255     public abstract String buildCacheKey(Map&lt;String, Object&gt; inputParams);
 256 
 257     private ProcessingTimeService getProcessingTimeService(){
 258         return ((StreamingRuntimeContext)this.runtimeContext).getProcessingTimeService();
 259     }
 260 
<abbr title=" 261     protected ScheduledFuture&lt;?&gt; registerTimer(Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture) {"> 261     protected ScheduledFuture&lt;?&gt; registerTimer(Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, RðŸ”µ</abbr>
<abbr title=" 262         long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService().getCurrentProcessingTime();"> 262         long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService(ðŸ”µ</abbr>
 263         return getProcessingTimeService().registerTimer(timeoutTimestamp, new ProcessingTimeCallback() {
 264             @Override
 265             public void onProcessingTime(long timestamp) throws Exception {
 266                 timeout(input, resultFuture);
 267             }
 268         });
 269     }
 270 
<abbr title=" 271     protected void registerTimerAndAddToHandler(Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture) throws InvocationTargetException, IllegalAccessException {"> 271     protected void registerTimerAndAddToHandler(Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, ðŸ”µ</abbr>
 272         ScheduledFuture&lt;?&gt; timeFuture = registerTimer(input, resultFuture);
 273         // resultFuture æ˜¯ResultHandler çš„å®žä¾‹
<abbr title=" 274         Method setTimeoutTimer = ReflectionUtils.getDeclaredMethod(resultFuture, &quot;setTimeoutTimer&quot;, ScheduledFuture.class);"> 274         Method setTimeoutTimer = ReflectionUtils.getDeclaredMethod(resultFuture, &quot;setTimeoutTimer&quot;, SchedðŸ”µ</abbr>
 275         setTimeoutTimer.invoke(resultFuture, timeFuture);
 276     }
 277 
<abbr title=" 278     protected void dealFillDataError(Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture, Throwable e) {"> 278     protected void dealFillDataError(Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resulðŸ”µ</abbr>
 279         parseErrorRecords.inc();
<abbr title=" 280         if (parseErrorRecords.getCount() &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)) {"> 280         if (parseErrorRecords.getCount() &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)ðŸ”µ</abbr>
 281             LOG.info(&quot;dealFillDataError&quot;, e);
 282             resultFuture.completeExceptionally(e);
 283         } else {
 284             dealMissKey(input, resultFuture);
 285         }
 286     }
 287 
 288     @Override
 289     public void close() throws Exception {
 290         super.close();
 291     }
 292 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.side;
  22  
  23  import com.dtstack.flink.sql.enums.ECacheContentType;
  24  import com.dtstack.flink.sql.enums.ECacheType;

  25  import com.dtstack.flink.sql.metric.MetricConstant;
  26  import com.dtstack.flink.sql.side.cache.AbstractSideCache;
  27  import com.dtstack.flink.sql.side.cache.CacheObj;
  28  import com.dtstack.flink.sql.side.cache.LRUSideCache;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 +import com.dtstack.flink.sql.util.ReflectionUtils;</span>
  30  import com.google.common.collect.Lists;
  31  import com.google.common.collect.Maps;
  32  import org.apache.calcite.sql.JoinType;
  33  import org.apache.commons.collections.MapUtils;
  34  import org.apache.flink.api.common.functions.RuntimeContext;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  35 +import org.apache.flink.api.java.tuple.Tuple2;</span>
  36  import org.apache.flink.configuration.Configuration;
  37  import org.apache.flink.metrics.Counter;
  38  import org.apache.flink.streaming.api.functions.async.ResultFuture;
  39  import org.apache.flink.streaming.api.functions.async.RichAsyncFunction;
  40  import org.apache.flink.streaming.api.operators.StreamingRuntimeContext;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  41 -import org.apache.flink.streaming.api.operators.async.queue.StreamRecordQueueEntry;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  42 +import org.apache.flink.streaming.api.operators.async.AsyncWaitOperator;</span>
  43  import org.apache.flink.streaming.runtime.tasks.ProcessingTimeCallback;
  44  import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  45 -import org.apache.flink.table.runtime.types.CRow;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  46 +import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;</span>
  47  import org.apache.flink.types.Row;
  48  import org.slf4j.Logger;
  49  import org.slf4j.LoggerFactory;
  50  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  51 +import java.lang.reflect.InvocationTargetException;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  52 +import java.lang.reflect.Method;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  53 +import java.sql.Timestamp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  54 +import java.time.LocalDateTime;</span>
  55  import java.util.Collections;
  56  import java.util.List;
  57  import java.util.Map;
  58  import java.util.concurrent.LinkedBlockingQueue;
  59  import java.util.concurrent.ScheduledFuture;
  60  import java.util.concurrent.ThreadPoolExecutor;
  61  import java.util.concurrent.TimeUnit;
  62  
  63  /**
  64   * All interfaces inherit naming rules: type + &quot;AsyncReqRow&quot; such as == &quot;MysqlAsyncReqRow
  65   * only support Left join / inner join(join),not support right join
  66   * Date: 2018/7/9
  67   * Company: www.dtstack.com
  68   * @author xuchao
  69   */
  70  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  71 -public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;CRow, CRow&gt; implements ISideReqRow {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="  72 +public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;Tuple2&lt;Boolean,Row&gt;, Tuple2&lt;Boolean,Row&gt;&gt; implements ISideReqRow {">  72 +public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;Tuple2&lt;Boolean,Row&gt;, Tuple2&lt;Boolean,Row&gt;&gt; implemenðŸ”µ</abbr></span>
  73      private static final Logger LOG = LoggerFactory.getLogger(BaseAsyncReqRow.class);
  74      private static final long serialVersionUID = 2098635244857937717L;
  75      private RuntimeContext runtimeContext;
  76      private static int TIMEOUT_LOG_FLUSH_NUM = 10;
  77      private int timeOutNum = 0;
  78      protected BaseSideInfo sideInfo;
  79      protected transient Counter parseErrorRecords;

  80  
  81      public BaseAsyncReqRow(BaseSideInfo sideInfo){
  82          this.sideInfo = sideInfo;
  83      }
  84      @Override
  85      public void setRuntimeContext(RuntimeContext runtimeContext) {
  86          super.setRuntimeContext(runtimeContext);
  87          this.runtimeContext = runtimeContext;
  88      }
  89      @Override
  90      public void open(Configuration parameters) throws Exception {
  91          super.open(parameters);
  92          initCache();
  93          initMetric();


  94          LOG.info(&quot;async dim table config info: {} &quot;, sideInfo.getSideTableInfo().toString());
  95      }
  96  
  97      private void initCache(){
  98          AbstractSideTableInfo sideTableInfo = sideInfo.getSideTableInfo();
<abbr title="  99          if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheType())){">  99          if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheTðŸ”µ</abbr>
 100              return;
 101          }
 102  
 103          AbstractSideCache sideCache;
 104          if(ECacheType.LRU.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
 105              sideCache = new LRUSideCache(sideTableInfo);
 106              sideInfo.setSideCache(sideCache);
 107          }else{
 108              throw new RuntimeException(&quot;not support side cache with type:&quot; + sideTableInfo.getCacheType());
 109          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 110 +</span>
 111          sideCache.initCache();
 112      }
 113  
 114      private void initMetric() {
<abbr title=" 115          parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_RECORDS);"> 115          parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_REðŸ”µ</abbr>
 116      }
 117  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 118 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 119 +    protected Object convertTimeIndictorTypeInfo(Integer index, Object obj) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 120 +        boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(index).getClass());"> 120 +        boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().gðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 121 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 122 +        //Type information for indicating event or processing time. However, it behaves like a regular SQL timestamp but is serialized as Long."> 122 +        //Type information for indicating event or processing time. However, it behaves like a regular SQL timestaðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 123 +        if (obj instanceof LocalDateTime &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 124 +            obj = Timestamp.valueOf(((LocalDateTime) obj));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 125 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 126 +        return obj;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 127 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 128 +</span>
 129      protected CacheObj getFromCache(String key){
 130          return sideInfo.getSideCache().getFromCache(key);
 131      }
 132  
 133      protected void putCache(String key, CacheObj value){
 134          sideInfo.getSideCache().putCache(key, value);
 135      }
 136  
 137      protected boolean openCache(){
 138          return sideInfo.getSideCache() != null;
 139      }
 140  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 141 -    protected void dealMissKey(CRow input, ResultFuture&lt;CRow&gt; resultFuture){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 142 +    protected void dealMissKey(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture){</span>
 143          if(sideInfo.getJoinType() == JoinType.LEFT){
 144              //Reserved left table data
 145              try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 146 -                Row row = fillData(input.row(), null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 147 -                resultFuture.complete(Collections.singleton(new CRow(row, input.change())));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 148 +                Row row = fillData(input.f1, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 149 +                resultFuture.complete(Collections.singleton(new Tuple2&lt;&gt;(input.f0, row)));</span>
 150              } catch (Exception e) {
 151                  dealFillDataError(input, resultFuture, e);
 152              }
 153          }else{
 154              resultFuture.complete(null);
 155          }
 156      }
 157  
 158      protected void dealCacheData(String key, CacheObj missKeyObj) {
 159          if (openCache()) {
 160              putCache(key, missKeyObj);
 161          }
 162      }
 163  
 164      @Override
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 165 -    public void timeout(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 166 +    public void timeout(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws Exception {"> 166 +    public void timeout(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws ExceptioðŸ”µ</abbr></span>
 167  
 168          if(timeOutNum % TIMEOUT_LOG_FLUSH_NUM == 0){
 169              LOG.info(&quot;Async function call has timed out. input:{}, timeOutNum:{}&quot;,input.toString(), timeOutNum);
 170          }
 171          timeOutNum ++;
 172          if(sideInfo.getJoinType() == JoinType.LEFT){
 173              resultFuture.complete(null);
 174              return;
 175          }
 176          if(timeOutNum &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)){
 177              resultFuture.completeExceptionally(new Exception(&quot;Async function call timedoutNum beyond limit.&quot;));
 178              return;
 179          }
 180          resultFuture.complete(null);
 181      }
 182  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 183 -    protected void preInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 184 -        ScheduledFuture&lt;?&gt; timeFuture = registerTimer(input, resultFuture);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 185 -        cancelTimerWhenComplete(resultFuture, timeFuture);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 186 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 187 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 188 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 189 -    public void asyncInvoke(CRow row, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 190 -        CRow input = new CRow(Row.copy(row.row()), row.change());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 191 +    protected void preInvoke(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 192 +            throws InvocationTargetException, IllegalAccessException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 193 +        registerTimerAndAddToHandler(input, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 194 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 195 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 196 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 197 +    public void asyncInvoke(Tuple2&lt;Boolean,Row&gt; row, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws Exception {"> 197 +    public void asyncInvoke(Tuple2&lt;Boolean,Row&gt; row, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws ExceptðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 198 +        Tuple2&lt;Boolean,Row&gt; input = Tuple2.of(row.f0, Row.copy(row.f1));</span>
 199          preInvoke(input, resultFuture);
 200          Map&lt;String, Object&gt; inputParams = parseInputParam(input);
 201          if(MapUtils.isEmpty(inputParams)){
 202              dealMissKey(input, resultFuture);
 203              return;
 204          }
 205          if(isUseCache(inputParams)){
 206              invokeWithCache(inputParams, input, resultFuture);
 207              return;
 208          }
 209          handleAsyncInvoke(inputParams, input, resultFuture);
 210      }
 211  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 212 -    private Map&lt;String, Object&gt; parseInputParam(CRow input){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 213 +    private Map&lt;String, Object&gt; parseInputParam(Tuple2&lt;Boolean,Row&gt; input){</span>
 214          Map&lt;String, Object&gt; inputParams = Maps.newHashMap();
 215          for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 216              Integer conValIndex = sideInfo.getEqualValIndex().get(i);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 217 -            Object equalObj = input.row().getField(conValIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 218 +            Object equalObj = input.f1.getField(conValIndex);</span>
 219              if(equalObj == null){
 220                  return inputParams;
 221              }
 222              String columnName = sideInfo.getEqualFieldList().get(i);
 223              inputParams.put(columnName, equalObj);
 224          }
 225          return inputParams;
 226      }
 227  
 228      protected boolean isUseCache(Map&lt;String, Object&gt; inputParams){
 229          return openCache() &amp;&amp; getFromCache(buildCacheKey(inputParams)) != null;
 230      }
 231  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 232 -    private void invokeWithCache(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 233 +    private void invokeWithCache(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture){"> 233 +    private void invokeWithCache(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;BðŸ”µ</abbr></span>
 234          if (openCache()) {
 235              CacheObj val = getFromCache(buildCacheKey(inputParams));
 236              if (val != null) {
 237                  if (ECacheContentType.MissVal == val.getType()) {
 238                      dealMissKey(input, resultFuture);
 239                      return;
 240                  }else if(ECacheContentType.SingleLine == val.getType()){
 241                      try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 242 -                        Row row = fillData(input.row(), val.getContent());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 243 -                        resultFuture.complete(Collections.singleton(new CRow(row, input.change())));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 244 +                        Row row = fillData(input.f1, val.getContent());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 245 +                        resultFuture.complete(Collections.singleton(Tuple2.of(input.f0, row)));</span>
 246                      } catch (Exception e) {
 247                          dealFillDataError(input, resultFuture, e);
 248                      }
 249                  } else if (ECacheContentType.MultiLine == val.getType()) {
 250                      try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 251 -                        List&lt;CRow&gt; rowList = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 252 +                        List&lt;Tuple2&lt;Boolean,Row&gt;&gt; rowList = Lists.newArrayList();</span>
 253                          for (Object one : (List) val.getContent()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 254 -                            Row row = fillData(input.row(), one);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 255 -                            rowList.add(new CRow(row, input.change()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 256 +                            Row row = fillData(input.f1, one);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 257 +                            rowList.add(Tuple2.of(input.f0, row));</span>
 258                          }
 259                          resultFuture.complete(rowList);
 260                      } catch (Exception e) {
 261                          dealFillDataError(input, resultFuture, e);
 262                      }
 263                  } else {
<abbr title=" 264                      resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot; + val.getType()));"> 264                      resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot; + val.geðŸ”µ</abbr>
 265                  }
 266                  return;
 267              }
 268          }
 269      }
 270  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 271 -    public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception;"> 271 -    public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, CRow input, ResultFuture&lt;CRow&gt; resultðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 272 +    public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws Exception;"> 272 +    public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, Tuple2&lt;Boolean,Row&gt; input, ResultFutuðŸ”µ</abbr></span>
 273  
 274      public abstract String buildCacheKey(Map&lt;String, Object&gt; inputParams);
 275  
 276      private ProcessingTimeService getProcessingTimeService(){
 277          return ((StreamingRuntimeContext)this.runtimeContext).getProcessingTimeService();
 278      }
 279  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 280 -    protected ScheduledFuture&lt;?&gt; registerTimer(CRow input, ResultFuture&lt;CRow&gt; resultFuture){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 281 +    protected ScheduledFuture&lt;?&gt; registerTimer(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture){"> 281 +    protected ScheduledFuture&lt;?&gt; registerTimer(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultðŸ”µ</abbr></span>
<abbr title=" 282          long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService().getCurrentProcessingTime();"> 282          long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService().getCurrðŸ”µ</abbr>
 283          return getProcessingTimeService().registerTimer(
 284                  timeoutTimestamp,
 285                  new ProcessingTimeCallback() {
 286                      @Override
 287                      public void onProcessingTime(long timestamp) throws Exception {
 288                          timeout(input, resultFuture);
 289                      }
 290                  });
 291      }
 292  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 293 -    protected void cancelTimerWhenComplete(ResultFuture&lt;CRow&gt; resultFuture, ScheduledFuture&lt;?&gt; timerFuture){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 294 -        ThreadPoolExecutor executors = new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());"> 294 -        ThreadPoolExecutor executors = new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQuðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 295 -        if(resultFuture instanceof StreamRecordQueueEntry){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 296 -            StreamRecordQueueEntry streamRecordBufferEntry = (StreamRecordQueueEntry) resultFuture;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 297 -            streamRecordBufferEntry.onComplete((Object value) -&gt; {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 298 -                timerFuture.cancel(true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 299 -            },executors);</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 300 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 301 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 302 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 303 -    protected void dealFillDataError(CRow input, ResultFuture&lt;CRow&gt; resultFuture, Throwable e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 304 +    protected void registerTimerAndAddToHandler(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture)"> 304 +    protected void registerTimerAndAddToHandler(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resulðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 305 +            throws InvocationTargetException, IllegalAccessException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 306 +        ScheduledFuture&lt;?&gt; timeFuture = registerTimer(input, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 307 +        // resultFuture æ˜¯ResultHandler çš„å®žä¾‹</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 308 +        Method setTimeoutTimer = ReflectionUtils.getDeclaredMethod(resultFuture, &quot;setTimeoutTimer&quot;, ScheduledFuture.class);"> 308 +        Method setTimeoutTimer = ReflectionUtils.getDeclaredMethod(resultFuture, &quot;setTimeoutTimer&quot;, ScheduledFuturðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 309 +        setTimeoutTimer.invoke(resultFuture, timeFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 310 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 311 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 312 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 313 +    protected void dealFillDataError(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture, Throwable e) {"> 313 +    protected void dealFillDataError(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture, ThðŸ”µ</abbr></span>
 314          parseErrorRecords.inc();
 315          if(parseErrorRecords.getCount() &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)){
 316              LOG.info(&quot;dealFillDataError&quot;, e);
 317              resultFuture.completeExceptionally(e);
 318          } else {
 319              dealMissKey(input, resultFuture);
 320          }
 321      }
 322  
 323      @Override
 324      public void close() throws Exception {
 325          super.close();
 326      }
 327  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.side;
  22  
  23  import com.dtstack.flink.sql.enums.ECacheContentType;
  24  import com.dtstack.flink.sql.enums.ECacheType;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  25 +import com.dtstack.flink.sql.factory.DTThreadFactory;</span>
  26  import com.dtstack.flink.sql.metric.MetricConstant;
  27  import com.dtstack.flink.sql.side.cache.AbstractSideCache;
  28  import com.dtstack.flink.sql.side.cache.CacheObj;
  29  import com.dtstack.flink.sql.side.cache.LRUSideCache;

  30  import com.google.common.collect.Lists;
  31  import com.google.common.collect.Maps;
  32  import org.apache.calcite.sql.JoinType;
  33  import org.apache.commons.collections.MapUtils;
  34  import org.apache.flink.api.common.functions.RuntimeContext;

  35  import org.apache.flink.configuration.Configuration;
  36  import org.apache.flink.metrics.Counter;
  37  import org.apache.flink.streaming.api.functions.async.ResultFuture;
  38  import org.apache.flink.streaming.api.functions.async.RichAsyncFunction;
  39  import org.apache.flink.streaming.api.operators.StreamingRuntimeContext;
  40  import org.apache.flink.streaming.api.operators.async.queue.StreamRecordQueueEntry;

  41  import org.apache.flink.streaming.runtime.tasks.ProcessingTimeCallback;
  42  import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;
  43  import org.apache.flink.table.runtime.types.CRow;

  44  import org.apache.flink.types.Row;
  45  import org.slf4j.Logger;
  46  import org.slf4j.LoggerFactory;
  47  




  48  import java.util.Collections;
  49  import java.util.List;
  50  import java.util.Map;
  51  import java.util.concurrent.LinkedBlockingQueue;
  52  import java.util.concurrent.ScheduledFuture;
  53  import java.util.concurrent.ThreadPoolExecutor;
  54  import java.util.concurrent.TimeUnit;
  55  
  56  /**
  57   * All interfaces inherit naming rules: type + &quot;AsyncReqRow&quot; such as == &quot;MysqlAsyncReqRow
  58   * only support Left join / inner join(join),not support right join
  59   * Date: 2018/7/9
  60   * Company: www.dtstack.com
  61   * @author xuchao
  62   */
  63  
  64  public abstract class BaseAsyncReqRow extends RichAsyncFunction&lt;CRow, CRow&gt; implements ISideReqRow {

  65      private static final Logger LOG = LoggerFactory.getLogger(BaseAsyncReqRow.class);
  66      private static final long serialVersionUID = 2098635244857937717L;
  67      private RuntimeContext runtimeContext;
  68      private static int TIMEOUT_LOG_FLUSH_NUM = 10;
  69      private int timeOutNum = 0;
  70      protected BaseSideInfo sideInfo;
  71      protected transient Counter parseErrorRecords;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  72 +    private transient ThreadPoolExecutor cancelExecutor;</span>
  73  
  74      public BaseAsyncReqRow(BaseSideInfo sideInfo){
  75          this.sideInfo = sideInfo;
  76      }
  77      @Override
  78      public void setRuntimeContext(RuntimeContext runtimeContext) {
  79          super.setRuntimeContext(runtimeContext);
  80          this.runtimeContext = runtimeContext;
  81      }
  82      @Override
  83      public void open(Configuration parameters) throws Exception {
  84          super.open(parameters);
  85          initCache();
  86          initMetric();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  87 +        cancelExecutor = new ThreadPoolExecutor(1, 1, 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;(100000),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  88 +                new DTThreadFactory(&quot;cancel-timer-executor&quot;));</span>
  89          LOG.info(&quot;async dim table config info: {} &quot;, sideInfo.getSideTableInfo().toString());
  90      }
  91  
  92      private void initCache(){
  93          AbstractSideTableInfo sideTableInfo = sideInfo.getSideTableInfo();
<abbr title="  94          if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheType())){">  94          if(sideTableInfo.getCacheType() == null || ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheTðŸ”µ</abbr>
  95              return;
  96          }
  97  
  98          AbstractSideCache sideCache;
  99          if(ECacheType.LRU.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
 100              sideCache = new LRUSideCache(sideTableInfo);
 101              sideInfo.setSideCache(sideCache);
 102          }else{
 103              throw new RuntimeException(&quot;not support side cache with type:&quot; + sideTableInfo.getCacheType());
 104          }

 105          sideCache.initCache();
 106      }
 107  
 108      private void initMetric() {
<abbr title=" 109          parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_RECORDS);"> 109          parseErrorRecords = getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_REðŸ”µ</abbr>
 110      }
 111  











 112      protected CacheObj getFromCache(String key){
 113          return sideInfo.getSideCache().getFromCache(key);
 114      }
 115  
 116      protected void putCache(String key, CacheObj value){
 117          sideInfo.getSideCache().putCache(key, value);
 118      }
 119  
 120      protected boolean openCache(){
 121          return sideInfo.getSideCache() != null;
 122      }
 123  
 124      protected void dealMissKey(CRow input, ResultFuture&lt;CRow&gt; resultFuture){

 125          if(sideInfo.getJoinType() == JoinType.LEFT){
 126              //Reserved left table data
 127              try {
 128                  Row row = fillData(input.row(), null);
 129                  resultFuture.complete(Collections.singleton(new CRow(row, input.change())));


 130              } catch (Exception e) {
 131                  dealFillDataError(input, resultFuture, e);
 132              }
 133          }else{
 134              resultFuture.complete(null);
 135          }
 136      }
 137  
 138      protected void dealCacheData(String key, CacheObj missKeyObj) {
 139          if (openCache()) {
 140              putCache(key, missKeyObj);
 141          }
 142      }
 143  
 144      @Override
 145      public void timeout(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {

 146  
 147          if(timeOutNum % TIMEOUT_LOG_FLUSH_NUM == 0){
 148              LOG.info(&quot;Async function call has timed out. input:{}, timeOutNum:{}&quot;,input.toString(), timeOutNum);
 149          }
 150          timeOutNum ++;
 151          if(sideInfo.getJoinType() == JoinType.LEFT){
 152              resultFuture.complete(null);
 153              return;
 154          }
 155          if(timeOutNum &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)){
 156              resultFuture.completeExceptionally(new Exception(&quot;Async function call timedoutNum beyond limit.&quot;));
 157              return;
 158          }
 159          resultFuture.complete(null);
 160      }
 161  
 162      protected void preInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
 163          ScheduledFuture&lt;?&gt; timeFuture = registerTimer(input, resultFuture);
 164          cancelTimerWhenComplete(resultFuture, timeFuture);
 165      }
 166  
 167      @Override
 168      public void asyncInvoke(CRow row, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {
 169          CRow input = new CRow(Row.copy(row.row()), row.change());








 170          preInvoke(input, resultFuture);
 171          Map&lt;String, Object&gt; inputParams = parseInputParam(input);
 172          if(MapUtils.isEmpty(inputParams)){
 173              dealMissKey(input, resultFuture);
 174              return;
 175          }
 176          if(isUseCache(inputParams)){
 177              invokeWithCache(inputParams, input, resultFuture);
 178              return;
 179          }
 180          handleAsyncInvoke(inputParams, input, resultFuture);
 181      }
 182  
 183      private Map&lt;String, Object&gt; parseInputParam(CRow input){

 184          Map&lt;String, Object&gt; inputParams = Maps.newHashMap();
 185          for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 186              Integer conValIndex = sideInfo.getEqualValIndex().get(i);
 187              Object equalObj = input.row().getField(conValIndex);

 188              if(equalObj == null){
 189                  return inputParams;
 190              }
 191              String columnName = sideInfo.getEqualFieldList().get(i);
 192              inputParams.put(columnName, equalObj);
 193          }
 194          return inputParams;
 195      }
 196  
 197      protected boolean isUseCache(Map&lt;String, Object&gt; inputParams){
 198          return openCache() &amp;&amp; getFromCache(buildCacheKey(inputParams)) != null;
 199      }
 200  
 201      private void invokeWithCache(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){

 202          if (openCache()) {
 203              CacheObj val = getFromCache(buildCacheKey(inputParams));
 204              if (val != null) {
 205                  if (ECacheContentType.MissVal == val.getType()) {
 206                      dealMissKey(input, resultFuture);
 207                      return;
 208                  }else if(ECacheContentType.SingleLine == val.getType()){
 209                      try {
 210                          Row row = fillData(input.row(), val.getContent());
 211                          resultFuture.complete(Collections.singleton(new CRow(row, input.change())));


 212                      } catch (Exception e) {
 213                          dealFillDataError(input, resultFuture, e);
 214                      }
 215                  } else if (ECacheContentType.MultiLine == val.getType()) {
 216                      try {
 217                          List&lt;CRow&gt; rowList = Lists.newArrayList();

 218                          for (Object one : (List) val.getContent()) {
 219                              Row row = fillData(input.row(), one);
 220                              rowList.add(new CRow(row, input.change()));


 221                          }
 222                          resultFuture.complete(rowList);
 223                      } catch (Exception e) {
 224                          dealFillDataError(input, resultFuture, e);
 225                      }
 226                  } else {
<abbr title=" 227                      resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot; + val.getType()));"> 227                      resultFuture.completeExceptionally(new RuntimeException(&quot;not support cache obj type &quot; + val.geðŸ”µ</abbr>
 228                  }
 229                  return;
 230              }
 231          }
 232      }
 233  
<abbr title=" 234      public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception;"> 234      public abstract void handleAsyncInvoke(Map&lt;String, Object&gt;  inputParams, CRow input, ResultFuture&lt;CRow&gt; resultðŸ”µ</abbr>

 235  
 236      public abstract String buildCacheKey(Map&lt;String, Object&gt; inputParams);
 237  
 238      private ProcessingTimeService getProcessingTimeService(){
 239          return ((StreamingRuntimeContext)this.runtimeContext).getProcessingTimeService();
 240      }
 241  
 242      protected ScheduledFuture&lt;?&gt; registerTimer(CRow input, ResultFuture&lt;CRow&gt; resultFuture){

<abbr title=" 243          long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService().getCurrentProcessingTime();"> 243          long timeoutTimestamp = sideInfo.getSideTableInfo().getAsyncTimeout() + getProcessingTimeService().getCurrðŸ”µ</abbr>
 244          return getProcessingTimeService().registerTimer(
 245                  timeoutTimestamp,
 246                  new ProcessingTimeCallback() {
 247                      @Override
 248                      public void onProcessingTime(long timestamp) throws Exception {
 249                          timeout(input, resultFuture);
 250                      }
 251                  });
 252      }
 253  
 254      protected void cancelTimerWhenComplete(ResultFuture&lt;CRow&gt; resultFuture, ScheduledFuture&lt;?&gt; timerFuture){
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 255 -        ThreadPoolExecutor executors = new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());"> 255 -        ThreadPoolExecutor executors = new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQuðŸ”µ</abbr></span>
 256          if(resultFuture instanceof StreamRecordQueueEntry){
 257              StreamRecordQueueEntry streamRecordBufferEntry = (StreamRecordQueueEntry) resultFuture;
 258              streamRecordBufferEntry.onComplete((Object value) -&gt; {
 259                  timerFuture.cancel(true);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 260 -            },executors);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 261 +            }, cancelExecutor);</span>
 262          }
 263      }
 264  
 265      protected void dealFillDataError(CRow input, ResultFuture&lt;CRow&gt; resultFuture, Throwable e) {










 266          parseErrorRecords.inc();
 267          if(parseErrorRecords.getCount() &gt; sideInfo.getSideTableInfo().getAsyncFailMaxNum(Long.MAX_VALUE)){
 268              LOG.info(&quot;dealFillDataError&quot;, e);
 269              resultFuture.completeExceptionally(e);
 270          } else {
 271              dealMissKey(input, resultFuture);
 272          }
 273      }
 274  
 275      @Override
 276      public void close() throws Exception {
 277          super.close();
 278      }
 279  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            