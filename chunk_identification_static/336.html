<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>336</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    336
                    <a href="335.html">prev</a>
                    <a href="337.html">next</a>
                    <a href="336_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_f7d94b0cb7419e571db1874a7057f7fbba096a17_impala/impala-sink/src/main/java/com/dtstack/flink/sql/sink/impala/ImpalaOutputFormat.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;f7d94b0cb7419e571db1874a7057f7fbba096a17:impala/impala-sink/src/main/java/com/dtstack/flink/sql/sink/impala/ImpalaOutputFormat.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;f7d94b0cb7419e571db1874a7057f7fbba096a17^1:impala/impala-sink/src/main/java/com/dtstack/flink/sql/sink/impala/ImpalaOutputFormat.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;f7d94b0cb7419e571db1874a7057f7fbba096a17^2:impala/impala-sink/src/main/java/com/dtstack/flink/sql/sink/impala/ImpalaOutputFormat.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;c46cb5c6d0d0b3ed0124fd05b1e4a0e71984bd54:impala/impala-sink/src/main/java/com/dtstack/flink/sql/sink/impala/ImpalaOutputFormat.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b]], subset: [[b], [b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.sink.impala;
  20 
  21 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  22 import com.dtstack.flink.sql.classloader.ClassLoaderManager;</span>
  23 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  24 import com.dtstack.flink.sql.factory.DTThreadFactory;</span>
  25 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  26 import com.dtstack.flink.sql.exception.ExceptionTrace;</span>
  27 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  28 import com.dtstack.flink.sql.factory.DTThreadFactory;
  29 import com.dtstack.flink.sql.outputformat.AbstractDtRichOutputFormat;
  30 import com.dtstack.flink.sql.sink.rdb.JDBCTypeConvertUtils;
  31 import com.dtstack.flink.sql.table.AbstractTableInfo;
  32 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
  33 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  34 import com.dtstack.flink.sql.util.KrbUtils;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  35 import com.google.common.collect.Maps;</span>
  36 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  37 import com.dtstack.flink.sql.util.DtStringUtil;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  38 import com.dtstack.flink.sql.util.JDBCUtils;</span>
  39 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  40 import com.dtstack.flink.sql.util.KrbUtils;
  41 import com.google.common.collect.Maps;
  42 import org.apache.commons.collections.CollectionUtils;
  43 import org.apache.flink.api.java.tuple.Tuple2;
  44 import org.apache.flink.configuration.Configuration;
  45 import org.apache.flink.types.Row;
  46 import org.apache.hadoop.security.UserGroupInformation;
  47 import org.slf4j.Logger;
  48 import org.slf4j.LoggerFactory;
  49 
  50 import java.io.IOException;
  51 import java.security.PrivilegedExceptionAction;
  52 import java.sql.Connection;
  53 import java.sql.DriverManager;
  54 import java.sql.PreparedStatement;
  55 import java.sql.SQLException;
  56 import java.sql.Statement;
  57 import java.util.ArrayList;
  58 import java.util.HashMap;
  59 import java.util.List;
  60 import java.util.Map;
  61 import java.util.Objects;
  62 import java.util.Set;
  63 import java.util.concurrent.ScheduledExecutorService;
  64 import java.util.concurrent.ScheduledFuture;
  65 import java.util.concurrent.ScheduledThreadPoolExecutor;
  66 import java.util.concurrent.TimeUnit;
  67 import java.util.regex.Matcher;
  68 import java.util.regex.Pattern;
  69 import java.util.stream.Collectors;
  70 
  71 import static com.dtstack.flink.sql.sink.rdb.JDBCTypeConvertUtils.setRecordToStatement;
  72 import static org.apache.flink.util.Preconditions.checkNotNull;
  73 
  74 /**
  75  * Date: 2020/10/14
  76  * Company: www.dtstack.com
  77  *
  78  * @author tiezhu
  79  */
  80 public class ImpalaOutputFormat extends AbstractDtRichOutputFormat&lt;Tuple2&lt;Boolean, Row&gt;&gt; {
  81 
  82     private static final Logger LOG = LoggerFactory.getLogger(ImpalaOutputFormat.class);
  83 
  84     private static final long serialVersionUID = 1L;
  85 
  86     // ${field}
  87     private static final Pattern STATIC_PARTITION_PATTERN = Pattern.compile(&quot;\\$\\{([^}]*)}&quot;);
  88     //specific type which values need to be quoted
  89     private static final String[] NEED_QUOTE_TYPE = {&quot;string&quot;, &quot;timestamp&quot;, &quot;varchar&quot;};
  90 
  91     private static final Integer DEFAULT_CONN_TIME_OUT = 60;
  92     private static final int RECEIVE_DATA_PRINT_FREQUENCY = 1000;
  93     private static final int DIRTY_DATA_PRINT_FREQUENCY = 1000;
  94 
  95     private static final String KUDU_TYPE = &quot;kudu&quot;;
  96     private static final String UPDATE_MODE = &quot;update&quot;;
  97     private static final String PARTITION_CONSTANT = &quot;PARTITION&quot;;
  98     private static final String DRIVER_NAME = &quot;com.cloudera.impala.jdbc41.Driver&quot;;
  99 
 100     private static final String VALUES_CONDITION = &quot;${valuesCondition}&quot;;
 101     private static final String PARTITION_CONDITION = &quot;${partitionCondition}&quot;;
 102     private static final String TABLE_FIELDS_CONDITION = &quot;${tableFieldsCondition}&quot;;
 103     private static final String NO_PARTITION = &quot;noPartition&quot;;
 104     // partition field of static partition which matched by ${field}
 105     private final List&lt;String&gt; staticPartitionFields = new ArrayList&lt;&gt;();
 106     public List&lt;String&gt; fieldNames;
 107     public List&lt;String&gt; fieldTypes;
 108     public List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfoList;
 109     protected transient Connection connection;
 110     protected transient Statement statement;
 111     protected transient PreparedStatement updateStatement;
 112     protected String keytabPath;
 113     protected String krb5confPath;
 114     protected String principal;
 115     protected Integer authMech;
 116     protected String dbUrl;
 117     protected String userName;
 118     protected String password;
 119     protected int batchSize = 100;
 120     protected long batchWaitInterval = 60 * 1000L;
 121     protected String tableName;
 122     protected List&lt;String&gt; primaryKeys;
 123     protected String partitionFields;
 124     protected Boolean enablePartition;
 125     protected String schema;
 126     protected String storeType;
 127     protected String updateMode;
 128     private transient volatile boolean closed = false;
 129     private int batchCount = 0;
 130     // |------------------------------------------------|
 131     // |   partitionCondition   |Array of valueCondition|
 132     // |------------------------------------------------|
 133     // | ptOne, ptTwo, ptThree  | [(v1, v2, v3, v4, v5)]|   DP
 134     // |------------------------------------------------|
 135     // | ptOne = v1, ptTwo = v2 | [(v3, v4, v5)]        |   SP
 136     // |------------------------------------------------|
 137     // | ptOne, ptTwo = v2      | [(v1, v3, v4, v5)]    |   DP and SP
 138     // |------------------------------------------------|
 139     // | noPartition            | [(v1, v2, v3, v4, v5)]|   kudu or disablePartition
 140     // |------------------------------------------------|
 141     private transient Map&lt;String, ArrayList&lt;String&gt;&gt; rowDataMap;
 142     // valueFieldsName -&gt; 重组之后的fieldNames，为了重组row data字段值对应
 143     // 需要对partition字段做特殊处理，比如原来的字段顺序为(age, name, id)，但是因为partition，写入的SQL为
 144     // INSERT INTO tableName(name, id) PARTITION(age) VALUES(?, ?, ?)
 145     // 那么实际executeSql设置字段的顺序应该为(name, id, age)，同时，字段对应的type顺序也需要重组
 146     private List&lt;String&gt; valueFieldNames;
 147     private transient AbstractDtRichOutputFormat&lt;?&gt; metricOutputFormat;
 148     private List&lt;Row&gt; rows;
 149 
 150     private transient ScheduledExecutorService scheduler;
 151     private transient ScheduledFuture&lt;?&gt; scheduledFuture;
 152 
 153     public static Builder getImpalaBuilder() {
 154         return new Builder();
 155     }
 156 
 157     @Override
 158     public void configure(Configuration parameters) {
 159     }
 160 
 161     @Override
 162     public void open(int taskNumber, int numTasks) throws IOException {
 163         try {
 164             rowDataMap = new HashMap&lt;&gt;();
 165             rows = new ArrayList&lt;&gt;();
 166             metricOutputFormat = this;
 167             openConnect();
 168             initScheduledTask(batchWaitInterval);
 169             init();
 170             initMetric();
 171         } catch (Exception e) {
 172             throw new RuntimeException(&quot;impala output format open error!&quot;, e);
 173         }
 174     }
 175 
 176     private void init() throws SQLException {
 177         if (Objects.nonNull(partitionFields)) {
 178             // match ${field} from partitionFields
 179             Matcher matcher = STATIC_PARTITION_PATTERN.matcher(partitionFields);
 180             while (matcher.find()) {
 181                 LOG.info(&quot;find static partition field: {}&quot;, matcher.group(1));
 182                 staticPartitionFields.add(matcher.group(1));
 183             }
 184         }
 185 
 186         if (updateMode.equalsIgnoreCase(UPDATE_MODE)) {
 187             if (!storeType.equalsIgnoreCase(KUDU_TYPE)) {
 188                 throw new IllegalArgumentException(&quot;update mode not support for non-kudu table!&quot;);
 189             }
<abbr title=" 190             updateStatement = connection.prepareStatement(buildUpdateSql(schema, tableName, fieldNames, primaryKeys));"> 190             updateStatement = connection.prepareStatement(buildUpdateSql(schema, tableName, fieldNames, p🔵</abbr>
 191         } else {
<abbr title=" 192             valueFieldNames = rebuildFieldNameListAndTypeList(fieldNames, staticPartitionFields, fieldTypes, partitionFields);"> 192             valueFieldNames = rebuildFieldNameListAndTypeList(fieldNames, staticPartitionFields, fieldTyp🔵</abbr>
 193         }
 194 
 195     }
 196 
 197     private void initScheduledTask(Long batchWaitInterval) {
 198         try {
 199             if (batchWaitInterval != 0) {
 200                 this.scheduler = new ScheduledThreadPoolExecutor(1,
 201                         new DTThreadFactory(&quot;impala-upsert-output-format&quot;));
 202                 this.scheduledFuture = this.scheduler.scheduleWithFixedDelay(() -&gt; {
 203                     synchronized (ImpalaOutputFormat.this) {
 204                         flush();
 205                     }
 206                 }, batchWaitInterval, batchWaitInterval, TimeUnit.MILLISECONDS);
 207             }
 208         } catch (Exception e) {
 209             throw new RuntimeException(e);
 210         }
 211     }
 212 
 213     private void openConnect() throws IOException {
 214         if (authMech == 1) {
 215             UserGroupInformation ugi = KrbUtils.loginAndReturnUgi(principal, keytabPath, krb5confPath);
 216             try {
 217                 ugi.doAs((PrivilegedExceptionAction&lt;Void&gt;) () -&gt; {
 218                     openJdbc();
 219                     return null;
 220                 });
 221             } catch (InterruptedException | IOException e) {
 222                 throw new IllegalArgumentException(&quot;connect impala error!&quot;, e);
 223             }
 224         } else {
 225             openJdbc();
 226         }
 227     }
 228 
 229     /**
 230      * get jdbc connection
 231      */
 232     private void openJdbc() {
 233         ClassLoaderManager.forName(DRIVER_NAME, getClass().getClassLoader());
 234         try {
 235             connection = DriverManager.getConnection(dbUrl, userName, password);
 236             statement = connection.createStatement();
 237             connection.setAutoCommit(false);
 238         } catch (SQLException sqlException) {
 239             throw new RuntimeException(&quot;get impala jdbc connection failed!&quot;, sqlException);
 240         }
 241     }
 242 
 243     private synchronized void flush() {
 244         try {
 245             if (batchCount &gt; 0) {
 246                 if (updateMode.equalsIgnoreCase(UPDATE_MODE)) {
 247                     executeUpdateBatch();
 248                 }
 249                 if (!rowDataMap.isEmpty()) {
 250                     String templateSql =
<abbr title=" 251                         &quot;INSERT INTO tableName ${tableFieldsCondition} PARTITION ${partitionCondition} VALUES ${valuesCondition}&quot;;"> 251                         &quot;INSERT INTO tableName ${tableFieldsCondition} PARTITION ${partitionCondition} VA🔵</abbr>
 252                     executeBatchSql(
 253                         templateSql,
 254                         schema,
 255                         tableName,
 256                         storeType,
 257                         enablePartition,
 258                         valueFieldNames,
 259                         partitionFields,
 260                         rowDataMap
 261                     );
 262                     rowDataMap.clear();
 263                 }
 264             }
 265             batchCount = 0;
 266         } catch (Exception e) {
 267             LOG.error(&quot;Writing records to impala jdbc failed.&quot;, e);
 268             throw new RuntimeException(&quot;Writing records to impala jdbc failed.&quot;, e);
 269         }
 270     }
 271 
 272     /**
 273      * execute batch update statement
 274      *
 275      * @throws SQLException throw sql exception
 276      */
 277     private void executeUpdateBatch() throws SQLException {
 278         try {
 279             rows.forEach(row -&gt; {
 280                 try {
 281                     JDBCTypeConvertUtils.setRecordToStatement(
 282                             updateStatement,
 283                             JDBCTypeConvertUtils.getSqlTypeFromFieldType(fieldTypes),
 284                             row,
 285                             primaryKeys.stream().mapToInt(fieldNames::indexOf).toArray()
 286                     );
 287                     updateStatement.addBatch();
 288                 } catch (Exception e) {
 289                     throw new RuntimeException(&quot;impala jdbc execute batch error!&quot;, e);
 290                 }
 291             });
 292             updateStatement.executeBatch();
 293             connection.commit();
 294             rows.clear();
 295         } catch (Exception e) {
 296             LOG.debug(&quot;impala jdbc execute batch error &quot;, e);
 297             JDBCUtils.rollBack(connection);
 298             JDBCUtils.commit(connection);
 299             updateStatement.clearBatch();
 300             executeUpdate(connection);
 301         }
 302     }
 303 
 304     public void executeUpdate(Connection connection) {
 305         rows.forEach(row -&gt; {
 306             try {
<abbr title=" 307                 setRecordToStatement(updateStatement, JDBCTypeConvertUtils.getSqlTypeFromFieldType(fieldTypes), row);"> 307                 setRecordToStatement(updateStatement, JDBCTypeConvertUtils.getSqlTypeFromFieldType(fieldT🔵</abbr>
 308                 updateStatement.executeUpdate();
 309                 JDBCUtils.commit(connection);
 310             } catch (Exception e) {
 311                 JDBCUtils.rollBack(connection);
 312                 JDBCUtils.commit(connection);
<abbr title=" 313                 if (metricOutputFormat.outDirtyRecords.getCount() % DIRTY_DATA_PRINT_FREQUENCY == 0 || LOG.isDebugEnabled()) {"> 313                 if (metricOutputFormat.outDirtyRecords.getCount() % DIRTY_DATA_PRINT_FREQUENCY == 0 || LO🔵</abbr>
 314                     LOG.error(&quot;record insert failed ,this row is {}&quot;, row.toString());
 315                     LOG.error(&quot;&quot;, e);
 316                 }
 317                 metricOutputFormat.outDirtyRecords.inc();
 318             }
 319         });
 320         rows.clear();
 321     }
 322 
<abbr title=" 323     private void putRowIntoMap(Map&lt;String, ArrayList&lt;String&gt;&gt; rowDataMap, Tuple2&lt;String, String&gt; rowData) {"> 323     private void putRowIntoMap(Map&lt;String, ArrayList&lt;String&gt;&gt; rowDataMap, Tuple2&lt;String, String&gt; rowData)🔵</abbr>
 324         Set&lt;String&gt; keySet = rowDataMap.keySet();
 325         ArrayList&lt;String&gt; tempRowArray;
 326         if (keySet.contains(rowData.f0)) {
 327             tempRowArray = rowDataMap.get(rowData.f0);
 328         } else {
 329             tempRowArray = new ArrayList&lt;&gt;();
 330         }
 331         tempRowArray.add(rowData.f1);
 332         rowDataMap.put(rowData.f0, tempRowArray);
 333     }
 334 
<abbr title=" 335     private List&lt;String&gt; rebuildFieldNameListAndTypeList(List&lt;String&gt; fieldNames, List&lt;String&gt; staticPartitionFields, List&lt;String&gt; fieldTypes, String partitionFields) {"> 335     private List&lt;String&gt; rebuildFieldNameListAndTypeList(List&lt;String&gt; fieldNames, List&lt;String&gt; staticPart🔵</abbr>
 336         if (partitionFields == null || partitionFields.isEmpty()) {
 337             return fieldNames;
 338         }
 339 
 340         List&lt;String&gt; valueFields = new ArrayList&lt;&gt;(fieldNames);
 341 
 342         for (int i = valueFields.size() - 1; i &gt;= 0; i--) {
 343             if (staticPartitionFields.contains(fieldNames.get(i))) {
 344                 valueFields.remove(i);
 345                 fieldTypes.remove(i);
 346             }
 347         }
 348 
 349         for (int i = 0; i &lt; valueFields.size(); i++) {
 350             if (partitionFields.contains(fieldNames.get(i))) {
 351                 valueFields.add(valueFields.remove(i));
 352                 fieldTypes.add(fieldTypes.remove(i));
 353             }
 354         }
 355 
 356         return valueFields;
 357     }
 358 
 359     @Override
 360     public void writeRecord(Tuple2&lt;Boolean, Row&gt; record) throws IOException {
 361         try {
 362             if (!record.f0) {
 363                 return;
 364             }
 365 
 366             if (outRecords.getCount() % RECEIVE_DATA_PRINT_FREQUENCY == 0 || LOG.isDebugEnabled()) {
 367                 LOG.info(&quot;Receive data : {}&quot;, record);
 368             }
 369 
 370             if (updateMode.equalsIgnoreCase(UPDATE_MODE)) {
 371                 rows.add(Row.copy(record.f1));
 372             } else {
 373                 Map&lt;String, Object&gt; valueMap = Maps.newHashMap();
 374                 Row row = Row.copy(record.f1);
 375 
 376                 for (int i = 0; i &lt; row.getArity(); i++) {
 377                     valueMap.put(fieldNames.get(i), row.getField(i));
 378                 }
 379 
 380                 Tuple2&lt;String, String&gt; rowTuple2 = new Tuple2&lt;&gt;();
 381                 if (storeType.equalsIgnoreCase(KUDU_TYPE) || !enablePartition) {
 382                     rowTuple2.f0 = NO_PARTITION;
 383                 } else {
<abbr title=" 384                     rowTuple2.f0 = buildPartitionCondition(valueMap, partitionFields, staticPartitionFields);"> 384                     rowTuple2.f0 = buildPartitionCondition(valueMap, partitionFields, staticPartitionFiel🔵</abbr>
 385                 }
 386 
 387                 // 根据字段名对 row data 重组, 比如，原始 row data : (1, xxx, 20) -&gt; (id, name, age)
 388                 // 但是由于 partition，写入的field 顺序变成了 (name, id, age)，则需要对 row data 重组变成 (xxx, 1, 20)
 389                 Row rowValue = new Row(fieldTypes.size());
 390                 for (int i = 0; i &lt; fieldTypes.size(); i++) {
 391                     rowValue.setField(i, valueMap.get(valueFieldNames.get(i)));
 392                 }
 393                 rowTuple2.f1 = buildValuesCondition(fieldTypes, rowValue);
 394                 putRowIntoMap(rowDataMap, rowTuple2);
 395             }
 396 
 397             batchCount++;
 398 
 399             if (batchCount &gt;= batchSize) {
 400                 flush();
 401             }
 402 
 403             // Receive data
 404             outRecords.inc();
 405         } catch (Exception e) {
 406             throw new IOException(&quot;Writing records to impala failed.&quot;, e);
 407         }
 408     }
 409 
 410     @Override
 411     public void close() throws IOException {
 412         if (closed) {
 413             return;
 414         }
 415         // 将还未执行的SQL flush
 416         if (batchCount &gt; 0) {
 417             flush();
 418         }
 419         // cancel scheduled task
 420         if (this.scheduledFuture != null) {
 421             scheduledFuture.cancel(false);
 422             this.scheduler.shutdown();
 423         }
 424         // close connection
 425         try {
 426             if (connection != null &amp;&amp; connection.isValid(DEFAULT_CONN_TIME_OUT)) {
 427                 connection.close();
 428             }
 429 
 430             if (statement != null &amp;&amp; !statement.isClosed()) {
 431                 statement.close();
 432             }
 433 
 434             if (updateStatement != null &amp;&amp; !updateStatement.isClosed()) {
 435                 updateStatement.close();
 436             }
 437         } catch (SQLException e) {
 438             throw new RuntimeException(&quot;impala connection close failed!&quot;, e);
 439         } finally {
 440             connection = null;
 441             statement = null;
 442             updateStatement = null;
 443         }
 444         closed = true;
 445     }
 446 
 447     /**
 448      * execute batch sql from row data map
<abbr title=" 449      * sql like &#x27;insert into tableName(f1, f2, f3) ${partitionCondition} values(v1, v2, v3), (v4, v5, v6)...."> 449      * sql like &#x27;insert into tableName(f1, f2, f3) ${partitionCondition} values(v1, v2, v3), (v4, v5, v6)🔵</abbr>
 450      *
 451      * @param tempSql         template sql
 452      * @param storeType       the store type of data
 453      * @param enablePartition enable partition or not
 454      * @param fieldNames      field name list
 455      * @param partitionFields partition fields
 456      * @param rowDataMap      row data map
 457      */
 458     private void executeBatchSql(String tempSql,
 459                                  String schema,
 460                                  String tableName,
 461                                  String storeType,
 462                                  Boolean enablePartition,
 463                                  List&lt;String&gt; fieldNames,
 464                                  String partitionFields,
 465                                  Map&lt;String, ArrayList&lt;String&gt;&gt; rowDataMap) {
 466         StringBuilder partitionCondition = new StringBuilder();
 467         String tableFieldsCondition = buildTableFieldsCondition(fieldNames, partitionFields);
 468         ArrayList&lt;String&gt; rowData = new ArrayList&lt;&gt;();
 469         String tableNameInfo = Objects.isNull(schema) ?
 470                 tableName : quoteIdentifier(schema) + &quot;.&quot; + tableName;
 471         tempSql = tempSql.replace(&quot;tableName&quot;, tableNameInfo);
 472         boolean isPartitioned = storeType.equalsIgnoreCase(KUDU_TYPE) || !enablePartition;
 473 
 474         try {
 475             // kudu ${partitionCondition} is null
 476             if (isPartitioned) {
 477                 tempSql = tempSql
 478                     .replace(PARTITION_CONDITION, partitionCondition.toString())
 479                     .replace(PARTITION_CONSTANT, &quot;&quot;)
 480                     .replace(TABLE_FIELDS_CONDITION, tableFieldsCondition);
 481                 rowData.addAll(rowDataMap.get(NO_PARTITION));
 482                 String executeSql = tempSql.replace(VALUES_CONDITION, String.join(&quot;, &quot;, rowData));
 483                 statement.execute(executeSql);
 484                 rowData.clear();
 485             } else {
 486                 // partition sql
 487                 Set&lt;String&gt; keySet = rowDataMap.keySet();
 488                 for (String key : keySet) {
 489                     rowData.addAll(rowDataMap.get(key));
 490                     partitionCondition.append(key);
 491                     tempSql = tempSql
 492                         .replace(PARTITION_CONDITION, partitionCondition.toString())
 493                         .replace(TABLE_FIELDS_CONDITION, tableFieldsCondition);
 494                     String executeSql = tempSql
 495                         .replace(VALUES_CONDITION, String.join(&quot;, &quot;, rowData));
 496                     statement.execute(executeSql);
 497                     partitionCondition.delete(0, partitionCondition.length());
 498                 }
 499             }
 500         } catch (Exception e) {
 501             if (e instanceof SQLException) {
 502                 dealBatchSqlError(rowData, connection, statement, tempSql);
 503             } else {
 504                 throw new RuntimeException(&quot;Insert into impala error!&quot;, e);
 505             }
 506         } finally {
 507             rowData.clear();
 508         }
 509     }
 510 
 511     /**
 512      * 当批量写入失败时，把批量的sql拆解为单条sql提交，对于单条写入的sql记做脏数据
 513      *
 514      * @param rowData 批量的values
 515      * @param connection 当前数据库connect
 516      * @param statement 当前statement
 517      * @param templateSql 模版sql，例如insert into tableName(f1, f2, f3) [partition] values $valueCondition
 518      */
 519     private void dealBatchSqlError(List&lt;String&gt; rowData,
 520                                    Connection connection,
 521                                    Statement statement,
 522                                    String templateSql) {
 523         String errorMsg = &quot;Insert into impala error. \nCause: [%s]\nRow: [%s]&quot;;
 524         JDBCUtils.rollBack(connection);
 525         JDBCUtils.commit(connection);
 526         for (String rowDatum : rowData) {
 527             String executeSql = templateSql.replace(VALUES_CONDITION, rowDatum);
 528             try {
 529                 statement.execute(executeSql);
 530                 JDBCUtils.commit(connection);
 531             } catch (SQLException e) {
 532                 JDBCUtils.rollBack(connection);
 533                 JDBCUtils.commit(connection);
<abbr title=" 534                 if (metricOutputFormat.outDirtyRecords.getCount() % DIRTY_DATA_PRINT_FREQUENCY == 0 || LOG.isDebugEnabled()) {"> 534                 if (metricOutputFormat.outDirtyRecords.getCount() % DIRTY_DATA_PRINT_FREQUENCY == 0 || LO🔵</abbr>
 535                     LOG.error(
 536                         String.format(
 537                             errorMsg,
 538                             ExceptionTrace.traceOriginalCause(e),
 539                             rowDatum)
 540                     );
 541                 }
 542                 metricOutputFormat.outDirtyRecords.inc();
 543             }
 544         }
 545     }
 546 
 547     /**
 548      * build partition condition with row data
 549      *
 550      * @param rowData              row data
 551      * @param partitionFields      partition fields
 552      * @param staticPartitionField static partition fields
 553      * @return condition like &#x27;(ptOne, ptTwo=v2)&#x27;
 554      */
<abbr title=" 555     private String buildPartitionCondition(Map&lt;String, Object&gt; rowData, String partitionFields, List&lt;String&gt; staticPartitionField) {"> 555     private String buildPartitionCondition(Map&lt;String, Object&gt; rowData, String partitionFields, List&lt;Stri🔵</abbr>
 556         for (String key : staticPartitionField) {
 557             StringBuilder sb = new StringBuilder();
 558             Object value = rowData.get(key);
 559             sb.append(key).append(&quot;=&quot;).append(value);
 560             partitionFields = partitionFields.replace(&quot;${&quot; + key + &quot;}&quot;, sb.toString());
 561         }
 562         return &quot;(&quot; + partitionFields + &quot;)&quot;;
 563     }
 564 
 565     /**
 566      * build field condition according to field names
 567      * replace ${tableFieldCondition}
 568      *
 569      * @param fieldNames      the selected field names
 570      * @param partitionFields the partition fields
 571      * @return condition like &#x27;(id, name, age)&#x27;
 572      */
 573     private String buildTableFieldsCondition(List&lt;String&gt; fieldNames, String partitionFields) {
 574         return &quot;(&quot; + fieldNames.stream()
 575                 .filter(f -&gt; !partitionFields.contains(f))
 576                 .map(this::quoteIdentifier)
 577                 .collect(Collectors.joining(&quot;, &quot;)) + &quot;)&quot;;
 578     }
 579 
 580     /**
 581      * according to field types, build the values condition
 582      * replace ${valuesCondition}
 583      *
 584      * @param fieldTypes field types
 585      * @return condition like &#x27;(?, ?, cast(&#x27;?&#x27; as string))&#x27; and &#x27;?&#x27; will be replaced with row data
 586      */
 587     private String buildValuesCondition(List&lt;String&gt; fieldTypes, Row row) {
 588         String valuesCondition = fieldTypes.stream().map(
 589                 f -&gt; {
 590                     for (String item : NEED_QUOTE_TYPE) {
 591                         if (f.toLowerCase().contains(item)) {
 592                             return String.format(&quot;cast(&#x27;?&#x27; as %s)&quot;, f.toLowerCase());
 593                         }
 594                     }
 595                     return &quot;?&quot;;
 596                 }).collect(Collectors.joining(&quot;, &quot;));
 597         for (int i = 0; i &lt; row.getArity(); i++) {
 598             Object rowField = row.getField(i);
 599             if (DtStringUtil.isEmptyOrNull(rowField)) {
 600                 valuesCondition = valuesCondition.replaceFirst(&quot;&#x27;\\?&#x27;&quot;, &quot;null&quot;);
 601             } else {
 602                 valuesCondition = valuesCondition.replaceFirst(&quot;\\?&quot;, rowField.toString());
 603             }
 604         }
 605         return &quot;(&quot; + valuesCondition + &quot;)&quot;;
 606     }
 607 
 608     /**
 609      * impala update mode SQL
 610      *
 611      * @return UPDATE tableName SET setCondition WHERE whereCondition
 612      */
<abbr title=" 613     private String buildUpdateSql(String schema, String tableName, List&lt;String&gt; fieldNames, List&lt;String&gt; primaryKeys) {"> 613     private String buildUpdateSql(String schema, String tableName, List&lt;String&gt; fieldNames, List&lt;String&gt; 🔵</abbr>
 614         //跳过primary key字段
 615         String setClause = fieldNames.stream()
 616                 .filter(f -&gt; !CollectionUtils.isNotEmpty(primaryKeys) || !primaryKeys.contains(f))
 617                 .map(f -&gt; quoteIdentifier(f) + &quot;=?&quot;)
 618                 .collect(Collectors.joining(&quot;, &quot;));
 619 
 620         String conditionClause = primaryKeys.stream()
 621                 .map(f -&gt; quoteIdentifier(f) + &quot;=?&quot;)
 622                 .collect(Collectors.joining(&quot; AND &quot;));
 623 
 624         return &quot;UPDATE &quot; + (Objects.isNull(schema) ? &quot;&quot; : quoteIdentifier(schema) + &quot;.&quot;)
 625                 + quoteIdentifier(tableName) + &quot; SET &quot; + setClause + &quot; WHERE &quot; + conditionClause;
 626     }
 627 
 628     private String quoteIdentifier(String identifier) {
 629         return &quot;`&quot; + identifier + &quot;`&quot;;
 630     }
 631 
 632     public static class Builder {
 633         private final ImpalaOutputFormat format = new ImpalaOutputFormat();
 634 
 635         public Builder setDbUrl(String dbUrl) {
 636             format.dbUrl = dbUrl;
 637             return this;
 638         }
 639 
 640         public Builder setUserName(String userName) {
 641             format.userName = userName;
 642             return this;
 643         }
 644 
 645         public Builder setPassword(String password) {
 646             format.password = password;
 647             return this;
 648         }
 649 
 650         public Builder setBatchSize(Integer batchSize) {
 651             format.batchSize = batchSize;
 652             return this;
 653         }
 654 
 655         public Builder setBatchWaitInterval(Long batchWaitInterval) {
 656             format.batchWaitInterval = batchWaitInterval;
 657             return this;
 658         }
 659 
 660         public Builder setTableName(String tableName) {
 661             format.tableName = tableName;
 662             return this;
 663         }
 664 
 665         public Builder setPartitionFields(String partitionFields) {
 666             format.partitionFields = Objects.isNull(partitionFields) ?
 667                     &quot;&quot; : partitionFields;
 668             return this;
 669         }
 670 
 671         public Builder setPrimaryKeys(List&lt;String&gt; primaryKeys) {
 672             format.primaryKeys = primaryKeys;
 673             return this;
 674         }
 675 
 676         public Builder setSchema(String schema) {
 677             format.schema = schema;
 678             return this;
 679         }
 680 
 681         public Builder setEnablePartition(Boolean enablePartition) {
 682             format.enablePartition = enablePartition;
 683             return this;
 684         }
 685 
 686         public Builder setUpdateMode(String updateMode) {
 687             format.updateMode = updateMode;
 688             return this;
 689         }
 690 
 691         public Builder setFieldList(List&lt;String&gt; fieldList) {
 692             format.fieldNames = fieldList;
 693             return this;
 694         }
 695 
 696         public Builder setFieldTypeList(List&lt;String&gt; fieldTypeList) {
 697             format.fieldTypes = fieldTypeList;
 698             return this;
 699         }
 700 
 701         public Builder setStoreType(String storeType) {
 702             format.storeType = storeType;
 703             return this;
 704         }
 705 
 706         public Builder setFieldExtraInfoList(List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfoList) {
 707             format.fieldExtraInfoList = fieldExtraInfoList;
 708             return this;
 709         }
 710 
 711         public Builder setKeyTabPath(String keyTabPath) {
 712             format.keytabPath = keyTabPath;
 713             return this;
 714         }
 715 
 716         public Builder setKrb5ConfPath(String krb5ConfPath) {
 717             format.krb5confPath = krb5ConfPath;
 718             return this;
 719         }
 720 
 721         public Builder setPrincipal(String principal) {
 722             format.principal = principal;
 723             return this;
 724         }
 725 
 726         public Builder setAuthMech(Integer authMech) {
 727             format.authMech = authMech;
 728             return this;
 729         }
 730 
 731         private boolean canHandle(String url) {
 732             return url.startsWith(&quot;jdbc:impala:&quot;);
 733         }
 734 
 735         public ImpalaOutputFormat build() {
 736             if (!canHandle(format.dbUrl)) {
<abbr title=" 737                 throw new IllegalArgumentException(&quot;impala dbUrl is illegal, check url: &quot; + format.dbUrl);"> 737                 throw new IllegalArgumentException(&quot;impala dbUrl is illegal, check url: &quot; + format.dbUrl)🔵</abbr>
 738             }
 739 
 740             if (format.authMech == EAuthMech.Kerberos.getType()) {
 741                 checkNotNull(format.krb5confPath,
 742                         &quot;When kerberos authentication is enabled, krb5confPath is required！&quot;);
 743                 checkNotNull(format.principal,
 744                         &quot;When kerberos authentication is enabled, principal is required！&quot;);
 745                 checkNotNull(format.keytabPath,
 746                         &quot;When kerberos authentication is enabled, keytabPath is required！&quot;);
 747             }
 748 
 749             if (format.authMech == EAuthMech.UserName.getType()) {
 750                 checkNotNull(format.userName, &quot;userName is required!&quot;);
 751             }
 752 
 753             if (format.authMech == EAuthMech.NameANDPassword.getType()) {
 754                 checkNotNull(format.userName, &quot;userName is required!&quot;);
 755                 checkNotNull(format.password, &quot;password is required!&quot;);
 756             }
 757 
 758             checkNotNull(format.storeType, &quot;storeType is required!&quot;);
 759 
 760             return format;
 761         }
 762     }
 763 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.sink.impala;
  20 
  21 import com.dtstack.flink.sql.classloader.ClassLoaderManager;
  22 
  23 import com.dtstack.flink.sql.exception.ExceptionTrace;
  24 import com.dtstack.flink.sql.factory.DTThreadFactory;
  25 import com.dtstack.flink.sql.outputformat.AbstractDtRichOutputFormat;
  26 import com.dtstack.flink.sql.sink.rdb.JDBCTypeConvertUtils;
  27 import com.dtstack.flink.sql.table.AbstractTableInfo;
  28 import com.dtstack.flink.sql.util.DtStringUtil;
  29 import com.dtstack.flink.sql.util.KrbUtils;
  30 import com.google.common.collect.Maps;
  31 import org.apache.commons.collections.CollectionUtils;
  32 import org.apache.flink.api.java.tuple.Tuple2;
  33 import org.apache.flink.configuration.Configuration;
  34 import org.apache.flink.types.Row;
  35 import org.apache.hadoop.security.UserGroupInformation;
  36 import org.slf4j.Logger;
  37 import org.slf4j.LoggerFactory;
  38 
  39 import java.io.IOException;
  40 import java.security.PrivilegedExceptionAction;
  41 import java.sql.Connection;
  42 import java.sql.DriverManager;
  43 import java.sql.PreparedStatement;
  44 import java.sql.SQLException;
  45 import java.sql.Statement;
  46 import java.util.ArrayList;
  47 import java.util.HashMap;
  48 import java.util.List;
  49 import java.util.Map;
  50 import java.util.Objects;
  51 import java.util.Set;
  52 import java.util.concurrent.ScheduledExecutorService;
  53 import java.util.concurrent.ScheduledFuture;
  54 import java.util.concurrent.ScheduledThreadPoolExecutor;
  55 import java.util.concurrent.TimeUnit;
  56 import java.util.regex.Matcher;
  57 import java.util.regex.Pattern;
  58 import java.util.stream.Collectors;
  59 
  60 import static com.dtstack.flink.sql.sink.rdb.JDBCTypeConvertUtils.setRecordToStatement;
  61 import static org.apache.flink.util.Preconditions.checkNotNull;
  62 
  63 /**
  64  * Date: 2020/10/14
  65  * Company: www.dtstack.com
  66  *
  67  * @author tiezhu
  68  */
  69 public class ImpalaOutputFormat extends AbstractDtRichOutputFormat&lt;Tuple2&lt;Boolean, Row&gt;&gt; {
  70 
  71     private static final Logger LOG = LoggerFactory.getLogger(ImpalaOutputFormat.class);
  72 
  73     private static final long serialVersionUID = 1L;
  74 
  75     // ${field}
  76     private static final Pattern STATIC_PARTITION_PATTERN = Pattern.compile(&quot;\\$\\{([^}]*)}&quot;);
  77     //specific type which values need to be quoted
  78     private static final String[] NEED_QUOTE_TYPE = {&quot;string&quot;, &quot;timestamp&quot;, &quot;varchar&quot;};
  79 
  80     private static final Integer DEFAULT_CONN_TIME_OUT = 60;
  81     private static final int RECEIVE_DATA_PRINT_FREQUENCY = 1000;
  82     private static final int DIRTY_DATA_PRINT_FREQUENCY = 1000;
  83 
  84     private static final String KUDU_TYPE = &quot;kudu&quot;;
  85     private static final String UPDATE_MODE = &quot;update&quot;;
  86     private static final String PARTITION_CONSTANT = &quot;PARTITION&quot;;
  87     private static final String DRIVER_NAME = &quot;com.cloudera.impala.jdbc41.Driver&quot;;
  88 
  89     private static final String VALUES_CONDITION = &quot;${valuesCondition}&quot;;
  90     private static final String PARTITION_CONDITION = &quot;${partitionCondition}&quot;;
  91     private static final String TABLE_FIELDS_CONDITION = &quot;${tableFieldsCondition}&quot;;
  92     private static final String NO_PARTITION = &quot;noPartition&quot;;
  93     protected transient Connection connection;
  94     protected transient Statement statement;
  95     protected transient PreparedStatement updateStatement;
  96     private transient volatile boolean closed = false;
  97     private int batchCount = 0;
  98     // |------------------------------------------------|
  99     // |   partitionCondition   |Array of valueCondition|
 100     // |------------------------------------------------|
 101     // | ptOne, ptTwo, ptThree  | [(v1, v2, v3, v4, v5)]|   DP
 102     // |------------------------------------------------|
 103     // | ptOne = v1, ptTwo = v2 | [(v3, v4, v5)]        |   SP
 104     // |------------------------------------------------|
 105     // | ptOne, ptTwo = v2      | [(v1, v3, v4, v5)]    |   DP and SP
 106     // |------------------------------------------------|
 107     // | noPartition            | [(v1, v2, v3, v4, v5)]|   kudu or disablePartition
 108     // |------------------------------------------------|
 109     private transient Map&lt;String, ArrayList&lt;String&gt;&gt; rowDataMap;
 110     protected String keytabPath;
 111     protected String krb5confPath;
 112     protected String principal;
 113     protected Integer authMech;
 114     protected String dbUrl;
 115     protected String userName;
 116     protected String password;
 117     protected int batchSize = 100;
 118     protected long batchWaitInterval = 60 * 1000L;
 119     protected String tableName;
 120     protected List&lt;String&gt; primaryKeys;
 121     protected String partitionFields;
 122     protected Boolean enablePartition;
 123     protected String schema;
 124     protected String storeType;
 125     protected String updateMode;
 126     public List&lt;String&gt; fieldNames;
 127     public List&lt;String&gt; fieldTypes;
 128     public List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfoList;
 129     // partition field of static partition which matched by ${field}
 130     private final List&lt;String&gt; staticPartitionFields = new ArrayList&lt;&gt;();
 131     // valueFieldsName -&gt; 重组之后的fieldNames，为了重组row data字段值对应
 132     // 需要对partition字段做特殊处理，比如原来的字段顺序为(age, name, id)，但是因为partition，写入的SQL为
 133     // INSERT INTO tableName(name, id) PARTITION(age) VALUES(?, ?, ?)
 134     // 那么实际executeSql设置字段的顺序应该为(name, id, age)，同时，字段对应的type顺序也需要重组
 135     private List&lt;String&gt; valueFieldNames;
 136     private transient AbstractDtRichOutputFormat&lt;?&gt; metricOutputFormat;
 137     private List&lt;Row&gt; rows;
 138 
 139     private transient ScheduledExecutorService scheduler;
 140     private transient ScheduledFuture&lt;?&gt; scheduledFuture;
 141 
 142     @Override
 143     public void configure(Configuration parameters) {
 144     }
 145 
 146     @Override
 147     public void open(int taskNumber, int numTasks) throws IOException {
 148         try {
 149             rowDataMap = new HashMap&lt;&gt;();
 150             rows = new ArrayList&lt;&gt;();
 151             metricOutputFormat = this;
 152             openConnect();
 153             initScheduledTask(batchWaitInterval);
 154             init();
 155             initMetric();
 156         } catch (Exception e) {
 157             throw new RuntimeException(&quot;impala output format open error!&quot;, e);
 158         }
 159     }
 160 
 161     private void init() throws SQLException {
 162         if (Objects.nonNull(partitionFields)) {
 163             // match ${field} from partitionFields
 164             Matcher matcher = STATIC_PARTITION_PATTERN.matcher(partitionFields);
 165             while (matcher.find()) {
 166                 LOG.info(&quot;find static partition field: {}&quot;, matcher.group(1));
 167                 staticPartitionFields.add(matcher.group(1));
 168             }
 169         }
 170 
 171         if (updateMode.equalsIgnoreCase(UPDATE_MODE)) {
 172             if (!storeType.equalsIgnoreCase(KUDU_TYPE)) {
 173                 throw new IllegalArgumentException(&quot;update mode not support for non-kudu table!&quot;);
 174             }
<abbr title=" 175             updateStatement = connection.prepareStatement(buildUpdateSql(schema, tableName, fieldNames, primaryKeys));"> 175             updateStatement = connection.prepareStatement(buildUpdateSql(schema, tableName, fieldNames, p🔵</abbr>
 176         } else {
<abbr title=" 177             valueFieldNames = rebuildFieldNameListAndTypeList(fieldNames, staticPartitionFields, fieldTypes, partitionFields);"> 177             valueFieldNames = rebuildFieldNameListAndTypeList(fieldNames, staticPartitionFields, fieldTyp🔵</abbr>
 178         }
 179 
 180     }
 181 
 182     private void initScheduledTask(Long batchWaitInterval) {
 183         try {
 184             if (batchWaitInterval != 0) {
 185                 this.scheduler = new ScheduledThreadPoolExecutor(1,
 186                         new DTThreadFactory(&quot;impala-upsert-output-format&quot;));
 187                 this.scheduledFuture = this.scheduler.scheduleWithFixedDelay(() -&gt; {
 188                     synchronized (ImpalaOutputFormat.this) {
 189                             flush();
 190                     }
 191                 }, batchWaitInterval, batchWaitInterval, TimeUnit.MILLISECONDS);
 192             }
 193         } catch (Exception e) {
 194             throw new RuntimeException(e);
 195         }
 196     }
 197 
 198     private void openConnect() throws IOException {
 199         if (authMech == 1) {
 200             UserGroupInformation ugi = KrbUtils.loginAndReturnUgi(principal, keytabPath, krb5confPath);
 201             try {
 202                 ugi.doAs((PrivilegedExceptionAction&lt;Void&gt;) () -&gt; {
 203                     openJdbc();
 204                     return null;
 205                 });
 206             } catch (InterruptedException | IOException e) {
 207                 throw new IllegalArgumentException(&quot;connect impala error!&quot;, e);
 208             }
 209         } else {
 210             openJdbc();
 211         }
 212     }
 213 
 214     /**
 215      * get jdbc connection
 216      */
 217     private void openJdbc() {
 218         ClassLoaderManager.forName(DRIVER_NAME, getClass().getClassLoader());
 219         try {
 220             connection = DriverManager.getConnection(dbUrl, userName, password);
 221             statement = connection.createStatement();
 222             connection.setAutoCommit(false);
 223         } catch (SQLException sqlException) {
 224             throw new RuntimeException(&quot;get impala jdbc connection failed!&quot;, sqlException);
 225         }
 226     }
 227 
 228     private synchronized void flush() {
 229         try {
 230         if (batchCount &gt; 0) {
 231             if (updateMode.equalsIgnoreCase(UPDATE_MODE)) {
 232                 executeUpdateBatch();
 233             }
 234             if (!rowDataMap.isEmpty()) {
 235                 String templateSql =
<abbr title=" 236                         &quot;INSERT INTO tableName ${tableFieldsCondition} PARTITION ${partitionCondition} VALUES ${valuesCondition}&quot;;"> 236                         &quot;INSERT INTO tableName ${tableFieldsCondition} PARTITION ${partitionCondition} VA🔵</abbr>
 237                 executeBatchSql(
 238                         templateSql,
 239                         schema,
 240                         tableName,
 241                         storeType,
 242                         enablePartition,
 243                         valueFieldNames,
 244                         partitionFields,
 245                         rowDataMap
 246                 );
 247                 rowDataMap.clear();
 248             }
 249         }
 250         batchCount = 0;
 251         } catch (Exception e) {
 252             LOG.error(&quot;Writing records to impala jdbc failed.&quot;, e);
 253             throw new RuntimeException(&quot;Writing records to impala jdbc failed.&quot;, e);
 254         }
 255     }
 256 
 257     /**
 258      * execute batch update statement
 259      *
 260      * @throws SQLException throw sql exception
 261      */
 262     private void executeUpdateBatch() throws SQLException {
 263         try {
 264             rows.forEach(row -&gt; {
 265                 try {
 266                     JDBCTypeConvertUtils.setRecordToStatement(
 267                             updateStatement,
 268                             JDBCTypeConvertUtils.getSqlTypeFromFieldType(fieldTypes),
 269                             row,
 270                             primaryKeys.stream().mapToInt(fieldNames::indexOf).toArray()
 271                     );
 272                     updateStatement.addBatch();
 273                 } catch (Exception e) {
 274                     throw new RuntimeException(&quot;impala jdbc execute batch error!&quot;, e);
 275                 }
 276             });
 277             updateStatement.executeBatch();
 278             connection.commit();
 279             rows.clear();
 280         } catch (Exception e) {
 281             LOG.debug(&quot;impala jdbc execute batch error &quot;, e);
 282             JDBCUtils.rollBack(connection);
 283             JDBCUtils.commit(connection);
 284             updateStatement.clearBatch();
 285             executeUpdate(connection);
 286         }
 287     }
 288 
 289     public void executeUpdate(Connection connection) {
 290         rows.forEach(row -&gt; {
 291             try {
<abbr title=" 292                 setRecordToStatement(updateStatement, JDBCTypeConvertUtils.getSqlTypeFromFieldType(fieldTypes), row);"> 292                 setRecordToStatement(updateStatement, JDBCTypeConvertUtils.getSqlTypeFromFieldType(fieldT🔵</abbr>
 293                 updateStatement.executeUpdate();
 294                 JDBCUtils.commit(connection);
 295             } catch (Exception e) {
 296                 JDBCUtils.rollBack(connection);
 297                 JDBCUtils.commit(connection);
<abbr title=" 298                 if (metricOutputFormat.outDirtyRecords.getCount() % DIRTY_DATA_PRINT_FREQUENCY == 0 || LOG.isDebugEnabled()) {"> 298                 if (metricOutputFormat.outDirtyRecords.getCount() % DIRTY_DATA_PRINT_FREQUENCY == 0 || LO🔵</abbr>
 299                     LOG.error(&quot;record insert failed ,this row is {}&quot;, row.toString());
 300                     LOG.error(&quot;&quot;, e);
 301                 }
 302                 metricOutputFormat.outDirtyRecords.inc();
 303             }
 304         });
 305         rows.clear();
 306     }
 307 
<abbr title=" 308     private void putRowIntoMap(Map&lt;String, ArrayList&lt;String&gt;&gt; rowDataMap, Tuple2&lt;String, String&gt; rowData) {"> 308     private void putRowIntoMap(Map&lt;String, ArrayList&lt;String&gt;&gt; rowDataMap, Tuple2&lt;String, String&gt; rowData)🔵</abbr>
 309         Set&lt;String&gt; keySet = rowDataMap.keySet();
 310         ArrayList&lt;String&gt; tempRowArray;
 311         if (keySet.contains(rowData.f0)) {
 312             tempRowArray = rowDataMap.get(rowData.f0);
 313         } else {
 314             tempRowArray = new ArrayList&lt;&gt;();
 315         }
 316         tempRowArray.add(rowData.f1);
 317         rowDataMap.put(rowData.f0, tempRowArray);
 318     }
 319 
<abbr title=" 320     private List&lt;String&gt; rebuildFieldNameListAndTypeList(List&lt;String&gt; fieldNames, List&lt;String&gt; staticPartitionFields, List&lt;String&gt; fieldTypes, String partitionFields) {"> 320     private List&lt;String&gt; rebuildFieldNameListAndTypeList(List&lt;String&gt; fieldNames, List&lt;String&gt; staticPart🔵</abbr>
 321         if (partitionFields == null || partitionFields.isEmpty()) {
 322             return fieldNames;
 323         }
 324 
 325         List&lt;String&gt; valueFields = new ArrayList&lt;&gt;(fieldNames);
 326 
 327         for (int i = valueFields.size() - 1; i &gt;= 0; i--) {
 328             if (staticPartitionFields.contains(fieldNames.get(i))) {
 329                 valueFields.remove(i);
 330                 fieldTypes.remove(i);
 331             }
 332         }
 333 
 334         for (int i = 0; i &lt; valueFields.size(); i++) {
 335             if (partitionFields.contains(fieldNames.get(i))) {
 336                 valueFields.add(valueFields.remove(i));
 337                 fieldTypes.add(fieldTypes.remove(i));
 338             }
 339         }
 340 
 341         return valueFields;
 342     }
 343 
 344     @Override
 345     public void writeRecord(Tuple2&lt;Boolean, Row&gt; record) throws IOException {
 346         try {
 347             if (!record.f0) {
 348                 return;
 349             }
 350 
 351             if (outRecords.getCount() % RECEIVE_DATA_PRINT_FREQUENCY == 0 || LOG.isDebugEnabled()) {
 352                 LOG.info(&quot;Receive data : {}&quot;, record);
 353             }
 354 
 355             if (updateMode.equalsIgnoreCase(UPDATE_MODE)) {
 356                 rows.add(Row.copy(record.f1));
 357             } else {
 358                 Map&lt;String, Object&gt; valueMap = Maps.newHashMap();
 359                 Row row = Row.copy(record.f1);
 360 
 361                 for (int i = 0; i &lt; row.getArity(); i++) {
 362                     valueMap.put(fieldNames.get(i), row.getField(i));
 363                 }
 364 
 365                 Tuple2&lt;String, String&gt; rowTuple2 = new Tuple2&lt;&gt;();
 366                 if (storeType.equalsIgnoreCase(KUDU_TYPE) || !enablePartition) {
 367                     rowTuple2.f0 = NO_PARTITION;
 368                 } else {
<abbr title=" 369                     rowTuple2.f0 = buildPartitionCondition(valueMap, partitionFields, staticPartitionFields);"> 369                     rowTuple2.f0 = buildPartitionCondition(valueMap, partitionFields, staticPartitionFiel🔵</abbr>
 370                 }
 371 
 372                 // 根据字段名对 row data 重组, 比如，原始 row data : (1, xxx, 20) -&gt; (id, name, age)
 373                 // 但是由于 partition，写入的field 顺序变成了 (name, id, age)，则需要对 row data 重组变成 (xxx, 1, 20)
 374                 Row rowValue = new Row(fieldTypes.size());
 375                 for (int i = 0; i &lt; fieldTypes.size(); i++) {
 376                     rowValue.setField(i, valueMap.get(valueFieldNames.get(i)));
 377                 }
 378                 rowTuple2.f1 = buildValuesCondition(fieldTypes, rowValue);
 379                 putRowIntoMap(rowDataMap, rowTuple2);
 380             }
 381 
 382             batchCount++;
 383 
 384             if (batchCount &gt;= batchSize) {
 385                 flush();
 386             }
 387 
 388             // Receive data
 389             outRecords.inc();
 390         } catch (Exception e) {
 391             throw new IOException(&quot;Writing records to impala failed.&quot;, e);
 392         }
 393     }
 394 
 395     @Override
 396     public void close() throws IOException {
 397         if (closed) {
 398             return;
 399         }
 400         // 将还未执行的SQL flush
 401         if (batchCount &gt; 0) {
 402                 flush();
 403         }
 404         // cancel scheduled task
 405         if (this.scheduledFuture != null) {
 406             scheduledFuture.cancel(false);
 407             this.scheduler.shutdown();
 408         }
 409         // close connection
 410         try {
 411             if (connection != null &amp;&amp; connection.isValid(DEFAULT_CONN_TIME_OUT)) {
 412                 connection.close();
 413             }
 414 
 415             if (statement != null &amp;&amp; !statement.isClosed()) {
 416                 statement.close();
 417             }
 418 
 419             if (updateStatement != null &amp;&amp; !updateStatement.isClosed()) {
 420                 updateStatement.close();
 421             }
 422         } catch (SQLException e) {
 423             throw new RuntimeException(&quot;impala connection close failed!&quot;, e);
 424         } finally {
 425             connection = null;
 426             statement = null;
 427             updateStatement = null;
 428         }
 429         closed = true;
 430     }
 431 
 432     /**
 433      * execute batch sql from row data map
<abbr title=" 434      * sql like &#x27;insert into tableName(f1, f2, f3) ${partitionCondition} values(v1, v2, v3), (v4, v5, v6)...."> 434      * sql like &#x27;insert into tableName(f1, f2, f3) ${partitionCondition} values(v1, v2, v3), (v4, v5, v6)🔵</abbr>
 435      *
 436      * @param tempSql         template sql
 437      * @param storeType       the store type of data
 438      * @param enablePartition enable partition or not
 439      * @param fieldNames      field name list
 440      * @param partitionFields partition fields
 441      * @param rowDataMap      row data map
 442      */
 443     private void executeBatchSql(String tempSql,
 444                                  String schema,
 445                                  String tableName,
 446                                  String storeType,
 447                                  Boolean enablePartition,
 448                                  List&lt;String&gt; fieldNames,
 449                                  String partitionFields,
 450                                  Map&lt;String, ArrayList&lt;String&gt;&gt; rowDataMap) {
 451         StringBuilder partitionCondition = new StringBuilder();
 452         String tableFieldsCondition = buildTableFieldsCondition(fieldNames, partitionFields);
 453         ArrayList&lt;String&gt; rowData = new ArrayList&lt;&gt;();
 454         String tableNameInfo = Objects.isNull(schema) ?
 455                 tableName : quoteIdentifier(schema) + &quot;.&quot; + tableName;
 456         tempSql = tempSql.replace(&quot;tableName&quot;, tableNameInfo);
 457         boolean isPartitioned = storeType.equalsIgnoreCase(KUDU_TYPE) || !enablePartition;
 458 
 459         try {
 460             // kudu ${partitionCondition} is null
 461             if (isPartitioned) {
 462                 tempSql = tempSql
 463                     .replace(PARTITION_CONDITION, partitionCondition.toString())
 464                     .replace(PARTITION_CONSTANT, &quot;&quot;)
 465                     .replace(TABLE_FIELDS_CONDITION, tableFieldsCondition);
 466                 rowData.addAll(rowDataMap.get(NO_PARTITION));
 467                 String executeSql = tempSql.replace(VALUES_CONDITION, String.join(&quot;, &quot;, rowData));
 468                 statement.execute(executeSql);
 469                 rowData.clear();
 470             } else {
 471                 // partition sql
 472                 Set&lt;String&gt; keySet = rowDataMap.keySet();
 473                 for (String key : keySet) {
 474                     rowData.addAll(rowDataMap.get(key));
 475                     partitionCondition.append(key);
 476                     tempSql = tempSql
 477                         .replace(PARTITION_CONDITION, partitionCondition.toString())
 478                         .replace(TABLE_FIELDS_CONDITION, tableFieldsCondition);
 479                     String executeSql = tempSql
 480                         .replace(VALUES_CONDITION, String.join(&quot;, &quot;, rowData));
 481                     statement.execute(executeSql);
 482                     partitionCondition.delete(0, partitionCondition.length());
 483                 }
 484             }
 485         } catch (Exception e) {
 486             if (e instanceof SQLException) {
 487                 dealBatchSqlError(rowData, connection, statement, tempSql);
 488             } else {
 489                 throw new RuntimeException(&quot;Insert into impala error!&quot;, e);
 490             }
 491         } finally {
 492             rowData.clear();
 493         }
 494     }
 495 
 496     /**
 497      * 当批量写入失败时，把批量的sql拆解为单条sql提交，对于单条写入的sql记做脏数据
 498      *
 499      * @param rowData 批量的values
 500      * @param connection 当前数据库connect
 501      * @param statement 当前statement
 502      * @param templateSql 模版sql，例如insert into tableName(f1, f2, f3) [partition] values $valueCondition
 503      */
 504     private void dealBatchSqlError(List&lt;String&gt; rowData,
 505                                    Connection connection,
 506                                    Statement statement,
 507                                    String templateSql) {
 508         String errorMsg = &quot;Insert into impala error. \nCause: [%s]\nRow: [%s]&quot;;
 509         JDBCUtils.rollBack(connection);
 510         JDBCUtils.commit(connection);
 511         for (String rowDatum : rowData) {
 512             String executeSql = templateSql.replace(VALUES_CONDITION, rowDatum);
 513             try {
 514                 statement.execute(executeSql);
 515                 JDBCUtils.commit(connection);
 516             } catch (SQLException e) {
 517                 JDBCUtils.rollBack(connection);
 518                 JDBCUtils.commit(connection);
<abbr title=" 519                 if (metricOutputFormat.outDirtyRecords.getCount() % DIRTY_DATA_PRINT_FREQUENCY == 0 || LOG.isDebugEnabled()) {"> 519                 if (metricOutputFormat.outDirtyRecords.getCount() % DIRTY_DATA_PRINT_FREQUENCY == 0 || LO🔵</abbr>
 520                     LOG.error(
 521                         String.format(
 522                             errorMsg,
 523                             ExceptionTrace.traceOriginalCause(e),
 524                             rowDatum)
 525                     );
 526                 }
 527                 metricOutputFormat.outDirtyRecords.inc();
 528             }
 529         }
 530     }
 531 
 532     /**
 533      * build partition condition with row data
 534      *
 535      * @param rowData              row data
 536      * @param partitionFields      partition fields
 537      * @param staticPartitionField static partition fields
 538      * @return condition like &#x27;(ptOne, ptTwo=v2)&#x27;
 539      */
<abbr title=" 540     private String buildPartitionCondition(Map&lt;String, Object&gt; rowData, String partitionFields, List&lt;String&gt; staticPartitionField) {"> 540     private String buildPartitionCondition(Map&lt;String, Object&gt; rowData, String partitionFields, List&lt;Stri🔵</abbr>
 541         for (String key : staticPartitionField) {
 542             StringBuilder sb = new StringBuilder();
 543             Object value = rowData.get(key);
 544             sb.append(key).append(&quot;=&quot;).append(value);
 545             partitionFields = partitionFields.replace(&quot;${&quot; + key + &quot;}&quot;, sb.toString());
 546         }
 547         return &quot;(&quot; + partitionFields + &quot;)&quot;;
 548     }
 549 
 550     /**
 551      * build field condition according to field names
 552      * replace ${tableFieldCondition}
 553      *
 554      * @param fieldNames      the selected field names
 555      * @param partitionFields the partition fields
 556      * @return condition like &#x27;(id, name, age)&#x27;
 557      */
 558     private String buildTableFieldsCondition(List&lt;String&gt; fieldNames, String partitionFields) {
 559         return &quot;(&quot; + fieldNames.stream()
 560                 .filter(f -&gt; !partitionFields.contains(f))
 561                 .map(this::quoteIdentifier)
 562                 .collect(Collectors.joining(&quot;, &quot;)) + &quot;)&quot;;
 563     }
 564 
 565     /**
 566      * according to field types, build the values condition
 567      * replace ${valuesCondition}
 568      *
 569      * @param fieldTypes field types
 570      * @return condition like &#x27;(?, ?, cast(&#x27;?&#x27; as string))&#x27; and &#x27;?&#x27; will be replaced with row data
 571      */
 572     private String buildValuesCondition(List&lt;String&gt; fieldTypes, Row row) {
 573         String valuesCondition = fieldTypes.stream().map(
 574                 f -&gt; {
 575                     for (String item : NEED_QUOTE_TYPE) {
 576                         if (f.toLowerCase().contains(item)) {
 577                             return String.format(&quot;cast(&#x27;?&#x27; as %s)&quot;, f.toLowerCase());
 578                         }
 579                     }
 580                     return &quot;?&quot;;
 581                 }).collect(Collectors.joining(&quot;, &quot;));
 582         for (int i = 0; i &lt; row.getArity(); i++) {
 583             Object rowField = row.getField(i);
 584             if (DtStringUtil.isEmptyOrNull(rowField)) {
 585                 valuesCondition = valuesCondition.replaceFirst(&quot;&#x27;\\?&#x27;&quot;, &quot;null&quot;);
 586             } else {
 587                 valuesCondition = valuesCondition.replaceFirst(&quot;\\?&quot;, rowField.toString());
 588         }
 589         }
 590         return &quot;(&quot; + valuesCondition + &quot;)&quot;;
 591     }
 592 
 593     /**
 594      * impala update mode SQL
 595      *
 596      * @return UPDATE tableName SET setCondition WHERE whereCondition
 597      */
<abbr title=" 598     private String buildUpdateSql(String schema, String tableName, List&lt;String&gt; fieldNames, List&lt;String&gt; primaryKeys) {"> 598     private String buildUpdateSql(String schema, String tableName, List&lt;String&gt; fieldNames, List&lt;String&gt; 🔵</abbr>
 599         //跳过primary key字段
 600         String setClause = fieldNames.stream()
 601                 .filter(f -&gt; !CollectionUtils.isNotEmpty(primaryKeys) || !primaryKeys.contains(f))
 602                 .map(f -&gt; quoteIdentifier(f) + &quot;=?&quot;)
 603                 .collect(Collectors.joining(&quot;, &quot;));
 604 
 605         String conditionClause = primaryKeys.stream()
 606                 .map(f -&gt; quoteIdentifier(f) + &quot;=?&quot;)
 607                 .collect(Collectors.joining(&quot; AND &quot;));
 608 
 609         return &quot;UPDATE &quot; + (Objects.isNull(schema) ? &quot;&quot; : quoteIdentifier(schema) + &quot;.&quot;)
 610                 + quoteIdentifier(tableName) + &quot; SET &quot; + setClause + &quot; WHERE &quot; + conditionClause;
 611     }
 612 
 613     private String quoteIdentifier(String identifier) {
 614         return &quot;`&quot; + identifier + &quot;`&quot;;
 615     }
 616 
 617     public static Builder getImpalaBuilder() {
 618         return new Builder();
 619     }
 620 
 621     public static class Builder {
 622         private final ImpalaOutputFormat format = new ImpalaOutputFormat();
 623 
 624         public Builder setDbUrl(String dbUrl) {
 625             format.dbUrl = dbUrl;
 626             return this;
 627         }
 628 
 629         public Builder setUserName(String userName) {
 630             format.userName = userName;
 631             return this;
 632         }
 633 
 634         public Builder setPassword(String password) {
 635             format.password = password;
 636             return this;
 637         }
 638 
 639         public Builder setBatchSize(Integer batchSize) {
 640             format.batchSize = batchSize;
 641             return this;
 642         }
 643 
 644         public Builder setBatchWaitInterval(Long batchWaitInterval) {
 645             format.batchWaitInterval = batchWaitInterval;
 646             return this;
 647         }
 648 
 649         public Builder setTableName(String tableName) {
 650             format.tableName = tableName;
 651             return this;
 652         }
 653 
 654         public Builder setPartitionFields(String partitionFields) {
 655             format.partitionFields = Objects.isNull(partitionFields) ?
 656                     &quot;&quot; : partitionFields;
 657             return this;
 658         }
 659 
 660         public Builder setPrimaryKeys(List&lt;String&gt; primaryKeys) {
 661             format.primaryKeys = primaryKeys;
 662             return this;
 663         }
 664 
 665         public Builder setSchema(String schema) {
 666             format.schema = schema;
 667             return this;
 668         }
 669 
 670         public Builder setEnablePartition(Boolean enablePartition) {
 671             format.enablePartition = enablePartition;
 672             return this;
 673         }
 674 
 675         public Builder setUpdateMode(String updateMode) {
 676             format.updateMode = updateMode;
 677             return this;
 678         }
 679 
 680         public Builder setFieldList(List&lt;String&gt; fieldList) {
 681             format.fieldNames = fieldList;
 682             return this;
 683         }
 684 
 685         public Builder setFieldTypeList(List&lt;String&gt; fieldTypeList) {
 686             format.fieldTypes = fieldTypeList;
 687             return this;
 688         }
 689 
 690         public Builder setStoreType(String storeType) {
 691             format.storeType = storeType;
 692             return this;
 693         }
 694 
 695         public Builder setFieldExtraInfoList(List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfoList) {
 696             format.fieldExtraInfoList = fieldExtraInfoList;
 697             return this;
 698         }
 699 
 700         public Builder setKeyTabPath(String keyTabPath) {
 701             format.keytabPath = keyTabPath;
 702             return this;
 703         }
 704 
 705         public Builder setKrb5ConfPath(String krb5ConfPath) {
 706             format.krb5confPath = krb5ConfPath;
 707             return this;
 708         }
 709 
 710         public Builder setPrincipal(String principal) {
 711             format.principal = principal;
 712             return this;
 713         }
 714 
 715         public Builder setAuthMech(Integer authMech) {
 716             format.authMech = authMech;
 717             return this;
 718         }
 719 
 720         private boolean canHandle(String url) {
 721             return url.startsWith(&quot;jdbc:impala:&quot;);
 722         }
 723 
 724         public ImpalaOutputFormat build() {
 725             if (!canHandle(format.dbUrl)) {
<abbr title=" 726                 throw new IllegalArgumentException(&quot;impala dbUrl is illegal, check url: &quot; + format.dbUrl);"> 726                 throw new IllegalArgumentException(&quot;impala dbUrl is illegal, check url: &quot; + format.dbUrl)🔵</abbr>
 727             }
 728 
 729             if (format.authMech == EAuthMech.Kerberos.getType()) {
 730                 checkNotNull(format.krb5confPath,
 731                         &quot;When kerberos authentication is enabled, krb5confPath is required！&quot;);
 732                 checkNotNull(format.principal,
 733                         &quot;When kerberos authentication is enabled, principal is required！&quot;);
 734                 checkNotNull(format.keytabPath,
 735                         &quot;When kerberos authentication is enabled, keytabPath is required！&quot;);
 736             }
 737 
 738             if (format.authMech == EAuthMech.UserName.getType()) {
 739                 checkNotNull(format.userName, &quot;userName is required!&quot;);
 740             }
 741 
 742             if (format.authMech == EAuthMech.NameANDPassword.getType()) {
 743                 checkNotNull(format.userName, &quot;userName is required!&quot;);
 744                 checkNotNull(format.password, &quot;password is required!&quot;);
 745             }
 746 
 747             checkNotNull(format.storeType, &quot;storeType is required!&quot;);
 748 
 749             return format;
 750         }
 751     }
 752 }
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.sink.impala;
  19 
  20 import com.dtstack.flink.sql.classloader.ClassLoaderManager;
  21 import com.dtstack.flink.sql.exception.ExceptionTrace;
  22 import com.dtstack.flink.sql.factory.DTThreadFactory;
  23 import com.dtstack.flink.sql.outputformat.AbstractDtRichOutputFormat;
  24 import com.dtstack.flink.sql.sink.rdb.JDBCTypeConvertUtils;
  25 import com.dtstack.flink.sql.table.AbstractTableInfo;
  26 import com.dtstack.flink.sql.util.DtStringUtil;
  27 import com.dtstack.flink.sql.util.KrbUtils;
  28 import com.google.common.collect.Maps;
  29 import java.io.IOException;
  30 import java.security.PrivilegedExceptionAction;
  31 import java.sql.Connection;
  32 import java.sql.DriverManager;
  33 import java.sql.PreparedStatement;
  34 import java.sql.SQLException;
  35 import java.sql.Statement;
  36 import java.util.ArrayList;
  37 import java.util.HashMap;
  38 import java.util.List;
  39 import java.util.Map;
  40 import java.util.Objects;
  41 import java.util.Set;
  42 import java.util.concurrent.ScheduledExecutorService;
  43 import java.util.concurrent.ScheduledFuture;
  44 import java.util.concurrent.ScheduledThreadPoolExecutor;
  45 import java.util.concurrent.TimeUnit;
  46 import java.util.regex.Matcher;
  47 import java.util.regex.Pattern;
  48 import java.util.stream.Collectors;
  49 import org.apache.commons.collections.CollectionUtils;
  50 import org.apache.flink.api.java.tuple.Tuple2;
  51 import org.apache.flink.configuration.Configuration;
  52 import org.apache.flink.types.Row;
  53 import org.apache.hadoop.security.UserGroupInformation;
  54 import org.slf4j.Logger;
  55 import org.slf4j.LoggerFactory;
  56 import static com.dtstack.flink.sql.sink.rdb.JDBCTypeConvertUtils.setRecordToStatement;
  57 import static org.apache.flink.util.Preconditions.checkNotNull;
  58 
  59 
  60 /**
  61  * Date: 2020/10/14
  62  * Company: www.dtstack.com
  63  *
  64  * @author tiezhu
  65  */
  66 public class ImpalaOutputFormat extends AbstractDtRichOutputFormat&lt;Tuple2&lt;Boolean, Row&gt;&gt; {
  67     private static final Logger LOG = LoggerFactory.getLogger(ImpalaOutputFormat.class);
  68 
  69     private static final long serialVersionUID = 1L;
  70 
  71     // ${field}
  72     // ${field}
  73     private static final Pattern STATIC_PARTITION_PATTERN = Pattern.compile(&quot;\\$\\{([^}]*)}&quot;);
  74 
  75     // specific type which values need to be quoted
<abbr title="  76     private static final String[] NEED_QUOTE_TYPE = new java.lang.String[]{ &quot;string&quot;, &quot;timestamp&quot;, &quot;varchar&quot; };">  76     private static final String[] NEED_QUOTE_TYPE = new java.lang.String[]{ &quot;string&quot;, &quot;timestamp&quot;, &quot;varch🔵</abbr>
  77 
  78     private static final Integer DEFAULT_CONN_TIME_OUT = 60;
  79 
  80     private static final int RECEIVE_DATA_PRINT_FREQUENCY = 1000;
  81 
  82     private static final int DIRTY_DATA_PRINT_FREQUENCY = 1000;
  83 
  84     private static final String KUDU_TYPE = &quot;kudu&quot;;
  85 
  86     private static final String UPDATE_MODE = &quot;update&quot;;
  87 
  88     private static final String PARTITION_CONSTANT = &quot;PARTITION&quot;;
  89 
  90     private static final String DRIVER_NAME = &quot;com.cloudera.impala.jdbc41.Driver&quot;;
  91 
  92     private static final String VALUES_CONDITION = &quot;${valuesCondition}&quot;;
  93 
  94     private static final String PARTITION_CONDITION = &quot;${partitionCondition}&quot;;
  95 
  96     private static final String TABLE_FIELDS_CONDITION = &quot;${tableFieldsCondition}&quot;;
  97 
  98     private static final String NO_PARTITION = &quot;noPartition&quot;;
  99 
 100     // partition field of static partition which matched by ${field}
 101     // partition field of static partition which matched by ${field}
 102     private final List&lt;String&gt; staticPartitionFields = new ArrayList&lt;&gt;();
 103 
 104     public List&lt;String&gt; fieldNames;
 105 
 106     public List&lt;String&gt; fieldTypes;
 107 
 108     public List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfoList;
 109 
 110     protected transient Connection connection;
 111 
 112     protected transient Statement statement;
 113 
 114     protected transient PreparedStatement updateStatement;
 115 
 116     protected String keytabPath;
 117 
 118     protected String krb5confPath;
 119 
 120     protected String principal;
 121 
 122     protected Integer authMech;
 123 
 124     protected String dbUrl;
 125 
 126     protected String userName;
 127 
 128     protected String password;
 129 
 130     protected int batchSize = 100;
 131 
 132     protected long batchWaitInterval = 60 * 1000L;
 133 
 134     protected String tableName;
 135 
 136     protected List&lt;String&gt; primaryKeys;
 137 
 138     protected String partitionFields;
 139 
 140     protected Boolean enablePartition;
 141 
 142     protected String schema;
 143 
 144     protected String storeType;
 145 
 146     protected String updateMode;
 147 
 148     private transient volatile boolean closed = false;
 149 
 150     private int batchCount = 0;
 151 
 152     // |------------------------------------------------|
 153     // |   partitionCondition   |Array of valueCondition|
 154     // |------------------------------------------------|
 155     // | ptOne, ptTwo, ptThree  | [(v1, v2, v3, v4, v5)]|   DP
 156     // |------------------------------------------------|
 157     // | ptOne = v1, ptTwo = v2 | [(v3, v4, v5)]        |   SP
 158     // |------------------------------------------------|
 159     // | ptOne, ptTwo = v2      | [(v1, v3, v4, v5)]    |   DP and SP
 160     // |------------------------------------------------|
 161     // | noPartition            | [(v1, v2, v3, v4, v5)]|   kudu or disablePartition
 162     // |------------------------------------------------|
 163     private transient Map&lt;String, ArrayList&lt;String&gt;&gt; rowDataMap;
 164 
 165     // valueFieldsName -&gt; 重组之后的fieldNames，为了重组row data字段值对应
 166     // 需要对partition字段做特殊处理，比如原来的字段顺序为(age, name, id)，但是因为partition，写入的SQL为
 167     // INSERT INTO tableName(name, id) PARTITION(age) VALUES(?, ?, ?)
 168     // 那么实际executeSql设置字段的顺序应该为(name, id, age)，同时，字段对应的type顺序也需要重组
 169     private List&lt;String&gt; valueFieldNames;
 170 
 171     private transient AbstractDtRichOutputFormat&lt;?&gt; metricOutputFormat;
 172 
 173     private List&lt;Row&gt; rows;
 174 
 175     private transient ScheduledExecutorService scheduler;
 176 
 177     private transient ScheduledFuture&lt;?&gt; scheduledFuture;
 178 
 179     public static Builder getImpalaBuilder() {
 180         return new Builder();
 181     }
 182 
 183     @Override
 184     public void configure(Configuration parameters) {
 185     }
 186 
 187     @Override
 188     public void open(int taskNumber, int numTasks) throws IOException {
 189         try {
 190             rowDataMap = new HashMap&lt;&gt;();
 191             rows = new ArrayList&lt;&gt;();
 192             metricOutputFormat = this;
 193             openConnect();
 194             initScheduledTask(batchWaitInterval);
 195             init();
 196             initMetric();
 197         } catch (Exception e) {
 198             throw new RuntimeException(&quot;impala output format open error!&quot;, e);
 199         }
 200     }
 201 
 202     private void init() throws SQLException {
 203         if (Objects.nonNull(partitionFields)) {
 204             // match ${field} from partitionFields
 205             Matcher matcher = STATIC_PARTITION_PATTERN.matcher(partitionFields);
 206             while (matcher.find()) {
 207                 LOG.info(&quot;find static partition field: {}&quot;, matcher.group(1));
 208                 staticPartitionFields.add(matcher.group(1));
 209             }
 210         }
 211 
 212         if (updateMode.equalsIgnoreCase(UPDATE_MODE)) {
 213             if (!storeType.equalsIgnoreCase(KUDU_TYPE)) {
 214                 throw new IllegalArgumentException(&quot;update mode not support for non-kudu table!&quot;);
 215             }
<abbr title=" 216             updateStatement = connection.prepareStatement(buildUpdateSql(schema, tableName, fieldNames, primaryKeys));"> 216             updateStatement = connection.prepareStatement(buildUpdateSql(schema, tableName, fieldNames, p🔵</abbr>
 217         } else {
<abbr title=" 218             valueFieldNames = rebuildFieldNameListAndTypeList(fieldNames, staticPartitionFields, fieldTypes, partitionFields);"> 218             valueFieldNames = rebuildFieldNameListAndTypeList(fieldNames, staticPartitionFields, fieldTyp🔵</abbr>
 219         }
 220 
 221     }
 222 
 223     private void initScheduledTask(Long batchWaitInterval) {
 224         try {
 225             if (batchWaitInterval != 0) {
<abbr title=" 226                 this.scheduler = new ScheduledThreadPoolExecutor(1, new DTThreadFactory(&quot;impala-upsert-output-format&quot;));"> 226                 this.scheduler = new ScheduledThreadPoolExecutor(1, new DTThreadFactory(&quot;impala-upsert-ou🔵</abbr>
 227                 this.scheduledFuture = this.scheduler.scheduleWithFixedDelay(() -&gt; {
 228                     synchronized(this) {
 229                         flush();
 230                     }
 231                 }, batchWaitInterval, batchWaitInterval, TimeUnit.MILLISECONDS);
 232             }
 233         } catch (java.lang.Exception e) {
 234             throw new RuntimeException(e);
 235         }
 236     }
 237 
 238     private void openConnect() throws IOException {
 239         if (authMech == 1) {
 240             UserGroupInformation ugi = KrbUtils.loginAndReturnUgi(principal, keytabPath, krb5confPath);
 241             try {
 242                 ugi.doAs((PrivilegedExceptionAction&lt;Void&gt;) () -&gt; {
 243                     openJdbc();
 244                     return null;
 245                 });
 246             } catch (InterruptedException | IOException e) {
 247                 throw new IllegalArgumentException(&quot;connect impala error!&quot;, e);
 248             }
 249         } else {
 250             openJdbc();
 251         }
 252     }
 253 
 254     /**
 255      * get jdbc connection
 256      */
 257     private void openJdbc() {
 258         ClassLoaderManager.forName(DRIVER_NAME, getClass().getClassLoader());
 259         try {
 260             connection = DriverManager.getConnection(dbUrl, userName, password);
 261             statement = connection.createStatement();
 262             connection.setAutoCommit(false);
 263         } catch (SQLException sqlException) {
 264             throw new RuntimeException(&quot;get impala jdbc connection failed!&quot;, sqlException);
 265         }
 266     }
 267 
 268     private synchronized void flush() {
 269         try {
 270             if (batchCount &gt; 0) {
 271                 if (updateMode.equalsIgnoreCase(UPDATE_MODE)) {
 272                     executeUpdateBatch();
 273                 }
 274                 if (!rowDataMap.isEmpty()) {
<abbr title=" 275                     String templateSql = &quot;INSERT INTO tableName ${tableFieldsCondition} PARTITION ${partitionCondition} VALUES ${valuesCondition}&quot;;"> 275                     String templateSql = &quot;INSERT INTO tableName ${tableFieldsCondition} PARTITION ${parti🔵</abbr>
<abbr title=" 276                     executeBatchSql(templateSql, schema, tableName, storeType, enablePartition, valueFieldNames, partitionFields, rowDataMap);"> 276                     executeBatchSql(templateSql, schema, tableName, storeType, enablePartition, valueFiel🔵</abbr>
 277                     rowDataMap.clear();
 278                 }
 279             }
 280             batchCount = 0;
 281         } catch (java.lang.Exception e) {
 282             LOG.error(&quot;Writing records to impala jdbc failed.&quot;, e);
 283             throw new RuntimeException(&quot;Writing records to impala jdbc failed.&quot;, e);
 284         }
 285     }
 286 
 287     /**
 288      * execute batch update statement
 289      *
 290      * @throws SQLException throw sql exception
 291      */
 292     private void executeUpdateBatch() throws SQLException {
 293         try {
 294             rows.forEach(( row) -&gt; {
 295                 try {
<abbr title=" 296                     JDBCTypeConvertUtils.setRecordToStatement(updateStatement, JDBCTypeConvertUtils.getSqlTypeFromFieldType(fieldTypes), row, primaryKeys.stream().mapToInt(fieldNames::indexOf).toArray());"> 296                     JDBCTypeConvertUtils.setRecordToStatement(updateStatement, JDBCTypeConvertUtils.getSq🔵</abbr>
 297                     updateStatement.addBatch();
 298                 } catch ( e) {
 299                     throw new &lt;e&gt;RuntimeException(&quot;impala jdbc execute batch error!&quot;);
 300                 }
 301             });
 302             updateStatement.executeBatch();
 303             connection.commit();
 304             rows.clear();
 305         } catch (java.lang.Exception e) {
 306             LOG.debug(&quot;impala jdbc execute batch error &quot;, e);
 307             JDBCUtils.rollBack(connection);
 308             JDBCUtils.commit(connection);
 309             updateStatement.clearBatch();
 310             executeUpdate(connection);
 311         }
 312     }
 313 
 314     public void executeUpdate(Connection connection) {
 315         rows.forEach(( row) -&gt; {
 316             try {
<abbr title=" 317                 setRecordToStatement(updateStatement, JDBCTypeConvertUtils.getSqlTypeFromFieldType(fieldTypes), row);"> 317                 setRecordToStatement(updateStatement, JDBCTypeConvertUtils.getSqlTypeFromFieldType(fieldT🔵</abbr>
 318                 updateStatement.executeUpdate();
 319                 JDBCUtils.commit(connection);
 320             } catch ( e) {
 321                 JDBCUtils.rollBack(connection);
 322                 JDBCUtils.commit(connection);
<abbr title=" 323                 if (((metricOutputFormat.outDirtyRecords.getCount() % DIRTY_DATA_PRINT_FREQUENCY) == 0) || LOG.isDebugEnabled()) {"> 323                 if (((metricOutputFormat.outDirtyRecords.getCount() % DIRTY_DATA_PRINT_FREQUENCY) == 0) |🔵</abbr>
 324                     LOG.error(&quot;record insert failed ,this row is {}&quot;, row.toString());
 325                     LOG.error(&quot;&quot;, e);
 326                 }
 327                 metricOutputFormat.outDirtyRecords.inc();
 328             }
 329         });
 330         rows.clear();
 331     }
 332 
<abbr title=" 333     private void putRowIntoMap(Map&lt;String, ArrayList&lt;String&gt;&gt; rowDataMap, Tuple2&lt;String, String&gt; rowData) {"> 333     private void putRowIntoMap(Map&lt;String, ArrayList&lt;String&gt;&gt; rowDataMap, Tuple2&lt;String, String&gt; rowData)🔵</abbr>
 334         Set&lt;String&gt; keySet = rowDataMap.keySet();
 335         ArrayList&lt;String&gt; tempRowArray;
 336         if (keySet.contains(rowData.f0)) {
 337             tempRowArray = rowDataMap.get(rowData.f0);
 338         } else {
 339             tempRowArray = new ArrayList&lt;&gt;();
 340         }
 341         tempRowArray.add(rowData.f1);
 342         rowDataMap.put(rowData.f0, tempRowArray);
 343     }
 344 
<abbr title=" 345     private List&lt;String&gt; rebuildFieldNameListAndTypeList(List&lt;String&gt; fieldNames, List&lt;String&gt; staticPartitionFields, List&lt;String&gt; fieldTypes, String partitionFields) {"> 345     private List&lt;String&gt; rebuildFieldNameListAndTypeList(List&lt;String&gt; fieldNames, List&lt;String&gt; staticPart🔵</abbr>
 346         if (partitionFields == null || partitionFields.isEmpty()) {
 347             return fieldNames;
 348         }
 349 
 350         List&lt;String&gt; valueFields = new ArrayList&lt;&gt;(fieldNames);
 351 
 352         for (int i = valueFields.size() - 1; i &gt;= 0; i--) {
 353             if (staticPartitionFields.contains(fieldNames.get(i))) {
 354                 valueFields.remove(i);
 355                 fieldTypes.remove(i);
 356             }
 357         }
 358 
 359         for (int i = 0; i &lt; valueFields.size(); i++) {
 360             if (partitionFields.contains(fieldNames.get(i))) {
 361                 valueFields.add(valueFields.remove(i));
 362                 fieldTypes.add(fieldTypes.remove(i));
 363             }
 364         }
 365 
 366         return valueFields;
 367     }
 368 
 369     @Override
 370     public void writeRecord(Tuple2&lt;Boolean, Row&gt; record) throws IOException {
 371         try {
 372             if (!record.f0) {
 373                 return;
 374             }
 375             if (((outRecords.getCount() % RECEIVE_DATA_PRINT_FREQUENCY) == 0) || LOG.isDebugEnabled()) {
 376                 LOG.info(&quot;Receive data : {}&quot;, record);
 377             }
 378             if (updateMode.equalsIgnoreCase(UPDATE_MODE)) {
 379                 rows.add(Row.copy(record.f1));
 380             } else {
 381                 Map&lt;String, Object&gt; valueMap = Maps.newHashMap();
 382                 Row row = Row.copy(record.f1);
 383                 for (int i = 0; i &lt; row.getArity(); i++) {
 384                     valueMap.put(fieldNames.get(i), row.getField(i));
 385                 }
 386                 Tuple2&lt;String, String&gt; rowTuple2 = new Tuple2&lt;&gt;();
 387                 if (storeType.equalsIgnoreCase(KUDU_TYPE) || (!enablePartition)) {
 388                     rowTuple2.f0 = NO_PARTITION;
 389                 } else {
<abbr title=" 390                     rowTuple2.f0 = buildPartitionCondition(valueMap, partitionFields, staticPartitionFields);"> 390                     rowTuple2.f0 = buildPartitionCondition(valueMap, partitionFields, staticPartitionFiel🔵</abbr>
 391                 }
 392                 // 根据字段名对 row data 重组, 比如，原始 row data : (1, xxx, 20) -&gt; (id, name, age)
 393                 // 但是由于 partition，写入的field 顺序变成了 (name, id, age)，则需要对 row data 重组变成 (xxx, 1, 20)
 394                 Row rowValue = new Row(fieldTypes.size());
 395                 for (int i = 0; i &lt; fieldTypes.size(); i++) {
 396                     rowValue.setField(i, valueMap.get(valueFieldNames.get(i)));
 397                 }
 398                 rowTuple2.f1 = buildValuesCondition(fieldTypes, rowValue);
 399                 putRowIntoMap(rowDataMap, rowTuple2);
 400             }
 401             batchCount++;
 402             if (batchCount &gt;= batchSize) {
 403                 flush();
 404             }
 405             // Receive data
 406             outRecords.inc();
 407         } catch (java.lang.Exception e) {
 408             throw new IOException(&quot;Writing records to impala failed.&quot;, e);
 409         }
 410     }
 411 
 412     @Override
 413     public void close() throws IOException {
 414         if (closed) {
 415             return;
 416         }
 417         // 将还未执行的SQL flush
 418         if (batchCount &gt; 0) {
 419             flush();
 420         }
 421         // cancel scheduled task
 422         if (this.scheduledFuture != null) {
 423             scheduledFuture.cancel(false);
 424             this.scheduler.shutdown();
 425         }
 426         // close connection
 427         try {
 428             if ((connection != null) &amp;&amp; connection.isValid(DEFAULT_CONN_TIME_OUT)) {
 429                 connection.close();
 430             }
 431             if ((statement != null) &amp;&amp; (!statement.isClosed())) {
 432                 statement.close();
 433             }
 434             if ((updateStatement != null) &amp;&amp; (!updateStatement.isClosed())) {
 435                 updateStatement.close();
 436             }
 437         } catch (SQLException e) {
 438             throw new RuntimeException(&quot;impala connection close failed!&quot;, e);
 439         } finally {
 440             connection = null;
 441             statement = null;
 442             updateStatement = null;
 443         }
 444         closed = true;
 445     }
 446 
 447     /**
 448      * execute batch sql from row data map
<abbr title=" 449      * sql like &#x27;insert into tableName(f1, f2, f3) ${partitionCondition} values(v1, v2, v3), (v4, v5, v6)...."> 449      * sql like &#x27;insert into tableName(f1, f2, f3) ${partitionCondition} values(v1, v2, v3), (v4, v5, v6)🔵</abbr>
 450      *
 451      * @param tempSql         template sql
 452      * @param storeType       the store type of data
 453      * @param enablePartition enable partition or not
 454      * @param fieldNames      field name list
 455      * @param partitionFields partition fields
 456      * @param rowDataMap      row data map
 457      */
<abbr title=" 458     private void executeBatchSql(String tempSql, String schema, String tableName, String storeType, Boolean enablePartition, List&lt;String&gt; fieldNames, String partitionFields, Map&lt;String, ArrayList&lt;String&gt;&gt; rowDataMap) {"> 458     private void executeBatchSql(String tempSql, String schema, String tableName, String storeType, Boole🔵</abbr>
 459         StringBuilder partitionCondition = new StringBuilder();
 460         String tableFieldsCondition = buildTableFieldsCondition(fieldNames, partitionFields);
 461         ArrayList&lt;String&gt; rowData = new ArrayList&lt;&gt;();
<abbr title=" 462         String tableNameInfo = (Objects.isNull(schema)) ? tableName : (quoteIdentifier(schema) + &quot;.&quot;) + tableName;"> 462         String tableNameInfo = (Objects.isNull(schema)) ? tableName : (quoteIdentifier(schema) + &quot;.&quot;) + t🔵</abbr>
 463         tempSql = tempSql.replace(&quot;tableName&quot;, tableNameInfo);
 464         boolean isPartitioned = storeType.equalsIgnoreCase(KUDU_TYPE) || (!enablePartition);
 465         try {
 466             // kudu ${partitionCondition} is null
 467             if (isPartitioned) {
<abbr title=" 468                 tempSql = tempSql.replace(PARTITION_CONDITION, partitionCondition.toString()).replace(PARTITION_CONSTANT, &quot;&quot;).replace(TABLE_FIELDS_CONDITION, tableFieldsCondition);"> 468                 tempSql = tempSql.replace(PARTITION_CONDITION, partitionCondition.toString()).replace(PAR🔵</abbr>
 469                 rowData.addAll(rowDataMap.get(NO_PARTITION));
 470                 String executeSql = tempSql.replace(VALUES_CONDITION, String.join(&quot;, &quot;, rowData));
 471                 statement.execute(executeSql);
 472                 rowData.clear();
 473             } else {
 474                 // partition sql
 475                 Set&lt;String&gt; keySet = rowDataMap.keySet();
 476                 for (String key : keySet) {
 477                     rowData.addAll(rowDataMap.get(key));
 478                     partitionCondition.append(key);
<abbr title=" 479                     tempSql = tempSql.replace(PARTITION_CONDITION, partitionCondition.toString()).replace(TABLE_FIELDS_CONDITION, tableFieldsCondition);"> 479                     tempSql = tempSql.replace(PARTITION_CONDITION, partitionCondition.toString()).replace🔵</abbr>
 480                     String executeSql = tempSql.replace(VALUES_CONDITION, String.join(&quot;, &quot;, rowData));
 481                     statement.execute(executeSql);
 482                     partitionCondition.delete(0, partitionCondition.length());
 483                 }
 484             }
 485         } catch (java.lang.Exception e) {
 486             if (e instanceof SQLException) {
 487                 dealBatchSqlError(rowData, connection, statement, tempSql);
 488             } else {
 489                 throw new RuntimeException(&quot;Insert into impala error!&quot;, e);
 490             }
 491         } finally {
 492             rowData.clear();
 493         }
 494     }
 495 
 496     /**
 497      * 当批量写入失败时，把批量的sql拆解为单条sql提交，对于单条写入的sql记做脏数据
 498      *
 499      * @param statement
 500      * 		execute statement
 501      * @param tempSql
 502      * 		template sql
 503      * @param storeType
 504      * 		the store type of data
 505      * @param enablePartition
 506      * 		enable partition or not
 507      */
<abbr title=" 508     private void dealBatchSqlError(List&lt;String&gt; rowData, Connection connection, Statement statement, String templateSql) {"> 508     private void dealBatchSqlError(List&lt;String&gt; rowData, Connection connection, Statement statement, Stri🔵</abbr>
 509         String errorMsg = &quot;Insert into impala error. \nCause: [%s]\nRow: [%s]&quot;;
 510         JDBCUtils.rollBack(connection);
 511         JDBCUtils.commit(connection);
 512         for (String rowDatum : rowData) {
 513             String executeSql = templateSql.replace(VALUES_CONDITION, rowDatum);
 514             try {
 515                 statement.execute(executeSql);
 516                 JDBCUtils.commit(connection);
 517             } catch (SQLException e) {
 518                 JDBCUtils.rollBack(connection);
 519                 JDBCUtils.commit(connection);
<abbr title=" 520                 if (((metricOutputFormat.outDirtyRecords.getCount() % DIRTY_DATA_PRINT_FREQUENCY) == 0) || LOG.isDebugEnabled()) {"> 520                 if (((metricOutputFormat.outDirtyRecords.getCount() % DIRTY_DATA_PRINT_FREQUENCY) == 0) |🔵</abbr>
 521                     LOG.error(String.format(errorMsg, ExceptionTrace.traceOriginalCause(e), rowDatum));
 522                 }
 523                 metricOutputFormat.outDirtyRecords.inc();
 524             }
 525         }
 526     }
 527 
 528     /**
 529      * build partition condition with row data
 530      *
 531      * @param rowData              row data
 532      * @param partitionFields      partition fields
 533      * @param staticPartitionField static partition fields
 534      * @return condition like &#x27;(ptOne, ptTwo=v2)&#x27;
 535      */
<abbr title=" 536     private String buildPartitionCondition(Map&lt;String, Object&gt; rowData, String partitionFields, List&lt;String&gt; staticPartitionField) {"> 536     private String buildPartitionCondition(Map&lt;String, Object&gt; rowData, String partitionFields, List&lt;Stri🔵</abbr>
 537         for (String key : staticPartitionField) {
 538             StringBuilder sb = new StringBuilder();
 539             Object value = rowData.get(key);
 540             sb.append(key).append(&quot;=&quot;).append(value);
 541             partitionFields = partitionFields.replace(&quot;${&quot; + key + &quot;}&quot;, sb.toString());
 542         }
 543         return &quot;(&quot; + partitionFields + &quot;)&quot;;
 544     }
 545 
 546     /**
 547      * build field condition according to field names
 548      * replace ${tableFieldCondition}
 549      *
 550      * @param fieldNames      the selected field names
 551      * @param partitionFields the partition fields
 552      * @return condition like &#x27;(id, name, age)&#x27;
 553      */
 554     private String buildTableFieldsCondition(List&lt;String&gt; fieldNames, String partitionFields) {
<abbr title=" 555         return (&quot;(&quot; + fieldNames.stream().filter(( f) -&gt; !partitionFields.contains(f)).map(this::quoteIdentifier).collect(Collectors.joining(&quot;, &quot;))) + &quot;)&quot;;"> 555         return (&quot;(&quot; + fieldNames.stream().filter(( f) -&gt; !partitionFields.contains(f)).map(this::quoteIde🔵</abbr>
 556     }
 557 
 558     /**
 559      * according to field types, build the values condition
 560      * replace ${valuesCondition}
 561      *
 562      * @param fieldTypes field types
 563      * @return condition like &#x27;(?, ?, cast(? as string))&#x27; and &#x27;?&#x27; will be replaced with row data
 564      */
 565     private String buildValuesCondition(List&lt;String&gt; fieldTypes, Row row) {
 566         String valuesCondition = fieldTypes.stream().map(( f) -&gt; {
 567             for (String item : NEED_QUOTE_TYPE) {
 568                 if (f.toLowerCase().contains(item)) {
 569                     return String.format(&quot;cast(\&#x27;?\&#x27; as %s)&quot;, f.toLowerCase());
 570                 }
 571             }
 572             return &quot;?&quot;;
 573         }).collect(Collectors.joining(&quot;, &quot;));
 574         for (int i = 0; i &lt; row.getArity(); i++) {
 575             Object rowField = row.getField(i);
 576             if (DtStringUtil.isEmptyOrNull(rowField)) {
 577                 valuesCondition = valuesCondition.replaceFirst(&quot;\&#x27;\\?\&#x27;&quot;, &quot;null&quot;);
 578             } else {
 579                 valuesCondition = valuesCondition.replaceFirst(&quot;\\?&quot;, rowField.toString());
 580             }
 581         }
 582         return (&quot;(&quot; + valuesCondition) + &quot;)&quot;;
 583     }
 584 
 585     /**
 586      * impala update mode SQL
 587      *
 588      * @return UPDATE tableName SET setCondition WHERE whereCondition
 589      */
<abbr title=" 590     private String buildUpdateSql(String schema, String tableName, List&lt;String&gt; fieldNames, List&lt;String&gt; primaryKeys) {"> 590     private String buildUpdateSql(String schema, String tableName, List&lt;String&gt; fieldNames, List&lt;String&gt; 🔵</abbr>
 591         //跳过primary key字段
<abbr title=" 592         String setClause = fieldNames.stream().filter(( f) -&gt; (!CollectionUtils.isNotEmpty(primaryKeys)) || (!primaryKeys.contains(f))).map(( f) -&gt; quoteIdentifier(f) + &quot;=?&quot;).collect(Collectors.joining(&quot;, &quot;));"> 592         String setClause = fieldNames.stream().filter(( f) -&gt; (!CollectionUtils.isNotEmpty(primaryKeys)) 🔵</abbr>
<abbr title=" 593         String conditionClause = primaryKeys.stream().map(( f) -&gt; quoteIdentifier(f) + &quot;=?&quot;).collect(Collectors.joining(&quot; AND &quot;));"> 593         String conditionClause = primaryKeys.stream().map(( f) -&gt; quoteIdentifier(f) + &quot;=?&quot;).collect(Coll🔵</abbr>
<abbr title=" 594         return (((((&quot;UPDATE &quot; + (Objects.isNull(schema) ? &quot;&quot; : quoteIdentifier(schema) + &quot;.&quot;)) + quoteIdentifier(tableName)) + &quot; SET &quot;) + setClause) + &quot; WHERE &quot;) + conditionClause;"> 594         return (((((&quot;UPDATE &quot; + (Objects.isNull(schema) ? &quot;&quot; : quoteIdentifier(schema) + &quot;.&quot;)) + quoteIde🔵</abbr>
 595     }
 596 
 597     private String quoteIdentifier(String identifier) {
 598         return &quot;`&quot; + identifier + &quot;`&quot;;
 599     }
 600 
 601     public static class Builder {
 602         private final ImpalaOutputFormat format = new ImpalaOutputFormat();
 603 
 604         public Builder setDbUrl(String dbUrl) {
 605             format.dbUrl = dbUrl;
 606             return this;
 607         }
 608 
 609         public Builder setUserName(String userName) {
 610             format.userName = userName;
 611             return this;
 612         }
 613 
 614         public Builder setPassword(String password) {
 615             format.password = password;
 616             return this;
 617         }
 618 
 619         public Builder setBatchSize(Integer batchSize) {
 620             format.batchSize = batchSize;
 621             return this;
 622         }
 623 
 624         public Builder setBatchWaitInterval(Long batchWaitInterval) {
 625             format.batchWaitInterval = batchWaitInterval;
 626             return this;
 627         }
 628 
 629         public Builder setTableName(String tableName) {
 630             format.tableName = tableName;
 631             return this;
 632         }
 633 
 634         public Builder setPartitionFields(String partitionFields) {
 635             format.partitionFields = (Objects.isNull(partitionFields)) ? &quot;&quot; : partitionFields;
 636             return this;
 637         }
 638 
 639         public Builder setPrimaryKeys(List&lt;String&gt; primaryKeys) {
 640             format.primaryKeys = primaryKeys;
 641             return this;
 642         }
 643 
 644         public Builder setSchema(String schema) {
 645             format.schema = schema;
 646             return this;
 647         }
 648 
 649         public Builder setEnablePartition(Boolean enablePartition) {
 650             format.enablePartition = enablePartition;
 651             return this;
 652         }
 653 
 654         public Builder setUpdateMode(String updateMode) {
 655             format.updateMode = updateMode;
 656             return this;
 657         }
 658 
 659         public Builder setFieldList(List&lt;String&gt; fieldList) {
 660             format.fieldNames = fieldList;
 661             return this;
 662         }
 663 
 664         public Builder setFieldTypeList(List&lt;String&gt; fieldTypeList) {
 665             format.fieldTypes = fieldTypeList;
 666             return this;
 667         }
 668 
 669         public Builder setStoreType(String storeType) {
 670             format.storeType = storeType;
 671             return this;
 672         }
 673 
 674         public Builder setFieldExtraInfoList(List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfoList) {
 675             format.fieldExtraInfoList = fieldExtraInfoList;
 676             return this;
 677         }
 678 
 679         public Builder setKeyTabPath(String keyTabPath) {
 680             format.keytabPath = keyTabPath;
 681             return this;
 682         }
 683 
 684         public Builder setKrb5ConfPath(String krb5ConfPath) {
 685             format.krb5confPath = krb5ConfPath;
 686             return this;
 687         }
 688 
 689         public Builder setPrincipal(String principal) {
 690             format.principal = principal;
 691             return this;
 692         }
 693 
 694         public Builder setAuthMech(Integer authMech) {
 695             format.authMech = authMech;
 696             return this;
 697         }
 698 
 699         private boolean canHandle(String url) {
 700             return url.startsWith(&quot;jdbc:impala:&quot;);
 701         }
 702 
 703         public ImpalaOutputFormat build() {
 704             if (!canHandle(format.dbUrl)) {
<abbr title=" 705                 throw new IllegalArgumentException(&quot;impala dbUrl is illegal, check url: &quot; + format.dbUrl);"> 705                 throw new IllegalArgumentException(&quot;impala dbUrl is illegal, check url: &quot; + format.dbUrl)🔵</abbr>
 706             }
 707             if (format.authMech == EAuthMech.Kerberos.getType()) {
<abbr title=" 708                 checkNotNull(format.krb5confPath, &quot;When kerberos authentication is enabled, krb5confPath is required！&quot;);"> 708                 checkNotNull(format.krb5confPath, &quot;When kerberos authentication is enabled, krb5confPath 🔵</abbr>
<abbr title=" 709                 checkNotNull(format.principal, &quot;When kerberos authentication is enabled, principal is required！&quot;);"> 709                 checkNotNull(format.principal, &quot;When kerberos authentication is enabled, principal is req🔵</abbr>
<abbr title=" 710                 checkNotNull(format.keytabPath, &quot;When kerberos authentication is enabled, keytabPath is required！&quot;);"> 710                 checkNotNull(format.keytabPath, &quot;When kerberos authentication is enabled, keytabPath is r🔵</abbr>
 711             }
 712             if (format.authMech == EAuthMech.UserName.getType()) {
 713                 checkNotNull(format.userName, &quot;userName is required!&quot;);
 714             }
 715             if (format.authMech == EAuthMech.NameANDPassword.getType()) {
 716                 checkNotNull(format.userName, &quot;userName is required!&quot;);
 717                 checkNotNull(format.password, &quot;password is required!&quot;);
 718             }
 719             checkNotNull(format.storeType, &quot;storeType is required!&quot;);
 720             return format;
 721         }
 722     }
 723 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.sink.impala;
  20  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  21 +import com.dtstack.flink.sql.classloader.ClassLoaderManager;</span>
  22  import com.dtstack.flink.sql.factory.DTThreadFactory;
  23  import com.dtstack.flink.sql.outputformat.AbstractDtRichOutputFormat;
  24  import com.dtstack.flink.sql.sink.rdb.JDBCTypeConvertUtils;
  25  import com.dtstack.flink.sql.table.AbstractTableInfo;

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  26 -import com.dtstack.flink.sql.util.JDBCUtils;</span>
  27  import com.dtstack.flink.sql.util.KrbUtils;
  28  import com.google.common.collect.Maps;
  29  import org.apache.commons.collections.CollectionUtils;
  30  import org.apache.flink.api.java.tuple.Tuple2;
  31  import org.apache.flink.configuration.Configuration;
  32  import org.apache.flink.types.Row;
  33  import org.apache.hadoop.security.UserGroupInformation;
  34  import org.slf4j.Logger;
  35  import org.slf4j.LoggerFactory;
  36  
  37  import java.io.IOException;
  38  import java.security.PrivilegedExceptionAction;
  39  import java.sql.Connection;
  40  import java.sql.DriverManager;
  41  import java.sql.PreparedStatement;
  42  import java.sql.SQLException;
  43  import java.sql.Statement;
  44  import java.util.ArrayList;
  45  import java.util.Arrays;
  46  import java.util.HashMap;
  47  import java.util.List;
  48  import java.util.Map;
  49  import java.util.Objects;
  50  import java.util.Set;
  51  import java.util.concurrent.ScheduledExecutorService;
  52  import java.util.concurrent.ScheduledFuture;
  53  import java.util.concurrent.ScheduledThreadPoolExecutor;
  54  import java.util.concurrent.TimeUnit;
  55  import java.util.regex.Matcher;
  56  import java.util.regex.Pattern;
  57  import java.util.stream.Collectors;
  58  
  59  import static com.dtstack.flink.sql.sink.rdb.JDBCTypeConvertUtils.setRecordToStatement;
  60  import static org.apache.flink.util.Preconditions.checkNotNull;
  61  
  62  /**
  63   * Date: 2020/10/14
  64   * Company: www.dtstack.com
  65   *
  66   * @author tiezhu
  67   */
  68  public class ImpalaOutputFormat extends AbstractDtRichOutputFormat&lt;Tuple2&lt;Boolean, Row&gt;&gt; {
  69  
  70      private static final Logger LOG = LoggerFactory.getLogger(ImpalaOutputFormat.class);
  71  
  72      private static final long serialVersionUID = 1L;
  73  
  74      // ${field}
  75      private static final Pattern STATIC_PARTITION_PATTERN = Pattern.compile(&quot;\\$\\{([^}]*)}&quot;);
  76      // cast(value as string) -&gt; cast(&#x27;value&#x27; as string)  cast(value as timestamp) -&gt; cast(&#x27;value&#x27; as timestamp)
  77      private static final Pattern TYPE_PATTERN = Pattern.compile(&quot;cast\\((.*) as (.*)\\)&quot;);
  78      //specific type which values need to be quoted
  79      private static final String[] NEED_QUOTE_TYPE = {&quot;string&quot;, &quot;timestamp&quot;, &quot;varchar&quot;};
  80  
  81      private static final Integer DEFAULT_CONN_TIME_OUT = 60;
  82      private static final int RECEIVE_DATA_PRINT_FREQUENCY = 1000;
  83      private static final int DIRTY_DATA_PRINT_FREQUENCY = 1000;
  84  
  85      private static final String KUDU_TYPE = &quot;kudu&quot;;
  86      private static final String UPDATE_MODE = &quot;update&quot;;
  87      private static final String PARTITION_CONSTANT = &quot;PARTITION&quot;;
  88      private static final String DRIVER_NAME = &quot;com.cloudera.impala.jdbc41.Driver&quot;;
  89  
  90      private static final String VALUES_CONDITION = &quot;${valuesCondition}&quot;;
  91      private static final String PARTITION_CONDITION = &quot;${partitionCondition}&quot;;
  92      private static final String TABLE_FIELDS_CONDITION = &quot;${tableFieldsCondition}&quot;;
  93      private static final String NO_PARTITION = &quot;noPartition&quot;;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  94 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  95 +    // partition field of static partition which matched by ${field}</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  96 +    private final List&lt;String&gt; staticPartitionFields = new ArrayList&lt;&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  97 +    public List&lt;String&gt; fieldNames;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  98 +    public List&lt;String&gt; fieldTypes;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  99 +    public List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfoList;</span>
 100      protected transient Connection connection;
 101      protected transient Statement statement;
 102      protected transient PreparedStatement updateStatement;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 103 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 104 -    private transient volatile boolean closed = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 105 -    private int batchCount = 0;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 106 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 107 -    // |------------------------------------------------|</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 108 -    // |   partitionCondition   |Array of valueCondition|</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 109 -    // |------------------------------------------------|</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 110 -    // | ptOne, ptTwo, ptThree  | [(v1, v2, v3, v4, v5)]|   DP</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 111 -    // |------------------------------------------------|</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 112 -    // | ptOne = v1, ptTwo = v2 | [(v3, v4, v5)]        |   SP</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 113 -    // |------------------------------------------------|</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 114 -    // | ptOne, ptTwo = v2      | [(v1, v3, v4, v5)]    |   DP and SP</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 115 -    // |------------------------------------------------|</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 116 -    // | noPartition            | [(v1, v2, v3, v4, v5)]|   kudu or disablePartition</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 117 -    // |------------------------------------------------|</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 118 -    private transient Map&lt;String, ArrayList&lt;String&gt;&gt; rowDataMap;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 119 -</span>
 120      protected String keytabPath;
 121      protected String krb5confPath;
 122      protected String principal;
 123      protected Integer authMech;
 124      protected String dbUrl;
 125      protected String userName;
 126      protected String password;
 127      protected int batchSize = 100;
 128      protected long batchWaitInterval = 60 * 1000L;
 129      protected String tableName;
 130      protected List&lt;String&gt; primaryKeys;
 131      protected String partitionFields;
 132      protected Boolean enablePartition;
 133      protected String schema;
 134      protected String storeType;
 135      protected String updateMode;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 136 -    public List&lt;String&gt; fieldNames;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 137 -    public List&lt;String&gt; fieldTypes;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 138 -    public List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfoList;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 139 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 140 -    // partition field of static partition which matched by ${field}</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 141 -    private final List&lt;String&gt; staticPartitionFields = new ArrayList&lt;&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 142 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 143 +    private transient volatile boolean closed = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 144 +    private int batchCount = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 145 +    // |------------------------------------------------|</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 146 +    // |   partitionCondition   |Array of valueCondition|</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 147 +    // |------------------------------------------------|</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 148 +    // | ptOne, ptTwo, ptThree  | [(v1, v2, v3, v4, v5)]|   DP</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 149 +    // |------------------------------------------------|</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 150 +    // | ptOne = v1, ptTwo = v2 | [(v3, v4, v5)]        |   SP</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 151 +    // |------------------------------------------------|</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 152 +    // | ptOne, ptTwo = v2      | [(v1, v3, v4, v5)]    |   DP and SP</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 153 +    // |------------------------------------------------|</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 154 +    // | noPartition            | [(v1, v2, v3, v4, v5)]|   kudu or disablePartition</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 155 +    // |------------------------------------------------|</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 156 +    private transient Map&lt;String, ArrayList&lt;String&gt;&gt; rowDataMap;</span>
 157      // valueFieldsName -&gt; 重组之后的fieldNames，为了重组row data字段值对应
 158      // 需要对partition字段做特殊处理，比如原来的字段顺序为(age, name, id)，但是因为partition，写入的SQL为
 159      // INSERT INTO tableName(name, id) PARTITION(age) VALUES(?, ?, ?)
 160      // 那么实际executeSql设置字段的顺序应该为(name, id, age)，同时，字段对应的type顺序也需要重组
 161      private List&lt;String&gt; valueFieldNames;
 162      private transient AbstractDtRichOutputFormat&lt;?&gt; metricOutputFormat;
 163      private List&lt;Row&gt; rows;
 164  
 165      private transient ScheduledExecutorService scheduler;
 166      private transient ScheduledFuture&lt;?&gt; scheduledFuture;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 167 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 168 +    public static Builder getImpalaBuilder() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 169 +        return new Builder();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 170 +    }</span>
 171  
 172      @Override
 173      public void configure(Configuration parameters) {
 174      }
 175  
 176      @Override
 177      public void open(int taskNumber, int numTasks) throws IOException {
 178          try {
 179              rowDataMap = new HashMap&lt;&gt;();
 180              rows = new ArrayList&lt;&gt;();
 181              metricOutputFormat = this;
 182              openConnect();
 183              initScheduledTask(batchWaitInterval);
 184              init();
 185              initMetric();
 186          } catch (Exception e) {
 187              throw new RuntimeException(&quot;impala output format open error!&quot;, e);
 188          }
 189      }
 190  
 191      private void init() throws SQLException {
 192          if (Objects.nonNull(partitionFields)) {
 193              // match ${field} from partitionFields
 194              Matcher matcher = STATIC_PARTITION_PATTERN.matcher(partitionFields);
 195              while (matcher.find()) {
 196                  LOG.info(&quot;find static partition field: {}&quot;, matcher.group(1));
 197                  staticPartitionFields.add(matcher.group(1));
 198              }
 199          }
 200  
 201          if (updateMode.equalsIgnoreCase(UPDATE_MODE)) {
 202              if (!storeType.equalsIgnoreCase(KUDU_TYPE)) {
 203                  throw new IllegalArgumentException(&quot;update mode not support for non-kudu table!&quot;);
 204              }
<abbr title=" 205              updateStatement = connection.prepareStatement(buildUpdateSql(schema, tableName, fieldNames, primaryKeys));"> 205              updateStatement = connection.prepareStatement(buildUpdateSql(schema, tableName, fieldNames, primaryKey🔵</abbr>
 206          } else {
<abbr title=" 207              valueFieldNames = rebuildFieldNameListAndTypeList(fieldNames, staticPartitionFields, fieldTypes, partitionFields);"> 207              valueFieldNames = rebuildFieldNameListAndTypeList(fieldNames, staticPartitionFields, fieldTypes, parti🔵</abbr>
 208          }
 209  
 210      }
 211  
 212      private void initScheduledTask(Long batchWaitInterval) {
 213          try {
 214              if (batchWaitInterval != 0) {
 215                  this.scheduler = new ScheduledThreadPoolExecutor(1,
 216                          new DTThreadFactory(&quot;impala-upsert-output-format&quot;));
 217                  this.scheduledFuture = this.scheduler.scheduleWithFixedDelay(() -&gt; {
 218                      synchronized (ImpalaOutputFormat.this) {
 219                          try {
 220                              flush();
 221                          } catch (Exception e) {
 222                              LOG.error(&quot;Writing records to impala jdbc failed.&quot;, e);
 223                              throw new RuntimeException(&quot;Writing records to impala jdbc failed.&quot;, e);
 224                          }

 225                      }
 226                  }, batchWaitInterval, batchWaitInterval, TimeUnit.MILLISECONDS);
 227              }
 228          } catch (Exception e) {
 229              throw new RuntimeException(e);
 230          }
 231      }
 232  
 233      private void openConnect() throws IOException {
 234          if (authMech == 1) {
 235              UserGroupInformation ugi = KrbUtils.loginAndReturnUgi(principal, keytabPath, krb5confPath);
 236              try {
 237                  ugi.doAs((PrivilegedExceptionAction&lt;Void&gt;) () -&gt; {
 238                      openJdbc();
 239                      return null;
 240                  });
 241              } catch (InterruptedException | IOException e) {
 242                  throw new IllegalArgumentException(&quot;connect impala error!&quot;, e);
 243              }
 244          } else {
 245              openJdbc();
 246          }
 247      }
 248  
 249      /**
 250       * get jdbc connection
 251       */
 252      private void openJdbc() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 253 -        JDBCUtils.forName(DRIVER_NAME, getClass().getClassLoader());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 254 +        ClassLoaderManager.forName(DRIVER_NAME, getClass().getClassLoader());</span>
 255          try {
 256              connection = DriverManager.getConnection(dbUrl, userName, password);
 257              statement = connection.createStatement();
 258              connection.setAutoCommit(false);
 259          } catch (SQLException sqlException) {
 260              throw new RuntimeException(&quot;get impala jdbc connection failed!&quot;, sqlException);
 261          }
 262      }
 263  
 264      private void flush() throws Exception {
 265          if (batchCount &gt; 0) {
 266              if (updateMode.equalsIgnoreCase(UPDATE_MODE)) {
 267                  executeUpdateBatch();
 268              }
 269              if (!rowDataMap.isEmpty()) {
 270                  String templateSql =








<abbr title=" 271                          &quot;INSERT INTO tableName ${tableFieldsCondition} PARTITION ${partitionCondition} VALUES ${valuesCondition}&quot;;"> 271                          &quot;INSERT INTO tableName ${tableFieldsCondition} PARTITION ${partitionCondition} VALUES ${va🔵</abbr>
 272                  executeBatchSql(
 273                          statement,

 274                          templateSql,
 275                          schema,
 276                          tableName,
 277                          storeType,
 278                          enablePartition,
 279                          valueFieldNames,
 280                          partitionFields,
 281                          rowDataMap
 282                  );
 283                  rowDataMap.clear();
 284              }
 285          }
 286          batchCount = 0;
 287  









 288      }
 289  
 290      /**
 291       * execute batch update statement
 292       *
 293       * @throws SQLException throw sql exception
 294       */
 295      private void executeUpdateBatch() throws SQLException {
 296          try {
 297              rows.forEach(row -&gt; {
 298                  try {
 299                      JDBCTypeConvertUtils.setRecordToStatement(
 300                              updateStatement,
 301                              JDBCTypeConvertUtils.getSqlTypeFromFieldType(fieldTypes),
 302                              row,
 303                              primaryKeys.stream().mapToInt(fieldNames::indexOf).toArray()
 304                      );
 305                      updateStatement.addBatch();
 306                  } catch (Exception e) {
 307                      throw new RuntimeException(&quot;impala jdbc execute batch error!&quot;, e);
 308                  }
 309              });
 310              updateStatement.executeBatch();
 311              connection.commit();
 312              rows.clear();
 313          } catch (Exception e) {
 314              LOG.debug(&quot;impala jdbc execute batch error &quot;, e);
 315              connection.rollback();
 316              connection.commit();


 317              updateStatement.clearBatch();
 318              executeUpdate(connection);
 319          }
 320      }
 321  
 322      public void executeUpdate(Connection connection) {
 323          rows.forEach(row -&gt; {
 324              try {
<abbr title=" 325                  setRecordToStatement(updateStatement, JDBCTypeConvertUtils.getSqlTypeFromFieldType(fieldTypes), row);"> 325                  setRecordToStatement(updateStatement, JDBCTypeConvertUtils.getSqlTypeFromFieldType(fieldTypes), ro🔵</abbr>
 326                  updateStatement.executeUpdate();
 327                  connection.commit();

 328              } catch (Exception e) {
 329                  try {
 330                      connection.rollback();
 331                      connection.commit();
 332                  } catch (SQLException e1) {
 333                      throw new RuntimeException(e1);
 334                  }


<abbr title=" 335                  if (metricOutputFormat.outDirtyRecords.getCount() % DIRTY_DATA_PRINT_FREQUENCY == 0 || LOG.isDebugEnabled()) {"> 335                  if (metricOutputFormat.outDirtyRecords.getCount() % DIRTY_DATA_PRINT_FREQUENCY == 0 || LOG.isDebug🔵</abbr>
 336                      LOG.error(&quot;record insert failed ,this row is {}&quot;, row.toString());
 337                      LOG.error(&quot;&quot;, e);
 338                  }
 339                  metricOutputFormat.outDirtyRecords.inc();
 340              }
 341          });
 342          rows.clear();
 343      }
 344  
 345      private void putRowIntoMap(Map&lt;String, ArrayList&lt;String&gt;&gt; rowDataMap, Tuple2&lt;String, String&gt; rowData) {
 346          Set&lt;String&gt; keySet = rowDataMap.keySet();
 347          ArrayList&lt;String&gt; tempRowArray;
 348          if (keySet.contains(rowData.f0)) {
 349              tempRowArray = rowDataMap.get(rowData.f0);
 350          } else {
 351              tempRowArray = new ArrayList&lt;&gt;();
 352          }
 353          tempRowArray.add(rowData.f1);
 354          rowDataMap.put(rowData.f0, tempRowArray);
 355      }
 356  
<abbr title=" 357      private List&lt;String&gt; rebuildFieldNameListAndTypeList(List&lt;String&gt; fieldNames, List&lt;String&gt; staticPartitionFields, List&lt;String&gt; fieldTypes, String partitionFields) {"> 357      private List&lt;String&gt; rebuildFieldNameListAndTypeList(List&lt;String&gt; fieldNames, List&lt;String&gt; staticPartitionFiel🔵</abbr>
 358          if (partitionFields == null || partitionFields.isEmpty()) {
 359              return fieldNames;
 360          }
 361  
 362          List&lt;String&gt; valueFields = new ArrayList&lt;&gt;(fieldNames);
 363  
 364          for (int i = valueFields.size() - 1; i &gt;= 0; i--) {
 365              if (staticPartitionFields.contains(fieldNames.get(i))) {
 366                  valueFields.remove(i);
 367                  fieldTypes.remove(i);
 368              }
 369          }
 370  
 371          for (int i = 0; i &lt; valueFields.size(); i++) {
 372              if (partitionFields.contains(fieldNames.get(i))) {
 373                  valueFields.add(valueFields.remove(i));
 374                  fieldTypes.add(fieldTypes.remove(i));
 375              }
 376          }
 377  
 378          return valueFields;
 379      }
 380  
 381      /**
 382       * Quote a specific type of value, like string, timestamp
 383       * before: 1, cast(tiezhu as string), cast(2001-01-09 01:05:01 as timestamp), cast(123 as int)
 384       * after: 1, cast(&#x27;tiezhu&#x27; as string), cast(&#x27;2001-01-09 01:05:01&#x27; as timestamp), cast(123 as int)
 385       * if cast value is null, then cast(null as type)
 386       *
 387       * @param valueCondition original value condition
 388       * @return quoted condition
 389       */
 390      private String valueConditionAddQuotation(String valueCondition) {
 391          String[] temps = valueCondition.split(&quot;,&quot;);
 392          List&lt;String&gt; replacedItem = new ArrayList&lt;&gt;();
 393          Arrays.stream(temps).forEach(
 394                  item -&gt; {
 395                      Matcher matcher = TYPE_PATTERN.matcher(item);
 396                      while (matcher.find()) {
 397                          String value = matcher.group(1);
 398                          String type = matcher.group(2);
 399  
 400                          for (String needQuoteType : NEED_QUOTE_TYPE) {
 401                              if (type.contains(needQuoteType)) {
 402                                  if (!&quot;null&quot;.equals(value)) {
 403                                      item = item.replace(value, &quot;&#x27;&quot; + value + &quot;&#x27;&quot;);
 404                                  }
 405                              }
 406                          }
 407                      }
 408                      replacedItem.add(item);
 409                  }
 410          );
 411  
 412          return &quot;(&quot; + String.join(&quot;, &quot;, replacedItem) + &quot;)&quot;;
 413      }
 414  
 415      @Override
 416      public void writeRecord(Tuple2&lt;Boolean, Row&gt; record) throws IOException {
 417          try {
 418              if (!record.f0) {
 419                  return;
 420              }
 421  
 422              if (outRecords.getCount() % RECEIVE_DATA_PRINT_FREQUENCY == 0 || LOG.isDebugEnabled()) {
 423                  LOG.info(&quot;Receive data : {}&quot;, record);
 424              }
 425  
 426              if (updateMode.equalsIgnoreCase(UPDATE_MODE)) {
 427                  rows.add(Row.copy(record.f1));
 428              } else {
 429                  Map&lt;String, Object&gt; valueMap = Maps.newHashMap();
 430                  Row row = Row.copy(record.f1);
 431  
 432                  for (int i = 0; i &lt; row.getArity(); i++) {
 433                      valueMap.put(fieldNames.get(i), row.getField(i));
 434                  }
 435  
 436                  Tuple2&lt;String, String&gt; rowTuple2 = new Tuple2&lt;&gt;();
 437                  if (storeType.equalsIgnoreCase(KUDU_TYPE) || !enablePartition) {
 438                      rowTuple2.f0 = NO_PARTITION;
 439                  } else {
 440                      rowTuple2.f0 = buildPartitionCondition(valueMap, partitionFields, staticPartitionFields);
 441                  }
 442  
 443                  // 根据字段名对 row data 重组, 比如，原始 row data : (1, xxx, 20) -&gt; (id, name, age)
 444                  // 但是由于 partition，写入的field 顺序变成了 (name, id, age)，则需要对 row data 重组变成 (xxx, 1, 20)
 445                  Row rowValue = new Row(fieldTypes.size());
 446                  for (int i = 0; i &lt; fieldTypes.size(); i++) {
 447                      rowValue.setField(i, valueMap.get(valueFieldNames.get(i)));
 448                  }
 449                  rowTuple2.f1 = valueConditionAddQuotation(buildValuesCondition(fieldTypes, rowValue));

 450                  putRowIntoMap(rowDataMap, rowTuple2);
 451              }
 452  
 453              batchCount++;
 454  
 455              if (batchCount &gt;= batchSize) {
 456                  flush();
 457              }
 458  
 459              // Receive data
 460              outRecords.inc();
 461          } catch (Exception e) {
 462              throw new IOException(&quot;Writing records to impala failed.&quot;, e);
 463          }
 464      }
 465  
 466      @Override
 467      public void close() throws IOException {
 468          if (closed) {
 469              return;
 470          }
 471          // 将还未执行的SQL flush
 472          if (batchCount &gt; 0) {
 473              try {
 474                  flush();
 475              } catch (Exception e) {
 476                  throw new RuntimeException(&quot;Writing records to impala failed.&quot;, e);
 477              }

 478          }
 479          // cancel scheduled task
 480          if (this.scheduledFuture != null) {
 481              scheduledFuture.cancel(false);
 482              this.scheduler.shutdown();
 483          }
 484          // close connection
 485          try {
 486              if (connection != null &amp;&amp; connection.isValid(DEFAULT_CONN_TIME_OUT)) {
 487                  connection.close();
 488              }
 489  
 490              if (statement != null &amp;&amp; !statement.isClosed()) {
 491                  statement.close();
 492              }
 493  
 494              if (updateStatement != null &amp;&amp; !updateStatement.isClosed()) {
 495                  updateStatement.close();
 496              }
 497          } catch (SQLException e) {
 498              throw new RuntimeException(&quot;impala connection close failed!&quot;, e);
 499          } finally {
 500              connection = null;
 501              statement = null;
 502              updateStatement = null;
 503          }
 504          closed = true;
 505      }
 506  
 507      /**
 508       * execute batch sql from row data map
 509       * sql like &#x27;insert into tableName(f1, f2, f3) ${partitionCondition} values(v1, v2, v3), (v4, v5, v6)....
 510       *
 511       * @param statement       execute statement
 512       * @param tempSql         template sql
 513       * @param storeType       the store type of data
 514       * @param enablePartition enable partition or not
 515       * @param fieldNames      field name list
 516       * @param partitionFields partition fields
 517       * @param rowDataMap      row data map
 518       */
 519      private void executeBatchSql(Statement statement,
 520                                   String tempSql,

 521                                   String schema,
 522                                   String tableName,
 523                                   String storeType,
 524                                   Boolean enablePartition,
 525                                   List&lt;String&gt; fieldNames,
 526                                   String partitionFields,
 527                                   Map&lt;String, ArrayList&lt;String&gt;&gt; rowDataMap) {
 528          StringBuilder valuesCondition = new StringBuilder();
 529          StringBuilder partitionCondition = new StringBuilder();
 530          String tableFieldsCondition = buildTableFieldsCondition(fieldNames, partitionFields);
 531          ArrayList&lt;String&gt; rowData;

 532          String tableNameInfo = Objects.isNull(schema) ?
 533                  tableName : quoteIdentifier(schema) + &quot;.&quot; + tableName;
 534          tempSql = tempSql.replace(&quot;tableName&quot;, tableNameInfo);
 535  
 536          // kudu ${partitionCondition} is null
 537          if (storeType.equalsIgnoreCase(KUDU_TYPE) || !enablePartition) {
























































 538              try {
 539                  rowData = rowDataMap.get(NO_PARTITION);
 540                  rowData.forEach(row -&gt; valuesCondition.append(row).append(&quot;, &quot;));
 541                  String executeSql = tempSql.replace(VALUES_CONDITION, valuesCondition.toString())
 542                          .replace(PARTITION_CONDITION, partitionCondition.toString())
 543                          .replace(PARTITION_CONSTANT, &quot;&quot;)
 544                          .replace(TABLE_FIELDS_CONDITION, tableFieldsCondition);
 545                  String substring = executeSql.substring(0, executeSql.length() - 2);
 546                  statement.execute(substring);
 547              } catch (Exception e) {
 548                  throw new RuntimeException(&quot;execute impala SQL error!&quot;, e);
 549              }
 550              return;
 551          }
 552  
 553          // partition sql
 554          Set&lt;String&gt; keySet = rowDataMap.keySet();
 555          String finalTempSql = tempSql;
 556          for (String key : keySet) {
 557              try {
 558                  String executeSql = String.copyValueOf(finalTempSql.toCharArray());
 559                  ArrayList&lt;String&gt; valuesConditionList = rowDataMap.get(key);
 560                  partitionCondition.append(key);
 561                  executeSql = executeSql.replace(PARTITION_CONDITION, partitionCondition.toString())
 562                          .replace(TABLE_FIELDS_CONDITION, tableFieldsCondition)
 563                          .replace(VALUES_CONDITION, String.join(&quot;, &quot;, valuesConditionList));
 564                  statement.execute(executeSql);
 565                  partitionCondition.delete(0, partitionCondition.length());
 566              } catch (SQLException sqlException) {
 567                  throw new RuntimeException(&quot;execute impala SQL error! &quot;, sqlException);













 568              }
 569          }
 570      }
 571  
 572      /**
 573       * build partition condition with row data
 574       *
 575       * @param rowData              row data
 576       * @param partitionFields      partition fields
 577       * @param staticPartitionField static partition fields
 578       * @return condition like &#x27;(ptOne, ptTwo=v2)&#x27;
 579       */
<abbr title=" 580      private String buildPartitionCondition(Map&lt;String, Object&gt; rowData, String partitionFields, List&lt;String&gt; staticPartitionField) {"> 580      private String buildPartitionCondition(Map&lt;String, Object&gt; rowData, String partitionFields, List&lt;String&gt; stati🔵</abbr>
 581          for (String key : staticPartitionField) {
 582              StringBuilder sb = new StringBuilder();
 583              Object value = rowData.get(key);
 584              sb.append(key).append(&quot;=&quot;).append(value);
 585              partitionFields = partitionFields.replace(&quot;${&quot; + key + &quot;}&quot;, sb.toString());
 586          }
 587          return &quot;(&quot; + partitionFields + &quot;)&quot;;
 588      }
 589  
 590      /**
 591       * build field condition according to field names
 592       * replace ${tableFieldCondition}
 593       *
 594       * @param fieldNames      the selected field names
 595       * @param partitionFields the partition fields
 596       * @return condition like &#x27;(id, name, age)&#x27;
 597       */
 598      private String buildTableFieldsCondition(List&lt;String&gt; fieldNames, String partitionFields) {
 599          return &quot;(&quot; + fieldNames.stream()
 600                  .filter(f -&gt; !partitionFields.contains(f))
 601                  .map(this::quoteIdentifier)
 602                  .collect(Collectors.joining(&quot;, &quot;)) + &quot;)&quot;;
 603      }
 604  
 605      /**
 606       * according to field types, build the values condition
 607       * replace ${valuesCondition}
 608       *
 609       * @param fieldTypes field types
 610       * @return condition like &#x27;(?, ?, cast(? as string))&#x27; and &#x27;?&#x27; will be replaced with row data

 611       */
 612      private String buildValuesCondition(List&lt;String&gt; fieldTypes, Row row) {
 613          String valuesCondition = fieldTypes.stream().map(
 614                  f -&gt; {
 615                      for (String item : NEED_QUOTE_TYPE) {
 616                          if (f.toLowerCase().contains(item)) {
 617                              return String.format(&quot;cast(? as %s)&quot;, f.toLowerCase());

 618                          }
 619                      }
 620                      return &quot;?&quot;;
 621                  }).collect(Collectors.joining(&quot;, &quot;));
 622          for (int i = 0; i &lt; row.getArity(); i++) {
<abbr title=" 623              valuesCondition = valuesCondition.replaceFirst(&quot;\\?&quot;, Objects.isNull(row.getField(i)) ? &quot;null&quot; : row.getField(i).toString());"> 623              valuesCondition = valuesCondition.replaceFirst(&quot;\\?&quot;, Objects.isNull(row.getField(i)) ? &quot;null&quot; : row.g🔵</abbr>
 624          }
 625          return valuesCondition;








 626      }
 627  
 628      /**
 629       * impala update mode SQL
 630       *
 631       * @return UPDATE tableName SET setCondition WHERE whereCondition
 632       */
<abbr title=" 633      private String buildUpdateSql(String schema, String tableName, List&lt;String&gt; fieldNames, List&lt;String&gt; primaryKeys) {"> 633      private String buildUpdateSql(String schema, String tableName, List&lt;String&gt; fieldNames, List&lt;String&gt; primaryKe🔵</abbr>
 634          //跳过primary key字段
 635          String setClause = fieldNames.stream()
 636                  .filter(f -&gt; !CollectionUtils.isNotEmpty(primaryKeys) || !primaryKeys.contains(f))
 637                  .map(f -&gt; quoteIdentifier(f) + &quot;=?&quot;)
 638                  .collect(Collectors.joining(&quot;, &quot;));
 639  
 640          String conditionClause = primaryKeys.stream()
 641                  .map(f -&gt; quoteIdentifier(f) + &quot;=?&quot;)
 642                  .collect(Collectors.joining(&quot; AND &quot;));
 643  
 644          return &quot;UPDATE &quot; + (Objects.isNull(schema) ? &quot;&quot; : quoteIdentifier(schema) + &quot;.&quot;)
 645                  + quoteIdentifier(tableName) + &quot; SET &quot; + setClause + &quot; WHERE &quot; + conditionClause;
 646      }
 647  
 648      private String quoteIdentifier(String identifier) {
 649          return &quot;`&quot; + identifier + &quot;`&quot;;
 650      }
 651  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 652 -    public static Builder getImpalaBuilder() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 653 -        return new Builder();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 654 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 655 -</span>
 656      public static class Builder {
 657          private final ImpalaOutputFormat format = new ImpalaOutputFormat();
 658  
 659          public Builder setDbUrl(String dbUrl) {
 660              format.dbUrl = dbUrl;
 661              return this;
 662          }
 663  
 664          public Builder setUserName(String userName) {
 665              format.userName = userName;
 666              return this;
 667          }
 668  
 669          public Builder setPassword(String password) {
 670              format.password = password;
 671              return this;
 672          }
 673  
 674          public Builder setBatchSize(Integer batchSize) {
 675              format.batchSize = batchSize;
 676              return this;
 677          }
 678  
 679          public Builder setBatchWaitInterval(Long batchWaitInterval) {
 680              format.batchWaitInterval = batchWaitInterval;
 681              return this;
 682          }
 683  
 684          public Builder setTableName(String tableName) {
 685              format.tableName = tableName;
 686              return this;
 687          }
 688  
 689          public Builder setPartitionFields(String partitionFields) {
 690              format.partitionFields = Objects.isNull(partitionFields) ?
 691                      &quot;&quot; : partitionFields;
 692              return this;
 693          }
 694  
 695          public Builder setPrimaryKeys(List&lt;String&gt; primaryKeys) {
 696              format.primaryKeys = primaryKeys;
 697              return this;
 698          }
 699  
 700          public Builder setSchema(String schema) {
 701              format.schema = schema;
 702              return this;
 703          }
 704  
 705          public Builder setEnablePartition(Boolean enablePartition) {
 706              format.enablePartition = enablePartition;
 707              return this;
 708          }
 709  
 710          public Builder setUpdateMode(String updateMode) {
 711              format.updateMode = updateMode;
 712              return this;
 713          }
 714  
 715          public Builder setFieldList(List&lt;String&gt; fieldList) {
 716              format.fieldNames = fieldList;
 717              return this;
 718          }
 719  
 720          public Builder setFieldTypeList(List&lt;String&gt; fieldTypeList) {
 721              format.fieldTypes = fieldTypeList;
 722              return this;
 723          }
 724  
 725          public Builder setStoreType(String storeType) {
 726              format.storeType = storeType;
 727              return this;
 728          }
 729  
 730          public Builder setFieldExtraInfoList(List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfoList) {
 731              format.fieldExtraInfoList = fieldExtraInfoList;
 732              return this;
 733          }
 734  
 735          public Builder setKeyTabPath(String keyTabPath) {
 736              format.keytabPath = keyTabPath;
 737              return this;
 738          }
 739  
 740          public Builder setKrb5ConfPath(String krb5ConfPath) {
 741              format.krb5confPath = krb5ConfPath;
 742              return this;
 743          }
 744  
 745          public Builder setPrincipal(String principal) {
 746              format.principal = principal;
 747              return this;
 748          }
 749  
 750          public Builder setAuthMech(Integer authMech) {
 751              format.authMech = authMech;
 752              return this;
 753          }
 754  
 755          private boolean canHandle(String url) {
 756              return url.startsWith(&quot;jdbc:impala:&quot;);
 757          }
 758  
 759          public ImpalaOutputFormat build() {
 760              if (!canHandle(format.dbUrl)) {
 761                  throw new IllegalArgumentException(&quot;impala dbUrl is illegal, check url: &quot; + format.dbUrl);
 762              }
 763  
 764              if (format.authMech == EAuthMech.Kerberos.getType()) {
 765                  checkNotNull(format.krb5confPath,
 766                          &quot;When kerberos authentication is enabled, krb5confPath is required！&quot;);
 767                  checkNotNull(format.principal,
 768                          &quot;When kerberos authentication is enabled, principal is required！&quot;);
 769                  checkNotNull(format.keytabPath,
 770                          &quot;When kerberos authentication is enabled, keytabPath is required！&quot;);
 771              }
 772  
 773              if (format.authMech == EAuthMech.UserName.getType()) {
 774                  checkNotNull(format.userName, &quot;userName is required!&quot;);
 775              }
 776  
 777              if (format.authMech == EAuthMech.NameANDPassword.getType()) {
 778                  checkNotNull(format.userName, &quot;userName is required!&quot;);
 779                  checkNotNull(format.password, &quot;password is required!&quot;);
 780              }
 781  
 782              checkNotNull(format.storeType, &quot;storeType is required!&quot;);
 783  
 784              return format;
 785          }
 786      }
 787  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.sink.impala;
  20  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  21 +import com.dtstack.flink.sql.exception.ExceptionTrace;</span>
  22  import com.dtstack.flink.sql.factory.DTThreadFactory;
  23  import com.dtstack.flink.sql.outputformat.AbstractDtRichOutputFormat;
  24  import com.dtstack.flink.sql.sink.rdb.JDBCTypeConvertUtils;
  25  import com.dtstack.flink.sql.table.AbstractTableInfo;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  26 +import com.dtstack.flink.sql.util.DtStringUtil;</span>
  27  import com.dtstack.flink.sql.util.JDBCUtils;
  28  import com.dtstack.flink.sql.util.KrbUtils;
  29  import com.google.common.collect.Maps;
  30  import org.apache.commons.collections.CollectionUtils;
  31  import org.apache.flink.api.java.tuple.Tuple2;
  32  import org.apache.flink.configuration.Configuration;
  33  import org.apache.flink.types.Row;
  34  import org.apache.hadoop.security.UserGroupInformation;
  35  import org.slf4j.Logger;
  36  import org.slf4j.LoggerFactory;
  37  
  38  import java.io.IOException;
  39  import java.security.PrivilegedExceptionAction;
  40  import java.sql.Connection;
  41  import java.sql.DriverManager;
  42  import java.sql.PreparedStatement;
  43  import java.sql.SQLException;
  44  import java.sql.Statement;
  45  import java.util.ArrayList;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  46 -import java.util.Arrays;</span>
  47  import java.util.HashMap;
  48  import java.util.List;
  49  import java.util.Map;
  50  import java.util.Objects;
  51  import java.util.Set;
  52  import java.util.concurrent.ScheduledExecutorService;
  53  import java.util.concurrent.ScheduledFuture;
  54  import java.util.concurrent.ScheduledThreadPoolExecutor;
  55  import java.util.concurrent.TimeUnit;
  56  import java.util.regex.Matcher;
  57  import java.util.regex.Pattern;
  58  import java.util.stream.Collectors;
  59  
  60  import static com.dtstack.flink.sql.sink.rdb.JDBCTypeConvertUtils.setRecordToStatement;
  61  import static org.apache.flink.util.Preconditions.checkNotNull;
  62  
  63  /**
  64   * Date: 2020/10/14
  65   * Company: www.dtstack.com
  66   *
  67   * @author tiezhu
  68   */
  69  public class ImpalaOutputFormat extends AbstractDtRichOutputFormat&lt;Tuple2&lt;Boolean, Row&gt;&gt; {
  70  
  71      private static final Logger LOG = LoggerFactory.getLogger(ImpalaOutputFormat.class);
  72  
  73      private static final long serialVersionUID = 1L;
  74  
  75      // ${field}
  76      private static final Pattern STATIC_PARTITION_PATTERN = Pattern.compile(&quot;\\$\\{([^}]*)}&quot;);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  77 -    // cast(value as string) -&gt; cast(&#x27;value&#x27; as string)  cast(value as timestamp) -&gt; cast(&#x27;value&#x27; as timestamp)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  78 -    private static final Pattern TYPE_PATTERN = Pattern.compile(&quot;cast\\((.*) as (.*)\\)&quot;);</span>
  79      //specific type which values need to be quoted
  80      private static final String[] NEED_QUOTE_TYPE = {&quot;string&quot;, &quot;timestamp&quot;, &quot;varchar&quot;};
  81  
  82      private static final Integer DEFAULT_CONN_TIME_OUT = 60;
  83      private static final int RECEIVE_DATA_PRINT_FREQUENCY = 1000;
  84      private static final int DIRTY_DATA_PRINT_FREQUENCY = 1000;
  85  
  86      private static final String KUDU_TYPE = &quot;kudu&quot;;
  87      private static final String UPDATE_MODE = &quot;update&quot;;
  88      private static final String PARTITION_CONSTANT = &quot;PARTITION&quot;;
  89      private static final String DRIVER_NAME = &quot;com.cloudera.impala.jdbc41.Driver&quot;;
  90  
  91      private static final String VALUES_CONDITION = &quot;${valuesCondition}&quot;;
  92      private static final String PARTITION_CONDITION = &quot;${partitionCondition}&quot;;
  93      private static final String TABLE_FIELDS_CONDITION = &quot;${tableFieldsCondition}&quot;;
  94      private static final String NO_PARTITION = &quot;noPartition&quot;;
  95  





  96      protected transient Connection connection;
  97      protected transient Statement statement;
  98      protected transient PreparedStatement updateStatement;
  99  
 100      private transient volatile boolean closed = false;
 101      private int batchCount = 0;
 102  
 103      // |------------------------------------------------|
 104      // |   partitionCondition   |Array of valueCondition|
 105      // |------------------------------------------------|
 106      // | ptOne, ptTwo, ptThree  | [(v1, v2, v3, v4, v5)]|   DP
 107      // |------------------------------------------------|
 108      // | ptOne = v1, ptTwo = v2 | [(v3, v4, v5)]        |   SP
 109      // |------------------------------------------------|
 110      // | ptOne, ptTwo = v2      | [(v1, v3, v4, v5)]    |   DP and SP
 111      // |------------------------------------------------|
 112      // | noPartition            | [(v1, v2, v3, v4, v5)]|   kudu or disablePartition
 113      // |------------------------------------------------|
 114      private transient Map&lt;String, ArrayList&lt;String&gt;&gt; rowDataMap;
 115  
 116      protected String keytabPath;
 117      protected String krb5confPath;
 118      protected String principal;
 119      protected Integer authMech;
 120      protected String dbUrl;
 121      protected String userName;
 122      protected String password;
 123      protected int batchSize = 100;
 124      protected long batchWaitInterval = 60 * 1000L;
 125      protected String tableName;
 126      protected List&lt;String&gt; primaryKeys;
 127      protected String partitionFields;
 128      protected Boolean enablePartition;
 129      protected String schema;
 130      protected String storeType;
 131      protected String updateMode;
 132      public List&lt;String&gt; fieldNames;
 133      public List&lt;String&gt; fieldTypes;
 134      public List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfoList;
 135  
 136      // partition field of static partition which matched by ${field}
 137      private final List&lt;String&gt; staticPartitionFields = new ArrayList&lt;&gt;();
 138  














 139      // valueFieldsName -&gt; 重组之后的fieldNames，为了重组row data字段值对应
 140      // 需要对partition字段做特殊处理，比如原来的字段顺序为(age, name, id)，但是因为partition，写入的SQL为
 141      // INSERT INTO tableName(name, id) PARTITION(age) VALUES(?, ?, ?)
 142      // 那么实际executeSql设置字段的顺序应该为(name, id, age)，同时，字段对应的type顺序也需要重组
 143      private List&lt;String&gt; valueFieldNames;
 144      private transient AbstractDtRichOutputFormat&lt;?&gt; metricOutputFormat;
 145      private List&lt;Row&gt; rows;
 146  
 147      private transient ScheduledExecutorService scheduler;
 148      private transient ScheduledFuture&lt;?&gt; scheduledFuture;




 149  
 150      @Override
 151      public void configure(Configuration parameters) {
 152      }
 153  
 154      @Override
 155      public void open(int taskNumber, int numTasks) throws IOException {
 156          try {
 157              rowDataMap = new HashMap&lt;&gt;();
 158              rows = new ArrayList&lt;&gt;();
 159              metricOutputFormat = this;
 160              openConnect();
 161              initScheduledTask(batchWaitInterval);
 162              init();
 163              initMetric();
 164          } catch (Exception e) {
 165              throw new RuntimeException(&quot;impala output format open error!&quot;, e);
 166          }
 167      }
 168  
 169      private void init() throws SQLException {
 170          if (Objects.nonNull(partitionFields)) {
 171              // match ${field} from partitionFields
 172              Matcher matcher = STATIC_PARTITION_PATTERN.matcher(partitionFields);
 173              while (matcher.find()) {
 174                  LOG.info(&quot;find static partition field: {}&quot;, matcher.group(1));
 175                  staticPartitionFields.add(matcher.group(1));
 176              }
 177          }
 178  
 179          if (updateMode.equalsIgnoreCase(UPDATE_MODE)) {
 180              if (!storeType.equalsIgnoreCase(KUDU_TYPE)) {
 181                  throw new IllegalArgumentException(&quot;update mode not support for non-kudu table!&quot;);
 182              }
<abbr title=" 183              updateStatement = connection.prepareStatement(buildUpdateSql(schema, tableName, fieldNames, primaryKeys));"> 183              updateStatement = connection.prepareStatement(buildUpdateSql(schema, tableName, fieldNames, primaryKey🔵</abbr>
 184          } else {
<abbr title=" 185              valueFieldNames = rebuildFieldNameListAndTypeList(fieldNames, staticPartitionFields, fieldTypes, partitionFields);"> 185              valueFieldNames = rebuildFieldNameListAndTypeList(fieldNames, staticPartitionFields, fieldTypes, parti🔵</abbr>
 186          }
 187  
 188      }
 189  
 190      private void initScheduledTask(Long batchWaitInterval) {
 191          try {
 192              if (batchWaitInterval != 0) {
 193                  this.scheduler = new ScheduledThreadPoolExecutor(1,
 194                          new DTThreadFactory(&quot;impala-upsert-output-format&quot;));
 195                  this.scheduledFuture = this.scheduler.scheduleWithFixedDelay(() -&gt; {
 196                      synchronized (ImpalaOutputFormat.this) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 197 -                        try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 198 -                            flush();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 199 -                        } catch (Exception e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 200 -                            LOG.error(&quot;Writing records to impala jdbc failed.&quot;, e);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 201 -                            throw new RuntimeException(&quot;Writing records to impala jdbc failed.&quot;, e);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 202 -                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 203 +                        flush();</span>
 204                      }
 205                  }, batchWaitInterval, batchWaitInterval, TimeUnit.MILLISECONDS);
 206              }
 207          } catch (Exception e) {
 208              throw new RuntimeException(e);
 209          }
 210      }
 211  
 212      private void openConnect() throws IOException {
 213          if (authMech == 1) {
 214              UserGroupInformation ugi = KrbUtils.loginAndReturnUgi(principal, keytabPath, krb5confPath);
 215              try {
 216                  ugi.doAs((PrivilegedExceptionAction&lt;Void&gt;) () -&gt; {
 217                      openJdbc();
 218                      return null;
 219                  });
 220              } catch (InterruptedException | IOException e) {
 221                  throw new IllegalArgumentException(&quot;connect impala error!&quot;, e);
 222              }
 223          } else {
 224              openJdbc();
 225          }
 226      }
 227  
 228      /**
 229       * get jdbc connection
 230       */
 231      private void openJdbc() {
 232          JDBCUtils.forName(DRIVER_NAME, getClass().getClassLoader());

 233          try {
 234              connection = DriverManager.getConnection(dbUrl, userName, password);
 235              statement = connection.createStatement();
 236              connection.setAutoCommit(false);
 237          } catch (SQLException sqlException) {
 238              throw new RuntimeException(&quot;get impala jdbc connection failed!&quot;, sqlException);
 239          }
 240      }
 241  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 242 -    private void flush() throws Exception {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 243 -        if (batchCount &gt; 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 244 -            if (updateMode.equalsIgnoreCase(UPDATE_MODE)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 245 -                executeUpdateBatch();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 246 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 247 -            if (!rowDataMap.isEmpty()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 248 -                String templateSql =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 249 +    private synchronized void flush() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 250 +        try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 251 +            if (batchCount &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 252 +                if (updateMode.equalsIgnoreCase(UPDATE_MODE)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 253 +                    executeUpdateBatch();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 254 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 255 +                if (!rowDataMap.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 256 +                    String templateSql =</span>
<abbr title=" 257                          &quot;INSERT INTO tableName ${tableFieldsCondition} PARTITION ${partitionCondition} VALUES ${valuesCondition}&quot;;"> 257                          &quot;INSERT INTO tableName ${tableFieldsCondition} PARTITION ${partitionCondition} VALUES ${va🔵</abbr>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 258 -                executeBatchSql(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 259 -                        statement,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 260 +                    executeBatchSql(</span>
 261                          templateSql,
 262                          schema,
 263                          tableName,
 264                          storeType,
 265                          enablePartition,
 266                          valueFieldNames,
 267                          partitionFields,
 268                          rowDataMap
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 269 -                );</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 270 -                rowDataMap.clear();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 271 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 272 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 273 -        batchCount = 0;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 274 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 275 +                    );</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 276 +                    rowDataMap.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 277 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 278 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 279 +            batchCount = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 280 +        } catch (Exception e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 281 +            LOG.error(&quot;Writing records to impala jdbc failed.&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 282 +            throw new RuntimeException(&quot;Writing records to impala jdbc failed.&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 283 +        }</span>
 284      }
 285  
 286      /**
 287       * execute batch update statement
 288       *
 289       * @throws SQLException throw sql exception
 290       */
 291      private void executeUpdateBatch() throws SQLException {
 292          try {
 293              rows.forEach(row -&gt; {
 294                  try {
 295                      JDBCTypeConvertUtils.setRecordToStatement(
 296                              updateStatement,
 297                              JDBCTypeConvertUtils.getSqlTypeFromFieldType(fieldTypes),
 298                              row,
 299                              primaryKeys.stream().mapToInt(fieldNames::indexOf).toArray()
 300                      );
 301                      updateStatement.addBatch();
 302                  } catch (Exception e) {
 303                      throw new RuntimeException(&quot;impala jdbc execute batch error!&quot;, e);
 304                  }
 305              });
 306              updateStatement.executeBatch();
 307              connection.commit();
 308              rows.clear();
 309          } catch (Exception e) {
 310              LOG.debug(&quot;impala jdbc execute batch error &quot;, e);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 311 -            connection.rollback();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 312 -            connection.commit();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 313 +            JDBCUtils.rollBack(connection);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 314 +            JDBCUtils.commit(connection);</span>
 315              updateStatement.clearBatch();
 316              executeUpdate(connection);
 317          }
 318      }
 319  
 320      public void executeUpdate(Connection connection) {
 321          rows.forEach(row -&gt; {
 322              try {
<abbr title=" 323                  setRecordToStatement(updateStatement, JDBCTypeConvertUtils.getSqlTypeFromFieldType(fieldTypes), row);"> 323                  setRecordToStatement(updateStatement, JDBCTypeConvertUtils.getSqlTypeFromFieldType(fieldTypes), ro🔵</abbr>
 324                  updateStatement.executeUpdate();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 325 -                connection.commit();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 326 +                JDBCUtils.commit(connection);</span>
 327              } catch (Exception e) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 328 -                try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 329 -                    connection.rollback();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 330 -                    connection.commit();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 331 -                } catch (SQLException e1) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 332 -                    throw new RuntimeException(e1);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 333 -                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 334 +                JDBCUtils.rollBack(connection);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 335 +                JDBCUtils.commit(connection);</span>
<abbr title=" 336                  if (metricOutputFormat.outDirtyRecords.getCount() % DIRTY_DATA_PRINT_FREQUENCY == 0 || LOG.isDebugEnabled()) {"> 336                  if (metricOutputFormat.outDirtyRecords.getCount() % DIRTY_DATA_PRINT_FREQUENCY == 0 || LOG.isDebug🔵</abbr>
 337                      LOG.error(&quot;record insert failed ,this row is {}&quot;, row.toString());
 338                      LOG.error(&quot;&quot;, e);
 339                  }
 340                  metricOutputFormat.outDirtyRecords.inc();
 341              }
 342          });
 343          rows.clear();
 344      }
 345  
 346      private void putRowIntoMap(Map&lt;String, ArrayList&lt;String&gt;&gt; rowDataMap, Tuple2&lt;String, String&gt; rowData) {
 347          Set&lt;String&gt; keySet = rowDataMap.keySet();
 348          ArrayList&lt;String&gt; tempRowArray;
 349          if (keySet.contains(rowData.f0)) {
 350              tempRowArray = rowDataMap.get(rowData.f0);
 351          } else {
 352              tempRowArray = new ArrayList&lt;&gt;();
 353          }
 354          tempRowArray.add(rowData.f1);
 355          rowDataMap.put(rowData.f0, tempRowArray);
 356      }
 357  
<abbr title=" 358      private List&lt;String&gt; rebuildFieldNameListAndTypeList(List&lt;String&gt; fieldNames, List&lt;String&gt; staticPartitionFields, List&lt;String&gt; fieldTypes, String partitionFields) {"> 358      private List&lt;String&gt; rebuildFieldNameListAndTypeList(List&lt;String&gt; fieldNames, List&lt;String&gt; staticPartitionFiel🔵</abbr>
 359          if (partitionFields == null || partitionFields.isEmpty()) {
 360              return fieldNames;
 361          }
 362  
 363          List&lt;String&gt; valueFields = new ArrayList&lt;&gt;(fieldNames);
 364  
 365          for (int i = valueFields.size() - 1; i &gt;= 0; i--) {
 366              if (staticPartitionFields.contains(fieldNames.get(i))) {
 367                  valueFields.remove(i);
 368                  fieldTypes.remove(i);
 369              }
 370          }
 371  
 372          for (int i = 0; i &lt; valueFields.size(); i++) {
 373              if (partitionFields.contains(fieldNames.get(i))) {
 374                  valueFields.add(valueFields.remove(i));
 375                  fieldTypes.add(fieldTypes.remove(i));
 376              }
 377          }
 378  
 379          return valueFields;
 380      }
 381  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 382 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 383 -     * Quote a specific type of value, like string, timestamp</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 384 -     * before: 1, cast(tiezhu as string), cast(2001-01-09 01:05:01 as timestamp), cast(123 as int)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 385 -     * after: 1, cast(&#x27;tiezhu&#x27; as string), cast(&#x27;2001-01-09 01:05:01&#x27; as timestamp), cast(123 as int)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 386 -     * if cast value is null, then cast(null as type)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 387 -     *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 388 -     * @param valueCondition original value condition</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 389 -     * @return quoted condition</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 390 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 391 -    private String valueConditionAddQuotation(String valueCondition) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 392 -        String[] temps = valueCondition.split(&quot;,&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 393 -        List&lt;String&gt; replacedItem = new ArrayList&lt;&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 394 -        Arrays.stream(temps).forEach(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 395 -                item -&gt; {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 396 -                    Matcher matcher = TYPE_PATTERN.matcher(item);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 397 -                    while (matcher.find()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 398 -                        String value = matcher.group(1);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 399 -                        String type = matcher.group(2);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 400 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 401 -                        for (String needQuoteType : NEED_QUOTE_TYPE) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 402 -                            if (type.contains(needQuoteType)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 403 -                                if (!&quot;null&quot;.equals(value)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 404 -                                    item = item.replace(value, &quot;&#x27;&quot; + value + &quot;&#x27;&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 405 -                                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 406 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 407 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 408 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 409 -                    replacedItem.add(item);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 410 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 411 -        );</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 412 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 413 -        return &quot;(&quot; + String.join(&quot;, &quot;, replacedItem) + &quot;)&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 414 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 415 -</span>
 416      @Override
 417      public void writeRecord(Tuple2&lt;Boolean, Row&gt; record) throws IOException {
 418          try {
 419              if (!record.f0) {
 420                  return;
 421              }
 422  
 423              if (outRecords.getCount() % RECEIVE_DATA_PRINT_FREQUENCY == 0 || LOG.isDebugEnabled()) {
 424                  LOG.info(&quot;Receive data : {}&quot;, record);
 425              }
 426  
 427              if (updateMode.equalsIgnoreCase(UPDATE_MODE)) {
 428                  rows.add(Row.copy(record.f1));
 429              } else {
 430                  Map&lt;String, Object&gt; valueMap = Maps.newHashMap();
 431                  Row row = Row.copy(record.f1);
 432  
 433                  for (int i = 0; i &lt; row.getArity(); i++) {
 434                      valueMap.put(fieldNames.get(i), row.getField(i));
 435                  }
 436  
 437                  Tuple2&lt;String, String&gt; rowTuple2 = new Tuple2&lt;&gt;();
 438                  if (storeType.equalsIgnoreCase(KUDU_TYPE) || !enablePartition) {
 439                      rowTuple2.f0 = NO_PARTITION;
 440                  } else {
 441                      rowTuple2.f0 = buildPartitionCondition(valueMap, partitionFields, staticPartitionFields);
 442                  }
 443  
 444                  // 根据字段名对 row data 重组, 比如，原始 row data : (1, xxx, 20) -&gt; (id, name, age)
 445                  // 但是由于 partition，写入的field 顺序变成了 (name, id, age)，则需要对 row data 重组变成 (xxx, 1, 20)
 446                  Row rowValue = new Row(fieldTypes.size());
 447                  for (int i = 0; i &lt; fieldTypes.size(); i++) {
 448                      rowValue.setField(i, valueMap.get(valueFieldNames.get(i)));
 449                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 450 -                rowTuple2.f1 = valueConditionAddQuotation(buildValuesCondition(fieldTypes, rowValue));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 451 +                rowTuple2.f1 = buildValuesCondition(fieldTypes, rowValue);</span>
 452                  putRowIntoMap(rowDataMap, rowTuple2);
 453              }
 454  
 455              batchCount++;
 456  
 457              if (batchCount &gt;= batchSize) {
 458                  flush();
 459              }
 460  
 461              // Receive data
 462              outRecords.inc();
 463          } catch (Exception e) {
 464              throw new IOException(&quot;Writing records to impala failed.&quot;, e);
 465          }
 466      }
 467  
 468      @Override
 469      public void close() throws IOException {
 470          if (closed) {
 471              return;
 472          }
 473          // 将还未执行的SQL flush
 474          if (batchCount &gt; 0) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 475 -            try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 476 -                flush();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 477 -            } catch (Exception e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 478 -                throw new RuntimeException(&quot;Writing records to impala failed.&quot;, e);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 479 -            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 480 +            flush();</span>
 481          }
 482          // cancel scheduled task
 483          if (this.scheduledFuture != null) {
 484              scheduledFuture.cancel(false);
 485              this.scheduler.shutdown();
 486          }
 487          // close connection
 488          try {
 489              if (connection != null &amp;&amp; connection.isValid(DEFAULT_CONN_TIME_OUT)) {
 490                  connection.close();
 491              }
 492  
 493              if (statement != null &amp;&amp; !statement.isClosed()) {
 494                  statement.close();
 495              }
 496  
 497              if (updateStatement != null &amp;&amp; !updateStatement.isClosed()) {
 498                  updateStatement.close();
 499              }
 500          } catch (SQLException e) {
 501              throw new RuntimeException(&quot;impala connection close failed!&quot;, e);
 502          } finally {
 503              connection = null;
 504              statement = null;
 505              updateStatement = null;
 506          }
 507          closed = true;
 508      }
 509  
 510      /**
 511       * execute batch sql from row data map
 512       * sql like &#x27;insert into tableName(f1, f2, f3) ${partitionCondition} values(v1, v2, v3), (v4, v5, v6)....
 513       *
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 514 -     * @param statement       execute statement</span>
 515       * @param tempSql         template sql
 516       * @param storeType       the store type of data
 517       * @param enablePartition enable partition or not
 518       * @param fieldNames      field name list
 519       * @param partitionFields partition fields
 520       * @param rowDataMap      row data map
 521       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 522 -    private void executeBatchSql(Statement statement,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 523 -                                 String tempSql,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 524 +    private void executeBatchSql(String tempSql,</span>
 525                                   String schema,
 526                                   String tableName,
 527                                   String storeType,
 528                                   Boolean enablePartition,
 529                                   List&lt;String&gt; fieldNames,
 530                                   String partitionFields,
 531                                   Map&lt;String, ArrayList&lt;String&gt;&gt; rowDataMap) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 532 -        StringBuilder valuesCondition = new StringBuilder();</span>
 533          StringBuilder partitionCondition = new StringBuilder();
 534          String tableFieldsCondition = buildTableFieldsCondition(fieldNames, partitionFields);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 535 -        ArrayList&lt;String&gt; rowData;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 536 +        ArrayList&lt;String&gt; rowData = new ArrayList&lt;&gt;();</span>
 537          String tableNameInfo = Objects.isNull(schema) ?
 538                  tableName : quoteIdentifier(schema) + &quot;.&quot; + tableName;
 539          tempSql = tempSql.replace(&quot;tableName&quot;, tableNameInfo);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 540 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 541 -        // kudu ${partitionCondition} is null</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 542 -        if (storeType.equalsIgnoreCase(KUDU_TYPE) || !enablePartition) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 543 +        boolean isPartitioned = storeType.equalsIgnoreCase(KUDU_TYPE) || !enablePartition;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 544 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 545 +        try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 546 +            // kudu ${partitionCondition} is null</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 547 +            if (isPartitioned) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 548 +                tempSql = tempSql</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 549 +                    .replace(PARTITION_CONDITION, partitionCondition.toString())</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 550 +                    .replace(PARTITION_CONSTANT, &quot;&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 551 +                    .replace(TABLE_FIELDS_CONDITION, tableFieldsCondition);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 552 +                rowData.addAll(rowDataMap.get(NO_PARTITION));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 553 +                String executeSql = tempSql.replace(VALUES_CONDITION, String.join(&quot;, &quot;, rowData));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 554 +                statement.execute(executeSql);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 555 +                rowData.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 556 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 557 +                // partition sql</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 558 +                Set&lt;String&gt; keySet = rowDataMap.keySet();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 559 +                for (String key : keySet) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 560 +                    rowData.addAll(rowDataMap.get(key));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 561 +                    partitionCondition.append(key);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 562 +                    tempSql = tempSql</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 563 +                        .replace(PARTITION_CONDITION, partitionCondition.toString())</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 564 +                        .replace(TABLE_FIELDS_CONDITION, tableFieldsCondition);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 565 +                    String executeSql = tempSql</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 566 +                        .replace(VALUES_CONDITION, String.join(&quot;, &quot;, rowData));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 567 +                    statement.execute(executeSql);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 568 +                    partitionCondition.delete(0, partitionCondition.length());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 569 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 570 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 571 +        } catch (Exception e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 572 +            if (e instanceof SQLException) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 573 +                dealBatchSqlError(rowData, connection, statement, tempSql);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 574 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 575 +                throw new RuntimeException(&quot;Insert into impala error!&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 576 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 577 +        } finally {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 578 +            rowData.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 579 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 580 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 581 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 582 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 583 +     * 当批量写入失败时，把批量的sql拆解为单条sql提交，对于单条写入的sql记做脏数据</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 584 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 585 +     * @param rowData 批量的values</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 586 +     * @param connection 当前数据库connect</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 587 +     * @param statement 当前statement</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 588 +     * @param templateSql 模版sql，例如insert into tableName(f1, f2, f3) [partition] values $valueCondition</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 589 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 590 +    private void dealBatchSqlError(List&lt;String&gt; rowData,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 591 +                                   Connection connection,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 592 +                                   Statement statement,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 593 +                                   String templateSql) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 594 +        String errorMsg = &quot;Insert into impala error. \nCause: [%s]\nRow: [%s]&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 595 +        JDBCUtils.rollBack(connection);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 596 +        JDBCUtils.commit(connection);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 597 +        for (String rowDatum : rowData) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 598 +            String executeSql = templateSql.replace(VALUES_CONDITION, rowDatum);</span>
 599              try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 600 -                rowData = rowDataMap.get(NO_PARTITION);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 601 -                rowData.forEach(row -&gt; valuesCondition.append(row).append(&quot;, &quot;));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 602 -                String executeSql = tempSql.replace(VALUES_CONDITION, valuesCondition.toString())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 603 -                        .replace(PARTITION_CONDITION, partitionCondition.toString())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 604 -                        .replace(PARTITION_CONSTANT, &quot;&quot;)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 605 -                        .replace(TABLE_FIELDS_CONDITION, tableFieldsCondition);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 606 -                String substring = executeSql.substring(0, executeSql.length() - 2);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 607 -                statement.execute(substring);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 608 -            } catch (Exception e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 609 -                throw new RuntimeException(&quot;execute impala SQL error!&quot;, e);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 610 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 611 -            return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 612 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 613 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 614 -        // partition sql</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 615 -        Set&lt;String&gt; keySet = rowDataMap.keySet();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 616 -        String finalTempSql = tempSql;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 617 -        for (String key : keySet) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 618 -            try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 619 -                String executeSql = String.copyValueOf(finalTempSql.toCharArray());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 620 -                ArrayList&lt;String&gt; valuesConditionList = rowDataMap.get(key);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 621 -                partitionCondition.append(key);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 622 -                executeSql = executeSql.replace(PARTITION_CONDITION, partitionCondition.toString())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 623 -                        .replace(TABLE_FIELDS_CONDITION, tableFieldsCondition)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 624 -                        .replace(VALUES_CONDITION, String.join(&quot;, &quot;, valuesConditionList));</span>
 625                  statement.execute(executeSql);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 626 -                partitionCondition.delete(0, partitionCondition.length());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 627 -            } catch (SQLException sqlException) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 628 -                throw new RuntimeException(&quot;execute impala SQL error! &quot;, sqlException);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 629 +                JDBCUtils.commit(connection);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 630 +            } catch (SQLException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 631 +                JDBCUtils.rollBack(connection);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 632 +                JDBCUtils.commit(connection);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 633 +                if (metricOutputFormat.outDirtyRecords.getCount() % DIRTY_DATA_PRINT_FREQUENCY == 0 || LOG.isDebugEnabled()) {"> 633 +                if (metricOutputFormat.outDirtyRecords.getCount() % DIRTY_DATA_PRINT_FREQUENCY == 0 || LOG.isDebug🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 634 +                    LOG.error(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 635 +                        String.format(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 636 +                            errorMsg,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 637 +                            ExceptionTrace.traceOriginalCause(e),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 638 +                            rowDatum)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 639 +                    );</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 640 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 641 +                metricOutputFormat.outDirtyRecords.inc();</span>
 642              }
 643          }
 644      }
 645  
 646      /**
 647       * build partition condition with row data
 648       *
 649       * @param rowData              row data
 650       * @param partitionFields      partition fields
 651       * @param staticPartitionField static partition fields
 652       * @return condition like &#x27;(ptOne, ptTwo=v2)&#x27;
 653       */
<abbr title=" 654      private String buildPartitionCondition(Map&lt;String, Object&gt; rowData, String partitionFields, List&lt;String&gt; staticPartitionField) {"> 654      private String buildPartitionCondition(Map&lt;String, Object&gt; rowData, String partitionFields, List&lt;String&gt; stati🔵</abbr>
 655          for (String key : staticPartitionField) {
 656              StringBuilder sb = new StringBuilder();
 657              Object value = rowData.get(key);
 658              sb.append(key).append(&quot;=&quot;).append(value);
 659              partitionFields = partitionFields.replace(&quot;${&quot; + key + &quot;}&quot;, sb.toString());
 660          }
 661          return &quot;(&quot; + partitionFields + &quot;)&quot;;
 662      }
 663  
 664      /**
 665       * build field condition according to field names
 666       * replace ${tableFieldCondition}
 667       *
 668       * @param fieldNames      the selected field names
 669       * @param partitionFields the partition fields
 670       * @return condition like &#x27;(id, name, age)&#x27;
 671       */
 672      private String buildTableFieldsCondition(List&lt;String&gt; fieldNames, String partitionFields) {
 673          return &quot;(&quot; + fieldNames.stream()
 674                  .filter(f -&gt; !partitionFields.contains(f))
 675                  .map(this::quoteIdentifier)
 676                  .collect(Collectors.joining(&quot;, &quot;)) + &quot;)&quot;;
 677      }
 678  
 679      /**
 680       * according to field types, build the values condition
 681       * replace ${valuesCondition}
 682       *
 683       * @param fieldTypes field types
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 684 -     * @return condition like &#x27;(?, ?, cast(? as string))&#x27; and &#x27;?&#x27; will be replaced with row data</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 685 +     * @return condition like &#x27;(?, ?, cast(&#x27;?&#x27; as string))&#x27; and &#x27;?&#x27; will be replaced with row data</span>
 686       */
 687      private String buildValuesCondition(List&lt;String&gt; fieldTypes, Row row) {
 688          String valuesCondition = fieldTypes.stream().map(
 689                  f -&gt; {
 690                      for (String item : NEED_QUOTE_TYPE) {
 691                          if (f.toLowerCase().contains(item)) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 692 -                            return String.format(&quot;cast(? as %s)&quot;, f.toLowerCase());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 693 +                            return String.format(&quot;cast(&#x27;?&#x27; as %s)&quot;, f.toLowerCase());</span>
 694                          }
 695                      }
 696                      return &quot;?&quot;;
 697                  }).collect(Collectors.joining(&quot;, &quot;));
 698          for (int i = 0; i &lt; row.getArity(); i++) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 699 -            valuesCondition = valuesCondition.replaceFirst(&quot;\\?&quot;, Objects.isNull(row.getField(i)) ? &quot;null&quot; : row.getField(i).toString());"> 699 -            valuesCondition = valuesCondition.replaceFirst(&quot;\\?&quot;, Objects.isNull(row.getField(i)) ? &quot;null&quot; : row.g🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 700 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 701 -        return valuesCondition;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 702 +            Object rowField = row.getField(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 703 +            if (DtStringUtil.isEmptyOrNull(rowField)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 704 +                valuesCondition = valuesCondition.replaceFirst(&quot;&#x27;\\?&#x27;&quot;, &quot;null&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 705 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 706 +                valuesCondition = valuesCondition.replaceFirst(&quot;\\?&quot;, rowField.toString());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 707 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 708 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 709 +        return &quot;(&quot; + valuesCondition + &quot;)&quot;;</span>
 710      }
 711  
 712      /**
 713       * impala update mode SQL
 714       *
 715       * @return UPDATE tableName SET setCondition WHERE whereCondition
 716       */
<abbr title=" 717      private String buildUpdateSql(String schema, String tableName, List&lt;String&gt; fieldNames, List&lt;String&gt; primaryKeys) {"> 717      private String buildUpdateSql(String schema, String tableName, List&lt;String&gt; fieldNames, List&lt;String&gt; primaryKe🔵</abbr>
 718          //跳过primary key字段
 719          String setClause = fieldNames.stream()
 720                  .filter(f -&gt; !CollectionUtils.isNotEmpty(primaryKeys) || !primaryKeys.contains(f))
 721                  .map(f -&gt; quoteIdentifier(f) + &quot;=?&quot;)
 722                  .collect(Collectors.joining(&quot;, &quot;));
 723  
 724          String conditionClause = primaryKeys.stream()
 725                  .map(f -&gt; quoteIdentifier(f) + &quot;=?&quot;)
 726                  .collect(Collectors.joining(&quot; AND &quot;));
 727  
 728          return &quot;UPDATE &quot; + (Objects.isNull(schema) ? &quot;&quot; : quoteIdentifier(schema) + &quot;.&quot;)
 729                  + quoteIdentifier(tableName) + &quot; SET &quot; + setClause + &quot; WHERE &quot; + conditionClause;
 730      }
 731  
 732      private String quoteIdentifier(String identifier) {
 733          return &quot;`&quot; + identifier + &quot;`&quot;;
 734      }
 735  
 736      public static Builder getImpalaBuilder() {
 737          return new Builder();
 738      }
 739  
 740      public static class Builder {
 741          private final ImpalaOutputFormat format = new ImpalaOutputFormat();
 742  
 743          public Builder setDbUrl(String dbUrl) {
 744              format.dbUrl = dbUrl;
 745              return this;
 746          }
 747  
 748          public Builder setUserName(String userName) {
 749              format.userName = userName;
 750              return this;
 751          }
 752  
 753          public Builder setPassword(String password) {
 754              format.password = password;
 755              return this;
 756          }
 757  
 758          public Builder setBatchSize(Integer batchSize) {
 759              format.batchSize = batchSize;
 760              return this;
 761          }
 762  
 763          public Builder setBatchWaitInterval(Long batchWaitInterval) {
 764              format.batchWaitInterval = batchWaitInterval;
 765              return this;
 766          }
 767  
 768          public Builder setTableName(String tableName) {
 769              format.tableName = tableName;
 770              return this;
 771          }
 772  
 773          public Builder setPartitionFields(String partitionFields) {
 774              format.partitionFields = Objects.isNull(partitionFields) ?
 775                      &quot;&quot; : partitionFields;
 776              return this;
 777          }
 778  
 779          public Builder setPrimaryKeys(List&lt;String&gt; primaryKeys) {
 780              format.primaryKeys = primaryKeys;
 781              return this;
 782          }
 783  
 784          public Builder setSchema(String schema) {
 785              format.schema = schema;
 786              return this;
 787          }
 788  
 789          public Builder setEnablePartition(Boolean enablePartition) {
 790              format.enablePartition = enablePartition;
 791              return this;
 792          }
 793  
 794          public Builder setUpdateMode(String updateMode) {
 795              format.updateMode = updateMode;
 796              return this;
 797          }
 798  
 799          public Builder setFieldList(List&lt;String&gt; fieldList) {
 800              format.fieldNames = fieldList;
 801              return this;
 802          }
 803  
 804          public Builder setFieldTypeList(List&lt;String&gt; fieldTypeList) {
 805              format.fieldTypes = fieldTypeList;
 806              return this;
 807          }
 808  
 809          public Builder setStoreType(String storeType) {
 810              format.storeType = storeType;
 811              return this;
 812          }
 813  
 814          public Builder setFieldExtraInfoList(List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfoList) {
 815              format.fieldExtraInfoList = fieldExtraInfoList;
 816              return this;
 817          }
 818  
 819          public Builder setKeyTabPath(String keyTabPath) {
 820              format.keytabPath = keyTabPath;
 821              return this;
 822          }
 823  
 824          public Builder setKrb5ConfPath(String krb5ConfPath) {
 825              format.krb5confPath = krb5ConfPath;
 826              return this;
 827          }
 828  
 829          public Builder setPrincipal(String principal) {
 830              format.principal = principal;
 831              return this;
 832          }
 833  
 834          public Builder setAuthMech(Integer authMech) {
 835              format.authMech = authMech;
 836              return this;
 837          }
 838  
 839          private boolean canHandle(String url) {
 840              return url.startsWith(&quot;jdbc:impala:&quot;);
 841          }
 842  
 843          public ImpalaOutputFormat build() {
 844              if (!canHandle(format.dbUrl)) {
 845                  throw new IllegalArgumentException(&quot;impala dbUrl is illegal, check url: &quot; + format.dbUrl);
 846              }
 847  
 848              if (format.authMech == EAuthMech.Kerberos.getType()) {
 849                  checkNotNull(format.krb5confPath,
 850                          &quot;When kerberos authentication is enabled, krb5confPath is required！&quot;);
 851                  checkNotNull(format.principal,
 852                          &quot;When kerberos authentication is enabled, principal is required！&quot;);
 853                  checkNotNull(format.keytabPath,
 854                          &quot;When kerberos authentication is enabled, keytabPath is required！&quot;);
 855              }
 856  
 857              if (format.authMech == EAuthMech.UserName.getType()) {
 858                  checkNotNull(format.userName, &quot;userName is required!&quot;);
 859              }
 860  
 861              if (format.authMech == EAuthMech.NameANDPassword.getType()) {
 862                  checkNotNull(format.userName, &quot;userName is required!&quot;);
 863                  checkNotNull(format.password, &quot;password is required!&quot;);
 864              }
 865  
 866              checkNotNull(format.storeType, &quot;storeType is required!&quot;);
 867  
 868              return format;
 869          }
 870      }
 871  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            