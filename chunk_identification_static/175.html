<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>175</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    175
                    <a href="174.html">prev</a>
                    <a href="176.html">next</a>
                    <a href="175_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    BroadleafCommerce/BroadleafCommerce_b2742e6260e4e7d992c82e42c7d3b352419d17bb_core/broadleaf-framework/src/main/java/org/broadleafcommerce/core/order/service/OrderServiceImpl.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;b2742e6260e4e7d992c82e42c7d3b352419d17bb:core/broadleaf-framework/src/main/java/org/broadleafcommerce/core/order/service/OrderServiceImpl.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;b2742e6260e4e7d992c82e42c7d3b352419d17bb^1:core/broadleaf-framework/src/main/java/org/broadleafcommerce/core/order/service/OrderServiceImpl.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;b2742e6260e4e7d992c82e42c7d3b352419d17bb^2:core/broadleaf-framework/src/main/java/org/broadleafcommerce/core/order/service/OrderServiceImpl.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;0e1bf7b54bdd251cdbd1077c4e8dc9aae3c8dc95:core/broadleaf-framework/src/main/java/org/broadleafcommerce/core/order/service/OrderServiceImpl.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bs], [j]], subset: [[sbj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Framework
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  * 
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.core.order.service;
  19 
  20 import org.apache.commons.collections.CollectionUtils;
  21 import org.apache.commons.logging.Log;
  22 import org.apache.commons.logging.LogFactory;
  23 import org.broadleafcommerce.common.extension.ExtensionResultHolder;
  24 import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  25 import org.broadleafcommerce.common.payment.PaymentType;
  26 import org.broadleafcommerce.common.util.BLCSystemProperty;
  27 import org.broadleafcommerce.common.util.TableCreator;
  28 import org.broadleafcommerce.common.util.TransactionUtils;
  29 import org.broadleafcommerce.common.util.TypedPredicate;
  30 import org.broadleafcommerce.common.web.BroadleafRequestContext;
  31 import org.broadleafcommerce.core.catalog.domain.Product;
  32 import org.broadleafcommerce.core.catalog.domain.Sku;
  33 import org.broadleafcommerce.core.offer.dao.OfferDao;
  34 import org.broadleafcommerce.core.offer.domain.Offer;
  35 import org.broadleafcommerce.core.offer.domain.OfferCode;
  36 import org.broadleafcommerce.core.offer.service.OfferService;
  37 import org.broadleafcommerce.core.offer.service.OfferServiceExtensionManager;
  38 import org.broadleafcommerce.core.offer.service.exception.OfferAlreadyAddedException;
  39 import org.broadleafcommerce.core.offer.service.exception.OfferException;
  40 import org.broadleafcommerce.core.offer.service.exception.OfferExpiredException;
  41 import org.broadleafcommerce.core.offer.service.exception.OfferMaxUseExceededException;
  42 import org.broadleafcommerce.core.order.dao.OrderDao;
  43 import org.broadleafcommerce.core.order.domain.BundleOrderItem;
  44 import org.broadleafcommerce.core.order.domain.DiscreteOrderItem;
  45 import org.broadleafcommerce.core.order.domain.GiftWrapOrderItem;
  46 import org.broadleafcommerce.core.order.domain.NullOrderFactory;
  47 import org.broadleafcommerce.core.order.domain.NullOrderImpl;
  48 import org.broadleafcommerce.core.order.domain.Order;
  49 import org.broadleafcommerce.core.order.domain.OrderItem;
  50 import org.broadleafcommerce.core.order.domain.OrderItemAttribute;
  51 import org.broadleafcommerce.core.order.service.call.ActivityMessageDTO;
  52 import org.broadleafcommerce.core.order.service.call.GiftWrapOrderItemRequest;
  53 import org.broadleafcommerce.core.order.service.call.OrderItemRequestDTO;
  54 import org.broadleafcommerce.core.order.service.exception.AddToCartException;
  55 import org.broadleafcommerce.core.order.service.exception.IllegalCartOperationException;
  56 import org.broadleafcommerce.core.order.service.exception.ItemNotFoundException;
  57 import org.broadleafcommerce.core.order.service.exception.RemoveFromCartException;
  58 import org.broadleafcommerce.core.order.service.exception.UpdateCartException;
  59 import org.broadleafcommerce.core.order.service.type.OrderStatus;
  60 import org.broadleafcommerce.core.order.service.workflow.CartOperationRequest;
  61 import org.broadleafcommerce.core.payment.dao.OrderPaymentDao;
  62 import org.broadleafcommerce.core.payment.domain.OrderPayment;
  63 import org.broadleafcommerce.core.payment.domain.secure.Referenced;
  64 import org.broadleafcommerce.core.payment.service.SecureOrderPaymentService;
  65 import org.broadleafcommerce.core.pricing.service.PricingService;
  66 import org.broadleafcommerce.core.pricing.service.exception.PricingException;
  67 import org.broadleafcommerce.core.workflow.ActivityMessages;
  68 import org.broadleafcommerce.core.workflow.ProcessContext;
  69 import org.broadleafcommerce.core.workflow.Processor;
  70 import org.broadleafcommerce.core.workflow.WorkflowException;
  71 import org.broadleafcommerce.profile.core.domain.Customer;
  72 import org.broadleafcommerce.profile.core.service.CustomerService;
  73 import org.hibernate.FlushMode;
  74 import org.hibernate.Session;
  75 import org.hibernate.exception.LockAcquisitionException;
  76 import org.springframework.beans.factory.annotation.Value;
  77 import org.springframework.jmx.export.annotation.ManagedAttribute;
  78 import org.springframework.jmx.export.annotation.ManagedResource;
  79 import org.springframework.stereotype.Service;
  80 import org.springframework.transaction.PlatformTransactionManager;
  81 import org.springframework.transaction.TransactionDefinition;
  82 import org.springframework.transaction.TransactionStatus;
  83 import org.springframework.transaction.annotation.Transactional;
  84 
  85 import java.math.BigDecimal;
  86 import java.util.ArrayList;
  87 import java.util.Collections;
  88 import java.util.Comparator;
  89 import java.util.Date;
  90 import java.util.List;
  91 import java.util.Map;
  92 import java.util.Objects;
  93 import java.util.Set;
  94 
  95 import javax.annotation.Resource;
  96 import javax.persistence.EntityManager;
  97 import javax.persistence.PersistenceContext;
  98 
  99 /**
 100  * @author apazzolini
 101  */
 102 @Service(&quot;blOrderService&quot;)
<abbr title=" 103 @ManagedResource(objectName=&quot;org.broadleafcommerce:name=OrderService&quot;, description=&quot;Order Service&quot;, currencyTimeLimit=15)"> 103 @ManagedResource(objectName=&quot;org.broadleafcommerce:name=OrderService&quot;, description=&quot;Order Service&quot;, curreðŸ”µ</abbr>
 104 public class OrderServiceImpl implements OrderService {
 105     private static final Log LOG = LogFactory.getLog(OrderServiceImpl.class);
 106 
 107     /* DAOs */
 108     @Resource(name = &quot;blOrderPaymentDao&quot;)
 109     protected OrderPaymentDao paymentDao;
 110     
 111     @Resource(name = &quot;blOrderDao&quot;)
 112     protected OrderDao orderDao;
 113     
 114     @Resource(name = &quot;blOfferDao&quot;)
 115     protected OfferDao offerDao;
 116 
 117     /* Factories */
 118     @Resource(name = &quot;blNullOrderFactory&quot;)
 119     protected NullOrderFactory nullOrderFactory;
 120     
 121     /* Services */
 122     @Resource(name = &quot;blCustomerService&quot;)
 123     protected CustomerService customerService;
 124 
 125     @Resource(name = &quot;blPricingService&quot;)
 126     protected PricingService pricingService;
 127     
 128     @Resource(name = &quot;blOrderItemService&quot;)
 129     protected OrderItemService orderItemService;
 130     
 131     @Resource(name = &quot;blFulfillmentGroupService&quot;)
 132     protected FulfillmentGroupService fulfillmentGroupService;
 133     
 134     @Resource(name = &quot;blOfferService&quot;)
 135     protected OfferService offerService;
 136 
 137     @Resource(name = &quot;blSecureOrderPaymentService&quot;)
 138     protected SecureOrderPaymentService securePaymentInfoService;
 139 
 140     @Resource(name = &quot;blMergeCartService&quot;)
 141     protected MergeCartService mergeCartService;
 142     
 143     @Resource(name = &quot;blOrderServiceExtensionManager&quot;)
 144     protected OrderServiceExtensionManager extensionManager;
 145     
 146     /* Workflows */
 147     @Resource(name = &quot;blAddItemWorkflow&quot;)
 148     protected Processor addItemWorkflow;
 149     
 150     @Resource(name = &quot;blUpdateProductOptionsForItemWorkflow&quot;)
 151     private Processor updateProductOptionsForItemWorkflow;
 152 
 153     @Resource(name = &quot;blUpdateItemWorkflow&quot;)
 154     protected Processor updateItemWorkflow;
 155     
 156     @Resource(name = &quot;blRemoveItemWorkflow&quot;)
 157     protected Processor removeItemWorkflow;
 158 
 159     @Resource(name = &quot;blTransactionManager&quot;)
 160     protected PlatformTransactionManager transactionManager;
 161 
 162     @Value(&quot;${pricing.retry.count.for.lock.failure}&quot;)
 163     protected int pricingRetryCountForLockFailure = 3;
 164 
 165     @Value(&quot;${pricing.retry.wait.interval.for.lock.failure}&quot;)
 166     protected long pricingRetryWaitIntervalForLockFailure = 500L;
 167 
 168     /**
 169      * Advanced setting. Should Hibernate auto flush before queries during an
<abbr title=" 170      * add-to-cart workflow. This should generally be able to be left false. This is a performance measure and"> 170      * add-to-cart workflow. This should generally be able to be left false. This is a performance measurðŸ”µ</abbr>
 171      * add-to-cart operations will be more efficient when this is false.
 172      */
 173     @Value(&quot;${auto.flush.on.query.during.add.to.cart:false}&quot;)
 174     protected boolean autoFlushAddToCart = false;
 175 
 176     /**
 177      * Advanced setting. Should Hibernate auto flush before queries during an
<abbr title=" 178      * update-cart workflow. This should generally be able to be left false. This is a performance measure and"> 178      * update-cart workflow. This should generally be able to be left false. This is a performance measurðŸ”µ</abbr>
 179      * update-cart operations will be more efficient when this is false.
 180      */
 181     @Value(&quot;${auto.flush.on.query.during.update.cart:false}&quot;)
 182     protected boolean autoFlushUpdateCart = false;
 183 
 184     /**
 185      * Advanced setting. Should Hibernate auto flush before queries during an
<abbr title=" 186      * remove-from-cart workflow. This should generally be able to be left false. This is a performance measure and"> 186      * remove-from-cart workflow. This should generally be able to be left false. This is a performance mðŸ”µ</abbr>
 187      * remove-from-cart operations will be more efficient when this is false.
 188      */
 189     @Value(&quot;${auto.flush.on.query.during.remove.from.cart:false}&quot;)
 190     protected boolean autoFlushRemoveFromCart = false;
 191 
 192     /**
 193      * Advanced setting. Should Hibernate auto flush before queries during an
<abbr title=" 194      * order save pricing flow. This should generally be able to be left false. This is a performance measure and"> 194      * order save pricing flow. This should generally be able to be left false. This is a performance meaðŸ”µ</abbr>
 195      * save operations will be more efficient when this is false.
 196      */
 197     @Value(&quot;${auto.flush.on.query.during.cart.pricing.save:false}&quot;)
 198     protected boolean autoFlushSaveCart = false;
 199 
 200     @PersistenceContext(unitName=&quot;blPU&quot;)
 201     protected EntityManager em;
 202 
 203     /* Fields */
 204     protected boolean moveNamedOrderItems = true;
 205     protected boolean deleteEmptyNamedOrders = true;
 206 
 207     protected Boolean automaticallyMergeLikeItems;
 208 
 209     @Resource(name = &quot;blOrderMultishipOptionService&quot;)
 210     protected OrderMultishipOptionService orderMultishipOptionService;
 211 
 212     @Resource(name = &quot;blOfferServiceExtensionManager&quot;)
 213     protected OfferServiceExtensionManager offerServiceExtensionManager;
 214 
 215 
 216     @Override
 217     @Transactional(&quot;blTransactionManager&quot;)
 218     public Order createNewCartForCustomer(Customer customer) {
 219 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 220         customer = customerService.saveCustomer(customer);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 221         return orderDao.createNewCartForCustomer(customer);</span>
 222 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 223     @Transactional(&quot;blTransactionManager&quot;)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 224     public Order createNewCartForCustomer(Customer customer) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 225         return orderDao.createNewCartForCustomer(customer);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 226     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 227 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 228     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 229     @Transactional(&quot;blTransactionManager&quot;)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 230     public Order createNamedOrderForCustomer(String name, Customer customer) {</span>
 231 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 232         final Object lock = Objects.isNull(customer.getId()) ? customer : customer.getId();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 233         synchronized (lock) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 234             return orderDao.createNewCartForCustomer(customer);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 235         }</span>
 236 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 237     }
 238 
 239     @Override
 240     @Transactional(&quot;blTransactionManager&quot;)
 241     public Order createNamedOrderForCustomer(String name, Customer customer) {
 242         Order namedOrder = orderDao.create();
 243         namedOrder.setCustomer(customer);
 244         namedOrder.setName(name);
 245         namedOrder.setStatus(OrderStatus.NAMED);
 246         
 247         if (extensionManager != null) {
 248             extensionManager.getProxy().attachAdditionalDataToNewNamedCart(customer, namedOrder);
 249         }
 250         
 251         if (BroadleafRequestContext.getBroadleafRequestContext() != null) {
 252             namedOrder.setLocale(BroadleafRequestContext.getBroadleafRequestContext().getLocale());
 253         }
 254         
 255         return persist(namedOrder); // No need to price here
 256     }
 257 
 258     @Override
 259     public Order findNamedOrderForCustomer(String name, Customer customer) {
 260         return orderDao.readNamedOrderForCustomer(customer, name);
 261     }
 262 
 263     @Override
 264     public Order findOrderById(Long orderId) {
 265         return orderDao.readOrderById(orderId);
 266     }
 267 
 268     @Override
 269     public List&lt;Order&gt; findOrdersByIds(List&lt;Long&gt; orderIds) {
 270         return orderDao.readOrdersByIds(orderIds);
 271     }
 272 
 273     @Override
 274     public Order findOrderById(Long orderId, boolean refresh) {
 275         return orderDao.readOrderById(orderId, refresh);
 276     }
 277 
 278     @Override
 279     public Order getNullOrder() {
 280         return nullOrderFactory.getNullOrder();
 281     }
 282 
 283     @Override
 284     public Order findCartForCustomer(Customer customer) {
 285         return orderDao.readCartForCustomer(customer);
 286     }
 287 
 288     @Override
 289     public List&lt;Order&gt; findOrdersForCustomer(Customer customer) {
 290         return orderDao.readOrdersForCustomer(customer.getId());
 291     }
 292 
 293     @Override
 294     public List&lt;Order&gt; findOrdersForCustomer(Customer customer, OrderStatus status) {
 295         return orderDao.readOrdersForCustomer(customer, status);
 296     }
 297 
 298     @Override
 299     public Order findOrderByOrderNumber(String orderNumber) {
 300         return orderDao.readOrderByOrderNumber(orderNumber);
 301     }
 302 
 303     @Override
 304     public List&lt;Order&gt; findOrdersByDateRange(Date startDate, Date endDate) {
 305         return orderDao.readOrdersByDateRange(startDate, endDate);
 306     }
 307 
 308     @Override
 309     public List&lt;Order&gt; findOrdersByDaysCount(Integer daysCount, Integer batchSize) {
 310         return orderDao.readOrdersOlderThanDaysCount(daysCount, batchSize);
 311     }
 312 
 313     @Override
<abbr title=" 314     public List&lt;Order&gt; findOrdersForCustomersInDateRange(List&lt;Long&gt; customerIds, Date startDate, Date endDate) {"> 314     public List&lt;Order&gt; findOrdersForCustomersInDateRange(List&lt;Long&gt; customerIds, Date startDate, Date endðŸ”µ</abbr>
 315         return orderDao.readOrdersForCustomersInDateRange(customerIds, startDate, endDate);
 316     }
 317 
 318     @Override
 319     public List&lt;OrderPayment&gt; findPaymentsForOrder(Order order) {
 320         return paymentDao.readPaymentsForOrder(order);
 321     }
 322     
 323     @Override
 324     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 325     public OrderPayment addPaymentToOrder(Order order, OrderPayment payment, Referenced securePaymentInfo) {"> 325     public OrderPayment addPaymentToOrder(Order order, OrderPayment payment, Referenced securePaymentInfoðŸ”µ</abbr>
 326         payment.setOrder(order);
 327         order.getPayments().add(payment);
 328         order = persist(order);
 329         int paymentIndex = order.getPayments().size() - 1;
 330 
 331         if (securePaymentInfo != null) {
 332             securePaymentInfoService.save(securePaymentInfo);
 333         }
 334 
 335         return order.getPayments().get(paymentIndex);
 336     }
 337     
 338     @Override
 339     public Order save(Order order, boolean priceOrder, boolean repriceItems) throws PricingException {
 340         if (repriceItems) {
 341             order.updatePrices();
 342         }
 343         return save(order, priceOrder);
 344     }
 345 
 346     @Override
 347     public Order save(Order order, Boolean priceOrder) throws PricingException {
 348         //persist the order first
 349         TransactionStatus status = TransactionUtils.createTransaction(&quot;saveOrder&quot;,
 350                     TransactionDefinition.PROPAGATION_REQUIRED, transactionManager);
 351         try {
 352             order = persist(order);
 353             TransactionUtils.finalizeTransaction(status, transactionManager, false);
 354         } catch (RuntimeException ex) {
 355             TransactionUtils.finalizeTransaction(status, transactionManager, true);
 356             throw ex;
 357         }
 358 
 359         //make any pricing changes - possibly retrying with the persisted state if there&#x27;s a lock failure
 360         if (priceOrder) {
 361             int retryCount = 0;
 362             boolean isValid = false;
 363             while (!isValid) {
 364                 Session session = em.unwrap(Session.class);
 365                 FlushMode current = session.getHibernateFlushMode();
 366                 try {
 367                     if (!autoFlushSaveCart) {
<abbr title=" 368                         //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 368                         //Performance measure. Hibernate will sometimes perform an autoflush when performðŸ”µ</abbr>
<abbr title=" 369                         //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 369                         //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern aboutðŸ”µ</abbr>
 370                         //incorrect results because something has not been flushed to the database yet.
 371                         session.setHibernateFlushMode(FlushMode.MANUAL);
 372                     }
 373                     order = pricingService.executePricing(order);
 374                     isValid = true;
 375                 } catch (Exception ex) {
 376                     boolean isValidCause = false;
 377                     Throwable cause = ex;
 378                     while (!isValidCause) {
 379                         if (cause.getClass().equals(LockAcquisitionException.class)) {
 380                             isValidCause = true;
 381                         }
 382                         cause = cause.getCause();
 383                         if (cause == null) {
 384                             break;
 385                         }
 386                     }
 387                     if (isValidCause) {
 388                         if (LOG.isInfoEnabled()) {
<abbr title=" 389                             LOG.info(&quot;Problem acquiring lock during pricing call - attempting to price again.&quot;);"> 389                             LOG.info(&quot;Problem acquiring lock during pricing call - attempting to price agðŸ”µ</abbr>
 390                         }
 391                         isValid = false;
 392                         if (retryCount &gt;= pricingRetryCountForLockFailure) {
 393                             if (LOG.isInfoEnabled()) {
<abbr title=" 394                                 LOG.info(&quot;Problem acquiring lock during pricing call. Retry limit exceeded at (&quot; + retryCount + &quot;). Throwing exception.&quot;);"> 394                                 LOG.info(&quot;Problem acquiring lock during pricing call. Retry limit exceedeðŸ”µ</abbr>
 395                             }
 396                             if (ex instanceof PricingException) {
 397                                 throw (PricingException) ex;
 398                             } else {
 399                                 throw new PricingException(ex);
 400                             }
 401                         } else {
 402                             order = findOrderById(order.getId());
 403                             retryCount++;
 404                         }
 405                         try {
 406                             Thread.sleep(pricingRetryWaitIntervalForLockFailure);
 407                         } catch (Throwable e) {
 408                             //do nothing
 409                         }
 410                     } else {
 411                         if (ex instanceof PricingException) {
 412                             throw (PricingException) ex;
 413                         } else {
 414                             throw new PricingException(ex);
 415                         }
 416                     }
 417                 } finally {
 418                     if (!autoFlushSaveCart) {
 419                         session.setHibernateFlushMode(current);
 420                     }
 421                 }
 422             }
 423 
 424             //make the final save of the priced order
 425             status = TransactionUtils.createTransaction(&quot;saveOrder&quot;,
 426                                 TransactionDefinition.PROPAGATION_REQUIRED, transactionManager);
 427             Session session = em.unwrap(Session.class);
 428             FlushMode current = session.getHibernateFlushMode();
 429             try {
 430                 if (!autoFlushSaveCart) {
<abbr title=" 431                     //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 431                     //Performance measure. Hibernate will sometimes perform an autoflush when performing ðŸ”µ</abbr>
<abbr title=" 432                     //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 432                     //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queðŸ”µ</abbr>
 433                     //incorrect results because something has not been flushed to the database yet.
 434                     session.setHibernateFlushMode(FlushMode.MANUAL);
 435                 }
 436                 order = persist(order);
 437 
 438                 if (extensionManager != null) {
 439                     extensionManager.getProxy().attachAdditionalDataToOrder(order, priceOrder);
 440                 }
 441                 if (!autoFlushSaveCart) {
 442                     session.setFlushMode(current);
 443                 }
 444                 TransactionUtils.finalizeTransaction(status, transactionManager, false);
 445             } catch (RuntimeException ex) {
 446                 TransactionUtils.finalizeTransaction(status, transactionManager, true);
 447                 throw ex;
 448             } finally {
 449                 if (!autoFlushSaveCart &amp;&amp; !session.getFlushMode().equals(current)) {
 450                     session.setHibernateFlushMode(current);
 451                 }
 452             }
 453         }
 454 
 455         return order;
 456     }
 457     
 458     // This method exists to provide OrderService methods the ability to save an order
 459     // without having to worry about a PricingException being thrown.
 460     protected Order persist(Order order) {
 461         return orderDao.save(order);
 462     }
 463 
 464     @Override
 465     @Transactional(&quot;blTransactionManager&quot;)
 466     public void cancelOrder(Order order) {
 467         orderDao.delete(order);
 468     }
 469 
 470     @Override
 471     @Transactional(&quot;blTransactionManager&quot;)
 472     public void deleteOrder(Order order) {
 473         orderMultishipOptionService.deleteAllOrderMultishipOptions(order);
 474         orderDao.delete(order);
 475     }
 476 
 477     @Override
 478     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 479     public Order addOfferCode(Order order, OfferCode offerCode, boolean priceOrder) throws PricingException, OfferException {"> 479     public Order addOfferCode(Order order, OfferCode offerCode, boolean priceOrder) throws PricingExceptiðŸ”µ</abbr>
 480         ArrayList&lt;OfferCode&gt; offerCodes = new ArrayList&lt;OfferCode&gt;();
 481         offerCodes.add(offerCode);
 482         return addOfferCodes(order, offerCodes, priceOrder);
 483     }
 484 
 485     @Override
 486     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 487     public Order addOfferCodes(Order order, List&lt;OfferCode&gt; offerCodes, boolean priceOrder) throws PricingException, OfferException {"> 487     public Order addOfferCodes(Order order, List&lt;OfferCode&gt; offerCodes, boolean priceOrder) throws PricinðŸ”µ</abbr>
 488         preValidateCartOperation(order);
 489         Set&lt;Offer&gt; addedOffers = offerService.getUniqueOffersFromOrder(order);
 490         if (extensionManager != null) {
 491             extensionManager.getProxy().addOfferCodes(order, offerCodes, priceOrder);
 492         }
 493         if (offerCodes != null &amp;&amp; !offerCodes.isEmpty()) {
 494             for (OfferCode offerCode : offerCodes) {
 495                 
<abbr title=" 496                 if (order.getAddedOfferCodes().contains(offerCode) || addedOffers.contains(offerCode.getOffer())) {"> 496                 if (order.getAddedOfferCodes().contains(offerCode) || addedOffers.contains(offerCode.getOðŸ”µ</abbr>
 497                     throw new OfferAlreadyAddedException(&quot;The offer has already been added.&quot;);
 498                 } else if (!offerService.verifyMaxCustomerUsageThreshold(order, offerCode)) {
<abbr title=" 499                     throw new OfferMaxUseExceededException(&quot;The customer has used this offer code more than the maximum allowed number of times.&quot;);"> 499                     throw new OfferMaxUseExceededException(&quot;The customer has used this offer code more thðŸ”µ</abbr>
 500                 } else if (!offerCode.isActive() || !offerCode.getOffer().isActive()) {
 501                     throw new OfferExpiredException(&quot;The offer has expired.&quot;);
 502                 }
 503 
 504                 order.getAddedOfferCodes().add(offerCode);
 505 
 506             }
 507             order = save(order, priceOrder);
 508         }
 509 
 510         return order;
 511     }
 512 
 513     @Override
 514     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 515     public Order removeOfferCode(Order order, OfferCode offerCode, boolean priceOrder) throws PricingException {"> 515     public Order removeOfferCode(Order order, OfferCode offerCode, boolean priceOrder) throws PricingExceðŸ”µ</abbr>
 516         order.getAddedOfferCodes().remove(offerCode);
 517         offerServiceExtensionManager.removeOfferCodeFromOrder(offerCode, order);
 518         order = save(order, priceOrder);
 519         return order;   
 520     }
 521 
 522     @Override
 523     @Transactional(&quot;blTransactionManager&quot;)
 524     public Order removeAllOfferCodes(Order order, boolean priceOrder) throws PricingException {
 525          order.getAddedOfferCodes().clear();
 526          order = save(order, priceOrder);
 527          return order;  
 528     }
 529 
 530     @Override
<abbr title=" 531     @ManagedAttribute(description=&quot;The delete empty named order after adding items to cart attribute&quot;, currencyTimeLimit=15)"> 531     @ManagedAttribute(description=&quot;The delete empty named order after adding items to cart attribute&quot;, cuðŸ”µ</abbr>
 532     public void setDeleteEmptyNamedOrders(boolean deleteEmptyNamedOrders) {
 533         this.deleteEmptyNamedOrders = deleteEmptyNamedOrders;
 534     }
 535     
 536     @Override
 537     public OrderItem findLastMatchingItem(Order order, Long skuId, Long productId) {
 538         if (order.getOrderItems() != null) {
 539             for (int i=(order.getOrderItems().size()-1); i &gt;= 0; i--) {
 540                 OrderItem currentItem = (order.getOrderItems().get(i));
 541                 if (currentItem instanceof DiscreteOrderItem) {
 542                     DiscreteOrderItem discreteItem = (DiscreteOrderItem) currentItem;
 543                     if (skuId != null) {
<abbr title=" 544                         if (discreteItem.getSku() != null &amp;&amp; skuId.equals(discreteItem.getSku().getId())) {"> 544                         if (discreteItem.getSku() != null &amp;&amp; skuId.equals(discreteItem.getSku().getId()))ðŸ”µ</abbr>
 545                             return discreteItem;
 546                         }
<abbr title=" 547                     } else if (productId != null &amp;&amp; discreteItem.getProduct() != null &amp;&amp; productId.equals(discreteItem.getProduct().getId())) {"> 547                     } else if (productId != null &amp;&amp; discreteItem.getProduct() != null &amp;&amp; productId.equalsðŸ”µ</abbr>
 548                         return discreteItem;
 549                     }
 550 
 551                 } else if (currentItem instanceof BundleOrderItem) {
 552                     BundleOrderItem bundleItem = (BundleOrderItem) currentItem;
 553                     if (skuId != null) {
 554                         if (bundleItem.getSku() != null &amp;&amp; skuId.equals(bundleItem.getSku().getId())) {
 555                             return bundleItem;
 556                         }
<abbr title=" 557                     } else if (productId != null &amp;&amp; bundleItem.getProduct() != null &amp;&amp; productId.equals(bundleItem.getProduct().getId())) {"> 557                     } else if (productId != null &amp;&amp; bundleItem.getProduct() != null &amp;&amp; productId.equals(bðŸ”µ</abbr>
 558                         return bundleItem;
 559                     }
 560                 }
 561             }
 562         }
 563         return null;
 564     }
 565     
 566     @Override
 567     @Transactional(&quot;blTransactionManager&quot;)
 568     public Order confirmOrder(Order order) {
 569         return orderDao.submitOrder(order);
 570     }
 571     
 572     @Override
 573     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 574     public Order addAllItemsFromNamedOrder(Order namedOrder, boolean priceOrder) throws RemoveFromCartException, AddToCartException {"> 574     public Order addAllItemsFromNamedOrder(Order namedOrder, boolean priceOrder) throws RemoveFromCartExcðŸ”µ</abbr>
 575         Order cartOrder = orderDao.readCartForCustomer(namedOrder.getCustomer());
 576         if (cartOrder == null) {
 577             cartOrder = createNewCartForCustomer(namedOrder.getCustomer());
 578         }
 579         List&lt;OrderItem&gt; items = new ArrayList&lt;OrderItem&gt;(namedOrder.getOrderItems());
 580 
 581         // Remove any order items that are children
 582         CollectionUtils.filter(items,  new TypedPredicate&lt;OrderItem&gt;() {
 583             @Override
 584             public boolean eval(OrderItem orderItem) {
 585                 return orderItem.getParentOrderItem() == null;
 586             }
 587         });
 588         for (OrderItem item : items) {
<abbr title=" 589             OrderItemRequestDTO orderItemRequest = orderItemService.buildOrderItemRequestDTOFromOrderItem(item);"> 589             OrderItemRequestDTO orderItemRequest = orderItemService.buildOrderItemRequestDTOFromOrderItemðŸ”µ</abbr>
 590             cartOrder = addItem(cartOrder.getId(), orderItemRequest, priceOrder);
 591 
 592             if (moveNamedOrderItems) {
 593                 removeItem(namedOrder.getId(), item.getId(), false);
 594             }
 595         }
 596         
 597         if (deleteEmptyNamedOrders) {
 598             cancelOrder(namedOrder);
 599         }
 600         
 601         return cartOrder;
 602     }
 603     
 604     @Override
 605     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 606     public Order addItemFromNamedOrder(Order namedOrder, OrderItem item, boolean priceOrder) throws RemoveFromCartException, AddToCartException {"> 606     public Order addItemFromNamedOrder(Order namedOrder, OrderItem item, boolean priceOrder) throws RemovðŸ”µ</abbr>
 607         Order cartOrder = orderDao.readCartForCustomer(namedOrder.getCustomer());
 608         if (cartOrder == null) {
 609             cartOrder = createNewCartForCustomer(namedOrder.getCustomer());
 610         }
 611 
<abbr title=" 612         OrderItemRequestDTO orderItemRequest = orderItemService.buildOrderItemRequestDTOFromOrderItem(item);"> 612         OrderItemRequestDTO orderItemRequest = orderItemService.buildOrderItemRequestDTOFromOrderItem(iteðŸ”µ</abbr>
 613         cartOrder = addItem(cartOrder.getId(), orderItemRequest, priceOrder);
 614 
 615         if (moveNamedOrderItems) {
 616             removeItem(namedOrder.getId(), item.getId(), false);
 617         }
 618 
 619         if (namedOrder.getOrderItems().size() == 0 &amp;&amp; deleteEmptyNamedOrders) {
 620             cancelOrder(namedOrder);
 621         }
 622             
 623         return cartOrder;
 624     }
 625     
 626     @Override
 627     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 628     public Order addItemFromNamedOrder(Order namedOrder, OrderItem item, int quantity, boolean priceOrder) throws RemoveFromCartException, AddToCartException, UpdateCartException {"> 628     public Order addItemFromNamedOrder(Order namedOrder, OrderItem item, int quantity, boolean priceOrderðŸ”µ</abbr>
 629         // Validate that the quantity requested makes sense
 630         if (quantity &lt; 1 || quantity &gt; item.getQuantity()) {
 631             throw new IllegalArgumentException(&quot;Cannot move 0 or less quantity&quot;);
 632         } else if (quantity == item.getQuantity()) {
 633             return addItemFromNamedOrder(namedOrder, item, priceOrder);
 634         }
 635         
 636         Order cartOrder = orderDao.readCartForCustomer(namedOrder.getCustomer());
 637         if (cartOrder == null) {
 638             cartOrder = createNewCartForCustomer(namedOrder.getCustomer());
 639         }
 640 
<abbr title=" 641         OrderItemRequestDTO orderItemRequest = orderItemService.buildOrderItemRequestDTOFromOrderItem(item);"> 641         OrderItemRequestDTO orderItemRequest = orderItemService.buildOrderItemRequestDTOFromOrderItem(iteðŸ”µ</abbr>
 642         orderItemRequest.setQuantity(quantity);
 643         cartOrder = addItem(cartOrder.getId(), orderItemRequest, priceOrder);
 644 
 645         if (moveNamedOrderItems) {
 646             // Update the old item to its new quantity only if we&#x27;re moving items
 647             OrderItemRequestDTO orderItemRequestDTO = new OrderItemRequestDTO();
 648             orderItemRequestDTO.setOrderItemId(item.getId());
 649             orderItemRequestDTO.setQuantity(item.getQuantity() - quantity);
 650             updateItemQuantity(namedOrder.getId(), orderItemRequestDTO, false);
 651         }
 652         return cartOrder;
 653     }
 654     
 655     @Override
 656     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 657     public OrderItem addGiftWrapItemToOrder(Order order, GiftWrapOrderItemRequest itemRequest, boolean priceOrder) throws PricingException {"> 657     public OrderItem addGiftWrapItemToOrder(Order order, GiftWrapOrderItemRequest itemRequest, boolean prðŸ”µ</abbr>
 658         GiftWrapOrderItem item = orderItemService.createGiftWrapOrderItem(itemRequest);
 659         item.setOrder(order);
 660         item = (GiftWrapOrderItem) orderItemService.saveOrderItem(item);
 661         
 662         order.getOrderItems().add(item);
 663         order = save(order, priceOrder);
 664         
 665         return item;
 666     }
 667     
 668     @Override
 669     @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = {AddToCartException.class})
<abbr title=" 670     public Order addItem(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throws AddToCartException {"> 670     public Order addItem(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throwðŸ”µ</abbr>
 671         // Don&#x27;t allow overrides from this method.
 672         orderItemRequestDTO.setOverrideRetailPrice(null);
 673         orderItemRequestDTO.setOverrideSalePrice(null);
 674         return addItemWithPriceOverrides(orderId, orderItemRequestDTO, priceOrder);
 675     }
 676 
 677     @Override
 678     @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = { AddToCartException.class })
<abbr title=" 679     public Order addItemWithPriceOverrides(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throws AddToCartException {"> 679     public Order addItemWithPriceOverrides(Long orderId, OrderItemRequestDTO orderItemRequestDTO, booleanðŸ”µ</abbr>
 680         Order order = findOrderById(orderId);
 681         preValidateCartOperation(order);
 682         if (getAutomaticallyMergeLikeItems()) {
 683             OrderItem item = findMatchingItem(order, orderItemRequestDTO);
 684             if (item != null &amp;&amp; item.getParentOrderItem() == null) {
 685                 orderItemRequestDTO.setQuantity(item.getQuantity() + orderItemRequestDTO.getQuantity());
 686                 orderItemRequestDTO.setOrderItemId(item.getId());
 687                 try {
 688                     return updateItemQuantity(orderId, orderItemRequestDTO, priceOrder);
 689                 } catch (RemoveFromCartException e) {
<abbr title=" 690                     throw new AddToCartException(&quot;Unexpected error - system tried to remove item while adding to cart&quot;, e);"> 690                     throw new AddToCartException(&quot;Unexpected error - system tried to remove item while adðŸ”µ</abbr>
 691                 } catch (UpdateCartException e) {
 692                     throw new AddToCartException(&quot;Could not update quantity for matched item&quot;, e);
 693                 }
 694             }
 695         }
 696         try {
<abbr title=" 697             // We only want to price on the last addition for performance reasons and only if the user asked for it."> 697             // We only want to price on the last addition for performance reasons and only if the user asðŸ”µ</abbr>
 698             int numAdditionRequests = priceOrder ? (getTotalChildOrderItems(orderItemRequestDTO)) : -1;
 699             int currentAddition = 1;
 700 
<abbr title=" 701             CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestDTO, currentAddition == numAdditionRequests);"> 701             CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItðŸ”µ</abbr>
 702 
 703             Session session = em.unwrap(Session.class);
 704             FlushMode current = session.getHibernateFlushMode();
 705             if (!autoFlushAddToCart) {
<abbr title=" 706                 //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 706                 //Performance measure. Hibernate will sometimes perform an autoflush when performing querðŸ”µ</abbr>
<abbr title=" 707                 //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 707                 //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queriesðŸ”µ</abbr>
 708                 //incorrect results because something has not been flushed to the database yet.
 709                 session.setHibernateFlushMode(FlushMode.MANUAL);
 710             }
 711             ProcessContext&lt;CartOperationRequest&gt; context;
 712             try {
<abbr title=" 713                 context = (ProcessContext&lt;CartOperationRequest&gt;) addItemWorkflow.doActivities(cartOpRequest);"> 713                 context = (ProcessContext&lt;CartOperationRequest&gt;) addItemWorkflow.doActivities(cartOpRequeðŸ”µ</abbr>
 714             } finally {
 715                 if (!autoFlushAddToCart) {
 716                     session.setHibernateFlushMode(current);
 717                 }
 718             }
 719 
 720             List&lt;ActivityMessageDTO&gt; orderMessages = new ArrayList&lt;ActivityMessageDTO&gt;();
 721             orderMessages.addAll(((ActivityMessages) context).getActivityMessages());
 722 
 723             // Update the orderItemRequest incase it changed during the initial add to cart workflow
 724             orderItemRequestDTO = context.getSeedData().getItemRequest();
 725             numAdditionRequests = priceOrder ? (getTotalChildOrderItems(orderItemRequestDTO) - 1) : -1;
<abbr title=" 726             addChildItems(orderItemRequestDTO, numAdditionRequests, currentAddition, context, orderMessages);"> 726             addChildItems(orderItemRequestDTO, numAdditionRequests, currentAddition, context, orderMessagðŸ”µ</abbr>
 727 
 728             context.getSeedData().getOrder().setOrderMessages(orderMessages);
 729             return context.getSeedData().getOrder();
 730         } catch (WorkflowException e) {
 731             throw new AddToCartException(&quot;Could not add to cart&quot;, getCartOperationExceptionRootCause(e));
 732         }
 733 
 734     }
 735 
 736     @Override
 737     public int getTotalChildOrderItems(OrderItemRequestDTO orderItemRequestDTO) {
 738         int count = 1;
 739         for (OrderItemRequestDTO childRequest : orderItemRequestDTO.getChildOrderItems()) {
 740             count += getTotalChildOrderItems(childRequest);
 741         }
 742         return count;
 743     }
 744 
 745     @Override
<abbr title=" 746     public void addChildItems(OrderItemRequestDTO orderItemRequestDTO, int numAdditionRequests, int currentAddition, ProcessContext&lt;CartOperationRequest&gt; context, List&lt;ActivityMessageDTO&gt; orderMessages) throws WorkflowException {"> 746     public void addChildItems(OrderItemRequestDTO orderItemRequestDTO, int numAdditionRequests, int curreðŸ”µ</abbr>
 747         if (CollectionUtils.isNotEmpty(orderItemRequestDTO.getChildOrderItems())) {
 748             Long parentOrderItemId = context.getSeedData().getOrderItem().getId();
 749             for (OrderItemRequestDTO childRequest : orderItemRequestDTO.getChildOrderItems()) {
 750                 childRequest.setParentOrderItemId(parentOrderItemId);
 751                 currentAddition++;
 752 
 753                 if (childRequest.getQuantity() &gt; 0) {
<abbr title=" 754                     CartOperationRequest childCartOpRequest = new CartOperationRequest(context.getSeedData().getOrder(), childRequest, currentAddition == numAdditionRequests);"> 754                     CartOperationRequest childCartOpRequest = new CartOperationRequest(context.getSeedDatðŸ”µ</abbr>
 755                     Session session = em.unwrap(Session.class);
 756                     FlushMode current = session.getHibernateFlushMode();
 757                     if (!autoFlushAddToCart) {
<abbr title=" 758                         //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 758                         //Performance measure. Hibernate will sometimes perform an autoflush when performðŸ”µ</abbr>
<abbr title=" 759                         //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 759                         //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern aboutðŸ”µ</abbr>
 760                         //incorrect results because something has not been flushed to the database yet.
 761                         session.setHibernateFlushMode(FlushMode.MANUAL);
 762                     }
 763                     ProcessContext&lt;CartOperationRequest&gt; childContext;
 764                     try {
<abbr title=" 765                         childContext = (ProcessContext&lt;CartOperationRequest&gt;) addItemWorkflow.doActivities(childCartOpRequest);"> 765                         childContext = (ProcessContext&lt;CartOperationRequest&gt;) addItemWorkflow.doActivitieðŸ”µ</abbr>
 766                     } finally {
 767                         if (!autoFlushAddToCart) {
 768                             session.setHibernateFlushMode(current);
 769                         }
 770                     }
 771                     orderMessages.addAll(((ActivityMessages) childContext).getActivityMessages());
 772 
<abbr title=" 773                     addChildItems(childRequest, numAdditionRequests, currentAddition, childContext, orderMessages);"> 773                     addChildItems(childRequest, numAdditionRequests, currentAddition, childContext, orderðŸ”µ</abbr>
 774                 }
 775             }
 776         }
 777     }
 778 
 779     @Override
<abbr title=" 780     public void addDependentOrderItem(OrderItemRequestDTO parentOrderItemRequest, OrderItemRequestDTO dependentOrderItem) {"> 780     public void addDependentOrderItem(OrderItemRequestDTO parentOrderItemRequest, OrderItemRequestDTO depðŸ”µ</abbr>
 781         parentOrderItemRequest.getChildOrderItems().add(dependentOrderItem);
<abbr title=" 782         Collections.sort(parentOrderItemRequest.getChildOrderItems(), new Comparator&lt;OrderItemRequestDTO&gt;() {"> 782         Collections.sort(parentOrderItemRequest.getChildOrderItems(), new Comparator&lt;OrderItemRequestDTO&gt;ðŸ”µ</abbr>
 783             @Override
 784             public int compare(OrderItemRequestDTO o1, OrderItemRequestDTO o2) {
<abbr title=" 785                 BigDecimal o1DisplayOrder = new BigDecimal(o1.getAdditionalAttributes().get(&quot;addOnDisplayOrder&quot;));"> 785                 BigDecimal o1DisplayOrder = new BigDecimal(o1.getAdditionalAttributes().get(&quot;addOnDisplayðŸ”µ</abbr>
<abbr title=" 786                 BigDecimal o2DisplayOrder = new BigDecimal(o2.getAdditionalAttributes().get(&quot;addOnDisplayOrder&quot;));"> 786                 BigDecimal o2DisplayOrder = new BigDecimal(o2.getAdditionalAttributes().get(&quot;addOnDisplayðŸ”µ</abbr>
 787                 return o1DisplayOrder.compareTo(o2DisplayOrder);
 788             }
 789         });
 790     }
 791 
 792     @Override
<abbr title=" 793     @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = {UpdateCartException.class, RemoveFromCartException.class})"> 793     @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = {UpdateCartException.class, RemoveFromCaðŸ”µ</abbr>
<abbr title=" 794     public Order updateItemQuantity(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throws UpdateCartException, RemoveFromCartException {"> 794     public Order updateItemQuantity(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOðŸ”µ</abbr>
 795         Order order = findOrderById(orderId);
 796         preValidateCartOperation(order);
 797         preValidateUpdateQuantityOperation(findOrderById(orderId), orderItemRequestDTO);
 798         if (orderItemRequestDTO.getQuantity() == 0) {
 799             return removeItem(orderId, orderItemRequestDTO.getOrderItemId(), priceOrder);
 800         }
 801         
 802         try {
<abbr title=" 803             CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestDTO, priceOrder);"> 803             CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItðŸ”µ</abbr>
 804             Session session = em.unwrap(Session.class);
 805             FlushMode current = session.getHibernateFlushMode();
 806             if (!autoFlushUpdateCart) {
<abbr title=" 807                 //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 807                 //Performance measure. Hibernate will sometimes perform an autoflush when performing querðŸ”µ</abbr>
<abbr title=" 808                 //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 808                 //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queriesðŸ”µ</abbr>
 809                 //incorrect results because something has not been flushed to the database yet.
 810                 session.setHibernateFlushMode(FlushMode.MANUAL);
 811             }
 812             ProcessContext&lt;CartOperationRequest&gt; context;
 813             try {
<abbr title=" 814                 context = (ProcessContext&lt;CartOperationRequest&gt;) updateItemWorkflow.doActivities(cartOpRequest);"> 814                 context = (ProcessContext&lt;CartOperationRequest&gt;) updateItemWorkflow.doActivities(cartOpReðŸ”µ</abbr>
 815             } finally {
 816                 if (!autoFlushUpdateCart) {
 817                     session.setHibernateFlushMode(current);
 818                 }
 819             }
<abbr title=" 820             context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getActivityMessages());"> 820             context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getAcðŸ”µ</abbr>
 821             return context.getSeedData().getOrder();
 822         } catch (WorkflowException e) {
<abbr title=" 823             throw new UpdateCartException(&quot;Could not update cart quantity&quot;, getCartOperationExceptionRootCause(e));"> 823             throw new UpdateCartException(&quot;Could not update cart quantity&quot;, getCartOperationExceptionRootðŸ”µ</abbr>
 824         }
 825     }
 826 
 827     @Override
 828     @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = {RemoveFromCartException.class})
<abbr title=" 829     public Order removeItem(Long orderId, Long orderItemId, boolean priceOrder) throws RemoveFromCartException {"> 829     public Order removeItem(Long orderId, Long orderItemId, boolean priceOrder) throws RemoveFromCartExceðŸ”µ</abbr>
 830         preValidateCartOperation(findOrderById(orderId));
 831         try {
 832             OrderItem oi = orderItemService.readOrderItemById(orderItemId);
 833             if (oi == null) {
 834                 throw new WorkflowException(new ItemNotFoundException());
 835             }
 836             List&lt;Long&gt; childrenToRemove = new ArrayList&lt;Long&gt;();
 837             if (oi instanceof BundleOrderItem) {
 838                 List&lt;DiscreteOrderItem&gt; bundledItems = ((BundleOrderItem) oi).getDiscreteOrderItems();
 839                 for (DiscreteOrderItem doi : bundledItems) {
 840                     findAllChildrenToRemove(childrenToRemove, doi);
 841                 }
 842             } else {
 843                 findAllChildrenToRemove(childrenToRemove, oi);
 844             }
 845             for (Long childToRemove : childrenToRemove) {
 846                 removeItemInternal(orderId, childToRemove, false);
 847             }                    
 848 
 849             return removeItemInternal(orderId, orderItemId, priceOrder);
 850         } catch (WorkflowException e) {
<abbr title=" 851             throw new RemoveFromCartException(&quot;Could not remove from cart&quot;, getCartOperationExceptionRootCause(e));"> 851             throw new RemoveFromCartException(&quot;Could not remove from cart&quot;, getCartOperationExceptionRootðŸ”µ</abbr>
 852         }
 853     }
 854 
 855     protected void findAllChildrenToRemove(List&lt;Long&gt; childrenToRemove, OrderItem orderItem){
 856         if (CollectionUtils.isNotEmpty(orderItem.getChildOrderItems())) {
 857             for (OrderItem childOrderItem : orderItem.getChildOrderItems()) {
 858                 findAllChildrenToRemove(childrenToRemove, childOrderItem);
 859                 childrenToRemove.add(childOrderItem.getId());
 860             }
 861         }
 862     }
 863     
<abbr title=" 864     protected Order removeItemInternal(Long orderId, Long orderItemId, boolean priceOrder) throws WorkflowException {"> 864     protected Order removeItemInternal(Long orderId, Long orderItemId, boolean priceOrder) throws WorkfloðŸ”µ</abbr>
 865         OrderItemRequestDTO orderItemRequestDTO = new OrderItemRequestDTO();
 866         orderItemRequestDTO.setOrderItemId(orderItemId);
<abbr title=" 867         CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestDTO, priceOrder);"> 867         CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemReðŸ”µ</abbr>
 868         Session session = em.unwrap(Session.class);
 869         FlushMode current = session.getHibernateFlushMode();
 870         if (!autoFlushRemoveFromCart) {
<abbr title=" 871             //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 871             //Performance measure. Hibernate will sometimes perform an autoflush when performing query opðŸ”µ</abbr>
<abbr title=" 872             //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 872             //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in ðŸ”µ</abbr>
 873             //incorrect results because something has not been flushed to the database yet.
 874             session.setHibernateFlushMode(FlushMode.MANUAL);
 875         }
 876         ProcessContext&lt;CartOperationRequest&gt; context;
 877         try {
<abbr title=" 878             context = (ProcessContext&lt;CartOperationRequest&gt;) removeItemWorkflow.doActivities(cartOpRequest);"> 878             context = (ProcessContext&lt;CartOperationRequest&gt;) removeItemWorkflow.doActivities(cartOpRequesðŸ”µ</abbr>
 879         } finally {
 880             if (!autoFlushRemoveFromCart) {
 881                 session.setHibernateFlushMode(current);
 882             }
 883         }
<abbr title=" 884         context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getActivityMessages());"> 884         context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getActiviðŸ”µ</abbr>
 885         return context.getSeedData().getOrder();
 886     }
 887 
 888     @Override
 889     @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = { RemoveFromCartException.class })
 890     public Order removeInactiveItems(Long orderId, boolean priceOrder) throws RemoveFromCartException {
 891         Order order = findOrderById(orderId);
 892         try {
 893 
 894             for (OrderItem currentItem : new ArrayList&lt;OrderItem&gt;(order.getOrderItems())) {
 895                 if (!currentItem.isSkuActive()) {
 896                     removeItem(orderId, currentItem.getId(), priceOrder);
 897                 }
 898             }
 899 
 900         } catch (Exception e) {
 901             throw new RemoveFromCartException(&quot;Could not remove from cart&quot;, e.getCause());
 902         }
 903         return findOrderById(orderId);
 904     }
 905 
 906     @Override
 907     public boolean getAutomaticallyMergeLikeItems() {
 908         
 909         if (automaticallyMergeLikeItems != null) {
 910             return automaticallyMergeLikeItems;
 911         }
 912 
 913         return BLCSystemProperty.resolveBooleanSystemProperty(&quot;automatically.merge.like.items&quot;, true);
 914     }
 915 
 916     @Override
 917     public void setAutomaticallyMergeLikeItems(boolean automaticallyMergeLikeItems) {
 918         this.automaticallyMergeLikeItems = automaticallyMergeLikeItems;
 919     }
 920     
 921     @Override
<abbr title=" 922     @ManagedAttribute(description=&quot;The move item from named order when adding to the cart attribute&quot;, currencyTimeLimit=15)"> 922     @ManagedAttribute(description=&quot;The move item from named order when adding to the cart attribute&quot;, curðŸ”µ</abbr>
 923     public boolean isMoveNamedOrderItems() {
 924         return moveNamedOrderItems;
 925     }
 926 
 927     @Override
<abbr title=" 928     @ManagedAttribute(description=&quot;The move item from named order when adding to the cart attribute&quot;, currencyTimeLimit=15)"> 928     @ManagedAttribute(description=&quot;The move item from named order when adding to the cart attribute&quot;, curðŸ”µ</abbr>
 929     public void setMoveNamedOrderItems(boolean moveNamedOrderItems) {
 930         this.moveNamedOrderItems = moveNamedOrderItems;
 931     }
 932 
 933     @Override
<abbr title=" 934     @ManagedAttribute(description=&quot;The delete empty named order after adding items to cart attribute&quot;, currencyTimeLimit=15)"> 934     @ManagedAttribute(description=&quot;The delete empty named order after adding items to cart attribute&quot;, cuðŸ”µ</abbr>
 935     public boolean isDeleteEmptyNamedOrders() {
 936         return deleteEmptyNamedOrders;
 937     }
 938 
 939     @Override
 940     @Transactional(&quot;blTransactionManager&quot;)
 941     public void removeAllPaymentsFromOrder(Order order) {
 942         removePaymentsFromOrder(order, null);
 943     }
 944 
 945     @Override
 946     @Transactional(&quot;blTransactionManager&quot;)
 947     public void removePaymentsFromOrder(Order order, PaymentType paymentInfoType) {
 948         List&lt;OrderPayment&gt; infos = new ArrayList&lt;OrderPayment&gt;();
 949         for (OrderPayment paymentInfo : order.getPayments()) {
 950             if (paymentInfoType == null || paymentInfoType.equals(paymentInfo.getType())) {
 951                 infos.add(paymentInfo);
 952             }
 953         }
 954         order.getPayments().removeAll(infos);
 955         for (OrderPayment paymentInfo : infos) {
 956             try {
<abbr title=" 957                 securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentInfo.getReferenceNumber(), paymentInfo.getType());"> 957                 securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentInfo.getReferenceNumber(),ðŸ”µ</abbr>
 958             } catch (WorkflowException e) {
 959                 // do nothing--this is an acceptable condition
 960                 LOG.debug(&quot;No secure payment is associated with the OrderPayment&quot;, e);
 961             }
 962             order.getPayments().remove(paymentInfo);
 963             paymentInfo = paymentDao.readPaymentById(paymentInfo.getId());
 964             paymentDao.delete(paymentInfo);
 965         }
 966     }
 967 
 968     @Override
 969     @Transactional(&quot;blTransactionManager&quot;)
 970     public void removeCreditCardPaymentsFromOrder(Order order) {
 971         List&lt;OrderPayment&gt; infos = new ArrayList&lt;OrderPayment&gt;();
 972         for (OrderPayment paymentInfo : order.getPayments()) {
 973             if (paymentInfo.getType().isCreditCardType()) {
 974                 infos.add(paymentInfo);
 975             }
 976         }
 977         order.getPayments().removeAll(infos);
 978         for (OrderPayment paymentInfo : infos) {
 979             try {
<abbr title=" 980                 securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentInfo.getReferenceNumber(), paymentInfo.getType());"> 980                 securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentInfo.getReferenceNumber(),ðŸ”µ</abbr>
 981             } catch (WorkflowException e) {
 982                 // do nothing--this is an acceptable condition
 983                 LOG.debug(&quot;No secure payment is associated with the OrderPayment&quot;, e);
 984             }
 985             order.getPayments().remove(paymentInfo);
 986             paymentInfo = paymentDao.readPaymentById(paymentInfo.getId());
 987             paymentDao.delete(paymentInfo);
 988         }
 989     }
 990 
 991     @Override
 992     @Transactional(&quot;blTransactionManager&quot;)
 993     public void removePaymentFromOrder(Order order, OrderPayment payment){
 994         OrderPayment paymentToRemove = null;
 995         for (OrderPayment info : order.getPayments()){
 996             if (info.equals(payment)){
 997                 paymentToRemove = info;
 998             }
 999         }
1000         if (paymentToRemove != null){
1001             try {
<abbr title="1002                 securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentToRemove.getReferenceNumber(), payment.getType());">1002                 securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentToRemove.getReferenceNumbeðŸ”µ</abbr>
1003             } catch (WorkflowException e) {
1004                 // do nothing--this is an acceptable condition
1005                 LOG.debug(&quot;No secure payment is associated with the OrderPayment&quot;, e);
1006             }
1007             order.getPayments().remove(paymentToRemove);
1008             payment = paymentDao.readPaymentById(paymentToRemove.getId());
1009             paymentDao.delete(payment);
1010         }
1011     }
1012     
1013     /**
1014      * This method will return the exception that is immediately below the deepest 
1015      * WorkflowException in the current stack trace.
1016      * 
1017      * @param e the workflow exception that contains the requested root cause
1018      * @return the root cause of the workflow exception
1019      */
1020     protected Throwable getCartOperationExceptionRootCause(WorkflowException e) {
1021         Throwable cause = e.getCause();
1022         if (cause == null) {
1023             return e;
1024         }
1025         
1026         Throwable currentCause = cause;
1027         while (currentCause.getCause() != null) {
1028             currentCause = currentCause.getCause();
1029             if (currentCause instanceof WorkflowException) {
1030                 cause = currentCause.getCause();
1031             }
1032         }
1033         
1034         return cause;
1035     }
1036 
1037     /**
1038      * Returns true if the two items attributes exactly match.
1039      * @param item1Attributes
1040      * @param item2
1041      * @return
1042      */
<abbr title="1043     protected boolean compareAttributes(Map&lt;String, OrderItemAttribute&gt; item1Attributes, OrderItemRequestDTO item2) {">1043     protected boolean compareAttributes(Map&lt;String, OrderItemAttribute&gt; item1Attributes, OrderItemRequestðŸ”µ</abbr>
1044         int item1AttributeSize = item1Attributes == null ? 0 : item1Attributes.size();
<abbr title="1045         int item2AttributeSize = item2.getItemAttributes() == null ? 0 : item2.getItemAttributes().size();">1045         int item2AttributeSize = item2.getItemAttributes() == null ? 0 : item2.getItemAttributes().size()ðŸ”µ</abbr>
1046 
1047         if (item1AttributeSize != item2AttributeSize) {
1048             return false;
1049         }
1050 
1051         for (String key : item2.getItemAttributes().keySet()) {
<abbr title="1052             String itemOneValue = (item1Attributes.get(key) == null) ? null : item1Attributes.get(key).getValue();">1052             String itemOneValue = (item1Attributes.get(key) == null) ? null : item1Attributes.get(key).geðŸ”µ</abbr>
1053             String itemTwoValue = item2.getItemAttributes().get(key);
1054             if (!itemTwoValue.equals(itemOneValue)) {
1055                 return false;
1056             }
1057         }
1058         return true;
1059     }
1060 
<abbr title="1061     protected boolean itemMatches(Sku item1Sku, Product item1Product, Map&lt;String, OrderItemAttribute&gt; item1Attributes,">1061     protected boolean itemMatches(Sku item1Sku, Product item1Product, Map&lt;String, OrderItemAttribute&gt; iteðŸ”µ</abbr>
1062             OrderItemRequestDTO item2) {
1063         // Must match on SKU and options
1064         if (item1Sku != null &amp;&amp; item2.getSkuId() != null) {
1065             if (item1Sku.getId().equals(item2.getSkuId())) {
1066                 return true;
1067             }
1068         } else {
1069             if (item1Product != null &amp;&amp; item2.getProductId() != null) {
1070                 if (item1Product.getId().equals(item2.getProductId())) {
1071                     return compareAttributes(item1Attributes, item2);
1072                 }
1073             }
1074         }
1075         return false;
1076     }
1077 
1078     protected OrderItem findMatchingItem(Order order, OrderItemRequestDTO itemToFind) {
1079         if (order == null) {
1080             return null;
1081         }
1082         for (OrderItem currentItem : order.getOrderItems()) {
1083             if (currentItem instanceof DiscreteOrderItem) {
1084                 DiscreteOrderItem discreteItem = (DiscreteOrderItem) currentItem;
<abbr title="1085                 if (itemMatches(discreteItem.getSku(), discreteItem.getProduct(), discreteItem.getOrderItemAttributes(),">1085                 if (itemMatches(discreteItem.getSku(), discreteItem.getProduct(), discreteItem.getOrderItðŸ”µ</abbr>
1086                         itemToFind)) {
1087                     return discreteItem;
1088                 }
1089             } else if (currentItem instanceof BundleOrderItem) {
1090                 BundleOrderItem bundleItem = (BundleOrderItem) currentItem;
1091                 if (itemMatches(bundleItem.getSku(), bundleItem.getProduct(), null, itemToFind)) {
1092                     return bundleItem;
1093                 }
1094             }
1095         }
1096         return null;
1097     }
1098 
1099     @Override
1100     @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = { UpdateCartException.class })
<abbr title="1101     public Order updateProductOptionsForItem(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throws UpdateCartException {">1101     public Order updateProductOptionsForItem(Long orderId, OrderItemRequestDTO orderItemRequestDTO, booleðŸ”µ</abbr>
1102         try {
<abbr title="1103             CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestDTO, priceOrder);">1103             CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItðŸ”µ</abbr>
<abbr title="1104             ProcessContext&lt;CartOperationRequest&gt; context = (ProcessContext&lt;CartOperationRequest&gt;) updateProductOptionsForItemWorkflow.doActivities(cartOpRequest);">1104             ProcessContext&lt;CartOperationRequest&gt; context = (ProcessContext&lt;CartOperationRequest&gt;) updatePðŸ”µ</abbr>
<abbr title="1105             context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getActivityMessages());">1105             context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getAcðŸ”µ</abbr>
1106             return context.getSeedData().getOrder();
1107         } catch (WorkflowException e) {
<abbr title="1108             throw new UpdateCartException(&quot;Could not product options&quot;, getCartOperationExceptionRootCause(e));">1108             throw new UpdateCartException(&quot;Could not product options&quot;, getCartOperationExceptionRootCauseðŸ”µ</abbr>
1109         }
1110     }
1111 
1112     @Override
1113     public Order reloadOrder(Order order) {
1114         if (order == null || order instanceof NullOrderImpl || order.getId() == null) {
1115             return order;
1116         }
1117 
1118         return orderDao.readOrderById(order.getId(), true);
1119     }
1120 
1121     @Override
1122     @Transactional(&quot;blTransactionManager&quot;)
1123     public boolean acquireLock(Order order) {
1124         return orderDao.acquireLock(order);
1125     }
1126 
1127     @Override
1128     public boolean releaseLock(Order order) {
1129         return orderDao.releaseLock(order);
1130     }
1131 
1132     @Override
1133     public void printOrder(Order order, Log log) {
1134         if (!log.isDebugEnabled()) {
1135             return;
1136         }
1137         
1138         TableCreator tc = new TableCreator(new TableCreator.Col[] {
1139             new TableCreator.Col(&quot;Order Item&quot;, 30),
1140             new TableCreator.Col(&quot;Qty&quot;),
1141             new TableCreator.Col(&quot;Unit Price&quot;),
1142             new TableCreator.Col(&quot;Avg Adj&quot;),
1143             new TableCreator.Col(&quot;Total Adj&quot;),
1144             new TableCreator.Col(&quot;Total Price&quot;)
1145         });
1146 
1147         for (OrderItem oi : order.getOrderItems()) {
1148             tc.addRow(new String[] {
1149                 oi.getName(),
1150                 String.valueOf(oi.getQuantity()),
1151                 String.valueOf(oi.getPriceBeforeAdjustments(true)),
1152                 String.valueOf(oi.getAverageAdjustmentValue()),
1153                 String.valueOf(oi.getTotalAdjustmentValue()),
1154                 String.valueOf(oi.getTotalPrice())
1155             });
1156         }
1157         
1158         tc.addSeparator()
1159             .withGlobalRowHeaderWidth(15)
1160             .addRow(&quot;Subtotal&quot;, order.getSubTotal())
1161             .addRow(&quot;Order Adj.&quot;, order.getOrderAdjustmentsValue())
1162             .addRow(&quot;Tax&quot;, order.getTotalTax())
1163             .addRow(&quot;Shipping&quot;, order.getTotalShipping())
1164             .addRow(&quot;Total&quot;, order.getTotal())
1165             .addSeparator();
1166         
1167         log.debug(tc.toString());
1168     }
1169     
1170     @Override
1171     public void preValidateCartOperation(Order cart) {
1172         ExtensionResultHolder erh = new ExtensionResultHolder();
1173         extensionManager.getProxy().preValidateCartOperation(cart, erh);
1174         if (erh.getThrowable() instanceof IllegalCartOperationException) {
1175             throw ((IllegalCartOperationException) erh.getThrowable());
1176         } else if (erh.getThrowable() != null) {
1177             throw new RuntimeException(erh.getThrowable());
1178         }
1179     }
1180 
1181     @Override
1182     public void preValidateUpdateQuantityOperation(Order cart, OrderItemRequestDTO dto) {
1183         ExtensionResultHolder erh = new ExtensionResultHolder();
1184         extensionManager.getProxy().preValidateUpdateQuantityOperation(cart, dto, erh);
1185         if (erh.getThrowable() instanceof IllegalCartOperationException) {
1186             throw ((IllegalCartOperationException) erh.getThrowable());
1187         } else if (erh.getThrowable() != null) {
1188             throw new RuntimeException(erh.getThrowable());
1189         }
1190     }
1191 
1192     @Override
1193     public void refresh(Order order) {
1194         orderDao.refresh(order);
1195     }
1196 
1197     @Override
1198     public Order findCartForCustomerWithEnhancements(Customer customer) {
1199         ExtensionResultHolder&lt;Order&gt; erh = new ExtensionResultHolder&lt;Order&gt;();
<abbr title="1200         ExtensionResultStatusType resultStatusType = extensionManager.findCartForCustomerWithEnhancements(customer, erh);">1200         ExtensionResultStatusType resultStatusType = extensionManager.findCartForCustomerWithEnhancementsðŸ”µ</abbr>
1201         if (ExtensionResultStatusType.NOT_HANDLED != resultStatusType) {
1202             return erh.getResult();
1203         }
1204         return findCartForCustomer(customer);
1205     }
1206 
1207     @Override
1208     public Order findCartForCustomerWithEnhancements(Customer customer, Order candidateOrder) {
1209         ExtensionResultHolder&lt;Order&gt; erh = new ExtensionResultHolder&lt;Order&gt;();
<abbr title="1210         ExtensionResultStatusType resultStatusType = extensionManager.findCartForCustomerWithEnhancements(customer, candidateOrder, erh);">1210         ExtensionResultStatusType resultStatusType = extensionManager.findCartForCustomerWithEnhancementsðŸ”µ</abbr>
1211         if (ExtensionResultStatusType.NOT_HANDLED != resultStatusType) {
1212             return erh.getResult();
1213         }
1214         return candidateOrder;
1215     }
1216 
1217     @Override
1218     public List&lt;Order&gt; findOrdersByEmail(String email) {
1219         return orderDao.readOrdersByEmail(email);
1220     }
1221     
1222     @Override
1223     public List&lt;Order&gt; readBatchOrders(int start, int pageSize, List&lt;OrderStatus&gt; orderStatusList) {
1224         return orderDao.readBatchOrders(start, pageSize, orderStatusList);
1225     }
1226 
1227     @Override
1228 	public Long readNumberOfOrders() {
1229     		return orderDao.readNumberOfOrders();
1230     }
1231 }</pre></td>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Framework
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.core.order.service;
  19 
  20 import org.apache.commons.collections.CollectionUtils;
  21 import org.apache.commons.logging.Log;
  22 import org.apache.commons.logging.LogFactory;
  23 import org.broadleafcommerce.common.extension.ExtensionResultHolder;
  24 import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  25 import org.broadleafcommerce.common.payment.PaymentType;
  26 import org.broadleafcommerce.common.util.BLCSystemProperty;
  27 import org.broadleafcommerce.common.util.TableCreator;
  28 import org.broadleafcommerce.common.util.TransactionUtils;
  29 import org.broadleafcommerce.common.util.TypedPredicate;
  30 import org.broadleafcommerce.common.web.BroadleafRequestContext;
  31 import org.broadleafcommerce.core.catalog.domain.Product;
  32 import org.broadleafcommerce.core.catalog.domain.Sku;
  33 import org.broadleafcommerce.core.offer.dao.OfferDao;
  34 import org.broadleafcommerce.core.offer.domain.Offer;
  35 import org.broadleafcommerce.core.offer.domain.OfferCode;
  36 import org.broadleafcommerce.core.offer.service.OfferService;
  37 import org.broadleafcommerce.core.offer.service.OfferServiceExtensionManager;
  38 import org.broadleafcommerce.core.offer.service.exception.OfferAlreadyAddedException;
  39 import org.broadleafcommerce.core.offer.service.exception.OfferException;
  40 import org.broadleafcommerce.core.offer.service.exception.OfferExpiredException;
  41 import org.broadleafcommerce.core.offer.service.exception.OfferMaxUseExceededException;
  42 import org.broadleafcommerce.core.order.dao.OrderDao;
  43 import org.broadleafcommerce.core.order.domain.BundleOrderItem;
  44 import org.broadleafcommerce.core.order.domain.DiscreteOrderItem;
  45 import org.broadleafcommerce.core.order.domain.GiftWrapOrderItem;
  46 import org.broadleafcommerce.core.order.domain.NullOrderFactory;
  47 import org.broadleafcommerce.core.order.domain.NullOrderImpl;
  48 import org.broadleafcommerce.core.order.domain.Order;
  49 import org.broadleafcommerce.core.order.domain.OrderItem;
  50 import org.broadleafcommerce.core.order.domain.OrderItemAttribute;
  51 import org.broadleafcommerce.core.order.service.call.ActivityMessageDTO;
  52 import org.broadleafcommerce.core.order.service.call.GiftWrapOrderItemRequest;
  53 import org.broadleafcommerce.core.order.service.call.OrderItemRequestDTO;
  54 import org.broadleafcommerce.core.order.service.exception.AddToCartException;
  55 import org.broadleafcommerce.core.order.service.exception.IllegalCartOperationException;
  56 import org.broadleafcommerce.core.order.service.exception.ItemNotFoundException;
  57 import org.broadleafcommerce.core.order.service.exception.RemoveFromCartException;
  58 import org.broadleafcommerce.core.order.service.exception.UpdateCartException;
  59 import org.broadleafcommerce.core.order.service.type.OrderStatus;
  60 import org.broadleafcommerce.core.order.service.workflow.CartOperationRequest;
  61 import org.broadleafcommerce.core.payment.dao.OrderPaymentDao;
  62 import org.broadleafcommerce.core.payment.domain.OrderPayment;
  63 import org.broadleafcommerce.core.payment.domain.secure.Referenced;
  64 import org.broadleafcommerce.core.payment.service.SecureOrderPaymentService;
  65 import org.broadleafcommerce.core.pricing.service.PricingService;
  66 import org.broadleafcommerce.core.pricing.service.exception.PricingException;
  67 import org.broadleafcommerce.core.workflow.ActivityMessages;
  68 import org.broadleafcommerce.core.workflow.ProcessContext;
  69 import org.broadleafcommerce.core.workflow.Processor;
  70 import org.broadleafcommerce.core.workflow.WorkflowException;
  71 import org.broadleafcommerce.profile.core.domain.Customer;
  72 import org.broadleafcommerce.profile.core.service.CustomerService;
  73 import org.hibernate.FlushMode;
  74 import org.hibernate.Session;
  75 import org.hibernate.exception.LockAcquisitionException;
  76 import org.springframework.beans.factory.annotation.Value;
  77 import org.springframework.jmx.export.annotation.ManagedAttribute;
  78 import org.springframework.jmx.export.annotation.ManagedResource;
  79 import org.springframework.stereotype.Service;
  80 import org.springframework.transaction.PlatformTransactionManager;
  81 import org.springframework.transaction.TransactionDefinition;
  82 import org.springframework.transaction.TransactionStatus;
  83 import org.springframework.transaction.annotation.Transactional;
  84 
  85 import java.math.BigDecimal;
  86 import java.util.ArrayList;
  87 import java.util.Collections;
  88 import java.util.Comparator;
  89 import java.util.Date;
  90 import java.util.List;
  91 import java.util.Map;
  92 import java.util.Objects;
  93 import java.util.Set;
  94 
  95 import javax.annotation.Resource;
  96 import javax.persistence.EntityManager;
  97 import javax.persistence.PersistenceContext;
  98 
  99 /**
 100  * @author apazzolini
 101  */
 102 @Service(&quot;blOrderService&quot;)
<abbr title=" 103 @ManagedResource(objectName=&quot;org.broadleafcommerce:name=OrderService&quot;, description=&quot;Order Service&quot;, currencyTimeLimit=15)"> 103 @ManagedResource(objectName=&quot;org.broadleafcommerce:name=OrderService&quot;, description=&quot;Order Service&quot;, curreðŸ”µ</abbr>
 104 public class OrderServiceImpl implements OrderService {
 105     private static final Log LOG = LogFactory.getLog(OrderServiceImpl.class);
 106 
 107     /* DAOs */
 108     @Resource(name = &quot;blOrderPaymentDao&quot;)
 109     protected OrderPaymentDao paymentDao;
 110 
 111     @Resource(name = &quot;blOrderDao&quot;)
 112     protected OrderDao orderDao;
 113 
 114     @Resource(name = &quot;blOfferDao&quot;)
 115     protected OfferDao offerDao;
 116 
 117     /* Factories */
 118     @Resource(name = &quot;blNullOrderFactory&quot;)
 119     protected NullOrderFactory nullOrderFactory;
 120 
 121     /* Services */
 122     @Resource(name = &quot;blCustomerService&quot;)
 123     protected CustomerService customerService;
 124 
 125     @Resource(name = &quot;blPricingService&quot;)
 126     protected PricingService pricingService;
 127 
 128     @Resource(name = &quot;blOrderItemService&quot;)
 129     protected OrderItemService orderItemService;
 130 
 131     @Resource(name = &quot;blFulfillmentGroupService&quot;)
 132     protected FulfillmentGroupService fulfillmentGroupService;
 133 
 134     @Resource(name = &quot;blOfferService&quot;)
 135     protected OfferService offerService;
 136 
 137     @Resource(name = &quot;blSecureOrderPaymentService&quot;)
 138     protected SecureOrderPaymentService securePaymentInfoService;
 139 
 140     @Resource(name = &quot;blMergeCartService&quot;)
 141     protected MergeCartService mergeCartService;
 142 
 143     @Resource(name = &quot;blOrderServiceExtensionManager&quot;)
 144     protected OrderServiceExtensionManager extensionManager;
 145 
 146     /* Workflows */
 147     @Resource(name = &quot;blAddItemWorkflow&quot;)
 148     protected Processor addItemWorkflow;
 149 
 150     @Resource(name = &quot;blUpdateProductOptionsForItemWorkflow&quot;)
 151     private Processor updateProductOptionsForItemWorkflow;
 152 
 153     @Resource(name = &quot;blUpdateItemWorkflow&quot;)
 154     protected Processor updateItemWorkflow;
 155 
 156     @Resource(name = &quot;blRemoveItemWorkflow&quot;)
 157     protected Processor removeItemWorkflow;
 158 
 159     @Resource(name = &quot;blTransactionManager&quot;)
 160     protected PlatformTransactionManager transactionManager;
 161 
 162     @Value(&quot;${pricing.retry.count.for.lock.failure}&quot;)
 163     protected int pricingRetryCountForLockFailure = 3;
 164 
 165     @Value(&quot;${pricing.retry.wait.interval.for.lock.failure}&quot;)
 166     protected long pricingRetryWaitIntervalForLockFailure = 500L;
 167 
 168     /**
 169      * Advanced setting. Should Hibernate auto flush before queries during an
<abbr title=" 170      * add-to-cart workflow. This should generally be able to be left false. This is a performance measure and"> 170      * add-to-cart workflow. This should generally be able to be left false. This is a performance measurðŸ”µ</abbr>
 171      * add-to-cart operations will be more efficient when this is false.
 172      */
 173     @Value(&quot;${auto.flush.on.query.during.add.to.cart:false}&quot;)
 174     protected boolean autoFlushAddToCart = false;
 175 
 176     /**
 177      * Advanced setting. Should Hibernate auto flush before queries during an
<abbr title=" 178      * update-cart workflow. This should generally be able to be left false. This is a performance measure and"> 178      * update-cart workflow. This should generally be able to be left false. This is a performance measurðŸ”µ</abbr>
 179      * update-cart operations will be more efficient when this is false.
 180      */
 181     @Value(&quot;${auto.flush.on.query.during.update.cart:false}&quot;)
 182     protected boolean autoFlushUpdateCart = false;
 183 
 184     /**
 185      * Advanced setting. Should Hibernate auto flush before queries during an
<abbr title=" 186      * remove-from-cart workflow. This should generally be able to be left false. This is a performance measure and"> 186      * remove-from-cart workflow. This should generally be able to be left false. This is a performance mðŸ”µ</abbr>
 187      * remove-from-cart operations will be more efficient when this is false.
 188      */
 189     @Value(&quot;${auto.flush.on.query.during.remove.from.cart:false}&quot;)
 190     protected boolean autoFlushRemoveFromCart = false;
 191 
 192     /**
 193      * Advanced setting. Should Hibernate auto flush before queries during an
<abbr title=" 194      * order save pricing flow. This should generally be able to be left false. This is a performance measure and"> 194      * order save pricing flow. This should generally be able to be left false. This is a performance meaðŸ”µ</abbr>
 195      * save operations will be more efficient when this is false.
 196      */
 197     @Value(&quot;${auto.flush.on.query.during.cart.pricing.save:false}&quot;)
 198     protected boolean autoFlushSaveCart = false;
 199 
 200     @PersistenceContext(unitName=&quot;blPU&quot;)
 201     protected EntityManager em;
 202 
 203     /* Fields */
 204     protected boolean moveNamedOrderItems = true;
 205     protected boolean deleteEmptyNamedOrders = true;
 206 
 207     protected Boolean automaticallyMergeLikeItems;
 208 
 209     @Resource(name = &quot;blOrderMultishipOptionService&quot;)
 210     protected OrderMultishipOptionService orderMultishipOptionService;
 211 
 212     @Resource(name = &quot;blOfferServiceExtensionManager&quot;)
 213     protected OfferServiceExtensionManager offerServiceExtensionManager;
 214 
 215 
 216     @Override
 217     @Transactional(&quot;blTransactionManager&quot;)
 218     public Order createNewCartForCustomer(Customer customer) {
 219 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 220         customer = customerService.saveCustomer(customer);</span>
 221 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 222         return orderDao.createNewCartForCustomer(customer);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 223     }</span>
 224 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 225         final Object lock = Objects.isNull(customer.getId()) ? customer : customer.getId();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 226         synchronized (lock) {</span>
 227 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 228         return orderDao.createNewCartForCustomer(customer);
 229     }
 230     }
 231 
 232     @Override
 233     @Transactional(&quot;blTransactionManager&quot;)
 234     public Order createNamedOrderForCustomer(String name, Customer customer) {
 235         Order namedOrder = orderDao.create();
 236         namedOrder.setCustomer(customer);
 237         namedOrder.setName(name);
 238         namedOrder.setStatus(OrderStatus.NAMED);
 239 
 240         if (extensionManager != null) {
 241             extensionManager.getProxy().attachAdditionalDataToNewNamedCart(customer, namedOrder);
 242         }
 243 
 244         if (BroadleafRequestContext.getBroadleafRequestContext() != null) {
 245             namedOrder.setLocale(BroadleafRequestContext.getBroadleafRequestContext().getLocale());
 246         }
 247 
 248         return persist(namedOrder); // No need to price here
 249     }
 250 
 251     @Override
 252     public Order findNamedOrderForCustomer(String name, Customer customer) {
 253         return orderDao.readNamedOrderForCustomer(customer, name);
 254     }
 255 
 256     @Override
 257     public Order findOrderById(Long orderId) {
 258         return orderDao.readOrderById(orderId);
 259     }
 260 
 261     @Override
 262     public List&lt;Order&gt; findOrdersByIds(List&lt;Long&gt; orderIds) {
 263         return orderDao.readOrdersByIds(orderIds);
 264     }
 265 
 266     @Override
 267     public Order findOrderById(Long orderId, boolean refresh) {
 268         return orderDao.readOrderById(orderId, refresh);
 269     }
 270 
 271     @Override
 272     public Order getNullOrder() {
 273         return nullOrderFactory.getNullOrder();
 274     }
 275 
 276     @Override
 277     public Order findCartForCustomer(Customer customer) {
 278         return orderDao.readCartForCustomer(customer);
 279     }
 280 
 281     @Override
 282     public List&lt;Order&gt; findOrdersForCustomer(Customer customer) {
 283         return orderDao.readOrdersForCustomer(customer.getId());
 284     }
 285 
 286     @Override
 287     public List&lt;Order&gt; findOrdersForCustomer(Customer customer, OrderStatus status) {
 288         return orderDao.readOrdersForCustomer(customer, status);
 289     }
 290 
 291     @Override
 292     public Order findOrderByOrderNumber(String orderNumber) {
 293         return orderDao.readOrderByOrderNumber(orderNumber);
 294     }
 295 
 296     @Override
 297     public List&lt;Order&gt; findOrdersByDateRange(Date startDate, Date endDate) {
 298         return orderDao.readOrdersByDateRange(startDate, endDate);
 299     }
 300 
 301     @Override
 302     public List&lt;Order&gt; findOrdersByDaysCount(Integer daysCount, Integer batchSize) {
 303         return orderDao.readOrdersOlderThanDaysCount(daysCount, batchSize);
 304     }
 305 
 306     @Override
<abbr title=" 307     public List&lt;Order&gt; findOrdersForCustomersInDateRange(List&lt;Long&gt; customerIds, Date startDate, Date endDate) {"> 307     public List&lt;Order&gt; findOrdersForCustomersInDateRange(List&lt;Long&gt; customerIds, Date startDate, Date endðŸ”µ</abbr>
 308         return orderDao.readOrdersForCustomersInDateRange(customerIds, startDate, endDate);
 309     }
 310 
 311     @Override
 312     public List&lt;OrderPayment&gt; findPaymentsForOrder(Order order) {
 313         return paymentDao.readPaymentsForOrder(order);
 314     }
 315 
 316     @Override
 317     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 318     public OrderPayment addPaymentToOrder(Order order, OrderPayment payment, Referenced securePaymentInfo) {"> 318     public OrderPayment addPaymentToOrder(Order order, OrderPayment payment, Referenced securePaymentInfoðŸ”µ</abbr>
 319         payment.setOrder(order);
 320         order.getPayments().add(payment);
 321         order = persist(order);
 322         int paymentIndex = order.getPayments().size() - 1;
 323 
 324         if (securePaymentInfo != null) {
 325             securePaymentInfoService.save(securePaymentInfo);
 326         }
 327 
 328         return order.getPayments().get(paymentIndex);
 329     }
 330 
 331     @Override
 332     public Order save(Order order, boolean priceOrder, boolean repriceItems) throws PricingException {
 333         if (repriceItems) {
 334             order.updatePrices();
 335         }
 336         return save(order, priceOrder);
 337     }
 338 
 339     @Override
 340     public Order save(Order order, Boolean priceOrder) throws PricingException {
 341         //persist the order first
 342         TransactionStatus status = TransactionUtils.createTransaction(&quot;saveOrder&quot;,
 343                     TransactionDefinition.PROPAGATION_REQUIRED, transactionManager);
 344         try {
 345             order = persist(order);
 346             TransactionUtils.finalizeTransaction(status, transactionManager, false);
 347         } catch (RuntimeException ex) {
 348             TransactionUtils.finalizeTransaction(status, transactionManager, true);
 349             throw ex;
 350         }
 351 
 352         //make any pricing changes - possibly retrying with the persisted state if there&#x27;s a lock failure
 353         if (priceOrder) {
 354             int retryCount = 0;
 355             boolean isValid = false;
 356             while (!isValid) {
 357                 Session session = em.unwrap(Session.class);
 358                 FlushMode current = session.getHibernateFlushMode();
 359                 try {
 360                     if (!autoFlushSaveCart) {
<abbr title=" 361                         //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 361                         //Performance measure. Hibernate will sometimes perform an autoflush when performðŸ”µ</abbr>
<abbr title=" 362                         //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 362                         //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern aboutðŸ”µ</abbr>
 363                         //incorrect results because something has not been flushed to the database yet.
 364                         session.setHibernateFlushMode(FlushMode.MANUAL);
 365                     }
 366                     order = pricingService.executePricing(order);
 367                     isValid = true;
 368                 } catch (Exception ex) {
 369                     boolean isValidCause = false;
 370                     Throwable cause = ex;
 371                     while (!isValidCause) {
 372                         if (cause.getClass().equals(LockAcquisitionException.class)) {
 373                             isValidCause = true;
 374                         }
 375                         cause = cause.getCause();
 376                         if (cause == null) {
 377                             break;
 378                         }
 379                     }
 380                     if (isValidCause) {
 381                         if (LOG.isInfoEnabled()) {
<abbr title=" 382                             LOG.info(&quot;Problem acquiring lock during pricing call - attempting to price again.&quot;);"> 382                             LOG.info(&quot;Problem acquiring lock during pricing call - attempting to price agðŸ”µ</abbr>
 383                         }
 384                         isValid = false;
 385                         if (retryCount &gt;= pricingRetryCountForLockFailure) {
 386                             if (LOG.isInfoEnabled()) {
<abbr title=" 387                                 LOG.info(&quot;Problem acquiring lock during pricing call. Retry limit exceeded at (&quot; + retryCount + &quot;). Throwing exception.&quot;);"> 387                                 LOG.info(&quot;Problem acquiring lock during pricing call. Retry limit exceedeðŸ”µ</abbr>
 388                             }
 389                             if (ex instanceof PricingException) {
 390                                 throw (PricingException) ex;
 391                             } else {
 392                                 throw new PricingException(ex);
 393                             }
 394                         } else {
 395                             order = findOrderById(order.getId());
 396                             retryCount++;
 397                         }
 398                         try {
 399                             Thread.sleep(pricingRetryWaitIntervalForLockFailure);
 400                         } catch (Throwable e) {
 401                             //do nothing
 402                         }
 403                     } else {
 404                         if (ex instanceof PricingException) {
 405                             throw (PricingException) ex;
 406                         } else {
 407                             throw new PricingException(ex);
 408                         }
 409                     }
 410                 } finally {
 411                     if (!autoFlushSaveCart) {
 412                         session.setHibernateFlushMode(current);
 413                     }
 414                 }
 415             }
 416 
 417             //make the final save of the priced order
 418             status = TransactionUtils.createTransaction(&quot;saveOrder&quot;,
 419                                 TransactionDefinition.PROPAGATION_REQUIRED, transactionManager);
 420             Session session = em.unwrap(Session.class);
 421             FlushMode current = session.getHibernateFlushMode();
 422             try {
 423                 if (!autoFlushSaveCart) {
<abbr title=" 424                     //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 424                     //Performance measure. Hibernate will sometimes perform an autoflush when performing ðŸ”µ</abbr>
<abbr title=" 425                     //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 425                     //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queðŸ”µ</abbr>
 426                     //incorrect results because something has not been flushed to the database yet.
 427                     session.setHibernateFlushMode(FlushMode.MANUAL);
 428                 }
 429                 order = persist(order);
 430 
 431                 if (extensionManager != null) {
 432                     extensionManager.getProxy().attachAdditionalDataToOrder(order, priceOrder);
 433                 }
 434                 if (!autoFlushSaveCart) {
 435                     session.setFlushMode(current);
 436                 }
 437                 TransactionUtils.finalizeTransaction(status, transactionManager, false);
 438             } catch (RuntimeException ex) {
 439                 TransactionUtils.finalizeTransaction(status, transactionManager, true);
 440                 throw ex;
 441             } finally {
 442                 if (!autoFlushSaveCart &amp;&amp; !session.getFlushMode().equals(current)) {
 443                     session.setHibernateFlushMode(current);
 444                 }
 445             }
 446         }
 447 
 448         return order;
 449     }
 450 
 451     // This method exists to provide OrderService methods the ability to save an order
 452     // without having to worry about a PricingException being thrown.
 453     protected Order persist(Order order) {
 454         return orderDao.save(order);
 455     }
 456 
 457     @Override
 458     @Transactional(&quot;blTransactionManager&quot;)
 459     public void cancelOrder(Order order) {
 460         orderDao.delete(order);
 461     }
 462 
 463     @Override
 464     @Transactional(&quot;blTransactionManager&quot;)
 465     public void deleteOrder(Order order) {
 466         orderMultishipOptionService.deleteAllOrderMultishipOptions(order);
 467         orderDao.delete(order);
 468     }
 469 
 470     @Override
 471     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 472     public Order addOfferCode(Order order, OfferCode offerCode, boolean priceOrder) throws PricingException, OfferException {"> 472     public Order addOfferCode(Order order, OfferCode offerCode, boolean priceOrder) throws PricingExceptiðŸ”µ</abbr>
 473         ArrayList&lt;OfferCode&gt; offerCodes = new ArrayList&lt;OfferCode&gt;();
 474         offerCodes.add(offerCode);
 475         return addOfferCodes(order, offerCodes, priceOrder);
 476     }
 477 
 478     @Override
 479     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 480     public Order addOfferCodes(Order order, List&lt;OfferCode&gt; offerCodes, boolean priceOrder) throws PricingException, OfferException {"> 480     public Order addOfferCodes(Order order, List&lt;OfferCode&gt; offerCodes, boolean priceOrder) throws PricinðŸ”µ</abbr>
 481         preValidateCartOperation(order);
 482         Set&lt;Offer&gt; addedOffers = offerService.getUniqueOffersFromOrder(order);
 483         if (extensionManager != null) {
 484             extensionManager.getProxy().addOfferCodes(order, offerCodes, priceOrder);
 485         }
 486         if (offerCodes != null &amp;&amp; !offerCodes.isEmpty()) {
 487             for (OfferCode offerCode : offerCodes) {
 488 
<abbr title=" 489                 if (order.getAddedOfferCodes().contains(offerCode) || addedOffers.contains(offerCode.getOffer())) {"> 489                 if (order.getAddedOfferCodes().contains(offerCode) || addedOffers.contains(offerCode.getOðŸ”µ</abbr>
 490                     throw new OfferAlreadyAddedException(&quot;The offer has already been added.&quot;);
 491                 } else if (!offerService.verifyMaxCustomerUsageThreshold(order, offerCode)) {
<abbr title=" 492                     throw new OfferMaxUseExceededException(&quot;The customer has used this offer code more than the maximum allowed number of times.&quot;);"> 492                     throw new OfferMaxUseExceededException(&quot;The customer has used this offer code more thðŸ”µ</abbr>
 493                 } else if (!offerCode.isActive() || !offerCode.getOffer().isActive()) {
 494                     throw new OfferExpiredException(&quot;The offer has expired.&quot;);
 495                 }
 496 
 497                 order.getAddedOfferCodes().add(offerCode);
 498 
 499             }
 500             order = save(order, priceOrder);
 501         }
 502 
 503         return order;
 504     }
 505 
 506     @Override
 507     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 508     public Order removeOfferCode(Order order, OfferCode offerCode, boolean priceOrder) throws PricingException {"> 508     public Order removeOfferCode(Order order, OfferCode offerCode, boolean priceOrder) throws PricingExceðŸ”µ</abbr>
 509         order.getAddedOfferCodes().remove(offerCode);
 510         offerServiceExtensionManager.removeOfferCodeFromOrder(offerCode, order);
 511         order = save(order, priceOrder);
 512         return order;
 513     }
 514 
 515     @Override
 516     @Transactional(&quot;blTransactionManager&quot;)
 517     public Order removeAllOfferCodes(Order order, boolean priceOrder) throws PricingException {
 518          order.getAddedOfferCodes().clear();
 519          order = save(order, priceOrder);
 520          return order;
 521     }
 522 
 523     @Override
<abbr title=" 524     @ManagedAttribute(description=&quot;The delete empty named order after adding items to cart attribute&quot;, currencyTimeLimit=15)"> 524     @ManagedAttribute(description=&quot;The delete empty named order after adding items to cart attribute&quot;, cuðŸ”µ</abbr>
 525     public void setDeleteEmptyNamedOrders(boolean deleteEmptyNamedOrders) {
 526         this.deleteEmptyNamedOrders = deleteEmptyNamedOrders;
 527     }
 528 
 529     @Override
 530     public OrderItem findLastMatchingItem(Order order, Long skuId, Long productId) {
 531         if (order.getOrderItems() != null) {
 532             for (int i=(order.getOrderItems().size()-1); i &gt;= 0; i--) {
 533                 OrderItem currentItem = (order.getOrderItems().get(i));
 534                 if (currentItem instanceof DiscreteOrderItem) {
 535                     DiscreteOrderItem discreteItem = (DiscreteOrderItem) currentItem;
 536                     if (skuId != null) {
<abbr title=" 537                         if (discreteItem.getSku() != null &amp;&amp; skuId.equals(discreteItem.getSku().getId())) {"> 537                         if (discreteItem.getSku() != null &amp;&amp; skuId.equals(discreteItem.getSku().getId()))ðŸ”µ</abbr>
 538                             return discreteItem;
 539                         }
<abbr title=" 540                     } else if (productId != null &amp;&amp; discreteItem.getProduct() != null &amp;&amp; productId.equals(discreteItem.getProduct().getId())) {"> 540                     } else if (productId != null &amp;&amp; discreteItem.getProduct() != null &amp;&amp; productId.equalsðŸ”µ</abbr>
 541                         return discreteItem;
 542                     }
 543 
 544                 } else if (currentItem instanceof BundleOrderItem) {
 545                     BundleOrderItem bundleItem = (BundleOrderItem) currentItem;
 546                     if (skuId != null) {
 547                         if (bundleItem.getSku() != null &amp;&amp; skuId.equals(bundleItem.getSku().getId())) {
 548                             return bundleItem;
 549                         }
<abbr title=" 550                     } else if (productId != null &amp;&amp; bundleItem.getProduct() != null &amp;&amp; productId.equals(bundleItem.getProduct().getId())) {"> 550                     } else if (productId != null &amp;&amp; bundleItem.getProduct() != null &amp;&amp; productId.equals(bðŸ”µ</abbr>
 551                         return bundleItem;
 552                     }
 553                 }
 554             }
 555         }
 556         return null;
 557     }
 558 
 559     @Override
 560     @Transactional(&quot;blTransactionManager&quot;)
 561     public Order confirmOrder(Order order) {
 562         return orderDao.submitOrder(order);
 563     }
 564 
 565     @Override
 566     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 567     public Order addAllItemsFromNamedOrder(Order namedOrder, boolean priceOrder) throws RemoveFromCartException, AddToCartException {"> 567     public Order addAllItemsFromNamedOrder(Order namedOrder, boolean priceOrder) throws RemoveFromCartExcðŸ”µ</abbr>
 568         Order cartOrder = orderDao.readCartForCustomer(namedOrder.getCustomer());
 569         if (cartOrder == null) {
 570             cartOrder = createNewCartForCustomer(namedOrder.getCustomer());
 571         }
 572         List&lt;OrderItem&gt; items = new ArrayList&lt;OrderItem&gt;(namedOrder.getOrderItems());
 573 
 574         // Remove any order items that are children
 575         CollectionUtils.filter(items,  new TypedPredicate&lt;OrderItem&gt;() {
 576             @Override
 577             public boolean eval(OrderItem orderItem) {
 578                 return orderItem.getParentOrderItem() == null;
 579             }
 580         });
 581         for (OrderItem item : items) {
<abbr title=" 582             OrderItemRequestDTO orderItemRequest = orderItemService.buildOrderItemRequestDTOFromOrderItem(item);"> 582             OrderItemRequestDTO orderItemRequest = orderItemService.buildOrderItemRequestDTOFromOrderItemðŸ”µ</abbr>
 583             cartOrder = addItem(cartOrder.getId(), orderItemRequest, priceOrder);
 584 
 585             if (moveNamedOrderItems) {
 586                 removeItem(namedOrder.getId(), item.getId(), false);
 587             }
 588         }
 589 
 590         if (deleteEmptyNamedOrders) {
 591             cancelOrder(namedOrder);
 592         }
 593 
 594         return cartOrder;
 595     }
 596 
 597     @Override
 598     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 599     public Order addItemFromNamedOrder(Order namedOrder, OrderItem item, boolean priceOrder) throws RemoveFromCartException, AddToCartException {"> 599     public Order addItemFromNamedOrder(Order namedOrder, OrderItem item, boolean priceOrder) throws RemovðŸ”µ</abbr>
 600         Order cartOrder = orderDao.readCartForCustomer(namedOrder.getCustomer());
 601         if (cartOrder == null) {
 602             cartOrder = createNewCartForCustomer(namedOrder.getCustomer());
 603         }
 604 
<abbr title=" 605         OrderItemRequestDTO orderItemRequest = orderItemService.buildOrderItemRequestDTOFromOrderItem(item);"> 605         OrderItemRequestDTO orderItemRequest = orderItemService.buildOrderItemRequestDTOFromOrderItem(iteðŸ”µ</abbr>
 606         cartOrder = addItem(cartOrder.getId(), orderItemRequest, priceOrder);
 607 
 608         if (moveNamedOrderItems) {
 609             removeItem(namedOrder.getId(), item.getId(), false);
 610         }
 611 
 612         if (namedOrder.getOrderItems().size() == 0 &amp;&amp; deleteEmptyNamedOrders) {
 613             cancelOrder(namedOrder);
 614         }
 615 
 616         return cartOrder;
 617     }
 618 
 619     @Override
 620     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 621     public Order addItemFromNamedOrder(Order namedOrder, OrderItem item, int quantity, boolean priceOrder) throws RemoveFromCartException, AddToCartException, UpdateCartException {"> 621     public Order addItemFromNamedOrder(Order namedOrder, OrderItem item, int quantity, boolean priceOrderðŸ”µ</abbr>
 622         // Validate that the quantity requested makes sense
 623         if (quantity &lt; 1 || quantity &gt; item.getQuantity()) {
 624             throw new IllegalArgumentException(&quot;Cannot move 0 or less quantity&quot;);
 625         } else if (quantity == item.getQuantity()) {
 626             return addItemFromNamedOrder(namedOrder, item, priceOrder);
 627         }
 628 
 629         Order cartOrder = orderDao.readCartForCustomer(namedOrder.getCustomer());
 630         if (cartOrder == null) {
 631             cartOrder = createNewCartForCustomer(namedOrder.getCustomer());
 632         }
 633 
<abbr title=" 634         OrderItemRequestDTO orderItemRequest = orderItemService.buildOrderItemRequestDTOFromOrderItem(item);"> 634         OrderItemRequestDTO orderItemRequest = orderItemService.buildOrderItemRequestDTOFromOrderItem(iteðŸ”µ</abbr>
 635         orderItemRequest.setQuantity(quantity);
 636         cartOrder = addItem(cartOrder.getId(), orderItemRequest, priceOrder);
 637 
 638         if (moveNamedOrderItems) {
 639             // Update the old item to its new quantity only if we&#x27;re moving items
 640             OrderItemRequestDTO orderItemRequestDTO = new OrderItemRequestDTO();
 641             orderItemRequestDTO.setOrderItemId(item.getId());
 642             orderItemRequestDTO.setQuantity(item.getQuantity() - quantity);
 643             updateItemQuantity(namedOrder.getId(), orderItemRequestDTO, false);
 644         }
 645         return cartOrder;
 646     }
 647 
 648     @Override
 649     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 650     public OrderItem addGiftWrapItemToOrder(Order order, GiftWrapOrderItemRequest itemRequest, boolean priceOrder) throws PricingException {"> 650     public OrderItem addGiftWrapItemToOrder(Order order, GiftWrapOrderItemRequest itemRequest, boolean prðŸ”µ</abbr>
 651         GiftWrapOrderItem item = orderItemService.createGiftWrapOrderItem(itemRequest);
 652         item.setOrder(order);
 653         item = (GiftWrapOrderItem) orderItemService.saveOrderItem(item);
 654 
 655         order.getOrderItems().add(item);
 656         order = save(order, priceOrder);
 657 
 658         return item;
 659     }
 660 
 661     @Override
 662     @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = {AddToCartException.class})
<abbr title=" 663     public Order addItem(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throws AddToCartException {"> 663     public Order addItem(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throwðŸ”µ</abbr>
 664         // Don&#x27;t allow overrides from this method.
 665         orderItemRequestDTO.setOverrideRetailPrice(null);
 666         orderItemRequestDTO.setOverrideSalePrice(null);
 667         return addItemWithPriceOverrides(orderId, orderItemRequestDTO, priceOrder);
 668     }
 669 
 670     @Override
 671     @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = { AddToCartException.class })
<abbr title=" 672     public Order addItemWithPriceOverrides(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throws AddToCartException {"> 672     public Order addItemWithPriceOverrides(Long orderId, OrderItemRequestDTO orderItemRequestDTO, booleanðŸ”µ</abbr>
 673         Order order = findOrderById(orderId);
 674         preValidateCartOperation(order);
 675         if (getAutomaticallyMergeLikeItems()) {
 676             OrderItem item = findMatchingItem(order, orderItemRequestDTO);
 677             if (item != null &amp;&amp; item.getParentOrderItem() == null) {
 678                 orderItemRequestDTO.setQuantity(item.getQuantity() + orderItemRequestDTO.getQuantity());
 679                 orderItemRequestDTO.setOrderItemId(item.getId());
 680                 try {
 681                     return updateItemQuantity(orderId, orderItemRequestDTO, priceOrder);
 682                 } catch (RemoveFromCartException e) {
<abbr title=" 683                     throw new AddToCartException(&quot;Unexpected error - system tried to remove item while adding to cart&quot;, e);"> 683                     throw new AddToCartException(&quot;Unexpected error - system tried to remove item while adðŸ”µ</abbr>
 684                 } catch (UpdateCartException e) {
 685                     throw new AddToCartException(&quot;Could not update quantity for matched item&quot;, e);
 686                 }
 687             }
 688         }
 689         try {
<abbr title=" 690             // We only want to price on the last addition for performance reasons and only if the user asked for it."> 690             // We only want to price on the last addition for performance reasons and only if the user asðŸ”µ</abbr>
 691             int numAdditionRequests = priceOrder ? (getTotalChildOrderItems(orderItemRequestDTO)) : -1;
 692             int currentAddition = 1;
 693 
<abbr title=" 694             CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestDTO, currentAddition == numAdditionRequests);"> 694             CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItðŸ”µ</abbr>
 695 
 696             Session session = em.unwrap(Session.class);
 697             FlushMode current = session.getHibernateFlushMode();
 698             if (!autoFlushAddToCart) {
<abbr title=" 699                 //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 699                 //Performance measure. Hibernate will sometimes perform an autoflush when performing querðŸ”µ</abbr>
<abbr title=" 700                 //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 700                 //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queriesðŸ”µ</abbr>
 701                 //incorrect results because something has not been flushed to the database yet.
 702                 session.setHibernateFlushMode(FlushMode.MANUAL);
 703             }
 704             ProcessContext&lt;CartOperationRequest&gt; context;
 705             try {
<abbr title=" 706                 context = (ProcessContext&lt;CartOperationRequest&gt;) addItemWorkflow.doActivities(cartOpRequest);"> 706                 context = (ProcessContext&lt;CartOperationRequest&gt;) addItemWorkflow.doActivities(cartOpRequeðŸ”µ</abbr>
 707             } finally {
 708                 if (!autoFlushAddToCart) {
 709                     session.setHibernateFlushMode(current);
 710                 }
 711             }
 712 
 713             List&lt;ActivityMessageDTO&gt; orderMessages = new ArrayList&lt;ActivityMessageDTO&gt;();
 714             orderMessages.addAll(((ActivityMessages) context).getActivityMessages());
 715 
 716             // Update the orderItemRequest incase it changed during the initial add to cart workflow
 717             orderItemRequestDTO = context.getSeedData().getItemRequest();
 718             numAdditionRequests = priceOrder ? (getTotalChildOrderItems(orderItemRequestDTO) - 1) : -1;
<abbr title=" 719             addChildItems(orderItemRequestDTO, numAdditionRequests, currentAddition, context, orderMessages);"> 719             addChildItems(orderItemRequestDTO, numAdditionRequests, currentAddition, context, orderMessagðŸ”µ</abbr>
 720 
 721             context.getSeedData().getOrder().setOrderMessages(orderMessages);
 722             return context.getSeedData().getOrder();
 723         } catch (WorkflowException e) {
 724             throw new AddToCartException(&quot;Could not add to cart&quot;, getCartOperationExceptionRootCause(e));
 725         }
 726 
 727     }
 728 
 729     @Override
 730     public int getTotalChildOrderItems(OrderItemRequestDTO orderItemRequestDTO) {
 731         int count = 1;
 732         for (OrderItemRequestDTO childRequest : orderItemRequestDTO.getChildOrderItems()) {
 733             count += getTotalChildOrderItems(childRequest);
 734         }
 735         return count;
 736     }
 737 
 738     @Override
<abbr title=" 739     public void addChildItems(OrderItemRequestDTO orderItemRequestDTO, int numAdditionRequests, int currentAddition, ProcessContext&lt;CartOperationRequest&gt; context, List&lt;ActivityMessageDTO&gt; orderMessages) throws WorkflowException {"> 739     public void addChildItems(OrderItemRequestDTO orderItemRequestDTO, int numAdditionRequests, int curreðŸ”µ</abbr>
 740         if (CollectionUtils.isNotEmpty(orderItemRequestDTO.getChildOrderItems())) {
 741             Long parentOrderItemId = context.getSeedData().getOrderItem().getId();
 742             for (OrderItemRequestDTO childRequest : orderItemRequestDTO.getChildOrderItems()) {
 743                 childRequest.setParentOrderItemId(parentOrderItemId);
 744                 currentAddition++;
 745 
 746                 if (childRequest.getQuantity() &gt; 0) {
<abbr title=" 747                     CartOperationRequest childCartOpRequest = new CartOperationRequest(context.getSeedData().getOrder(), childRequest, currentAddition == numAdditionRequests);"> 747                     CartOperationRequest childCartOpRequest = new CartOperationRequest(context.getSeedDatðŸ”µ</abbr>
 748                     Session session = em.unwrap(Session.class);
 749                     FlushMode current = session.getHibernateFlushMode();
 750                     if (!autoFlushAddToCart) {
<abbr title=" 751                         //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 751                         //Performance measure. Hibernate will sometimes perform an autoflush when performðŸ”µ</abbr>
<abbr title=" 752                         //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 752                         //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern aboutðŸ”µ</abbr>
 753                         //incorrect results because something has not been flushed to the database yet.
 754                         session.setHibernateFlushMode(FlushMode.MANUAL);
 755                     }
 756                     ProcessContext&lt;CartOperationRequest&gt; childContext;
 757                     try {
<abbr title=" 758                         childContext = (ProcessContext&lt;CartOperationRequest&gt;) addItemWorkflow.doActivities(childCartOpRequest);"> 758                         childContext = (ProcessContext&lt;CartOperationRequest&gt;) addItemWorkflow.doActivitieðŸ”µ</abbr>
 759                     } finally {
 760                         if (!autoFlushAddToCart) {
 761                             session.setHibernateFlushMode(current);
 762                         }
 763                     }
 764                     orderMessages.addAll(((ActivityMessages) childContext).getActivityMessages());
 765 
<abbr title=" 766                     addChildItems(childRequest, numAdditionRequests, currentAddition, childContext, orderMessages);"> 766                     addChildItems(childRequest, numAdditionRequests, currentAddition, childContext, orderðŸ”µ</abbr>
 767                 }
 768             }
 769         }
 770     }
 771 
 772     @Override
<abbr title=" 773     public void addDependentOrderItem(OrderItemRequestDTO parentOrderItemRequest, OrderItemRequestDTO dependentOrderItem) {"> 773     public void addDependentOrderItem(OrderItemRequestDTO parentOrderItemRequest, OrderItemRequestDTO depðŸ”µ</abbr>
 774         parentOrderItemRequest.getChildOrderItems().add(dependentOrderItem);
<abbr title=" 775         Collections.sort(parentOrderItemRequest.getChildOrderItems(), new Comparator&lt;OrderItemRequestDTO&gt;() {"> 775         Collections.sort(parentOrderItemRequest.getChildOrderItems(), new Comparator&lt;OrderItemRequestDTO&gt;ðŸ”µ</abbr>
 776             @Override
 777             public int compare(OrderItemRequestDTO o1, OrderItemRequestDTO o2) {
<abbr title=" 778                 BigDecimal o1DisplayOrder = new BigDecimal(o1.getAdditionalAttributes().get(&quot;addOnDisplayOrder&quot;));"> 778                 BigDecimal o1DisplayOrder = new BigDecimal(o1.getAdditionalAttributes().get(&quot;addOnDisplayðŸ”µ</abbr>
<abbr title=" 779                 BigDecimal o2DisplayOrder = new BigDecimal(o2.getAdditionalAttributes().get(&quot;addOnDisplayOrder&quot;));"> 779                 BigDecimal o2DisplayOrder = new BigDecimal(o2.getAdditionalAttributes().get(&quot;addOnDisplayðŸ”µ</abbr>
 780                 return o1DisplayOrder.compareTo(o2DisplayOrder);
 781             }
 782         });
 783     }
 784 
 785     @Override
<abbr title=" 786     @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = {UpdateCartException.class, RemoveFromCartException.class})"> 786     @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = {UpdateCartException.class, RemoveFromCaðŸ”µ</abbr>
<abbr title=" 787     public Order updateItemQuantity(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throws UpdateCartException, RemoveFromCartException {"> 787     public Order updateItemQuantity(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOðŸ”µ</abbr>
 788         Order order = findOrderById(orderId);
 789         preValidateCartOperation(order);
 790         preValidateUpdateQuantityOperation(findOrderById(orderId), orderItemRequestDTO);
 791         if (orderItemRequestDTO.getQuantity() == 0) {
 792             return removeItem(orderId, orderItemRequestDTO.getOrderItemId(), priceOrder);
 793         }
 794 
 795         try {
<abbr title=" 796             CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestDTO, priceOrder);"> 796             CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItðŸ”µ</abbr>
 797             Session session = em.unwrap(Session.class);
 798             FlushMode current = session.getHibernateFlushMode();
 799             if (!autoFlushUpdateCart) {
<abbr title=" 800                 //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 800                 //Performance measure. Hibernate will sometimes perform an autoflush when performing querðŸ”µ</abbr>
<abbr title=" 801                 //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 801                 //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queriesðŸ”µ</abbr>
 802                 //incorrect results because something has not been flushed to the database yet.
 803                 session.setHibernateFlushMode(FlushMode.MANUAL);
 804             }
 805             ProcessContext&lt;CartOperationRequest&gt; context;
 806             try {
<abbr title=" 807                 context = (ProcessContext&lt;CartOperationRequest&gt;) updateItemWorkflow.doActivities(cartOpRequest);"> 807                 context = (ProcessContext&lt;CartOperationRequest&gt;) updateItemWorkflow.doActivities(cartOpReðŸ”µ</abbr>
 808             } finally {
 809                 if (!autoFlushUpdateCart) {
 810                     session.setHibernateFlushMode(current);
 811                 }
 812             }
<abbr title=" 813             context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getActivityMessages());"> 813             context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getAcðŸ”µ</abbr>
 814             return context.getSeedData().getOrder();
 815         } catch (WorkflowException e) {
<abbr title=" 816             throw new UpdateCartException(&quot;Could not update cart quantity&quot;, getCartOperationExceptionRootCause(e));"> 816             throw new UpdateCartException(&quot;Could not update cart quantity&quot;, getCartOperationExceptionRootðŸ”µ</abbr>
 817         }
 818     }
 819 
 820     @Override
 821     @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = {RemoveFromCartException.class})
<abbr title=" 822     public Order removeItem(Long orderId, Long orderItemId, boolean priceOrder) throws RemoveFromCartException {"> 822     public Order removeItem(Long orderId, Long orderItemId, boolean priceOrder) throws RemoveFromCartExceðŸ”µ</abbr>
 823         preValidateCartOperation(findOrderById(orderId));
 824         try {
 825             OrderItem oi = orderItemService.readOrderItemById(orderItemId);
 826             if (oi == null) {
 827                 throw new WorkflowException(new ItemNotFoundException());
 828             }
 829             List&lt;Long&gt; childrenToRemove = new ArrayList&lt;Long&gt;();
 830             if (oi instanceof BundleOrderItem) {
 831                 List&lt;DiscreteOrderItem&gt; bundledItems = ((BundleOrderItem) oi).getDiscreteOrderItems();
 832                 for (DiscreteOrderItem doi : bundledItems) {
 833                     findAllChildrenToRemove(childrenToRemove, doi);
 834                 }
 835             } else {
 836                 findAllChildrenToRemove(childrenToRemove, oi);
 837             }
 838             for (Long childToRemove : childrenToRemove) {
 839                 removeItemInternal(orderId, childToRemove, false);
 840             }
 841 
 842             return removeItemInternal(orderId, orderItemId, priceOrder);
 843         } catch (WorkflowException e) {
<abbr title=" 844             throw new RemoveFromCartException(&quot;Could not remove from cart&quot;, getCartOperationExceptionRootCause(e));"> 844             throw new RemoveFromCartException(&quot;Could not remove from cart&quot;, getCartOperationExceptionRootðŸ”µ</abbr>
 845         }
 846     }
 847 
 848     protected void findAllChildrenToRemove(List&lt;Long&gt; childrenToRemove, OrderItem orderItem){
 849         if (CollectionUtils.isNotEmpty(orderItem.getChildOrderItems())) {
 850             for (OrderItem childOrderItem : orderItem.getChildOrderItems()) {
 851                 findAllChildrenToRemove(childrenToRemove, childOrderItem);
 852                 childrenToRemove.add(childOrderItem.getId());
 853             }
 854         }
 855     }
 856 
<abbr title=" 857     protected Order removeItemInternal(Long orderId, Long orderItemId, boolean priceOrder) throws WorkflowException {"> 857     protected Order removeItemInternal(Long orderId, Long orderItemId, boolean priceOrder) throws WorkfloðŸ”µ</abbr>
 858         OrderItemRequestDTO orderItemRequestDTO = new OrderItemRequestDTO();
 859         orderItemRequestDTO.setOrderItemId(orderItemId);
<abbr title=" 860         CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestDTO, priceOrder);"> 860         CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemReðŸ”µ</abbr>
 861         Session session = em.unwrap(Session.class);
 862         FlushMode current = session.getHibernateFlushMode();
 863         if (!autoFlushRemoveFromCart) {
<abbr title=" 864             //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 864             //Performance measure. Hibernate will sometimes perform an autoflush when performing query opðŸ”µ</abbr>
<abbr title=" 865             //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 865             //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in ðŸ”µ</abbr>
 866             //incorrect results because something has not been flushed to the database yet.
 867             session.setHibernateFlushMode(FlushMode.MANUAL);
 868         }
 869         ProcessContext&lt;CartOperationRequest&gt; context;
 870         try {
<abbr title=" 871             context = (ProcessContext&lt;CartOperationRequest&gt;) removeItemWorkflow.doActivities(cartOpRequest);"> 871             context = (ProcessContext&lt;CartOperationRequest&gt;) removeItemWorkflow.doActivities(cartOpRequesðŸ”µ</abbr>
 872         } finally {
 873             if (!autoFlushRemoveFromCart) {
 874                 session.setHibernateFlushMode(current);
 875             }
 876         }
<abbr title=" 877         context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getActivityMessages());"> 877         context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getActiviðŸ”µ</abbr>
 878         return context.getSeedData().getOrder();
 879     }
 880 
 881     @Override
 882     @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = { RemoveFromCartException.class })
 883     public Order removeInactiveItems(Long orderId, boolean priceOrder) throws RemoveFromCartException {
 884         Order order = findOrderById(orderId);
 885         try {
 886 
 887             for (OrderItem currentItem : new ArrayList&lt;OrderItem&gt;(order.getOrderItems())) {
 888                 if (!currentItem.isSkuActive()) {
 889                     removeItem(orderId, currentItem.getId(), priceOrder);
 890                 }
 891             }
 892 
 893         } catch (Exception e) {
 894             throw new RemoveFromCartException(&quot;Could not remove from cart&quot;, e.getCause());
 895         }
 896         return findOrderById(orderId);
 897     }
 898 
 899     @Override
 900     public boolean getAutomaticallyMergeLikeItems() {
 901 
 902         if (automaticallyMergeLikeItems != null) {
 903             return automaticallyMergeLikeItems;
 904         }
 905 
 906         return BLCSystemProperty.resolveBooleanSystemProperty(&quot;automatically.merge.like.items&quot;, true);
 907     }
 908 
 909     @Override
 910     public void setAutomaticallyMergeLikeItems(boolean automaticallyMergeLikeItems) {
 911         this.automaticallyMergeLikeItems = automaticallyMergeLikeItems;
 912     }
 913 
 914     @Override
<abbr title=" 915     @ManagedAttribute(description=&quot;The move item from named order when adding to the cart attribute&quot;, currencyTimeLimit=15)"> 915     @ManagedAttribute(description=&quot;The move item from named order when adding to the cart attribute&quot;, curðŸ”µ</abbr>
 916     public boolean isMoveNamedOrderItems() {
 917         return moveNamedOrderItems;
 918     }
 919 
 920     @Override
<abbr title=" 921     @ManagedAttribute(description=&quot;The move item from named order when adding to the cart attribute&quot;, currencyTimeLimit=15)"> 921     @ManagedAttribute(description=&quot;The move item from named order when adding to the cart attribute&quot;, curðŸ”µ</abbr>
 922     public void setMoveNamedOrderItems(boolean moveNamedOrderItems) {
 923         this.moveNamedOrderItems = moveNamedOrderItems;
 924     }
 925 
 926     @Override
<abbr title=" 927     @ManagedAttribute(description=&quot;The delete empty named order after adding items to cart attribute&quot;, currencyTimeLimit=15)"> 927     @ManagedAttribute(description=&quot;The delete empty named order after adding items to cart attribute&quot;, cuðŸ”µ</abbr>
 928     public boolean isDeleteEmptyNamedOrders() {
 929         return deleteEmptyNamedOrders;
 930     }
 931 
 932     @Override
 933     @Transactional(&quot;blTransactionManager&quot;)
 934     public void removeAllPaymentsFromOrder(Order order) {
 935         removePaymentsFromOrder(order, null);
 936     }
 937 
 938     @Override
 939     @Transactional(&quot;blTransactionManager&quot;)
 940     public void removePaymentsFromOrder(Order order, PaymentType paymentInfoType) {
 941         List&lt;OrderPayment&gt; infos = new ArrayList&lt;OrderPayment&gt;();
 942         for (OrderPayment paymentInfo : order.getPayments()) {
 943             if (paymentInfoType == null || paymentInfoType.equals(paymentInfo.getType())) {
 944                 infos.add(paymentInfo);
 945             }
 946         }
 947         order.getPayments().removeAll(infos);
 948         for (OrderPayment paymentInfo : infos) {
 949             try {
<abbr title=" 950                 securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentInfo.getReferenceNumber(), paymentInfo.getType());"> 950                 securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentInfo.getReferenceNumber(),ðŸ”µ</abbr>
 951             } catch (WorkflowException e) {
 952                 // do nothing--this is an acceptable condition
 953                 LOG.debug(&quot;No secure payment is associated with the OrderPayment&quot;, e);
 954             }
 955             order.getPayments().remove(paymentInfo);
 956             paymentInfo = paymentDao.readPaymentById(paymentInfo.getId());
 957             paymentDao.delete(paymentInfo);
 958         }
 959     }
 960 
 961     @Override
 962     @Transactional(&quot;blTransactionManager&quot;)
 963     public void removeCreditCardPaymentsFromOrder(Order order) {
 964         List&lt;OrderPayment&gt; infos = new ArrayList&lt;OrderPayment&gt;();
 965         for (OrderPayment paymentInfo : order.getPayments()) {
 966             if (paymentInfo.getType().isCreditCardType()) {
 967                 infos.add(paymentInfo);
 968             }
 969         }
 970         order.getPayments().removeAll(infos);
 971         for (OrderPayment paymentInfo : infos) {
 972             try {
<abbr title=" 973                 securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentInfo.getReferenceNumber(), paymentInfo.getType());"> 973                 securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentInfo.getReferenceNumber(),ðŸ”µ</abbr>
 974             } catch (WorkflowException e) {
 975                 // do nothing--this is an acceptable condition
 976                 LOG.debug(&quot;No secure payment is associated with the OrderPayment&quot;, e);
 977             }
 978             order.getPayments().remove(paymentInfo);
 979             paymentInfo = paymentDao.readPaymentById(paymentInfo.getId());
 980             paymentDao.delete(paymentInfo);
 981         }
 982     }
 983 
 984     @Override
 985     @Transactional(&quot;blTransactionManager&quot;)
 986     public void removePaymentFromOrder(Order order, OrderPayment payment){
 987         OrderPayment paymentToRemove = null;
 988         for (OrderPayment info : order.getPayments()){
 989             if (info.equals(payment)){
 990                 paymentToRemove = info;
 991             }
 992         }
 993         if (paymentToRemove != null){
 994             try {
<abbr title=" 995                 securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentToRemove.getReferenceNumber(), payment.getType());"> 995                 securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentToRemove.getReferenceNumbeðŸ”µ</abbr>
 996             } catch (WorkflowException e) {
 997                 // do nothing--this is an acceptable condition
 998                 LOG.debug(&quot;No secure payment is associated with the OrderPayment&quot;, e);
 999             }
1000             order.getPayments().remove(paymentToRemove);
1001             payment = paymentDao.readPaymentById(paymentToRemove.getId());
1002             paymentDao.delete(payment);
1003         }
1004     }
1005 
1006     /**
1007      * This method will return the exception that is immediately below the deepest
1008      * WorkflowException in the current stack trace.
1009      *
1010      * @param e the workflow exception that contains the requested root cause
1011      * @return the root cause of the workflow exception
1012      */
1013     protected Throwable getCartOperationExceptionRootCause(WorkflowException e) {
1014         Throwable cause = e.getCause();
1015         if (cause == null) {
1016             return e;
1017         }
1018 
1019         Throwable currentCause = cause;
1020         while (currentCause.getCause() != null) {
1021             currentCause = currentCause.getCause();
1022             if (currentCause instanceof WorkflowException) {
1023                 cause = currentCause.getCause();
1024             }
1025         }
1026 
1027         return cause;
1028     }
1029 
1030     /**
1031      * Returns true if the two items attributes exactly match.
1032      * @param item1Attributes
1033      * @param item2
1034      * @return
1035      */
<abbr title="1036     protected boolean compareAttributes(Map&lt;String, OrderItemAttribute&gt; item1Attributes, OrderItemRequestDTO item2) {">1036     protected boolean compareAttributes(Map&lt;String, OrderItemAttribute&gt; item1Attributes, OrderItemRequestðŸ”µ</abbr>
1037         int item1AttributeSize = item1Attributes == null ? 0 : item1Attributes.size();
<abbr title="1038         int item2AttributeSize = item2.getItemAttributes() == null ? 0 : item2.getItemAttributes().size();">1038         int item2AttributeSize = item2.getItemAttributes() == null ? 0 : item2.getItemAttributes().size()ðŸ”µ</abbr>
1039 
1040         if (item1AttributeSize != item2AttributeSize) {
1041             return false;
1042         }
1043 
1044         for (String key : item2.getItemAttributes().keySet()) {
<abbr title="1045             String itemOneValue = (item1Attributes.get(key) == null) ? null : item1Attributes.get(key).getValue();">1045             String itemOneValue = (item1Attributes.get(key) == null) ? null : item1Attributes.get(key).geðŸ”µ</abbr>
1046             String itemTwoValue = item2.getItemAttributes().get(key);
1047             if (!itemTwoValue.equals(itemOneValue)) {
1048                 return false;
1049             }
1050         }
1051         return true;
1052     }
1053 
<abbr title="1054     protected boolean itemMatches(Sku item1Sku, Product item1Product, Map&lt;String, OrderItemAttribute&gt; item1Attributes,">1054     protected boolean itemMatches(Sku item1Sku, Product item1Product, Map&lt;String, OrderItemAttribute&gt; iteðŸ”µ</abbr>
1055             OrderItemRequestDTO item2) {
1056         // Must match on SKU and options
1057         if (item1Sku != null &amp;&amp; item2.getSkuId() != null) {
1058             if (item1Sku.getId().equals(item2.getSkuId())) {
1059                 return true;
1060             }
1061         } else {
1062             if (item1Product != null &amp;&amp; item2.getProductId() != null) {
1063                 if (item1Product.getId().equals(item2.getProductId())) {
1064                     return compareAttributes(item1Attributes, item2);
1065                 }
1066             }
1067         }
1068         return false;
1069     }
1070 
1071     protected OrderItem findMatchingItem(Order order, OrderItemRequestDTO itemToFind) {
1072         if (order == null) {
1073             return null;
1074         }
1075         for (OrderItem currentItem : order.getOrderItems()) {
1076             if (currentItem instanceof DiscreteOrderItem) {
1077                 DiscreteOrderItem discreteItem = (DiscreteOrderItem) currentItem;
<abbr title="1078                 if (itemMatches(discreteItem.getSku(), discreteItem.getProduct(), discreteItem.getOrderItemAttributes(),">1078                 if (itemMatches(discreteItem.getSku(), discreteItem.getProduct(), discreteItem.getOrderItðŸ”µ</abbr>
1079                         itemToFind)) {
1080                     return discreteItem;
1081                 }
1082             } else if (currentItem instanceof BundleOrderItem) {
1083                 BundleOrderItem bundleItem = (BundleOrderItem) currentItem;
1084                 if (itemMatches(bundleItem.getSku(), bundleItem.getProduct(), null, itemToFind)) {
1085                     return bundleItem;
1086                 }
1087             }
1088         }
1089         return null;
1090     }
1091 
1092     @Override
1093     @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = { UpdateCartException.class })
<abbr title="1094     public Order updateProductOptionsForItem(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throws UpdateCartException {">1094     public Order updateProductOptionsForItem(Long orderId, OrderItemRequestDTO orderItemRequestDTO, booleðŸ”µ</abbr>
1095         try {
<abbr title="1096             CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestDTO, priceOrder);">1096             CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItðŸ”µ</abbr>
<abbr title="1097             ProcessContext&lt;CartOperationRequest&gt; context = (ProcessContext&lt;CartOperationRequest&gt;) updateProductOptionsForItemWorkflow.doActivities(cartOpRequest);">1097             ProcessContext&lt;CartOperationRequest&gt; context = (ProcessContext&lt;CartOperationRequest&gt;) updatePðŸ”µ</abbr>
<abbr title="1098             context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getActivityMessages());">1098             context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getAcðŸ”µ</abbr>
1099             return context.getSeedData().getOrder();
1100         } catch (WorkflowException e) {
<abbr title="1101             throw new UpdateCartException(&quot;Could not product options&quot;, getCartOperationExceptionRootCause(e));">1101             throw new UpdateCartException(&quot;Could not product options&quot;, getCartOperationExceptionRootCauseðŸ”µ</abbr>
1102         }
1103     }
1104 
1105     @Override
1106     public Order reloadOrder(Order order) {
1107         if (order == null || order instanceof NullOrderImpl || order.getId() == null) {
1108             return order;
1109         }
1110 
1111         return orderDao.readOrderById(order.getId(), true);
1112     }
1113 
1114     @Override
1115     @Transactional(&quot;blTransactionManager&quot;)
1116     public boolean acquireLock(Order order) {
1117         return orderDao.acquireLock(order);
1118     }
1119 
1120     @Override
1121     public boolean releaseLock(Order order) {
1122         return orderDao.releaseLock(order);
1123     }
1124 
1125     @Override
1126     public void printOrder(Order order, Log log) {
1127         if (!log.isDebugEnabled()) {
1128             return;
1129         }
1130 
1131         TableCreator tc = new TableCreator(new TableCreator.Col[] {
1132             new TableCreator.Col(&quot;Order Item&quot;, 30),
1133             new TableCreator.Col(&quot;Qty&quot;),
1134             new TableCreator.Col(&quot;Unit Price&quot;),
1135             new TableCreator.Col(&quot;Avg Adj&quot;),
1136             new TableCreator.Col(&quot;Total Adj&quot;),
1137             new TableCreator.Col(&quot;Total Price&quot;)
1138         });
1139 
1140         for (OrderItem oi : order.getOrderItems()) {
1141             tc.addRow(new String[] {
1142                 oi.getName(),
1143                 String.valueOf(oi.getQuantity()),
1144                 String.valueOf(oi.getPriceBeforeAdjustments(true)),
1145                 String.valueOf(oi.getAverageAdjustmentValue()),
1146                 String.valueOf(oi.getTotalAdjustmentValue()),
1147                 String.valueOf(oi.getTotalPrice())
1148             });
1149         }
1150 
1151         tc.addSeparator()
1152             .withGlobalRowHeaderWidth(15)
1153             .addRow(&quot;Subtotal&quot;, order.getSubTotal())
1154             .addRow(&quot;Order Adj.&quot;, order.getOrderAdjustmentsValue())
1155             .addRow(&quot;Tax&quot;, order.getTotalTax())
1156             .addRow(&quot;Shipping&quot;, order.getTotalShipping())
1157             .addRow(&quot;Total&quot;, order.getTotal())
1158             .addSeparator();
1159 
1160         log.debug(tc.toString());
1161     }
1162 
1163     @Override
1164     public void preValidateCartOperation(Order cart) {
1165         ExtensionResultHolder erh = new ExtensionResultHolder();
1166         extensionManager.getProxy().preValidateCartOperation(cart, erh);
1167         if (erh.getThrowable() instanceof IllegalCartOperationException) {
1168             throw ((IllegalCartOperationException) erh.getThrowable());
1169         } else if (erh.getThrowable() != null) {
1170             throw new RuntimeException(erh.getThrowable());
1171         }
1172     }
1173 
1174     @Override
1175     public void preValidateUpdateQuantityOperation(Order cart, OrderItemRequestDTO dto) {
1176         ExtensionResultHolder erh = new ExtensionResultHolder();
1177         extensionManager.getProxy().preValidateUpdateQuantityOperation(cart, dto, erh);
1178         if (erh.getThrowable() instanceof IllegalCartOperationException) {
1179             throw ((IllegalCartOperationException) erh.getThrowable());
1180         } else if (erh.getThrowable() != null) {
1181             throw new RuntimeException(erh.getThrowable());
1182         }
1183     }
1184 
1185     @Override
1186     public void refresh(Order order) {
1187         orderDao.refresh(order);
1188     }
1189 
1190     @Override
1191     public Order findCartForCustomerWithEnhancements(Customer customer) {
1192         ExtensionResultHolder&lt;Order&gt; erh = new ExtensionResultHolder&lt;Order&gt;();
<abbr title="1193         ExtensionResultStatusType resultStatusType = extensionManager.findCartForCustomerWithEnhancements(customer, erh);">1193         ExtensionResultStatusType resultStatusType = extensionManager.findCartForCustomerWithEnhancementsðŸ”µ</abbr>
1194         if (ExtensionResultStatusType.NOT_HANDLED != resultStatusType) {
1195             return erh.getResult();
1196         }
1197         return findCartForCustomer(customer);
1198     }
1199 
1200     @Override
1201     public Order findCartForCustomerWithEnhancements(Customer customer, Order candidateOrder) {
1202         ExtensionResultHolder&lt;Order&gt; erh = new ExtensionResultHolder&lt;Order&gt;();
<abbr title="1203         ExtensionResultStatusType resultStatusType = extensionManager.findCartForCustomerWithEnhancements(customer, candidateOrder, erh);">1203         ExtensionResultStatusType resultStatusType = extensionManager.findCartForCustomerWithEnhancementsðŸ”µ</abbr>
1204         if (ExtensionResultStatusType.NOT_HANDLED != resultStatusType) {
1205             return erh.getResult();
1206         }
1207         return candidateOrder;
1208     }
1209 
1210     @Override
1211     public List&lt;Order&gt; findOrdersByEmail(String email) {
1212         return orderDao.readOrdersByEmail(email);
1213     }
1214 
1215     @Override
1216     public List&lt;Order&gt; readBatchOrders(int start, int pageSize, List&lt;OrderStatus&gt; orderStatusList) {
1217         return orderDao.readBatchOrders(start, pageSize, orderStatusList);
1218     }
1219 
1220     @Override
1221 	public Long readNumberOfOrders() {
1222     		return orderDao.readNumberOfOrders();
1223     }
1224 }
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Framework
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.core.order.service;
  19 
  20 import java.math.BigDecimal;
  21 import java.util.ArrayList;
  22 import java.util.Collections;
  23 import java.util.Comparator;
  24 import java.util.Date;
  25 import java.util.List;
  26 import java.util.Map;
  27 import java.util.Objects;
  28 import java.util.Set;
  29 import javax.annotation.Resource;
  30 import javax.persistence.EntityManager;
  31 import javax.persistence.PersistenceContext;
  32 import org.apache.commons.collections.CollectionUtils;
  33 import org.apache.commons.logging.Log;
  34 import org.apache.commons.logging.LogFactory;
  35 import org.broadleafcommerce.common.extension.ExtensionResultHolder;
  36 import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  37 import org.broadleafcommerce.common.payment.PaymentType;
  38 import org.broadleafcommerce.common.util.BLCSystemProperty;
  39 import org.broadleafcommerce.common.util.TableCreator;
  40 import org.broadleafcommerce.common.util.TransactionUtils;
  41 import org.broadleafcommerce.common.util.TypedPredicate;
  42 import org.broadleafcommerce.common.web.BroadleafRequestContext;
  43 import org.broadleafcommerce.core.catalog.domain.Product;
  44 import org.broadleafcommerce.core.catalog.domain.Sku;
  45 import org.broadleafcommerce.core.offer.dao.OfferDao;
  46 import org.broadleafcommerce.core.offer.domain.Offer;
  47 import org.broadleafcommerce.core.offer.domain.OfferCode;
  48 import org.broadleafcommerce.core.offer.service.OfferService;
  49 import org.broadleafcommerce.core.offer.service.OfferServiceExtensionManager;
  50 import org.broadleafcommerce.core.offer.service.exception.OfferAlreadyAddedException;
  51 import org.broadleafcommerce.core.offer.service.exception.OfferException;
  52 import org.broadleafcommerce.core.offer.service.exception.OfferExpiredException;
  53 import org.broadleafcommerce.core.offer.service.exception.OfferMaxUseExceededException;
  54 import org.broadleafcommerce.core.order.dao.OrderDao;
  55 import org.broadleafcommerce.core.order.domain.BundleOrderItem;
  56 import org.broadleafcommerce.core.order.domain.DiscreteOrderItem;
  57 import org.broadleafcommerce.core.order.domain.GiftWrapOrderItem;
  58 import org.broadleafcommerce.core.order.domain.NullOrderFactory;
  59 import org.broadleafcommerce.core.order.domain.NullOrderImpl;
  60 import org.broadleafcommerce.core.order.domain.Order;
  61 import org.broadleafcommerce.core.order.domain.OrderItem;
  62 import org.broadleafcommerce.core.order.domain.OrderItemAttribute;
  63 import org.broadleafcommerce.core.order.service.call.ActivityMessageDTO;
  64 import org.broadleafcommerce.core.order.service.call.GiftWrapOrderItemRequest;
  65 import org.broadleafcommerce.core.order.service.call.OrderItemRequestDTO;
  66 import org.broadleafcommerce.core.order.service.exception.AddToCartException;
  67 import org.broadleafcommerce.core.order.service.exception.IllegalCartOperationException;
  68 import org.broadleafcommerce.core.order.service.exception.ItemNotFoundException;
  69 import org.broadleafcommerce.core.order.service.exception.RemoveFromCartException;
  70 import org.broadleafcommerce.core.order.service.exception.UpdateCartException;
  71 import org.broadleafcommerce.core.order.service.type.OrderStatus;
  72 import org.broadleafcommerce.core.order.service.workflow.CartOperationRequest;
  73 import org.broadleafcommerce.core.payment.dao.OrderPaymentDao;
  74 import org.broadleafcommerce.core.payment.domain.OrderPayment;
  75 import org.broadleafcommerce.core.payment.domain.secure.Referenced;
  76 import org.broadleafcommerce.core.payment.service.SecureOrderPaymentService;
  77 import org.broadleafcommerce.core.pricing.service.PricingService;
  78 import org.broadleafcommerce.core.pricing.service.exception.PricingException;
  79 import org.broadleafcommerce.core.workflow.ActivityMessages;
  80 import org.broadleafcommerce.core.workflow.ProcessContext;
  81 import org.broadleafcommerce.core.workflow.Processor;
  82 import org.broadleafcommerce.core.workflow.WorkflowException;
  83 import org.broadleafcommerce.profile.core.domain.Customer;
  84 import org.broadleafcommerce.profile.core.service.CustomerService;
  85 import org.hibernate.FlushMode;
  86 import org.hibernate.Session;
  87 import org.hibernate.exception.LockAcquisitionException;
  88 import org.springframework.beans.factory.annotation.Value;
  89 import org.springframework.jmx.export.annotation.ManagedAttribute;
  90 import org.springframework.jmx.export.annotation.ManagedResource;
  91 import org.springframework.stereotype.Service;
  92 import org.springframework.transaction.PlatformTransactionManager;
  93 import org.springframework.transaction.TransactionDefinition;
  94 import org.springframework.transaction.TransactionStatus;
  95 import org.springframework.transaction.annotation.Transactional;
  96 
  97 
  98 /**
  99  * @author apazzolini
 100  */
 101 @Service(&quot;blOrderService&quot;)
<abbr title=" 102 @ManagedResource(objectName = &quot;org.broadleafcommerce:name=OrderService&quot;, description = &quot;Order Service&quot;, currencyTimeLimit = 15)"> 102 @ManagedResource(objectName = &quot;org.broadleafcommerce:name=OrderService&quot;, description = &quot;Order Service&quot;, cðŸ”µ</abbr>
 103 public class OrderServiceImpl implements OrderService {
 104     private static final Log LOG = LogFactory.getLog(OrderServiceImpl.class);
 105 
 106     /* DAOs */
 107     @Resource(name = &quot;blOrderPaymentDao&quot;)
 108     protected OrderPaymentDao paymentDao;
 109 
 110     @Resource(name = &quot;blOrderDao&quot;)
 111     protected OrderDao orderDao;
 112 
 113     @Resource(name = &quot;blOfferDao&quot;)
 114     protected OfferDao offerDao;
 115 
 116     /* Factories */
 117     @Resource(name = &quot;blNullOrderFactory&quot;)
 118     protected NullOrderFactory nullOrderFactory;
 119 
 120     /* Services */
 121     @Resource(name = &quot;blCustomerService&quot;)
 122     protected CustomerService customerService;
 123 
 124     @Resource(name = &quot;blPricingService&quot;)
 125     protected PricingService pricingService;
 126 
 127     @Resource(name = &quot;blOrderItemService&quot;)
 128     protected OrderItemService orderItemService;
 129 
 130     @Resource(name = &quot;blFulfillmentGroupService&quot;)
 131     protected FulfillmentGroupService fulfillmentGroupService;
 132 
 133     @Resource(name = &quot;blOfferService&quot;)
 134     protected OfferService offerService;
 135 
 136     @Resource(name = &quot;blSecureOrderPaymentService&quot;)
 137     protected SecureOrderPaymentService securePaymentInfoService;
 138 
 139     @Resource(name = &quot;blMergeCartService&quot;)
 140     protected MergeCartService mergeCartService;
 141 
 142     @Resource(name = &quot;blOrderServiceExtensionManager&quot;)
 143     protected OrderServiceExtensionManager extensionManager;
 144 
 145     /* Workflows */
 146     @Resource(name = &quot;blAddItemWorkflow&quot;)
 147     protected Processor addItemWorkflow;
 148 
 149     @Resource(name = &quot;blUpdateProductOptionsForItemWorkflow&quot;)
 150     private Processor updateProductOptionsForItemWorkflow;
 151 
 152     @Resource(name = &quot;blUpdateItemWorkflow&quot;)
 153     protected Processor updateItemWorkflow;
 154 
 155     @Resource(name = &quot;blRemoveItemWorkflow&quot;)
 156     protected Processor removeItemWorkflow;
 157 
 158     @Resource(name = &quot;blTransactionManager&quot;)
 159     protected PlatformTransactionManager transactionManager;
 160 
 161     @Value(&quot;${pricing.retry.count.for.lock.failure}&quot;)
 162     protected int pricingRetryCountForLockFailure = 3;
 163 
 164     @Value(&quot;${pricing.retry.wait.interval.for.lock.failure}&quot;)
 165     protected long pricingRetryWaitIntervalForLockFailure = 500L;
 166 
 167     /**
 168      * Advanced setting. Should Hibernate auto flush before queries during an
<abbr title=" 169      * add-to-cart workflow. This should generally be able to be left false. This is a performance measure and"> 169      * add-to-cart workflow. This should generally be able to be left false. This is a performance measurðŸ”µ</abbr>
 170      * add-to-cart operations will be more efficient when this is false.
 171      */
 172     @Value(&quot;${auto.flush.on.query.during.add.to.cart:false}&quot;)
 173     protected boolean autoFlushAddToCart = false;
 174 
 175     /**
 176      * Advanced setting. Should Hibernate auto flush before queries during an
<abbr title=" 177      * update-cart workflow. This should generally be able to be left false. This is a performance measure and"> 177      * update-cart workflow. This should generally be able to be left false. This is a performance measurðŸ”µ</abbr>
 178      * update-cart operations will be more efficient when this is false.
 179      */
 180     @Value(&quot;${auto.flush.on.query.during.update.cart:false}&quot;)
 181     protected boolean autoFlushUpdateCart = false;
 182 
 183     /**
 184      * Advanced setting. Should Hibernate auto flush before queries during an
<abbr title=" 185      * remove-from-cart workflow. This should generally be able to be left false. This is a performance measure and"> 185      * remove-from-cart workflow. This should generally be able to be left false. This is a performance mðŸ”µ</abbr>
 186      * remove-from-cart operations will be more efficient when this is false.
 187      */
 188     @Value(&quot;${auto.flush.on.query.during.remove.from.cart:false}&quot;)
 189     protected boolean autoFlushRemoveFromCart = false;
 190 
 191     /**
 192      * Advanced setting. Should Hibernate auto flush before queries during an
<abbr title=" 193      * order save pricing flow. This should generally be able to be left false. This is a performance measure and"> 193      * order save pricing flow. This should generally be able to be left false. This is a performance meaðŸ”µ</abbr>
 194      * save operations will be more efficient when this is false.
 195      */
 196     @Value(&quot;${auto.flush.on.query.during.cart.pricing.save:false}&quot;)
 197     protected boolean autoFlushSaveCart = false;
 198 
 199     @PersistenceContext(unitName=&quot;blPU&quot;)
 200     protected EntityManager em;
 201 
 202     /* Fields */
 203     protected boolean moveNamedOrderItems = true;
 204 
 205     protected boolean deleteEmptyNamedOrders = true;
 206 
 207     protected Boolean automaticallyMergeLikeItems;
 208 
 209     @Resource(name = &quot;blOrderMultishipOptionService&quot;)
 210     protected OrderMultishipOptionService orderMultishipOptionService;
 211 
 212     @Resource(name = &quot;blOfferServiceExtensionManager&quot;)
 213     protected OfferServiceExtensionManager offerServiceExtensionManager;
 214 
 215     @Override
 216     @Transactional(&quot;blTransactionManager&quot;)
 217     public Order createNewCartForCustomer(Customer customer) {
 218 
 219 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 220         customer = customerService.saveCustomer(customer);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 221         return orderDao.createNewCartForCustomer(customer);</span>
 222 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 223 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 223 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwðŸ”µ</abbr></span>
 224 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 225 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 226         final Object lock = Objects.isNull(customer.getId()) ? customer : customer.getId();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 227         synchronized (lock) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 228             return orderDao.createNewCartForCustomer(customer);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 229         }</span>
 230 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 231 
 232     }
 233 
 234     @Override
 235     @Transactional(&quot;blTransactionManager&quot;)
 236     public Order createNamedOrderForCustomer(String name, Customer customer) {
 237         Order namedOrder = orderDao.create();
 238         namedOrder.setCustomer(customer);
 239         namedOrder.setName(name);
 240         namedOrder.setStatus(OrderStatus.NAMED);
 241 
 242         if (extensionManager != null) {
 243             extensionManager.getProxy().attachAdditionalDataToNewNamedCart(customer, namedOrder);
 244         }
 245 
 246         if (BroadleafRequestContext.getBroadleafRequestContext() != null) {
 247             namedOrder.setLocale(BroadleafRequestContext.getBroadleafRequestContext().getLocale());
 248         }
 249 
 250         return persist(namedOrder); // No need to price here
 251     }
 252 
 253     @Override
 254     public Order findNamedOrderForCustomer(String name, Customer customer) {
 255         return orderDao.readNamedOrderForCustomer(customer, name);
 256     }
 257 
 258     @Override
 259     public Order findOrderById(Long orderId) {
 260         return orderDao.readOrderById(orderId);
 261     }
 262 
 263     @Override
 264     public List&lt;Order&gt; findOrdersByIds(List&lt;Long&gt; orderIds) {
 265         return orderDao.readOrdersByIds(orderIds);
 266     }
 267 
 268     @Override
 269     public Order findOrderById(Long orderId, boolean refresh) {
 270         return orderDao.readOrderById(orderId, refresh);
 271     }
 272 
 273     @Override
 274     public Order getNullOrder() {
 275         return nullOrderFactory.getNullOrder();
 276     }
 277 
 278     @Override
 279     public Order findCartForCustomer(Customer customer) {
 280         return orderDao.readCartForCustomer(customer);
 281     }
 282 
 283     @Override
 284     public List&lt;Order&gt; findOrdersForCustomer(Customer customer) {
 285         return orderDao.readOrdersForCustomer(customer.getId());
 286     }
 287 
 288     @Override
 289     public List&lt;Order&gt; findOrdersForCustomer(Customer customer, OrderStatus status) {
 290         return orderDao.readOrdersForCustomer(customer, status);
 291     }
 292 
 293     @Override
 294     public Order findOrderByOrderNumber(String orderNumber) {
 295         return orderDao.readOrderByOrderNumber(orderNumber);
 296     }
 297 
 298     @Override
 299     public List&lt;Order&gt; findOrdersByDateRange(Date startDate, Date endDate) {
 300         return orderDao.readOrdersByDateRange(startDate, endDate);
 301     }
 302 
 303     @Override
 304     public List&lt;Order&gt; findOrdersByDaysCount(Integer daysCount, Integer batchSize) {
 305         return orderDao.readOrdersOlderThanDaysCount(daysCount, batchSize);
 306     }
 307 
 308     @Override
<abbr title=" 309     public List&lt;Order&gt; findOrdersForCustomersInDateRange(List&lt;Long&gt; customerIds, Date startDate, Date endDate) {"> 309     public List&lt;Order&gt; findOrdersForCustomersInDateRange(List&lt;Long&gt; customerIds, Date startDate, Date endðŸ”µ</abbr>
 310         return orderDao.readOrdersForCustomersInDateRange(customerIds, startDate, endDate);
 311     }
 312 
 313     @Override
 314     public List&lt;OrderPayment&gt; findPaymentsForOrder(Order order) {
 315         return paymentDao.readPaymentsForOrder(order);
 316     }
 317 
 318     @Override
 319     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 320     public OrderPayment addPaymentToOrder(Order order, OrderPayment payment, Referenced securePaymentInfo) {"> 320     public OrderPayment addPaymentToOrder(Order order, OrderPayment payment, Referenced securePaymentInfoðŸ”µ</abbr>
 321         payment.setOrder(order);
 322         order.getPayments().add(payment);
 323         order = persist(order);
 324         int paymentIndex = order.getPayments().size() - 1;
 325 
 326         if (securePaymentInfo != null) {
 327             securePaymentInfoService.save(securePaymentInfo);
 328         }
 329 
 330         return order.getPayments().get(paymentIndex);
 331     }
 332 
 333     @Override
 334     public Order save(Order order, boolean priceOrder, boolean repriceItems) throws PricingException {
 335         if (repriceItems) {
 336             order.updatePrices();
 337         }
 338         return save(order, priceOrder);
 339     }
 340 
 341     @Override
 342     public Order save(Order order, Boolean priceOrder) throws PricingException {
 343         //persist the order first
 344         TransactionStatus status = TransactionUtils.createTransaction(&quot;saveOrder&quot;,
 345                     TransactionDefinition.PROPAGATION_REQUIRED, transactionManager);
 346         try {
 347             order = persist(order);
 348             TransactionUtils.finalizeTransaction(status, transactionManager, false);
 349         } catch (RuntimeException ex) {
 350             TransactionUtils.finalizeTransaction(status, transactionManager, true);
 351             throw ex;
 352         }
 353 
 354         //make any pricing changes - possibly retrying with the persisted state if there&#x27;s a lock failure
 355         if (priceOrder) {
 356             int retryCount = 0;
 357             boolean isValid = false;
 358             while (!isValid) {
 359                 Session session = em.unwrap(Session.class);
 360                 FlushMode current = session.getHibernateFlushMode();
 361                 try {
 362                     if (!autoFlushSaveCart) {
<abbr title=" 363                         //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 363                         //Performance measure. Hibernate will sometimes perform an autoflush when performðŸ”µ</abbr>
<abbr title=" 364                         //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 364                         //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern aboutðŸ”µ</abbr>
 365                         //incorrect results because something has not been flushed to the database yet.
 366                         session.setHibernateFlushMode(FlushMode.MANUAL);
 367                     }
 368                     order = pricingService.executePricing(order);
 369                     isValid = true;
 370                 } catch (Exception ex) {
 371                     boolean isValidCause = false;
 372                     Throwable cause = ex;
 373                     while (!isValidCause) {
 374                         if (cause.getClass().equals(LockAcquisitionException.class)) {
 375                             isValidCause = true;
 376                         }
 377                         cause = cause.getCause();
 378                         if (cause == null) {
 379                             break;
 380                         }
 381                     }
 382                     if (isValidCause) {
 383                         if (LOG.isInfoEnabled()) {
<abbr title=" 384                             LOG.info(&quot;Problem acquiring lock during pricing call - attempting to price again.&quot;);"> 384                             LOG.info(&quot;Problem acquiring lock during pricing call - attempting to price agðŸ”µ</abbr>
 385                         }
 386                         isValid = false;
 387                         if (retryCount &gt;= pricingRetryCountForLockFailure) {
 388                             if (LOG.isInfoEnabled()) {
<abbr title=" 389                                 LOG.info(&quot;Problem acquiring lock during pricing call. Retry limit exceeded at (&quot; + retryCount + &quot;). Throwing exception.&quot;);"> 389                                 LOG.info(&quot;Problem acquiring lock during pricing call. Retry limit exceedeðŸ”µ</abbr>
 390                             }
 391                             if (ex instanceof PricingException) {
 392                                 throw (PricingException) ex;
 393                             } else {
 394                                 throw new PricingException(ex);
 395                             }
 396                         } else {
 397                             order = findOrderById(order.getId());
 398                             retryCount++;
 399                         }
 400                         try {
 401                             Thread.sleep(pricingRetryWaitIntervalForLockFailure);
 402                         } catch (Throwable e) {
 403                             //do nothing
 404                         }
 405                     } else {
 406                         if (ex instanceof PricingException) {
 407                             throw (PricingException) ex;
 408                         } else {
 409                             throw new PricingException(ex);
 410                         }
 411                     }
 412                 } finally {
 413                     if (!autoFlushSaveCart) {
 414                         session.setHibernateFlushMode(current);
 415                     }
 416                 }
 417             }
 418 
 419             //make the final save of the priced order
 420             status = TransactionUtils.createTransaction(&quot;saveOrder&quot;,
 421                                 TransactionDefinition.PROPAGATION_REQUIRED, transactionManager);
 422             Session session = em.unwrap(Session.class);
 423             FlushMode current = session.getHibernateFlushMode();
 424             try {
 425                 if (!autoFlushSaveCart) {
<abbr title=" 426                     //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 426                     //Performance measure. Hibernate will sometimes perform an autoflush when performing ðŸ”µ</abbr>
<abbr title=" 427                     //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 427                     //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queðŸ”µ</abbr>
 428                     //incorrect results because something has not been flushed to the database yet.
 429                     session.setHibernateFlushMode(FlushMode.MANUAL);
 430                 }
 431                 order = persist(order);
 432 
 433                 if (extensionManager != null) {
 434                     extensionManager.getProxy().attachAdditionalDataToOrder(order, priceOrder);
 435                 }
 436                 if (!autoFlushSaveCart) {
 437                     session.setFlushMode(current);
 438                 }
 439                 TransactionUtils.finalizeTransaction(status, transactionManager, false);
 440             } catch (RuntimeException ex) {
 441                 TransactionUtils.finalizeTransaction(status, transactionManager, true);
 442                 throw ex;
 443             } finally {
 444                 if (!autoFlushSaveCart &amp;&amp; !session.getFlushMode().equals(current)) {
 445                     session.setHibernateFlushMode(current);
 446                 }
 447             }
 448         }
 449 
 450         return order;
 451     }
 452 
 453     // This method exists to provide OrderService methods the ability to save an order
 454     // without having to worry about a PricingException being thrown.
 455     protected Order persist(Order order) {
 456         return orderDao.save(order);
 457     }
 458 
 459     @Override
 460     @Transactional(&quot;blTransactionManager&quot;)
 461     public void cancelOrder(Order order) {
 462         orderDao.delete(order);
 463     }
 464 
 465     @Override
 466     @Transactional(&quot;blTransactionManager&quot;)
 467     public void deleteOrder(Order order) {
 468         orderMultishipOptionService.deleteAllOrderMultishipOptions(order);
 469         orderDao.delete(order);
 470     }
 471 
 472     @Override
 473     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 474     public Order addOfferCode(Order order, OfferCode offerCode, boolean priceOrder) throws PricingException, OfferException {"> 474     public Order addOfferCode(Order order, OfferCode offerCode, boolean priceOrder) throws PricingExceptiðŸ”µ</abbr>
 475         ArrayList&lt;OfferCode&gt; offerCodes = new ArrayList&lt;OfferCode&gt;();
 476         offerCodes.add(offerCode);
 477         return addOfferCodes(order, offerCodes, priceOrder);
 478     }
 479 
 480     @Override
 481     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 482     public Order addOfferCodes(Order order, List&lt;OfferCode&gt; offerCodes, boolean priceOrder) throws PricingException, OfferException {"> 482     public Order addOfferCodes(Order order, List&lt;OfferCode&gt; offerCodes, boolean priceOrder) throws PricinðŸ”µ</abbr>
 483         preValidateCartOperation(order);
 484         Set&lt;Offer&gt; addedOffers = offerService.getUniqueOffersFromOrder(order);
 485         if (extensionManager != null) {
 486             extensionManager.getProxy().addOfferCodes(order, offerCodes, priceOrder);
 487         }
 488         if (offerCodes != null &amp;&amp; !offerCodes.isEmpty()) {
 489             for (OfferCode offerCode : offerCodes) {
 490 
<abbr title=" 491                 if (order.getAddedOfferCodes().contains(offerCode) || addedOffers.contains(offerCode.getOffer())) {"> 491                 if (order.getAddedOfferCodes().contains(offerCode) || addedOffers.contains(offerCode.getOðŸ”µ</abbr>
 492                     throw new OfferAlreadyAddedException(&quot;The offer has already been added.&quot;);
 493                 } else if (!offerService.verifyMaxCustomerUsageThreshold(order, offerCode)) {
<abbr title=" 494                     throw new OfferMaxUseExceededException(&quot;The customer has used this offer code more than the maximum allowed number of times.&quot;);"> 494                     throw new OfferMaxUseExceededException(&quot;The customer has used this offer code more thðŸ”µ</abbr>
 495                 } else if (!offerCode.isActive() || !offerCode.getOffer().isActive()) {
 496                     throw new OfferExpiredException(&quot;The offer has expired.&quot;);
 497                 }
 498 
 499                 order.getAddedOfferCodes().add(offerCode);
 500 
 501             }
 502             order = save(order, priceOrder);
 503         }
 504 
 505         return order;
 506     }
 507 
 508     @Override
 509     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 510     public Order removeOfferCode(Order order, OfferCode offerCode, boolean priceOrder) throws PricingException {"> 510     public Order removeOfferCode(Order order, OfferCode offerCode, boolean priceOrder) throws PricingExceðŸ”µ</abbr>
 511         order.getAddedOfferCodes().remove(offerCode);
 512         offerServiceExtensionManager.removeOfferCodeFromOrder(offerCode, order);
 513         order = save(order, priceOrder);
 514         return order;
 515     }
 516 
 517     @Override
 518     @Transactional(&quot;blTransactionManager&quot;)
 519     public Order removeAllOfferCodes(Order order, boolean priceOrder) throws PricingException {
 520          order.getAddedOfferCodes().clear();
 521          order = save(order, priceOrder);
 522          return order;
 523     }
 524 
 525     @Override
<abbr title=" 526     @ManagedAttribute(description=&quot;The delete empty named order after adding items to cart attribute&quot;, currencyTimeLimit=15)"> 526     @ManagedAttribute(description=&quot;The delete empty named order after adding items to cart attribute&quot;, cuðŸ”µ</abbr>
 527     public void setDeleteEmptyNamedOrders(boolean deleteEmptyNamedOrders) {
 528         this.deleteEmptyNamedOrders = deleteEmptyNamedOrders;
 529     }
 530 
 531     @Override
 532     public OrderItem findLastMatchingItem(Order order, Long skuId, Long productId) {
 533         if (order.getOrderItems() != null) {
 534             for (int i=(order.getOrderItems().size()-1); i &gt;= 0; i--) {
 535                 OrderItem currentItem = (order.getOrderItems().get(i));
 536                 if (currentItem instanceof DiscreteOrderItem) {
 537                     DiscreteOrderItem discreteItem = (DiscreteOrderItem) currentItem;
 538                     if (skuId != null) {
<abbr title=" 539                         if (discreteItem.getSku() != null &amp;&amp; skuId.equals(discreteItem.getSku().getId())) {"> 539                         if (discreteItem.getSku() != null &amp;&amp; skuId.equals(discreteItem.getSku().getId()))ðŸ”µ</abbr>
 540                             return discreteItem;
 541                         }
<abbr title=" 542                     } else if (productId != null &amp;&amp; discreteItem.getProduct() != null &amp;&amp; productId.equals(discreteItem.getProduct().getId())) {"> 542                     } else if (productId != null &amp;&amp; discreteItem.getProduct() != null &amp;&amp; productId.equalsðŸ”µ</abbr>
 543                         return discreteItem;
 544                     }
 545 
 546                 } else if (currentItem instanceof BundleOrderItem) {
 547                     BundleOrderItem bundleItem = (BundleOrderItem) currentItem;
 548                     if (skuId != null) {
 549                         if (bundleItem.getSku() != null &amp;&amp; skuId.equals(bundleItem.getSku().getId())) {
 550                             return bundleItem;
 551                         }
<abbr title=" 552                     } else if (productId != null &amp;&amp; bundleItem.getProduct() != null &amp;&amp; productId.equals(bundleItem.getProduct().getId())) {"> 552                     } else if (productId != null &amp;&amp; bundleItem.getProduct() != null &amp;&amp; productId.equals(bðŸ”µ</abbr>
 553                         return bundleItem;
 554                     }
 555                 }
 556             }
 557         }
 558         return null;
 559     }
 560 
 561     @Override
 562     @Transactional(&quot;blTransactionManager&quot;)
 563     public Order confirmOrder(Order order) {
 564         return orderDao.submitOrder(order);
 565     }
 566 
 567     @Override
 568     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 569     public Order addAllItemsFromNamedOrder(Order namedOrder, boolean priceOrder) throws RemoveFromCartException, AddToCartException {"> 569     public Order addAllItemsFromNamedOrder(Order namedOrder, boolean priceOrder) throws RemoveFromCartExcðŸ”µ</abbr>
 570         Order cartOrder = orderDao.readCartForCustomer(namedOrder.getCustomer());
 571         if (cartOrder == null) {
 572             cartOrder = createNewCartForCustomer(namedOrder.getCustomer());
 573         }
 574         List&lt;OrderItem&gt; items = new ArrayList&lt;OrderItem&gt;(namedOrder.getOrderItems());
 575 
 576         // Remove any order items that are children
 577         CollectionUtils.filter(items,  new TypedPredicate&lt;OrderItem&gt;() {
 578             @Override
 579             public boolean eval(OrderItem orderItem) {
 580                 return orderItem.getParentOrderItem() == null;
 581             }
 582         });
 583         for (OrderItem item : items) {
<abbr title=" 584             OrderItemRequestDTO orderItemRequest = orderItemService.buildOrderItemRequestDTOFromOrderItem(item);"> 584             OrderItemRequestDTO orderItemRequest = orderItemService.buildOrderItemRequestDTOFromOrderItemðŸ”µ</abbr>
 585             cartOrder = addItem(cartOrder.getId(), orderItemRequest, priceOrder);
 586 
 587             if (moveNamedOrderItems) {
 588                 removeItem(namedOrder.getId(), item.getId(), false);
 589             }
 590         }
 591 
 592         if (deleteEmptyNamedOrders) {
 593             cancelOrder(namedOrder);
 594         }
 595 
 596         return cartOrder;
 597     }
 598 
 599     @Override
 600     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 601     public Order addItemFromNamedOrder(Order namedOrder, OrderItem item, boolean priceOrder) throws RemoveFromCartException, AddToCartException {"> 601     public Order addItemFromNamedOrder(Order namedOrder, OrderItem item, boolean priceOrder) throws RemovðŸ”µ</abbr>
 602         Order cartOrder = orderDao.readCartForCustomer(namedOrder.getCustomer());
 603         if (cartOrder == null) {
 604             cartOrder = createNewCartForCustomer(namedOrder.getCustomer());
 605         }
 606 
<abbr title=" 607         OrderItemRequestDTO orderItemRequest = orderItemService.buildOrderItemRequestDTOFromOrderItem(item);"> 607         OrderItemRequestDTO orderItemRequest = orderItemService.buildOrderItemRequestDTOFromOrderItem(iteðŸ”µ</abbr>
 608         cartOrder = addItem(cartOrder.getId(), orderItemRequest, priceOrder);
 609 
 610         if (moveNamedOrderItems) {
 611             removeItem(namedOrder.getId(), item.getId(), false);
 612         }
 613 
 614         if (namedOrder.getOrderItems().size() == 0 &amp;&amp; deleteEmptyNamedOrders) {
 615             cancelOrder(namedOrder);
 616         }
 617 
 618         return cartOrder;
 619     }
 620 
 621     @Override
 622     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 623     public Order addItemFromNamedOrder(Order namedOrder, OrderItem item, int quantity, boolean priceOrder) throws RemoveFromCartException, AddToCartException, UpdateCartException {"> 623     public Order addItemFromNamedOrder(Order namedOrder, OrderItem item, int quantity, boolean priceOrderðŸ”µ</abbr>
 624         // Validate that the quantity requested makes sense
 625         if (quantity &lt; 1 || quantity &gt; item.getQuantity()) {
 626             throw new IllegalArgumentException(&quot;Cannot move 0 or less quantity&quot;);
 627         } else if (quantity == item.getQuantity()) {
 628             return addItemFromNamedOrder(namedOrder, item, priceOrder);
 629         }
 630 
 631         Order cartOrder = orderDao.readCartForCustomer(namedOrder.getCustomer());
 632         if (cartOrder == null) {
 633             cartOrder = createNewCartForCustomer(namedOrder.getCustomer());
 634         }
 635 
<abbr title=" 636         OrderItemRequestDTO orderItemRequest = orderItemService.buildOrderItemRequestDTOFromOrderItem(item);"> 636         OrderItemRequestDTO orderItemRequest = orderItemService.buildOrderItemRequestDTOFromOrderItem(iteðŸ”µ</abbr>
 637         orderItemRequest.setQuantity(quantity);
 638         cartOrder = addItem(cartOrder.getId(), orderItemRequest, priceOrder);
 639 
 640         if (moveNamedOrderItems) {
 641             // Update the old item to its new quantity only if we&#x27;re moving items
 642             OrderItemRequestDTO orderItemRequestDTO = new OrderItemRequestDTO();
 643             orderItemRequestDTO.setOrderItemId(item.getId());
 644             orderItemRequestDTO.setQuantity(item.getQuantity() - quantity);
 645             updateItemQuantity(namedOrder.getId(), orderItemRequestDTO, false);
 646         }
 647         return cartOrder;
 648     }
 649 
 650     @Override
 651     @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 652     public OrderItem addGiftWrapItemToOrder(Order order, GiftWrapOrderItemRequest itemRequest, boolean priceOrder) throws PricingException {"> 652     public OrderItem addGiftWrapItemToOrder(Order order, GiftWrapOrderItemRequest itemRequest, boolean prðŸ”µ</abbr>
 653         GiftWrapOrderItem item = orderItemService.createGiftWrapOrderItem(itemRequest);
 654         item.setOrder(order);
 655         item = (GiftWrapOrderItem) orderItemService.saveOrderItem(item);
 656 
 657         order.getOrderItems().add(item);
 658         order = save(order, priceOrder);
 659 
 660         return item;
 661     }
 662 
 663     @Override
 664     @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = {AddToCartException.class})
<abbr title=" 665     public Order addItem(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throws AddToCartException {"> 665     public Order addItem(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throwðŸ”µ</abbr>
 666         // Don&#x27;t allow overrides from this method.
 667         orderItemRequestDTO.setOverrideRetailPrice(null);
 668         orderItemRequestDTO.setOverrideSalePrice(null);
 669         return addItemWithPriceOverrides(orderId, orderItemRequestDTO, priceOrder);
 670     }
 671 
 672     @Override
 673     @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = { AddToCartException.class })
<abbr title=" 674     public Order addItemWithPriceOverrides(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throws AddToCartException {"> 674     public Order addItemWithPriceOverrides(Long orderId, OrderItemRequestDTO orderItemRequestDTO, booleanðŸ”µ</abbr>
 675         Order order = findOrderById(orderId);
 676         preValidateCartOperation(order);
 677         if (getAutomaticallyMergeLikeItems()) {
 678             OrderItem item = findMatchingItem(order, orderItemRequestDTO);
 679             if (item != null &amp;&amp; item.getParentOrderItem() == null) {
 680                 orderItemRequestDTO.setQuantity(item.getQuantity() + orderItemRequestDTO.getQuantity());
 681                 orderItemRequestDTO.setOrderItemId(item.getId());
 682                 try {
 683                     return updateItemQuantity(orderId, orderItemRequestDTO, priceOrder);
 684                 } catch (RemoveFromCartException e) {
<abbr title=" 685                     throw new AddToCartException(&quot;Unexpected error - system tried to remove item while adding to cart&quot;, e);"> 685                     throw new AddToCartException(&quot;Unexpected error - system tried to remove item while adðŸ”µ</abbr>
 686                 } catch (UpdateCartException e) {
 687                     throw new AddToCartException(&quot;Could not update quantity for matched item&quot;, e);
 688                 }
 689             }
 690         }
 691         try {
<abbr title=" 692             // We only want to price on the last addition for performance reasons and only if the user asked for it."> 692             // We only want to price on the last addition for performance reasons and only if the user asðŸ”µ</abbr>
 693             int numAdditionRequests = priceOrder ? (getTotalChildOrderItems(orderItemRequestDTO)) : -1;
 694             int currentAddition = 1;
 695 
<abbr title=" 696             CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestDTO, currentAddition == numAdditionRequests);"> 696             CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItðŸ”µ</abbr>
 697 
 698             Session session = em.unwrap(Session.class);
 699             FlushMode current = session.getHibernateFlushMode();
 700             if (!autoFlushAddToCart) {
<abbr title=" 701                 //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 701                 //Performance measure. Hibernate will sometimes perform an autoflush when performing querðŸ”µ</abbr>
<abbr title=" 702                 //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 702                 //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queriesðŸ”µ</abbr>
 703                 //incorrect results because something has not been flushed to the database yet.
 704                 session.setHibernateFlushMode(FlushMode.MANUAL);
 705             }
 706             ProcessContext&lt;CartOperationRequest&gt; context;
 707             try {
<abbr title=" 708                 context = (ProcessContext&lt;CartOperationRequest&gt;) addItemWorkflow.doActivities(cartOpRequest);"> 708                 context = (ProcessContext&lt;CartOperationRequest&gt;) addItemWorkflow.doActivities(cartOpRequeðŸ”µ</abbr>
 709             } finally {
 710                 if (!autoFlushAddToCart) {
 711                     session.setHibernateFlushMode(current);
 712                 }
 713             }
 714 
 715             List&lt;ActivityMessageDTO&gt; orderMessages = new ArrayList&lt;ActivityMessageDTO&gt;();
 716             orderMessages.addAll(((ActivityMessages) context).getActivityMessages());
 717 
 718             // Update the orderItemRequest incase it changed during the initial add to cart workflow
 719             orderItemRequestDTO = context.getSeedData().getItemRequest();
 720             numAdditionRequests = priceOrder ? (getTotalChildOrderItems(orderItemRequestDTO) - 1) : -1;
<abbr title=" 721             addChildItems(orderItemRequestDTO, numAdditionRequests, currentAddition, context, orderMessages);"> 721             addChildItems(orderItemRequestDTO, numAdditionRequests, currentAddition, context, orderMessagðŸ”µ</abbr>
 722 
 723             context.getSeedData().getOrder().setOrderMessages(orderMessages);
 724             return context.getSeedData().getOrder();
 725         } catch (WorkflowException e) {
 726             throw new AddToCartException(&quot;Could not add to cart&quot;, getCartOperationExceptionRootCause(e));
 727         }
 728 
 729     }
 730 
 731     @Override
 732     public int getTotalChildOrderItems(OrderItemRequestDTO orderItemRequestDTO) {
 733         int count = 1;
 734         for (OrderItemRequestDTO childRequest : orderItemRequestDTO.getChildOrderItems()) {
 735             count += getTotalChildOrderItems(childRequest);
 736         }
 737         return count;
 738     }
 739 
 740     @Override
<abbr title=" 741     public void addChildItems(OrderItemRequestDTO orderItemRequestDTO, int numAdditionRequests, int currentAddition, ProcessContext&lt;CartOperationRequest&gt; context, List&lt;ActivityMessageDTO&gt; orderMessages) throws WorkflowException {"> 741     public void addChildItems(OrderItemRequestDTO orderItemRequestDTO, int numAdditionRequests, int curreðŸ”µ</abbr>
 742         if (CollectionUtils.isNotEmpty(orderItemRequestDTO.getChildOrderItems())) {
 743             Long parentOrderItemId = context.getSeedData().getOrderItem().getId();
 744             for (OrderItemRequestDTO childRequest : orderItemRequestDTO.getChildOrderItems()) {
 745                 childRequest.setParentOrderItemId(parentOrderItemId);
 746                 currentAddition++;
 747 
 748                 if (childRequest.getQuantity() &gt; 0) {
<abbr title=" 749                     CartOperationRequest childCartOpRequest = new CartOperationRequest(context.getSeedData().getOrder(), childRequest, currentAddition == numAdditionRequests);"> 749                     CartOperationRequest childCartOpRequest = new CartOperationRequest(context.getSeedDatðŸ”µ</abbr>
 750                     Session session = em.unwrap(Session.class);
 751                     FlushMode current = session.getHibernateFlushMode();
 752                     if (!autoFlushAddToCart) {
<abbr title=" 753                         //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 753                         //Performance measure. Hibernate will sometimes perform an autoflush when performðŸ”µ</abbr>
<abbr title=" 754                         //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 754                         //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern aboutðŸ”µ</abbr>
 755                         //incorrect results because something has not been flushed to the database yet.
 756                         session.setHibernateFlushMode(FlushMode.MANUAL);
 757                     }
 758                     ProcessContext&lt;CartOperationRequest&gt; childContext;
 759                     try {
<abbr title=" 760                         childContext = (ProcessContext&lt;CartOperationRequest&gt;) addItemWorkflow.doActivities(childCartOpRequest);"> 760                         childContext = (ProcessContext&lt;CartOperationRequest&gt;) addItemWorkflow.doActivitieðŸ”µ</abbr>
 761                     } finally {
 762                         if (!autoFlushAddToCart) {
 763                             session.setHibernateFlushMode(current);
 764                         }
 765                     }
 766                     orderMessages.addAll(((ActivityMessages) childContext).getActivityMessages());
 767 
<abbr title=" 768                     addChildItems(childRequest, numAdditionRequests, currentAddition, childContext, orderMessages);"> 768                     addChildItems(childRequest, numAdditionRequests, currentAddition, childContext, orderðŸ”µ</abbr>
 769                 }
 770             }
 771         }
 772     }
 773 
 774     @Override
<abbr title=" 775     public void addDependentOrderItem(OrderItemRequestDTO parentOrderItemRequest, OrderItemRequestDTO dependentOrderItem) {"> 775     public void addDependentOrderItem(OrderItemRequestDTO parentOrderItemRequest, OrderItemRequestDTO depðŸ”µ</abbr>
 776         parentOrderItemRequest.getChildOrderItems().add(dependentOrderItem);
<abbr title=" 777         Collections.sort(parentOrderItemRequest.getChildOrderItems(), new Comparator&lt;OrderItemRequestDTO&gt;() {"> 777         Collections.sort(parentOrderItemRequest.getChildOrderItems(), new Comparator&lt;OrderItemRequestDTO&gt;ðŸ”µ</abbr>
 778             @Override
 779             public int compare(OrderItemRequestDTO o1, OrderItemRequestDTO o2) {
<abbr title=" 780                 BigDecimal o1DisplayOrder = new BigDecimal(o1.getAdditionalAttributes().get(&quot;addOnDisplayOrder&quot;));"> 780                 BigDecimal o1DisplayOrder = new BigDecimal(o1.getAdditionalAttributes().get(&quot;addOnDisplayðŸ”µ</abbr>
<abbr title=" 781                 BigDecimal o2DisplayOrder = new BigDecimal(o2.getAdditionalAttributes().get(&quot;addOnDisplayOrder&quot;));"> 781                 BigDecimal o2DisplayOrder = new BigDecimal(o2.getAdditionalAttributes().get(&quot;addOnDisplayðŸ”µ</abbr>
 782                 return o1DisplayOrder.compareTo(o2DisplayOrder);
 783             }
 784         });
 785     }
 786 
 787     @Override
<abbr title=" 788     @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = {UpdateCartException.class, RemoveFromCartException.class})"> 788     @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = {UpdateCartException.class, RemoveFromCaðŸ”µ</abbr>
<abbr title=" 789     public Order updateItemQuantity(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throws UpdateCartException, RemoveFromCartException {"> 789     public Order updateItemQuantity(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOðŸ”µ</abbr>
 790         Order order = findOrderById(orderId);
 791         preValidateCartOperation(order);
 792         preValidateUpdateQuantityOperation(findOrderById(orderId), orderItemRequestDTO);
 793         if (orderItemRequestDTO.getQuantity() == 0) {
 794             return removeItem(orderId, orderItemRequestDTO.getOrderItemId(), priceOrder);
 795         }
 796 
 797         try {
<abbr title=" 798             CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestDTO, priceOrder);"> 798             CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItðŸ”µ</abbr>
 799             Session session = em.unwrap(Session.class);
 800             FlushMode current = session.getHibernateFlushMode();
 801             if (!autoFlushUpdateCart) {
<abbr title=" 802                 //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 802                 //Performance measure. Hibernate will sometimes perform an autoflush when performing querðŸ”µ</abbr>
<abbr title=" 803                 //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 803                 //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queriesðŸ”µ</abbr>
 804                 //incorrect results because something has not been flushed to the database yet.
 805                 session.setHibernateFlushMode(FlushMode.MANUAL);
 806             }
 807             ProcessContext&lt;CartOperationRequest&gt; context;
 808             try {
<abbr title=" 809                 context = (ProcessContext&lt;CartOperationRequest&gt;) updateItemWorkflow.doActivities(cartOpRequest);"> 809                 context = (ProcessContext&lt;CartOperationRequest&gt;) updateItemWorkflow.doActivities(cartOpReðŸ”µ</abbr>
 810             } finally {
 811                 if (!autoFlushUpdateCart) {
 812                     session.setHibernateFlushMode(current);
 813                 }
 814             }
<abbr title=" 815             context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getActivityMessages());"> 815             context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getAcðŸ”µ</abbr>
 816             return context.getSeedData().getOrder();
 817         } catch (WorkflowException e) {
<abbr title=" 818             throw new UpdateCartException(&quot;Could not update cart quantity&quot;, getCartOperationExceptionRootCause(e));"> 818             throw new UpdateCartException(&quot;Could not update cart quantity&quot;, getCartOperationExceptionRootðŸ”µ</abbr>
 819         }
 820     }
 821 
 822     @Override
 823     @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = {RemoveFromCartException.class})
<abbr title=" 824     public Order removeItem(Long orderId, Long orderItemId, boolean priceOrder) throws RemoveFromCartException {"> 824     public Order removeItem(Long orderId, Long orderItemId, boolean priceOrder) throws RemoveFromCartExceðŸ”µ</abbr>
 825         preValidateCartOperation(findOrderById(orderId));
 826         try {
 827             OrderItem oi = orderItemService.readOrderItemById(orderItemId);
 828             if (oi == null) {
 829                 throw new WorkflowException(new ItemNotFoundException());
 830             }
 831             List&lt;Long&gt; childrenToRemove = new ArrayList&lt;Long&gt;();
 832             if (oi instanceof BundleOrderItem) {
 833                 List&lt;DiscreteOrderItem&gt; bundledItems = ((BundleOrderItem) oi).getDiscreteOrderItems();
 834                 for (DiscreteOrderItem doi : bundledItems) {
 835                     findAllChildrenToRemove(childrenToRemove, doi);
 836                 }
 837             } else {
 838                 findAllChildrenToRemove(childrenToRemove, oi);
 839             }
 840             for (Long childToRemove : childrenToRemove) {
 841                 removeItemInternal(orderId, childToRemove, false);
 842             }
 843 
 844             return removeItemInternal(orderId, orderItemId, priceOrder);
 845         } catch (WorkflowException e) {
<abbr title=" 846             throw new RemoveFromCartException(&quot;Could not remove from cart&quot;, getCartOperationExceptionRootCause(e));"> 846             throw new RemoveFromCartException(&quot;Could not remove from cart&quot;, getCartOperationExceptionRootðŸ”µ</abbr>
 847         }
 848     }
 849 
 850     protected void findAllChildrenToRemove(List&lt;Long&gt; childrenToRemove, OrderItem orderItem){
 851         if (CollectionUtils.isNotEmpty(orderItem.getChildOrderItems())) {
 852             for (OrderItem childOrderItem : orderItem.getChildOrderItems()) {
 853                 findAllChildrenToRemove(childrenToRemove, childOrderItem);
 854                 childrenToRemove.add(childOrderItem.getId());
 855             }
 856         }
 857     }
 858 
<abbr title=" 859     protected Order removeItemInternal(Long orderId, Long orderItemId, boolean priceOrder) throws WorkflowException {"> 859     protected Order removeItemInternal(Long orderId, Long orderItemId, boolean priceOrder) throws WorkfloðŸ”µ</abbr>
 860         OrderItemRequestDTO orderItemRequestDTO = new OrderItemRequestDTO();
 861         orderItemRequestDTO.setOrderItemId(orderItemId);
<abbr title=" 862         CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestDTO, priceOrder);"> 862         CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemReðŸ”µ</abbr>
 863         Session session = em.unwrap(Session.class);
 864         FlushMode current = session.getHibernateFlushMode();
 865         if (!autoFlushRemoveFromCart) {
<abbr title=" 866             //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 866             //Performance measure. Hibernate will sometimes perform an autoflush when performing query opðŸ”µ</abbr>
<abbr title=" 867             //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 867             //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in ðŸ”µ</abbr>
 868             //incorrect results because something has not been flushed to the database yet.
 869             session.setHibernateFlushMode(FlushMode.MANUAL);
 870         }
 871         ProcessContext&lt;CartOperationRequest&gt; context;
 872         try {
<abbr title=" 873             context = (ProcessContext&lt;CartOperationRequest&gt;) removeItemWorkflow.doActivities(cartOpRequest);"> 873             context = (ProcessContext&lt;CartOperationRequest&gt;) removeItemWorkflow.doActivities(cartOpRequesðŸ”µ</abbr>
 874         } finally {
 875             if (!autoFlushRemoveFromCart) {
 876                 session.setHibernateFlushMode(current);
 877             }
 878         }
<abbr title=" 879         context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getActivityMessages());"> 879         context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getActiviðŸ”µ</abbr>
 880         return context.getSeedData().getOrder();
 881     }
 882 
 883     @Override
 884     @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = { RemoveFromCartException.class })
 885     public Order removeInactiveItems(Long orderId, boolean priceOrder) throws RemoveFromCartException {
 886         Order order = findOrderById(orderId);
 887         try {
 888 
 889             for (OrderItem currentItem : new ArrayList&lt;OrderItem&gt;(order.getOrderItems())) {
 890                 if (!currentItem.isSkuActive()) {
 891                     removeItem(orderId, currentItem.getId(), priceOrder);
 892                 }
 893             }
 894 
 895         } catch (Exception e) {
 896             throw new RemoveFromCartException(&quot;Could not remove from cart&quot;, e.getCause());
 897         }
 898         return findOrderById(orderId);
 899     }
 900 
 901     @Override
 902     public boolean getAutomaticallyMergeLikeItems() {
 903 
 904         if (automaticallyMergeLikeItems != null) {
 905             return automaticallyMergeLikeItems;
 906         }
 907 
 908         return BLCSystemProperty.resolveBooleanSystemProperty(&quot;automatically.merge.like.items&quot;, true);
 909     }
 910 
 911     @Override
 912     public void setAutomaticallyMergeLikeItems(boolean automaticallyMergeLikeItems) {
 913         this.automaticallyMergeLikeItems = automaticallyMergeLikeItems;
 914     }
 915 
 916     @Override
<abbr title=" 917     @ManagedAttribute(description=&quot;The move item from named order when adding to the cart attribute&quot;, currencyTimeLimit=15)"> 917     @ManagedAttribute(description=&quot;The move item from named order when adding to the cart attribute&quot;, curðŸ”µ</abbr>
 918     public boolean isMoveNamedOrderItems() {
 919         return moveNamedOrderItems;
 920     }
 921 
 922     @Override
<abbr title=" 923     @ManagedAttribute(description=&quot;The move item from named order when adding to the cart attribute&quot;, currencyTimeLimit=15)"> 923     @ManagedAttribute(description=&quot;The move item from named order when adding to the cart attribute&quot;, curðŸ”µ</abbr>
 924     public void setMoveNamedOrderItems(boolean moveNamedOrderItems) {
 925         this.moveNamedOrderItems = moveNamedOrderItems;
 926     }
 927 
 928     @Override
<abbr title=" 929     @ManagedAttribute(description=&quot;The delete empty named order after adding items to cart attribute&quot;, currencyTimeLimit=15)"> 929     @ManagedAttribute(description=&quot;The delete empty named order after adding items to cart attribute&quot;, cuðŸ”µ</abbr>
 930     public boolean isDeleteEmptyNamedOrders() {
 931         return deleteEmptyNamedOrders;
 932     }
 933 
 934     @Override
 935     @Transactional(&quot;blTransactionManager&quot;)
 936     public void removeAllPaymentsFromOrder(Order order) {
 937         removePaymentsFromOrder(order, null);
 938     }
 939 
 940     @Override
 941     @Transactional(&quot;blTransactionManager&quot;)
 942     public void removePaymentsFromOrder(Order order, PaymentType paymentInfoType) {
 943         List&lt;OrderPayment&gt; infos = new ArrayList&lt;OrderPayment&gt;();
 944         for (OrderPayment paymentInfo : order.getPayments()) {
 945             if (paymentInfoType == null || paymentInfoType.equals(paymentInfo.getType())) {
 946                 infos.add(paymentInfo);
 947             }
 948         }
 949         order.getPayments().removeAll(infos);
 950         for (OrderPayment paymentInfo : infos) {
 951             try {
<abbr title=" 952                 securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentInfo.getReferenceNumber(), paymentInfo.getType());"> 952                 securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentInfo.getReferenceNumber(),ðŸ”µ</abbr>
 953             } catch (WorkflowException e) {
 954                 // do nothing--this is an acceptable condition
 955                 LOG.debug(&quot;No secure payment is associated with the OrderPayment&quot;, e);
 956             }
 957             order.getPayments().remove(paymentInfo);
 958             paymentInfo = paymentDao.readPaymentById(paymentInfo.getId());
 959             paymentDao.delete(paymentInfo);
 960         }
 961     }
 962 
 963     @Override
 964     @Transactional(&quot;blTransactionManager&quot;)
 965     public void removeCreditCardPaymentsFromOrder(Order order) {
 966         List&lt;OrderPayment&gt; infos = new ArrayList&lt;OrderPayment&gt;();
 967         for (OrderPayment paymentInfo : order.getPayments()) {
 968             if (paymentInfo.getType().isCreditCardType()) {
 969                 infos.add(paymentInfo);
 970             }
 971         }
 972         order.getPayments().removeAll(infos);
 973         for (OrderPayment paymentInfo : infos) {
 974             try {
<abbr title=" 975                 securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentInfo.getReferenceNumber(), paymentInfo.getType());"> 975                 securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentInfo.getReferenceNumber(),ðŸ”µ</abbr>
 976             } catch (WorkflowException e) {
 977                 // do nothing--this is an acceptable condition
 978                 LOG.debug(&quot;No secure payment is associated with the OrderPayment&quot;, e);
 979             }
 980             order.getPayments().remove(paymentInfo);
 981             paymentInfo = paymentDao.readPaymentById(paymentInfo.getId());
 982             paymentDao.delete(paymentInfo);
 983         }
 984     }
 985 
 986     @Override
 987     @Transactional(&quot;blTransactionManager&quot;)
 988     public void removePaymentFromOrder(Order order, OrderPayment payment){
 989         OrderPayment paymentToRemove = null;
 990         for (OrderPayment info : order.getPayments()){
 991             if (info.equals(payment)){
 992                 paymentToRemove = info;
 993             }
 994         }
 995         if (paymentToRemove != null){
 996             try {
<abbr title=" 997                 securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentToRemove.getReferenceNumber(), payment.getType());"> 997                 securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentToRemove.getReferenceNumbeðŸ”µ</abbr>
 998             } catch (WorkflowException e) {
 999                 // do nothing--this is an acceptable condition
1000                 LOG.debug(&quot;No secure payment is associated with the OrderPayment&quot;, e);
1001             }
1002             order.getPayments().remove(paymentToRemove);
1003             payment = paymentDao.readPaymentById(paymentToRemove.getId());
1004             paymentDao.delete(payment);
1005         }
1006     }
1007 
1008     /**
1009      * This method will return the exception that is immediately below the deepest
1010      * WorkflowException in the current stack trace.
1011      *
1012      * @param e the workflow exception that contains the requested root cause
1013      * @return the root cause of the workflow exception
1014      */
1015     protected Throwable getCartOperationExceptionRootCause(WorkflowException e) {
1016         Throwable cause = e.getCause();
1017         if (cause == null) {
1018             return e;
1019         }
1020 
1021         Throwable currentCause = cause;
1022         while (currentCause.getCause() != null) {
1023             currentCause = currentCause.getCause();
1024             if (currentCause instanceof WorkflowException) {
1025                 cause = currentCause.getCause();
1026             }
1027         }
1028 
1029         return cause;
1030     }
1031 
1032     /**
1033      * Returns true if the two items attributes exactly match.
1034      * @param item1Attributes
1035      * @param item2
1036      * @return
1037      */
<abbr title="1038     protected boolean compareAttributes(Map&lt;String, OrderItemAttribute&gt; item1Attributes, OrderItemRequestDTO item2) {">1038     protected boolean compareAttributes(Map&lt;String, OrderItemAttribute&gt; item1Attributes, OrderItemRequestðŸ”µ</abbr>
1039         int item1AttributeSize = item1Attributes == null ? 0 : item1Attributes.size();
<abbr title="1040         int item2AttributeSize = item2.getItemAttributes() == null ? 0 : item2.getItemAttributes().size();">1040         int item2AttributeSize = item2.getItemAttributes() == null ? 0 : item2.getItemAttributes().size()ðŸ”µ</abbr>
1041 
1042         if (item1AttributeSize != item2AttributeSize) {
1043             return false;
1044         }
1045 
1046         for (String key : item2.getItemAttributes().keySet()) {
<abbr title="1047             String itemOneValue = (item1Attributes.get(key) == null) ? null : item1Attributes.get(key).getValue();">1047             String itemOneValue = (item1Attributes.get(key) == null) ? null : item1Attributes.get(key).geðŸ”µ</abbr>
1048             String itemTwoValue = item2.getItemAttributes().get(key);
1049             if (!itemTwoValue.equals(itemOneValue)) {
1050                 return false;
1051             }
1052         }
1053         return true;
1054     }
1055 
<abbr title="1056     protected boolean itemMatches(Sku item1Sku, Product item1Product, Map&lt;String, OrderItemAttribute&gt; item1Attributes,">1056     protected boolean itemMatches(Sku item1Sku, Product item1Product, Map&lt;String, OrderItemAttribute&gt; iteðŸ”µ</abbr>
1057             OrderItemRequestDTO item2) {
1058         // Must match on SKU and options
1059         if (item1Sku != null &amp;&amp; item2.getSkuId() != null) {
1060             if (item1Sku.getId().equals(item2.getSkuId())) {
1061                 return true;
1062             }
1063         } else {
1064             if (item1Product != null &amp;&amp; item2.getProductId() != null) {
1065                 if (item1Product.getId().equals(item2.getProductId())) {
1066                     return compareAttributes(item1Attributes, item2);
1067                 }
1068             }
1069         }
1070         return false;
1071     }
1072 
1073     protected OrderItem findMatchingItem(Order order, OrderItemRequestDTO itemToFind) {
1074         if (order == null) {
1075             return null;
1076         }
1077         for (OrderItem currentItem : order.getOrderItems()) {
1078             if (currentItem instanceof DiscreteOrderItem) {
1079                 DiscreteOrderItem discreteItem = (DiscreteOrderItem) currentItem;
<abbr title="1080                 if (itemMatches(discreteItem.getSku(), discreteItem.getProduct(), discreteItem.getOrderItemAttributes(),">1080                 if (itemMatches(discreteItem.getSku(), discreteItem.getProduct(), discreteItem.getOrderItðŸ”µ</abbr>
1081                         itemToFind)) {
1082                     return discreteItem;
1083                 }
1084             } else if (currentItem instanceof BundleOrderItem) {
1085                 BundleOrderItem bundleItem = (BundleOrderItem) currentItem;
1086                 if (itemMatches(bundleItem.getSku(), bundleItem.getProduct(), null, itemToFind)) {
1087                     return bundleItem;
1088                 }
1089             }
1090         }
1091         return null;
1092     }
1093 
1094     @Override
1095     @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = { UpdateCartException.class })
<abbr title="1096     public Order updateProductOptionsForItem(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throws UpdateCartException {">1096     public Order updateProductOptionsForItem(Long orderId, OrderItemRequestDTO orderItemRequestDTO, booleðŸ”µ</abbr>
1097         try {
<abbr title="1098             CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestDTO, priceOrder);">1098             CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItðŸ”µ</abbr>
<abbr title="1099             ProcessContext&lt;CartOperationRequest&gt; context = (ProcessContext&lt;CartOperationRequest&gt;) updateProductOptionsForItemWorkflow.doActivities(cartOpRequest);">1099             ProcessContext&lt;CartOperationRequest&gt; context = (ProcessContext&lt;CartOperationRequest&gt;) updatePðŸ”µ</abbr>
<abbr title="1100             context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getActivityMessages());">1100             context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getAcðŸ”µ</abbr>
1101             return context.getSeedData().getOrder();
1102         } catch (WorkflowException e) {
<abbr title="1103             throw new UpdateCartException(&quot;Could not product options&quot;, getCartOperationExceptionRootCause(e));">1103             throw new UpdateCartException(&quot;Could not product options&quot;, getCartOperationExceptionRootCauseðŸ”µ</abbr>
1104         }
1105     }
1106 
1107     @Override
1108     public Order reloadOrder(Order order) {
1109         if (order == null || order instanceof NullOrderImpl || order.getId() == null) {
1110             return order;
1111         }
1112 
1113         return orderDao.readOrderById(order.getId(), true);
1114     }
1115 
1116     @Override
1117     @Transactional(&quot;blTransactionManager&quot;)
1118     public boolean acquireLock(Order order) {
1119         return orderDao.acquireLock(order);
1120     }
1121 
1122     @Override
1123     public boolean releaseLock(Order order) {
1124         return orderDao.releaseLock(order);
1125     }
1126 
1127     @Override
1128     public void printOrder(Order order, Log log) {
1129         if (!log.isDebugEnabled()) {
1130             return;
1131         }
1132 
1133         TableCreator tc = new TableCreator(new TableCreator.Col[] {
1134             new TableCreator.Col(&quot;Order Item&quot;, 30),
1135             new TableCreator.Col(&quot;Qty&quot;),
1136             new TableCreator.Col(&quot;Unit Price&quot;),
1137             new TableCreator.Col(&quot;Avg Adj&quot;),
1138             new TableCreator.Col(&quot;Total Adj&quot;),
1139             new TableCreator.Col(&quot;Total Price&quot;)
1140         });
1141 
1142         for (OrderItem oi : order.getOrderItems()) {
1143             tc.addRow(new String[] {
1144                 oi.getName(),
1145                 String.valueOf(oi.getQuantity()),
1146                 String.valueOf(oi.getPriceBeforeAdjustments(true)),
1147                 String.valueOf(oi.getAverageAdjustmentValue()),
1148                 String.valueOf(oi.getTotalAdjustmentValue()),
1149                 String.valueOf(oi.getTotalPrice())
1150             });
1151         }
1152 
1153         tc.addSeparator()
1154             .withGlobalRowHeaderWidth(15)
1155             .addRow(&quot;Subtotal&quot;, order.getSubTotal())
1156             .addRow(&quot;Order Adj.&quot;, order.getOrderAdjustmentsValue())
1157             .addRow(&quot;Tax&quot;, order.getTotalTax())
1158             .addRow(&quot;Shipping&quot;, order.getTotalShipping())
1159             .addRow(&quot;Total&quot;, order.getTotal())
1160             .addSeparator();
1161 
1162         log.debug(tc.toString());
1163     }
1164 
1165     @Override
1166     public void preValidateCartOperation(Order cart) {
1167         ExtensionResultHolder erh = new ExtensionResultHolder();
1168         extensionManager.getProxy().preValidateCartOperation(cart, erh);
1169         if (erh.getThrowable() instanceof IllegalCartOperationException) {
1170             throw ((IllegalCartOperationException) erh.getThrowable());
1171         } else if (erh.getThrowable() != null) {
1172             throw new RuntimeException(erh.getThrowable());
1173         }
1174     }
1175 
1176     @Override
1177     public void preValidateUpdateQuantityOperation(Order cart, OrderItemRequestDTO dto) {
1178         ExtensionResultHolder erh = new ExtensionResultHolder();
1179         extensionManager.getProxy().preValidateUpdateQuantityOperation(cart, dto, erh);
1180         if (erh.getThrowable() instanceof IllegalCartOperationException) {
1181             throw ((IllegalCartOperationException) erh.getThrowable());
1182         } else if (erh.getThrowable() != null) {
1183             throw new RuntimeException(erh.getThrowable());
1184         }
1185     }
1186 
1187     @Override
1188     public void refresh(Order order) {
1189         orderDao.refresh(order);
1190     }
1191 
1192     @Override
1193     public Order findCartForCustomerWithEnhancements(Customer customer) {
1194         ExtensionResultHolder&lt;Order&gt; erh = new ExtensionResultHolder&lt;Order&gt;();
<abbr title="1195         ExtensionResultStatusType resultStatusType = extensionManager.findCartForCustomerWithEnhancements(customer, erh);">1195         ExtensionResultStatusType resultStatusType = extensionManager.findCartForCustomerWithEnhancementsðŸ”µ</abbr>
1196         if (ExtensionResultStatusType.NOT_HANDLED != resultStatusType) {
1197             return erh.getResult();
1198         }
1199         return findCartForCustomer(customer);
1200     }
1201 
1202     @Override
1203     public Order findCartForCustomerWithEnhancements(Customer customer, Order candidateOrder) {
1204         ExtensionResultHolder&lt;Order&gt; erh = new ExtensionResultHolder&lt;Order&gt;();
<abbr title="1205         ExtensionResultStatusType resultStatusType = extensionManager.findCartForCustomerWithEnhancements(customer, candidateOrder, erh);">1205         ExtensionResultStatusType resultStatusType = extensionManager.findCartForCustomerWithEnhancementsðŸ”µ</abbr>
1206         if (ExtensionResultStatusType.NOT_HANDLED != resultStatusType) {
1207             return erh.getResult();
1208         }
1209         return candidateOrder;
1210     }
1211 
1212     @Override
1213     public List&lt;Order&gt; findOrdersByEmail(String email) {
1214         return orderDao.readOrdersByEmail(email);
1215     }
1216 
1217     @Override
1218     public List&lt;Order&gt; readBatchOrders(int start, int pageSize, List&lt;OrderStatus&gt; orderStatusList) {
1219         return orderDao.readBatchOrders(start, pageSize, orderStatusList);
1220     }
1221 
1222     @Override
1223     	public Long readNumberOfOrders() {
1224     		return orderDao.readNumberOfOrders();
1225     }
1226 }
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * #%L
   3   * BroadleafCommerce Framework
   4   * %%
   5   * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6   * %%
   7   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10   * the Broadleaf End User License Agreement (EULA), Version 1.1
  11   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12   * shall apply.
  13   *
<abbr title="  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  15   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  16   * #L%
  17   */
  18  package org.broadleafcommerce.core.order.service;
  19  
  20  import org.apache.commons.collections.CollectionUtils;
  21  import org.apache.commons.lang3.builder.CompareToBuilder;
  22  import org.apache.commons.logging.Log;
  23  import org.apache.commons.logging.LogFactory;
  24  import org.broadleafcommerce.common.extension.ExtensionResultHolder;
  25  import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  26  import org.broadleafcommerce.common.payment.PaymentType;
  27  import org.broadleafcommerce.common.util.BLCSystemProperty;
  28  import org.broadleafcommerce.common.util.TableCreator;
  29  import org.broadleafcommerce.common.util.TransactionUtils;
  30  import org.broadleafcommerce.common.util.TypedPredicate;
  31  import org.broadleafcommerce.common.web.BroadleafRequestContext;
  32  import org.broadleafcommerce.core.catalog.domain.Product;
  33  import org.broadleafcommerce.core.catalog.domain.Sku;
  34  import org.broadleafcommerce.core.offer.dao.OfferDao;
  35  import org.broadleafcommerce.core.offer.domain.Offer;
  36  import org.broadleafcommerce.core.offer.domain.OfferCode;
  37  import org.broadleafcommerce.core.offer.service.OfferService;
  38  import org.broadleafcommerce.core.offer.service.OfferServiceExtensionHandler;
  39  import org.broadleafcommerce.core.offer.service.OfferServiceExtensionManager;
  40  import org.broadleafcommerce.core.offer.service.exception.OfferAlreadyAddedException;
  41  import org.broadleafcommerce.core.offer.service.exception.OfferException;
  42  import org.broadleafcommerce.core.offer.service.exception.OfferExpiredException;
  43  import org.broadleafcommerce.core.offer.service.exception.OfferMaxUseExceededException;
  44  import org.broadleafcommerce.core.order.dao.OrderDao;
  45  import org.broadleafcommerce.core.order.domain.BundleOrderItem;
  46  import org.broadleafcommerce.core.order.domain.DiscreteOrderItem;
  47  import org.broadleafcommerce.core.order.domain.GiftWrapOrderItem;
  48  import org.broadleafcommerce.core.order.domain.NullOrderFactory;
  49  import org.broadleafcommerce.core.order.domain.NullOrderImpl;
  50  import org.broadleafcommerce.core.order.domain.Order;
  51  import org.broadleafcommerce.core.order.domain.OrderItem;
  52  import org.broadleafcommerce.core.order.domain.OrderItemAttribute;
  53  import org.broadleafcommerce.core.order.service.call.ActivityMessageDTO;
  54  import org.broadleafcommerce.core.order.service.call.GiftWrapOrderItemRequest;
  55  import org.broadleafcommerce.core.order.service.call.OrderItemRequestDTO;
  56  import org.broadleafcommerce.core.order.service.exception.AddToCartException;
  57  import org.broadleafcommerce.core.order.service.exception.IllegalCartOperationException;
  58  import org.broadleafcommerce.core.order.service.exception.ItemNotFoundException;
  59  import org.broadleafcommerce.core.order.service.exception.RemoveFromCartException;
  60  import org.broadleafcommerce.core.order.service.exception.UpdateCartException;
  61  import org.broadleafcommerce.core.order.service.type.OrderStatus;
  62  import org.broadleafcommerce.core.order.service.workflow.CartOperationRequest;
  63  import org.broadleafcommerce.core.payment.dao.OrderPaymentDao;
  64  import org.broadleafcommerce.core.payment.domain.OrderPayment;
  65  import org.broadleafcommerce.core.payment.domain.secure.Referenced;
  66  import org.broadleafcommerce.core.payment.service.SecureOrderPaymentService;
  67  import org.broadleafcommerce.core.pricing.service.PricingService;
  68  import org.broadleafcommerce.core.pricing.service.exception.PricingException;
  69  import org.broadleafcommerce.core.workflow.ActivityMessages;
  70  import org.broadleafcommerce.core.workflow.ProcessContext;
  71  import org.broadleafcommerce.core.workflow.Processor;
  72  import org.broadleafcommerce.core.workflow.WorkflowException;
  73  import org.broadleafcommerce.profile.core.domain.Customer;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  74 +import org.broadleafcommerce.profile.core.service.CustomerService;</span>
  75  import org.hibernate.FlushMode;
  76  import org.hibernate.Session;
  77  import org.hibernate.exception.LockAcquisitionException;
  78  import org.springframework.beans.factory.annotation.Value;
  79  import org.springframework.jmx.export.annotation.ManagedAttribute;
  80  import org.springframework.jmx.export.annotation.ManagedResource;
  81  import org.springframework.stereotype.Service;
  82  import org.springframework.transaction.PlatformTransactionManager;
  83  import org.springframework.transaction.TransactionDefinition;
  84  import org.springframework.transaction.TransactionStatus;
  85  import org.springframework.transaction.annotation.Transactional;
  86  
  87  import java.math.BigDecimal;
  88  import java.util.ArrayList;
  89  import java.util.Collections;
  90  import java.util.Comparator;
  91  import java.util.Date;
  92  import java.util.List;
  93  import java.util.Map;

  94  import java.util.Set;
  95  
  96  import javax.annotation.Resource;
  97  import javax.persistence.EntityManager;
  98  import javax.persistence.PersistenceContext;
  99  
 100  
 101  /**
 102   * @author apazzolini
 103   */
 104  @Service(&quot;blOrderService&quot;)
<abbr title=" 105  @ManagedResource(objectName=&quot;org.broadleafcommerce:name=OrderService&quot;, description=&quot;Order Service&quot;, currencyTimeLimit=15)"> 105  @ManagedResource(objectName=&quot;org.broadleafcommerce:name=OrderService&quot;, description=&quot;Order Service&quot;, currencyTimeLiðŸ”µ</abbr>
 106  public class OrderServiceImpl implements OrderService {
 107      private static final Log LOG = LogFactory.getLog(OrderServiceImpl.class);
 108  
 109      /* DAOs */
 110      @Resource(name = &quot;blOrderPaymentDao&quot;)
 111      protected OrderPaymentDao paymentDao;
 112  
 113      @Resource(name = &quot;blOrderDao&quot;)
 114      protected OrderDao orderDao;
 115  
 116      @Resource(name = &quot;blOfferDao&quot;)
 117      protected OfferDao offerDao;
 118  
 119      /* Factories */
 120      @Resource(name = &quot;blNullOrderFactory&quot;)
 121      protected NullOrderFactory nullOrderFactory;
 122  
 123      /* Services */
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 124 +    @Resource(name = &quot;blCustomerService&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 125 +    protected CustomerService customerService;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 126 +</span>
 127      @Resource(name = &quot;blPricingService&quot;)
 128      protected PricingService pricingService;
 129  
 130      @Resource(name = &quot;blOrderItemService&quot;)
 131      protected OrderItemService orderItemService;
 132  
 133      @Resource(name = &quot;blFulfillmentGroupService&quot;)
 134      protected FulfillmentGroupService fulfillmentGroupService;
 135  
 136      @Resource(name = &quot;blOfferService&quot;)
 137      protected OfferService offerService;
 138  
 139      @Resource(name = &quot;blSecureOrderPaymentService&quot;)
 140      protected SecureOrderPaymentService securePaymentInfoService;
 141  
 142      @Resource(name = &quot;blMergeCartService&quot;)
 143      protected MergeCartService mergeCartService;
 144  
 145      @Resource(name = &quot;blOrderServiceExtensionManager&quot;)
 146      protected OrderServiceExtensionManager extensionManager;
 147  
 148      /* Workflows */
 149      @Resource(name = &quot;blAddItemWorkflow&quot;)
 150      protected Processor addItemWorkflow;
 151  
 152      @Resource(name = &quot;blUpdateProductOptionsForItemWorkflow&quot;)
 153      private Processor updateProductOptionsForItemWorkflow;
 154  
 155      @Resource(name = &quot;blUpdateItemWorkflow&quot;)
 156      protected Processor updateItemWorkflow;
 157  
 158      @Resource(name = &quot;blRemoveItemWorkflow&quot;)
 159      protected Processor removeItemWorkflow;
 160  
 161      @Resource(name = &quot;blTransactionManager&quot;)
 162      protected PlatformTransactionManager transactionManager;
 163  
 164      @Value(&quot;${pricing.retry.count.for.lock.failure}&quot;)
 165      protected int pricingRetryCountForLockFailure = 3;
 166  
 167      @Value(&quot;${pricing.retry.wait.interval.for.lock.failure}&quot;)
 168      protected long pricingRetryWaitIntervalForLockFailure = 500L;
 169  
 170      /**
 171       * Advanced setting. Should Hibernate auto flush before queries during an
 172       * add-to-cart workflow. This should generally be able to be left false. This is a performance measure and
 173       * add-to-cart operations will be more efficient when this is false.
 174       */
 175      @Value(&quot;${auto.flush.on.query.during.add.to.cart:false}&quot;)
 176      protected boolean autoFlushAddToCart = false;
 177  
 178      /**
 179       * Advanced setting. Should Hibernate auto flush before queries during an
 180       * update-cart workflow. This should generally be able to be left false. This is a performance measure and
 181       * update-cart operations will be more efficient when this is false.
 182       */
 183      @Value(&quot;${auto.flush.on.query.during.update.cart:false}&quot;)
 184      protected boolean autoFlushUpdateCart = false;
 185  
 186      /**
 187       * Advanced setting. Should Hibernate auto flush before queries during an
<abbr title=" 188       * remove-from-cart workflow. This should generally be able to be left false. This is a performance measure and"> 188       * remove-from-cart workflow. This should generally be able to be left false. This is a performance measure anðŸ”µ</abbr>
 189       * remove-from-cart operations will be more efficient when this is false.
 190       */
 191      @Value(&quot;${auto.flush.on.query.during.remove.from.cart:false}&quot;)
 192      protected boolean autoFlushRemoveFromCart = false;
 193  
 194      /**
 195       * Advanced setting. Should Hibernate auto flush before queries during an
 196       * order save pricing flow. This should generally be able to be left false. This is a performance measure and
 197       * save operations will be more efficient when this is false.
 198       */
 199      @Value(&quot;${auto.flush.on.query.during.cart.pricing.save:false}&quot;)
 200      protected boolean autoFlushSaveCart = false;
 201  
 202      @PersistenceContext(unitName=&quot;blPU&quot;)
 203      protected EntityManager em;
 204  
 205      /* Fields */
 206      protected boolean moveNamedOrderItems = true;
 207      protected boolean deleteEmptyNamedOrders = true;
 208  
 209      protected Boolean automaticallyMergeLikeItems;
 210  
 211      @Resource(name = &quot;blOrderMultishipOptionService&quot;)
 212      protected OrderMultishipOptionService orderMultishipOptionService;
 213  
 214      @Resource(name = &quot;blOfferServiceExtensionManager&quot;)
 215      protected OfferServiceExtensionManager offerServiceExtensionManager;
 216  
 217  
 218      @Override
 219      @Transactional(&quot;blTransactionManager&quot;)
 220      public Order createNewCartForCustomer(Customer customer) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 221 +        customer = customerService.saveCustomer(customer);</span>
 222          return orderDao.createNewCartForCustomer(customer);




 223      }
 224  
 225      @Override
 226      @Transactional(&quot;blTransactionManager&quot;)
 227      public Order createNamedOrderForCustomer(String name, Customer customer) {
 228          Order namedOrder = orderDao.create();
 229          namedOrder.setCustomer(customer);
 230          namedOrder.setName(name);
 231          namedOrder.setStatus(OrderStatus.NAMED);
 232  
 233          if (extensionManager != null) {
 234              extensionManager.getProxy().attachAdditionalDataToNewNamedCart(customer, namedOrder);
 235          }
 236  
 237          if (BroadleafRequestContext.getBroadleafRequestContext() != null) {
 238              namedOrder.setLocale(BroadleafRequestContext.getBroadleafRequestContext().getLocale());
 239          }
 240  
 241          return persist(namedOrder); // No need to price here
 242      }
 243  
 244      @Override
 245      public Order findNamedOrderForCustomer(String name, Customer customer) {
 246          return orderDao.readNamedOrderForCustomer(customer, name);
 247      }
 248  
 249      @Override
 250      public Order findOrderById(Long orderId) {
 251          return orderDao.readOrderById(orderId);
 252      }
 253  
 254      @Override
 255      public List&lt;Order&gt; findOrdersByIds(List&lt;Long&gt; orderIds) {
 256          return orderDao.readOrdersByIds(orderIds);
 257      }
 258  
 259      @Override
 260      public Order findOrderById(Long orderId, boolean refresh) {
 261          return orderDao.readOrderById(orderId, refresh);
 262      }
 263  
 264      @Override
 265      public Order getNullOrder() {
 266          return nullOrderFactory.getNullOrder();
 267      }
 268  
 269      @Override
 270      public Order findCartForCustomer(Customer customer) {
 271          return orderDao.readCartForCustomer(customer);
 272      }
 273  
 274      @Override
 275      public List&lt;Order&gt; findOrdersForCustomer(Customer customer) {
 276          return orderDao.readOrdersForCustomer(customer.getId());
 277      }
 278  
 279      @Override
 280      public List&lt;Order&gt; findOrdersForCustomer(Customer customer, OrderStatus status) {
 281          return orderDao.readOrdersForCustomer(customer, status);
 282      }
 283  
 284      @Override
 285      public Order findOrderByOrderNumber(String orderNumber) {
 286          return orderDao.readOrderByOrderNumber(orderNumber);
 287      }
 288  
 289      @Override
 290      public List&lt;Order&gt; findOrdersByDateRange(Date startDate, Date endDate) {
 291          return orderDao.readOrdersByDateRange(startDate, endDate);
 292      }
 293  
 294      @Override
 295      public List&lt;Order&gt; findOrdersByDaysCount(Integer daysCount, Integer batchSize) {
 296          return orderDao.readOrdersOlderThanDaysCount(daysCount, batchSize);
 297      }
 298  
 299      @Override
 300      public List&lt;Order&gt; findOrdersForCustomersInDateRange(List&lt;Long&gt; customerIds, Date startDate, Date endDate) {
 301          return orderDao.readOrdersForCustomersInDateRange(customerIds, startDate, endDate);
 302      }
 303  
 304      @Override
 305      public List&lt;OrderPayment&gt; findPaymentsForOrder(Order order) {
 306          return paymentDao.readPaymentsForOrder(order);
 307      }
 308  
 309      @Override
 310      @Transactional(&quot;blTransactionManager&quot;)
 311      public OrderPayment addPaymentToOrder(Order order, OrderPayment payment, Referenced securePaymentInfo) {
 312          payment.setOrder(order);
 313          order.getPayments().add(payment);
 314          order = persist(order);
 315          int paymentIndex = order.getPayments().size() - 1;
 316  
 317          if (securePaymentInfo != null) {
 318              securePaymentInfoService.save(securePaymentInfo);
 319          }
 320  
 321          return order.getPayments().get(paymentIndex);
 322      }
 323  
 324      @Override
 325      public Order save(Order order, boolean priceOrder, boolean repriceItems) throws PricingException {
 326          if (repriceItems) {
 327              order.updatePrices();
 328          }
 329          return save(order, priceOrder);
 330      }
 331  
 332      @Override
 333      public Order save(Order order, Boolean priceOrder) throws PricingException {
 334          //persist the order first
 335          TransactionStatus status = TransactionUtils.createTransaction(&quot;saveOrder&quot;,
 336                      TransactionDefinition.PROPAGATION_REQUIRED, transactionManager);
 337          try {
 338              order = persist(order);
 339              TransactionUtils.finalizeTransaction(status, transactionManager, false);
 340          } catch (RuntimeException ex) {
 341              TransactionUtils.finalizeTransaction(status, transactionManager, true);
 342              throw ex;
 343          }
 344  
 345          //make any pricing changes - possibly retrying with the persisted state if there&#x27;s a lock failure
 346          if (priceOrder) {
 347              int retryCount = 0;
 348              boolean isValid = false;
 349              while (!isValid) {
 350                  Session session = em.unwrap(Session.class);
 351                  FlushMode current = session.getHibernateFlushMode();
 352                  try {
 353                      if (!autoFlushSaveCart) {
<abbr title=" 354                          //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 354                          //Performance measure. Hibernate will sometimes perform an autoflush when performing queryðŸ”µ</abbr>
<abbr title=" 355                          //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 355                          //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries ðŸ”µ</abbr>
 356                          //incorrect results because something has not been flushed to the database yet.
 357                          session.setHibernateFlushMode(FlushMode.MANUAL);
 358                      }
 359                      order = pricingService.executePricing(order);
 360                      isValid = true;
 361                  } catch (Exception ex) {
 362                      boolean isValidCause = false;
 363                      Throwable cause = ex;
 364                      while (!isValidCause) {
 365                          if (cause.getClass().equals(LockAcquisitionException.class)) {
 366                              isValidCause = true;
 367                          }
 368                          cause = cause.getCause();
 369                          if (cause == null) {
 370                              break;
 371                          }
 372                      }
 373                      if (isValidCause) {
 374                          if (LOG.isInfoEnabled()) {
 375                              LOG.info(&quot;Problem acquiring lock during pricing call - attempting to price again.&quot;);
 376                          }
 377                          isValid = false;
 378                          if (retryCount &gt;= pricingRetryCountForLockFailure) {
 379                              if (LOG.isInfoEnabled()) {
<abbr title=" 380                                  LOG.info(&quot;Problem acquiring lock during pricing call. Retry limit exceeded at (&quot; + retryCount + &quot;). Throwing exception.&quot;);"> 380                                  LOG.info(&quot;Problem acquiring lock during pricing call. Retry limit exceeded at (&quot; +ðŸ”µ</abbr>
 381                              }
 382                              if (ex instanceof PricingException) {
 383                                  throw (PricingException) ex;
 384                              } else {
 385                                  throw new PricingException(ex);
 386                              }
 387                          } else {
 388                              order = findOrderById(order.getId());
 389                              retryCount++;
 390                          }
 391                          try {
 392                              Thread.sleep(pricingRetryWaitIntervalForLockFailure);
 393                          } catch (Throwable e) {
 394                              //do nothing
 395                          }
 396                      } else {
 397                          if (ex instanceof PricingException) {
 398                              throw (PricingException) ex;
 399                          } else {
 400                              throw new PricingException(ex);
 401                          }
 402                      }
 403                  } finally {
 404                      if (!autoFlushSaveCart) {
 405                          session.setHibernateFlushMode(current);
 406                      }
 407                  }
 408              }
 409  
 410              //make the final save of the priced order
 411              status = TransactionUtils.createTransaction(&quot;saveOrder&quot;,
 412                                  TransactionDefinition.PROPAGATION_REQUIRED, transactionManager);
 413              Session session = em.unwrap(Session.class);
 414              FlushMode current = session.getHibernateFlushMode();
 415              try {
 416                  if (!autoFlushSaveCart) {
<abbr title=" 417                      //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 417                      //Performance measure. Hibernate will sometimes perform an autoflush when performing query opeðŸ”µ</abbr>
<abbr title=" 418                      //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 418                      //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in tðŸ”µ</abbr>
 419                      //incorrect results because something has not been flushed to the database yet.
 420                      session.setHibernateFlushMode(FlushMode.MANUAL);
 421                  }
 422                  order = persist(order);
 423  
 424                  if (extensionManager != null) {
 425                      extensionManager.getProxy().attachAdditionalDataToOrder(order, priceOrder);
 426                  }
 427                  if (!autoFlushSaveCart) {
 428                      session.setFlushMode(current);
 429                  }
 430                  TransactionUtils.finalizeTransaction(status, transactionManager, false);
 431              } catch (RuntimeException ex) {
 432                  TransactionUtils.finalizeTransaction(status, transactionManager, true);
 433                  throw ex;
 434              } finally {
 435                  if (!autoFlushSaveCart &amp;&amp; !session.getFlushMode().equals(current)) {
 436                      session.setHibernateFlushMode(current);
 437                  }
 438              }
 439          }
 440  
 441          return order;
 442      }
 443  
 444      // This method exists to provide OrderService methods the ability to save an order
 445      // without having to worry about a PricingException being thrown.
 446      protected Order persist(Order order) {
 447          return orderDao.save(order);
 448      }
 449  
 450      @Override
 451      @Transactional(&quot;blTransactionManager&quot;)
 452      public void cancelOrder(Order order) {
 453          orderDao.delete(order);
 454      }
 455  
 456      @Override
 457      @Transactional(&quot;blTransactionManager&quot;)
 458      public void deleteOrder(Order order) {
 459          orderMultishipOptionService.deleteAllOrderMultishipOptions(order);
 460          orderDao.delete(order);
 461      }
 462  
 463      @Override
 464      @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 465      public Order addOfferCode(Order order, OfferCode offerCode, boolean priceOrder) throws PricingException, OfferException {"> 465      public Order addOfferCode(Order order, OfferCode offerCode, boolean priceOrder) throws PricingException, OfferðŸ”µ</abbr>
 466          ArrayList&lt;OfferCode&gt; offerCodes = new ArrayList&lt;OfferCode&gt;();
 467          offerCodes.add(offerCode);
 468          return addOfferCodes(order, offerCodes, priceOrder);
 469      }
 470  
 471      @Override
 472      @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 473      public Order addOfferCodes(Order order, List&lt;OfferCode&gt; offerCodes, boolean priceOrder) throws PricingException, OfferException {"> 473      public Order addOfferCodes(Order order, List&lt;OfferCode&gt; offerCodes, boolean priceOrder) throws PricingExceptioðŸ”µ</abbr>
 474          preValidateCartOperation(order);
 475          Set&lt;Offer&gt; addedOffers = offerService.getUniqueOffersFromOrder(order);
 476          if (extensionManager != null) {
 477              extensionManager.getProxy().addOfferCodes(order, offerCodes, priceOrder);
 478          }
 479          if (offerCodes != null &amp;&amp; !offerCodes.isEmpty()) {
 480              for (OfferCode offerCode : offerCodes) {
 481  
<abbr title=" 482                  if (order.getAddedOfferCodes().contains(offerCode) || addedOffers.contains(offerCode.getOffer())) {"> 482                  if (order.getAddedOfferCodes().contains(offerCode) || addedOffers.contains(offerCode.getOffer())) ðŸ”µ</abbr>
 483                      throw new OfferAlreadyAddedException(&quot;The offer has already been added.&quot;);
 484                  } else if (!offerService.verifyMaxCustomerUsageThreshold(order, offerCode)) {
<abbr title=" 485                      throw new OfferMaxUseExceededException(&quot;The customer has used this offer code more than the maximum allowed number of times.&quot;);"> 485                      throw new OfferMaxUseExceededException(&quot;The customer has used this offer code more than the maðŸ”µ</abbr>
 486                  } else if (!offerCode.isActive() || !offerCode.getOffer().isActive()) {
 487                      throw new OfferExpiredException(&quot;The offer has expired.&quot;);
 488                  }
 489  
 490                  order.getAddedOfferCodes().add(offerCode);
 491  
 492              }
 493              order = save(order, priceOrder);
 494          }
 495  
 496          return order;
 497      }
 498  
 499      @Override
 500      @Transactional(&quot;blTransactionManager&quot;)
 501      public Order removeOfferCode(Order order, OfferCode offerCode, boolean priceOrder) throws PricingException {
 502          order.getAddedOfferCodes().remove(offerCode);
 503          offerServiceExtensionManager.removeOfferCodeFromOrder(offerCode, order);
 504          order = save(order, priceOrder);
 505          return order;
 506      }
 507  
 508      @Override
 509      @Transactional(&quot;blTransactionManager&quot;)
 510      public Order removeAllOfferCodes(Order order, boolean priceOrder) throws PricingException {
 511           order.getAddedOfferCodes().clear();
 512           order = save(order, priceOrder);
 513           return order;
 514      }
 515  
 516      @Override
<abbr title=" 517      @ManagedAttribute(description=&quot;The delete empty named order after adding items to cart attribute&quot;, currencyTimeLimit=15)"> 517      @ManagedAttribute(description=&quot;The delete empty named order after adding items to cart attribute&quot;, currencyTimðŸ”µ</abbr>
 518      public void setDeleteEmptyNamedOrders(boolean deleteEmptyNamedOrders) {
 519          this.deleteEmptyNamedOrders = deleteEmptyNamedOrders;
 520      }
 521  
 522      @Override
 523      public OrderItem findLastMatchingItem(Order order, Long skuId, Long productId) {
 524          if (order.getOrderItems() != null) {
 525              for (int i=(order.getOrderItems().size()-1); i &gt;= 0; i--) {
 526                  OrderItem currentItem = (order.getOrderItems().get(i));
 527                  if (currentItem instanceof DiscreteOrderItem) {
 528                      DiscreteOrderItem discreteItem = (DiscreteOrderItem) currentItem;
 529                      if (skuId != null) {
 530                          if (discreteItem.getSku() != null &amp;&amp; skuId.equals(discreteItem.getSku().getId())) {
 531                              return discreteItem;
 532                          }
<abbr title=" 533                      } else if (productId != null &amp;&amp; discreteItem.getProduct() != null &amp;&amp; productId.equals(discreteItem.getProduct().getId())) {"> 533                      } else if (productId != null &amp;&amp; discreteItem.getProduct() != null &amp;&amp; productId.equals(discreteðŸ”µ</abbr>
 534                          return discreteItem;
 535                      }
 536  
 537                  } else if (currentItem instanceof BundleOrderItem) {
 538                      BundleOrderItem bundleItem = (BundleOrderItem) currentItem;
 539                      if (skuId != null) {
 540                          if (bundleItem.getSku() != null &amp;&amp; skuId.equals(bundleItem.getSku().getId())) {
 541                              return bundleItem;
 542                          }
<abbr title=" 543                      } else if (productId != null &amp;&amp; bundleItem.getProduct() != null &amp;&amp; productId.equals(bundleItem.getProduct().getId())) {"> 543                      } else if (productId != null &amp;&amp; bundleItem.getProduct() != null &amp;&amp; productId.equals(bundleItemðŸ”µ</abbr>
 544                          return bundleItem;
 545                      }
 546                  }
 547              }
 548          }
 549          return null;
 550      }
 551  
 552      @Override
 553      @Transactional(&quot;blTransactionManager&quot;)
 554      public Order confirmOrder(Order order) {
 555          return orderDao.submitOrder(order);
 556      }
 557  
 558      @Override
 559      @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 560      public Order addAllItemsFromNamedOrder(Order namedOrder, boolean priceOrder) throws RemoveFromCartException, AddToCartException {"> 560      public Order addAllItemsFromNamedOrder(Order namedOrder, boolean priceOrder) throws RemoveFromCartException, AðŸ”µ</abbr>
 561          Order cartOrder = orderDao.readCartForCustomer(namedOrder.getCustomer());
 562          if (cartOrder == null) {
 563              cartOrder = createNewCartForCustomer(namedOrder.getCustomer());
 564          }
 565          List&lt;OrderItem&gt; items = new ArrayList&lt;OrderItem&gt;(namedOrder.getOrderItems());
 566  
 567          // Remove any order items that are children
 568          CollectionUtils.filter(items,  new TypedPredicate&lt;OrderItem&gt;() {
 569              @Override
 570              public boolean eval(OrderItem orderItem) {
 571                  return orderItem.getParentOrderItem() == null;
 572              }
 573          });
 574          for (OrderItem item : items) {
 575              OrderItemRequestDTO orderItemRequest = orderItemService.buildOrderItemRequestDTOFromOrderItem(item);
 576              cartOrder = addItem(cartOrder.getId(), orderItemRequest, priceOrder);
 577  
 578              if (moveNamedOrderItems) {
 579                  removeItem(namedOrder.getId(), item.getId(), false);
 580              }
 581          }
 582  
 583          if (deleteEmptyNamedOrders) {
 584              cancelOrder(namedOrder);
 585          }
 586  
 587          return cartOrder;
 588      }
 589  
 590      @Override
 591      @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 592      public Order addItemFromNamedOrder(Order namedOrder, OrderItem item, boolean priceOrder) throws RemoveFromCartException, AddToCartException {"> 592      public Order addItemFromNamedOrder(Order namedOrder, OrderItem item, boolean priceOrder) throws RemoveFromCartðŸ”µ</abbr>
 593          Order cartOrder = orderDao.readCartForCustomer(namedOrder.getCustomer());
 594          if (cartOrder == null) {
 595              cartOrder = createNewCartForCustomer(namedOrder.getCustomer());
 596          }
 597  
 598          OrderItemRequestDTO orderItemRequest = orderItemService.buildOrderItemRequestDTOFromOrderItem(item);
 599          cartOrder = addItem(cartOrder.getId(), orderItemRequest, priceOrder);
 600  
 601          if (moveNamedOrderItems) {
 602              removeItem(namedOrder.getId(), item.getId(), false);
 603          }
 604  
 605          if (namedOrder.getOrderItems().size() == 0 &amp;&amp; deleteEmptyNamedOrders) {
 606              cancelOrder(namedOrder);
 607          }
 608  
 609          return cartOrder;
 610      }
 611  
 612      @Override
 613      @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 614      public Order addItemFromNamedOrder(Order namedOrder, OrderItem item, int quantity, boolean priceOrder) throws RemoveFromCartException, AddToCartException, UpdateCartException {"> 614      public Order addItemFromNamedOrder(Order namedOrder, OrderItem item, int quantity, boolean priceOrder) throws ðŸ”µ</abbr>
 615          // Validate that the quantity requested makes sense
 616          if (quantity &lt; 1 || quantity &gt; item.getQuantity()) {
 617              throw new IllegalArgumentException(&quot;Cannot move 0 or less quantity&quot;);
 618          } else if (quantity == item.getQuantity()) {
 619              return addItemFromNamedOrder(namedOrder, item, priceOrder);
 620          }
 621  
 622          Order cartOrder = orderDao.readCartForCustomer(namedOrder.getCustomer());
 623          if (cartOrder == null) {
 624              cartOrder = createNewCartForCustomer(namedOrder.getCustomer());
 625          }
 626  
 627          OrderItemRequestDTO orderItemRequest = orderItemService.buildOrderItemRequestDTOFromOrderItem(item);
 628          orderItemRequest.setQuantity(quantity);
 629          cartOrder = addItem(cartOrder.getId(), orderItemRequest, priceOrder);
 630  
 631          if (moveNamedOrderItems) {
 632              // Update the old item to its new quantity only if we&#x27;re moving items
 633              OrderItemRequestDTO orderItemRequestDTO = new OrderItemRequestDTO();
 634              orderItemRequestDTO.setOrderItemId(item.getId());
 635              orderItemRequestDTO.setQuantity(item.getQuantity() - quantity);
 636              updateItemQuantity(namedOrder.getId(), orderItemRequestDTO, false);
 637          }
 638          return cartOrder;
 639      }
 640  
 641      @Override
 642      @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 643      public OrderItem addGiftWrapItemToOrder(Order order, GiftWrapOrderItemRequest itemRequest, boolean priceOrder) throws PricingException {"> 643      public OrderItem addGiftWrapItemToOrder(Order order, GiftWrapOrderItemRequest itemRequest, boolean priceOrder)ðŸ”µ</abbr>
 644          GiftWrapOrderItem item = orderItemService.createGiftWrapOrderItem(itemRequest);
 645          item.setOrder(order);
 646          item = (GiftWrapOrderItem) orderItemService.saveOrderItem(item);
 647  
 648          order.getOrderItems().add(item);
 649          order = save(order, priceOrder);
 650  
 651          return item;
 652      }
 653  
 654      @Override
 655      @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = {AddToCartException.class})
<abbr title=" 656      public Order addItem(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throws AddToCartException {"> 656      public Order addItem(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throws AddToCaðŸ”µ</abbr>
 657          // Don&#x27;t allow overrides from this method.
 658          orderItemRequestDTO.setOverrideRetailPrice(null);
 659          orderItemRequestDTO.setOverrideSalePrice(null);
 660          return addItemWithPriceOverrides(orderId, orderItemRequestDTO, priceOrder);
 661      }
 662  
 663      @Override
 664      @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = { AddToCartException.class })
<abbr title=" 665      public Order addItemWithPriceOverrides(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throws AddToCartException {"> 665      public Order addItemWithPriceOverrides(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrdðŸ”µ</abbr>
 666          Order order = findOrderById(orderId);
 667          preValidateCartOperation(order);
 668          if (getAutomaticallyMergeLikeItems()) {
 669              OrderItem item = findMatchingItem(order, orderItemRequestDTO);
 670              if (item != null &amp;&amp; item.getParentOrderItem() == null) {
 671                  orderItemRequestDTO.setQuantity(item.getQuantity() + orderItemRequestDTO.getQuantity());
 672                  orderItemRequestDTO.setOrderItemId(item.getId());
 673                  try {
 674                      return updateItemQuantity(orderId, orderItemRequestDTO, priceOrder);
 675                  } catch (RemoveFromCartException e) {
<abbr title=" 676                      throw new AddToCartException(&quot;Unexpected error - system tried to remove item while adding to cart&quot;, e);"> 676                      throw new AddToCartException(&quot;Unexpected error - system tried to remove item while adding to cðŸ”µ</abbr>
 677                  } catch (UpdateCartException e) {
 678                      throw new AddToCartException(&quot;Could not update quantity for matched item&quot;, e);
 679                  }
 680              }
 681          }
 682          try {
<abbr title=" 683              // We only want to price on the last addition for performance reasons and only if the user asked for it."> 683              // We only want to price on the last addition for performance reasons and only if the user asked for iðŸ”µ</abbr>
 684              int numAdditionRequests = priceOrder ? (getTotalChildOrderItems(orderItemRequestDTO)) : -1;
 685              int currentAddition = 1;
 686  
<abbr title=" 687              CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestDTO, currentAddition == numAdditionRequests);"> 687              CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestðŸ”µ</abbr>
 688  
 689              Session session = em.unwrap(Session.class);
 690              FlushMode current = session.getHibernateFlushMode();
 691              if (!autoFlushAddToCart) {
<abbr title=" 692                  //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 692                  //Performance measure. Hibernate will sometimes perform an autoflush when performing query operatiðŸ”µ</abbr>
<abbr title=" 693                  //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 693                  //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the fðŸ”µ</abbr>
 694                  //incorrect results because something has not been flushed to the database yet.
 695                  session.setHibernateFlushMode(FlushMode.MANUAL);
 696              }
 697              ProcessContext&lt;CartOperationRequest&gt; context;
 698              try {
 699                  context = (ProcessContext&lt;CartOperationRequest&gt;) addItemWorkflow.doActivities(cartOpRequest);
 700              } finally {
 701                  if (!autoFlushAddToCart) {
 702                      session.setHibernateFlushMode(current);
 703                  }
 704              }
 705  
 706              List&lt;ActivityMessageDTO&gt; orderMessages = new ArrayList&lt;ActivityMessageDTO&gt;();
 707              orderMessages.addAll(((ActivityMessages) context).getActivityMessages());
 708  
 709              // Update the orderItemRequest incase it changed during the initial add to cart workflow
 710              orderItemRequestDTO = context.getSeedData().getItemRequest();
 711              numAdditionRequests = priceOrder ? (getTotalChildOrderItems(orderItemRequestDTO) - 1) : -1;
 712              addChildItems(orderItemRequestDTO, numAdditionRequests, currentAddition, context, orderMessages);
 713  
 714              context.getSeedData().getOrder().setOrderMessages(orderMessages);
 715              return context.getSeedData().getOrder();
 716          } catch (WorkflowException e) {
 717              throw new AddToCartException(&quot;Could not add to cart&quot;, getCartOperationExceptionRootCause(e));
 718          }
 719  
 720      }
 721  
 722      @Override
 723      public int getTotalChildOrderItems(OrderItemRequestDTO orderItemRequestDTO) {
 724          int count = 1;
 725          for (OrderItemRequestDTO childRequest : orderItemRequestDTO.getChildOrderItems()) {
 726              count += getTotalChildOrderItems(childRequest);
 727          }
 728          return count;
 729      }
 730  
 731      @Override
<abbr title=" 732      public void addChildItems(OrderItemRequestDTO orderItemRequestDTO, int numAdditionRequests, int currentAddition, ProcessContext&lt;CartOperationRequest&gt; context, List&lt;ActivityMessageDTO&gt; orderMessages) throws WorkflowException {"> 732      public void addChildItems(OrderItemRequestDTO orderItemRequestDTO, int numAdditionRequests, int currentAdditioðŸ”µ</abbr>
 733          if (CollectionUtils.isNotEmpty(orderItemRequestDTO.getChildOrderItems())) {
 734              Long parentOrderItemId = context.getSeedData().getOrderItem().getId();
 735              for (OrderItemRequestDTO childRequest : orderItemRequestDTO.getChildOrderItems()) {
 736                  childRequest.setParentOrderItemId(parentOrderItemId);
 737                  currentAddition++;
 738  
 739                  if (childRequest.getQuantity() &gt; 0) {
<abbr title=" 740                      CartOperationRequest childCartOpRequest = new CartOperationRequest(context.getSeedData().getOrder(), childRequest, currentAddition == numAdditionRequests);"> 740                      CartOperationRequest childCartOpRequest = new CartOperationRequest(context.getSeedData().getOrðŸ”µ</abbr>
 741                      Session session = em.unwrap(Session.class);
 742                      FlushMode current = session.getHibernateFlushMode();
 743                      if (!autoFlushAddToCart) {
<abbr title=" 744                          //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 744                          //Performance measure. Hibernate will sometimes perform an autoflush when performing queryðŸ”µ</abbr>
<abbr title=" 745                          //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 745                          //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries ðŸ”µ</abbr>
 746                          //incorrect results because something has not been flushed to the database yet.
 747                          session.setHibernateFlushMode(FlushMode.MANUAL);
 748                      }
 749                      ProcessContext&lt;CartOperationRequest&gt; childContext;
 750                      try {
<abbr title=" 751                          childContext = (ProcessContext&lt;CartOperationRequest&gt;) addItemWorkflow.doActivities(childCartOpRequest);"> 751                          childContext = (ProcessContext&lt;CartOperationRequest&gt;) addItemWorkflow.doActivities(childCaðŸ”µ</abbr>
 752                      } finally {
 753                          if (!autoFlushAddToCart) {
 754                              session.setHibernateFlushMode(current);
 755                          }
 756                      }
 757                      orderMessages.addAll(((ActivityMessages) childContext).getActivityMessages());
 758  
<abbr title=" 759                      addChildItems(childRequest, numAdditionRequests, currentAddition, childContext, orderMessages);"> 759                      addChildItems(childRequest, numAdditionRequests, currentAddition, childContext, orderMessages)ðŸ”µ</abbr>
 760                  }
 761              }
 762          }
 763      }
 764  
 765      @Override
<abbr title=" 766      public void addDependentOrderItem(OrderItemRequestDTO parentOrderItemRequest, OrderItemRequestDTO dependentOrderItem) {"> 766      public void addDependentOrderItem(OrderItemRequestDTO parentOrderItemRequest, OrderItemRequestDTO dependentOrdðŸ”µ</abbr>
 767          parentOrderItemRequest.getChildOrderItems().add(dependentOrderItem);
 768          Collections.sort(parentOrderItemRequest.getChildOrderItems(), new Comparator&lt;OrderItemRequestDTO&gt;() {
 769              @Override
 770              public int compare(OrderItemRequestDTO o1, OrderItemRequestDTO o2) {
 771                  BigDecimal o1DisplayOrder = new BigDecimal(o1.getAdditionalAttributes().get(&quot;addOnDisplayOrder&quot;));
 772                  BigDecimal o2DisplayOrder = new BigDecimal(o2.getAdditionalAttributes().get(&quot;addOnDisplayOrder&quot;));
 773                  return o1DisplayOrder.compareTo(o2DisplayOrder);
 774              }
 775          });
 776      }
 777  
 778      @Override
<abbr title=" 779      @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = {UpdateCartException.class, RemoveFromCartException.class})"> 779      @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = {UpdateCartException.class, RemoveFromCartExceptiðŸ”µ</abbr>
<abbr title=" 780      public Order updateItemQuantity(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throws UpdateCartException, RemoveFromCartException {"> 780      public Order updateItemQuantity(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) thrðŸ”µ</abbr>
 781          Order order = findOrderById(orderId);
 782          preValidateCartOperation(order);
 783          preValidateUpdateQuantityOperation(findOrderById(orderId), orderItemRequestDTO);
 784          if (orderItemRequestDTO.getQuantity() == 0) {
 785              return removeItem(orderId, orderItemRequestDTO.getOrderItemId(), priceOrder);
 786          }
 787  
 788          try {
<abbr title=" 789              CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestDTO, priceOrder);"> 789              CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestðŸ”µ</abbr>
 790              Session session = em.unwrap(Session.class);
 791              FlushMode current = session.getHibernateFlushMode();
 792              if (!autoFlushUpdateCart) {
<abbr title=" 793                  //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 793                  //Performance measure. Hibernate will sometimes perform an autoflush when performing query operatiðŸ”µ</abbr>
<abbr title=" 794                  //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 794                  //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the fðŸ”µ</abbr>
 795                  //incorrect results because something has not been flushed to the database yet.
 796                  session.setHibernateFlushMode(FlushMode.MANUAL);
 797              }
 798              ProcessContext&lt;CartOperationRequest&gt; context;
 799              try {
 800                  context = (ProcessContext&lt;CartOperationRequest&gt;) updateItemWorkflow.doActivities(cartOpRequest);
 801              } finally {
 802                  if (!autoFlushUpdateCart) {
 803                      session.setHibernateFlushMode(current);
 804                  }
 805              }
<abbr title=" 806              context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getActivityMessages());"> 806              context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getActivityMesðŸ”µ</abbr>
 807              return context.getSeedData().getOrder();
 808          } catch (WorkflowException e) {
<abbr title=" 809              throw new UpdateCartException(&quot;Could not update cart quantity&quot;, getCartOperationExceptionRootCause(e));"> 809              throw new UpdateCartException(&quot;Could not update cart quantity&quot;, getCartOperationExceptionRootCause(e))ðŸ”µ</abbr>
 810          }
 811      }
 812  
 813      @Override
 814      @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = {RemoveFromCartException.class})
 815      public Order removeItem(Long orderId, Long orderItemId, boolean priceOrder) throws RemoveFromCartException {
 816          preValidateCartOperation(findOrderById(orderId));
 817          try {
 818              OrderItem oi = orderItemService.readOrderItemById(orderItemId);
 819              if (oi == null) {
 820                  throw new WorkflowException(new ItemNotFoundException());
 821              }
 822              List&lt;Long&gt; childrenToRemove = new ArrayList&lt;Long&gt;();
 823              if (oi instanceof BundleOrderItem) {
 824                  List&lt;DiscreteOrderItem&gt; bundledItems = ((BundleOrderItem) oi).getDiscreteOrderItems();
 825                  for (DiscreteOrderItem doi : bundledItems) {
 826                      findAllChildrenToRemove(childrenToRemove, doi);
 827                  }
 828              } else {
 829                  findAllChildrenToRemove(childrenToRemove, oi);
 830              }
 831              for (Long childToRemove : childrenToRemove) {
 832                  removeItemInternal(orderId, childToRemove, false);
 833              }
 834  
 835              return removeItemInternal(orderId, orderItemId, priceOrder);
 836          } catch (WorkflowException e) {
<abbr title=" 837              throw new RemoveFromCartException(&quot;Could not remove from cart&quot;, getCartOperationExceptionRootCause(e));"> 837              throw new RemoveFromCartException(&quot;Could not remove from cart&quot;, getCartOperationExceptionRootCause(e))ðŸ”µ</abbr>
 838          }
 839      }
 840  
 841      protected void findAllChildrenToRemove(List&lt;Long&gt; childrenToRemove, OrderItem orderItem){
 842          if (CollectionUtils.isNotEmpty(orderItem.getChildOrderItems())) {
 843              for (OrderItem childOrderItem : orderItem.getChildOrderItems()) {
 844                  findAllChildrenToRemove(childrenToRemove, childOrderItem);
 845                  childrenToRemove.add(childOrderItem.getId());
 846              }
 847          }
 848      }
 849  
<abbr title=" 850      protected Order removeItemInternal(Long orderId, Long orderItemId, boolean priceOrder) throws WorkflowException {"> 850      protected Order removeItemInternal(Long orderId, Long orderItemId, boolean priceOrder) throws WorkflowExceptioðŸ”µ</abbr>
 851          OrderItemRequestDTO orderItemRequestDTO = new OrderItemRequestDTO();
 852          orderItemRequestDTO.setOrderItemId(orderItemId);
<abbr title=" 853          CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestDTO, priceOrder);"> 853          CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestDTO,ðŸ”µ</abbr>
 854          Session session = em.unwrap(Session.class);
 855          FlushMode current = session.getHibernateFlushMode();
 856          if (!autoFlushRemoveFromCart) {
<abbr title=" 857              //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 857              //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations ðŸ”µ</abbr>
<abbr title=" 858              //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 858              //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow ðŸ”µ</abbr>
 859              //incorrect results because something has not been flushed to the database yet.
 860              session.setHibernateFlushMode(FlushMode.MANUAL);
 861          }
 862          ProcessContext&lt;CartOperationRequest&gt; context;
 863          try {
 864              context = (ProcessContext&lt;CartOperationRequest&gt;) removeItemWorkflow.doActivities(cartOpRequest);
 865          } finally {
 866              if (!autoFlushRemoveFromCart) {
 867                  session.setHibernateFlushMode(current);
 868              }
 869          }
<abbr title=" 870          context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getActivityMessages());"> 870          context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getActivityMessageðŸ”µ</abbr>
 871          return context.getSeedData().getOrder();
 872      }
 873  
 874      @Override
 875      @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = { RemoveFromCartException.class })
 876      public Order removeInactiveItems(Long orderId, boolean priceOrder) throws RemoveFromCartException {
 877          Order order = findOrderById(orderId);
 878          try {
 879  
 880              for (OrderItem currentItem : new ArrayList&lt;OrderItem&gt;(order.getOrderItems())) {
 881                  if (!currentItem.isSkuActive()) {
 882                      removeItem(orderId, currentItem.getId(), priceOrder);
 883                  }
 884              }
 885  
 886          } catch (Exception e) {
 887              throw new RemoveFromCartException(&quot;Could not remove from cart&quot;, e.getCause());
 888          }
 889          return findOrderById(orderId);
 890      }
 891  
 892      @Override
 893      public boolean getAutomaticallyMergeLikeItems() {
 894  
 895          if (automaticallyMergeLikeItems != null) {
 896              return automaticallyMergeLikeItems;
 897          }
 898  
 899          return BLCSystemProperty.resolveBooleanSystemProperty(&quot;automatically.merge.like.items&quot;, true);
 900      }
 901  
 902      @Override
 903      public void setAutomaticallyMergeLikeItems(boolean automaticallyMergeLikeItems) {
 904          this.automaticallyMergeLikeItems = automaticallyMergeLikeItems;
 905      }
 906  
 907      @Override
<abbr title=" 908      @ManagedAttribute(description=&quot;The move item from named order when adding to the cart attribute&quot;, currencyTimeLimit=15)"> 908      @ManagedAttribute(description=&quot;The move item from named order when adding to the cart attribute&quot;, currencyTimeðŸ”µ</abbr>
 909      public boolean isMoveNamedOrderItems() {
 910          return moveNamedOrderItems;
 911      }
 912  
 913      @Override
<abbr title=" 914      @ManagedAttribute(description=&quot;The move item from named order when adding to the cart attribute&quot;, currencyTimeLimit=15)"> 914      @ManagedAttribute(description=&quot;The move item from named order when adding to the cart attribute&quot;, currencyTimeðŸ”µ</abbr>
 915      public void setMoveNamedOrderItems(boolean moveNamedOrderItems) {
 916          this.moveNamedOrderItems = moveNamedOrderItems;
 917      }
 918  
 919      @Override
<abbr title=" 920      @ManagedAttribute(description=&quot;The delete empty named order after adding items to cart attribute&quot;, currencyTimeLimit=15)"> 920      @ManagedAttribute(description=&quot;The delete empty named order after adding items to cart attribute&quot;, currencyTimðŸ”µ</abbr>
 921      public boolean isDeleteEmptyNamedOrders() {
 922          return deleteEmptyNamedOrders;
 923      }
 924  
 925      @Override
 926      @Transactional(&quot;blTransactionManager&quot;)
 927      public void removeAllPaymentsFromOrder(Order order) {
 928          removePaymentsFromOrder(order, null);
 929      }
 930  
 931      @Override
 932      @Transactional(&quot;blTransactionManager&quot;)
 933      public void removePaymentsFromOrder(Order order, PaymentType paymentInfoType) {
 934          List&lt;OrderPayment&gt; infos = new ArrayList&lt;OrderPayment&gt;();
 935          for (OrderPayment paymentInfo : order.getPayments()) {
 936              if (paymentInfoType == null || paymentInfoType.equals(paymentInfo.getType())) {
 937                  infos.add(paymentInfo);
 938              }
 939          }
 940          order.getPayments().removeAll(infos);
 941          for (OrderPayment paymentInfo : infos) {
 942              try {
<abbr title=" 943                  securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentInfo.getReferenceNumber(), paymentInfo.getType());"> 943                  securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentInfo.getReferenceNumber(), paymentIðŸ”µ</abbr>
 944              } catch (WorkflowException e) {
 945                  // do nothing--this is an acceptable condition
 946                  LOG.debug(&quot;No secure payment is associated with the OrderPayment&quot;, e);
 947              }
 948              order.getPayments().remove(paymentInfo);
 949              paymentInfo = paymentDao.readPaymentById(paymentInfo.getId());
 950              paymentDao.delete(paymentInfo);
 951          }
 952      }
 953  
 954      @Override
 955      @Transactional(&quot;blTransactionManager&quot;)
 956      public void removeCreditCardPaymentsFromOrder(Order order) {
 957          List&lt;OrderPayment&gt; infos = new ArrayList&lt;OrderPayment&gt;();
 958          for (OrderPayment paymentInfo : order.getPayments()) {
 959              if (paymentInfo.getType().isCreditCardType()) {
 960                  infos.add(paymentInfo);
 961              }
 962          }
 963          order.getPayments().removeAll(infos);
 964          for (OrderPayment paymentInfo : infos) {
 965              try {
<abbr title=" 966                  securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentInfo.getReferenceNumber(), paymentInfo.getType());"> 966                  securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentInfo.getReferenceNumber(), paymentIðŸ”µ</abbr>
 967              } catch (WorkflowException e) {
 968                  // do nothing--this is an acceptable condition
 969                  LOG.debug(&quot;No secure payment is associated with the OrderPayment&quot;, e);
 970              }
 971              order.getPayments().remove(paymentInfo);
 972              paymentInfo = paymentDao.readPaymentById(paymentInfo.getId());
 973              paymentDao.delete(paymentInfo);
 974          }
 975      }
 976  
 977      @Override
 978      @Transactional(&quot;blTransactionManager&quot;)
 979      public void removePaymentFromOrder(Order order, OrderPayment payment){
 980          OrderPayment paymentToRemove = null;
 981          for (OrderPayment info : order.getPayments()){
 982              if (info.equals(payment)){
 983                  paymentToRemove = info;
 984              }
 985          }
 986          if (paymentToRemove != null){
 987              try {
<abbr title=" 988                  securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentToRemove.getReferenceNumber(), payment.getType());"> 988                  securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentToRemove.getReferenceNumber(), paymðŸ”µ</abbr>
 989              } catch (WorkflowException e) {
 990                  // do nothing--this is an acceptable condition
 991                  LOG.debug(&quot;No secure payment is associated with the OrderPayment&quot;, e);
 992              }
 993              order.getPayments().remove(paymentToRemove);
 994              payment = paymentDao.readPaymentById(paymentToRemove.getId());
 995              paymentDao.delete(payment);
 996          }
 997      }
 998  
 999      /**
1000       * This method will return the exception that is immediately below the deepest
1001       * WorkflowException in the current stack trace.
1002       *
1003       * @param e the workflow exception that contains the requested root cause
1004       * @return the root cause of the workflow exception
1005       */
1006      protected Throwable getCartOperationExceptionRootCause(WorkflowException e) {
1007          Throwable cause = e.getCause();
1008          if (cause == null) {
1009              return e;
1010          }
1011  
1012          Throwable currentCause = cause;
1013          while (currentCause.getCause() != null) {
1014              currentCause = currentCause.getCause();
1015              if (currentCause instanceof WorkflowException) {
1016                  cause = currentCause.getCause();
1017              }
1018          }
1019  
1020          return cause;
1021      }
1022  
1023      /**
1024       * Returns true if the two items attributes exactly match.
1025       * @param item1Attributes
1026       * @param item2
1027       * @return
1028       */
<abbr title="1029      protected boolean compareAttributes(Map&lt;String, OrderItemAttribute&gt; item1Attributes, OrderItemRequestDTO item2) {">1029      protected boolean compareAttributes(Map&lt;String, OrderItemAttribute&gt; item1Attributes, OrderItemRequestDTO item2ðŸ”µ</abbr>
1030          int item1AttributeSize = item1Attributes == null ? 0 : item1Attributes.size();
1031          int item2AttributeSize = item2.getItemAttributes() == null ? 0 : item2.getItemAttributes().size();
1032  
1033          if (item1AttributeSize != item2AttributeSize) {
1034              return false;
1035          }
1036  
1037          for (String key : item2.getItemAttributes().keySet()) {
1038              String itemOneValue = (item1Attributes.get(key) == null) ? null : item1Attributes.get(key).getValue();
1039              String itemTwoValue = item2.getItemAttributes().get(key);
1040              if (!itemTwoValue.equals(itemOneValue)) {
1041                  return false;
1042              }
1043          }
1044          return true;
1045      }
1046  
<abbr title="1047      protected boolean itemMatches(Sku item1Sku, Product item1Product, Map&lt;String, OrderItemAttribute&gt; item1Attributes,">1047      protected boolean itemMatches(Sku item1Sku, Product item1Product, Map&lt;String, OrderItemAttribute&gt; item1AttribuðŸ”µ</abbr>
1048              OrderItemRequestDTO item2) {
1049          // Must match on SKU and options
1050          if (item1Sku != null &amp;&amp; item2.getSkuId() != null) {
1051              if (item1Sku.getId().equals(item2.getSkuId())) {
1052                  return true;
1053              }
1054          } else {
1055              if (item1Product != null &amp;&amp; item2.getProductId() != null) {
1056                  if (item1Product.getId().equals(item2.getProductId())) {
1057                      return compareAttributes(item1Attributes, item2);
1058                  }
1059              }
1060          }
1061          return false;
1062      }
1063  
1064      protected OrderItem findMatchingItem(Order order, OrderItemRequestDTO itemToFind) {
1065          if (order == null) {
1066              return null;
1067          }
1068          for (OrderItem currentItem : order.getOrderItems()) {
1069              if (currentItem instanceof DiscreteOrderItem) {
1070                  DiscreteOrderItem discreteItem = (DiscreteOrderItem) currentItem;
<abbr title="1071                  if (itemMatches(discreteItem.getSku(), discreteItem.getProduct(), discreteItem.getOrderItemAttributes(),">1071                  if (itemMatches(discreteItem.getSku(), discreteItem.getProduct(), discreteItem.getOrderItemAttribuðŸ”µ</abbr>
1072                          itemToFind)) {
1073                      return discreteItem;
1074                  }
1075              } else if (currentItem instanceof BundleOrderItem) {
1076                  BundleOrderItem bundleItem = (BundleOrderItem) currentItem;
1077                  if (itemMatches(bundleItem.getSku(), bundleItem.getProduct(), null, itemToFind)) {
1078                      return bundleItem;
1079                  }
1080              }
1081          }
1082          return null;
1083      }
1084  
1085      @Override
1086      @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = { UpdateCartException.class })
<abbr title="1087      public Order updateProductOptionsForItem(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throws UpdateCartException {">1087      public Order updateProductOptionsForItem(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOðŸ”µ</abbr>
1088          try {
<abbr title="1089              CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestDTO, priceOrder);">1089              CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestðŸ”µ</abbr>
<abbr title="1090              ProcessContext&lt;CartOperationRequest&gt; context = (ProcessContext&lt;CartOperationRequest&gt;) updateProductOptionsForItemWorkflow.doActivities(cartOpRequest);">1090              ProcessContext&lt;CartOperationRequest&gt; context = (ProcessContext&lt;CartOperationRequest&gt;) updateProductOptðŸ”µ</abbr>
<abbr title="1091              context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getActivityMessages());">1091              context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getActivityMesðŸ”µ</abbr>
1092              return context.getSeedData().getOrder();
1093          } catch (WorkflowException e) {
1094              throw new UpdateCartException(&quot;Could not product options&quot;, getCartOperationExceptionRootCause(e));
1095          }
1096      }
1097  
1098      @Override
1099      public Order reloadOrder(Order order) {
1100          if (order == null || order instanceof NullOrderImpl || order.getId() == null) {
1101              return order;
1102          }
1103  
1104          return orderDao.readOrderById(order.getId(), true);
1105      }
1106  
1107      @Override
1108      @Transactional(&quot;blTransactionManager&quot;)
1109      public boolean acquireLock(Order order) {
1110          return orderDao.acquireLock(order);
1111      }
1112  
1113      @Override
1114      public boolean releaseLock(Order order) {
1115          return orderDao.releaseLock(order);
1116      }
1117  
1118      @Override
1119      public void printOrder(Order order, Log log) {
1120          if (!log.isDebugEnabled()) {
1121              return;
1122          }
1123  
1124          TableCreator tc = new TableCreator(new TableCreator.Col[] {
1125              new TableCreator.Col(&quot;Order Item&quot;, 30),
1126              new TableCreator.Col(&quot;Qty&quot;),
1127              new TableCreator.Col(&quot;Unit Price&quot;),
1128              new TableCreator.Col(&quot;Avg Adj&quot;),
1129              new TableCreator.Col(&quot;Total Adj&quot;),
1130              new TableCreator.Col(&quot;Total Price&quot;)
1131          });
1132  
1133          for (OrderItem oi : order.getOrderItems()) {
1134              tc.addRow(new String[] {
1135                  oi.getName(),
1136                  String.valueOf(oi.getQuantity()),
1137                  String.valueOf(oi.getPriceBeforeAdjustments(true)),
1138                  String.valueOf(oi.getAverageAdjustmentValue()),
1139                  String.valueOf(oi.getTotalAdjustmentValue()),
1140                  String.valueOf(oi.getTotalPrice())
1141              });
1142          }
1143  
1144          tc.addSeparator()
1145              .withGlobalRowHeaderWidth(15)
1146              .addRow(&quot;Subtotal&quot;, order.getSubTotal())
1147              .addRow(&quot;Order Adj.&quot;, order.getOrderAdjustmentsValue())
1148              .addRow(&quot;Tax&quot;, order.getTotalTax())
1149              .addRow(&quot;Shipping&quot;, order.getTotalShipping())
1150              .addRow(&quot;Total&quot;, order.getTotal())
1151              .addSeparator();
1152  
1153          log.debug(tc.toString());
1154      }
1155  
1156      @Override
1157      public void preValidateCartOperation(Order cart) {
1158          ExtensionResultHolder erh = new ExtensionResultHolder();
1159          extensionManager.getProxy().preValidateCartOperation(cart, erh);
1160          if (erh.getThrowable() instanceof IllegalCartOperationException) {
1161              throw ((IllegalCartOperationException) erh.getThrowable());
1162          } else if (erh.getThrowable() != null) {
1163              throw new RuntimeException(erh.getThrowable());
1164          }
1165      }
1166  
1167      @Override
1168      public void preValidateUpdateQuantityOperation(Order cart, OrderItemRequestDTO dto) {
1169          ExtensionResultHolder erh = new ExtensionResultHolder();
1170          extensionManager.getProxy().preValidateUpdateQuantityOperation(cart, dto, erh);
1171          if (erh.getThrowable() instanceof IllegalCartOperationException) {
1172              throw ((IllegalCartOperationException) erh.getThrowable());
1173          } else if (erh.getThrowable() != null) {
1174              throw new RuntimeException(erh.getThrowable());
1175          }
1176      }
1177  
1178      @Override
1179      public void refresh(Order order) {
1180          orderDao.refresh(order);
1181      }
1182  
1183      @Override
1184      public Order findCartForCustomerWithEnhancements(Customer customer) {
1185          ExtensionResultHolder&lt;Order&gt; erh = new ExtensionResultHolder&lt;Order&gt;();
<abbr title="1186          ExtensionResultStatusType resultStatusType = extensionManager.findCartForCustomerWithEnhancements(customer, erh);">1186          ExtensionResultStatusType resultStatusType = extensionManager.findCartForCustomerWithEnhancements(customerðŸ”µ</abbr>
1187          if (ExtensionResultStatusType.NOT_HANDLED != resultStatusType) {
1188              return erh.getResult();
1189          }
1190          return findCartForCustomer(customer);
1191      }
1192  
1193      @Override
1194      public Order findCartForCustomerWithEnhancements(Customer customer, Order candidateOrder) {
1195          ExtensionResultHolder&lt;Order&gt; erh = new ExtensionResultHolder&lt;Order&gt;();
<abbr title="1196          ExtensionResultStatusType resultStatusType = extensionManager.findCartForCustomerWithEnhancements(customer, candidateOrder, erh);">1196          ExtensionResultStatusType resultStatusType = extensionManager.findCartForCustomerWithEnhancements(customerðŸ”µ</abbr>
1197          if (ExtensionResultStatusType.NOT_HANDLED != resultStatusType) {
1198              return erh.getResult();
1199          }
1200          return candidateOrder;
1201      }
1202  
1203      @Override
1204      public List&lt;Order&gt; findOrdersByEmail(String email) {
1205          return orderDao.readOrdersByEmail(email);
1206      }
1207  
1208      @Override
1209      public List&lt;Order&gt; readBatchOrders(int start, int pageSize, List&lt;OrderStatus&gt; orderStatusList) {
1210          return orderDao.readBatchOrders(start, pageSize, orderStatusList);
1211      }
1212  
1213      @Override
1214  	public Long readNumberOfOrders() {
1215      		return orderDao.readNumberOfOrders();
1216      }
1217  }</pre></td>
                            <td><pre>   1  /*
   2   * #%L
   3   * BroadleafCommerce Framework
   4   * %%
   5   * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6   * %%
   7   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10   * the Broadleaf End User License Agreement (EULA), Version 1.1
  11   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12   * shall apply.
  13   *
<abbr title="  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  15   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  16   * #L%
  17   */
  18  package org.broadleafcommerce.core.order.service;
  19  
  20  import org.apache.commons.collections.CollectionUtils;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  21 -import org.apache.commons.lang3.builder.CompareToBuilder;</span>
  22  import org.apache.commons.logging.Log;
  23  import org.apache.commons.logging.LogFactory;
  24  import org.broadleafcommerce.common.extension.ExtensionResultHolder;
  25  import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  26  import org.broadleafcommerce.common.payment.PaymentType;
  27  import org.broadleafcommerce.common.util.BLCSystemProperty;
  28  import org.broadleafcommerce.common.util.TableCreator;
  29  import org.broadleafcommerce.common.util.TransactionUtils;
  30  import org.broadleafcommerce.common.util.TypedPredicate;
  31  import org.broadleafcommerce.common.web.BroadleafRequestContext;
  32  import org.broadleafcommerce.core.catalog.domain.Product;
  33  import org.broadleafcommerce.core.catalog.domain.Sku;
  34  import org.broadleafcommerce.core.offer.dao.OfferDao;
  35  import org.broadleafcommerce.core.offer.domain.Offer;
  36  import org.broadleafcommerce.core.offer.domain.OfferCode;
  37  import org.broadleafcommerce.core.offer.service.OfferService;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  38 -import org.broadleafcommerce.core.offer.service.OfferServiceExtensionHandler;</span>
  39  import org.broadleafcommerce.core.offer.service.OfferServiceExtensionManager;
  40  import org.broadleafcommerce.core.offer.service.exception.OfferAlreadyAddedException;
  41  import org.broadleafcommerce.core.offer.service.exception.OfferException;
  42  import org.broadleafcommerce.core.offer.service.exception.OfferExpiredException;
  43  import org.broadleafcommerce.core.offer.service.exception.OfferMaxUseExceededException;
  44  import org.broadleafcommerce.core.order.dao.OrderDao;
  45  import org.broadleafcommerce.core.order.domain.BundleOrderItem;
  46  import org.broadleafcommerce.core.order.domain.DiscreteOrderItem;
  47  import org.broadleafcommerce.core.order.domain.GiftWrapOrderItem;
  48  import org.broadleafcommerce.core.order.domain.NullOrderFactory;
  49  import org.broadleafcommerce.core.order.domain.NullOrderImpl;
  50  import org.broadleafcommerce.core.order.domain.Order;
  51  import org.broadleafcommerce.core.order.domain.OrderItem;
  52  import org.broadleafcommerce.core.order.domain.OrderItemAttribute;
  53  import org.broadleafcommerce.core.order.service.call.ActivityMessageDTO;
  54  import org.broadleafcommerce.core.order.service.call.GiftWrapOrderItemRequest;
  55  import org.broadleafcommerce.core.order.service.call.OrderItemRequestDTO;
  56  import org.broadleafcommerce.core.order.service.exception.AddToCartException;
  57  import org.broadleafcommerce.core.order.service.exception.IllegalCartOperationException;
  58  import org.broadleafcommerce.core.order.service.exception.ItemNotFoundException;
  59  import org.broadleafcommerce.core.order.service.exception.RemoveFromCartException;
  60  import org.broadleafcommerce.core.order.service.exception.UpdateCartException;
  61  import org.broadleafcommerce.core.order.service.type.OrderStatus;
  62  import org.broadleafcommerce.core.order.service.workflow.CartOperationRequest;
  63  import org.broadleafcommerce.core.payment.dao.OrderPaymentDao;
  64  import org.broadleafcommerce.core.payment.domain.OrderPayment;
  65  import org.broadleafcommerce.core.payment.domain.secure.Referenced;
  66  import org.broadleafcommerce.core.payment.service.SecureOrderPaymentService;
  67  import org.broadleafcommerce.core.pricing.service.PricingService;
  68  import org.broadleafcommerce.core.pricing.service.exception.PricingException;
  69  import org.broadleafcommerce.core.workflow.ActivityMessages;
  70  import org.broadleafcommerce.core.workflow.ProcessContext;
  71  import org.broadleafcommerce.core.workflow.Processor;
  72  import org.broadleafcommerce.core.workflow.WorkflowException;
  73  import org.broadleafcommerce.profile.core.domain.Customer;

  74  import org.hibernate.FlushMode;
  75  import org.hibernate.Session;
  76  import org.hibernate.exception.LockAcquisitionException;
  77  import org.springframework.beans.factory.annotation.Value;
  78  import org.springframework.jmx.export.annotation.ManagedAttribute;
  79  import org.springframework.jmx.export.annotation.ManagedResource;
  80  import org.springframework.stereotype.Service;
  81  import org.springframework.transaction.PlatformTransactionManager;
  82  import org.springframework.transaction.TransactionDefinition;
  83  import org.springframework.transaction.TransactionStatus;
  84  import org.springframework.transaction.annotation.Transactional;
  85  
  86  import java.math.BigDecimal;
  87  import java.util.ArrayList;
  88  import java.util.Collections;
  89  import java.util.Comparator;
  90  import java.util.Date;
  91  import java.util.List;
  92  import java.util.Map;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  93 +import java.util.Objects;</span>
  94  import java.util.Set;
  95  
  96  import javax.annotation.Resource;
  97  import javax.persistence.EntityManager;
  98  import javax.persistence.PersistenceContext;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  99 -</span>
 100  
 101  /**
 102   * @author apazzolini
 103   */
 104  @Service(&quot;blOrderService&quot;)
<abbr title=" 105  @ManagedResource(objectName=&quot;org.broadleafcommerce:name=OrderService&quot;, description=&quot;Order Service&quot;, currencyTimeLimit=15)"> 105  @ManagedResource(objectName=&quot;org.broadleafcommerce:name=OrderService&quot;, description=&quot;Order Service&quot;, currencyTimeLiðŸ”µ</abbr>
 106  public class OrderServiceImpl implements OrderService {
 107      private static final Log LOG = LogFactory.getLog(OrderServiceImpl.class);
 108  
 109      /* DAOs */
 110      @Resource(name = &quot;blOrderPaymentDao&quot;)
 111      protected OrderPaymentDao paymentDao;
 112  
 113      @Resource(name = &quot;blOrderDao&quot;)
 114      protected OrderDao orderDao;
 115  
 116      @Resource(name = &quot;blOfferDao&quot;)
 117      protected OfferDao offerDao;
 118  
 119      /* Factories */
 120      @Resource(name = &quot;blNullOrderFactory&quot;)
 121      protected NullOrderFactory nullOrderFactory;
 122  
 123      /* Services */



 124      @Resource(name = &quot;blPricingService&quot;)
 125      protected PricingService pricingService;
 126  
 127      @Resource(name = &quot;blOrderItemService&quot;)
 128      protected OrderItemService orderItemService;
 129  
 130      @Resource(name = &quot;blFulfillmentGroupService&quot;)
 131      protected FulfillmentGroupService fulfillmentGroupService;
 132  
 133      @Resource(name = &quot;blOfferService&quot;)
 134      protected OfferService offerService;
 135  
 136      @Resource(name = &quot;blSecureOrderPaymentService&quot;)
 137      protected SecureOrderPaymentService securePaymentInfoService;
 138  
 139      @Resource(name = &quot;blMergeCartService&quot;)
 140      protected MergeCartService mergeCartService;
 141  
 142      @Resource(name = &quot;blOrderServiceExtensionManager&quot;)
 143      protected OrderServiceExtensionManager extensionManager;
 144  
 145      /* Workflows */
 146      @Resource(name = &quot;blAddItemWorkflow&quot;)
 147      protected Processor addItemWorkflow;
 148  
 149      @Resource(name = &quot;blUpdateProductOptionsForItemWorkflow&quot;)
 150      private Processor updateProductOptionsForItemWorkflow;
 151  
 152      @Resource(name = &quot;blUpdateItemWorkflow&quot;)
 153      protected Processor updateItemWorkflow;
 154  
 155      @Resource(name = &quot;blRemoveItemWorkflow&quot;)
 156      protected Processor removeItemWorkflow;
 157  
 158      @Resource(name = &quot;blTransactionManager&quot;)
 159      protected PlatformTransactionManager transactionManager;
 160  
 161      @Value(&quot;${pricing.retry.count.for.lock.failure}&quot;)
 162      protected int pricingRetryCountForLockFailure = 3;
 163  
 164      @Value(&quot;${pricing.retry.wait.interval.for.lock.failure}&quot;)
 165      protected long pricingRetryWaitIntervalForLockFailure = 500L;
 166  
 167      /**
 168       * Advanced setting. Should Hibernate auto flush before queries during an
 169       * add-to-cart workflow. This should generally be able to be left false. This is a performance measure and
 170       * add-to-cart operations will be more efficient when this is false.
 171       */
 172      @Value(&quot;${auto.flush.on.query.during.add.to.cart:false}&quot;)
 173      protected boolean autoFlushAddToCart = false;
 174  
 175      /**
 176       * Advanced setting. Should Hibernate auto flush before queries during an
 177       * update-cart workflow. This should generally be able to be left false. This is a performance measure and
 178       * update-cart operations will be more efficient when this is false.
 179       */
 180      @Value(&quot;${auto.flush.on.query.during.update.cart:false}&quot;)
 181      protected boolean autoFlushUpdateCart = false;
 182  
 183      /**
 184       * Advanced setting. Should Hibernate auto flush before queries during an
<abbr title=" 185       * remove-from-cart workflow. This should generally be able to be left false. This is a performance measure and"> 185       * remove-from-cart workflow. This should generally be able to be left false. This is a performance measure anðŸ”µ</abbr>
 186       * remove-from-cart operations will be more efficient when this is false.
 187       */
 188      @Value(&quot;${auto.flush.on.query.during.remove.from.cart:false}&quot;)
 189      protected boolean autoFlushRemoveFromCart = false;
 190  
 191      /**
 192       * Advanced setting. Should Hibernate auto flush before queries during an
 193       * order save pricing flow. This should generally be able to be left false. This is a performance measure and
 194       * save operations will be more efficient when this is false.
 195       */
 196      @Value(&quot;${auto.flush.on.query.during.cart.pricing.save:false}&quot;)
 197      protected boolean autoFlushSaveCart = false;
 198  
 199      @PersistenceContext(unitName=&quot;blPU&quot;)
 200      protected EntityManager em;
 201  
 202      /* Fields */
 203      protected boolean moveNamedOrderItems = true;
 204      protected boolean deleteEmptyNamedOrders = true;
 205  
 206      protected Boolean automaticallyMergeLikeItems;
 207  
 208      @Resource(name = &quot;blOrderMultishipOptionService&quot;)
 209      protected OrderMultishipOptionService orderMultishipOptionService;
 210  
 211      @Resource(name = &quot;blOfferServiceExtensionManager&quot;)
 212      protected OfferServiceExtensionManager offerServiceExtensionManager;
 213  
 214  
 215      @Override
 216      @Transactional(&quot;blTransactionManager&quot;)
 217      public Order createNewCartForCustomer(Customer customer) {

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 218 -        return orderDao.createNewCartForCustomer(customer);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 219 +        final Object lock = Objects.isNull(customer.getId()) ? customer : customer.getId();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 220 +        synchronized (lock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 221 +            return orderDao.createNewCartForCustomer(customer);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 222 +        }</span>
 223      }
 224  
 225      @Override
 226      @Transactional(&quot;blTransactionManager&quot;)
 227      public Order createNamedOrderForCustomer(String name, Customer customer) {
 228          Order namedOrder = orderDao.create();
 229          namedOrder.setCustomer(customer);
 230          namedOrder.setName(name);
 231          namedOrder.setStatus(OrderStatus.NAMED);
 232  
 233          if (extensionManager != null) {
 234              extensionManager.getProxy().attachAdditionalDataToNewNamedCart(customer, namedOrder);
 235          }
 236  
 237          if (BroadleafRequestContext.getBroadleafRequestContext() != null) {
 238              namedOrder.setLocale(BroadleafRequestContext.getBroadleafRequestContext().getLocale());
 239          }
 240  
 241          return persist(namedOrder); // No need to price here
 242      }
 243  
 244      @Override
 245      public Order findNamedOrderForCustomer(String name, Customer customer) {
 246          return orderDao.readNamedOrderForCustomer(customer, name);
 247      }
 248  
 249      @Override
 250      public Order findOrderById(Long orderId) {
 251          return orderDao.readOrderById(orderId);
 252      }
 253  
 254      @Override
 255      public List&lt;Order&gt; findOrdersByIds(List&lt;Long&gt; orderIds) {
 256          return orderDao.readOrdersByIds(orderIds);
 257      }
 258  
 259      @Override
 260      public Order findOrderById(Long orderId, boolean refresh) {
 261          return orderDao.readOrderById(orderId, refresh);
 262      }
 263  
 264      @Override
 265      public Order getNullOrder() {
 266          return nullOrderFactory.getNullOrder();
 267      }
 268  
 269      @Override
 270      public Order findCartForCustomer(Customer customer) {
 271          return orderDao.readCartForCustomer(customer);
 272      }
 273  
 274      @Override
 275      public List&lt;Order&gt; findOrdersForCustomer(Customer customer) {
 276          return orderDao.readOrdersForCustomer(customer.getId());
 277      }
 278  
 279      @Override
 280      public List&lt;Order&gt; findOrdersForCustomer(Customer customer, OrderStatus status) {
 281          return orderDao.readOrdersForCustomer(customer, status);
 282      }
 283  
 284      @Override
 285      public Order findOrderByOrderNumber(String orderNumber) {
 286          return orderDao.readOrderByOrderNumber(orderNumber);
 287      }
 288  
 289      @Override
 290      public List&lt;Order&gt; findOrdersByDateRange(Date startDate, Date endDate) {
 291          return orderDao.readOrdersByDateRange(startDate, endDate);
 292      }
 293  
 294      @Override
 295      public List&lt;Order&gt; findOrdersByDaysCount(Integer daysCount, Integer batchSize) {
 296          return orderDao.readOrdersOlderThanDaysCount(daysCount, batchSize);
 297      }
 298  
 299      @Override
 300      public List&lt;Order&gt; findOrdersForCustomersInDateRange(List&lt;Long&gt; customerIds, Date startDate, Date endDate) {
 301          return orderDao.readOrdersForCustomersInDateRange(customerIds, startDate, endDate);
 302      }
 303  
 304      @Override
 305      public List&lt;OrderPayment&gt; findPaymentsForOrder(Order order) {
 306          return paymentDao.readPaymentsForOrder(order);
 307      }
 308  
 309      @Override
 310      @Transactional(&quot;blTransactionManager&quot;)
 311      public OrderPayment addPaymentToOrder(Order order, OrderPayment payment, Referenced securePaymentInfo) {
 312          payment.setOrder(order);
 313          order.getPayments().add(payment);
 314          order = persist(order);
 315          int paymentIndex = order.getPayments().size() - 1;
 316  
 317          if (securePaymentInfo != null) {
 318              securePaymentInfoService.save(securePaymentInfo);
 319          }
 320  
 321          return order.getPayments().get(paymentIndex);
 322      }
 323  
 324      @Override
 325      public Order save(Order order, boolean priceOrder, boolean repriceItems) throws PricingException {
 326          if (repriceItems) {
 327              order.updatePrices();
 328          }
 329          return save(order, priceOrder);
 330      }
 331  
 332      @Override
 333      public Order save(Order order, Boolean priceOrder) throws PricingException {
 334          //persist the order first
 335          TransactionStatus status = TransactionUtils.createTransaction(&quot;saveOrder&quot;,
 336                      TransactionDefinition.PROPAGATION_REQUIRED, transactionManager);
 337          try {
 338              order = persist(order);
 339              TransactionUtils.finalizeTransaction(status, transactionManager, false);
 340          } catch (RuntimeException ex) {
 341              TransactionUtils.finalizeTransaction(status, transactionManager, true);
 342              throw ex;
 343          }
 344  
 345          //make any pricing changes - possibly retrying with the persisted state if there&#x27;s a lock failure
 346          if (priceOrder) {
 347              int retryCount = 0;
 348              boolean isValid = false;
 349              while (!isValid) {
 350                  Session session = em.unwrap(Session.class);
 351                  FlushMode current = session.getHibernateFlushMode();
 352                  try {
 353                      if (!autoFlushSaveCart) {
<abbr title=" 354                          //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 354                          //Performance measure. Hibernate will sometimes perform an autoflush when performing queryðŸ”µ</abbr>
<abbr title=" 355                          //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 355                          //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries ðŸ”µ</abbr>
 356                          //incorrect results because something has not been flushed to the database yet.
 357                          session.setHibernateFlushMode(FlushMode.MANUAL);
 358                      }
 359                      order = pricingService.executePricing(order);
 360                      isValid = true;
 361                  } catch (Exception ex) {
 362                      boolean isValidCause = false;
 363                      Throwable cause = ex;
 364                      while (!isValidCause) {
 365                          if (cause.getClass().equals(LockAcquisitionException.class)) {
 366                              isValidCause = true;
 367                          }
 368                          cause = cause.getCause();
 369                          if (cause == null) {
 370                              break;
 371                          }
 372                      }
 373                      if (isValidCause) {
 374                          if (LOG.isInfoEnabled()) {
 375                              LOG.info(&quot;Problem acquiring lock during pricing call - attempting to price again.&quot;);
 376                          }
 377                          isValid = false;
 378                          if (retryCount &gt;= pricingRetryCountForLockFailure) {
 379                              if (LOG.isInfoEnabled()) {
<abbr title=" 380                                  LOG.info(&quot;Problem acquiring lock during pricing call. Retry limit exceeded at (&quot; + retryCount + &quot;). Throwing exception.&quot;);"> 380                                  LOG.info(&quot;Problem acquiring lock during pricing call. Retry limit exceeded at (&quot; +ðŸ”µ</abbr>
 381                              }
 382                              if (ex instanceof PricingException) {
 383                                  throw (PricingException) ex;
 384                              } else {
 385                                  throw new PricingException(ex);
 386                              }
 387                          } else {
 388                              order = findOrderById(order.getId());
 389                              retryCount++;
 390                          }
 391                          try {
 392                              Thread.sleep(pricingRetryWaitIntervalForLockFailure);
 393                          } catch (Throwable e) {
 394                              //do nothing
 395                          }
 396                      } else {
 397                          if (ex instanceof PricingException) {
 398                              throw (PricingException) ex;
 399                          } else {
 400                              throw new PricingException(ex);
 401                          }
 402                      }
 403                  } finally {
 404                      if (!autoFlushSaveCart) {
 405                          session.setHibernateFlushMode(current);
 406                      }
 407                  }
 408              }
 409  
 410              //make the final save of the priced order
 411              status = TransactionUtils.createTransaction(&quot;saveOrder&quot;,
 412                                  TransactionDefinition.PROPAGATION_REQUIRED, transactionManager);
 413              Session session = em.unwrap(Session.class);
 414              FlushMode current = session.getHibernateFlushMode();
 415              try {
 416                  if (!autoFlushSaveCart) {
<abbr title=" 417                      //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 417                      //Performance measure. Hibernate will sometimes perform an autoflush when performing query opeðŸ”µ</abbr>
<abbr title=" 418                      //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 418                      //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in tðŸ”µ</abbr>
 419                      //incorrect results because something has not been flushed to the database yet.
 420                      session.setHibernateFlushMode(FlushMode.MANUAL);
 421                  }
 422                  order = persist(order);
 423  
 424                  if (extensionManager != null) {
 425                      extensionManager.getProxy().attachAdditionalDataToOrder(order, priceOrder);
 426                  }
 427                  if (!autoFlushSaveCart) {
 428                      session.setFlushMode(current);
 429                  }
 430                  TransactionUtils.finalizeTransaction(status, transactionManager, false);
 431              } catch (RuntimeException ex) {
 432                  TransactionUtils.finalizeTransaction(status, transactionManager, true);
 433                  throw ex;
 434              } finally {
 435                  if (!autoFlushSaveCart &amp;&amp; !session.getFlushMode().equals(current)) {
 436                      session.setHibernateFlushMode(current);
 437                  }
 438              }
 439          }
 440  
 441          return order;
 442      }
 443  
 444      // This method exists to provide OrderService methods the ability to save an order
 445      // without having to worry about a PricingException being thrown.
 446      protected Order persist(Order order) {
 447          return orderDao.save(order);
 448      }
 449  
 450      @Override
 451      @Transactional(&quot;blTransactionManager&quot;)
 452      public void cancelOrder(Order order) {
 453          orderDao.delete(order);
 454      }
 455  
 456      @Override
 457      @Transactional(&quot;blTransactionManager&quot;)
 458      public void deleteOrder(Order order) {
 459          orderMultishipOptionService.deleteAllOrderMultishipOptions(order);
 460          orderDao.delete(order);
 461      }
 462  
 463      @Override
 464      @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 465      public Order addOfferCode(Order order, OfferCode offerCode, boolean priceOrder) throws PricingException, OfferException {"> 465      public Order addOfferCode(Order order, OfferCode offerCode, boolean priceOrder) throws PricingException, OfferðŸ”µ</abbr>
 466          ArrayList&lt;OfferCode&gt; offerCodes = new ArrayList&lt;OfferCode&gt;();
 467          offerCodes.add(offerCode);
 468          return addOfferCodes(order, offerCodes, priceOrder);
 469      }
 470  
 471      @Override
 472      @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 473      public Order addOfferCodes(Order order, List&lt;OfferCode&gt; offerCodes, boolean priceOrder) throws PricingException, OfferException {"> 473      public Order addOfferCodes(Order order, List&lt;OfferCode&gt; offerCodes, boolean priceOrder) throws PricingExceptioðŸ”µ</abbr>
 474          preValidateCartOperation(order);
 475          Set&lt;Offer&gt; addedOffers = offerService.getUniqueOffersFromOrder(order);
 476          if (extensionManager != null) {
 477              extensionManager.getProxy().addOfferCodes(order, offerCodes, priceOrder);
 478          }
 479          if (offerCodes != null &amp;&amp; !offerCodes.isEmpty()) {
 480              for (OfferCode offerCode : offerCodes) {
 481  
<abbr title=" 482                  if (order.getAddedOfferCodes().contains(offerCode) || addedOffers.contains(offerCode.getOffer())) {"> 482                  if (order.getAddedOfferCodes().contains(offerCode) || addedOffers.contains(offerCode.getOffer())) ðŸ”µ</abbr>
 483                      throw new OfferAlreadyAddedException(&quot;The offer has already been added.&quot;);
 484                  } else if (!offerService.verifyMaxCustomerUsageThreshold(order, offerCode)) {
<abbr title=" 485                      throw new OfferMaxUseExceededException(&quot;The customer has used this offer code more than the maximum allowed number of times.&quot;);"> 485                      throw new OfferMaxUseExceededException(&quot;The customer has used this offer code more than the maðŸ”µ</abbr>
 486                  } else if (!offerCode.isActive() || !offerCode.getOffer().isActive()) {
 487                      throw new OfferExpiredException(&quot;The offer has expired.&quot;);
 488                  }
 489  
 490                  order.getAddedOfferCodes().add(offerCode);
 491  
 492              }
 493              order = save(order, priceOrder);
 494          }
 495  
 496          return order;
 497      }
 498  
 499      @Override
 500      @Transactional(&quot;blTransactionManager&quot;)
 501      public Order removeOfferCode(Order order, OfferCode offerCode, boolean priceOrder) throws PricingException {
 502          order.getAddedOfferCodes().remove(offerCode);
 503          offerServiceExtensionManager.removeOfferCodeFromOrder(offerCode, order);
 504          order = save(order, priceOrder);
 505          return order;
 506      }
 507  
 508      @Override
 509      @Transactional(&quot;blTransactionManager&quot;)
 510      public Order removeAllOfferCodes(Order order, boolean priceOrder) throws PricingException {
 511           order.getAddedOfferCodes().clear();
 512           order = save(order, priceOrder);
 513           return order;
 514      }
 515  
 516      @Override
<abbr title=" 517      @ManagedAttribute(description=&quot;The delete empty named order after adding items to cart attribute&quot;, currencyTimeLimit=15)"> 517      @ManagedAttribute(description=&quot;The delete empty named order after adding items to cart attribute&quot;, currencyTimðŸ”µ</abbr>
 518      public void setDeleteEmptyNamedOrders(boolean deleteEmptyNamedOrders) {
 519          this.deleteEmptyNamedOrders = deleteEmptyNamedOrders;
 520      }
 521  
 522      @Override
 523      public OrderItem findLastMatchingItem(Order order, Long skuId, Long productId) {
 524          if (order.getOrderItems() != null) {
 525              for (int i=(order.getOrderItems().size()-1); i &gt;= 0; i--) {
 526                  OrderItem currentItem = (order.getOrderItems().get(i));
 527                  if (currentItem instanceof DiscreteOrderItem) {
 528                      DiscreteOrderItem discreteItem = (DiscreteOrderItem) currentItem;
 529                      if (skuId != null) {
 530                          if (discreteItem.getSku() != null &amp;&amp; skuId.equals(discreteItem.getSku().getId())) {
 531                              return discreteItem;
 532                          }
<abbr title=" 533                      } else if (productId != null &amp;&amp; discreteItem.getProduct() != null &amp;&amp; productId.equals(discreteItem.getProduct().getId())) {"> 533                      } else if (productId != null &amp;&amp; discreteItem.getProduct() != null &amp;&amp; productId.equals(discreteðŸ”µ</abbr>
 534                          return discreteItem;
 535                      }
 536  
 537                  } else if (currentItem instanceof BundleOrderItem) {
 538                      BundleOrderItem bundleItem = (BundleOrderItem) currentItem;
 539                      if (skuId != null) {
 540                          if (bundleItem.getSku() != null &amp;&amp; skuId.equals(bundleItem.getSku().getId())) {
 541                              return bundleItem;
 542                          }
<abbr title=" 543                      } else if (productId != null &amp;&amp; bundleItem.getProduct() != null &amp;&amp; productId.equals(bundleItem.getProduct().getId())) {"> 543                      } else if (productId != null &amp;&amp; bundleItem.getProduct() != null &amp;&amp; productId.equals(bundleItemðŸ”µ</abbr>
 544                          return bundleItem;
 545                      }
 546                  }
 547              }
 548          }
 549          return null;
 550      }
 551  
 552      @Override
 553      @Transactional(&quot;blTransactionManager&quot;)
 554      public Order confirmOrder(Order order) {
 555          return orderDao.submitOrder(order);
 556      }
 557  
 558      @Override
 559      @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 560      public Order addAllItemsFromNamedOrder(Order namedOrder, boolean priceOrder) throws RemoveFromCartException, AddToCartException {"> 560      public Order addAllItemsFromNamedOrder(Order namedOrder, boolean priceOrder) throws RemoveFromCartException, AðŸ”µ</abbr>
 561          Order cartOrder = orderDao.readCartForCustomer(namedOrder.getCustomer());
 562          if (cartOrder == null) {
 563              cartOrder = createNewCartForCustomer(namedOrder.getCustomer());
 564          }
 565          List&lt;OrderItem&gt; items = new ArrayList&lt;OrderItem&gt;(namedOrder.getOrderItems());
 566  
 567          // Remove any order items that are children
 568          CollectionUtils.filter(items,  new TypedPredicate&lt;OrderItem&gt;() {
 569              @Override
 570              public boolean eval(OrderItem orderItem) {
 571                  return orderItem.getParentOrderItem() == null;
 572              }
 573          });
 574          for (OrderItem item : items) {
 575              OrderItemRequestDTO orderItemRequest = orderItemService.buildOrderItemRequestDTOFromOrderItem(item);
 576              cartOrder = addItem(cartOrder.getId(), orderItemRequest, priceOrder);
 577  
 578              if (moveNamedOrderItems) {
 579                  removeItem(namedOrder.getId(), item.getId(), false);
 580              }
 581          }
 582  
 583          if (deleteEmptyNamedOrders) {
 584              cancelOrder(namedOrder);
 585          }
 586  
 587          return cartOrder;
 588      }
 589  
 590      @Override
 591      @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 592      public Order addItemFromNamedOrder(Order namedOrder, OrderItem item, boolean priceOrder) throws RemoveFromCartException, AddToCartException {"> 592      public Order addItemFromNamedOrder(Order namedOrder, OrderItem item, boolean priceOrder) throws RemoveFromCartðŸ”µ</abbr>
 593          Order cartOrder = orderDao.readCartForCustomer(namedOrder.getCustomer());
 594          if (cartOrder == null) {
 595              cartOrder = createNewCartForCustomer(namedOrder.getCustomer());
 596          }
 597  
 598          OrderItemRequestDTO orderItemRequest = orderItemService.buildOrderItemRequestDTOFromOrderItem(item);
 599          cartOrder = addItem(cartOrder.getId(), orderItemRequest, priceOrder);
 600  
 601          if (moveNamedOrderItems) {
 602              removeItem(namedOrder.getId(), item.getId(), false);
 603          }
 604  
 605          if (namedOrder.getOrderItems().size() == 0 &amp;&amp; deleteEmptyNamedOrders) {
 606              cancelOrder(namedOrder);
 607          }
 608  
 609          return cartOrder;
 610      }
 611  
 612      @Override
 613      @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 614      public Order addItemFromNamedOrder(Order namedOrder, OrderItem item, int quantity, boolean priceOrder) throws RemoveFromCartException, AddToCartException, UpdateCartException {"> 614      public Order addItemFromNamedOrder(Order namedOrder, OrderItem item, int quantity, boolean priceOrder) throws ðŸ”µ</abbr>
 615          // Validate that the quantity requested makes sense
 616          if (quantity &lt; 1 || quantity &gt; item.getQuantity()) {
 617              throw new IllegalArgumentException(&quot;Cannot move 0 or less quantity&quot;);
 618          } else if (quantity == item.getQuantity()) {
 619              return addItemFromNamedOrder(namedOrder, item, priceOrder);
 620          }
 621  
 622          Order cartOrder = orderDao.readCartForCustomer(namedOrder.getCustomer());
 623          if (cartOrder == null) {
 624              cartOrder = createNewCartForCustomer(namedOrder.getCustomer());
 625          }
 626  
 627          OrderItemRequestDTO orderItemRequest = orderItemService.buildOrderItemRequestDTOFromOrderItem(item);
 628          orderItemRequest.setQuantity(quantity);
 629          cartOrder = addItem(cartOrder.getId(), orderItemRequest, priceOrder);
 630  
 631          if (moveNamedOrderItems) {
 632              // Update the old item to its new quantity only if we&#x27;re moving items
 633              OrderItemRequestDTO orderItemRequestDTO = new OrderItemRequestDTO();
 634              orderItemRequestDTO.setOrderItemId(item.getId());
 635              orderItemRequestDTO.setQuantity(item.getQuantity() - quantity);
 636              updateItemQuantity(namedOrder.getId(), orderItemRequestDTO, false);
 637          }
 638          return cartOrder;
 639      }
 640  
 641      @Override
 642      @Transactional(&quot;blTransactionManager&quot;)
<abbr title=" 643      public OrderItem addGiftWrapItemToOrder(Order order, GiftWrapOrderItemRequest itemRequest, boolean priceOrder) throws PricingException {"> 643      public OrderItem addGiftWrapItemToOrder(Order order, GiftWrapOrderItemRequest itemRequest, boolean priceOrder)ðŸ”µ</abbr>
 644          GiftWrapOrderItem item = orderItemService.createGiftWrapOrderItem(itemRequest);
 645          item.setOrder(order);
 646          item = (GiftWrapOrderItem) orderItemService.saveOrderItem(item);
 647  
 648          order.getOrderItems().add(item);
 649          order = save(order, priceOrder);
 650  
 651          return item;
 652      }
 653  
 654      @Override
 655      @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = {AddToCartException.class})
<abbr title=" 656      public Order addItem(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throws AddToCartException {"> 656      public Order addItem(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throws AddToCaðŸ”µ</abbr>
 657          // Don&#x27;t allow overrides from this method.
 658          orderItemRequestDTO.setOverrideRetailPrice(null);
 659          orderItemRequestDTO.setOverrideSalePrice(null);
 660          return addItemWithPriceOverrides(orderId, orderItemRequestDTO, priceOrder);
 661      }
 662  
 663      @Override
 664      @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = { AddToCartException.class })
<abbr title=" 665      public Order addItemWithPriceOverrides(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throws AddToCartException {"> 665      public Order addItemWithPriceOverrides(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrdðŸ”µ</abbr>
 666          Order order = findOrderById(orderId);
 667          preValidateCartOperation(order);
 668          if (getAutomaticallyMergeLikeItems()) {
 669              OrderItem item = findMatchingItem(order, orderItemRequestDTO);
 670              if (item != null &amp;&amp; item.getParentOrderItem() == null) {
 671                  orderItemRequestDTO.setQuantity(item.getQuantity() + orderItemRequestDTO.getQuantity());
 672                  orderItemRequestDTO.setOrderItemId(item.getId());
 673                  try {
 674                      return updateItemQuantity(orderId, orderItemRequestDTO, priceOrder);
 675                  } catch (RemoveFromCartException e) {
<abbr title=" 676                      throw new AddToCartException(&quot;Unexpected error - system tried to remove item while adding to cart&quot;, e);"> 676                      throw new AddToCartException(&quot;Unexpected error - system tried to remove item while adding to cðŸ”µ</abbr>
 677                  } catch (UpdateCartException e) {
 678                      throw new AddToCartException(&quot;Could not update quantity for matched item&quot;, e);
 679                  }
 680              }
 681          }
 682          try {
<abbr title=" 683              // We only want to price on the last addition for performance reasons and only if the user asked for it."> 683              // We only want to price on the last addition for performance reasons and only if the user asked for iðŸ”µ</abbr>
 684              int numAdditionRequests = priceOrder ? (getTotalChildOrderItems(orderItemRequestDTO)) : -1;
 685              int currentAddition = 1;
 686  
<abbr title=" 687              CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestDTO, currentAddition == numAdditionRequests);"> 687              CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestðŸ”µ</abbr>
 688  
 689              Session session = em.unwrap(Session.class);
 690              FlushMode current = session.getHibernateFlushMode();
 691              if (!autoFlushAddToCart) {
<abbr title=" 692                  //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 692                  //Performance measure. Hibernate will sometimes perform an autoflush when performing query operatiðŸ”µ</abbr>
<abbr title=" 693                  //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 693                  //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the fðŸ”µ</abbr>
 694                  //incorrect results because something has not been flushed to the database yet.
 695                  session.setHibernateFlushMode(FlushMode.MANUAL);
 696              }
 697              ProcessContext&lt;CartOperationRequest&gt; context;
 698              try {
 699                  context = (ProcessContext&lt;CartOperationRequest&gt;) addItemWorkflow.doActivities(cartOpRequest);
 700              } finally {
 701                  if (!autoFlushAddToCart) {
 702                      session.setHibernateFlushMode(current);
 703                  }
 704              }
 705  
 706              List&lt;ActivityMessageDTO&gt; orderMessages = new ArrayList&lt;ActivityMessageDTO&gt;();
 707              orderMessages.addAll(((ActivityMessages) context).getActivityMessages());
 708  
 709              // Update the orderItemRequest incase it changed during the initial add to cart workflow
 710              orderItemRequestDTO = context.getSeedData().getItemRequest();
 711              numAdditionRequests = priceOrder ? (getTotalChildOrderItems(orderItemRequestDTO) - 1) : -1;
 712              addChildItems(orderItemRequestDTO, numAdditionRequests, currentAddition, context, orderMessages);
 713  
 714              context.getSeedData().getOrder().setOrderMessages(orderMessages);
 715              return context.getSeedData().getOrder();
 716          } catch (WorkflowException e) {
 717              throw new AddToCartException(&quot;Could not add to cart&quot;, getCartOperationExceptionRootCause(e));
 718          }
 719  
 720      }
 721  
 722      @Override
 723      public int getTotalChildOrderItems(OrderItemRequestDTO orderItemRequestDTO) {
 724          int count = 1;
 725          for (OrderItemRequestDTO childRequest : orderItemRequestDTO.getChildOrderItems()) {
 726              count += getTotalChildOrderItems(childRequest);
 727          }
 728          return count;
 729      }
 730  
 731      @Override
<abbr title=" 732      public void addChildItems(OrderItemRequestDTO orderItemRequestDTO, int numAdditionRequests, int currentAddition, ProcessContext&lt;CartOperationRequest&gt; context, List&lt;ActivityMessageDTO&gt; orderMessages) throws WorkflowException {"> 732      public void addChildItems(OrderItemRequestDTO orderItemRequestDTO, int numAdditionRequests, int currentAdditioðŸ”µ</abbr>
 733          if (CollectionUtils.isNotEmpty(orderItemRequestDTO.getChildOrderItems())) {
 734              Long parentOrderItemId = context.getSeedData().getOrderItem().getId();
 735              for (OrderItemRequestDTO childRequest : orderItemRequestDTO.getChildOrderItems()) {
 736                  childRequest.setParentOrderItemId(parentOrderItemId);
 737                  currentAddition++;
 738  
 739                  if (childRequest.getQuantity() &gt; 0) {
<abbr title=" 740                      CartOperationRequest childCartOpRequest = new CartOperationRequest(context.getSeedData().getOrder(), childRequest, currentAddition == numAdditionRequests);"> 740                      CartOperationRequest childCartOpRequest = new CartOperationRequest(context.getSeedData().getOrðŸ”µ</abbr>
 741                      Session session = em.unwrap(Session.class);
 742                      FlushMode current = session.getHibernateFlushMode();
 743                      if (!autoFlushAddToCart) {
<abbr title=" 744                          //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 744                          //Performance measure. Hibernate will sometimes perform an autoflush when performing queryðŸ”µ</abbr>
<abbr title=" 745                          //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 745                          //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries ðŸ”µ</abbr>
 746                          //incorrect results because something has not been flushed to the database yet.
 747                          session.setHibernateFlushMode(FlushMode.MANUAL);
 748                      }
 749                      ProcessContext&lt;CartOperationRequest&gt; childContext;
 750                      try {
<abbr title=" 751                          childContext = (ProcessContext&lt;CartOperationRequest&gt;) addItemWorkflow.doActivities(childCartOpRequest);"> 751                          childContext = (ProcessContext&lt;CartOperationRequest&gt;) addItemWorkflow.doActivities(childCaðŸ”µ</abbr>
 752                      } finally {
 753                          if (!autoFlushAddToCart) {
 754                              session.setHibernateFlushMode(current);
 755                          }
 756                      }
 757                      orderMessages.addAll(((ActivityMessages) childContext).getActivityMessages());
 758  
<abbr title=" 759                      addChildItems(childRequest, numAdditionRequests, currentAddition, childContext, orderMessages);"> 759                      addChildItems(childRequest, numAdditionRequests, currentAddition, childContext, orderMessages)ðŸ”µ</abbr>
 760                  }
 761              }
 762          }
 763      }
 764  
 765      @Override
<abbr title=" 766      public void addDependentOrderItem(OrderItemRequestDTO parentOrderItemRequest, OrderItemRequestDTO dependentOrderItem) {"> 766      public void addDependentOrderItem(OrderItemRequestDTO parentOrderItemRequest, OrderItemRequestDTO dependentOrdðŸ”µ</abbr>
 767          parentOrderItemRequest.getChildOrderItems().add(dependentOrderItem);
 768          Collections.sort(parentOrderItemRequest.getChildOrderItems(), new Comparator&lt;OrderItemRequestDTO&gt;() {
 769              @Override
 770              public int compare(OrderItemRequestDTO o1, OrderItemRequestDTO o2) {
 771                  BigDecimal o1DisplayOrder = new BigDecimal(o1.getAdditionalAttributes().get(&quot;addOnDisplayOrder&quot;));
 772                  BigDecimal o2DisplayOrder = new BigDecimal(o2.getAdditionalAttributes().get(&quot;addOnDisplayOrder&quot;));
 773                  return o1DisplayOrder.compareTo(o2DisplayOrder);
 774              }
 775          });
 776      }
 777  
 778      @Override
<abbr title=" 779      @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = {UpdateCartException.class, RemoveFromCartException.class})"> 779      @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = {UpdateCartException.class, RemoveFromCartExceptiðŸ”µ</abbr>
<abbr title=" 780      public Order updateItemQuantity(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throws UpdateCartException, RemoveFromCartException {"> 780      public Order updateItemQuantity(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) thrðŸ”µ</abbr>
 781          Order order = findOrderById(orderId);
 782          preValidateCartOperation(order);
 783          preValidateUpdateQuantityOperation(findOrderById(orderId), orderItemRequestDTO);
 784          if (orderItemRequestDTO.getQuantity() == 0) {
 785              return removeItem(orderId, orderItemRequestDTO.getOrderItemId(), priceOrder);
 786          }
 787  
 788          try {
<abbr title=" 789              CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestDTO, priceOrder);"> 789              CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestðŸ”µ</abbr>
 790              Session session = em.unwrap(Session.class);
 791              FlushMode current = session.getHibernateFlushMode();
 792              if (!autoFlushUpdateCart) {
<abbr title=" 793                  //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 793                  //Performance measure. Hibernate will sometimes perform an autoflush when performing query operatiðŸ”µ</abbr>
<abbr title=" 794                  //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 794                  //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the fðŸ”µ</abbr>
 795                  //incorrect results because something has not been flushed to the database yet.
 796                  session.setHibernateFlushMode(FlushMode.MANUAL);
 797              }
 798              ProcessContext&lt;CartOperationRequest&gt; context;
 799              try {
 800                  context = (ProcessContext&lt;CartOperationRequest&gt;) updateItemWorkflow.doActivities(cartOpRequest);
 801              } finally {
 802                  if (!autoFlushUpdateCart) {
 803                      session.setHibernateFlushMode(current);
 804                  }
 805              }
<abbr title=" 806              context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getActivityMessages());"> 806              context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getActivityMesðŸ”µ</abbr>
 807              return context.getSeedData().getOrder();
 808          } catch (WorkflowException e) {
<abbr title=" 809              throw new UpdateCartException(&quot;Could not update cart quantity&quot;, getCartOperationExceptionRootCause(e));"> 809              throw new UpdateCartException(&quot;Could not update cart quantity&quot;, getCartOperationExceptionRootCause(e))ðŸ”µ</abbr>
 810          }
 811      }
 812  
 813      @Override
 814      @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = {RemoveFromCartException.class})
 815      public Order removeItem(Long orderId, Long orderItemId, boolean priceOrder) throws RemoveFromCartException {
 816          preValidateCartOperation(findOrderById(orderId));
 817          try {
 818              OrderItem oi = orderItemService.readOrderItemById(orderItemId);
 819              if (oi == null) {
 820                  throw new WorkflowException(new ItemNotFoundException());
 821              }
 822              List&lt;Long&gt; childrenToRemove = new ArrayList&lt;Long&gt;();
 823              if (oi instanceof BundleOrderItem) {
 824                  List&lt;DiscreteOrderItem&gt; bundledItems = ((BundleOrderItem) oi).getDiscreteOrderItems();
 825                  for (DiscreteOrderItem doi : bundledItems) {
 826                      findAllChildrenToRemove(childrenToRemove, doi);
 827                  }
 828              } else {
 829                  findAllChildrenToRemove(childrenToRemove, oi);
 830              }
 831              for (Long childToRemove : childrenToRemove) {
 832                  removeItemInternal(orderId, childToRemove, false);
 833              }
 834  
 835              return removeItemInternal(orderId, orderItemId, priceOrder);
 836          } catch (WorkflowException e) {
<abbr title=" 837              throw new RemoveFromCartException(&quot;Could not remove from cart&quot;, getCartOperationExceptionRootCause(e));"> 837              throw new RemoveFromCartException(&quot;Could not remove from cart&quot;, getCartOperationExceptionRootCause(e))ðŸ”µ</abbr>
 838          }
 839      }
 840  
 841      protected void findAllChildrenToRemove(List&lt;Long&gt; childrenToRemove, OrderItem orderItem){
 842          if (CollectionUtils.isNotEmpty(orderItem.getChildOrderItems())) {
 843              for (OrderItem childOrderItem : orderItem.getChildOrderItems()) {
 844                  findAllChildrenToRemove(childrenToRemove, childOrderItem);
 845                  childrenToRemove.add(childOrderItem.getId());
 846              }
 847          }
 848      }
 849  
<abbr title=" 850      protected Order removeItemInternal(Long orderId, Long orderItemId, boolean priceOrder) throws WorkflowException {"> 850      protected Order removeItemInternal(Long orderId, Long orderItemId, boolean priceOrder) throws WorkflowExceptioðŸ”µ</abbr>
 851          OrderItemRequestDTO orderItemRequestDTO = new OrderItemRequestDTO();
 852          orderItemRequestDTO.setOrderItemId(orderItemId);
<abbr title=" 853          CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestDTO, priceOrder);"> 853          CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestDTO,ðŸ”µ</abbr>
 854          Session session = em.unwrap(Session.class);
 855          FlushMode current = session.getHibernateFlushMode();
 856          if (!autoFlushRemoveFromCart) {
<abbr title=" 857              //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations and this can"> 857              //Performance measure. Hibernate will sometimes perform an autoflush when performing query operations ðŸ”µ</abbr>
<abbr title=" 858              //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow returning"> 858              //be expensive. It is possible to avoid the autoflush if there&#x27;s no concern about queries in the flow ðŸ”µ</abbr>
 859              //incorrect results because something has not been flushed to the database yet.
 860              session.setHibernateFlushMode(FlushMode.MANUAL);
 861          }
 862          ProcessContext&lt;CartOperationRequest&gt; context;
 863          try {
 864              context = (ProcessContext&lt;CartOperationRequest&gt;) removeItemWorkflow.doActivities(cartOpRequest);
 865          } finally {
 866              if (!autoFlushRemoveFromCart) {
 867                  session.setHibernateFlushMode(current);
 868              }
 869          }
<abbr title=" 870          context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getActivityMessages());"> 870          context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getActivityMessageðŸ”µ</abbr>
 871          return context.getSeedData().getOrder();
 872      }
 873  
 874      @Override
 875      @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = { RemoveFromCartException.class })
 876      public Order removeInactiveItems(Long orderId, boolean priceOrder) throws RemoveFromCartException {
 877          Order order = findOrderById(orderId);
 878          try {
 879  
 880              for (OrderItem currentItem : new ArrayList&lt;OrderItem&gt;(order.getOrderItems())) {
 881                  if (!currentItem.isSkuActive()) {
 882                      removeItem(orderId, currentItem.getId(), priceOrder);
 883                  }
 884              }
 885  
 886          } catch (Exception e) {
 887              throw new RemoveFromCartException(&quot;Could not remove from cart&quot;, e.getCause());
 888          }
 889          return findOrderById(orderId);
 890      }
 891  
 892      @Override
 893      public boolean getAutomaticallyMergeLikeItems() {
 894  
 895          if (automaticallyMergeLikeItems != null) {
 896              return automaticallyMergeLikeItems;
 897          }
 898  
 899          return BLCSystemProperty.resolveBooleanSystemProperty(&quot;automatically.merge.like.items&quot;, true);
 900      }
 901  
 902      @Override
 903      public void setAutomaticallyMergeLikeItems(boolean automaticallyMergeLikeItems) {
 904          this.automaticallyMergeLikeItems = automaticallyMergeLikeItems;
 905      }
 906  
 907      @Override
<abbr title=" 908      @ManagedAttribute(description=&quot;The move item from named order when adding to the cart attribute&quot;, currencyTimeLimit=15)"> 908      @ManagedAttribute(description=&quot;The move item from named order when adding to the cart attribute&quot;, currencyTimeðŸ”µ</abbr>
 909      public boolean isMoveNamedOrderItems() {
 910          return moveNamedOrderItems;
 911      }
 912  
 913      @Override
<abbr title=" 914      @ManagedAttribute(description=&quot;The move item from named order when adding to the cart attribute&quot;, currencyTimeLimit=15)"> 914      @ManagedAttribute(description=&quot;The move item from named order when adding to the cart attribute&quot;, currencyTimeðŸ”µ</abbr>
 915      public void setMoveNamedOrderItems(boolean moveNamedOrderItems) {
 916          this.moveNamedOrderItems = moveNamedOrderItems;
 917      }
 918  
 919      @Override
<abbr title=" 920      @ManagedAttribute(description=&quot;The delete empty named order after adding items to cart attribute&quot;, currencyTimeLimit=15)"> 920      @ManagedAttribute(description=&quot;The delete empty named order after adding items to cart attribute&quot;, currencyTimðŸ”µ</abbr>
 921      public boolean isDeleteEmptyNamedOrders() {
 922          return deleteEmptyNamedOrders;
 923      }
 924  
 925      @Override
 926      @Transactional(&quot;blTransactionManager&quot;)
 927      public void removeAllPaymentsFromOrder(Order order) {
 928          removePaymentsFromOrder(order, null);
 929      }
 930  
 931      @Override
 932      @Transactional(&quot;blTransactionManager&quot;)
 933      public void removePaymentsFromOrder(Order order, PaymentType paymentInfoType) {
 934          List&lt;OrderPayment&gt; infos = new ArrayList&lt;OrderPayment&gt;();
 935          for (OrderPayment paymentInfo : order.getPayments()) {
 936              if (paymentInfoType == null || paymentInfoType.equals(paymentInfo.getType())) {
 937                  infos.add(paymentInfo);
 938              }
 939          }
 940          order.getPayments().removeAll(infos);
 941          for (OrderPayment paymentInfo : infos) {
 942              try {
<abbr title=" 943                  securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentInfo.getReferenceNumber(), paymentInfo.getType());"> 943                  securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentInfo.getReferenceNumber(), paymentIðŸ”µ</abbr>
 944              } catch (WorkflowException e) {
 945                  // do nothing--this is an acceptable condition
 946                  LOG.debug(&quot;No secure payment is associated with the OrderPayment&quot;, e);
 947              }
 948              order.getPayments().remove(paymentInfo);
 949              paymentInfo = paymentDao.readPaymentById(paymentInfo.getId());
 950              paymentDao.delete(paymentInfo);
 951          }
 952      }
 953  
 954      @Override
 955      @Transactional(&quot;blTransactionManager&quot;)
 956      public void removeCreditCardPaymentsFromOrder(Order order) {
 957          List&lt;OrderPayment&gt; infos = new ArrayList&lt;OrderPayment&gt;();
 958          for (OrderPayment paymentInfo : order.getPayments()) {
 959              if (paymentInfo.getType().isCreditCardType()) {
 960                  infos.add(paymentInfo);
 961              }
 962          }
 963          order.getPayments().removeAll(infos);
 964          for (OrderPayment paymentInfo : infos) {
 965              try {
<abbr title=" 966                  securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentInfo.getReferenceNumber(), paymentInfo.getType());"> 966                  securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentInfo.getReferenceNumber(), paymentIðŸ”µ</abbr>
 967              } catch (WorkflowException e) {
 968                  // do nothing--this is an acceptable condition
 969                  LOG.debug(&quot;No secure payment is associated with the OrderPayment&quot;, e);
 970              }
 971              order.getPayments().remove(paymentInfo);
 972              paymentInfo = paymentDao.readPaymentById(paymentInfo.getId());
 973              paymentDao.delete(paymentInfo);
 974          }
 975      }
 976  
 977      @Override
 978      @Transactional(&quot;blTransactionManager&quot;)
 979      public void removePaymentFromOrder(Order order, OrderPayment payment){
 980          OrderPayment paymentToRemove = null;
 981          for (OrderPayment info : order.getPayments()){
 982              if (info.equals(payment)){
 983                  paymentToRemove = info;
 984              }
 985          }
 986          if (paymentToRemove != null){
 987              try {
<abbr title=" 988                  securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentToRemove.getReferenceNumber(), payment.getType());"> 988                  securePaymentInfoService.findAndRemoveSecurePaymentInfo(paymentToRemove.getReferenceNumber(), paymðŸ”µ</abbr>
 989              } catch (WorkflowException e) {
 990                  // do nothing--this is an acceptable condition
 991                  LOG.debug(&quot;No secure payment is associated with the OrderPayment&quot;, e);
 992              }
 993              order.getPayments().remove(paymentToRemove);
 994              payment = paymentDao.readPaymentById(paymentToRemove.getId());
 995              paymentDao.delete(payment);
 996          }
 997      }
 998  
 999      /**
1000       * This method will return the exception that is immediately below the deepest
1001       * WorkflowException in the current stack trace.
1002       *
1003       * @param e the workflow exception that contains the requested root cause
1004       * @return the root cause of the workflow exception
1005       */
1006      protected Throwable getCartOperationExceptionRootCause(WorkflowException e) {
1007          Throwable cause = e.getCause();
1008          if (cause == null) {
1009              return e;
1010          }
1011  
1012          Throwable currentCause = cause;
1013          while (currentCause.getCause() != null) {
1014              currentCause = currentCause.getCause();
1015              if (currentCause instanceof WorkflowException) {
1016                  cause = currentCause.getCause();
1017              }
1018          }
1019  
1020          return cause;
1021      }
1022  
1023      /**
1024       * Returns true if the two items attributes exactly match.
1025       * @param item1Attributes
1026       * @param item2
1027       * @return
1028       */
<abbr title="1029      protected boolean compareAttributes(Map&lt;String, OrderItemAttribute&gt; item1Attributes, OrderItemRequestDTO item2) {">1029      protected boolean compareAttributes(Map&lt;String, OrderItemAttribute&gt; item1Attributes, OrderItemRequestDTO item2ðŸ”µ</abbr>
1030          int item1AttributeSize = item1Attributes == null ? 0 : item1Attributes.size();
1031          int item2AttributeSize = item2.getItemAttributes() == null ? 0 : item2.getItemAttributes().size();
1032  
1033          if (item1AttributeSize != item2AttributeSize) {
1034              return false;
1035          }
1036  
1037          for (String key : item2.getItemAttributes().keySet()) {
1038              String itemOneValue = (item1Attributes.get(key) == null) ? null : item1Attributes.get(key).getValue();
1039              String itemTwoValue = item2.getItemAttributes().get(key);
1040              if (!itemTwoValue.equals(itemOneValue)) {
1041                  return false;
1042              }
1043          }
1044          return true;
1045      }
1046  
<abbr title="1047      protected boolean itemMatches(Sku item1Sku, Product item1Product, Map&lt;String, OrderItemAttribute&gt; item1Attributes,">1047      protected boolean itemMatches(Sku item1Sku, Product item1Product, Map&lt;String, OrderItemAttribute&gt; item1AttribuðŸ”µ</abbr>
1048              OrderItemRequestDTO item2) {
1049          // Must match on SKU and options
1050          if (item1Sku != null &amp;&amp; item2.getSkuId() != null) {
1051              if (item1Sku.getId().equals(item2.getSkuId())) {
1052                  return true;
1053              }
1054          } else {
1055              if (item1Product != null &amp;&amp; item2.getProductId() != null) {
1056                  if (item1Product.getId().equals(item2.getProductId())) {
1057                      return compareAttributes(item1Attributes, item2);
1058                  }
1059              }
1060          }
1061          return false;
1062      }
1063  
1064      protected OrderItem findMatchingItem(Order order, OrderItemRequestDTO itemToFind) {
1065          if (order == null) {
1066              return null;
1067          }
1068          for (OrderItem currentItem : order.getOrderItems()) {
1069              if (currentItem instanceof DiscreteOrderItem) {
1070                  DiscreteOrderItem discreteItem = (DiscreteOrderItem) currentItem;
<abbr title="1071                  if (itemMatches(discreteItem.getSku(), discreteItem.getProduct(), discreteItem.getOrderItemAttributes(),">1071                  if (itemMatches(discreteItem.getSku(), discreteItem.getProduct(), discreteItem.getOrderItemAttribuðŸ”µ</abbr>
1072                          itemToFind)) {
1073                      return discreteItem;
1074                  }
1075              } else if (currentItem instanceof BundleOrderItem) {
1076                  BundleOrderItem bundleItem = (BundleOrderItem) currentItem;
1077                  if (itemMatches(bundleItem.getSku(), bundleItem.getProduct(), null, itemToFind)) {
1078                      return bundleItem;
1079                  }
1080              }
1081          }
1082          return null;
1083      }
1084  
1085      @Override
1086      @Transactional(value = &quot;blTransactionManager&quot;, rollbackFor = { UpdateCartException.class })
<abbr title="1087      public Order updateProductOptionsForItem(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOrder) throws UpdateCartException {">1087      public Order updateProductOptionsForItem(Long orderId, OrderItemRequestDTO orderItemRequestDTO, boolean priceOðŸ”µ</abbr>
1088          try {
<abbr title="1089              CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestDTO, priceOrder);">1089              CartOperationRequest cartOpRequest = new CartOperationRequest(findOrderById(orderId), orderItemRequestðŸ”µ</abbr>
<abbr title="1090              ProcessContext&lt;CartOperationRequest&gt; context = (ProcessContext&lt;CartOperationRequest&gt;) updateProductOptionsForItemWorkflow.doActivities(cartOpRequest);">1090              ProcessContext&lt;CartOperationRequest&gt; context = (ProcessContext&lt;CartOperationRequest&gt;) updateProductOptðŸ”µ</abbr>
<abbr title="1091              context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getActivityMessages());">1091              context.getSeedData().getOrder().getOrderMessages().addAll(((ActivityMessages) context).getActivityMesðŸ”µ</abbr>
1092              return context.getSeedData().getOrder();
1093          } catch (WorkflowException e) {
1094              throw new UpdateCartException(&quot;Could not product options&quot;, getCartOperationExceptionRootCause(e));
1095          }
1096      }
1097  
1098      @Override
1099      public Order reloadOrder(Order order) {
1100          if (order == null || order instanceof NullOrderImpl || order.getId() == null) {
1101              return order;
1102          }
1103  
1104          return orderDao.readOrderById(order.getId(), true);
1105      }
1106  
1107      @Override
1108      @Transactional(&quot;blTransactionManager&quot;)
1109      public boolean acquireLock(Order order) {
1110          return orderDao.acquireLock(order);
1111      }
1112  
1113      @Override
1114      public boolean releaseLock(Order order) {
1115          return orderDao.releaseLock(order);
1116      }
1117  
1118      @Override
1119      public void printOrder(Order order, Log log) {
1120          if (!log.isDebugEnabled()) {
1121              return;
1122          }
1123  
1124          TableCreator tc = new TableCreator(new TableCreator.Col[] {
1125              new TableCreator.Col(&quot;Order Item&quot;, 30),
1126              new TableCreator.Col(&quot;Qty&quot;),
1127              new TableCreator.Col(&quot;Unit Price&quot;),
1128              new TableCreator.Col(&quot;Avg Adj&quot;),
1129              new TableCreator.Col(&quot;Total Adj&quot;),
1130              new TableCreator.Col(&quot;Total Price&quot;)
1131          });
1132  
1133          for (OrderItem oi : order.getOrderItems()) {
1134              tc.addRow(new String[] {
1135                  oi.getName(),
1136                  String.valueOf(oi.getQuantity()),
1137                  String.valueOf(oi.getPriceBeforeAdjustments(true)),
1138                  String.valueOf(oi.getAverageAdjustmentValue()),
1139                  String.valueOf(oi.getTotalAdjustmentValue()),
1140                  String.valueOf(oi.getTotalPrice())
1141              });
1142          }
1143  
1144          tc.addSeparator()
1145              .withGlobalRowHeaderWidth(15)
1146              .addRow(&quot;Subtotal&quot;, order.getSubTotal())
1147              .addRow(&quot;Order Adj.&quot;, order.getOrderAdjustmentsValue())
1148              .addRow(&quot;Tax&quot;, order.getTotalTax())
1149              .addRow(&quot;Shipping&quot;, order.getTotalShipping())
1150              .addRow(&quot;Total&quot;, order.getTotal())
1151              .addSeparator();
1152  
1153          log.debug(tc.toString());
1154      }
1155  
1156      @Override
1157      public void preValidateCartOperation(Order cart) {
1158          ExtensionResultHolder erh = new ExtensionResultHolder();
1159          extensionManager.getProxy().preValidateCartOperation(cart, erh);
1160          if (erh.getThrowable() instanceof IllegalCartOperationException) {
1161              throw ((IllegalCartOperationException) erh.getThrowable());
1162          } else if (erh.getThrowable() != null) {
1163              throw new RuntimeException(erh.getThrowable());
1164          }
1165      }
1166  
1167      @Override
1168      public void preValidateUpdateQuantityOperation(Order cart, OrderItemRequestDTO dto) {
1169          ExtensionResultHolder erh = new ExtensionResultHolder();
1170          extensionManager.getProxy().preValidateUpdateQuantityOperation(cart, dto, erh);
1171          if (erh.getThrowable() instanceof IllegalCartOperationException) {
1172              throw ((IllegalCartOperationException) erh.getThrowable());
1173          } else if (erh.getThrowable() != null) {
1174              throw new RuntimeException(erh.getThrowable());
1175          }
1176      }
1177  
1178      @Override
1179      public void refresh(Order order) {
1180          orderDao.refresh(order);
1181      }
1182  
1183      @Override
1184      public Order findCartForCustomerWithEnhancements(Customer customer) {
1185          ExtensionResultHolder&lt;Order&gt; erh = new ExtensionResultHolder&lt;Order&gt;();
<abbr title="1186          ExtensionResultStatusType resultStatusType = extensionManager.findCartForCustomerWithEnhancements(customer, erh);">1186          ExtensionResultStatusType resultStatusType = extensionManager.findCartForCustomerWithEnhancements(customerðŸ”µ</abbr>
1187          if (ExtensionResultStatusType.NOT_HANDLED != resultStatusType) {
1188              return erh.getResult();
1189          }
1190          return findCartForCustomer(customer);
1191      }
1192  
1193      @Override
1194      public Order findCartForCustomerWithEnhancements(Customer customer, Order candidateOrder) {
1195          ExtensionResultHolder&lt;Order&gt; erh = new ExtensionResultHolder&lt;Order&gt;();
<abbr title="1196          ExtensionResultStatusType resultStatusType = extensionManager.findCartForCustomerWithEnhancements(customer, candidateOrder, erh);">1196          ExtensionResultStatusType resultStatusType = extensionManager.findCartForCustomerWithEnhancements(customerðŸ”µ</abbr>
1197          if (ExtensionResultStatusType.NOT_HANDLED != resultStatusType) {
1198              return erh.getResult();
1199          }
1200          return candidateOrder;
1201      }
1202  
1203      @Override
1204      public List&lt;Order&gt; findOrdersByEmail(String email) {
1205          return orderDao.readOrdersByEmail(email);
1206      }
1207  
1208      @Override
1209      public List&lt;Order&gt; readBatchOrders(int start, int pageSize, List&lt;OrderStatus&gt; orderStatusList) {
1210          return orderDao.readBatchOrders(start, pageSize, orderStatusList);
1211      }
1212  
1213      @Override
1214  	public Long readNumberOfOrders() {
1215      		return orderDao.readNumberOfOrders();
1216      }
1217  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            