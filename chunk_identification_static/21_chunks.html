<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>21 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;import com.arialyy.aria.core.download.DTaskWrapper;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.arialyy.aria.core.download.DownloadEntity;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.arialyy.aria.core.download.m3u8.M3U8FileLoader;\n&#x27;
                         &#x27;import com.arialyy.aria.core.inf.AbsNormalEntity;\n&#x27;
                         &#x27;import com.arialyy.aria.core.inf.AbsTaskWrapper;\n&#x27;
                         &#x27;import com.arialyy.aria.core.inf.ITaskWrapper;\n&#x27;
                         &#x27;import com.arialyy.aria.core.upload.UploadEntity;\n&#x27;
                         &#x27;import com.arialyy.aria.orm.DbEntity;\n&#x27;
                         &#x27;import com.arialyy.aria.util.ALog;\n&#x27;
                         &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                         &#x27;import com.arialyy.aria.util.DbDataHelper;\n&#x27;
                         &#x27;import java.io.File;\n&#x27;
                         &#x27;import java.util.ArrayList;\n&#x27;
                         &#x27;import java.util.HashSet;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Properties;\n&#x27;
                         &#x27;import java.util.Set;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * 处理任务记录，分配线程区间\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public class RecordHandler {\n&#x27;
                         &#x27;  private final String TAG = &quot;RecordHandler&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  public static final int TYPE_DOWNLOAD = 1;\n&#x27;
                         &#x27;  public static final int TYPE_UPLOAD = 2;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private static final String STATE = &quot;_state_&quot;;\n&#x27;
                         &#x27;  private static final String RECORD = &quot;_record_&quot;;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 小于1m的文件不启用多线程\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private static final long SUB_LEN = 1024 * 1024;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 分块文件路径\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public static final String SUB_PATH = &#x27;
                         &#x27;&quot;%s.%s.part&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Deprecated private File mConfigFile;\n&#x27;
                         &#x27;  private TaskRecord mRecord;\n&#x27;
                         &#x27;  private AbsTaskWrapper mTaskWrapper;\n&#x27;
                         &#x27;  private AbsNormalEntity mEntity;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  RecordHandler(AbsTaskWrapper wrapper) {\n&#x27;
                         &#x27;    mTaskWrapper = wrapper;\n&#x27;
                         &#x27;    mEntity = (AbsNormalEntity) &#x27;
                         &#x27;mTaskWrapper.getEntity();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取任务记录，如果任务记录存在，检查任务记录\n&#x27;
                         &#x27;   * 检查记录 对于分块任务： 子分块不存在或被删除，子线程将重新下载\n&#x27;
                         &#x27;   * 对于普通任务： 预下载文件不存在，则任务任务呗删除\n&#x27;
                         &#x27;   * 如果任务记录不存在或线程记录不存在，初始化记录\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @return 任务记录\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  TaskRecord getRecord() {\n&#x27;
                         &#x27;    mConfigFile = new &#x27;
                         &#x27;File(CommonUtil.getFileConfigPath(false, &#x27;
                         &#x27;mEntity.getFileName()));\n&#x27;
                         &#x27;    if (mConfigFile.exists()) {\n&#x27;
                         &#x27;      convertDb();\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      mRecord = &#x27;
                         &#x27;DbDataHelper.getTaskRecord(getFilePath());\n&#x27;
                         &#x27;      if (mRecord == null) {\n&#x27;
                         &#x27;        initRecord(true);\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        if (mRecord.threadRecords == null || &#x27;
                         &#x27;mRecord.threadRecords.isEmpty()) {\n&#x27;
                         &#x27;          initRecord(false);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if (mTaskWrapper.getRequestType() == &#x27;
                         &#x27;ITaskWrapper.M3U8_FILE) {\n&#x27;
                         &#x27;          handleM3U8Record();\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          if (mRecord.isBlock) {\n&#x27;
                         &#x27;            handleBlockRecord();\n&#x27;
                         &#x27;          } else if (!mTaskWrapper.isSupportBP()) {\n&#x27;
                         &#x27;            handleNoSupportBPRecord();\n&#x27;
                         &#x27;          } else {\n&#x27;
                         &#x27;            handleSingleThreadRecord();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    saveRecord();\n&#x27;
                         &#x27;    return mRecord;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理m3u8记录，\n&#x27;
                         &#x27;   * 1、如果分片文件存在，并且分片文件的记录没有完成，则需要删除该分片文件\n&#x27;
                         &#x27;   * 2、如果记录显示已完成，但是分片文件不存在，则重新开始该分片\n&#x27;
                         &#x27;   * 3、如果记录显示已完成，并且文件存在，记录当前任务进度\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleM3U8Record() {\n&#x27;
                         &#x27;    DTaskWrapper wrapper = (DTaskWrapper) &#x27;
                         &#x27;mTaskWrapper;\n&#x27;
                         &#x27;    String cacheDir = &#x27;
                         &#x27;wrapper.asM3U8().getCacheDir();\n&#x27;
                         &#x27;    long currentProgress = 0;\n&#x27;
                         &#x27;    for (ThreadRecord record : &#x27;
                         &#x27;mRecord.threadRecords) {\n&#x27;
                         &#x27;      File temp = new &#x27;
                         &#x27;File(M3U8FileLoader.getTsFilePath(cacheDir, &#x27;
                         &#x27;record.threadId));\n&#x27;
                         &#x27;      if (!record.isComplete) {\n&#x27;
                         &#x27;        if (temp.exists()) {\n&#x27;
                         &#x27;          temp.delete();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        record.startLocation = 0;\n&#x27;
                         &#x27;        ALog.d(TAG, &#x27;
                         &#x27;String.format(&quot;分片【%s】未完成，将重新下载该分片&quot;, &#x27;
                         &#x27;record.threadId));\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        if (!temp.exists()) {\n&#x27;
                         &#x27;          record.startLocation = 0;\n&#x27;
                         &#x27;          record.isComplete = false;\n&#x27;
                         &#x27;          ALog.w(TAG, &#x27;
                         &#x27;String.format(&quot;分片【%s】不存在，将重新下载该分片&quot;, &#x27;
                         &#x27;record.threadId));\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          currentProgress += temp.length();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    &#x27;
                         &#x27;wrapper.getEntity().setCurrentProgress(currentProgress);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理不支持断点的记录\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleNoSupportBPRecord() {\n&#x27;
                         &#x27;    ThreadRecord tr = mRecord.threadRecords.get(0);\n&#x27;
                         &#x27;    tr.startLocation = 0;\n&#x27;
                         &#x27;    tr.endLocation = mEntity.getFileSize();\n&#x27;
                         &#x27;    tr.key = mRecord.filePath;\n&#x27;
                         &#x27;    tr.blockLen = tr.endLocation;\n&#x27;
                         &#x27;    tr.isComplete = false;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理单线程的任务的记录\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleSingleThreadRecord() {\n&#x27;
                         &#x27;    File file = new File(mRecord.filePath);\n&#x27;
                         &#x27;    ThreadRecord tr = mRecord.threadRecords.get(0);\n&#x27;
                         &#x27;    if (!file.exists()) {\n&#x27;
                         &#x27;      ALog.w(TAG, String.format(&quot;文件【%s】不存在，任务将重新开始&quot;, &#x27;
                         &#x27;file.getPath()));\n&#x27;
                         &#x27;      tr.startLocation = 0;\n&#x27;
                         &#x27;      tr.isComplete = false;\n&#x27;
                         &#x27;      tr.endLocation = mEntity.getFileSize();\n&#x27;
                         &#x27;    } else if (mRecord.isOpenDynamicFile) {\n&#x27;
                         &#x27;      if (file.length() &gt; mEntity.getFileSize()) {\n&#x27;
                         &#x27;        ALog.i(TAG, String.format(&quot;文件【%s】错误，任务重新开始&quot;, &#x27;
                         &#x27;file.getPath()));\n&#x27;
                         &#x27;        file.delete();\n&#x27;
                         &#x27;        tr.startLocation = 0;\n&#x27;
                         &#x27;        tr.isComplete = false;\n&#x27;
                         &#x27;        tr.endLocation = mEntity.getFileSize();\n&#x27;
                         &#x27;      } else if (file.length() == &#x27;
                         &#x27;mEntity.getFileSize()) {\n&#x27;
                         &#x27;        tr.isComplete = true;\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        if (file.length() != tr.startLocation) {\n&#x27;
                         &#x27;          ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;修正【%s】的进度记录为：%s&quot;, file.getPath(), &#x27;
                         &#x27;file.length()));\n&#x27;
                         &#x27;          tr.startLocation = file.length();\n&#x27;
                         &#x27;          tr.isComplete = false;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    mTaskWrapper.setNewTask(false);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * &#x27;
                         &#x27;处理分块任务的记录，分块文件（blockFileLen）长度必须需要小于等于线程区间（threadRectLen）的长度\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleBlockRecord() {\n&#x27;
                         &#x27;    // 默认线程分块长度\n&#x27;
                         &#x27;    long normalRectLen = mEntity.getFileSize() / &#x27;
                         &#x27;mRecord.threadRecords.size();\n&#x27;
                         &#x27;    for (ThreadRecord tr : mRecord.threadRecords) {\n&#x27;
                         &#x27;      long threadRect = tr.blockLen;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;      File temp = new File(String.format(SUB_PATH, &#x27;
                         &#x27;mRecord.filePath, tr.threadId));\n&#x27;
                         &#x27;      if (!temp.exists()) {\n&#x27;
                         &#x27;        ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;分块文件【%s】不存在，该分块将重新开始&quot;, &#x27;
                         &#x27;temp.getPath()));\n&#x27;
                         &#x27;        tr.isComplete = false;\n&#x27;
                         &#x27;        tr.startLocation = tr.threadId * &#x27;
                         &#x27;normalRectLen;\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        if (!tr.isComplete) {\n&#x27;
                         &#x27;          ALog.i(TAG, String.format(\n&#x27;
                         &#x27;              &quot;startLocation = %s; endLocation = %s; &#x27;
                         &#x27;block = %s; tempLen = %s; threadId = %s&quot;,\n&#x27;
                         &#x27;              tr.startLocation, tr.endLocation, &#x27;
                         &#x27;threadRect, temp.length(), tr.threadId));\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;          long blockFileLen = temp.length(); // &#x27;
                         &#x27;磁盘中的分块文件长度\n&#x27;
                         &#x27;          /*\n&#x27;
                         &#x27;           * 检查磁盘中的分块文件\n&#x27;
                         &#x27;           */\n&#x27;
                         &#x27;          if (blockFileLen &gt; threadRect) {\n&#x27;
                         &#x27;            ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;分块【%s】错误，分块长度【%s】 &gt; &#x27;
                         &#x27;线程区间长度【%s】，将重新开始该分块&quot;,\n&#x27;
                         &#x27;                tr.threadId, blockFileLen, &#x27;
                         &#x27;threadRect));\n&#x27;
                         &#x27;            temp.delete();\n&#x27;
                         &#x27;            tr.startLocation = tr.threadId * &#x27;
                         &#x27;threadRect;\n&#x27;
                         &#x27;            continue;\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;          long realLocation =\n&#x27;
                         &#x27;              tr.threadId * normalRectLen + &#x27;
                         &#x27;blockFileLen; //正常情况下，该线程的startLocation的位置\n&#x27;
                         &#x27;          /*\n&#x27;
                         &#x27;           * 检查记录文件\n&#x27;
                         &#x27;           */\n&#x27;
                         &#x27;          if (blockFileLen == threadRect) {\n&#x27;
                         &#x27;            ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;分块【%s】已完成，更新记录&quot;, temp.getPath()));\n&#x27;
                         &#x27;            tr.startLocation = blockFileLen;\n&#x27;
                         &#x27;            tr.isComplete = true;\n&#x27;
                         &#x27;          } else if (tr.startLocation != &#x27;
                         &#x27;realLocation) { // 处理记录小于分块文件长度的情况\n&#x27;
                         &#x27;            ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;修正分块【%s】的进度记录为：%s&quot;, temp.getPath(), &#x27;
                         &#x27;realLocation));\n&#x27;
                         &#x27;            tr.startLocation = realLocation;\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          ALog.i(TAG, String.format(&quot;分块【%s】已完成&quot;, &#x27;
                         &#x27;temp.getPath()));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    mTaskWrapper.setNewTask(false);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * convertDb 是兼容性代码 从3.4.1开始，线程配置信息将存储在数据库中。 &#x27;
                         &#x27;将配置文件的内容复制到数据库中，并将配置文件删除\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void convertDb() {\n&#x27;
                         &#x27;    List&lt;RecordWrapper&gt; records =\n&#x27;
                         &#x27;        &#x27;
                         &#x27;DbEntity.findRelationData(RecordWrapper.class, &#x27;
                         &#x27;&quot;TaskRecord.filePath=?&quot;,\n&#x27;
                         &#x27;            getFilePath());\n&#x27;
                         &#x27;    if (records == null || records.size() == 0) {\n&#x27;
                         &#x27;      Properties pro = &#x27;
                         &#x27;CommonUtil.loadConfig(mConfigFile);\n&#x27;
                         &#x27;      if (pro.isEmpty()) {\n&#x27;
                         &#x27;        ALog.d(TAG, &quot;老版本的线程记录为空，任务为新任务&quot;);\n&#x27;
                         &#x27;        initRecord(true);\n&#x27;
                         &#x27;        return;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;      Set&lt;Object&gt; keys = pro.keySet();\n&#x27;
                         &#x27;      // &#x27;
                         &#x27;老版本记录是5s存一次，但是5s中内，如果线程执行完成，record记录是没有的，只有state记录...\n&#x27;
                         &#x27;      // 第一步应该是record 和 state去重取正确的线程数\n&#x27;
                         &#x27;      Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\n&#x27;
                         &#x27;      for (Object key : keys) {\n&#x27;
                         &#x27;        String str = String.valueOf(key);\n&#x27;
                         &#x27;        int i = &#x27;
                         &#x27;Integer.parseInt(str.substring(str.length() - 1));\n&#x27;
                         &#x27;        set.add(i);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      int threadNum = set.size();\n&#x27;
                         &#x27;      if (threadNum == 0) {\n&#x27;
                         &#x27;        ALog.d(TAG, &quot;线程数为空，任务为新任务&quot;);\n&#x27;
                         &#x27;        initRecord(true);\n&#x27;
                         &#x27;        return;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      mTaskWrapper.setNewTask(false);\n&#x27;
                         &#x27;      mRecord = createTaskRecord(threadNum);\n&#x27;
                         &#x27;      mRecord.isOpenDynamicFile = false;\n&#x27;
                         &#x27;      mRecord.isBlock = false;\n&#x27;
                         &#x27;      File tempFile = new File(getFilePath());\n&#x27;
                         &#x27;      for (int i = 0; i &lt; threadNum; i++) {\n&#x27;
                         &#x27;        ThreadRecord tRecord = new ThreadRecord();\n&#x27;
                         &#x27;        tRecord.key = mRecord.filePath;\n&#x27;
                         &#x27;        Object state = &#x27;
                         &#x27;pro.getProperty(tempFile.getName() + STATE + i);\n&#x27;
                         &#x27;        Object record = &#x27;
                         &#x27;pro.getProperty(tempFile.getName() + RECORD + i);\n&#x27;
                         &#x27;        if (state != null &amp;&amp; &#x27;
                         &#x27;Integer.parseInt(String.valueOf(state)) == 1) {\n&#x27;
                         &#x27;          tRecord.isComplete = true;\n&#x27;
                         &#x27;          continue;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (record != null) {\n&#x27;
                         &#x27;          long temp = &#x27;
                         &#x27;Long.parseLong(String.valueOf(record));\n&#x27;
                         &#x27;          tRecord.startLocation = temp &gt; 0 ? temp : &#x27;
                         &#x27;0;\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          tRecord.startLocation = 0;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        mRecord.threadRecords.add(tRecord);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      mConfigFile.delete();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 初始化任务记录，分配线程区间\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @param newRecord {@code true} 需要创建新{@link &#x27;
                         &#x27;TaskRecord}\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void initRecord(boolean newRecord) {\n&#x27;
                         &#x27;    if (newRecord) {\n&#x27;
                         &#x27;      mRecord = &#x27;
                         &#x27;createTaskRecord(getNewTaskThreadNum());\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    mTaskWrapper.setNewTask(true);\n&#x27;
                         &#x27;    // 处理线程区间记录\n&#x27;
                         &#x27;    int requestType = &#x27;
                         &#x27;mTaskWrapper.getRequestType();\n&#x27;
                         &#x27;    long blockSize = mEntity.getFileSize() / &#x27;
                         &#x27;mRecord.threadNum;\n&#x27;
                         &#x27;    for (int i = 0; i &lt; mRecord.threadNum; i++) {\n&#x27;
                         &#x27;      long startL = i * blockSize, endL = (i + 1) * &#x27;
                         &#x27;blockSize;\n&#x27;
                         &#x27;      ThreadRecord tr;\n&#x27;
                         &#x27;      tr = new ThreadRecord();\n&#x27;
                         &#x27;      tr.key = mRecord.filePath;\n&#x27;
                         &#x27;      tr.threadId = i;\n&#x27;
                         &#x27;      tr.startLocation = startL;\n&#x27;
                         &#x27;      tr.isComplete = false;\n&#x27;
                         &#x27;      if (requestType == ITaskWrapper.M3U8_FILE) {\n&#x27;
                         &#x27;        tr.startLocation = 0;\n&#x27;
                         &#x27;        tr.threadType = TaskRecord.TYPE_M3U8;\n&#x27;
                         &#x27;        tr.m3u8url = ((DTaskWrapper) &#x27;
                         &#x27;mTaskWrapper).asM3U8().getUrls().get(i);\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        tr.threadType = TaskRecord.TYPE_HTTP_FTP;\n&#x27;
                         &#x27;        //最后一个线程的结束位置即为文件的总长度\n&#x27;
                         &#x27;        if (i == (mRecord.threadNum - 1)) {\n&#x27;
                         &#x27;          endL = mEntity.getFileSize();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        tr.endLocation = endL;\n&#x27;
                         &#x27;        tr.blockLen = &#x27;
                         &#x27;CommonUtil.getBlockLen(mEntity.getFileSize(), i, &#x27;
                         &#x27;mRecord.threadNum);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      mRecord.threadRecords.add(tr);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 创建任务记录\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @param threadNum 线程总数\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private TaskRecord createTaskRecord(int threadNum) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;    TaskRecord record = new TaskRecord();\n&#x27;
                         &#x27;    record.fileName = mEntity.getFileName();\n&#x27;
                         &#x27;    record.filePath = getFilePath();\n&#x27;
                         &#x27;    record.threadRecords = new ArrayList&lt;&gt;();\n&#x27;
                         &#x27;    record.threadNum = threadNum;\n&#x27;
                         &#x27;    // 处理分块和动态文件参数\n&#x27;
                         &#x27;    if (getRecordType() == TYPE_DOWNLOAD) {\n&#x27;
                         &#x27;      record.isBlock = threadNum &gt; 1 &amp;&amp; &#x27;
                         &#x27;Configuration.getInstance().downloadCfg.isUseBlock();\n&#x27;
                         &#x27;      // 线程数为1，或者使用了分块，则认为是使用动态长度文件\n&#x27;
                         &#x27;      record.isOpenDynamicFile = threadNum == 1 || &#x27;
                         &#x27;record.isBlock;\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      record.isBlock = false;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    if (mTaskWrapper.getRequestType() == &#x27;
                         &#x27;ITaskWrapper.M3U8_FILE) {\n&#x27;
                         &#x27;      record.taskType = TaskRecord.TYPE_M3U8;\n&#x27;
                         &#x27;      record.isOpenDynamicFile = true;\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      record.taskType = TaskRecord.TYPE_HTTP_FTP;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    record.isGroupRecord = mEntity.isGroupChild();\n&#x27;
                         &#x27;    if (record.isGroupRecord) {\n&#x27;
                         &#x27;      if (mEntity instanceof DownloadEntity) {\n&#x27;
                         &#x27;        record.dGroupHash = ((DownloadEntity) &#x27;
                         &#x27;mEntity).getGroupHash();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    return record;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 保存任务记录\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void saveRecord() {\n&#x27;
                         &#x27;    mRecord.threadNum = &#x27;
                         &#x27;mRecord.threadRecords.size();\n&#x27;
                         &#x27;    mRecord.save();\n&#x27;
                         &#x27;    DbEntity.saveAll(mRecord.threadRecords);\n&#x27;
                         &#x27;    ALog.d(TAG, String.format(&quot;保存记录，线程记录数：%s&quot;, &#x27;
                         &#x27;mRecord.threadRecords.size()));\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取记录类型\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @return {@link #TYPE_DOWNLOAD}、{@link &#x27;
                         &#x27;#TYPE_UPLOAD}\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private int getRecordType() {\n&#x27;
                         &#x27;    if (mEntity instanceof DownloadEntity) {\n&#x27;
                         &#x27;      return TYPE_DOWNLOAD;\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      return TYPE_UPLOAD;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取任务路径\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @return 任务文件路径\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private String getFilePath() {\n&#x27;
                         &#x27;    if (mEntity instanceof DownloadEntity) {\n&#x27;
                         &#x27;      return ((DownloadEntity) &#x27;
                         &#x27;mTaskWrapper.getEntity()).getFilePath();\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      return ((UploadEntity) &#x27;
                         &#x27;mTaskWrapper.getEntity()).getFilePath();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 小于1m的文件或是任务组的子任务、线程数强制为1\n&#x27;
                         &#x27;   * 不支持断点或chunked模式的线程数都为，线程数强制为1\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private int getNewTaskThreadNum() {\n&#x27;
                         &#x27;    if (getRecordType() == TYPE_DOWNLOAD) {\n&#x27;
                         &#x27;      if (mTaskWrapper.getRequestType() == &#x27;
                         &#x27;ITaskWrapper.M3U8_FILE) {\n&#x27;
                         &#x27;        return ((DTaskWrapper) &#x27;
                         &#x27;mTaskWrapper).asM3U8().getUrls().size();\n&#x27;
                         &#x27;      }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.DownloadEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.core.inf.AbsNormalEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.core.inf.AbsTaskWrapper;\n&#x27;
                           &#x27;import com.arialyy.aria.core.upload.UploadEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.orm.DbEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.util.ALog;\n&#x27;
                           &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                           &#x27;import com.arialyy.aria.util.DbDataHelper;\n&#x27;
                           &#x27;import java.io.File;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;import java.util.HashSet;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;import java.util.Properties;\n&#x27;
                           &#x27;import java.util.Set;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * 处理任务记录，分配线程区间\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class RecordHandler {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  public static final int TYPE_DOWNLOAD = 1;\n&#x27;
                           &#x27;  public static final int TYPE_UPLOAD = 2;\n&#x27;
                           &#x27;  private final String TAG = &quot;RecordHandler&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private static final String STATE = &quot;_state_&quot;;\n&#x27;
                           &#x27;  private static final String RECORD = &#x27;
                           &#x27;&quot;_record_&quot;;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 小于1m的文件不启用多线程\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private static final long SUB_LEN = 1024 * &#x27;
                           &#x27;1024;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 分块文件路径\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public static final String SUB_PATH = &#x27;
                           &#x27;&quot;%s.%s.part&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Deprecated private File mConfigFile;\n&#x27;
                           &#x27;  private TaskRecord mRecord;\n&#x27;
                           &#x27;  private AbsTaskWrapper mTaskWrapper;\n&#x27;
                           &#x27;  private AbsNormalEntity mEntity;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  RecordHandler(AbsTaskWrapper wrapper) {\n&#x27;
                           &#x27;    mTaskWrapper = wrapper;\n&#x27;
                           &#x27;    mEntity = (AbsNormalEntity) &#x27;
                           &#x27;mTaskWrapper.getEntity();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 获取任务记录，如果任务记录存在，检查任务记录\n&#x27;
                           &#x27;   * 检查记录 对于分块任务： 子分块不存在或被删除，子线程将重新下载\n&#x27;
                           &#x27;   * 对于普通任务： 预下载文件不存在，则任务任务呗删除\n&#x27;
                           &#x27;   * 如果任务记录不存在或线程记录不存在，初始化记录\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return 任务记录\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  TaskRecord getRecord() {\n&#x27;
                           &#x27;    mConfigFile = new &#x27;
                           &#x27;File(CommonUtil.getFileConfigPath(false, &#x27;
                           &#x27;mEntity.getFileName()));\n&#x27;
                           &#x27;    if (mConfigFile.exists()) {\n&#x27;
                           &#x27;      convertDb();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      mRecord = &#x27;
                           &#x27;DbDataHelper.getTaskRecord(getFilePath());\n&#x27;
                           &#x27;      if (mRecord == null) {\n&#x27;
                           &#x27;        initRecord(true);\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        if (mRecord.threadRecords == null || &#x27;
                           &#x27;mRecord.threadRecords.isEmpty()) {\n&#x27;
                           &#x27;          initRecord(false);\n&#x27;
                           &#x27;        } else if (mRecord.isBlock) {\n&#x27;
                           &#x27;          handleBlockRecord();\n&#x27;
                           &#x27;        } else if (!mTaskWrapper.isSupportBP()) {\n&#x27;
                           &#x27;          handleNoSupportBPRecord();\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          handleSingleThreadRecord();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    saveRecord();\n&#x27;
                           &#x27;    return mRecord;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理不支持断点的记录\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleNoSupportBPRecord() {\n&#x27;
                           &#x27;    ThreadRecord tr = &#x27;
                           &#x27;mRecord.threadRecords.get(0);\n&#x27;
                           &#x27;    tr.startLocation = 0;\n&#x27;
                           &#x27;    tr.endLocation = mEntity.getFileSize();\n&#x27;
                           &#x27;    tr.key = mRecord.filePath;\n&#x27;
                           &#x27;    tr.blockLen = tr.endLocation;\n&#x27;
                           &#x27;    tr.isComplete = false;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理单线程的任务的记录\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleSingleThreadRecord() {\n&#x27;
                           &#x27;    File file = new File(mRecord.filePath);\n&#x27;
                           &#x27;    ThreadRecord tr = &#x27;
                           &#x27;mRecord.threadRecords.get(0);\n&#x27;
                           &#x27;    if (!file.exists()) {\n&#x27;
                           &#x27;      ALog.w(TAG, &#x27;
                           &#x27;String.format(&quot;文件【%s】不存在，任务将重新开始&quot;, &#x27;
                           &#x27;file.getPath()));\n&#x27;
                           &#x27;      tr.startLocation = 0;\n&#x27;
                           &#x27;      tr.isComplete = false;\n&#x27;
                           &#x27;      tr.endLocation = mEntity.getFileSize();\n&#x27;
                           &#x27;    } else if (mRecord.isOpenDynamicFile) {\n&#x27;
                           &#x27;      if (file.length() &gt; mEntity.getFileSize()) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;文件【%s】错误，任务重新开始&quot;, &#x27;
                           &#x27;file.getPath()));\n&#x27;
                           &#x27;        file.delete();\n&#x27;
                           &#x27;        tr.startLocation = 0;\n&#x27;
                           &#x27;        tr.isComplete = false;\n&#x27;
                           &#x27;        tr.endLocation = mEntity.getFileSize();\n&#x27;
                           &#x27;      } else if (file.length() == &#x27;
                           &#x27;mEntity.getFileSize()) {\n&#x27;
                           &#x27;        tr.isComplete = true;\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        if (file.length() != tr.startLocation) {\n&#x27;
                           &#x27;          ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;修正【%s】的进度记录为：%s&quot;, file.getPath(), &#x27;
                           &#x27;file.length()));\n&#x27;
                           &#x27;          tr.startLocation = file.length();\n&#x27;
                           &#x27;          tr.isComplete = false;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    mTaskWrapper.setNewTask(false);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * &#x27;
                           &#x27;处理分块任务的记录，分块文件（blockFileLen）长度必须需要小于等于线程区间（threadRectLen）的长度\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleBlockRecord() {\n&#x27;
                           &#x27;    // 默认线程分块长度\n&#x27;
                           &#x27;    long normalRectLen = mEntity.getFileSize() / &#x27;
                           &#x27;mRecord.threadRecords.size();\n&#x27;
                           &#x27;    for (ThreadRecord tr : mRecord.threadRecords) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      long threadRect = tr.blockLen;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      File temp = new File(String.format(SUB_PATH, &#x27;
                           &#x27;mRecord.filePath, tr.threadId));\n&#x27;
                           &#x27;      if (!temp.exists()) {\n&#x27;
                           &#x27;        ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;分块文件【%s】不存在，该分块将重新开始&quot;, &#x27;
                           &#x27;temp.getPath()));\n&#x27;
                           &#x27;        tr.isComplete = false;\n&#x27;
                           &#x27;        tr.startLocation = tr.threadId * &#x27;
                           &#x27;normalRectLen;\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        if (!tr.isComplete) {\n&#x27;
                           &#x27;          ALog.i(TAG, String.format(\n&#x27;
                           &#x27;              &quot;startLocation = %s; endLocation = &#x27;
                           &#x27;%s; block = %s; tempLen = %s; threadId = %s&quot;,\n&#x27;
                           &#x27;              tr.startLocation, tr.endLocation, &#x27;
                           &#x27;threadRect, temp.length(), tr.threadId));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;          long blockFileLen = temp.length(); // &#x27;
                           &#x27;磁盘中的分块文件长度\n&#x27;
                           &#x27;          /*\n&#x27;
                           &#x27;           * 检查磁盘中的分块文件\n&#x27;
                           &#x27;           */\n&#x27;
                           &#x27;          if (blockFileLen &gt; threadRect) {\n&#x27;
                           &#x27;            ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;分块【%s】错误，分块长度【%s】 &gt; &#x27;
                           &#x27;线程区间长度【%s】，将重新开始该分块&quot;,\n&#x27;
                           &#x27;                tr.threadId, blockFileLen, &#x27;
                           &#x27;threadRect));\n&#x27;
                           &#x27;            temp.delete();\n&#x27;
                           &#x27;            tr.startLocation = tr.threadId * &#x27;
                           &#x27;threadRect;\n&#x27;
                           &#x27;            continue;\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;          long realLocation =\n&#x27;
                           &#x27;              tr.threadId * normalRectLen + &#x27;
                           &#x27;blockFileLen; //正常情况下，该线程的startLocation的位置\n&#x27;
                           &#x27;          /*\n&#x27;
                           &#x27;           * 检查记录文件\n&#x27;
                           &#x27;           */\n&#x27;
                           &#x27;          if (blockFileLen == threadRect) {\n&#x27;
                           &#x27;            ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;分块【%s】已完成，更新记录&quot;, temp.getPath()));\n&#x27;
                           &#x27;            tr.startLocation = blockFileLen;\n&#x27;
                           &#x27;            tr.isComplete = true;\n&#x27;
                           &#x27;          } else if (tr.startLocation != &#x27;
                           &#x27;realLocation) { // 处理记录小于分块文件长度的情况\n&#x27;
                           &#x27;            ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;修正分块【%s】的进度记录为：%s&quot;, temp.getPath(), &#x27;
                           &#x27;realLocation));\n&#x27;
                           &#x27;            tr.startLocation = realLocation;\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          ALog.i(TAG, String.format(&quot;分块【%s】已完成&quot;, &#x27;
                           &#x27;temp.getPath()));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    mTaskWrapper.setNewTask(false);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * convertDb 是兼容性代码 从3.4.1开始，线程配置信息将存储在数据库中。 &#x27;
                           &#x27;将配置文件的内容复制到数据库中，并将配置文件删除\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void convertDb() {\n&#x27;
                           &#x27;    List&lt;RecordWrapper&gt; records =\n&#x27;
                           &#x27;        &#x27;
                           &#x27;DbEntity.findRelationData(RecordWrapper.class, &#x27;
                           &#x27;&quot;TaskRecord.filePath=?&quot;,\n&#x27;
                           &#x27;            getFilePath());\n&#x27;
                           &#x27;    if (records == null || records.size() == 0) {\n&#x27;
                           &#x27;      Properties pro = &#x27;
                           &#x27;CommonUtil.loadConfig(mConfigFile);\n&#x27;
                           &#x27;      if (pro.isEmpty()) {\n&#x27;
                           &#x27;        ALog.d(TAG, &quot;老版本的线程记录为空，任务为新任务&quot;);\n&#x27;
                           &#x27;        initRecord(true);\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      Set&lt;Object&gt; keys = pro.keySet();\n&#x27;
                           &#x27;      // &#x27;
                           &#x27;老版本记录是5s存一次，但是5s中内，如果线程执行完成，record记录是没有的，只有state记录...\n&#x27;
                           &#x27;      // 第一步应该是record 和 state去重取正确的线程数\n&#x27;
                           &#x27;      Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\n&#x27;
                           &#x27;      for (Object key : keys) {\n&#x27;
                           &#x27;        String str = String.valueOf(key);\n&#x27;
                           &#x27;        int i = &#x27;
                           &#x27;Integer.parseInt(str.substring(str.length() - &#x27;
                           &#x27;1));\n&#x27;
                           &#x27;        set.add(i);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      int threadNum = set.size();\n&#x27;
                           &#x27;      if (threadNum == 0) {\n&#x27;
                           &#x27;        ALog.d(TAG, &quot;线程数为空，任务为新任务&quot;);\n&#x27;
                           &#x27;        initRecord(true);\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mTaskWrapper.setNewTask(false);\n&#x27;
                           &#x27;      mRecord = createTaskRecord(threadNum);\n&#x27;
                           &#x27;      mRecord.isOpenDynamicFile = false;\n&#x27;
                           &#x27;      mRecord.isBlock = false;\n&#x27;
                           &#x27;      File tempFile = new File(getFilePath());\n&#x27;
                           &#x27;      for (int i = 0; i &lt; threadNum; i++) {\n&#x27;
                           &#x27;        ThreadRecord tRecord = new &#x27;
                           &#x27;ThreadRecord();\n&#x27;
                           &#x27;        tRecord.key = mRecord.filePath;\n&#x27;
                           &#x27;        Object state = &#x27;
                           &#x27;pro.getProperty(tempFile.getName() + STATE + i);\n&#x27;
                           &#x27;        Object record = &#x27;
                           &#x27;pro.getProperty(tempFile.getName() + RECORD + i);\n&#x27;
                           &#x27;        if (state != null &amp;&amp; &#x27;
                           &#x27;Integer.parseInt(String.valueOf(state)) == 1) {\n&#x27;
                           &#x27;          tRecord.isComplete = true;\n&#x27;
                           &#x27;          continue;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (record != null) {\n&#x27;
                           &#x27;          long temp = &#x27;
                           &#x27;Long.parseLong(String.valueOf(record));\n&#x27;
                           &#x27;          tRecord.startLocation = temp &gt; 0 ? temp &#x27;
                           &#x27;: 0;\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          tRecord.startLocation = 0;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        mRecord.threadRecords.add(tRecord);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mConfigFile.delete();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 初始化任务记录，分配线程区间\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param newRecord {@code true} 需要创建新{@link &#x27;
                           &#x27;TaskRecord}\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void initRecord(boolean newRecord) {\n&#x27;
                           &#x27;    if (newRecord) {\n&#x27;
                           &#x27;      mRecord = &#x27;
                           &#x27;createTaskRecord(getNewTaskThreadNum());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    mTaskWrapper.setNewTask(true);\n&#x27;
                           &#x27;    // 处理线程区间记录\n&#x27;
                           &#x27;    long blockSize = mEntity.getFileSize() / &#x27;
                           &#x27;mRecord.threadNum;\n&#x27;
                           &#x27;    for (int i = 0; i &lt; mRecord.threadNum; i++) {\n&#x27;
                           &#x27;      long startL = i * blockSize, endL = (i + 1) &#x27;
                           &#x27;* blockSize;\n&#x27;
                           &#x27;      ThreadRecord tr;\n&#x27;
                           &#x27;      tr = new ThreadRecord();\n&#x27;
                           &#x27;      tr.key = mRecord.filePath;\n&#x27;
                           &#x27;      tr.threadId = i;\n&#x27;
                           &#x27;      tr.startLocation = startL;\n&#x27;
                           &#x27;      //最后一个线程的结束位置即为文件的总长度\n&#x27;
                           &#x27;      if (i == (mRecord.threadNum - 1)) {\n&#x27;
                           &#x27;        endL = mEntity.getFileSize();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      tr.endLocation = endL;\n&#x27;
                           &#x27;      tr.blockLen = &#x27;
                           &#x27;CommonUtil.getBlockLen(mEntity.getFileSize(), i, &#x27;
                           &#x27;mRecord.threadNum);\n&#x27;
                           &#x27;      mRecord.threadRecords.add(tr);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 创建任务记录\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param threadNum 线程总数\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private TaskRecord createTaskRecord(int &#x27;
                           &#x27;threadNum) {\n&#x27;
                           &#x27;    TaskRecord record = new TaskRecord();\n&#x27;
                           &#x27;    record.fileName = mEntity.getFileName();\n&#x27;
                           &#x27;    record.filePath = getFilePath();\n&#x27;
                           &#x27;    record.threadRecords = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;    record.threadNum = threadNum;\n&#x27;
                           &#x27;    // 处理分块和动态文件参数\n&#x27;
                           &#x27;    if (getRecordType() == TYPE_DOWNLOAD) {\n&#x27;
                           &#x27;      record.isBlock = threadNum &gt; 1 &amp;&amp; &#x27;
                           &#x27;Configuration.getInstance().downloadCfg.isUseBlock();\n&#x27;
                           &#x27;      // 线程数为1，或者使用了分块，则认为是使用动态长度文件\n&#x27;
                           &#x27;      record.isOpenDynamicFile = threadNum == 1 || &#x27;
                           &#x27;record.isBlock;\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      record.isBlock = false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    record.isGroupRecord = &#x27;
                           &#x27;mEntity.isGroupChild();\n&#x27;
                           &#x27;    if (record.isGroupRecord) {\n&#x27;
                           &#x27;      if (mEntity instanceof DownloadEntity) {\n&#x27;
                           &#x27;        record.dGroupHash = ((DownloadEntity) &#x27;
                           &#x27;mEntity).getGroupHash();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    return record;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 保存任务记录\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void saveRecord() {\n&#x27;
                           &#x27;    mRecord.threadNum = &#x27;
                           &#x27;mRecord.threadRecords.size();\n&#x27;
                           &#x27;    mRecord.save();\n&#x27;
                           &#x27;    DbEntity.saveAll(mRecord.threadRecords);\n&#x27;
                           &#x27;    ALog.d(TAG, String.format(&quot;保存记录，线程记录数：%s&quot;, &#x27;
                           &#x27;mRecord.threadRecords.size()));\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 获取记录类型\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return {@link #TYPE_DOWNLOAD}、{@link &#x27;
                           &#x27;#TYPE_UPLOAD}\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private int getRecordType() {\n&#x27;
                           &#x27;    if (mEntity instanceof DownloadEntity) {\n&#x27;
                           &#x27;      return TYPE_DOWNLOAD;\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      return TYPE_UPLOAD;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 获取任务路径\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return 任务文件路径\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private String getFilePath() {\n&#x27;
                           &#x27;    if (mEntity instanceof DownloadEntity) {\n&#x27;
                           &#x27;      return ((DownloadEntity) &#x27;
                           &#x27;mTaskWrapper.getEntity()).getFilePath();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      return ((UploadEntity) &#x27;
                           &#x27;mTaskWrapper.getEntity()).getFilePath();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 小于1m的文件或是任务组的子任务、线程数强制为1\n&#x27;
                           &#x27;   * 不支持断点或chunked模式的线程数都为，线程数强制为1\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private int getNewTaskThreadNum() {\n&#x27;
                           &#x27;    if (getRecordType() == TYPE_DOWNLOAD) {\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;import com.arialyy.aria.core.download.DTaskWrapper;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.arialyy.aria.core.download.DownloadEntity;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.arialyy.aria.core.download.m3u8.M3U8FileLoader;\n&#x27;
                         &#x27;import com.arialyy.aria.core.inf.AbsNormalEntity;\n&#x27;
                         &#x27;import com.arialyy.aria.core.inf.AbsTaskWrapper;\n&#x27;
                         &#x27;import com.arialyy.aria.core.inf.ITaskWrapper;\n&#x27;
                         &#x27;import com.arialyy.aria.core.upload.UploadEntity;\n&#x27;
                         &#x27;import com.arialyy.aria.orm.DbEntity;\n&#x27;
                         &#x27;import com.arialyy.aria.util.ALog;\n&#x27;
                         &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                         &#x27;import com.arialyy.aria.util.DbDataHelper;\n&#x27;
                         &#x27;import java.io.File;\n&#x27;
                         &#x27;import java.util.ArrayList;\n&#x27;
                         &#x27;import java.util.HashSet;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Properties;\n&#x27;
                         &#x27;import java.util.Set;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * 处理任务记录，分配线程区间\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public class RecordHandler {\n&#x27;
                         &#x27;  private final String TAG = &quot;RecordHandler&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  public static final int TYPE_DOWNLOAD = 1;\n&#x27;
                         &#x27;  public static final int TYPE_UPLOAD = 2;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private static final String STATE = &quot;_state_&quot;;\n&#x27;
                         &#x27;  private static final String RECORD = &quot;_record_&quot;;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 小于1m的文件不启用多线程\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private static final long SUB_LEN = 1024 * 1024;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 分块文件路径\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public static final String SUB_PATH = &#x27;
                         &#x27;&quot;%s.%s.part&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Deprecated private File mConfigFile;\n&#x27;
                         &#x27;  private TaskRecord mRecord;\n&#x27;
                         &#x27;  private AbsTaskWrapper mTaskWrapper;\n&#x27;
                         &#x27;  private AbsNormalEntity mEntity;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  RecordHandler(AbsTaskWrapper wrapper) {\n&#x27;
                         &#x27;    mTaskWrapper = wrapper;\n&#x27;
                         &#x27;    mEntity = (AbsNormalEntity) &#x27;
                         &#x27;mTaskWrapper.getEntity();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取任务记录，如果任务记录存在，检查任务记录\n&#x27;
                         &#x27;   * 检查记录 对于分块任务： 子分块不存在或被删除，子线程将重新下载\n&#x27;
                         &#x27;   * 对于普通任务： 预下载文件不存在，则任务任务呗删除\n&#x27;
                         &#x27;   * 如果任务记录不存在或线程记录不存在，初始化记录\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @return 任务记录\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  TaskRecord getRecord() {\n&#x27;
                         &#x27;    mConfigFile = new &#x27;
                         &#x27;File(CommonUtil.getFileConfigPath(false, &#x27;
                         &#x27;mEntity.getFileName()));\n&#x27;
                         &#x27;    if (mConfigFile.exists()) {\n&#x27;
                         &#x27;      convertDb();\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      mRecord = &#x27;
                         &#x27;DbDataHelper.getTaskRecord(getFilePath());\n&#x27;
                         &#x27;      if (mRecord == null) {\n&#x27;
                         &#x27;        initRecord(true);\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        if (mRecord.threadRecords == null || &#x27;
                         &#x27;mRecord.threadRecords.isEmpty()) {\n&#x27;
                         &#x27;          initRecord(false);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if (mTaskWrapper.getRequestType() == &#x27;
                         &#x27;ITaskWrapper.M3U8_FILE) {\n&#x27;
                         &#x27;          handleM3U8Record();\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          if (mRecord.isBlock) {\n&#x27;
                         &#x27;            handleBlockRecord();\n&#x27;
                         &#x27;          } else if (!mTaskWrapper.isSupportBP()) {\n&#x27;
                         &#x27;            handleNoSupportBPRecord();\n&#x27;
                         &#x27;          } else {\n&#x27;
                         &#x27;            handleSingleThreadRecord();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    saveRecord();\n&#x27;
                         &#x27;    return mRecord;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理m3u8记录，\n&#x27;
                         &#x27;   * 1、如果分片文件存在，并且分片文件的记录没有完成，则需要删除该分片文件\n&#x27;
                         &#x27;   * 2、如果记录显示已完成，但是分片文件不存在，则重新开始该分片\n&#x27;
                         &#x27;   * 3、如果记录显示已完成，并且文件存在，记录当前任务进度\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleM3U8Record() {\n&#x27;
                         &#x27;    DTaskWrapper wrapper = (DTaskWrapper) &#x27;
                         &#x27;mTaskWrapper;\n&#x27;
                         &#x27;    String cacheDir = &#x27;
                         &#x27;wrapper.asM3U8().getCacheDir();\n&#x27;
                         &#x27;    long currentProgress = 0;\n&#x27;
                         &#x27;    for (ThreadRecord record : &#x27;
                         &#x27;mRecord.threadRecords) {\n&#x27;
                         &#x27;      File temp = new &#x27;
                         &#x27;File(M3U8FileLoader.getTsFilePath(cacheDir, &#x27;
                         &#x27;record.threadId));\n&#x27;
                         &#x27;      if (!record.isComplete) {\n&#x27;
                         &#x27;        if (temp.exists()) {\n&#x27;
                         &#x27;          temp.delete();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        record.startLocation = 0;\n&#x27;
                         &#x27;        ALog.d(TAG, &#x27;
                         &#x27;String.format(&quot;分片【%s】未完成，将重新下载该分片&quot;, &#x27;
                         &#x27;record.threadId));\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        if (!temp.exists()) {\n&#x27;
                         &#x27;          record.startLocation = 0;\n&#x27;
                         &#x27;          record.isComplete = false;\n&#x27;
                         &#x27;          ALog.w(TAG, &#x27;
                         &#x27;String.format(&quot;分片【%s】不存在，将重新下载该分片&quot;, &#x27;
                         &#x27;record.threadId));\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          currentProgress += temp.length();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    &#x27;
                         &#x27;wrapper.getEntity().setCurrentProgress(currentProgress);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理不支持断点的记录\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleNoSupportBPRecord() {\n&#x27;
                         &#x27;    ThreadRecord tr = mRecord.threadRecords.get(0);\n&#x27;
                         &#x27;    tr.startLocation = 0;\n&#x27;
                         &#x27;    tr.endLocation = mEntity.getFileSize();\n&#x27;
                         &#x27;    tr.key = mRecord.filePath;\n&#x27;
                         &#x27;    tr.blockLen = tr.endLocation;\n&#x27;
                         &#x27;    tr.isComplete = false;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理单线程的任务的记录\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleSingleThreadRecord() {\n&#x27;
                         &#x27;    File file = new File(mRecord.filePath);\n&#x27;
                         &#x27;    ThreadRecord tr = mRecord.threadRecords.get(0);\n&#x27;
                         &#x27;    if (!file.exists()) {\n&#x27;
                         &#x27;      ALog.w(TAG, String.format(&quot;文件【%s】不存在，任务将重新开始&quot;, &#x27;
                         &#x27;file.getPath()));\n&#x27;
                         &#x27;      tr.startLocation = 0;\n&#x27;
                         &#x27;      tr.isComplete = false;\n&#x27;
                         &#x27;      tr.endLocation = mEntity.getFileSize();\n&#x27;
                         &#x27;    } else if (mRecord.isOpenDynamicFile) {\n&#x27;
                         &#x27;      if (file.length() &gt; mEntity.getFileSize()) {\n&#x27;
                         &#x27;        ALog.i(TAG, String.format(&quot;文件【%s】错误，任务重新开始&quot;, &#x27;
                         &#x27;file.getPath()));\n&#x27;
                         &#x27;        file.delete();\n&#x27;
                         &#x27;        tr.startLocation = 0;\n&#x27;
                         &#x27;        tr.isComplete = false;\n&#x27;
                         &#x27;        tr.endLocation = mEntity.getFileSize();\n&#x27;
                         &#x27;      } else if (file.length() == &#x27;
                         &#x27;mEntity.getFileSize()) {\n&#x27;
                         &#x27;        tr.isComplete = true;\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        if (file.length() != tr.startLocation) {\n&#x27;
                         &#x27;          ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;修正【%s】的进度记录为：%s&quot;, file.getPath(), &#x27;
                         &#x27;file.length()));\n&#x27;
                         &#x27;          tr.startLocation = file.length();\n&#x27;
                         &#x27;          tr.isComplete = false;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    mTaskWrapper.setNewTask(false);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * &#x27;
                         &#x27;处理分块任务的记录，分块文件（blockFileLen）长度必须需要小于等于线程区间（threadRectLen）的长度\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleBlockRecord() {\n&#x27;
                         &#x27;    // 默认线程分块长度\n&#x27;
                         &#x27;    long normalRectLen = mEntity.getFileSize() / &#x27;
                         &#x27;mRecord.threadRecords.size();\n&#x27;
                         &#x27;    for (ThreadRecord tr : mRecord.threadRecords) {\n&#x27;
                         &#x27;      long threadRect = tr.blockLen;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;      File temp = new File(String.format(SUB_PATH, &#x27;
                         &#x27;mRecord.filePath, tr.threadId));\n&#x27;
                         &#x27;      if (!temp.exists()) {\n&#x27;
                         &#x27;        ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;分块文件【%s】不存在，该分块将重新开始&quot;, &#x27;
                         &#x27;temp.getPath()));\n&#x27;
                         &#x27;        tr.isComplete = false;\n&#x27;
                         &#x27;        tr.startLocation = tr.threadId * &#x27;
                         &#x27;normalRectLen;\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        if (!tr.isComplete) {\n&#x27;
                         &#x27;          ALog.i(TAG, String.format(\n&#x27;
                         &#x27;              &quot;startLocation = %s; endLocation = %s; &#x27;
                         &#x27;block = %s; tempLen = %s; threadId = %s&quot;,\n&#x27;
                         &#x27;              tr.startLocation, tr.endLocation, &#x27;
                         &#x27;threadRect, temp.length(), tr.threadId));\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;          long blockFileLen = temp.length(); // &#x27;
                         &#x27;磁盘中的分块文件长度\n&#x27;
                         &#x27;          /*\n&#x27;
                         &#x27;           * 检查磁盘中的分块文件\n&#x27;
                         &#x27;           */\n&#x27;
                         &#x27;          if (blockFileLen &gt; threadRect) {\n&#x27;
                         &#x27;            ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;分块【%s】错误，分块长度【%s】 &gt; &#x27;
                         &#x27;线程区间长度【%s】，将重新开始该分块&quot;,\n&#x27;
                         &#x27;                tr.threadId, blockFileLen, &#x27;
                         &#x27;threadRect));\n&#x27;
                         &#x27;            temp.delete();\n&#x27;
                         &#x27;            tr.startLocation = tr.threadId * &#x27;
                         &#x27;threadRect;\n&#x27;
                         &#x27;            continue;\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;          long realLocation =\n&#x27;
                         &#x27;              tr.threadId * normalRectLen + &#x27;
                         &#x27;blockFileLen; //正常情况下，该线程的startLocation的位置\n&#x27;
                         &#x27;          /*\n&#x27;
                         &#x27;           * 检查记录文件\n&#x27;
                         &#x27;           */\n&#x27;
                         &#x27;          if (blockFileLen == threadRect) {\n&#x27;
                         &#x27;            ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;分块【%s】已完成，更新记录&quot;, temp.getPath()));\n&#x27;
                         &#x27;            tr.startLocation = blockFileLen;\n&#x27;
                         &#x27;            tr.isComplete = true;\n&#x27;
                         &#x27;          } else if (tr.startLocation != &#x27;
                         &#x27;realLocation) { // 处理记录小于分块文件长度的情况\n&#x27;
                         &#x27;            ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;修正分块【%s】的进度记录为：%s&quot;, temp.getPath(), &#x27;
                         &#x27;realLocation));\n&#x27;
                         &#x27;            tr.startLocation = realLocation;\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          ALog.i(TAG, String.format(&quot;分块【%s】已完成&quot;, &#x27;
                         &#x27;temp.getPath()));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    mTaskWrapper.setNewTask(false);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * convertDb 是兼容性代码 从3.4.1开始，线程配置信息将存储在数据库中。 &#x27;
                         &#x27;将配置文件的内容复制到数据库中，并将配置文件删除\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void convertDb() {\n&#x27;
                         &#x27;    List&lt;RecordWrapper&gt; records =\n&#x27;
                         &#x27;        &#x27;
                         &#x27;DbEntity.findRelationData(RecordWrapper.class, &#x27;
                         &#x27;&quot;TaskRecord.filePath=?&quot;,\n&#x27;
                         &#x27;            getFilePath());\n&#x27;
                         &#x27;    if (records == null || records.size() == 0) {\n&#x27;
                         &#x27;      Properties pro = &#x27;
                         &#x27;CommonUtil.loadConfig(mConfigFile);\n&#x27;
                         &#x27;      if (pro.isEmpty()) {\n&#x27;
                         &#x27;        ALog.d(TAG, &quot;老版本的线程记录为空，任务为新任务&quot;);\n&#x27;
                         &#x27;        initRecord(true);\n&#x27;
                         &#x27;        return;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;      Set&lt;Object&gt; keys = pro.keySet();\n&#x27;
                         &#x27;      // &#x27;
                         &#x27;老版本记录是5s存一次，但是5s中内，如果线程执行完成，record记录是没有的，只有state记录...\n&#x27;
                         &#x27;      // 第一步应该是record 和 state去重取正确的线程数\n&#x27;
                         &#x27;      Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\n&#x27;
                         &#x27;      for (Object key : keys) {\n&#x27;
                         &#x27;        String str = String.valueOf(key);\n&#x27;
                         &#x27;        int i = &#x27;
                         &#x27;Integer.parseInt(str.substring(str.length() - 1));\n&#x27;
                         &#x27;        set.add(i);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      int threadNum = set.size();\n&#x27;
                         &#x27;      if (threadNum == 0) {\n&#x27;
                         &#x27;        ALog.d(TAG, &quot;线程数为空，任务为新任务&quot;);\n&#x27;
                         &#x27;        initRecord(true);\n&#x27;
                         &#x27;        return;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      mTaskWrapper.setNewTask(false);\n&#x27;
                         &#x27;      mRecord = createTaskRecord(threadNum);\n&#x27;
                         &#x27;      mRecord.isOpenDynamicFile = false;\n&#x27;
                         &#x27;      mRecord.isBlock = false;\n&#x27;
                         &#x27;      File tempFile = new File(getFilePath());\n&#x27;
                         &#x27;      for (int i = 0; i &lt; threadNum; i++) {\n&#x27;
                         &#x27;        ThreadRecord tRecord = new ThreadRecord();\n&#x27;
                         &#x27;        tRecord.key = mRecord.filePath;\n&#x27;
                         &#x27;        Object state = &#x27;
                         &#x27;pro.getProperty(tempFile.getName() + STATE + i);\n&#x27;
                         &#x27;        Object record = &#x27;
                         &#x27;pro.getProperty(tempFile.getName() + RECORD + i);\n&#x27;
                         &#x27;        if (state != null &amp;&amp; &#x27;
                         &#x27;Integer.parseInt(String.valueOf(state)) == 1) {\n&#x27;
                         &#x27;          tRecord.isComplete = true;\n&#x27;
                         &#x27;          continue;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (record != null) {\n&#x27;
                         &#x27;          long temp = &#x27;
                         &#x27;Long.parseLong(String.valueOf(record));\n&#x27;
                         &#x27;          tRecord.startLocation = temp &gt; 0 ? temp : &#x27;
                         &#x27;0;\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          tRecord.startLocation = 0;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        mRecord.threadRecords.add(tRecord);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      mConfigFile.delete();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 初始化任务记录，分配线程区间\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @param newRecord {@code true} 需要创建新{@link &#x27;
                         &#x27;TaskRecord}\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void initRecord(boolean newRecord) {\n&#x27;
                         &#x27;    if (newRecord) {\n&#x27;
                         &#x27;      mRecord = &#x27;
                         &#x27;createTaskRecord(getNewTaskThreadNum());\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    mTaskWrapper.setNewTask(true);\n&#x27;
                         &#x27;    // 处理线程区间记录\n&#x27;
                         &#x27;    int requestType = &#x27;
                         &#x27;mTaskWrapper.getRequestType();\n&#x27;
                         &#x27;    long blockSize = mEntity.getFileSize() / &#x27;
                         &#x27;mRecord.threadNum;\n&#x27;
                         &#x27;    for (int i = 0; i &lt; mRecord.threadNum; i++) {\n&#x27;
                         &#x27;      long startL = i * blockSize, endL = (i + 1) * &#x27;
                         &#x27;blockSize;\n&#x27;
                         &#x27;      ThreadRecord tr;\n&#x27;
                         &#x27;      tr = new ThreadRecord();\n&#x27;
                         &#x27;      tr.key = mRecord.filePath;\n&#x27;
                         &#x27;      tr.threadId = i;\n&#x27;
                         &#x27;      tr.startLocation = startL;\n&#x27;
                         &#x27;      tr.isComplete = false;\n&#x27;
                         &#x27;      if (requestType == ITaskWrapper.M3U8_FILE) {\n&#x27;
                         &#x27;        tr.startLocation = 0;\n&#x27;
                         &#x27;        tr.threadType = TaskRecord.TYPE_M3U8;\n&#x27;
                         &#x27;        tr.m3u8url = ((DTaskWrapper) &#x27;
                         &#x27;mTaskWrapper).asM3U8().getUrls().get(i);\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        tr.threadType = TaskRecord.TYPE_HTTP_FTP;\n&#x27;
                         &#x27;        //最后一个线程的结束位置即为文件的总长度\n&#x27;
                         &#x27;        if (i == (mRecord.threadNum - 1)) {\n&#x27;
                         &#x27;          endL = mEntity.getFileSize();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        tr.endLocation = endL;\n&#x27;
                         &#x27;        tr.blockLen = &#x27;
                         &#x27;CommonUtil.getBlockLen(mEntity.getFileSize(), i, &#x27;
                         &#x27;mRecord.threadNum);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      mRecord.threadRecords.add(tr);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 创建任务记录\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @param threadNum 线程总数\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private TaskRecord createTaskRecord(int threadNum) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;    TaskRecord record = new TaskRecord();\n&#x27;
                         &#x27;    record.fileName = mEntity.getFileName();\n&#x27;
                         &#x27;    record.filePath = getFilePath();\n&#x27;
                         &#x27;    record.threadRecords = new ArrayList&lt;&gt;();\n&#x27;
                         &#x27;    record.threadNum = threadNum;\n&#x27;
                         &#x27;    // 处理分块和动态文件参数\n&#x27;
                         &#x27;    if (getRecordType() == TYPE_DOWNLOAD) {\n&#x27;
                         &#x27;      record.isBlock = threadNum &gt; 1 &amp;&amp; &#x27;
                         &#x27;Configuration.getInstance().downloadCfg.isUseBlock();\n&#x27;
                         &#x27;      // 线程数为1，或者使用了分块，则认为是使用动态长度文件\n&#x27;
                         &#x27;      record.isOpenDynamicFile = threadNum == 1 || &#x27;
                         &#x27;record.isBlock;\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      record.isBlock = false;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    if (mTaskWrapper.getRequestType() == &#x27;
                         &#x27;ITaskWrapper.M3U8_FILE) {\n&#x27;
                         &#x27;      record.taskType = TaskRecord.TYPE_M3U8;\n&#x27;
                         &#x27;      record.isOpenDynamicFile = true;\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      record.taskType = TaskRecord.TYPE_HTTP_FTP;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    record.isGroupRecord = mEntity.isGroupChild();\n&#x27;
                         &#x27;    if (record.isGroupRecord) {\n&#x27;
                         &#x27;      if (mEntity instanceof DownloadEntity) {\n&#x27;
                         &#x27;        record.dGroupHash = ((DownloadEntity) &#x27;
                         &#x27;mEntity).getGroupHash();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    return record;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 保存任务记录\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void saveRecord() {\n&#x27;
                         &#x27;    mRecord.threadNum = &#x27;
                         &#x27;mRecord.threadRecords.size();\n&#x27;
                         &#x27;    mRecord.save();\n&#x27;
                         &#x27;    DbEntity.saveAll(mRecord.threadRecords);\n&#x27;
                         &#x27;    ALog.d(TAG, String.format(&quot;保存记录，线程记录数：%s&quot;, &#x27;
                         &#x27;mRecord.threadRecords.size()));\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取记录类型\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @return {@link #TYPE_DOWNLOAD}、{@link &#x27;
                         &#x27;#TYPE_UPLOAD}\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private int getRecordType() {\n&#x27;
                         &#x27;    if (mEntity instanceof DownloadEntity) {\n&#x27;
                         &#x27;      return TYPE_DOWNLOAD;\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      return TYPE_UPLOAD;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取任务路径\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @return 任务文件路径\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private String getFilePath() {\n&#x27;
                         &#x27;    if (mEntity instanceof DownloadEntity) {\n&#x27;
                         &#x27;      return ((DownloadEntity) &#x27;
                         &#x27;mTaskWrapper.getEntity()).getFilePath();\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      return ((UploadEntity) &#x27;
                         &#x27;mTaskWrapper.getEntity()).getFilePath();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 小于1m的文件或是任务组的子任务、线程数强制为1\n&#x27;
                         &#x27;   * 不支持断点或chunked模式的线程数都为，线程数强制为1\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private int getNewTaskThreadNum() {\n&#x27;
                         &#x27;    if (getRecordType() == TYPE_DOWNLOAD) {\n&#x27;
                         &#x27;      if (mTaskWrapper.getRequestType() == &#x27;
                         &#x27;ITaskWrapper.M3U8_FILE) {\n&#x27;
                         &#x27;        return ((DTaskWrapper) &#x27;
                         &#x27;mTaskWrapper).asM3U8().getUrls().size();\n&#x27;
                         &#x27;      }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.DownloadEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.core.inf.AbsNormalEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.core.inf.AbsTaskWrapper;\n&#x27;
                           &#x27;import com.arialyy.aria.core.upload.UploadEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.orm.DbEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.util.ALog;\n&#x27;
                           &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                           &#x27;import com.arialyy.aria.util.DbDataHelper;\n&#x27;
                           &#x27;import java.io.File;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;import java.util.HashSet;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;import java.util.Properties;\n&#x27;
                           &#x27;import java.util.Set;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * 处理任务记录，分配线程区间\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class RecordHandler {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  public static final int TYPE_DOWNLOAD = 1;\n&#x27;
                           &#x27;  public static final int TYPE_UPLOAD = 2;\n&#x27;
                           &#x27;  private final String TAG = &quot;RecordHandler&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private static final String STATE = &quot;_state_&quot;;\n&#x27;
                           &#x27;  private static final String RECORD = &#x27;
                           &#x27;&quot;_record_&quot;;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 小于1m的文件不启用多线程\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private static final long SUB_LEN = 1024 * &#x27;
                           &#x27;1024;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 分块文件路径\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public static final String SUB_PATH = &#x27;
                           &#x27;&quot;%s.%s.part&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Deprecated private File mConfigFile;\n&#x27;
                           &#x27;  private TaskRecord mRecord;\n&#x27;
                           &#x27;  private AbsTaskWrapper mTaskWrapper;\n&#x27;
                           &#x27;  private AbsNormalEntity mEntity;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  RecordHandler(AbsTaskWrapper wrapper) {\n&#x27;
                           &#x27;    mTaskWrapper = wrapper;\n&#x27;
                           &#x27;    mEntity = (AbsNormalEntity) &#x27;
                           &#x27;mTaskWrapper.getEntity();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 获取任务记录，如果任务记录存在，检查任务记录\n&#x27;
                           &#x27;   * 检查记录 对于分块任务： 子分块不存在或被删除，子线程将重新下载\n&#x27;
                           &#x27;   * 对于普通任务： 预下载文件不存在，则任务任务呗删除\n&#x27;
                           &#x27;   * 如果任务记录不存在或线程记录不存在，初始化记录\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return 任务记录\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  TaskRecord getRecord() {\n&#x27;
                           &#x27;    mConfigFile = new &#x27;
                           &#x27;File(CommonUtil.getFileConfigPath(false, &#x27;
                           &#x27;mEntity.getFileName()));\n&#x27;
                           &#x27;    if (mConfigFile.exists()) {\n&#x27;
                           &#x27;      convertDb();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      mRecord = &#x27;
                           &#x27;DbDataHelper.getTaskRecord(getFilePath());\n&#x27;
                           &#x27;      if (mRecord == null) {\n&#x27;
                           &#x27;        initRecord(true);\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        if (mRecord.threadRecords == null || &#x27;
                           &#x27;mRecord.threadRecords.isEmpty()) {\n&#x27;
                           &#x27;          initRecord(false);\n&#x27;
                           &#x27;        } else if (mRecord.isBlock) {\n&#x27;
                           &#x27;          handleBlockRecord();\n&#x27;
                           &#x27;        } else if (!mTaskWrapper.isSupportBP()) {\n&#x27;
                           &#x27;          handleNoSupportBPRecord();\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          handleSingleThreadRecord();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    saveRecord();\n&#x27;
                           &#x27;    return mRecord;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理不支持断点的记录\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleNoSupportBPRecord() {\n&#x27;
                           &#x27;    ThreadRecord tr = &#x27;
                           &#x27;mRecord.threadRecords.get(0);\n&#x27;
                           &#x27;    tr.startLocation = 0;\n&#x27;
                           &#x27;    tr.endLocation = mEntity.getFileSize();\n&#x27;
                           &#x27;    tr.key = mRecord.filePath;\n&#x27;
                           &#x27;    tr.blockLen = tr.endLocation;\n&#x27;
                           &#x27;    tr.isComplete = false;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理单线程的任务的记录\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleSingleThreadRecord() {\n&#x27;
                           &#x27;    File file = new File(mRecord.filePath);\n&#x27;
                           &#x27;    ThreadRecord tr = &#x27;
                           &#x27;mRecord.threadRecords.get(0);\n&#x27;
                           &#x27;    if (!file.exists()) {\n&#x27;
                           &#x27;      ALog.w(TAG, &#x27;
                           &#x27;String.format(&quot;文件【%s】不存在，任务将重新开始&quot;, &#x27;
                           &#x27;file.getPath()));\n&#x27;
                           &#x27;      tr.startLocation = 0;\n&#x27;
                           &#x27;      tr.isComplete = false;\n&#x27;
                           &#x27;      tr.endLocation = mEntity.getFileSize();\n&#x27;
                           &#x27;    } else if (mRecord.isOpenDynamicFile) {\n&#x27;
                           &#x27;      if (file.length() &gt; mEntity.getFileSize()) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;文件【%s】错误，任务重新开始&quot;, &#x27;
                           &#x27;file.getPath()));\n&#x27;
                           &#x27;        file.delete();\n&#x27;
                           &#x27;        tr.startLocation = 0;\n&#x27;
                           &#x27;        tr.isComplete = false;\n&#x27;
                           &#x27;        tr.endLocation = mEntity.getFileSize();\n&#x27;
                           &#x27;      } else if (file.length() == &#x27;
                           &#x27;mEntity.getFileSize()) {\n&#x27;
                           &#x27;        tr.isComplete = true;\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        if (file.length() != tr.startLocation) {\n&#x27;
                           &#x27;          ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;修正【%s】的进度记录为：%s&quot;, file.getPath(), &#x27;
                           &#x27;file.length()));\n&#x27;
                           &#x27;          tr.startLocation = file.length();\n&#x27;
                           &#x27;          tr.isComplete = false;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    mTaskWrapper.setNewTask(false);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * &#x27;
                           &#x27;处理分块任务的记录，分块文件（blockFileLen）长度必须需要小于等于线程区间（threadRectLen）的长度\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleBlockRecord() {\n&#x27;
                           &#x27;    // 默认线程分块长度\n&#x27;
                           &#x27;    long normalRectLen = mEntity.getFileSize() / &#x27;
                           &#x27;mRecord.threadRecords.size();\n&#x27;
                           &#x27;    for (ThreadRecord tr : mRecord.threadRecords) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      long threadRect = tr.blockLen;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      File temp = new File(String.format(SUB_PATH, &#x27;
                           &#x27;mRecord.filePath, tr.threadId));\n&#x27;
                           &#x27;      if (!temp.exists()) {\n&#x27;
                           &#x27;        ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;分块文件【%s】不存在，该分块将重新开始&quot;, &#x27;
                           &#x27;temp.getPath()));\n&#x27;
                           &#x27;        tr.isComplete = false;\n&#x27;
                           &#x27;        tr.startLocation = tr.threadId * &#x27;
                           &#x27;normalRectLen;\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        if (!tr.isComplete) {\n&#x27;
                           &#x27;          ALog.i(TAG, String.format(\n&#x27;
                           &#x27;              &quot;startLocation = %s; endLocation = &#x27;
                           &#x27;%s; block = %s; tempLen = %s; threadId = %s&quot;,\n&#x27;
                           &#x27;              tr.startLocation, tr.endLocation, &#x27;
                           &#x27;threadRect, temp.length(), tr.threadId));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;          long blockFileLen = temp.length(); // &#x27;
                           &#x27;磁盘中的分块文件长度\n&#x27;
                           &#x27;          /*\n&#x27;
                           &#x27;           * 检查磁盘中的分块文件\n&#x27;
                           &#x27;           */\n&#x27;
                           &#x27;          if (blockFileLen &gt; threadRect) {\n&#x27;
                           &#x27;            ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;分块【%s】错误，分块长度【%s】 &gt; &#x27;
                           &#x27;线程区间长度【%s】，将重新开始该分块&quot;,\n&#x27;
                           &#x27;                tr.threadId, blockFileLen, &#x27;
                           &#x27;threadRect));\n&#x27;
                           &#x27;            temp.delete();\n&#x27;
                           &#x27;            tr.startLocation = tr.threadId * &#x27;
                           &#x27;threadRect;\n&#x27;
                           &#x27;            continue;\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;          long realLocation =\n&#x27;
                           &#x27;              tr.threadId * normalRectLen + &#x27;
                           &#x27;blockFileLen; //正常情况下，该线程的startLocation的位置\n&#x27;
                           &#x27;          /*\n&#x27;
                           &#x27;           * 检查记录文件\n&#x27;
                           &#x27;           */\n&#x27;
                           &#x27;          if (blockFileLen == threadRect) {\n&#x27;
                           &#x27;            ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;分块【%s】已完成，更新记录&quot;, temp.getPath()));\n&#x27;
                           &#x27;            tr.startLocation = blockFileLen;\n&#x27;
                           &#x27;            tr.isComplete = true;\n&#x27;
                           &#x27;          } else if (tr.startLocation != &#x27;
                           &#x27;realLocation) { // 处理记录小于分块文件长度的情况\n&#x27;
                           &#x27;            ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;修正分块【%s】的进度记录为：%s&quot;, temp.getPath(), &#x27;
                           &#x27;realLocation));\n&#x27;
                           &#x27;            tr.startLocation = realLocation;\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          ALog.i(TAG, String.format(&quot;分块【%s】已完成&quot;, &#x27;
                           &#x27;temp.getPath()));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    mTaskWrapper.setNewTask(false);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * convertDb 是兼容性代码 从3.4.1开始，线程配置信息将存储在数据库中。 &#x27;
                           &#x27;将配置文件的内容复制到数据库中，并将配置文件删除\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void convertDb() {\n&#x27;
                           &#x27;    List&lt;RecordWrapper&gt; records =\n&#x27;
                           &#x27;        &#x27;
                           &#x27;DbEntity.findRelationData(RecordWrapper.class, &#x27;
                           &#x27;&quot;TaskRecord.filePath=?&quot;,\n&#x27;
                           &#x27;            getFilePath());\n&#x27;
                           &#x27;    if (records == null || records.size() == 0) {\n&#x27;
                           &#x27;      Properties pro = &#x27;
                           &#x27;CommonUtil.loadConfig(mConfigFile);\n&#x27;
                           &#x27;      if (pro.isEmpty()) {\n&#x27;
                           &#x27;        ALog.d(TAG, &quot;老版本的线程记录为空，任务为新任务&quot;);\n&#x27;
                           &#x27;        initRecord(true);\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      Set&lt;Object&gt; keys = pro.keySet();\n&#x27;
                           &#x27;      // &#x27;
                           &#x27;老版本记录是5s存一次，但是5s中内，如果线程执行完成，record记录是没有的，只有state记录...\n&#x27;
                           &#x27;      // 第一步应该是record 和 state去重取正确的线程数\n&#x27;
                           &#x27;      Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\n&#x27;
                           &#x27;      for (Object key : keys) {\n&#x27;
                           &#x27;        String str = String.valueOf(key);\n&#x27;
                           &#x27;        int i = &#x27;
                           &#x27;Integer.parseInt(str.substring(str.length() - &#x27;
                           &#x27;1));\n&#x27;
                           &#x27;        set.add(i);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      int threadNum = set.size();\n&#x27;
                           &#x27;      if (threadNum == 0) {\n&#x27;
                           &#x27;        ALog.d(TAG, &quot;线程数为空，任务为新任务&quot;);\n&#x27;
                           &#x27;        initRecord(true);\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mTaskWrapper.setNewTask(false);\n&#x27;
                           &#x27;      mRecord = createTaskRecord(threadNum);\n&#x27;
                           &#x27;      mRecord.isOpenDynamicFile = false;\n&#x27;
                           &#x27;      mRecord.isBlock = false;\n&#x27;
                           &#x27;      File tempFile = new File(getFilePath());\n&#x27;
                           &#x27;      for (int i = 0; i &lt; threadNum; i++) {\n&#x27;
                           &#x27;        ThreadRecord tRecord = new &#x27;
                           &#x27;ThreadRecord();\n&#x27;
                           &#x27;        tRecord.key = mRecord.filePath;\n&#x27;
                           &#x27;        Object state = &#x27;
                           &#x27;pro.getProperty(tempFile.getName() + STATE + i);\n&#x27;
                           &#x27;        Object record = &#x27;
                           &#x27;pro.getProperty(tempFile.getName() + RECORD + i);\n&#x27;
                           &#x27;        if (state != null &amp;&amp; &#x27;
                           &#x27;Integer.parseInt(String.valueOf(state)) == 1) {\n&#x27;
                           &#x27;          tRecord.isComplete = true;\n&#x27;
                           &#x27;          continue;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (record != null) {\n&#x27;
                           &#x27;          long temp = &#x27;
                           &#x27;Long.parseLong(String.valueOf(record));\n&#x27;
                           &#x27;          tRecord.startLocation = temp &gt; 0 ? temp &#x27;
                           &#x27;: 0;\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          tRecord.startLocation = 0;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        mRecord.threadRecords.add(tRecord);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mConfigFile.delete();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 初始化任务记录，分配线程区间\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param newRecord {@code true} 需要创建新{@link &#x27;
                           &#x27;TaskRecord}\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void initRecord(boolean newRecord) {\n&#x27;
                           &#x27;    if (newRecord) {\n&#x27;
                           &#x27;      mRecord = &#x27;
                           &#x27;createTaskRecord(getNewTaskThreadNum());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    mTaskWrapper.setNewTask(true);\n&#x27;
                           &#x27;    // 处理线程区间记录\n&#x27;
                           &#x27;    long blockSize = mEntity.getFileSize() / &#x27;
                           &#x27;mRecord.threadNum;\n&#x27;
                           &#x27;    for (int i = 0; i &lt; mRecord.threadNum; i++) {\n&#x27;
                           &#x27;      long startL = i * blockSize, endL = (i + 1) &#x27;
                           &#x27;* blockSize;\n&#x27;
                           &#x27;      ThreadRecord tr;\n&#x27;
                           &#x27;      tr = new ThreadRecord();\n&#x27;
                           &#x27;      tr.key = mRecord.filePath;\n&#x27;
                           &#x27;      tr.threadId = i;\n&#x27;
                           &#x27;      tr.startLocation = startL;\n&#x27;
                           &#x27;      //最后一个线程的结束位置即为文件的总长度\n&#x27;
                           &#x27;      if (i == (mRecord.threadNum - 1)) {\n&#x27;
                           &#x27;        endL = mEntity.getFileSize();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      tr.endLocation = endL;\n&#x27;
                           &#x27;      tr.blockLen = &#x27;
                           &#x27;CommonUtil.getBlockLen(mEntity.getFileSize(), i, &#x27;
                           &#x27;mRecord.threadNum);\n&#x27;
                           &#x27;      mRecord.threadRecords.add(tr);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 创建任务记录\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param threadNum 线程总数\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private TaskRecord createTaskRecord(int &#x27;
                           &#x27;threadNum) {\n&#x27;
                           &#x27;    TaskRecord record = new TaskRecord();\n&#x27;
                           &#x27;    record.fileName = mEntity.getFileName();\n&#x27;
                           &#x27;    record.filePath = getFilePath();\n&#x27;
                           &#x27;    record.threadRecords = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;    record.threadNum = threadNum;\n&#x27;
                           &#x27;    // 处理分块和动态文件参数\n&#x27;
                           &#x27;    if (getRecordType() == TYPE_DOWNLOAD) {\n&#x27;
                           &#x27;      record.isBlock = threadNum &gt; 1 &amp;&amp; &#x27;
                           &#x27;Configuration.getInstance().downloadCfg.isUseBlock();\n&#x27;
                           &#x27;      // 线程数为1，或者使用了分块，则认为是使用动态长度文件\n&#x27;
                           &#x27;      record.isOpenDynamicFile = threadNum == 1 || &#x27;
                           &#x27;record.isBlock;\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      record.isBlock = false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    record.isGroupRecord = &#x27;
                           &#x27;mEntity.isGroupChild();\n&#x27;
                           &#x27;    if (record.isGroupRecord) {\n&#x27;
                           &#x27;      if (mEntity instanceof DownloadEntity) {\n&#x27;
                           &#x27;        record.dGroupHash = ((DownloadEntity) &#x27;
                           &#x27;mEntity).getGroupHash();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    return record;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 保存任务记录\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void saveRecord() {\n&#x27;
                           &#x27;    mRecord.threadNum = &#x27;
                           &#x27;mRecord.threadRecords.size();\n&#x27;
                           &#x27;    mRecord.save();\n&#x27;
                           &#x27;    DbEntity.saveAll(mRecord.threadRecords);\n&#x27;
                           &#x27;    ALog.d(TAG, String.format(&quot;保存记录，线程记录数：%s&quot;, &#x27;
                           &#x27;mRecord.threadRecords.size()));\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 获取记录类型\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return {@link #TYPE_DOWNLOAD}、{@link &#x27;
                           &#x27;#TYPE_UPLOAD}\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private int getRecordType() {\n&#x27;
                           &#x27;    if (mEntity instanceof DownloadEntity) {\n&#x27;
                           &#x27;      return TYPE_DOWNLOAD;\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      return TYPE_UPLOAD;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 获取任务路径\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return 任务文件路径\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private String getFilePath() {\n&#x27;
                           &#x27;    if (mEntity instanceof DownloadEntity) {\n&#x27;
                           &#x27;      return ((DownloadEntity) &#x27;
                           &#x27;mTaskWrapper.getEntity()).getFilePath();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      return ((UploadEntity) &#x27;
                           &#x27;mTaskWrapper.getEntity()).getFilePath();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 小于1m的文件或是任务组的子任务、线程数强制为1\n&#x27;
                           &#x27;   * 不支持断点或chunked模式的线程数都为，线程数强制为1\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private int getNewTaskThreadNum() {\n&#x27;
                           &#x27;    if (getRecordType() == TYPE_DOWNLOAD) {\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;import com.arialyy.aria.core.download.DTaskWrapper;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.arialyy.aria.core.download.DownloadEntity;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.arialyy.aria.core.download.m3u8.M3U8FileLoader;\n&#x27;
                         &#x27;import com.arialyy.aria.core.inf.AbsNormalEntity;\n&#x27;
                         &#x27;import com.arialyy.aria.core.inf.AbsTaskWrapper;\n&#x27;
                         &#x27;import com.arialyy.aria.core.inf.ITaskWrapper;\n&#x27;
                         &#x27;import com.arialyy.aria.core.upload.UploadEntity;\n&#x27;
                         &#x27;import com.arialyy.aria.orm.DbEntity;\n&#x27;
                         &#x27;import com.arialyy.aria.util.ALog;\n&#x27;
                         &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                         &#x27;import com.arialyy.aria.util.DbDataHelper;\n&#x27;
                         &#x27;import java.io.File;\n&#x27;
                         &#x27;import java.util.ArrayList;\n&#x27;
                         &#x27;import java.util.HashSet;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Properties;\n&#x27;
                         &#x27;import java.util.Set;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * 处理任务记录，分配线程区间\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public class RecordHandler {\n&#x27;
                         &#x27;  private final String TAG = &quot;RecordHandler&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  public static final int TYPE_DOWNLOAD = 1;\n&#x27;
                         &#x27;  public static final int TYPE_UPLOAD = 2;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private static final String STATE = &quot;_state_&quot;;\n&#x27;
                         &#x27;  private static final String RECORD = &quot;_record_&quot;;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 小于1m的文件不启用多线程\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private static final long SUB_LEN = 1024 * 1024;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 分块文件路径\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public static final String SUB_PATH = &#x27;
                         &#x27;&quot;%s.%s.part&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Deprecated private File mConfigFile;\n&#x27;
                         &#x27;  private TaskRecord mRecord;\n&#x27;
                         &#x27;  private AbsTaskWrapper mTaskWrapper;\n&#x27;
                         &#x27;  private AbsNormalEntity mEntity;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  RecordHandler(AbsTaskWrapper wrapper) {\n&#x27;
                         &#x27;    mTaskWrapper = wrapper;\n&#x27;
                         &#x27;    mEntity = (AbsNormalEntity) &#x27;
                         &#x27;mTaskWrapper.getEntity();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取任务记录，如果任务记录存在，检查任务记录\n&#x27;
                         &#x27;   * 检查记录 对于分块任务： 子分块不存在或被删除，子线程将重新下载\n&#x27;
                         &#x27;   * 对于普通任务： 预下载文件不存在，则任务任务呗删除\n&#x27;
                         &#x27;   * 如果任务记录不存在或线程记录不存在，初始化记录\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @return 任务记录\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  TaskRecord getRecord() {\n&#x27;
                         &#x27;    mConfigFile = new &#x27;
                         &#x27;File(CommonUtil.getFileConfigPath(false, &#x27;
                         &#x27;mEntity.getFileName()));\n&#x27;
                         &#x27;    if (mConfigFile.exists()) {\n&#x27;
                         &#x27;      convertDb();\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      mRecord = &#x27;
                         &#x27;DbDataHelper.getTaskRecord(getFilePath());\n&#x27;
                         &#x27;      if (mRecord == null) {\n&#x27;
                         &#x27;        initRecord(true);\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        if (mRecord.threadRecords == null || &#x27;
                         &#x27;mRecord.threadRecords.isEmpty()) {\n&#x27;
                         &#x27;          initRecord(false);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if (mTaskWrapper.getRequestType() == &#x27;
                         &#x27;ITaskWrapper.M3U8_FILE) {\n&#x27;
                         &#x27;          handleM3U8Record();\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          if (mRecord.isBlock) {\n&#x27;
                         &#x27;            handleBlockRecord();\n&#x27;
                         &#x27;          } else if (!mTaskWrapper.isSupportBP()) {\n&#x27;
                         &#x27;            handleNoSupportBPRecord();\n&#x27;
                         &#x27;          } else {\n&#x27;
                         &#x27;            handleSingleThreadRecord();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    saveRecord();\n&#x27;
                         &#x27;    return mRecord;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理m3u8记录，\n&#x27;
                         &#x27;   * 1、如果分片文件存在，并且分片文件的记录没有完成，则需要删除该分片文件\n&#x27;
                         &#x27;   * 2、如果记录显示已完成，但是分片文件不存在，则重新开始该分片\n&#x27;
                         &#x27;   * 3、如果记录显示已完成，并且文件存在，记录当前任务进度\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleM3U8Record() {\n&#x27;
                         &#x27;    DTaskWrapper wrapper = (DTaskWrapper) &#x27;
                         &#x27;mTaskWrapper;\n&#x27;
                         &#x27;    String cacheDir = &#x27;
                         &#x27;wrapper.asM3U8().getCacheDir();\n&#x27;
                         &#x27;    long currentProgress = 0;\n&#x27;
                         &#x27;    for (ThreadRecord record : &#x27;
                         &#x27;mRecord.threadRecords) {\n&#x27;
                         &#x27;      File temp = new &#x27;
                         &#x27;File(M3U8FileLoader.getTsFilePath(cacheDir, &#x27;
                         &#x27;record.threadId));\n&#x27;
                         &#x27;      if (!record.isComplete) {\n&#x27;
                         &#x27;        if (temp.exists()) {\n&#x27;
                         &#x27;          temp.delete();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        record.startLocation = 0;\n&#x27;
                         &#x27;        ALog.d(TAG, &#x27;
                         &#x27;String.format(&quot;分片【%s】未完成，将重新下载该分片&quot;, &#x27;
                         &#x27;record.threadId));\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        if (!temp.exists()) {\n&#x27;
                         &#x27;          record.startLocation = 0;\n&#x27;
                         &#x27;          record.isComplete = false;\n&#x27;
                         &#x27;          ALog.w(TAG, &#x27;
                         &#x27;String.format(&quot;分片【%s】不存在，将重新下载该分片&quot;, &#x27;
                         &#x27;record.threadId));\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          currentProgress += temp.length();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    &#x27;
                         &#x27;wrapper.getEntity().setCurrentProgress(currentProgress);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理不支持断点的记录\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleNoSupportBPRecord() {\n&#x27;
                         &#x27;    ThreadRecord tr = mRecord.threadRecords.get(0);\n&#x27;
                         &#x27;    tr.startLocation = 0;\n&#x27;
                         &#x27;    tr.endLocation = mEntity.getFileSize();\n&#x27;
                         &#x27;    tr.key = mRecord.filePath;\n&#x27;
                         &#x27;    tr.blockLen = tr.endLocation;\n&#x27;
                         &#x27;    tr.isComplete = false;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理单线程的任务的记录\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleSingleThreadRecord() {\n&#x27;
                         &#x27;    File file = new File(mRecord.filePath);\n&#x27;
                         &#x27;    ThreadRecord tr = mRecord.threadRecords.get(0);\n&#x27;
                         &#x27;    if (!file.exists()) {\n&#x27;
                         &#x27;      ALog.w(TAG, String.format(&quot;文件【%s】不存在，任务将重新开始&quot;, &#x27;
                         &#x27;file.getPath()));\n&#x27;
                         &#x27;      tr.startLocation = 0;\n&#x27;
                         &#x27;      tr.isComplete = false;\n&#x27;
                         &#x27;      tr.endLocation = mEntity.getFileSize();\n&#x27;
                         &#x27;    } else if (mRecord.isOpenDynamicFile) {\n&#x27;
                         &#x27;      if (file.length() &gt; mEntity.getFileSize()) {\n&#x27;
                         &#x27;        ALog.i(TAG, String.format(&quot;文件【%s】错误，任务重新开始&quot;, &#x27;
                         &#x27;file.getPath()));\n&#x27;
                         &#x27;        file.delete();\n&#x27;
                         &#x27;        tr.startLocation = 0;\n&#x27;
                         &#x27;        tr.isComplete = false;\n&#x27;
                         &#x27;        tr.endLocation = mEntity.getFileSize();\n&#x27;
                         &#x27;      } else if (file.length() == &#x27;
                         &#x27;mEntity.getFileSize()) {\n&#x27;
                         &#x27;        tr.isComplete = true;\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        if (file.length() != tr.startLocation) {\n&#x27;
                         &#x27;          ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;修正【%s】的进度记录为：%s&quot;, file.getPath(), &#x27;
                         &#x27;file.length()));\n&#x27;
                         &#x27;          tr.startLocation = file.length();\n&#x27;
                         &#x27;          tr.isComplete = false;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    mTaskWrapper.setNewTask(false);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * &#x27;
                         &#x27;处理分块任务的记录，分块文件（blockFileLen）长度必须需要小于等于线程区间（threadRectLen）的长度\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleBlockRecord() {\n&#x27;
                         &#x27;    // 默认线程分块长度\n&#x27;
                         &#x27;    long normalRectLen = mEntity.getFileSize() / &#x27;
                         &#x27;mRecord.threadRecords.size();\n&#x27;
                         &#x27;    for (ThreadRecord tr : mRecord.threadRecords) {\n&#x27;
                         &#x27;      long threadRect = tr.blockLen;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;      File temp = new File(String.format(SUB_PATH, &#x27;
                         &#x27;mRecord.filePath, tr.threadId));\n&#x27;
                         &#x27;      if (!temp.exists()) {\n&#x27;
                         &#x27;        ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;分块文件【%s】不存在，该分块将重新开始&quot;, &#x27;
                         &#x27;temp.getPath()));\n&#x27;
                         &#x27;        tr.isComplete = false;\n&#x27;
                         &#x27;        tr.startLocation = tr.threadId * &#x27;
                         &#x27;normalRectLen;\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        if (!tr.isComplete) {\n&#x27;
                         &#x27;          ALog.i(TAG, String.format(\n&#x27;
                         &#x27;              &quot;startLocation = %s; endLocation = %s; &#x27;
                         &#x27;block = %s; tempLen = %s; threadId = %s&quot;,\n&#x27;
                         &#x27;              tr.startLocation, tr.endLocation, &#x27;
                         &#x27;threadRect, temp.length(), tr.threadId));\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;          long blockFileLen = temp.length(); // &#x27;
                         &#x27;磁盘中的分块文件长度\n&#x27;
                         &#x27;          /*\n&#x27;
                         &#x27;           * 检查磁盘中的分块文件\n&#x27;
                         &#x27;           */\n&#x27;
                         &#x27;          if (blockFileLen &gt; threadRect) {\n&#x27;
                         &#x27;            ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;分块【%s】错误，分块长度【%s】 &gt; &#x27;
                         &#x27;线程区间长度【%s】，将重新开始该分块&quot;,\n&#x27;
                         &#x27;                tr.threadId, blockFileLen, &#x27;
                         &#x27;threadRect));\n&#x27;
                         &#x27;            temp.delete();\n&#x27;
                         &#x27;            tr.startLocation = tr.threadId * &#x27;
                         &#x27;threadRect;\n&#x27;
                         &#x27;            continue;\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;          long realLocation =\n&#x27;
                         &#x27;              tr.threadId * normalRectLen + &#x27;
                         &#x27;blockFileLen; //正常情况下，该线程的startLocation的位置\n&#x27;
                         &#x27;          /*\n&#x27;
                         &#x27;           * 检查记录文件\n&#x27;
                         &#x27;           */\n&#x27;
                         &#x27;          if (blockFileLen == threadRect) {\n&#x27;
                         &#x27;            ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;分块【%s】已完成，更新记录&quot;, temp.getPath()));\n&#x27;
                         &#x27;            tr.startLocation = blockFileLen;\n&#x27;
                         &#x27;            tr.isComplete = true;\n&#x27;
                         &#x27;          } else if (tr.startLocation != &#x27;
                         &#x27;realLocation) { // 处理记录小于分块文件长度的情况\n&#x27;
                         &#x27;            ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;修正分块【%s】的进度记录为：%s&quot;, temp.getPath(), &#x27;
                         &#x27;realLocation));\n&#x27;
                         &#x27;            tr.startLocation = realLocation;\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          ALog.i(TAG, String.format(&quot;分块【%s】已完成&quot;, &#x27;
                         &#x27;temp.getPath()));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    mTaskWrapper.setNewTask(false);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * convertDb 是兼容性代码 从3.4.1开始，线程配置信息将存储在数据库中。 &#x27;
                         &#x27;将配置文件的内容复制到数据库中，并将配置文件删除\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void convertDb() {\n&#x27;
                         &#x27;    List&lt;RecordWrapper&gt; records =\n&#x27;
                         &#x27;        &#x27;
                         &#x27;DbEntity.findRelationData(RecordWrapper.class, &#x27;
                         &#x27;&quot;TaskRecord.filePath=?&quot;,\n&#x27;
                         &#x27;            getFilePath());\n&#x27;
                         &#x27;    if (records == null || records.size() == 0) {\n&#x27;
                         &#x27;      Properties pro = &#x27;
                         &#x27;CommonUtil.loadConfig(mConfigFile);\n&#x27;
                         &#x27;      if (pro.isEmpty()) {\n&#x27;
                         &#x27;        ALog.d(TAG, &quot;老版本的线程记录为空，任务为新任务&quot;);\n&#x27;
                         &#x27;        initRecord(true);\n&#x27;
                         &#x27;        return;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;      Set&lt;Object&gt; keys = pro.keySet();\n&#x27;
                         &#x27;      // &#x27;
                         &#x27;老版本记录是5s存一次，但是5s中内，如果线程执行完成，record记录是没有的，只有state记录...\n&#x27;
                         &#x27;      // 第一步应该是record 和 state去重取正确的线程数\n&#x27;
                         &#x27;      Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\n&#x27;
                         &#x27;      for (Object key : keys) {\n&#x27;
                         &#x27;        String str = String.valueOf(key);\n&#x27;
                         &#x27;        int i = &#x27;
                         &#x27;Integer.parseInt(str.substring(str.length() - 1));\n&#x27;
                         &#x27;        set.add(i);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      int threadNum = set.size();\n&#x27;
                         &#x27;      if (threadNum == 0) {\n&#x27;
                         &#x27;        ALog.d(TAG, &quot;线程数为空，任务为新任务&quot;);\n&#x27;
                         &#x27;        initRecord(true);\n&#x27;
                         &#x27;        return;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      mTaskWrapper.setNewTask(false);\n&#x27;
                         &#x27;      mRecord = createTaskRecord(threadNum);\n&#x27;
                         &#x27;      mRecord.isOpenDynamicFile = false;\n&#x27;
                         &#x27;      mRecord.isBlock = false;\n&#x27;
                         &#x27;      File tempFile = new File(getFilePath());\n&#x27;
                         &#x27;      for (int i = 0; i &lt; threadNum; i++) {\n&#x27;
                         &#x27;        ThreadRecord tRecord = new ThreadRecord();\n&#x27;
                         &#x27;        tRecord.key = mRecord.filePath;\n&#x27;
                         &#x27;        Object state = &#x27;
                         &#x27;pro.getProperty(tempFile.getName() + STATE + i);\n&#x27;
                         &#x27;        Object record = &#x27;
                         &#x27;pro.getProperty(tempFile.getName() + RECORD + i);\n&#x27;
                         &#x27;        if (state != null &amp;&amp; &#x27;
                         &#x27;Integer.parseInt(String.valueOf(state)) == 1) {\n&#x27;
                         &#x27;          tRecord.isComplete = true;\n&#x27;
                         &#x27;          continue;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (record != null) {\n&#x27;
                         &#x27;          long temp = &#x27;
                         &#x27;Long.parseLong(String.valueOf(record));\n&#x27;
                         &#x27;          tRecord.startLocation = temp &gt; 0 ? temp : &#x27;
                         &#x27;0;\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          tRecord.startLocation = 0;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        mRecord.threadRecords.add(tRecord);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      mConfigFile.delete();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 初始化任务记录，分配线程区间\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @param newRecord {@code true} 需要创建新{@link &#x27;
                         &#x27;TaskRecord}\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void initRecord(boolean newRecord) {\n&#x27;
                         &#x27;    if (newRecord) {\n&#x27;
                         &#x27;      mRecord = &#x27;
                         &#x27;createTaskRecord(getNewTaskThreadNum());\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    mTaskWrapper.setNewTask(true);\n&#x27;
                         &#x27;    // 处理线程区间记录\n&#x27;
                         &#x27;    int requestType = &#x27;
                         &#x27;mTaskWrapper.getRequestType();\n&#x27;
                         &#x27;    long blockSize = mEntity.getFileSize() / &#x27;
                         &#x27;mRecord.threadNum;\n&#x27;
                         &#x27;    for (int i = 0; i &lt; mRecord.threadNum; i++) {\n&#x27;
                         &#x27;      long startL = i * blockSize, endL = (i + 1) * &#x27;
                         &#x27;blockSize;\n&#x27;
                         &#x27;      ThreadRecord tr;\n&#x27;
                         &#x27;      tr = new ThreadRecord();\n&#x27;
                         &#x27;      tr.key = mRecord.filePath;\n&#x27;
                         &#x27;      tr.threadId = i;\n&#x27;
                         &#x27;      tr.startLocation = startL;\n&#x27;
                         &#x27;      tr.isComplete = false;\n&#x27;
                         &#x27;      if (requestType == ITaskWrapper.M3U8_FILE) {\n&#x27;
                         &#x27;        tr.startLocation = 0;\n&#x27;
                         &#x27;        tr.threadType = TaskRecord.TYPE_M3U8;\n&#x27;
                         &#x27;        tr.m3u8url = ((DTaskWrapper) &#x27;
                         &#x27;mTaskWrapper).asM3U8().getUrls().get(i);\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        tr.threadType = TaskRecord.TYPE_HTTP_FTP;\n&#x27;
                         &#x27;        //最后一个线程的结束位置即为文件的总长度\n&#x27;
                         &#x27;        if (i == (mRecord.threadNum - 1)) {\n&#x27;
                         &#x27;          endL = mEntity.getFileSize();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        tr.endLocation = endL;\n&#x27;
                         &#x27;        tr.blockLen = &#x27;
                         &#x27;CommonUtil.getBlockLen(mEntity.getFileSize(), i, &#x27;
                         &#x27;mRecord.threadNum);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      mRecord.threadRecords.add(tr);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 创建任务记录\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @param threadNum 线程总数\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private TaskRecord createTaskRecord(int threadNum) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;    TaskRecord record = new TaskRecord();\n&#x27;
                         &#x27;    record.fileName = mEntity.getFileName();\n&#x27;
                         &#x27;    record.filePath = getFilePath();\n&#x27;
                         &#x27;    record.threadRecords = new ArrayList&lt;&gt;();\n&#x27;
                         &#x27;    record.threadNum = threadNum;\n&#x27;
                         &#x27;    // 处理分块和动态文件参数\n&#x27;
                         &#x27;    if (getRecordType() == TYPE_DOWNLOAD) {\n&#x27;
                         &#x27;      record.isBlock = threadNum &gt; 1 &amp;&amp; &#x27;
                         &#x27;Configuration.getInstance().downloadCfg.isUseBlock();\n&#x27;
                         &#x27;      // 线程数为1，或者使用了分块，则认为是使用动态长度文件\n&#x27;
                         &#x27;      record.isOpenDynamicFile = threadNum == 1 || &#x27;
                         &#x27;record.isBlock;\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      record.isBlock = false;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    if (mTaskWrapper.getRequestType() == &#x27;
                         &#x27;ITaskWrapper.M3U8_FILE) {\n&#x27;
                         &#x27;      record.taskType = TaskRecord.TYPE_M3U8;\n&#x27;
                         &#x27;      record.isOpenDynamicFile = true;\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      record.taskType = TaskRecord.TYPE_HTTP_FTP;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    record.isGroupRecord = mEntity.isGroupChild();\n&#x27;
                         &#x27;    if (record.isGroupRecord) {\n&#x27;
                         &#x27;      if (mEntity instanceof DownloadEntity) {\n&#x27;
                         &#x27;        record.dGroupHash = ((DownloadEntity) &#x27;
                         &#x27;mEntity).getGroupHash();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    return record;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 保存任务记录\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void saveRecord() {\n&#x27;
                         &#x27;    mRecord.threadNum = &#x27;
                         &#x27;mRecord.threadRecords.size();\n&#x27;
                         &#x27;    mRecord.save();\n&#x27;
                         &#x27;    DbEntity.saveAll(mRecord.threadRecords);\n&#x27;
                         &#x27;    ALog.d(TAG, String.format(&quot;保存记录，线程记录数：%s&quot;, &#x27;
                         &#x27;mRecord.threadRecords.size()));\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取记录类型\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @return {@link #TYPE_DOWNLOAD}、{@link &#x27;
                         &#x27;#TYPE_UPLOAD}\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private int getRecordType() {\n&#x27;
                         &#x27;    if (mEntity instanceof DownloadEntity) {\n&#x27;
                         &#x27;      return TYPE_DOWNLOAD;\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      return TYPE_UPLOAD;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取任务路径\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @return 任务文件路径\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private String getFilePath() {\n&#x27;
                         &#x27;    if (mEntity instanceof DownloadEntity) {\n&#x27;
                         &#x27;      return ((DownloadEntity) &#x27;
                         &#x27;mTaskWrapper.getEntity()).getFilePath();\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      return ((UploadEntity) &#x27;
                         &#x27;mTaskWrapper.getEntity()).getFilePath();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 小于1m的文件或是任务组的子任务、线程数强制为1\n&#x27;
                         &#x27;   * 不支持断点或chunked模式的线程数都为，线程数强制为1\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private int getNewTaskThreadNum() {\n&#x27;
                         &#x27;    if (getRecordType() == TYPE_DOWNLOAD) {\n&#x27;
                         &#x27;      if (mTaskWrapper.getRequestType() == &#x27;
                         &#x27;ITaskWrapper.M3U8_FILE) {\n&#x27;
                         &#x27;        return ((DTaskWrapper) &#x27;
                         &#x27;mTaskWrapper).asM3U8().getUrls().size();\n&#x27;
                         &#x27;      }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.DownloadEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.core.inf.AbsNormalEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.core.inf.AbsTaskWrapper;\n&#x27;
                           &#x27;import com.arialyy.aria.core.upload.UploadEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.orm.DbEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.util.ALog;\n&#x27;
                           &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                           &#x27;import com.arialyy.aria.util.DbDataHelper;\n&#x27;
                           &#x27;import java.io.File;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;import java.util.HashSet;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;import java.util.Properties;\n&#x27;
                           &#x27;import java.util.Set;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * 处理任务记录，分配线程区间\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class RecordHandler {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  public static final int TYPE_DOWNLOAD = 1;\n&#x27;
                           &#x27;  public static final int TYPE_UPLOAD = 2;\n&#x27;
                           &#x27;  private final String TAG = &quot;RecordHandler&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private static final String STATE = &quot;_state_&quot;;\n&#x27;
                           &#x27;  private static final String RECORD = &#x27;
                           &#x27;&quot;_record_&quot;;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 小于1m的文件不启用多线程\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private static final long SUB_LEN = 1024 * &#x27;
                           &#x27;1024;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 分块文件路径\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public static final String SUB_PATH = &#x27;
                           &#x27;&quot;%s.%s.part&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Deprecated private File mConfigFile;\n&#x27;
                           &#x27;  private TaskRecord mRecord;\n&#x27;
                           &#x27;  private AbsTaskWrapper mTaskWrapper;\n&#x27;
                           &#x27;  private AbsNormalEntity mEntity;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  RecordHandler(AbsTaskWrapper wrapper) {\n&#x27;
                           &#x27;    mTaskWrapper = wrapper;\n&#x27;
                           &#x27;    mEntity = (AbsNormalEntity) &#x27;
                           &#x27;mTaskWrapper.getEntity();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 获取任务记录，如果任务记录存在，检查任务记录\n&#x27;
                           &#x27;   * 检查记录 对于分块任务： 子分块不存在或被删除，子线程将重新下载\n&#x27;
                           &#x27;   * 对于普通任务： 预下载文件不存在，则任务任务呗删除\n&#x27;
                           &#x27;   * 如果任务记录不存在或线程记录不存在，初始化记录\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return 任务记录\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  TaskRecord getRecord() {\n&#x27;
                           &#x27;    mConfigFile = new &#x27;
                           &#x27;File(CommonUtil.getFileConfigPath(false, &#x27;
                           &#x27;mEntity.getFileName()));\n&#x27;
                           &#x27;    if (mConfigFile.exists()) {\n&#x27;
                           &#x27;      convertDb();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      mRecord = &#x27;
                           &#x27;DbDataHelper.getTaskRecord(getFilePath());\n&#x27;
                           &#x27;      if (mRecord == null) {\n&#x27;
                           &#x27;        initRecord(true);\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        if (mRecord.threadRecords == null || &#x27;
                           &#x27;mRecord.threadRecords.isEmpty()) {\n&#x27;
                           &#x27;          initRecord(false);\n&#x27;
                           &#x27;        } else if (mRecord.isBlock) {\n&#x27;
                           &#x27;          handleBlockRecord();\n&#x27;
                           &#x27;        } else if (!mTaskWrapper.isSupportBP()) {\n&#x27;
                           &#x27;          handleNoSupportBPRecord();\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          handleSingleThreadRecord();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    saveRecord();\n&#x27;
                           &#x27;    return mRecord;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理不支持断点的记录\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleNoSupportBPRecord() {\n&#x27;
                           &#x27;    ThreadRecord tr = &#x27;
                           &#x27;mRecord.threadRecords.get(0);\n&#x27;
                           &#x27;    tr.startLocation = 0;\n&#x27;
                           &#x27;    tr.endLocation = mEntity.getFileSize();\n&#x27;
                           &#x27;    tr.key = mRecord.filePath;\n&#x27;
                           &#x27;    tr.blockLen = tr.endLocation;\n&#x27;
                           &#x27;    tr.isComplete = false;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理单线程的任务的记录\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleSingleThreadRecord() {\n&#x27;
                           &#x27;    File file = new File(mRecord.filePath);\n&#x27;
                           &#x27;    ThreadRecord tr = &#x27;
                           &#x27;mRecord.threadRecords.get(0);\n&#x27;
                           &#x27;    if (!file.exists()) {\n&#x27;
                           &#x27;      ALog.w(TAG, &#x27;
                           &#x27;String.format(&quot;文件【%s】不存在，任务将重新开始&quot;, &#x27;
                           &#x27;file.getPath()));\n&#x27;
                           &#x27;      tr.startLocation = 0;\n&#x27;
                           &#x27;      tr.isComplete = false;\n&#x27;
                           &#x27;      tr.endLocation = mEntity.getFileSize();\n&#x27;
                           &#x27;    } else if (mRecord.isOpenDynamicFile) {\n&#x27;
                           &#x27;      if (file.length() &gt; mEntity.getFileSize()) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;文件【%s】错误，任务重新开始&quot;, &#x27;
                           &#x27;file.getPath()));\n&#x27;
                           &#x27;        file.delete();\n&#x27;
                           &#x27;        tr.startLocation = 0;\n&#x27;
                           &#x27;        tr.isComplete = false;\n&#x27;
                           &#x27;        tr.endLocation = mEntity.getFileSize();\n&#x27;
                           &#x27;      } else if (file.length() == &#x27;
                           &#x27;mEntity.getFileSize()) {\n&#x27;
                           &#x27;        tr.isComplete = true;\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        if (file.length() != tr.startLocation) {\n&#x27;
                           &#x27;          ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;修正【%s】的进度记录为：%s&quot;, file.getPath(), &#x27;
                           &#x27;file.length()));\n&#x27;
                           &#x27;          tr.startLocation = file.length();\n&#x27;
                           &#x27;          tr.isComplete = false;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    mTaskWrapper.setNewTask(false);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * &#x27;
                           &#x27;处理分块任务的记录，分块文件（blockFileLen）长度必须需要小于等于线程区间（threadRectLen）的长度\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleBlockRecord() {\n&#x27;
                           &#x27;    // 默认线程分块长度\n&#x27;
                           &#x27;    long normalRectLen = mEntity.getFileSize() / &#x27;
                           &#x27;mRecord.threadRecords.size();\n&#x27;
                           &#x27;    for (ThreadRecord tr : mRecord.threadRecords) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      long threadRect = tr.blockLen;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      File temp = new File(String.format(SUB_PATH, &#x27;
                           &#x27;mRecord.filePath, tr.threadId));\n&#x27;
                           &#x27;      if (!temp.exists()) {\n&#x27;
                           &#x27;        ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;分块文件【%s】不存在，该分块将重新开始&quot;, &#x27;
                           &#x27;temp.getPath()));\n&#x27;
                           &#x27;        tr.isComplete = false;\n&#x27;
                           &#x27;        tr.startLocation = tr.threadId * &#x27;
                           &#x27;normalRectLen;\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        if (!tr.isComplete) {\n&#x27;
                           &#x27;          ALog.i(TAG, String.format(\n&#x27;
                           &#x27;              &quot;startLocation = %s; endLocation = &#x27;
                           &#x27;%s; block = %s; tempLen = %s; threadId = %s&quot;,\n&#x27;
                           &#x27;              tr.startLocation, tr.endLocation, &#x27;
                           &#x27;threadRect, temp.length(), tr.threadId));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;          long blockFileLen = temp.length(); // &#x27;
                           &#x27;磁盘中的分块文件长度\n&#x27;
                           &#x27;          /*\n&#x27;
                           &#x27;           * 检查磁盘中的分块文件\n&#x27;
                           &#x27;           */\n&#x27;
                           &#x27;          if (blockFileLen &gt; threadRect) {\n&#x27;
                           &#x27;            ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;分块【%s】错误，分块长度【%s】 &gt; &#x27;
                           &#x27;线程区间长度【%s】，将重新开始该分块&quot;,\n&#x27;
                           &#x27;                tr.threadId, blockFileLen, &#x27;
                           &#x27;threadRect));\n&#x27;
                           &#x27;            temp.delete();\n&#x27;
                           &#x27;            tr.startLocation = tr.threadId * &#x27;
                           &#x27;threadRect;\n&#x27;
                           &#x27;            continue;\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;          long realLocation =\n&#x27;
                           &#x27;              tr.threadId * normalRectLen + &#x27;
                           &#x27;blockFileLen; //正常情况下，该线程的startLocation的位置\n&#x27;
                           &#x27;          /*\n&#x27;
                           &#x27;           * 检查记录文件\n&#x27;
                           &#x27;           */\n&#x27;
                           &#x27;          if (blockFileLen == threadRect) {\n&#x27;
                           &#x27;            ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;分块【%s】已完成，更新记录&quot;, temp.getPath()));\n&#x27;
                           &#x27;            tr.startLocation = blockFileLen;\n&#x27;
                           &#x27;            tr.isComplete = true;\n&#x27;
                           &#x27;          } else if (tr.startLocation != &#x27;
                           &#x27;realLocation) { // 处理记录小于分块文件长度的情况\n&#x27;
                           &#x27;            ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;修正分块【%s】的进度记录为：%s&quot;, temp.getPath(), &#x27;
                           &#x27;realLocation));\n&#x27;
                           &#x27;            tr.startLocation = realLocation;\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          ALog.i(TAG, String.format(&quot;分块【%s】已完成&quot;, &#x27;
                           &#x27;temp.getPath()));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    mTaskWrapper.setNewTask(false);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * convertDb 是兼容性代码 从3.4.1开始，线程配置信息将存储在数据库中。 &#x27;
                           &#x27;将配置文件的内容复制到数据库中，并将配置文件删除\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void convertDb() {\n&#x27;
                           &#x27;    List&lt;RecordWrapper&gt; records =\n&#x27;
                           &#x27;        &#x27;
                           &#x27;DbEntity.findRelationData(RecordWrapper.class, &#x27;
                           &#x27;&quot;TaskRecord.filePath=?&quot;,\n&#x27;
                           &#x27;            getFilePath());\n&#x27;
                           &#x27;    if (records == null || records.size() == 0) {\n&#x27;
                           &#x27;      Properties pro = &#x27;
                           &#x27;CommonUtil.loadConfig(mConfigFile);\n&#x27;
                           &#x27;      if (pro.isEmpty()) {\n&#x27;
                           &#x27;        ALog.d(TAG, &quot;老版本的线程记录为空，任务为新任务&quot;);\n&#x27;
                           &#x27;        initRecord(true);\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      Set&lt;Object&gt; keys = pro.keySet();\n&#x27;
                           &#x27;      // &#x27;
                           &#x27;老版本记录是5s存一次，但是5s中内，如果线程执行完成，record记录是没有的，只有state记录...\n&#x27;
                           &#x27;      // 第一步应该是record 和 state去重取正确的线程数\n&#x27;
                           &#x27;      Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\n&#x27;
                           &#x27;      for (Object key : keys) {\n&#x27;
                           &#x27;        String str = String.valueOf(key);\n&#x27;
                           &#x27;        int i = &#x27;
                           &#x27;Integer.parseInt(str.substring(str.length() - &#x27;
                           &#x27;1));\n&#x27;
                           &#x27;        set.add(i);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      int threadNum = set.size();\n&#x27;
                           &#x27;      if (threadNum == 0) {\n&#x27;
                           &#x27;        ALog.d(TAG, &quot;线程数为空，任务为新任务&quot;);\n&#x27;
                           &#x27;        initRecord(true);\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mTaskWrapper.setNewTask(false);\n&#x27;
                           &#x27;      mRecord = createTaskRecord(threadNum);\n&#x27;
                           &#x27;      mRecord.isOpenDynamicFile = false;\n&#x27;
                           &#x27;      mRecord.isBlock = false;\n&#x27;
                           &#x27;      File tempFile = new File(getFilePath());\n&#x27;
                           &#x27;      for (int i = 0; i &lt; threadNum; i++) {\n&#x27;
                           &#x27;        ThreadRecord tRecord = new &#x27;
                           &#x27;ThreadRecord();\n&#x27;
                           &#x27;        tRecord.key = mRecord.filePath;\n&#x27;
                           &#x27;        Object state = &#x27;
                           &#x27;pro.getProperty(tempFile.getName() + STATE + i);\n&#x27;
                           &#x27;        Object record = &#x27;
                           &#x27;pro.getProperty(tempFile.getName() + RECORD + i);\n&#x27;
                           &#x27;        if (state != null &amp;&amp; &#x27;
                           &#x27;Integer.parseInt(String.valueOf(state)) == 1) {\n&#x27;
                           &#x27;          tRecord.isComplete = true;\n&#x27;
                           &#x27;          continue;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (record != null) {\n&#x27;
                           &#x27;          long temp = &#x27;
                           &#x27;Long.parseLong(String.valueOf(record));\n&#x27;
                           &#x27;          tRecord.startLocation = temp &gt; 0 ? temp &#x27;
                           &#x27;: 0;\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          tRecord.startLocation = 0;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        mRecord.threadRecords.add(tRecord);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mConfigFile.delete();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 初始化任务记录，分配线程区间\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param newRecord {@code true} 需要创建新{@link &#x27;
                           &#x27;TaskRecord}\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void initRecord(boolean newRecord) {\n&#x27;
                           &#x27;    if (newRecord) {\n&#x27;
                           &#x27;      mRecord = &#x27;
                           &#x27;createTaskRecord(getNewTaskThreadNum());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    mTaskWrapper.setNewTask(true);\n&#x27;
                           &#x27;    // 处理线程区间记录\n&#x27;
                           &#x27;    long blockSize = mEntity.getFileSize() / &#x27;
                           &#x27;mRecord.threadNum;\n&#x27;
                           &#x27;    for (int i = 0; i &lt; mRecord.threadNum; i++) {\n&#x27;
                           &#x27;      long startL = i * blockSize, endL = (i + 1) &#x27;
                           &#x27;* blockSize;\n&#x27;
                           &#x27;      ThreadRecord tr;\n&#x27;
                           &#x27;      tr = new ThreadRecord();\n&#x27;
                           &#x27;      tr.key = mRecord.filePath;\n&#x27;
                           &#x27;      tr.threadId = i;\n&#x27;
                           &#x27;      tr.startLocation = startL;\n&#x27;
                           &#x27;      //最后一个线程的结束位置即为文件的总长度\n&#x27;
                           &#x27;      if (i == (mRecord.threadNum - 1)) {\n&#x27;
                           &#x27;        endL = mEntity.getFileSize();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      tr.endLocation = endL;\n&#x27;
                           &#x27;      tr.blockLen = &#x27;
                           &#x27;CommonUtil.getBlockLen(mEntity.getFileSize(), i, &#x27;
                           &#x27;mRecord.threadNum);\n&#x27;
                           &#x27;      mRecord.threadRecords.add(tr);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 创建任务记录\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param threadNum 线程总数\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private TaskRecord createTaskRecord(int &#x27;
                           &#x27;threadNum) {\n&#x27;
                           &#x27;    TaskRecord record = new TaskRecord();\n&#x27;
                           &#x27;    record.fileName = mEntity.getFileName();\n&#x27;
                           &#x27;    record.filePath = getFilePath();\n&#x27;
                           &#x27;    record.threadRecords = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;    record.threadNum = threadNum;\n&#x27;
                           &#x27;    // 处理分块和动态文件参数\n&#x27;
                           &#x27;    if (getRecordType() == TYPE_DOWNLOAD) {\n&#x27;
                           &#x27;      record.isBlock = threadNum &gt; 1 &amp;&amp; &#x27;
                           &#x27;Configuration.getInstance().downloadCfg.isUseBlock();\n&#x27;
                           &#x27;      // 线程数为1，或者使用了分块，则认为是使用动态长度文件\n&#x27;
                           &#x27;      record.isOpenDynamicFile = threadNum == 1 || &#x27;
                           &#x27;record.isBlock;\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      record.isBlock = false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    record.isGroupRecord = &#x27;
                           &#x27;mEntity.isGroupChild();\n&#x27;
                           &#x27;    if (record.isGroupRecord) {\n&#x27;
                           &#x27;      if (mEntity instanceof DownloadEntity) {\n&#x27;
                           &#x27;        record.dGroupHash = ((DownloadEntity) &#x27;
                           &#x27;mEntity).getGroupHash();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    return record;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 保存任务记录\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void saveRecord() {\n&#x27;
                           &#x27;    mRecord.threadNum = &#x27;
                           &#x27;mRecord.threadRecords.size();\n&#x27;
                           &#x27;    mRecord.save();\n&#x27;
                           &#x27;    DbEntity.saveAll(mRecord.threadRecords);\n&#x27;
                           &#x27;    ALog.d(TAG, String.format(&quot;保存记录，线程记录数：%s&quot;, &#x27;
                           &#x27;mRecord.threadRecords.size()));\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 获取记录类型\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return {@link #TYPE_DOWNLOAD}、{@link &#x27;
                           &#x27;#TYPE_UPLOAD}\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private int getRecordType() {\n&#x27;
                           &#x27;    if (mEntity instanceof DownloadEntity) {\n&#x27;
                           &#x27;      return TYPE_DOWNLOAD;\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      return TYPE_UPLOAD;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 获取任务路径\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return 任务文件路径\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private String getFilePath() {\n&#x27;
                           &#x27;    if (mEntity instanceof DownloadEntity) {\n&#x27;
                           &#x27;      return ((DownloadEntity) &#x27;
                           &#x27;mTaskWrapper.getEntity()).getFilePath();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      return ((UploadEntity) &#x27;
                           &#x27;mTaskWrapper.getEntity()).getFilePath();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 小于1m的文件或是任务组的子任务、线程数强制为1\n&#x27;
                           &#x27;   * 不支持断点或chunked模式的线程数都为，线程数强制为1\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private int getNewTaskThreadNum() {\n&#x27;
                           &#x27;    if (getRecordType() == TYPE_DOWNLOAD) {\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;import com.arialyy.aria.core.download.DTaskWrapper;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.arialyy.aria.core.download.DownloadEntity;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.arialyy.aria.core.download.m3u8.M3U8FileLoader;\n&#x27;
                         &#x27;import com.arialyy.aria.core.inf.AbsNormalEntity;\n&#x27;
                         &#x27;import com.arialyy.aria.core.inf.AbsTaskWrapper;\n&#x27;
                         &#x27;import com.arialyy.aria.core.inf.ITaskWrapper;\n&#x27;
                         &#x27;import com.arialyy.aria.core.upload.UploadEntity;\n&#x27;
                         &#x27;import com.arialyy.aria.orm.DbEntity;\n&#x27;
                         &#x27;import com.arialyy.aria.util.ALog;\n&#x27;
                         &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                         &#x27;import com.arialyy.aria.util.DbDataHelper;\n&#x27;
                         &#x27;import java.io.File;\n&#x27;
                         &#x27;import java.util.ArrayList;\n&#x27;
                         &#x27;import java.util.HashSet;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Properties;\n&#x27;
                         &#x27;import java.util.Set;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * 处理任务记录，分配线程区间\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public class RecordHandler {\n&#x27;
                         &#x27;  private final String TAG = &quot;RecordHandler&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  public static final int TYPE_DOWNLOAD = 1;\n&#x27;
                         &#x27;  public static final int TYPE_UPLOAD = 2;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private static final String STATE = &quot;_state_&quot;;\n&#x27;
                         &#x27;  private static final String RECORD = &quot;_record_&quot;;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 小于1m的文件不启用多线程\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private static final long SUB_LEN = 1024 * 1024;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 分块文件路径\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public static final String SUB_PATH = &#x27;
                         &#x27;&quot;%s.%s.part&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Deprecated private File mConfigFile;\n&#x27;
                         &#x27;  private TaskRecord mRecord;\n&#x27;
                         &#x27;  private AbsTaskWrapper mTaskWrapper;\n&#x27;
                         &#x27;  private AbsNormalEntity mEntity;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  RecordHandler(AbsTaskWrapper wrapper) {\n&#x27;
                         &#x27;    mTaskWrapper = wrapper;\n&#x27;
                         &#x27;    mEntity = (AbsNormalEntity) &#x27;
                         &#x27;mTaskWrapper.getEntity();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取任务记录，如果任务记录存在，检查任务记录\n&#x27;
                         &#x27;   * 检查记录 对于分块任务： 子分块不存在或被删除，子线程将重新下载\n&#x27;
                         &#x27;   * 对于普通任务： 预下载文件不存在，则任务任务呗删除\n&#x27;
                         &#x27;   * 如果任务记录不存在或线程记录不存在，初始化记录\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @return 任务记录\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  TaskRecord getRecord() {\n&#x27;
                         &#x27;    mConfigFile = new &#x27;
                         &#x27;File(CommonUtil.getFileConfigPath(false, &#x27;
                         &#x27;mEntity.getFileName()));\n&#x27;
                         &#x27;    if (mConfigFile.exists()) {\n&#x27;
                         &#x27;      convertDb();\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      mRecord = &#x27;
                         &#x27;DbDataHelper.getTaskRecord(getFilePath());\n&#x27;
                         &#x27;      if (mRecord == null) {\n&#x27;
                         &#x27;        initRecord(true);\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        if (mRecord.threadRecords == null || &#x27;
                         &#x27;mRecord.threadRecords.isEmpty()) {\n&#x27;
                         &#x27;          initRecord(false);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if (mTaskWrapper.getRequestType() == &#x27;
                         &#x27;ITaskWrapper.M3U8_FILE) {\n&#x27;
                         &#x27;          handleM3U8Record();\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          if (mRecord.isBlock) {\n&#x27;
                         &#x27;            handleBlockRecord();\n&#x27;
                         &#x27;          } else if (!mTaskWrapper.isSupportBP()) {\n&#x27;
                         &#x27;            handleNoSupportBPRecord();\n&#x27;
                         &#x27;          } else {\n&#x27;
                         &#x27;            handleSingleThreadRecord();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    saveRecord();\n&#x27;
                         &#x27;    return mRecord;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理m3u8记录，\n&#x27;
                         &#x27;   * 1、如果分片文件存在，并且分片文件的记录没有完成，则需要删除该分片文件\n&#x27;
                         &#x27;   * 2、如果记录显示已完成，但是分片文件不存在，则重新开始该分片\n&#x27;
                         &#x27;   * 3、如果记录显示已完成，并且文件存在，记录当前任务进度\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleM3U8Record() {\n&#x27;
                         &#x27;    DTaskWrapper wrapper = (DTaskWrapper) &#x27;
                         &#x27;mTaskWrapper;\n&#x27;
                         &#x27;    String cacheDir = &#x27;
                         &#x27;wrapper.asM3U8().getCacheDir();\n&#x27;
                         &#x27;    long currentProgress = 0;\n&#x27;
                         &#x27;    for (ThreadRecord record : &#x27;
                         &#x27;mRecord.threadRecords) {\n&#x27;
                         &#x27;      File temp = new &#x27;
                         &#x27;File(M3U8FileLoader.getTsFilePath(cacheDir, &#x27;
                         &#x27;record.threadId));\n&#x27;
                         &#x27;      if (!record.isComplete) {\n&#x27;
                         &#x27;        if (temp.exists()) {\n&#x27;
                         &#x27;          temp.delete();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        record.startLocation = 0;\n&#x27;
                         &#x27;        ALog.d(TAG, &#x27;
                         &#x27;String.format(&quot;分片【%s】未完成，将重新下载该分片&quot;, &#x27;
                         &#x27;record.threadId));\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        if (!temp.exists()) {\n&#x27;
                         &#x27;          record.startLocation = 0;\n&#x27;
                         &#x27;          record.isComplete = false;\n&#x27;
                         &#x27;          ALog.w(TAG, &#x27;
                         &#x27;String.format(&quot;分片【%s】不存在，将重新下载该分片&quot;, &#x27;
                         &#x27;record.threadId));\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          currentProgress += temp.length();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    &#x27;
                         &#x27;wrapper.getEntity().setCurrentProgress(currentProgress);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理不支持断点的记录\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleNoSupportBPRecord() {\n&#x27;
                         &#x27;    ThreadRecord tr = mRecord.threadRecords.get(0);\n&#x27;
                         &#x27;    tr.startLocation = 0;\n&#x27;
                         &#x27;    tr.endLocation = mEntity.getFileSize();\n&#x27;
                         &#x27;    tr.key = mRecord.filePath;\n&#x27;
                         &#x27;    tr.blockLen = tr.endLocation;\n&#x27;
                         &#x27;    tr.isComplete = false;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理单线程的任务的记录\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleSingleThreadRecord() {\n&#x27;
                         &#x27;    File file = new File(mRecord.filePath);\n&#x27;
                         &#x27;    ThreadRecord tr = mRecord.threadRecords.get(0);\n&#x27;
                         &#x27;    if (!file.exists()) {\n&#x27;
                         &#x27;      ALog.w(TAG, String.format(&quot;文件【%s】不存在，任务将重新开始&quot;, &#x27;
                         &#x27;file.getPath()));\n&#x27;
                         &#x27;      tr.startLocation = 0;\n&#x27;
                         &#x27;      tr.isComplete = false;\n&#x27;
                         &#x27;      tr.endLocation = mEntity.getFileSize();\n&#x27;
                         &#x27;    } else if (mRecord.isOpenDynamicFile) {\n&#x27;
                         &#x27;      if (file.length() &gt; mEntity.getFileSize()) {\n&#x27;
                         &#x27;        ALog.i(TAG, String.format(&quot;文件【%s】错误，任务重新开始&quot;, &#x27;
                         &#x27;file.getPath()));\n&#x27;
                         &#x27;        file.delete();\n&#x27;
                         &#x27;        tr.startLocation = 0;\n&#x27;
                         &#x27;        tr.isComplete = false;\n&#x27;
                         &#x27;        tr.endLocation = mEntity.getFileSize();\n&#x27;
                         &#x27;      } else if (file.length() == &#x27;
                         &#x27;mEntity.getFileSize()) {\n&#x27;
                         &#x27;        tr.isComplete = true;\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        if (file.length() != tr.startLocation) {\n&#x27;
                         &#x27;          ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;修正【%s】的进度记录为：%s&quot;, file.getPath(), &#x27;
                         &#x27;file.length()));\n&#x27;
                         &#x27;          tr.startLocation = file.length();\n&#x27;
                         &#x27;          tr.isComplete = false;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    mTaskWrapper.setNewTask(false);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * &#x27;
                         &#x27;处理分块任务的记录，分块文件（blockFileLen）长度必须需要小于等于线程区间（threadRectLen）的长度\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleBlockRecord() {\n&#x27;
                         &#x27;    // 默认线程分块长度\n&#x27;
                         &#x27;    long normalRectLen = mEntity.getFileSize() / &#x27;
                         &#x27;mRecord.threadRecords.size();\n&#x27;
                         &#x27;    for (ThreadRecord tr : mRecord.threadRecords) {\n&#x27;
                         &#x27;      long threadRect = tr.blockLen;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;      File temp = new File(String.format(SUB_PATH, &#x27;
                         &#x27;mRecord.filePath, tr.threadId));\n&#x27;
                         &#x27;      if (!temp.exists()) {\n&#x27;
                         &#x27;        ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;分块文件【%s】不存在，该分块将重新开始&quot;, &#x27;
                         &#x27;temp.getPath()));\n&#x27;
                         &#x27;        tr.isComplete = false;\n&#x27;
                         &#x27;        tr.startLocation = tr.threadId * &#x27;
                         &#x27;normalRectLen;\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        if (!tr.isComplete) {\n&#x27;
                         &#x27;          ALog.i(TAG, String.format(\n&#x27;
                         &#x27;              &quot;startLocation = %s; endLocation = %s; &#x27;
                         &#x27;block = %s; tempLen = %s; threadId = %s&quot;,\n&#x27;
                         &#x27;              tr.startLocation, tr.endLocation, &#x27;
                         &#x27;threadRect, temp.length(), tr.threadId));\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;          long blockFileLen = temp.length(); // &#x27;
                         &#x27;磁盘中的分块文件长度\n&#x27;
                         &#x27;          /*\n&#x27;
                         &#x27;           * 检查磁盘中的分块文件\n&#x27;
                         &#x27;           */\n&#x27;
                         &#x27;          if (blockFileLen &gt; threadRect) {\n&#x27;
                         &#x27;            ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;分块【%s】错误，分块长度【%s】 &gt; &#x27;
                         &#x27;线程区间长度【%s】，将重新开始该分块&quot;,\n&#x27;
                         &#x27;                tr.threadId, blockFileLen, &#x27;
                         &#x27;threadRect));\n&#x27;
                         &#x27;            temp.delete();\n&#x27;
                         &#x27;            tr.startLocation = tr.threadId * &#x27;
                         &#x27;threadRect;\n&#x27;
                         &#x27;            continue;\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;          long realLocation =\n&#x27;
                         &#x27;              tr.threadId * normalRectLen + &#x27;
                         &#x27;blockFileLen; //正常情况下，该线程的startLocation的位置\n&#x27;
                         &#x27;          /*\n&#x27;
                         &#x27;           * 检查记录文件\n&#x27;
                         &#x27;           */\n&#x27;
                         &#x27;          if (blockFileLen == threadRect) {\n&#x27;
                         &#x27;            ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;分块【%s】已完成，更新记录&quot;, temp.getPath()));\n&#x27;
                         &#x27;            tr.startLocation = blockFileLen;\n&#x27;
                         &#x27;            tr.isComplete = true;\n&#x27;
                         &#x27;          } else if (tr.startLocation != &#x27;
                         &#x27;realLocation) { // 处理记录小于分块文件长度的情况\n&#x27;
                         &#x27;            ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;修正分块【%s】的进度记录为：%s&quot;, temp.getPath(), &#x27;
                         &#x27;realLocation));\n&#x27;
                         &#x27;            tr.startLocation = realLocation;\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          ALog.i(TAG, String.format(&quot;分块【%s】已完成&quot;, &#x27;
                         &#x27;temp.getPath()));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    mTaskWrapper.setNewTask(false);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * convertDb 是兼容性代码 从3.4.1开始，线程配置信息将存储在数据库中。 &#x27;
                         &#x27;将配置文件的内容复制到数据库中，并将配置文件删除\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void convertDb() {\n&#x27;
                         &#x27;    List&lt;RecordWrapper&gt; records =\n&#x27;
                         &#x27;        &#x27;
                         &#x27;DbEntity.findRelationData(RecordWrapper.class, &#x27;
                         &#x27;&quot;TaskRecord.filePath=?&quot;,\n&#x27;
                         &#x27;            getFilePath());\n&#x27;
                         &#x27;    if (records == null || records.size() == 0) {\n&#x27;
                         &#x27;      Properties pro = &#x27;
                         &#x27;CommonUtil.loadConfig(mConfigFile);\n&#x27;
                         &#x27;      if (pro.isEmpty()) {\n&#x27;
                         &#x27;        ALog.d(TAG, &quot;老版本的线程记录为空，任务为新任务&quot;);\n&#x27;
                         &#x27;        initRecord(true);\n&#x27;
                         &#x27;        return;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;      Set&lt;Object&gt; keys = pro.keySet();\n&#x27;
                         &#x27;      // &#x27;
                         &#x27;老版本记录是5s存一次，但是5s中内，如果线程执行完成，record记录是没有的，只有state记录...\n&#x27;
                         &#x27;      // 第一步应该是record 和 state去重取正确的线程数\n&#x27;
                         &#x27;      Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\n&#x27;
                         &#x27;      for (Object key : keys) {\n&#x27;
                         &#x27;        String str = String.valueOf(key);\n&#x27;
                         &#x27;        int i = &#x27;
                         &#x27;Integer.parseInt(str.substring(str.length() - 1));\n&#x27;
                         &#x27;        set.add(i);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      int threadNum = set.size();\n&#x27;
                         &#x27;      if (threadNum == 0) {\n&#x27;
                         &#x27;        ALog.d(TAG, &quot;线程数为空，任务为新任务&quot;);\n&#x27;
                         &#x27;        initRecord(true);\n&#x27;
                         &#x27;        return;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      mTaskWrapper.setNewTask(false);\n&#x27;
                         &#x27;      mRecord = createTaskRecord(threadNum);\n&#x27;
                         &#x27;      mRecord.isOpenDynamicFile = false;\n&#x27;
                         &#x27;      mRecord.isBlock = false;\n&#x27;
                         &#x27;      File tempFile = new File(getFilePath());\n&#x27;
                         &#x27;      for (int i = 0; i &lt; threadNum; i++) {\n&#x27;
                         &#x27;        ThreadRecord tRecord = new ThreadRecord();\n&#x27;
                         &#x27;        tRecord.key = mRecord.filePath;\n&#x27;
                         &#x27;        Object state = &#x27;
                         &#x27;pro.getProperty(tempFile.getName() + STATE + i);\n&#x27;
                         &#x27;        Object record = &#x27;
                         &#x27;pro.getProperty(tempFile.getName() + RECORD + i);\n&#x27;
                         &#x27;        if (state != null &amp;&amp; &#x27;
                         &#x27;Integer.parseInt(String.valueOf(state)) == 1) {\n&#x27;
                         &#x27;          tRecord.isComplete = true;\n&#x27;
                         &#x27;          continue;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (record != null) {\n&#x27;
                         &#x27;          long temp = &#x27;
                         &#x27;Long.parseLong(String.valueOf(record));\n&#x27;
                         &#x27;          tRecord.startLocation = temp &gt; 0 ? temp : &#x27;
                         &#x27;0;\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          tRecord.startLocation = 0;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        mRecord.threadRecords.add(tRecord);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      mConfigFile.delete();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 初始化任务记录，分配线程区间\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @param newRecord {@code true} 需要创建新{@link &#x27;
                         &#x27;TaskRecord}\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void initRecord(boolean newRecord) {\n&#x27;
                         &#x27;    if (newRecord) {\n&#x27;
                         &#x27;      mRecord = &#x27;
                         &#x27;createTaskRecord(getNewTaskThreadNum());\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    mTaskWrapper.setNewTask(true);\n&#x27;
                         &#x27;    // 处理线程区间记录\n&#x27;
                         &#x27;    int requestType = &#x27;
                         &#x27;mTaskWrapper.getRequestType();\n&#x27;
                         &#x27;    long blockSize = mEntity.getFileSize() / &#x27;
                         &#x27;mRecord.threadNum;\n&#x27;
                         &#x27;    for (int i = 0; i &lt; mRecord.threadNum; i++) {\n&#x27;
                         &#x27;      long startL = i * blockSize, endL = (i + 1) * &#x27;
                         &#x27;blockSize;\n&#x27;
                         &#x27;      ThreadRecord tr;\n&#x27;
                         &#x27;      tr = new ThreadRecord();\n&#x27;
                         &#x27;      tr.key = mRecord.filePath;\n&#x27;
                         &#x27;      tr.threadId = i;\n&#x27;
                         &#x27;      tr.startLocation = startL;\n&#x27;
                         &#x27;      tr.isComplete = false;\n&#x27;
                         &#x27;      if (requestType == ITaskWrapper.M3U8_FILE) {\n&#x27;
                         &#x27;        tr.startLocation = 0;\n&#x27;
                         &#x27;        tr.threadType = TaskRecord.TYPE_M3U8;\n&#x27;
                         &#x27;        tr.m3u8url = ((DTaskWrapper) &#x27;
                         &#x27;mTaskWrapper).asM3U8().getUrls().get(i);\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        tr.threadType = TaskRecord.TYPE_HTTP_FTP;\n&#x27;
                         &#x27;        //最后一个线程的结束位置即为文件的总长度\n&#x27;
                         &#x27;        if (i == (mRecord.threadNum - 1)) {\n&#x27;
                         &#x27;          endL = mEntity.getFileSize();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        tr.endLocation = endL;\n&#x27;
                         &#x27;        tr.blockLen = &#x27;
                         &#x27;CommonUtil.getBlockLen(mEntity.getFileSize(), i, &#x27;
                         &#x27;mRecord.threadNum);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      mRecord.threadRecords.add(tr);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 创建任务记录\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @param threadNum 线程总数\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private TaskRecord createTaskRecord(int threadNum) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;    TaskRecord record = new TaskRecord();\n&#x27;
                         &#x27;    record.fileName = mEntity.getFileName();\n&#x27;
                         &#x27;    record.filePath = getFilePath();\n&#x27;
                         &#x27;    record.threadRecords = new ArrayList&lt;&gt;();\n&#x27;
                         &#x27;    record.threadNum = threadNum;\n&#x27;
                         &#x27;    // 处理分块和动态文件参数\n&#x27;
                         &#x27;    if (getRecordType() == TYPE_DOWNLOAD) {\n&#x27;
                         &#x27;      record.isBlock = threadNum &gt; 1 &amp;&amp; &#x27;
                         &#x27;Configuration.getInstance().downloadCfg.isUseBlock();\n&#x27;
                         &#x27;      // 线程数为1，或者使用了分块，则认为是使用动态长度文件\n&#x27;
                         &#x27;      record.isOpenDynamicFile = threadNum == 1 || &#x27;
                         &#x27;record.isBlock;\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      record.isBlock = false;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    if (mTaskWrapper.getRequestType() == &#x27;
                         &#x27;ITaskWrapper.M3U8_FILE) {\n&#x27;
                         &#x27;      record.taskType = TaskRecord.TYPE_M3U8;\n&#x27;
                         &#x27;      record.isOpenDynamicFile = true;\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      record.taskType = TaskRecord.TYPE_HTTP_FTP;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    record.isGroupRecord = mEntity.isGroupChild();\n&#x27;
                         &#x27;    if (record.isGroupRecord) {\n&#x27;
                         &#x27;      if (mEntity instanceof DownloadEntity) {\n&#x27;
                         &#x27;        record.dGroupHash = ((DownloadEntity) &#x27;
                         &#x27;mEntity).getGroupHash();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    return record;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 保存任务记录\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void saveRecord() {\n&#x27;
                         &#x27;    mRecord.threadNum = &#x27;
                         &#x27;mRecord.threadRecords.size();\n&#x27;
                         &#x27;    mRecord.save();\n&#x27;
                         &#x27;    DbEntity.saveAll(mRecord.threadRecords);\n&#x27;
                         &#x27;    ALog.d(TAG, String.format(&quot;保存记录，线程记录数：%s&quot;, &#x27;
                         &#x27;mRecord.threadRecords.size()));\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取记录类型\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @return {@link #TYPE_DOWNLOAD}、{@link &#x27;
                         &#x27;#TYPE_UPLOAD}\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private int getRecordType() {\n&#x27;
                         &#x27;    if (mEntity instanceof DownloadEntity) {\n&#x27;
                         &#x27;      return TYPE_DOWNLOAD;\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      return TYPE_UPLOAD;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取任务路径\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @return 任务文件路径\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private String getFilePath() {\n&#x27;
                         &#x27;    if (mEntity instanceof DownloadEntity) {\n&#x27;
                         &#x27;      return ((DownloadEntity) &#x27;
                         &#x27;mTaskWrapper.getEntity()).getFilePath();\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      return ((UploadEntity) &#x27;
                         &#x27;mTaskWrapper.getEntity()).getFilePath();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 小于1m的文件或是任务组的子任务、线程数强制为1\n&#x27;
                         &#x27;   * 不支持断点或chunked模式的线程数都为，线程数强制为1\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private int getNewTaskThreadNum() {\n&#x27;
                         &#x27;    if (getRecordType() == TYPE_DOWNLOAD) {\n&#x27;
                         &#x27;      if (mTaskWrapper.getRequestType() == &#x27;
                         &#x27;ITaskWrapper.M3U8_FILE) {\n&#x27;
                         &#x27;        return ((DTaskWrapper) &#x27;
                         &#x27;mTaskWrapper).asM3U8().getUrls().size();\n&#x27;
                         &#x27;      }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.DownloadEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.core.inf.AbsNormalEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.core.inf.AbsTaskWrapper;\n&#x27;
                           &#x27;import com.arialyy.aria.core.upload.UploadEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.orm.DbEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.util.ALog;\n&#x27;
                           &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                           &#x27;import com.arialyy.aria.util.DbDataHelper;\n&#x27;
                           &#x27;import java.io.File;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;import java.util.HashSet;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;import java.util.Properties;\n&#x27;
                           &#x27;import java.util.Set;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * 处理任务记录，分配线程区间\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class RecordHandler {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  public static final int TYPE_DOWNLOAD = 1;\n&#x27;
                           &#x27;  public static final int TYPE_UPLOAD = 2;\n&#x27;
                           &#x27;  private final String TAG = &quot;RecordHandler&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private static final String STATE = &quot;_state_&quot;;\n&#x27;
                           &#x27;  private static final String RECORD = &#x27;
                           &#x27;&quot;_record_&quot;;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 小于1m的文件不启用多线程\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private static final long SUB_LEN = 1024 * &#x27;
                           &#x27;1024;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 分块文件路径\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public static final String SUB_PATH = &#x27;
                           &#x27;&quot;%s.%s.part&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Deprecated private File mConfigFile;\n&#x27;
                           &#x27;  private TaskRecord mRecord;\n&#x27;
                           &#x27;  private AbsTaskWrapper mTaskWrapper;\n&#x27;
                           &#x27;  private AbsNormalEntity mEntity;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  RecordHandler(AbsTaskWrapper wrapper) {\n&#x27;
                           &#x27;    mTaskWrapper = wrapper;\n&#x27;
                           &#x27;    mEntity = (AbsNormalEntity) &#x27;
                           &#x27;mTaskWrapper.getEntity();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 获取任务记录，如果任务记录存在，检查任务记录\n&#x27;
                           &#x27;   * 检查记录 对于分块任务： 子分块不存在或被删除，子线程将重新下载\n&#x27;
                           &#x27;   * 对于普通任务： 预下载文件不存在，则任务任务呗删除\n&#x27;
                           &#x27;   * 如果任务记录不存在或线程记录不存在，初始化记录\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return 任务记录\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  TaskRecord getRecord() {\n&#x27;
                           &#x27;    mConfigFile = new &#x27;
                           &#x27;File(CommonUtil.getFileConfigPath(false, &#x27;
                           &#x27;mEntity.getFileName()));\n&#x27;
                           &#x27;    if (mConfigFile.exists()) {\n&#x27;
                           &#x27;      convertDb();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      mRecord = &#x27;
                           &#x27;DbDataHelper.getTaskRecord(getFilePath());\n&#x27;
                           &#x27;      if (mRecord == null) {\n&#x27;
                           &#x27;        initRecord(true);\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        if (mRecord.threadRecords == null || &#x27;
                           &#x27;mRecord.threadRecords.isEmpty()) {\n&#x27;
                           &#x27;          initRecord(false);\n&#x27;
                           &#x27;        } else if (mRecord.isBlock) {\n&#x27;
                           &#x27;          handleBlockRecord();\n&#x27;
                           &#x27;        } else if (!mTaskWrapper.isSupportBP()) {\n&#x27;
                           &#x27;          handleNoSupportBPRecord();\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          handleSingleThreadRecord();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    saveRecord();\n&#x27;
                           &#x27;    return mRecord;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理不支持断点的记录\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleNoSupportBPRecord() {\n&#x27;
                           &#x27;    ThreadRecord tr = &#x27;
                           &#x27;mRecord.threadRecords.get(0);\n&#x27;
                           &#x27;    tr.startLocation = 0;\n&#x27;
                           &#x27;    tr.endLocation = mEntity.getFileSize();\n&#x27;
                           &#x27;    tr.key = mRecord.filePath;\n&#x27;
                           &#x27;    tr.blockLen = tr.endLocation;\n&#x27;
                           &#x27;    tr.isComplete = false;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理单线程的任务的记录\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleSingleThreadRecord() {\n&#x27;
                           &#x27;    File file = new File(mRecord.filePath);\n&#x27;
                           &#x27;    ThreadRecord tr = &#x27;
                           &#x27;mRecord.threadRecords.get(0);\n&#x27;
                           &#x27;    if (!file.exists()) {\n&#x27;
                           &#x27;      ALog.w(TAG, &#x27;
                           &#x27;String.format(&quot;文件【%s】不存在，任务将重新开始&quot;, &#x27;
                           &#x27;file.getPath()));\n&#x27;
                           &#x27;      tr.startLocation = 0;\n&#x27;
                           &#x27;      tr.isComplete = false;\n&#x27;
                           &#x27;      tr.endLocation = mEntity.getFileSize();\n&#x27;
                           &#x27;    } else if (mRecord.isOpenDynamicFile) {\n&#x27;
                           &#x27;      if (file.length() &gt; mEntity.getFileSize()) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;文件【%s】错误，任务重新开始&quot;, &#x27;
                           &#x27;file.getPath()));\n&#x27;
                           &#x27;        file.delete();\n&#x27;
                           &#x27;        tr.startLocation = 0;\n&#x27;
                           &#x27;        tr.isComplete = false;\n&#x27;
                           &#x27;        tr.endLocation = mEntity.getFileSize();\n&#x27;
                           &#x27;      } else if (file.length() == &#x27;
                           &#x27;mEntity.getFileSize()) {\n&#x27;
                           &#x27;        tr.isComplete = true;\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        if (file.length() != tr.startLocation) {\n&#x27;
                           &#x27;          ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;修正【%s】的进度记录为：%s&quot;, file.getPath(), &#x27;
                           &#x27;file.length()));\n&#x27;
                           &#x27;          tr.startLocation = file.length();\n&#x27;
                           &#x27;          tr.isComplete = false;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    mTaskWrapper.setNewTask(false);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * &#x27;
                           &#x27;处理分块任务的记录，分块文件（blockFileLen）长度必须需要小于等于线程区间（threadRectLen）的长度\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleBlockRecord() {\n&#x27;
                           &#x27;    // 默认线程分块长度\n&#x27;
                           &#x27;    long normalRectLen = mEntity.getFileSize() / &#x27;
                           &#x27;mRecord.threadRecords.size();\n&#x27;
                           &#x27;    for (ThreadRecord tr : mRecord.threadRecords) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      long threadRect = tr.blockLen;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      File temp = new File(String.format(SUB_PATH, &#x27;
                           &#x27;mRecord.filePath, tr.threadId));\n&#x27;
                           &#x27;      if (!temp.exists()) {\n&#x27;
                           &#x27;        ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;分块文件【%s】不存在，该分块将重新开始&quot;, &#x27;
                           &#x27;temp.getPath()));\n&#x27;
                           &#x27;        tr.isComplete = false;\n&#x27;
                           &#x27;        tr.startLocation = tr.threadId * &#x27;
                           &#x27;normalRectLen;\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        if (!tr.isComplete) {\n&#x27;
                           &#x27;          ALog.i(TAG, String.format(\n&#x27;
                           &#x27;              &quot;startLocation = %s; endLocation = &#x27;
                           &#x27;%s; block = %s; tempLen = %s; threadId = %s&quot;,\n&#x27;
                           &#x27;              tr.startLocation, tr.endLocation, &#x27;
                           &#x27;threadRect, temp.length(), tr.threadId));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;          long blockFileLen = temp.length(); // &#x27;
                           &#x27;磁盘中的分块文件长度\n&#x27;
                           &#x27;          /*\n&#x27;
                           &#x27;           * 检查磁盘中的分块文件\n&#x27;
                           &#x27;           */\n&#x27;
                           &#x27;          if (blockFileLen &gt; threadRect) {\n&#x27;
                           &#x27;            ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;分块【%s】错误，分块长度【%s】 &gt; &#x27;
                           &#x27;线程区间长度【%s】，将重新开始该分块&quot;,\n&#x27;
                           &#x27;                tr.threadId, blockFileLen, &#x27;
                           &#x27;threadRect));\n&#x27;
                           &#x27;            temp.delete();\n&#x27;
                           &#x27;            tr.startLocation = tr.threadId * &#x27;
                           &#x27;threadRect;\n&#x27;
                           &#x27;            continue;\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;          long realLocation =\n&#x27;
                           &#x27;              tr.threadId * normalRectLen + &#x27;
                           &#x27;blockFileLen; //正常情况下，该线程的startLocation的位置\n&#x27;
                           &#x27;          /*\n&#x27;
                           &#x27;           * 检查记录文件\n&#x27;
                           &#x27;           */\n&#x27;
                           &#x27;          if (blockFileLen == threadRect) {\n&#x27;
                           &#x27;            ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;分块【%s】已完成，更新记录&quot;, temp.getPath()));\n&#x27;
                           &#x27;            tr.startLocation = blockFileLen;\n&#x27;
                           &#x27;            tr.isComplete = true;\n&#x27;
                           &#x27;          } else if (tr.startLocation != &#x27;
                           &#x27;realLocation) { // 处理记录小于分块文件长度的情况\n&#x27;
                           &#x27;            ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;修正分块【%s】的进度记录为：%s&quot;, temp.getPath(), &#x27;
                           &#x27;realLocation));\n&#x27;
                           &#x27;            tr.startLocation = realLocation;\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          ALog.i(TAG, String.format(&quot;分块【%s】已完成&quot;, &#x27;
                           &#x27;temp.getPath()));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    mTaskWrapper.setNewTask(false);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * convertDb 是兼容性代码 从3.4.1开始，线程配置信息将存储在数据库中。 &#x27;
                           &#x27;将配置文件的内容复制到数据库中，并将配置文件删除\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void convertDb() {\n&#x27;
                           &#x27;    List&lt;RecordWrapper&gt; records =\n&#x27;
                           &#x27;        &#x27;
                           &#x27;DbEntity.findRelationData(RecordWrapper.class, &#x27;
                           &#x27;&quot;TaskRecord.filePath=?&quot;,\n&#x27;
                           &#x27;            getFilePath());\n&#x27;
                           &#x27;    if (records == null || records.size() == 0) {\n&#x27;
                           &#x27;      Properties pro = &#x27;
                           &#x27;CommonUtil.loadConfig(mConfigFile);\n&#x27;
                           &#x27;      if (pro.isEmpty()) {\n&#x27;
                           &#x27;        ALog.d(TAG, &quot;老版本的线程记录为空，任务为新任务&quot;);\n&#x27;
                           &#x27;        initRecord(true);\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      Set&lt;Object&gt; keys = pro.keySet();\n&#x27;
                           &#x27;      // &#x27;
                           &#x27;老版本记录是5s存一次，但是5s中内，如果线程执行完成，record记录是没有的，只有state记录...\n&#x27;
                           &#x27;      // 第一步应该是record 和 state去重取正确的线程数\n&#x27;
                           &#x27;      Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\n&#x27;
                           &#x27;      for (Object key : keys) {\n&#x27;
                           &#x27;        String str = String.valueOf(key);\n&#x27;
                           &#x27;        int i = &#x27;
                           &#x27;Integer.parseInt(str.substring(str.length() - &#x27;
                           &#x27;1));\n&#x27;
                           &#x27;        set.add(i);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      int threadNum = set.size();\n&#x27;
                           &#x27;      if (threadNum == 0) {\n&#x27;
                           &#x27;        ALog.d(TAG, &quot;线程数为空，任务为新任务&quot;);\n&#x27;
                           &#x27;        initRecord(true);\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mTaskWrapper.setNewTask(false);\n&#x27;
                           &#x27;      mRecord = createTaskRecord(threadNum);\n&#x27;
                           &#x27;      mRecord.isOpenDynamicFile = false;\n&#x27;
                           &#x27;      mRecord.isBlock = false;\n&#x27;
                           &#x27;      File tempFile = new File(getFilePath());\n&#x27;
                           &#x27;      for (int i = 0; i &lt; threadNum; i++) {\n&#x27;
                           &#x27;        ThreadRecord tRecord = new &#x27;
                           &#x27;ThreadRecord();\n&#x27;
                           &#x27;        tRecord.key = mRecord.filePath;\n&#x27;
                           &#x27;        Object state = &#x27;
                           &#x27;pro.getProperty(tempFile.getName() + STATE + i);\n&#x27;
                           &#x27;        Object record = &#x27;
                           &#x27;pro.getProperty(tempFile.getName() + RECORD + i);\n&#x27;
                           &#x27;        if (state != null &amp;&amp; &#x27;
                           &#x27;Integer.parseInt(String.valueOf(state)) == 1) {\n&#x27;
                           &#x27;          tRecord.isComplete = true;\n&#x27;
                           &#x27;          continue;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (record != null) {\n&#x27;
                           &#x27;          long temp = &#x27;
                           &#x27;Long.parseLong(String.valueOf(record));\n&#x27;
                           &#x27;          tRecord.startLocation = temp &gt; 0 ? temp &#x27;
                           &#x27;: 0;\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          tRecord.startLocation = 0;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        mRecord.threadRecords.add(tRecord);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mConfigFile.delete();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 初始化任务记录，分配线程区间\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param newRecord {@code true} 需要创建新{@link &#x27;
                           &#x27;TaskRecord}\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void initRecord(boolean newRecord) {\n&#x27;
                           &#x27;    if (newRecord) {\n&#x27;
                           &#x27;      mRecord = &#x27;
                           &#x27;createTaskRecord(getNewTaskThreadNum());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    mTaskWrapper.setNewTask(true);\n&#x27;
                           &#x27;    // 处理线程区间记录\n&#x27;
                           &#x27;    long blockSize = mEntity.getFileSize() / &#x27;
                           &#x27;mRecord.threadNum;\n&#x27;
                           &#x27;    for (int i = 0; i &lt; mRecord.threadNum; i++) {\n&#x27;
                           &#x27;      long startL = i * blockSize, endL = (i + 1) &#x27;
                           &#x27;* blockSize;\n&#x27;
                           &#x27;      ThreadRecord tr;\n&#x27;
                           &#x27;      tr = new ThreadRecord();\n&#x27;
                           &#x27;      tr.key = mRecord.filePath;\n&#x27;
                           &#x27;      tr.threadId = i;\n&#x27;
                           &#x27;      tr.startLocation = startL;\n&#x27;
                           &#x27;      //最后一个线程的结束位置即为文件的总长度\n&#x27;
                           &#x27;      if (i == (mRecord.threadNum - 1)) {\n&#x27;
                           &#x27;        endL = mEntity.getFileSize();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      tr.endLocation = endL;\n&#x27;
                           &#x27;      tr.blockLen = &#x27;
                           &#x27;CommonUtil.getBlockLen(mEntity.getFileSize(), i, &#x27;
                           &#x27;mRecord.threadNum);\n&#x27;
                           &#x27;      mRecord.threadRecords.add(tr);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 创建任务记录\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param threadNum 线程总数\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private TaskRecord createTaskRecord(int &#x27;
                           &#x27;threadNum) {\n&#x27;
                           &#x27;    TaskRecord record = new TaskRecord();\n&#x27;
                           &#x27;    record.fileName = mEntity.getFileName();\n&#x27;
                           &#x27;    record.filePath = getFilePath();\n&#x27;
                           &#x27;    record.threadRecords = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;    record.threadNum = threadNum;\n&#x27;
                           &#x27;    // 处理分块和动态文件参数\n&#x27;
                           &#x27;    if (getRecordType() == TYPE_DOWNLOAD) {\n&#x27;
                           &#x27;      record.isBlock = threadNum &gt; 1 &amp;&amp; &#x27;
                           &#x27;Configuration.getInstance().downloadCfg.isUseBlock();\n&#x27;
                           &#x27;      // 线程数为1，或者使用了分块，则认为是使用动态长度文件\n&#x27;
                           &#x27;      record.isOpenDynamicFile = threadNum == 1 || &#x27;
                           &#x27;record.isBlock;\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      record.isBlock = false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    record.isGroupRecord = &#x27;
                           &#x27;mEntity.isGroupChild();\n&#x27;
                           &#x27;    if (record.isGroupRecord) {\n&#x27;
                           &#x27;      if (mEntity instanceof DownloadEntity) {\n&#x27;
                           &#x27;        record.dGroupHash = ((DownloadEntity) &#x27;
                           &#x27;mEntity).getGroupHash();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    return record;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 保存任务记录\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void saveRecord() {\n&#x27;
                           &#x27;    mRecord.threadNum = &#x27;
                           &#x27;mRecord.threadRecords.size();\n&#x27;
                           &#x27;    mRecord.save();\n&#x27;
                           &#x27;    DbEntity.saveAll(mRecord.threadRecords);\n&#x27;
                           &#x27;    ALog.d(TAG, String.format(&quot;保存记录，线程记录数：%s&quot;, &#x27;
                           &#x27;mRecord.threadRecords.size()));\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 获取记录类型\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return {@link #TYPE_DOWNLOAD}、{@link &#x27;
                           &#x27;#TYPE_UPLOAD}\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private int getRecordType() {\n&#x27;
                           &#x27;    if (mEntity instanceof DownloadEntity) {\n&#x27;
                           &#x27;      return TYPE_DOWNLOAD;\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      return TYPE_UPLOAD;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 获取任务路径\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return 任务文件路径\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private String getFilePath() {\n&#x27;
                           &#x27;    if (mEntity instanceof DownloadEntity) {\n&#x27;
                           &#x27;      return ((DownloadEntity) &#x27;
                           &#x27;mTaskWrapper.getEntity()).getFilePath();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      return ((UploadEntity) &#x27;
                           &#x27;mTaskWrapper.getEntity()).getFilePath();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 小于1m的文件或是任务组的子任务、线程数强制为1\n&#x27;
                           &#x27;   * 不支持断点或chunked模式的线程数都为，线程数强制为1\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private int getNewTaskThreadNum() {\n&#x27;
                           &#x27;    if (getRecordType() == TYPE_DOWNLOAD) {\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;import com.arialyy.aria.core.download.DTaskWrapper;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.arialyy.aria.core.download.DownloadEntity;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.arialyy.aria.core.download.m3u8.M3U8FileLoader;\n&#x27;
                         &#x27;import com.arialyy.aria.core.inf.AbsNormalEntity;\n&#x27;
                         &#x27;import com.arialyy.aria.core.inf.AbsTaskWrapper;\n&#x27;
                         &#x27;import com.arialyy.aria.core.inf.ITaskWrapper;\n&#x27;
                         &#x27;import com.arialyy.aria.core.upload.UploadEntity;\n&#x27;
                         &#x27;import com.arialyy.aria.orm.DbEntity;\n&#x27;
                         &#x27;import com.arialyy.aria.util.ALog;\n&#x27;
                         &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                         &#x27;import com.arialyy.aria.util.DbDataHelper;\n&#x27;
                         &#x27;import java.io.File;\n&#x27;
                         &#x27;import java.util.ArrayList;\n&#x27;
                         &#x27;import java.util.HashSet;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Properties;\n&#x27;
                         &#x27;import java.util.Set;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * 处理任务记录，分配线程区间\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public class RecordHandler {\n&#x27;
                         &#x27;  private final String TAG = &quot;RecordHandler&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  public static final int TYPE_DOWNLOAD = 1;\n&#x27;
                         &#x27;  public static final int TYPE_UPLOAD = 2;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private static final String STATE = &quot;_state_&quot;;\n&#x27;
                         &#x27;  private static final String RECORD = &quot;_record_&quot;;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 小于1m的文件不启用多线程\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private static final long SUB_LEN = 1024 * 1024;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 分块文件路径\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public static final String SUB_PATH = &#x27;
                         &#x27;&quot;%s.%s.part&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Deprecated private File mConfigFile;\n&#x27;
                         &#x27;  private TaskRecord mRecord;\n&#x27;
                         &#x27;  private AbsTaskWrapper mTaskWrapper;\n&#x27;
                         &#x27;  private AbsNormalEntity mEntity;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  RecordHandler(AbsTaskWrapper wrapper) {\n&#x27;
                         &#x27;    mTaskWrapper = wrapper;\n&#x27;
                         &#x27;    mEntity = (AbsNormalEntity) &#x27;
                         &#x27;mTaskWrapper.getEntity();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取任务记录，如果任务记录存在，检查任务记录\n&#x27;
                         &#x27;   * 检查记录 对于分块任务： 子分块不存在或被删除，子线程将重新下载\n&#x27;
                         &#x27;   * 对于普通任务： 预下载文件不存在，则任务任务呗删除\n&#x27;
                         &#x27;   * 如果任务记录不存在或线程记录不存在，初始化记录\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @return 任务记录\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  TaskRecord getRecord() {\n&#x27;
                         &#x27;    mConfigFile = new &#x27;
                         &#x27;File(CommonUtil.getFileConfigPath(false, &#x27;
                         &#x27;mEntity.getFileName()));\n&#x27;
                         &#x27;    if (mConfigFile.exists()) {\n&#x27;
                         &#x27;      convertDb();\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      mRecord = &#x27;
                         &#x27;DbDataHelper.getTaskRecord(getFilePath());\n&#x27;
                         &#x27;      if (mRecord == null) {\n&#x27;
                         &#x27;        initRecord(true);\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        if (mRecord.threadRecords == null || &#x27;
                         &#x27;mRecord.threadRecords.isEmpty()) {\n&#x27;
                         &#x27;          initRecord(false);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if (mTaskWrapper.getRequestType() == &#x27;
                         &#x27;ITaskWrapper.M3U8_FILE) {\n&#x27;
                         &#x27;          handleM3U8Record();\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          if (mRecord.isBlock) {\n&#x27;
                         &#x27;            handleBlockRecord();\n&#x27;
                         &#x27;          } else if (!mTaskWrapper.isSupportBP()) {\n&#x27;
                         &#x27;            handleNoSupportBPRecord();\n&#x27;
                         &#x27;          } else {\n&#x27;
                         &#x27;            handleSingleThreadRecord();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    saveRecord();\n&#x27;
                         &#x27;    return mRecord;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理m3u8记录，\n&#x27;
                         &#x27;   * 1、如果分片文件存在，并且分片文件的记录没有完成，则需要删除该分片文件\n&#x27;
                         &#x27;   * 2、如果记录显示已完成，但是分片文件不存在，则重新开始该分片\n&#x27;
                         &#x27;   * 3、如果记录显示已完成，并且文件存在，记录当前任务进度\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleM3U8Record() {\n&#x27;
                         &#x27;    DTaskWrapper wrapper = (DTaskWrapper) &#x27;
                         &#x27;mTaskWrapper;\n&#x27;
                         &#x27;    String cacheDir = &#x27;
                         &#x27;wrapper.asM3U8().getCacheDir();\n&#x27;
                         &#x27;    long currentProgress = 0;\n&#x27;
                         &#x27;    for (ThreadRecord record : &#x27;
                         &#x27;mRecord.threadRecords) {\n&#x27;
                         &#x27;      File temp = new &#x27;
                         &#x27;File(M3U8FileLoader.getTsFilePath(cacheDir, &#x27;
                         &#x27;record.threadId));\n&#x27;
                         &#x27;      if (!record.isComplete) {\n&#x27;
                         &#x27;        if (temp.exists()) {\n&#x27;
                         &#x27;          temp.delete();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        record.startLocation = 0;\n&#x27;
                         &#x27;        ALog.d(TAG, &#x27;
                         &#x27;String.format(&quot;分片【%s】未完成，将重新下载该分片&quot;, &#x27;
                         &#x27;record.threadId));\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        if (!temp.exists()) {\n&#x27;
                         &#x27;          record.startLocation = 0;\n&#x27;
                         &#x27;          record.isComplete = false;\n&#x27;
                         &#x27;          ALog.w(TAG, &#x27;
                         &#x27;String.format(&quot;分片【%s】不存在，将重新下载该分片&quot;, &#x27;
                         &#x27;record.threadId));\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          currentProgress += temp.length();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    &#x27;
                         &#x27;wrapper.getEntity().setCurrentProgress(currentProgress);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理不支持断点的记录\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleNoSupportBPRecord() {\n&#x27;
                         &#x27;    ThreadRecord tr = mRecord.threadRecords.get(0);\n&#x27;
                         &#x27;    tr.startLocation = 0;\n&#x27;
                         &#x27;    tr.endLocation = mEntity.getFileSize();\n&#x27;
                         &#x27;    tr.key = mRecord.filePath;\n&#x27;
                         &#x27;    tr.blockLen = tr.endLocation;\n&#x27;
                         &#x27;    tr.isComplete = false;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理单线程的任务的记录\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleSingleThreadRecord() {\n&#x27;
                         &#x27;    File file = new File(mRecord.filePath);\n&#x27;
                         &#x27;    ThreadRecord tr = mRecord.threadRecords.get(0);\n&#x27;
                         &#x27;    if (!file.exists()) {\n&#x27;
                         &#x27;      ALog.w(TAG, String.format(&quot;文件【%s】不存在，任务将重新开始&quot;, &#x27;
                         &#x27;file.getPath()));\n&#x27;
                         &#x27;      tr.startLocation = 0;\n&#x27;
                         &#x27;      tr.isComplete = false;\n&#x27;
                         &#x27;      tr.endLocation = mEntity.getFileSize();\n&#x27;
                         &#x27;    } else if (mRecord.isOpenDynamicFile) {\n&#x27;
                         &#x27;      if (file.length() &gt; mEntity.getFileSize()) {\n&#x27;
                         &#x27;        ALog.i(TAG, String.format(&quot;文件【%s】错误，任务重新开始&quot;, &#x27;
                         &#x27;file.getPath()));\n&#x27;
                         &#x27;        file.delete();\n&#x27;
                         &#x27;        tr.startLocation = 0;\n&#x27;
                         &#x27;        tr.isComplete = false;\n&#x27;
                         &#x27;        tr.endLocation = mEntity.getFileSize();\n&#x27;
                         &#x27;      } else if (file.length() == &#x27;
                         &#x27;mEntity.getFileSize()) {\n&#x27;
                         &#x27;        tr.isComplete = true;\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        if (file.length() != tr.startLocation) {\n&#x27;
                         &#x27;          ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;修正【%s】的进度记录为：%s&quot;, file.getPath(), &#x27;
                         &#x27;file.length()));\n&#x27;
                         &#x27;          tr.startLocation = file.length();\n&#x27;
                         &#x27;          tr.isComplete = false;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    mTaskWrapper.setNewTask(false);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * &#x27;
                         &#x27;处理分块任务的记录，分块文件（blockFileLen）长度必须需要小于等于线程区间（threadRectLen）的长度\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleBlockRecord() {\n&#x27;
                         &#x27;    // 默认线程分块长度\n&#x27;
                         &#x27;    long normalRectLen = mEntity.getFileSize() / &#x27;
                         &#x27;mRecord.threadRecords.size();\n&#x27;
                         &#x27;    for (ThreadRecord tr : mRecord.threadRecords) {\n&#x27;
                         &#x27;      long threadRect = tr.blockLen;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;      File temp = new File(String.format(SUB_PATH, &#x27;
                         &#x27;mRecord.filePath, tr.threadId));\n&#x27;
                         &#x27;      if (!temp.exists()) {\n&#x27;
                         &#x27;        ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;分块文件【%s】不存在，该分块将重新开始&quot;, &#x27;
                         &#x27;temp.getPath()));\n&#x27;
                         &#x27;        tr.isComplete = false;\n&#x27;
                         &#x27;        tr.startLocation = tr.threadId * &#x27;
                         &#x27;normalRectLen;\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        if (!tr.isComplete) {\n&#x27;
                         &#x27;          ALog.i(TAG, String.format(\n&#x27;
                         &#x27;              &quot;startLocation = %s; endLocation = %s; &#x27;
                         &#x27;block = %s; tempLen = %s; threadId = %s&quot;,\n&#x27;
                         &#x27;              tr.startLocation, tr.endLocation, &#x27;
                         &#x27;threadRect, temp.length(), tr.threadId));\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;          long blockFileLen = temp.length(); // &#x27;
                         &#x27;磁盘中的分块文件长度\n&#x27;
                         &#x27;          /*\n&#x27;
                         &#x27;           * 检查磁盘中的分块文件\n&#x27;
                         &#x27;           */\n&#x27;
                         &#x27;          if (blockFileLen &gt; threadRect) {\n&#x27;
                         &#x27;            ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;分块【%s】错误，分块长度【%s】 &gt; &#x27;
                         &#x27;线程区间长度【%s】，将重新开始该分块&quot;,\n&#x27;
                         &#x27;                tr.threadId, blockFileLen, &#x27;
                         &#x27;threadRect));\n&#x27;
                         &#x27;            temp.delete();\n&#x27;
                         &#x27;            tr.startLocation = tr.threadId * &#x27;
                         &#x27;threadRect;\n&#x27;
                         &#x27;            continue;\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;          long realLocation =\n&#x27;
                         &#x27;              tr.threadId * normalRectLen + &#x27;
                         &#x27;blockFileLen; //正常情况下，该线程的startLocation的位置\n&#x27;
                         &#x27;          /*\n&#x27;
                         &#x27;           * 检查记录文件\n&#x27;
                         &#x27;           */\n&#x27;
                         &#x27;          if (blockFileLen == threadRect) {\n&#x27;
                         &#x27;            ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;分块【%s】已完成，更新记录&quot;, temp.getPath()));\n&#x27;
                         &#x27;            tr.startLocation = blockFileLen;\n&#x27;
                         &#x27;            tr.isComplete = true;\n&#x27;
                         &#x27;          } else if (tr.startLocation != &#x27;
                         &#x27;realLocation) { // 处理记录小于分块文件长度的情况\n&#x27;
                         &#x27;            ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;修正分块【%s】的进度记录为：%s&quot;, temp.getPath(), &#x27;
                         &#x27;realLocation));\n&#x27;
                         &#x27;            tr.startLocation = realLocation;\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          ALog.i(TAG, String.format(&quot;分块【%s】已完成&quot;, &#x27;
                         &#x27;temp.getPath()));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    mTaskWrapper.setNewTask(false);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * convertDb 是兼容性代码 从3.4.1开始，线程配置信息将存储在数据库中。 &#x27;
                         &#x27;将配置文件的内容复制到数据库中，并将配置文件删除\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void convertDb() {\n&#x27;
                         &#x27;    List&lt;RecordWrapper&gt; records =\n&#x27;
                         &#x27;        &#x27;
                         &#x27;DbEntity.findRelationData(RecordWrapper.class, &#x27;
                         &#x27;&quot;TaskRecord.filePath=?&quot;,\n&#x27;
                         &#x27;            getFilePath());\n&#x27;
                         &#x27;    if (records == null || records.size() == 0) {\n&#x27;
                         &#x27;      Properties pro = &#x27;
                         &#x27;CommonUtil.loadConfig(mConfigFile);\n&#x27;
                         &#x27;      if (pro.isEmpty()) {\n&#x27;
                         &#x27;        ALog.d(TAG, &quot;老版本的线程记录为空，任务为新任务&quot;);\n&#x27;
                         &#x27;        initRecord(true);\n&#x27;
                         &#x27;        return;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;      Set&lt;Object&gt; keys = pro.keySet();\n&#x27;
                         &#x27;      // &#x27;
                         &#x27;老版本记录是5s存一次，但是5s中内，如果线程执行完成，record记录是没有的，只有state记录...\n&#x27;
                         &#x27;      // 第一步应该是record 和 state去重取正确的线程数\n&#x27;
                         &#x27;      Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\n&#x27;
                         &#x27;      for (Object key : keys) {\n&#x27;
                         &#x27;        String str = String.valueOf(key);\n&#x27;
                         &#x27;        int i = &#x27;
                         &#x27;Integer.parseInt(str.substring(str.length() - 1));\n&#x27;
                         &#x27;        set.add(i);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      int threadNum = set.size();\n&#x27;
                         &#x27;      if (threadNum == 0) {\n&#x27;
                         &#x27;        ALog.d(TAG, &quot;线程数为空，任务为新任务&quot;);\n&#x27;
                         &#x27;        initRecord(true);\n&#x27;
                         &#x27;        return;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      mTaskWrapper.setNewTask(false);\n&#x27;
                         &#x27;      mRecord = createTaskRecord(threadNum);\n&#x27;
                         &#x27;      mRecord.isOpenDynamicFile = false;\n&#x27;
                         &#x27;      mRecord.isBlock = false;\n&#x27;
                         &#x27;      File tempFile = new File(getFilePath());\n&#x27;
                         &#x27;      for (int i = 0; i &lt; threadNum; i++) {\n&#x27;
                         &#x27;        ThreadRecord tRecord = new ThreadRecord();\n&#x27;
                         &#x27;        tRecord.key = mRecord.filePath;\n&#x27;
                         &#x27;        Object state = &#x27;
                         &#x27;pro.getProperty(tempFile.getName() + STATE + i);\n&#x27;
                         &#x27;        Object record = &#x27;
                         &#x27;pro.getProperty(tempFile.getName() + RECORD + i);\n&#x27;
                         &#x27;        if (state != null &amp;&amp; &#x27;
                         &#x27;Integer.parseInt(String.valueOf(state)) == 1) {\n&#x27;
                         &#x27;          tRecord.isComplete = true;\n&#x27;
                         &#x27;          continue;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (record != null) {\n&#x27;
                         &#x27;          long temp = &#x27;
                         &#x27;Long.parseLong(String.valueOf(record));\n&#x27;
                         &#x27;          tRecord.startLocation = temp &gt; 0 ? temp : &#x27;
                         &#x27;0;\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          tRecord.startLocation = 0;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        mRecord.threadRecords.add(tRecord);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      mConfigFile.delete();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 初始化任务记录，分配线程区间\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @param newRecord {@code true} 需要创建新{@link &#x27;
                         &#x27;TaskRecord}\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void initRecord(boolean newRecord) {\n&#x27;
                         &#x27;    if (newRecord) {\n&#x27;
                         &#x27;      mRecord = &#x27;
                         &#x27;createTaskRecord(getNewTaskThreadNum());\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    mTaskWrapper.setNewTask(true);\n&#x27;
                         &#x27;    // 处理线程区间记录\n&#x27;
                         &#x27;    int requestType = &#x27;
                         &#x27;mTaskWrapper.getRequestType();\n&#x27;
                         &#x27;    long blockSize = mEntity.getFileSize() / &#x27;
                         &#x27;mRecord.threadNum;\n&#x27;
                         &#x27;    for (int i = 0; i &lt; mRecord.threadNum; i++) {\n&#x27;
                         &#x27;      long startL = i * blockSize, endL = (i + 1) * &#x27;
                         &#x27;blockSize;\n&#x27;
                         &#x27;      ThreadRecord tr;\n&#x27;
                         &#x27;      tr = new ThreadRecord();\n&#x27;
                         &#x27;      tr.key = mRecord.filePath;\n&#x27;
                         &#x27;      tr.threadId = i;\n&#x27;
                         &#x27;      tr.startLocation = startL;\n&#x27;
                         &#x27;      tr.isComplete = false;\n&#x27;
                         &#x27;      if (requestType == ITaskWrapper.M3U8_FILE) {\n&#x27;
                         &#x27;        tr.startLocation = 0;\n&#x27;
                         &#x27;        tr.threadType = TaskRecord.TYPE_M3U8;\n&#x27;
                         &#x27;        tr.m3u8url = ((DTaskWrapper) &#x27;
                         &#x27;mTaskWrapper).asM3U8().getUrls().get(i);\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        tr.threadType = TaskRecord.TYPE_HTTP_FTP;\n&#x27;
                         &#x27;        //最后一个线程的结束位置即为文件的总长度\n&#x27;
                         &#x27;        if (i == (mRecord.threadNum - 1)) {\n&#x27;
                         &#x27;          endL = mEntity.getFileSize();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        tr.endLocation = endL;\n&#x27;
                         &#x27;        tr.blockLen = &#x27;
                         &#x27;CommonUtil.getBlockLen(mEntity.getFileSize(), i, &#x27;
                         &#x27;mRecord.threadNum);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      mRecord.threadRecords.add(tr);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 创建任务记录\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @param threadNum 线程总数\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private TaskRecord createTaskRecord(int threadNum) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;    TaskRecord record = new TaskRecord();\n&#x27;
                         &#x27;    record.fileName = mEntity.getFileName();\n&#x27;
                         &#x27;    record.filePath = getFilePath();\n&#x27;
                         &#x27;    record.threadRecords = new ArrayList&lt;&gt;();\n&#x27;
                         &#x27;    record.threadNum = threadNum;\n&#x27;
                         &#x27;    // 处理分块和动态文件参数\n&#x27;
                         &#x27;    if (getRecordType() == TYPE_DOWNLOAD) {\n&#x27;
                         &#x27;      record.isBlock = threadNum &gt; 1 &amp;&amp; &#x27;
                         &#x27;Configuration.getInstance().downloadCfg.isUseBlock();\n&#x27;
                         &#x27;      // 线程数为1，或者使用了分块，则认为是使用动态长度文件\n&#x27;
                         &#x27;      record.isOpenDynamicFile = threadNum == 1 || &#x27;
                         &#x27;record.isBlock;\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      record.isBlock = false;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    if (mTaskWrapper.getRequestType() == &#x27;
                         &#x27;ITaskWrapper.M3U8_FILE) {\n&#x27;
                         &#x27;      record.taskType = TaskRecord.TYPE_M3U8;\n&#x27;
                         &#x27;      record.isOpenDynamicFile = true;\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      record.taskType = TaskRecord.TYPE_HTTP_FTP;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    record.isGroupRecord = mEntity.isGroupChild();\n&#x27;
                         &#x27;    if (record.isGroupRecord) {\n&#x27;
                         &#x27;      if (mEntity instanceof DownloadEntity) {\n&#x27;
                         &#x27;        record.dGroupHash = ((DownloadEntity) &#x27;
                         &#x27;mEntity).getGroupHash();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    return record;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 保存任务记录\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void saveRecord() {\n&#x27;
                         &#x27;    mRecord.threadNum = &#x27;
                         &#x27;mRecord.threadRecords.size();\n&#x27;
                         &#x27;    mRecord.save();\n&#x27;
                         &#x27;    DbEntity.saveAll(mRecord.threadRecords);\n&#x27;
                         &#x27;    ALog.d(TAG, String.format(&quot;保存记录，线程记录数：%s&quot;, &#x27;
                         &#x27;mRecord.threadRecords.size()));\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取记录类型\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @return {@link #TYPE_DOWNLOAD}、{@link &#x27;
                         &#x27;#TYPE_UPLOAD}\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private int getRecordType() {\n&#x27;
                         &#x27;    if (mEntity instanceof DownloadEntity) {\n&#x27;
                         &#x27;      return TYPE_DOWNLOAD;\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      return TYPE_UPLOAD;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取任务路径\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @return 任务文件路径\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private String getFilePath() {\n&#x27;
                         &#x27;    if (mEntity instanceof DownloadEntity) {\n&#x27;
                         &#x27;      return ((DownloadEntity) &#x27;
                         &#x27;mTaskWrapper.getEntity()).getFilePath();\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      return ((UploadEntity) &#x27;
                         &#x27;mTaskWrapper.getEntity()).getFilePath();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 小于1m的文件或是任务组的子任务、线程数强制为1\n&#x27;
                         &#x27;   * 不支持断点或chunked模式的线程数都为，线程数强制为1\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private int getNewTaskThreadNum() {\n&#x27;
                         &#x27;    if (getRecordType() == TYPE_DOWNLOAD) {\n&#x27;
                         &#x27;      if (mTaskWrapper.getRequestType() == &#x27;
                         &#x27;ITaskWrapper.M3U8_FILE) {\n&#x27;
                         &#x27;        return ((DTaskWrapper) &#x27;
                         &#x27;mTaskWrapper).asM3U8().getUrls().size();\n&#x27;
                         &#x27;      }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.DownloadEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.core.inf.AbsNormalEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.core.inf.AbsTaskWrapper;\n&#x27;
                           &#x27;import com.arialyy.aria.core.upload.UploadEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.orm.DbEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.util.ALog;\n&#x27;
                           &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                           &#x27;import com.arialyy.aria.util.DbDataHelper;\n&#x27;
                           &#x27;import java.io.File;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;import java.util.HashSet;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;import java.util.Properties;\n&#x27;
                           &#x27;import java.util.Set;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * 处理任务记录，分配线程区间\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class RecordHandler {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  public static final int TYPE_DOWNLOAD = 1;\n&#x27;
                           &#x27;  public static final int TYPE_UPLOAD = 2;\n&#x27;
                           &#x27;  private final String TAG = &quot;RecordHandler&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private static final String STATE = &quot;_state_&quot;;\n&#x27;
                           &#x27;  private static final String RECORD = &#x27;
                           &#x27;&quot;_record_&quot;;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 小于1m的文件不启用多线程\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private static final long SUB_LEN = 1024 * &#x27;
                           &#x27;1024;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 分块文件路径\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public static final String SUB_PATH = &#x27;
                           &#x27;&quot;%s.%s.part&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Deprecated private File mConfigFile;\n&#x27;
                           &#x27;  private TaskRecord mRecord;\n&#x27;
                           &#x27;  private AbsTaskWrapper mTaskWrapper;\n&#x27;
                           &#x27;  private AbsNormalEntity mEntity;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  RecordHandler(AbsTaskWrapper wrapper) {\n&#x27;
                           &#x27;    mTaskWrapper = wrapper;\n&#x27;
                           &#x27;    mEntity = (AbsNormalEntity) &#x27;
                           &#x27;mTaskWrapper.getEntity();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 获取任务记录，如果任务记录存在，检查任务记录\n&#x27;
                           &#x27;   * 检查记录 对于分块任务： 子分块不存在或被删除，子线程将重新下载\n&#x27;
                           &#x27;   * 对于普通任务： 预下载文件不存在，则任务任务呗删除\n&#x27;
                           &#x27;   * 如果任务记录不存在或线程记录不存在，初始化记录\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return 任务记录\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  TaskRecord getRecord() {\n&#x27;
                           &#x27;    mConfigFile = new &#x27;
                           &#x27;File(CommonUtil.getFileConfigPath(false, &#x27;
                           &#x27;mEntity.getFileName()));\n&#x27;
                           &#x27;    if (mConfigFile.exists()) {\n&#x27;
                           &#x27;      convertDb();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      mRecord = &#x27;
                           &#x27;DbDataHelper.getTaskRecord(getFilePath());\n&#x27;
                           &#x27;      if (mRecord == null) {\n&#x27;
                           &#x27;        initRecord(true);\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        if (mRecord.threadRecords == null || &#x27;
                           &#x27;mRecord.threadRecords.isEmpty()) {\n&#x27;
                           &#x27;          initRecord(false);\n&#x27;
                           &#x27;        } else if (mRecord.isBlock) {\n&#x27;
                           &#x27;          handleBlockRecord();\n&#x27;
                           &#x27;        } else if (!mTaskWrapper.isSupportBP()) {\n&#x27;
                           &#x27;          handleNoSupportBPRecord();\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          handleSingleThreadRecord();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    saveRecord();\n&#x27;
                           &#x27;    return mRecord;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理不支持断点的记录\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleNoSupportBPRecord() {\n&#x27;
                           &#x27;    ThreadRecord tr = &#x27;
                           &#x27;mRecord.threadRecords.get(0);\n&#x27;
                           &#x27;    tr.startLocation = 0;\n&#x27;
                           &#x27;    tr.endLocation = mEntity.getFileSize();\n&#x27;
                           &#x27;    tr.key = mRecord.filePath;\n&#x27;
                           &#x27;    tr.blockLen = tr.endLocation;\n&#x27;
                           &#x27;    tr.isComplete = false;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理单线程的任务的记录\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleSingleThreadRecord() {\n&#x27;
                           &#x27;    File file = new File(mRecord.filePath);\n&#x27;
                           &#x27;    ThreadRecord tr = &#x27;
                           &#x27;mRecord.threadRecords.get(0);\n&#x27;
                           &#x27;    if (!file.exists()) {\n&#x27;
                           &#x27;      ALog.w(TAG, &#x27;
                           &#x27;String.format(&quot;文件【%s】不存在，任务将重新开始&quot;, &#x27;
                           &#x27;file.getPath()));\n&#x27;
                           &#x27;      tr.startLocation = 0;\n&#x27;
                           &#x27;      tr.isComplete = false;\n&#x27;
                           &#x27;      tr.endLocation = mEntity.getFileSize();\n&#x27;
                           &#x27;    } else if (mRecord.isOpenDynamicFile) {\n&#x27;
                           &#x27;      if (file.length() &gt; mEntity.getFileSize()) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;文件【%s】错误，任务重新开始&quot;, &#x27;
                           &#x27;file.getPath()));\n&#x27;
                           &#x27;        file.delete();\n&#x27;
                           &#x27;        tr.startLocation = 0;\n&#x27;
                           &#x27;        tr.isComplete = false;\n&#x27;
                           &#x27;        tr.endLocation = mEntity.getFileSize();\n&#x27;
                           &#x27;      } else if (file.length() == &#x27;
                           &#x27;mEntity.getFileSize()) {\n&#x27;
                           &#x27;        tr.isComplete = true;\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        if (file.length() != tr.startLocation) {\n&#x27;
                           &#x27;          ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;修正【%s】的进度记录为：%s&quot;, file.getPath(), &#x27;
                           &#x27;file.length()));\n&#x27;
                           &#x27;          tr.startLocation = file.length();\n&#x27;
                           &#x27;          tr.isComplete = false;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    mTaskWrapper.setNewTask(false);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * &#x27;
                           &#x27;处理分块任务的记录，分块文件（blockFileLen）长度必须需要小于等于线程区间（threadRectLen）的长度\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleBlockRecord() {\n&#x27;
                           &#x27;    // 默认线程分块长度\n&#x27;
                           &#x27;    long normalRectLen = mEntity.getFileSize() / &#x27;
                           &#x27;mRecord.threadRecords.size();\n&#x27;
                           &#x27;    for (ThreadRecord tr : mRecord.threadRecords) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      long threadRect = tr.blockLen;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      File temp = new File(String.format(SUB_PATH, &#x27;
                           &#x27;mRecord.filePath, tr.threadId));\n&#x27;
                           &#x27;      if (!temp.exists()) {\n&#x27;
                           &#x27;        ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;分块文件【%s】不存在，该分块将重新开始&quot;, &#x27;
                           &#x27;temp.getPath()));\n&#x27;
                           &#x27;        tr.isComplete = false;\n&#x27;
                           &#x27;        tr.startLocation = tr.threadId * &#x27;
                           &#x27;normalRectLen;\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        if (!tr.isComplete) {\n&#x27;
                           &#x27;          ALog.i(TAG, String.format(\n&#x27;
                           &#x27;              &quot;startLocation = %s; endLocation = &#x27;
                           &#x27;%s; block = %s; tempLen = %s; threadId = %s&quot;,\n&#x27;
                           &#x27;              tr.startLocation, tr.endLocation, &#x27;
                           &#x27;threadRect, temp.length(), tr.threadId));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;          long blockFileLen = temp.length(); // &#x27;
                           &#x27;磁盘中的分块文件长度\n&#x27;
                           &#x27;          /*\n&#x27;
                           &#x27;           * 检查磁盘中的分块文件\n&#x27;
                           &#x27;           */\n&#x27;
                           &#x27;          if (blockFileLen &gt; threadRect) {\n&#x27;
                           &#x27;            ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;分块【%s】错误，分块长度【%s】 &gt; &#x27;
                           &#x27;线程区间长度【%s】，将重新开始该分块&quot;,\n&#x27;
                           &#x27;                tr.threadId, blockFileLen, &#x27;
                           &#x27;threadRect));\n&#x27;
                           &#x27;            temp.delete();\n&#x27;
                           &#x27;            tr.startLocation = tr.threadId * &#x27;
                           &#x27;threadRect;\n&#x27;
                           &#x27;            continue;\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;          long realLocation =\n&#x27;
                           &#x27;              tr.threadId * normalRectLen + &#x27;
                           &#x27;blockFileLen; //正常情况下，该线程的startLocation的位置\n&#x27;
                           &#x27;          /*\n&#x27;
                           &#x27;           * 检查记录文件\n&#x27;
                           &#x27;           */\n&#x27;
                           &#x27;          if (blockFileLen == threadRect) {\n&#x27;
                           &#x27;            ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;分块【%s】已完成，更新记录&quot;, temp.getPath()));\n&#x27;
                           &#x27;            tr.startLocation = blockFileLen;\n&#x27;
                           &#x27;            tr.isComplete = true;\n&#x27;
                           &#x27;          } else if (tr.startLocation != &#x27;
                           &#x27;realLocation) { // 处理记录小于分块文件长度的情况\n&#x27;
                           &#x27;            ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;修正分块【%s】的进度记录为：%s&quot;, temp.getPath(), &#x27;
                           &#x27;realLocation));\n&#x27;
                           &#x27;            tr.startLocation = realLocation;\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          ALog.i(TAG, String.format(&quot;分块【%s】已完成&quot;, &#x27;
                           &#x27;temp.getPath()));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    mTaskWrapper.setNewTask(false);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * convertDb 是兼容性代码 从3.4.1开始，线程配置信息将存储在数据库中。 &#x27;
                           &#x27;将配置文件的内容复制到数据库中，并将配置文件删除\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void convertDb() {\n&#x27;
                           &#x27;    List&lt;RecordWrapper&gt; records =\n&#x27;
                           &#x27;        &#x27;
                           &#x27;DbEntity.findRelationData(RecordWrapper.class, &#x27;
                           &#x27;&quot;TaskRecord.filePath=?&quot;,\n&#x27;
                           &#x27;            getFilePath());\n&#x27;
                           &#x27;    if (records == null || records.size() == 0) {\n&#x27;
                           &#x27;      Properties pro = &#x27;
                           &#x27;CommonUtil.loadConfig(mConfigFile);\n&#x27;
                           &#x27;      if (pro.isEmpty()) {\n&#x27;
                           &#x27;        ALog.d(TAG, &quot;老版本的线程记录为空，任务为新任务&quot;);\n&#x27;
                           &#x27;        initRecord(true);\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      Set&lt;Object&gt; keys = pro.keySet();\n&#x27;
                           &#x27;      // &#x27;
                           &#x27;老版本记录是5s存一次，但是5s中内，如果线程执行完成，record记录是没有的，只有state记录...\n&#x27;
                           &#x27;      // 第一步应该是record 和 state去重取正确的线程数\n&#x27;
                           &#x27;      Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\n&#x27;
                           &#x27;      for (Object key : keys) {\n&#x27;
                           &#x27;        String str = String.valueOf(key);\n&#x27;
                           &#x27;        int i = &#x27;
                           &#x27;Integer.parseInt(str.substring(str.length() - &#x27;
                           &#x27;1));\n&#x27;
                           &#x27;        set.add(i);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      int threadNum = set.size();\n&#x27;
                           &#x27;      if (threadNum == 0) {\n&#x27;
                           &#x27;        ALog.d(TAG, &quot;线程数为空，任务为新任务&quot;);\n&#x27;
                           &#x27;        initRecord(true);\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mTaskWrapper.setNewTask(false);\n&#x27;
                           &#x27;      mRecord = createTaskRecord(threadNum);\n&#x27;
                           &#x27;      mRecord.isOpenDynamicFile = false;\n&#x27;
                           &#x27;      mRecord.isBlock = false;\n&#x27;
                           &#x27;      File tempFile = new File(getFilePath());\n&#x27;
                           &#x27;      for (int i = 0; i &lt; threadNum; i++) {\n&#x27;
                           &#x27;        ThreadRecord tRecord = new &#x27;
                           &#x27;ThreadRecord();\n&#x27;
                           &#x27;        tRecord.key = mRecord.filePath;\n&#x27;
                           &#x27;        Object state = &#x27;
                           &#x27;pro.getProperty(tempFile.getName() + STATE + i);\n&#x27;
                           &#x27;        Object record = &#x27;
                           &#x27;pro.getProperty(tempFile.getName() + RECORD + i);\n&#x27;
                           &#x27;        if (state != null &amp;&amp; &#x27;
                           &#x27;Integer.parseInt(String.valueOf(state)) == 1) {\n&#x27;
                           &#x27;          tRecord.isComplete = true;\n&#x27;
                           &#x27;          continue;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (record != null) {\n&#x27;
                           &#x27;          long temp = &#x27;
                           &#x27;Long.parseLong(String.valueOf(record));\n&#x27;
                           &#x27;          tRecord.startLocation = temp &gt; 0 ? temp &#x27;
                           &#x27;: 0;\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          tRecord.startLocation = 0;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        mRecord.threadRecords.add(tRecord);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mConfigFile.delete();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 初始化任务记录，分配线程区间\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param newRecord {@code true} 需要创建新{@link &#x27;
                           &#x27;TaskRecord}\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void initRecord(boolean newRecord) {\n&#x27;
                           &#x27;    if (newRecord) {\n&#x27;
                           &#x27;      mRecord = &#x27;
                           &#x27;createTaskRecord(getNewTaskThreadNum());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    mTaskWrapper.setNewTask(true);\n&#x27;
                           &#x27;    // 处理线程区间记录\n&#x27;
                           &#x27;    long blockSize = mEntity.getFileSize() / &#x27;
                           &#x27;mRecord.threadNum;\n&#x27;
                           &#x27;    for (int i = 0; i &lt; mRecord.threadNum; i++) {\n&#x27;
                           &#x27;      long startL = i * blockSize, endL = (i + 1) &#x27;
                           &#x27;* blockSize;\n&#x27;
                           &#x27;      ThreadRecord tr;\n&#x27;
                           &#x27;      tr = new ThreadRecord();\n&#x27;
                           &#x27;      tr.key = mRecord.filePath;\n&#x27;
                           &#x27;      tr.threadId = i;\n&#x27;
                           &#x27;      tr.startLocation = startL;\n&#x27;
                           &#x27;      //最后一个线程的结束位置即为文件的总长度\n&#x27;
                           &#x27;      if (i == (mRecord.threadNum - 1)) {\n&#x27;
                           &#x27;        endL = mEntity.getFileSize();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      tr.endLocation = endL;\n&#x27;
                           &#x27;      tr.blockLen = &#x27;
                           &#x27;CommonUtil.getBlockLen(mEntity.getFileSize(), i, &#x27;
                           &#x27;mRecord.threadNum);\n&#x27;
                           &#x27;      mRecord.threadRecords.add(tr);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 创建任务记录\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param threadNum 线程总数\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private TaskRecord createTaskRecord(int &#x27;
                           &#x27;threadNum) {\n&#x27;
                           &#x27;    TaskRecord record = new TaskRecord();\n&#x27;
                           &#x27;    record.fileName = mEntity.getFileName();\n&#x27;
                           &#x27;    record.filePath = getFilePath();\n&#x27;
                           &#x27;    record.threadRecords = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;    record.threadNum = threadNum;\n&#x27;
                           &#x27;    // 处理分块和动态文件参数\n&#x27;
                           &#x27;    if (getRecordType() == TYPE_DOWNLOAD) {\n&#x27;
                           &#x27;      record.isBlock = threadNum &gt; 1 &amp;&amp; &#x27;
                           &#x27;Configuration.getInstance().downloadCfg.isUseBlock();\n&#x27;
                           &#x27;      // 线程数为1，或者使用了分块，则认为是使用动态长度文件\n&#x27;
                           &#x27;      record.isOpenDynamicFile = threadNum == 1 || &#x27;
                           &#x27;record.isBlock;\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      record.isBlock = false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    record.isGroupRecord = &#x27;
                           &#x27;mEntity.isGroupChild();\n&#x27;
                           &#x27;    if (record.isGroupRecord) {\n&#x27;
                           &#x27;      if (mEntity instanceof DownloadEntity) {\n&#x27;
                           &#x27;        record.dGroupHash = ((DownloadEntity) &#x27;
                           &#x27;mEntity).getGroupHash();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    return record;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 保存任务记录\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void saveRecord() {\n&#x27;
                           &#x27;    mRecord.threadNum = &#x27;
                           &#x27;mRecord.threadRecords.size();\n&#x27;
                           &#x27;    mRecord.save();\n&#x27;
                           &#x27;    DbEntity.saveAll(mRecord.threadRecords);\n&#x27;
                           &#x27;    ALog.d(TAG, String.format(&quot;保存记录，线程记录数：%s&quot;, &#x27;
                           &#x27;mRecord.threadRecords.size()));\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 获取记录类型\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return {@link #TYPE_DOWNLOAD}、{@link &#x27;
                           &#x27;#TYPE_UPLOAD}\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private int getRecordType() {\n&#x27;
                           &#x27;    if (mEntity instanceof DownloadEntity) {\n&#x27;
                           &#x27;      return TYPE_DOWNLOAD;\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      return TYPE_UPLOAD;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 获取任务路径\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return 任务文件路径\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private String getFilePath() {\n&#x27;
                           &#x27;    if (mEntity instanceof DownloadEntity) {\n&#x27;
                           &#x27;      return ((DownloadEntity) &#x27;
                           &#x27;mTaskWrapper.getEntity()).getFilePath();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      return ((UploadEntity) &#x27;
                           &#x27;mTaskWrapper.getEntity()).getFilePath();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 小于1m的文件或是任务组的子任务、线程数强制为1\n&#x27;
                           &#x27;   * 不支持断点或chunked模式的线程数都为，线程数强制为1\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private int getNewTaskThreadNum() {\n&#x27;
                           &#x27;    if (getRecordType() == TYPE_DOWNLOAD) {\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;import com.arialyy.aria.core.download.DTaskWrapper;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.arialyy.aria.core.download.DownloadEntity;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.arialyy.aria.core.download.m3u8.M3U8FileLoader;\n&#x27;
                         &#x27;import com.arialyy.aria.core.inf.AbsNormalEntity;\n&#x27;
                         &#x27;import com.arialyy.aria.core.inf.AbsTaskWrapper;\n&#x27;
                         &#x27;import com.arialyy.aria.core.inf.ITaskWrapper;\n&#x27;
                         &#x27;import com.arialyy.aria.core.upload.UploadEntity;\n&#x27;
                         &#x27;import com.arialyy.aria.orm.DbEntity;\n&#x27;
                         &#x27;import com.arialyy.aria.util.ALog;\n&#x27;
                         &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                         &#x27;import com.arialyy.aria.util.DbDataHelper;\n&#x27;
                         &#x27;import java.io.File;\n&#x27;
                         &#x27;import java.util.ArrayList;\n&#x27;
                         &#x27;import java.util.HashSet;\n&#x27;
                         &#x27;import java.util.List;\n&#x27;
                         &#x27;import java.util.Properties;\n&#x27;
                         &#x27;import java.util.Set;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * 处理任务记录，分配线程区间\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;public class RecordHandler {\n&#x27;
                         &#x27;  private final String TAG = &quot;RecordHandler&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  public static final int TYPE_DOWNLOAD = 1;\n&#x27;
                         &#x27;  public static final int TYPE_UPLOAD = 2;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private static final String STATE = &quot;_state_&quot;;\n&#x27;
                         &#x27;  private static final String RECORD = &quot;_record_&quot;;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 小于1m的文件不启用多线程\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private static final long SUB_LEN = 1024 * 1024;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 分块文件路径\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public static final String SUB_PATH = &#x27;
                         &#x27;&quot;%s.%s.part&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Deprecated private File mConfigFile;\n&#x27;
                         &#x27;  private TaskRecord mRecord;\n&#x27;
                         &#x27;  private AbsTaskWrapper mTaskWrapper;\n&#x27;
                         &#x27;  private AbsNormalEntity mEntity;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  RecordHandler(AbsTaskWrapper wrapper) {\n&#x27;
                         &#x27;    mTaskWrapper = wrapper;\n&#x27;
                         &#x27;    mEntity = (AbsNormalEntity) &#x27;
                         &#x27;mTaskWrapper.getEntity();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取任务记录，如果任务记录存在，检查任务记录\n&#x27;
                         &#x27;   * 检查记录 对于分块任务： 子分块不存在或被删除，子线程将重新下载\n&#x27;
                         &#x27;   * 对于普通任务： 预下载文件不存在，则任务任务呗删除\n&#x27;
                         &#x27;   * 如果任务记录不存在或线程记录不存在，初始化记录\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @return 任务记录\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  TaskRecord getRecord() {\n&#x27;
                         &#x27;    mConfigFile = new &#x27;
                         &#x27;File(CommonUtil.getFileConfigPath(false, &#x27;
                         &#x27;mEntity.getFileName()));\n&#x27;
                         &#x27;    if (mConfigFile.exists()) {\n&#x27;
                         &#x27;      convertDb();\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      mRecord = &#x27;
                         &#x27;DbDataHelper.getTaskRecord(getFilePath());\n&#x27;
                         &#x27;      if (mRecord == null) {\n&#x27;
                         &#x27;        initRecord(true);\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        if (mRecord.threadRecords == null || &#x27;
                         &#x27;mRecord.threadRecords.isEmpty()) {\n&#x27;
                         &#x27;          initRecord(false);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if (mTaskWrapper.getRequestType() == &#x27;
                         &#x27;ITaskWrapper.M3U8_FILE) {\n&#x27;
                         &#x27;          handleM3U8Record();\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          if (mRecord.isBlock) {\n&#x27;
                         &#x27;            handleBlockRecord();\n&#x27;
                         &#x27;          } else if (!mTaskWrapper.isSupportBP()) {\n&#x27;
                         &#x27;            handleNoSupportBPRecord();\n&#x27;
                         &#x27;          } else {\n&#x27;
                         &#x27;            handleSingleThreadRecord();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    saveRecord();\n&#x27;
                         &#x27;    return mRecord;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理m3u8记录，\n&#x27;
                         &#x27;   * 1、如果分片文件存在，并且分片文件的记录没有完成，则需要删除该分片文件\n&#x27;
                         &#x27;   * 2、如果记录显示已完成，但是分片文件不存在，则重新开始该分片\n&#x27;
                         &#x27;   * 3、如果记录显示已完成，并且文件存在，记录当前任务进度\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleM3U8Record() {\n&#x27;
                         &#x27;    DTaskWrapper wrapper = (DTaskWrapper) &#x27;
                         &#x27;mTaskWrapper;\n&#x27;
                         &#x27;    String cacheDir = &#x27;
                         &#x27;wrapper.asM3U8().getCacheDir();\n&#x27;
                         &#x27;    long currentProgress = 0;\n&#x27;
                         &#x27;    for (ThreadRecord record : &#x27;
                         &#x27;mRecord.threadRecords) {\n&#x27;
                         &#x27;      File temp = new &#x27;
                         &#x27;File(M3U8FileLoader.getTsFilePath(cacheDir, &#x27;
                         &#x27;record.threadId));\n&#x27;
                         &#x27;      if (!record.isComplete) {\n&#x27;
                         &#x27;        if (temp.exists()) {\n&#x27;
                         &#x27;          temp.delete();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        record.startLocation = 0;\n&#x27;
                         &#x27;        ALog.d(TAG, &#x27;
                         &#x27;String.format(&quot;分片【%s】未完成，将重新下载该分片&quot;, &#x27;
                         &#x27;record.threadId));\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        if (!temp.exists()) {\n&#x27;
                         &#x27;          record.startLocation = 0;\n&#x27;
                         &#x27;          record.isComplete = false;\n&#x27;
                         &#x27;          ALog.w(TAG, &#x27;
                         &#x27;String.format(&quot;分片【%s】不存在，将重新下载该分片&quot;, &#x27;
                         &#x27;record.threadId));\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          currentProgress += temp.length();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    &#x27;
                         &#x27;wrapper.getEntity().setCurrentProgress(currentProgress);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理不支持断点的记录\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleNoSupportBPRecord() {\n&#x27;
                         &#x27;    ThreadRecord tr = mRecord.threadRecords.get(0);\n&#x27;
                         &#x27;    tr.startLocation = 0;\n&#x27;
                         &#x27;    tr.endLocation = mEntity.getFileSize();\n&#x27;
                         &#x27;    tr.key = mRecord.filePath;\n&#x27;
                         &#x27;    tr.blockLen = tr.endLocation;\n&#x27;
                         &#x27;    tr.isComplete = false;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 处理单线程的任务的记录\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleSingleThreadRecord() {\n&#x27;
                         &#x27;    File file = new File(mRecord.filePath);\n&#x27;
                         &#x27;    ThreadRecord tr = mRecord.threadRecords.get(0);\n&#x27;
                         &#x27;    if (!file.exists()) {\n&#x27;
                         &#x27;      ALog.w(TAG, String.format(&quot;文件【%s】不存在，任务将重新开始&quot;, &#x27;
                         &#x27;file.getPath()));\n&#x27;
                         &#x27;      tr.startLocation = 0;\n&#x27;
                         &#x27;      tr.isComplete = false;\n&#x27;
                         &#x27;      tr.endLocation = mEntity.getFileSize();\n&#x27;
                         &#x27;    } else if (mRecord.isOpenDynamicFile) {\n&#x27;
                         &#x27;      if (file.length() &gt; mEntity.getFileSize()) {\n&#x27;
                         &#x27;        ALog.i(TAG, String.format(&quot;文件【%s】错误，任务重新开始&quot;, &#x27;
                         &#x27;file.getPath()));\n&#x27;
                         &#x27;        file.delete();\n&#x27;
                         &#x27;        tr.startLocation = 0;\n&#x27;
                         &#x27;        tr.isComplete = false;\n&#x27;
                         &#x27;        tr.endLocation = mEntity.getFileSize();\n&#x27;
                         &#x27;      } else if (file.length() == &#x27;
                         &#x27;mEntity.getFileSize()) {\n&#x27;
                         &#x27;        tr.isComplete = true;\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        if (file.length() != tr.startLocation) {\n&#x27;
                         &#x27;          ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;修正【%s】的进度记录为：%s&quot;, file.getPath(), &#x27;
                         &#x27;file.length()));\n&#x27;
                         &#x27;          tr.startLocation = file.length();\n&#x27;
                         &#x27;          tr.isComplete = false;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    mTaskWrapper.setNewTask(false);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * &#x27;
                         &#x27;处理分块任务的记录，分块文件（blockFileLen）长度必须需要小于等于线程区间（threadRectLen）的长度\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void handleBlockRecord() {\n&#x27;
                         &#x27;    // 默认线程分块长度\n&#x27;
                         &#x27;    long normalRectLen = mEntity.getFileSize() / &#x27;
                         &#x27;mRecord.threadRecords.size();\n&#x27;
                         &#x27;    for (ThreadRecord tr : mRecord.threadRecords) {\n&#x27;
                         &#x27;      long threadRect = tr.blockLen;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;      File temp = new File(String.format(SUB_PATH, &#x27;
                         &#x27;mRecord.filePath, tr.threadId));\n&#x27;
                         &#x27;      if (!temp.exists()) {\n&#x27;
                         &#x27;        ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;分块文件【%s】不存在，该分块将重新开始&quot;, &#x27;
                         &#x27;temp.getPath()));\n&#x27;
                         &#x27;        tr.isComplete = false;\n&#x27;
                         &#x27;        tr.startLocation = tr.threadId * &#x27;
                         &#x27;normalRectLen;\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        if (!tr.isComplete) {\n&#x27;
                         &#x27;          ALog.i(TAG, String.format(\n&#x27;
                         &#x27;              &quot;startLocation = %s; endLocation = %s; &#x27;
                         &#x27;block = %s; tempLen = %s; threadId = %s&quot;,\n&#x27;
                         &#x27;              tr.startLocation, tr.endLocation, &#x27;
                         &#x27;threadRect, temp.length(), tr.threadId));\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;          long blockFileLen = temp.length(); // &#x27;
                         &#x27;磁盘中的分块文件长度\n&#x27;
                         &#x27;          /*\n&#x27;
                         &#x27;           * 检查磁盘中的分块文件\n&#x27;
                         &#x27;           */\n&#x27;
                         &#x27;          if (blockFileLen &gt; threadRect) {\n&#x27;
                         &#x27;            ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;分块【%s】错误，分块长度【%s】 &gt; &#x27;
                         &#x27;线程区间长度【%s】，将重新开始该分块&quot;,\n&#x27;
                         &#x27;                tr.threadId, blockFileLen, &#x27;
                         &#x27;threadRect));\n&#x27;
                         &#x27;            temp.delete();\n&#x27;
                         &#x27;            tr.startLocation = tr.threadId * &#x27;
                         &#x27;threadRect;\n&#x27;
                         &#x27;            continue;\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;          long realLocation =\n&#x27;
                         &#x27;              tr.threadId * normalRectLen + &#x27;
                         &#x27;blockFileLen; //正常情况下，该线程的startLocation的位置\n&#x27;
                         &#x27;          /*\n&#x27;
                         &#x27;           * 检查记录文件\n&#x27;
                         &#x27;           */\n&#x27;
                         &#x27;          if (blockFileLen == threadRect) {\n&#x27;
                         &#x27;            ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;分块【%s】已完成，更新记录&quot;, temp.getPath()));\n&#x27;
                         &#x27;            tr.startLocation = blockFileLen;\n&#x27;
                         &#x27;            tr.isComplete = true;\n&#x27;
                         &#x27;          } else if (tr.startLocation != &#x27;
                         &#x27;realLocation) { // 处理记录小于分块文件长度的情况\n&#x27;
                         &#x27;            ALog.i(TAG, &#x27;
                         &#x27;String.format(&quot;修正分块【%s】的进度记录为：%s&quot;, temp.getPath(), &#x27;
                         &#x27;realLocation));\n&#x27;
                         &#x27;            tr.startLocation = realLocation;\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          ALog.i(TAG, String.format(&quot;分块【%s】已完成&quot;, &#x27;
                         &#x27;temp.getPath()));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    mTaskWrapper.setNewTask(false);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * convertDb 是兼容性代码 从3.4.1开始，线程配置信息将存储在数据库中。 &#x27;
                         &#x27;将配置文件的内容复制到数据库中，并将配置文件删除\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void convertDb() {\n&#x27;
                         &#x27;    List&lt;RecordWrapper&gt; records =\n&#x27;
                         &#x27;        &#x27;
                         &#x27;DbEntity.findRelationData(RecordWrapper.class, &#x27;
                         &#x27;&quot;TaskRecord.filePath=?&quot;,\n&#x27;
                         &#x27;            getFilePath());\n&#x27;
                         &#x27;    if (records == null || records.size() == 0) {\n&#x27;
                         &#x27;      Properties pro = &#x27;
                         &#x27;CommonUtil.loadConfig(mConfigFile);\n&#x27;
                         &#x27;      if (pro.isEmpty()) {\n&#x27;
                         &#x27;        ALog.d(TAG, &quot;老版本的线程记录为空，任务为新任务&quot;);\n&#x27;
                         &#x27;        initRecord(true);\n&#x27;
                         &#x27;        return;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;      Set&lt;Object&gt; keys = pro.keySet();\n&#x27;
                         &#x27;      // &#x27;
                         &#x27;老版本记录是5s存一次，但是5s中内，如果线程执行完成，record记录是没有的，只有state记录...\n&#x27;
                         &#x27;      // 第一步应该是record 和 state去重取正确的线程数\n&#x27;
                         &#x27;      Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\n&#x27;
                         &#x27;      for (Object key : keys) {\n&#x27;
                         &#x27;        String str = String.valueOf(key);\n&#x27;
                         &#x27;        int i = &#x27;
                         &#x27;Integer.parseInt(str.substring(str.length() - 1));\n&#x27;
                         &#x27;        set.add(i);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      int threadNum = set.size();\n&#x27;
                         &#x27;      if (threadNum == 0) {\n&#x27;
                         &#x27;        ALog.d(TAG, &quot;线程数为空，任务为新任务&quot;);\n&#x27;
                         &#x27;        initRecord(true);\n&#x27;
                         &#x27;        return;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      mTaskWrapper.setNewTask(false);\n&#x27;
                         &#x27;      mRecord = createTaskRecord(threadNum);\n&#x27;
                         &#x27;      mRecord.isOpenDynamicFile = false;\n&#x27;
                         &#x27;      mRecord.isBlock = false;\n&#x27;
                         &#x27;      File tempFile = new File(getFilePath());\n&#x27;
                         &#x27;      for (int i = 0; i &lt; threadNum; i++) {\n&#x27;
                         &#x27;        ThreadRecord tRecord = new ThreadRecord();\n&#x27;
                         &#x27;        tRecord.key = mRecord.filePath;\n&#x27;
                         &#x27;        Object state = &#x27;
                         &#x27;pro.getProperty(tempFile.getName() + STATE + i);\n&#x27;
                         &#x27;        Object record = &#x27;
                         &#x27;pro.getProperty(tempFile.getName() + RECORD + i);\n&#x27;
                         &#x27;        if (state != null &amp;&amp; &#x27;
                         &#x27;Integer.parseInt(String.valueOf(state)) == 1) {\n&#x27;
                         &#x27;          tRecord.isComplete = true;\n&#x27;
                         &#x27;          continue;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (record != null) {\n&#x27;
                         &#x27;          long temp = &#x27;
                         &#x27;Long.parseLong(String.valueOf(record));\n&#x27;
                         &#x27;          tRecord.startLocation = temp &gt; 0 ? temp : &#x27;
                         &#x27;0;\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          tRecord.startLocation = 0;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        mRecord.threadRecords.add(tRecord);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      mConfigFile.delete();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 初始化任务记录，分配线程区间\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @param newRecord {@code true} 需要创建新{@link &#x27;
                         &#x27;TaskRecord}\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void initRecord(boolean newRecord) {\n&#x27;
                         &#x27;    if (newRecord) {\n&#x27;
                         &#x27;      mRecord = &#x27;
                         &#x27;createTaskRecord(getNewTaskThreadNum());\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    mTaskWrapper.setNewTask(true);\n&#x27;
                         &#x27;    // 处理线程区间记录\n&#x27;
                         &#x27;    int requestType = &#x27;
                         &#x27;mTaskWrapper.getRequestType();\n&#x27;
                         &#x27;    long blockSize = mEntity.getFileSize() / &#x27;
                         &#x27;mRecord.threadNum;\n&#x27;
                         &#x27;    for (int i = 0; i &lt; mRecord.threadNum; i++) {\n&#x27;
                         &#x27;      long startL = i * blockSize, endL = (i + 1) * &#x27;
                         &#x27;blockSize;\n&#x27;
                         &#x27;      ThreadRecord tr;\n&#x27;
                         &#x27;      tr = new ThreadRecord();\n&#x27;
                         &#x27;      tr.key = mRecord.filePath;\n&#x27;
                         &#x27;      tr.threadId = i;\n&#x27;
                         &#x27;      tr.startLocation = startL;\n&#x27;
                         &#x27;      tr.isComplete = false;\n&#x27;
                         &#x27;      if (requestType == ITaskWrapper.M3U8_FILE) {\n&#x27;
                         &#x27;        tr.startLocation = 0;\n&#x27;
                         &#x27;        tr.threadType = TaskRecord.TYPE_M3U8;\n&#x27;
                         &#x27;        tr.m3u8url = ((DTaskWrapper) &#x27;
                         &#x27;mTaskWrapper).asM3U8().getUrls().get(i);\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        tr.threadType = TaskRecord.TYPE_HTTP_FTP;\n&#x27;
                         &#x27;        //最后一个线程的结束位置即为文件的总长度\n&#x27;
                         &#x27;        if (i == (mRecord.threadNum - 1)) {\n&#x27;
                         &#x27;          endL = mEntity.getFileSize();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        tr.endLocation = endL;\n&#x27;
                         &#x27;        tr.blockLen = &#x27;
                         &#x27;CommonUtil.getBlockLen(mEntity.getFileSize(), i, &#x27;
                         &#x27;mRecord.threadNum);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      mRecord.threadRecords.add(tr);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 创建任务记录\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @param threadNum 线程总数\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private TaskRecord createTaskRecord(int threadNum) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;    TaskRecord record = new TaskRecord();\n&#x27;
                         &#x27;    record.fileName = mEntity.getFileName();\n&#x27;
                         &#x27;    record.filePath = getFilePath();\n&#x27;
                         &#x27;    record.threadRecords = new ArrayList&lt;&gt;();\n&#x27;
                         &#x27;    record.threadNum = threadNum;\n&#x27;
                         &#x27;    // 处理分块和动态文件参数\n&#x27;
                         &#x27;    if (getRecordType() == TYPE_DOWNLOAD) {\n&#x27;
                         &#x27;      record.isBlock = threadNum &gt; 1 &amp;&amp; &#x27;
                         &#x27;Configuration.getInstance().downloadCfg.isUseBlock();\n&#x27;
                         &#x27;      // 线程数为1，或者使用了分块，则认为是使用动态长度文件\n&#x27;
                         &#x27;      record.isOpenDynamicFile = threadNum == 1 || &#x27;
                         &#x27;record.isBlock;\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      record.isBlock = false;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    if (mTaskWrapper.getRequestType() == &#x27;
                         &#x27;ITaskWrapper.M3U8_FILE) {\n&#x27;
                         &#x27;      record.taskType = TaskRecord.TYPE_M3U8;\n&#x27;
                         &#x27;      record.isOpenDynamicFile = true;\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      record.taskType = TaskRecord.TYPE_HTTP_FTP;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    record.isGroupRecord = mEntity.isGroupChild();\n&#x27;
                         &#x27;    if (record.isGroupRecord) {\n&#x27;
                         &#x27;      if (mEntity instanceof DownloadEntity) {\n&#x27;
                         &#x27;        record.dGroupHash = ((DownloadEntity) &#x27;
                         &#x27;mEntity).getGroupHash();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    return record;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 保存任务记录\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void saveRecord() {\n&#x27;
                         &#x27;    mRecord.threadNum = &#x27;
                         &#x27;mRecord.threadRecords.size();\n&#x27;
                         &#x27;    mRecord.save();\n&#x27;
                         &#x27;    DbEntity.saveAll(mRecord.threadRecords);\n&#x27;
                         &#x27;    ALog.d(TAG, String.format(&quot;保存记录，线程记录数：%s&quot;, &#x27;
                         &#x27;mRecord.threadRecords.size()));\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取记录类型\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @return {@link #TYPE_DOWNLOAD}、{@link &#x27;
                         &#x27;#TYPE_UPLOAD}\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private int getRecordType() {\n&#x27;
                         &#x27;    if (mEntity instanceof DownloadEntity) {\n&#x27;
                         &#x27;      return TYPE_DOWNLOAD;\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      return TYPE_UPLOAD;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 获取任务路径\n&#x27;
                         &#x27;   *\n&#x27;
                         &#x27;   * @return 任务文件路径\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private String getFilePath() {\n&#x27;
                         &#x27;    if (mEntity instanceof DownloadEntity) {\n&#x27;
                         &#x27;      return ((DownloadEntity) &#x27;
                         &#x27;mTaskWrapper.getEntity()).getFilePath();\n&#x27;
                         &#x27;    } else {\n&#x27;
                         &#x27;      return ((UploadEntity) &#x27;
                         &#x27;mTaskWrapper.getEntity()).getFilePath();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 小于1m的文件或是任务组的子任务、线程数强制为1\n&#x27;
                         &#x27;   * 不支持断点或chunked模式的线程数都为，线程数强制为1\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private int getNewTaskThreadNum() {\n&#x27;
                         &#x27;    if (getRecordType() == TYPE_DOWNLOAD) {\n&#x27;
                         &#x27;      if (mTaskWrapper.getRequestType() == &#x27;
                         &#x27;ITaskWrapper.M3U8_FILE) {\n&#x27;
                         &#x27;        return ((DTaskWrapper) &#x27;
                         &#x27;mTaskWrapper).asM3U8().getUrls().size();\n&#x27;
                         &#x27;      }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.DownloadEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.core.inf.AbsNormalEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.core.inf.AbsTaskWrapper;\n&#x27;
                           &#x27;import com.arialyy.aria.core.upload.UploadEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.orm.DbEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.util.ALog;\n&#x27;
                           &#x27;import com.arialyy.aria.util.CommonUtil;\n&#x27;
                           &#x27;import com.arialyy.aria.util.DbDataHelper;\n&#x27;
                           &#x27;import java.io.File;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;import java.util.HashSet;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;import java.util.Properties;\n&#x27;
                           &#x27;import java.util.Set;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * 处理任务记录，分配线程区间\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class RecordHandler {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  public static final int TYPE_DOWNLOAD = 1;\n&#x27;
                           &#x27;  public static final int TYPE_UPLOAD = 2;\n&#x27;
                           &#x27;  private final String TAG = &quot;RecordHandler&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private static final String STATE = &quot;_state_&quot;;\n&#x27;
                           &#x27;  private static final String RECORD = &#x27;
                           &#x27;&quot;_record_&quot;;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 小于1m的文件不启用多线程\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private static final long SUB_LEN = 1024 * &#x27;
                           &#x27;1024;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 分块文件路径\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  public static final String SUB_PATH = &#x27;
                           &#x27;&quot;%s.%s.part&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Deprecated private File mConfigFile;\n&#x27;
                           &#x27;  private TaskRecord mRecord;\n&#x27;
                           &#x27;  private AbsTaskWrapper mTaskWrapper;\n&#x27;
                           &#x27;  private AbsNormalEntity mEntity;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  RecordHandler(AbsTaskWrapper wrapper) {\n&#x27;
                           &#x27;    mTaskWrapper = wrapper;\n&#x27;
                           &#x27;    mEntity = (AbsNormalEntity) &#x27;
                           &#x27;mTaskWrapper.getEntity();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 获取任务记录，如果任务记录存在，检查任务记录\n&#x27;
                           &#x27;   * 检查记录 对于分块任务： 子分块不存在或被删除，子线程将重新下载\n&#x27;
                           &#x27;   * 对于普通任务： 预下载文件不存在，则任务任务呗删除\n&#x27;
                           &#x27;   * 如果任务记录不存在或线程记录不存在，初始化记录\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return 任务记录\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  TaskRecord getRecord() {\n&#x27;
                           &#x27;    mConfigFile = new &#x27;
                           &#x27;File(CommonUtil.getFileConfigPath(false, &#x27;
                           &#x27;mEntity.getFileName()));\n&#x27;
                           &#x27;    if (mConfigFile.exists()) {\n&#x27;
                           &#x27;      convertDb();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      mRecord = &#x27;
                           &#x27;DbDataHelper.getTaskRecord(getFilePath());\n&#x27;
                           &#x27;      if (mRecord == null) {\n&#x27;
                           &#x27;        initRecord(true);\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        if (mRecord.threadRecords == null || &#x27;
                           &#x27;mRecord.threadRecords.isEmpty()) {\n&#x27;
                           &#x27;          initRecord(false);\n&#x27;
                           &#x27;        } else if (mRecord.isBlock) {\n&#x27;
                           &#x27;          handleBlockRecord();\n&#x27;
                           &#x27;        } else if (!mTaskWrapper.isSupportBP()) {\n&#x27;
                           &#x27;          handleNoSupportBPRecord();\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          handleSingleThreadRecord();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    saveRecord();\n&#x27;
                           &#x27;    return mRecord;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理不支持断点的记录\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleNoSupportBPRecord() {\n&#x27;
                           &#x27;    ThreadRecord tr = &#x27;
                           &#x27;mRecord.threadRecords.get(0);\n&#x27;
                           &#x27;    tr.startLocation = 0;\n&#x27;
                           &#x27;    tr.endLocation = mEntity.getFileSize();\n&#x27;
                           &#x27;    tr.key = mRecord.filePath;\n&#x27;
                           &#x27;    tr.blockLen = tr.endLocation;\n&#x27;
                           &#x27;    tr.isComplete = false;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 处理单线程的任务的记录\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleSingleThreadRecord() {\n&#x27;
                           &#x27;    File file = new File(mRecord.filePath);\n&#x27;
                           &#x27;    ThreadRecord tr = &#x27;
                           &#x27;mRecord.threadRecords.get(0);\n&#x27;
                           &#x27;    if (!file.exists()) {\n&#x27;
                           &#x27;      ALog.w(TAG, &#x27;
                           &#x27;String.format(&quot;文件【%s】不存在，任务将重新开始&quot;, &#x27;
                           &#x27;file.getPath()));\n&#x27;
                           &#x27;      tr.startLocation = 0;\n&#x27;
                           &#x27;      tr.isComplete = false;\n&#x27;
                           &#x27;      tr.endLocation = mEntity.getFileSize();\n&#x27;
                           &#x27;    } else if (mRecord.isOpenDynamicFile) {\n&#x27;
                           &#x27;      if (file.length() &gt; mEntity.getFileSize()) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;文件【%s】错误，任务重新开始&quot;, &#x27;
                           &#x27;file.getPath()));\n&#x27;
                           &#x27;        file.delete();\n&#x27;
                           &#x27;        tr.startLocation = 0;\n&#x27;
                           &#x27;        tr.isComplete = false;\n&#x27;
                           &#x27;        tr.endLocation = mEntity.getFileSize();\n&#x27;
                           &#x27;      } else if (file.length() == &#x27;
                           &#x27;mEntity.getFileSize()) {\n&#x27;
                           &#x27;        tr.isComplete = true;\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        if (file.length() != tr.startLocation) {\n&#x27;
                           &#x27;          ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;修正【%s】的进度记录为：%s&quot;, file.getPath(), &#x27;
                           &#x27;file.length()));\n&#x27;
                           &#x27;          tr.startLocation = file.length();\n&#x27;
                           &#x27;          tr.isComplete = false;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    mTaskWrapper.setNewTask(false);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * &#x27;
                           &#x27;处理分块任务的记录，分块文件（blockFileLen）长度必须需要小于等于线程区间（threadRectLen）的长度\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void handleBlockRecord() {\n&#x27;
                           &#x27;    // 默认线程分块长度\n&#x27;
                           &#x27;    long normalRectLen = mEntity.getFileSize() / &#x27;
                           &#x27;mRecord.threadRecords.size();\n&#x27;
                           &#x27;    for (ThreadRecord tr : mRecord.threadRecords) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;      long threadRect = tr.blockLen;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      File temp = new File(String.format(SUB_PATH, &#x27;
                           &#x27;mRecord.filePath, tr.threadId));\n&#x27;
                           &#x27;      if (!temp.exists()) {\n&#x27;
                           &#x27;        ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;分块文件【%s】不存在，该分块将重新开始&quot;, &#x27;
                           &#x27;temp.getPath()));\n&#x27;
                           &#x27;        tr.isComplete = false;\n&#x27;
                           &#x27;        tr.startLocation = tr.threadId * &#x27;
                           &#x27;normalRectLen;\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        if (!tr.isComplete) {\n&#x27;
                           &#x27;          ALog.i(TAG, String.format(\n&#x27;
                           &#x27;              &quot;startLocation = %s; endLocation = &#x27;
                           &#x27;%s; block = %s; tempLen = %s; threadId = %s&quot;,\n&#x27;
                           &#x27;              tr.startLocation, tr.endLocation, &#x27;
                           &#x27;threadRect, temp.length(), tr.threadId));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;          long blockFileLen = temp.length(); // &#x27;
                           &#x27;磁盘中的分块文件长度\n&#x27;
                           &#x27;          /*\n&#x27;
                           &#x27;           * 检查磁盘中的分块文件\n&#x27;
                           &#x27;           */\n&#x27;
                           &#x27;          if (blockFileLen &gt; threadRect) {\n&#x27;
                           &#x27;            ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;分块【%s】错误，分块长度【%s】 &gt; &#x27;
                           &#x27;线程区间长度【%s】，将重新开始该分块&quot;,\n&#x27;
                           &#x27;                tr.threadId, blockFileLen, &#x27;
                           &#x27;threadRect));\n&#x27;
                           &#x27;            temp.delete();\n&#x27;
                           &#x27;            tr.startLocation = tr.threadId * &#x27;
                           &#x27;threadRect;\n&#x27;
                           &#x27;            continue;\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;          long realLocation =\n&#x27;
                           &#x27;              tr.threadId * normalRectLen + &#x27;
                           &#x27;blockFileLen; //正常情况下，该线程的startLocation的位置\n&#x27;
                           &#x27;          /*\n&#x27;
                           &#x27;           * 检查记录文件\n&#x27;
                           &#x27;           */\n&#x27;
                           &#x27;          if (blockFileLen == threadRect) {\n&#x27;
                           &#x27;            ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;分块【%s】已完成，更新记录&quot;, temp.getPath()));\n&#x27;
                           &#x27;            tr.startLocation = blockFileLen;\n&#x27;
                           &#x27;            tr.isComplete = true;\n&#x27;
                           &#x27;          } else if (tr.startLocation != &#x27;
                           &#x27;realLocation) { // 处理记录小于分块文件长度的情况\n&#x27;
                           &#x27;            ALog.i(TAG, &#x27;
                           &#x27;String.format(&quot;修正分块【%s】的进度记录为：%s&quot;, temp.getPath(), &#x27;
                           &#x27;realLocation));\n&#x27;
                           &#x27;            tr.startLocation = realLocation;\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          ALog.i(TAG, String.format(&quot;分块【%s】已完成&quot;, &#x27;
                           &#x27;temp.getPath()));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    mTaskWrapper.setNewTask(false);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * convertDb 是兼容性代码 从3.4.1开始，线程配置信息将存储在数据库中。 &#x27;
                           &#x27;将配置文件的内容复制到数据库中，并将配置文件删除\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void convertDb() {\n&#x27;
                           &#x27;    List&lt;RecordWrapper&gt; records =\n&#x27;
                           &#x27;        &#x27;
                           &#x27;DbEntity.findRelationData(RecordWrapper.class, &#x27;
                           &#x27;&quot;TaskRecord.filePath=?&quot;,\n&#x27;
                           &#x27;            getFilePath());\n&#x27;
                           &#x27;    if (records == null || records.size() == 0) {\n&#x27;
                           &#x27;      Properties pro = &#x27;
                           &#x27;CommonUtil.loadConfig(mConfigFile);\n&#x27;
                           &#x27;      if (pro.isEmpty()) {\n&#x27;
                           &#x27;        ALog.d(TAG, &quot;老版本的线程记录为空，任务为新任务&quot;);\n&#x27;
                           &#x27;        initRecord(true);\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      Set&lt;Object&gt; keys = pro.keySet();\n&#x27;
                           &#x27;      // &#x27;
                           &#x27;老版本记录是5s存一次，但是5s中内，如果线程执行完成，record记录是没有的，只有state记录...\n&#x27;
                           &#x27;      // 第一步应该是record 和 state去重取正确的线程数\n&#x27;
                           &#x27;      Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\n&#x27;
                           &#x27;      for (Object key : keys) {\n&#x27;
                           &#x27;        String str = String.valueOf(key);\n&#x27;
                           &#x27;        int i = &#x27;
                           &#x27;Integer.parseInt(str.substring(str.length() - &#x27;
                           &#x27;1));\n&#x27;
                           &#x27;        set.add(i);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      int threadNum = set.size();\n&#x27;
                           &#x27;      if (threadNum == 0) {\n&#x27;
                           &#x27;        ALog.d(TAG, &quot;线程数为空，任务为新任务&quot;);\n&#x27;
                           &#x27;        initRecord(true);\n&#x27;
                           &#x27;        return;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mTaskWrapper.setNewTask(false);\n&#x27;
                           &#x27;      mRecord = createTaskRecord(threadNum);\n&#x27;
                           &#x27;      mRecord.isOpenDynamicFile = false;\n&#x27;
                           &#x27;      mRecord.isBlock = false;\n&#x27;
                           &#x27;      File tempFile = new File(getFilePath());\n&#x27;
                           &#x27;      for (int i = 0; i &lt; threadNum; i++) {\n&#x27;
                           &#x27;        ThreadRecord tRecord = new &#x27;
                           &#x27;ThreadRecord();\n&#x27;
                           &#x27;        tRecord.key = mRecord.filePath;\n&#x27;
                           &#x27;        Object state = &#x27;
                           &#x27;pro.getProperty(tempFile.getName() + STATE + i);\n&#x27;
                           &#x27;        Object record = &#x27;
                           &#x27;pro.getProperty(tempFile.getName() + RECORD + i);\n&#x27;
                           &#x27;        if (state != null &amp;&amp; &#x27;
                           &#x27;Integer.parseInt(String.valueOf(state)) == 1) {\n&#x27;
                           &#x27;          tRecord.isComplete = true;\n&#x27;
                           &#x27;          continue;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (record != null) {\n&#x27;
                           &#x27;          long temp = &#x27;
                           &#x27;Long.parseLong(String.valueOf(record));\n&#x27;
                           &#x27;          tRecord.startLocation = temp &gt; 0 ? temp &#x27;
                           &#x27;: 0;\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          tRecord.startLocation = 0;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        mRecord.threadRecords.add(tRecord);\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      mConfigFile.delete();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 初始化任务记录，分配线程区间\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param newRecord {@code true} 需要创建新{@link &#x27;
                           &#x27;TaskRecord}\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void initRecord(boolean newRecord) {\n&#x27;
                           &#x27;    if (newRecord) {\n&#x27;
                           &#x27;      mRecord = &#x27;
                           &#x27;createTaskRecord(getNewTaskThreadNum());\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    mTaskWrapper.setNewTask(true);\n&#x27;
                           &#x27;    // 处理线程区间记录\n&#x27;
                           &#x27;    long blockSize = mEntity.getFileSize() / &#x27;
                           &#x27;mRecord.threadNum;\n&#x27;
                           &#x27;    for (int i = 0; i &lt; mRecord.threadNum; i++) {\n&#x27;
                           &#x27;      long startL = i * blockSize, endL = (i + 1) &#x27;
                           &#x27;* blockSize;\n&#x27;
                           &#x27;      ThreadRecord tr;\n&#x27;
                           &#x27;      tr = new ThreadRecord();\n&#x27;
                           &#x27;      tr.key = mRecord.filePath;\n&#x27;
                           &#x27;      tr.threadId = i;\n&#x27;
                           &#x27;      tr.startLocation = startL;\n&#x27;
                           &#x27;      //最后一个线程的结束位置即为文件的总长度\n&#x27;
                           &#x27;      if (i == (mRecord.threadNum - 1)) {\n&#x27;
                           &#x27;        endL = mEntity.getFileSize();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;      tr.endLocation = endL;\n&#x27;
                           &#x27;      tr.blockLen = &#x27;
                           &#x27;CommonUtil.getBlockLen(mEntity.getFileSize(), i, &#x27;
                           &#x27;mRecord.threadNum);\n&#x27;
                           &#x27;      mRecord.threadRecords.add(tr);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 创建任务记录\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @param threadNum 线程总数\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private TaskRecord createTaskRecord(int &#x27;
                           &#x27;threadNum) {\n&#x27;
                           &#x27;    TaskRecord record = new TaskRecord();\n&#x27;
                           &#x27;    record.fileName = mEntity.getFileName();\n&#x27;
                           &#x27;    record.filePath = getFilePath();\n&#x27;
                           &#x27;    record.threadRecords = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;    record.threadNum = threadNum;\n&#x27;
                           &#x27;    // 处理分块和动态文件参数\n&#x27;
                           &#x27;    if (getRecordType() == TYPE_DOWNLOAD) {\n&#x27;
                           &#x27;      record.isBlock = threadNum &gt; 1 &amp;&amp; &#x27;
                           &#x27;Configuration.getInstance().downloadCfg.isUseBlock();\n&#x27;
                           &#x27;      // 线程数为1，或者使用了分块，则认为是使用动态长度文件\n&#x27;
                           &#x27;      record.isOpenDynamicFile = threadNum == 1 || &#x27;
                           &#x27;record.isBlock;\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      record.isBlock = false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    record.isGroupRecord = &#x27;
                           &#x27;mEntity.isGroupChild();\n&#x27;
                           &#x27;    if (record.isGroupRecord) {\n&#x27;
                           &#x27;      if (mEntity instanceof DownloadEntity) {\n&#x27;
                           &#x27;        record.dGroupHash = ((DownloadEntity) &#x27;
                           &#x27;mEntity).getGroupHash();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    return record;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 保存任务记录\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private void saveRecord() {\n&#x27;
                           &#x27;    mRecord.threadNum = &#x27;
                           &#x27;mRecord.threadRecords.size();\n&#x27;
                           &#x27;    mRecord.save();\n&#x27;
                           &#x27;    DbEntity.saveAll(mRecord.threadRecords);\n&#x27;
                           &#x27;    ALog.d(TAG, String.format(&quot;保存记录，线程记录数：%s&quot;, &#x27;
                           &#x27;mRecord.threadRecords.size()));\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 获取记录类型\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return {@link #TYPE_DOWNLOAD}、{@link &#x27;
                           &#x27;#TYPE_UPLOAD}\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private int getRecordType() {\n&#x27;
                           &#x27;    if (mEntity instanceof DownloadEntity) {\n&#x27;
                           &#x27;      return TYPE_DOWNLOAD;\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      return TYPE_UPLOAD;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 获取任务路径\n&#x27;
                           &#x27;   *\n&#x27;
                           &#x27;   * @return 任务文件路径\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private String getFilePath() {\n&#x27;
                           &#x27;    if (mEntity instanceof DownloadEntity) {\n&#x27;
                           &#x27;      return ((DownloadEntity) &#x27;
                           &#x27;mTaskWrapper.getEntity()).getFilePath();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      return ((UploadEntity) &#x27;
                           &#x27;mTaskWrapper.getEntity()).getFilePath();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /**\n&#x27;
                           &#x27;   * 小于1m的文件或是任务组的子任务、线程数强制为1\n&#x27;
                           &#x27;   * 不支持断点或chunked模式的线程数都为，线程数强制为1\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private int getNewTaskThreadNum() {\n&#x27;
                           &#x27;    if (getRecordType() == TYPE_DOWNLOAD) {\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        