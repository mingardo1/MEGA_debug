<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>181</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    181
                    <a href="180.html">prev</a>
                    <a href="182.html">next</a>
                    <a href="181_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_7a3235c598fa46fbc540746648f129f6ef8dc647_WallpaperPicker/src/com/android/gallery3d/glrenderer/UploadedTexture.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;7a3235c598fa46fbc540746648f129f6ef8dc647:WallpaperPicker/src/com/android/gallery3d/glrenderer/UploadedTexture.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;7a3235c598fa46fbc540746648f129f6ef8dc647^1:WallpaperPicker/src/com/android/gallery3d/glrenderer/UploadedTexture.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;7a3235c598fa46fbc540746648f129f6ef8dc647^2:WallpaperPicker/src/com/android/gallery3d/glrenderer/UploadedTexture.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;42ea0db8892020cc07046979892460bad55d2b45:WallpaperPicker/src/com/android/gallery3d/glrenderer/UploadedTexture.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [bj]], subset: [[b], [bj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2010 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.gallery3d.glrenderer;
  18 
  19 import android.graphics.Bitmap;
  20 import android.graphics.Bitmap.Config;
  21 import android.opengl.GLUtils;
  22 
  23 import com.android.gallery3d.common.Utils;
  24 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  25 import com.android.launcher3.util.Thunk;</span>
  26 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  27 </span>
  28 =======
  29 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  30 
  31 import java.util.HashMap;
  32 
  33 import javax.microedition.khronos.opengles.GL11;
  34 
  35 // UploadedTextures use a Bitmap for the content of the texture.
  36 //
  37 // Subclasses should implement onGetBitmap() to provide the Bitmap and
  38 // implement onFreeBitmap(mBitmap) which will be called when the Bitmap
  39 // is not needed anymore.
  40 //
  41 // isContentValid() is meaningful only when the isLoaded() returns true.
  42 // It means whether the content needs to be updated.
  43 //
  44 // The user of this class should call recycle() when the texture is not
  45 // needed anymore.
  46 //
  47 // By default an UploadedTexture is opaque (so it can be drawn faster without
  48 // blending). The user or subclass can override it using setOpaque().
  49 public abstract class UploadedTexture extends BasicTexture {
  50 
  51     // To prevent keeping allocation the borders, we store those used borders here.
  52     // Since the length will be power of two, it won&#x27;t use too much memory.
  53     private static HashMap&lt;BorderKey, Bitmap&gt; sBorderLines =
  54             new HashMap&lt;BorderKey, Bitmap&gt;();
  55     private static BorderKey sBorderKey = new BorderKey();
  56 
  57     @SuppressWarnings(&quot;unused&quot;)
  58     private static final String TAG = &quot;Texture&quot;;
  59     private boolean mContentValid = true;
  60 
  61     // indicate this textures is being uploaded in background
  62     private boolean mIsUploading = false;
  63     private boolean mOpaque = true;
  64     private boolean mThrottled = false;
  65     private static int sUploadedCount;
  66     private static final int UPLOAD_LIMIT = 100;
  67 
  68     protected Bitmap mBitmap;
  69     private int mBorder;
  70 
  71     protected UploadedTexture() {
  72         this(false);
  73     }
  74 
  75     protected UploadedTexture(boolean hasBorder) {
  76         super(null, 0, STATE_UNLOADED);
  77         if (hasBorder) {
  78             setBorder(true);
  79             mBorder = 1;
  80         }
  81     }
  82 
  83     protected void setIsUploading(boolean uploading) {
  84         mIsUploading = uploading;
  85     }
  86 
  87     public boolean isUploading() {
  88         return mIsUploading;
  89     }
  90 
  91     @Thunk static class BorderKey implements Cloneable {
  92         public boolean vertical;
  93         public Config config;
  94         public int length;
  95 
  96         @Override
  97         public int hashCode() {
  98             int x = config.hashCode() ^ length;
  99             return vertical ? x : -x;
 100         }
 101 
 102         @Override
 103         public boolean equals(Object object) {
 104             if (!(object instanceof BorderKey)) return false;
 105             BorderKey o = (BorderKey) object;
 106             return vertical == o.vertical
 107                     &amp;&amp; config == o.config &amp;&amp; length == o.length;
 108         }
 109 
 110         @Override
 111         public BorderKey clone() {
 112             try {
 113                 return (BorderKey) super.clone();
 114             } catch (CloneNotSupportedException e) {
 115                 throw new AssertionError(e);
 116             }
 117         }
 118     }
 119 
 120     protected void setThrottled(boolean throttled) {
 121         mThrottled = throttled;
 122     }
 123 
 124     private static Bitmap getBorderLine(
 125             boolean vertical, Config config, int length) {
 126         BorderKey key = sBorderKey;
 127         key.vertical = vertical;
 128         key.config = config;
 129         key.length = length;
 130         Bitmap bitmap = sBorderLines.get(key);
 131         if (bitmap == null) {
 132             bitmap = vertical
 133                     ? Bitmap.createBitmap(1, length, config)
 134                     : Bitmap.createBitmap(length, 1, config);
 135             sBorderLines.put(key.clone(), bitmap);
 136         }
 137         return bitmap;
 138     }
 139 
 140     private Bitmap getBitmap() {
 141         if (mBitmap == null) {
 142             mBitmap = onGetBitmap();
 143             int w = mBitmap.getWidth() + mBorder * 2;
 144             int h = mBitmap.getHeight() + mBorder * 2;
 145             if (mWidth == UNSPECIFIED) {
 146                 setSize(w, h);
 147             }
 148         }
 149         return mBitmap;
 150     }
 151 
 152     private void freeBitmap() {
 153         Utils.assertTrue(mBitmap != null);
 154         onFreeBitmap(mBitmap);
 155         mBitmap = null;
 156     }
 157 
 158     @Override
 159     public int getWidth() {
 160         if (mWidth == UNSPECIFIED) getBitmap();
 161         return mWidth;
 162     }
 163 
 164     @Override
 165     public int getHeight() {
 166         if (mWidth == UNSPECIFIED) getBitmap();
 167         return mHeight;
 168     }
 169 
 170     protected abstract Bitmap onGetBitmap();
 171 
 172     protected abstract void onFreeBitmap(Bitmap bitmap);
 173 
 174     protected void invalidateContent() {
 175         if (mBitmap != null) freeBitmap();
 176         mContentValid = false;
 177         mWidth = UNSPECIFIED;
 178         mHeight = UNSPECIFIED;
 179     }
 180 
 181     /**
 182      * Whether the content on GPU is valid.
 183      */
 184     public boolean isContentValid() {
 185         return isLoaded() &amp;&amp; mContentValid;
 186     }
 187 
 188     /**
 189      * Updates the content on GPU&#x27;s memory.
 190      * @param canvas
 191      */
 192     public void updateContent(GLCanvas canvas) {
 193         if (!isLoaded()) {
 194             if (mThrottled &amp;&amp; ++sUploadedCount &gt; UPLOAD_LIMIT) {
 195                 return;
 196             }
 197             uploadToCanvas(canvas);
 198         } else if (!mContentValid) {
 199             Bitmap bitmap = getBitmap();
 200             int format = GLUtils.getInternalFormat(bitmap);
 201             int type = GLUtils.getType(bitmap);
 202             canvas.texSubImage2D(this, mBorder, mBorder, bitmap, format, type);
 203             freeBitmap();
 204             mContentValid = true;
 205         }
 206     }
 207 
 208     public static void resetUploadLimit() {
 209         sUploadedCount = 0;
 210     }
 211 
 212     public static boolean uploadLimitReached() {
 213         return sUploadedCount &gt; UPLOAD_LIMIT;
 214     }
 215 
 216     private void uploadToCanvas(GLCanvas canvas) {
 217 
 218         Bitmap bitmap = getBitmap();
 219         if (bitmap != null) {
 220             try {
 221                 int bWidth = bitmap.getWidth();
 222                 int bHeight = bitmap.getHeight();
 223                 int width = bWidth + mBorder * 2;
 224                 int height = bHeight + mBorder * 2;
 225                 int texWidth = getTextureWidth();
 226                 int texHeight = getTextureHeight();
 227 
 228 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 229                 Utils.assertTrue(bWidth &lt;= texWidth &amp;&amp; bHeight &lt;= texHeight);</span>
 230 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 231                 Assert.assertTrue(bWidth &lt;= texWidth &amp;&amp; bHeight &lt;= texHeight);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 232 </span>
 233 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 234                 assertTrue(bWidth &lt;= texWidth &amp;&amp; bHeight &lt;= texHeight);</span>
 235 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 236 
 237                 // Upload the bitmap to a new texture.
 238                 mId = canvas.getGLId().generateTexture();
 239                 canvas.setTextureParameters(this);
 240 
 241                 if (bWidth == texWidth &amp;&amp; bHeight == texHeight) {
 242                     canvas.initializeTexture(this, bitmap);
 243                 } else {
 244                     int format = GLUtils.getInternalFormat(bitmap);
 245                     int type = GLUtils.getType(bitmap);
 246                     Config config = bitmap.getConfig();
 247 
 248                     canvas.initializeTextureSize(this, format, type);
 249                     canvas.texSubImage2D(this, mBorder, mBorder, bitmap, format, type);
 250 
 251                     if (mBorder &gt; 0) {
 252                         // Left border
 253                         Bitmap line = getBorderLine(true, config, texHeight);
 254                         canvas.texSubImage2D(this, 0, 0, line, format, type);
 255 
 256                         // Top border
 257                         line = getBorderLine(false, config, texWidth);
 258                         canvas.texSubImage2D(this, 0, 0, line, format, type);
 259                     }
 260 
 261                     // Right border
 262                     if (mBorder + bWidth &lt; texWidth) {
 263                         Bitmap line = getBorderLine(true, config, texHeight);
 264                         canvas.texSubImage2D(this, mBorder + bWidth, 0, line, format, type);
 265                     }
 266 
 267                     // Bottom border
 268                     if (mBorder + bHeight &lt; texHeight) {
 269                         Bitmap line = getBorderLine(false, config, texWidth);
 270                         canvas.texSubImage2D(this, 0, mBorder + bHeight, line, format, type);
 271                     }
 272                 }
 273             } finally {
 274                 freeBitmap();
 275             }
 276             // Update texture state.
 277             setAssociatedCanvas(canvas);
 278             mState = STATE_LOADED;
 279             mContentValid = true;
 280         } else {
 281             mState = STATE_ERROR;
 282             throw new RuntimeException(&quot;Texture load fail, no bitmap&quot;);
 283         }
 284     }
 285 
 286     @Override
 287     protected boolean onBind(GLCanvas canvas) {
 288         updateContent(canvas);
 289         return isContentValid();
 290     }
 291 
 292     @Override
 293     protected int getTarget() {
 294         return GL11.GL_TEXTURE_2D;
 295     }
 296 
 297     public void setOpaque(boolean isOpaque) {
 298         mOpaque = isOpaque;
 299     }
 300 
 301     @Override
 302     public boolean isOpaque() {
 303         return mOpaque;
 304     }
 305 
 306     @Override
 307     public void recycle() {
 308         super.recycle();
 309         if (mBitmap != null) freeBitmap();
 310     }
 311 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2010 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.gallery3d.glrenderer;
  18 
  19 import android.graphics.Bitmap;
  20 import android.graphics.Bitmap.Config;
  21 import android.opengl.GLUtils;
  22 
  23 import com.android.gallery3d.common.Utils;
  24 import com.android.launcher3.util.Thunk;
  25 
  26 import java.util.HashMap;
  27 
  28 import javax.microedition.khronos.opengles.GL11;
  29 
  30 // UploadedTextures use a Bitmap for the content of the texture.
  31 //
  32 // Subclasses should implement onGetBitmap() to provide the Bitmap and
  33 // implement onFreeBitmap(mBitmap) which will be called when the Bitmap
  34 // is not needed anymore.
  35 //
  36 // isContentValid() is meaningful only when the isLoaded() returns true.
  37 // It means whether the content needs to be updated.
  38 //
  39 // The user of this class should call recycle() when the texture is not
  40 // needed anymore.
  41 //
  42 // By default an UploadedTexture is opaque (so it can be drawn faster without
  43 // blending). The user or subclass can override it using setOpaque().
  44 public abstract class UploadedTexture extends BasicTexture {
  45 
  46     // To prevent keeping allocation the borders, we store those used borders here.
  47     // Since the length will be power of two, it won&#x27;t use too much memory.
  48     private static HashMap&lt;BorderKey, Bitmap&gt; sBorderLines =
  49             new HashMap&lt;BorderKey, Bitmap&gt;();
  50     private static BorderKey sBorderKey = new BorderKey();
  51 
  52     @SuppressWarnings(&quot;unused&quot;)
  53     private static final String TAG = &quot;Texture&quot;;
  54     private boolean mContentValid = true;
  55 
  56     // indicate this textures is being uploaded in background
  57     private boolean mIsUploading = false;
  58     private boolean mOpaque = true;
  59     private boolean mThrottled = false;
  60     private static int sUploadedCount;
  61     private static final int UPLOAD_LIMIT = 100;
  62 
  63     protected Bitmap mBitmap;
  64     private int mBorder;
  65 
  66     protected UploadedTexture() {
  67         this(false);
  68     }
  69 
  70     protected UploadedTexture(boolean hasBorder) {
  71         super(null, 0, STATE_UNLOADED);
  72         if (hasBorder) {
  73             setBorder(true);
  74             mBorder = 1;
  75         }
  76     }
  77 
  78     protected void setIsUploading(boolean uploading) {
  79         mIsUploading = uploading;
  80     }
  81 
  82     public boolean isUploading() {
  83         return mIsUploading;
  84     }
  85 
  86     @Thunk static class BorderKey implements Cloneable {
  87         public boolean vertical;
  88         public Config config;
  89         public int length;
  90 
  91         @Override
  92         public int hashCode() {
  93             int x = config.hashCode() ^ length;
  94             return vertical ? x : -x;
  95         }
  96 
  97         @Override
  98         public boolean equals(Object object) {
  99             if (!(object instanceof BorderKey)) return false;
 100             BorderKey o = (BorderKey) object;
 101             return vertical == o.vertical
 102                     &amp;&amp; config == o.config &amp;&amp; length == o.length;
 103         }
 104 
 105         @Override
 106         public BorderKey clone() {
 107             try {
 108                 return (BorderKey) super.clone();
 109             } catch (CloneNotSupportedException e) {
 110                 throw new AssertionError(e);
 111             }
 112         }
 113     }
 114 
 115     protected void setThrottled(boolean throttled) {
 116         mThrottled = throttled;
 117     }
 118 
 119     private static Bitmap getBorderLine(
 120             boolean vertical, Config config, int length) {
 121         BorderKey key = sBorderKey;
 122         key.vertical = vertical;
 123         key.config = config;
 124         key.length = length;
 125         Bitmap bitmap = sBorderLines.get(key);
 126         if (bitmap == null) {
 127             bitmap = vertical
 128                     ? Bitmap.createBitmap(1, length, config)
 129                     : Bitmap.createBitmap(length, 1, config);
 130             sBorderLines.put(key.clone(), bitmap);
 131         }
 132         return bitmap;
 133     }
 134 
 135     private Bitmap getBitmap() {
 136         if (mBitmap == null) {
 137             mBitmap = onGetBitmap();
 138             int w = mBitmap.getWidth() + mBorder * 2;
 139             int h = mBitmap.getHeight() + mBorder * 2;
 140             if (mWidth == UNSPECIFIED) {
 141                 setSize(w, h);
 142             }
 143         }
 144         return mBitmap;
 145     }
 146 
 147     private void freeBitmap() {
 148         Utils.assertTrue(mBitmap != null);
 149         onFreeBitmap(mBitmap);
 150         mBitmap = null;
 151     }
 152 
 153     @Override
 154     public int getWidth() {
 155         if (mWidth == UNSPECIFIED) getBitmap();
 156         return mWidth;
 157     }
 158 
 159     @Override
 160     public int getHeight() {
 161         if (mWidth == UNSPECIFIED) getBitmap();
 162         return mHeight;
 163     }
 164 
 165     protected abstract Bitmap onGetBitmap();
 166 
 167     protected abstract void onFreeBitmap(Bitmap bitmap);
 168 
 169     protected void invalidateContent() {
 170         if (mBitmap != null) freeBitmap();
 171         mContentValid = false;
 172         mWidth = UNSPECIFIED;
 173         mHeight = UNSPECIFIED;
 174     }
 175 
 176     /**
 177      * Whether the content on GPU is valid.
 178      */
 179     public boolean isContentValid() {
 180         return isLoaded() &amp;&amp; mContentValid;
 181     }
 182 
 183     /**
 184      * Updates the content on GPU&#x27;s memory.
 185      * @param canvas
 186      */
 187     public void updateContent(GLCanvas canvas) {
 188         if (!isLoaded()) {
 189             if (mThrottled &amp;&amp; ++sUploadedCount &gt; UPLOAD_LIMIT) {
 190                 return;
 191             }
 192             uploadToCanvas(canvas);
 193         } else if (!mContentValid) {
 194             Bitmap bitmap = getBitmap();
 195             int format = GLUtils.getInternalFormat(bitmap);
 196             int type = GLUtils.getType(bitmap);
 197             canvas.texSubImage2D(this, mBorder, mBorder, bitmap, format, type);
 198             freeBitmap();
 199             mContentValid = true;
 200         }
 201     }
 202 
 203     public static void resetUploadLimit() {
 204         sUploadedCount = 0;
 205     }
 206 
 207     public static boolean uploadLimitReached() {
 208         return sUploadedCount &gt; UPLOAD_LIMIT;
 209     }
 210 
 211     private void uploadToCanvas(GLCanvas canvas) {
 212 
 213         Bitmap bitmap = getBitmap();
 214         if (bitmap != null) {
 215             try {
 216                 int bWidth = bitmap.getWidth();
 217                 int bHeight = bitmap.getHeight();
 218                 int width = bWidth + mBorder * 2;
 219                 int height = bHeight + mBorder * 2;
 220                 int texWidth = getTextureWidth();
 221                 int texHeight = getTextureHeight();
 222 
 223 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 224                 Utils.assertTrue(bWidth &lt;= texWidth &amp;&amp; bHeight &lt;= texHeight);</span>
 225 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 226                 Assert.assertTrue(bWidth &lt;= texWidth &amp;&amp; bHeight &lt;= texHeight);</span>
 227 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 228                 assertTrue(bWidth &lt;= texWidth &amp;&amp; bHeight &lt;= texHeight);</span>
 229 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 230 
 231                 // Upload the bitmap to a new texture.
 232                 mId = canvas.getGLId().generateTexture();
 233                 canvas.setTextureParameters(this);
 234 
 235                 if (bWidth == texWidth &amp;&amp; bHeight == texHeight) {
 236                     canvas.initializeTexture(this, bitmap);
 237                 } else {
 238                     int format = GLUtils.getInternalFormat(bitmap);
 239                     int type = GLUtils.getType(bitmap);
 240                     Config config = bitmap.getConfig();
 241 
 242                     canvas.initializeTextureSize(this, format, type);
 243                     canvas.texSubImage2D(this, mBorder, mBorder, bitmap, format, type);
 244 
 245                     if (mBorder &gt; 0) {
 246                         // Left border
 247                         Bitmap line = getBorderLine(true, config, texHeight);
 248                         canvas.texSubImage2D(this, 0, 0, line, format, type);
 249 
 250                         // Top border
 251                         line = getBorderLine(false, config, texWidth);
 252                         canvas.texSubImage2D(this, 0, 0, line, format, type);
 253                     }
 254 
 255                     // Right border
 256                     if (mBorder + bWidth &lt; texWidth) {
 257                         Bitmap line = getBorderLine(true, config, texHeight);
 258                         canvas.texSubImage2D(this, mBorder + bWidth, 0, line, format, type);
 259                     }
 260 
 261                     // Bottom border
 262                     if (mBorder + bHeight &lt; texHeight) {
 263                         Bitmap line = getBorderLine(false, config, texWidth);
 264                         canvas.texSubImage2D(this, 0, mBorder + bHeight, line, format, type);
 265                     }
 266                 }
 267             } finally {
 268                 freeBitmap();
 269             }
 270             // Update texture state.
 271             setAssociatedCanvas(canvas);
 272             mState = STATE_LOADED;
 273             mContentValid = true;
 274         } else {
 275             mState = STATE_ERROR;
 276             throw new RuntimeException(&quot;Texture load fail, no bitmap&quot;);
 277         }
 278     }
 279 
 280     @Override
 281     protected boolean onBind(GLCanvas canvas) {
 282         updateContent(canvas);
 283         return isContentValid();
 284     }
 285 
 286     @Override
 287     protected int getTarget() {
 288         return GL11.GL_TEXTURE_2D;
 289     }
 290 
 291     public void setOpaque(boolean isOpaque) {
 292         mOpaque = isOpaque;
 293     }
 294 
 295     @Override
 296     public boolean isOpaque() {
 297         return mOpaque;
 298     }
 299 
 300     @Override
 301     public void recycle() {
 302         super.recycle();
 303         if (mBitmap != null) freeBitmap();
 304     }
 305 }
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2010 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.gallery3d.glrenderer;
  17 
  18 import android.graphics.Bitmap.Config;
  19 import android.graphics.Bitmap;
  20 import android.opengl.GLUtils;
  21 import com.android.gallery3d.common.Utils;
  22 import com.android.launcher3.util.Thunk;
  23 import java.util.HashMap;
  24 import javax.microedition.khronos.opengles.GL11;
  25 
  26 
  27 // UploadedTextures use a Bitmap for the content of the texture.
  28 //
  29 // Subclasses should implement onGetBitmap() to provide the Bitmap and
  30 // implement onFreeBitmap(mBitmap) which will be called when the Bitmap
  31 // is not needed anymore.
  32 //
  33 // isContentValid() is meaningful only when the isLoaded() returns true.
  34 // It means whether the content needs to be updated.
  35 //
  36 // The user of this class should call recycle() when the texture is not
  37 // needed anymore.
  38 //
  39 // By default an UploadedTexture is opaque (so it can be drawn faster without
  40 // blending). The user or subclass can override it using setOpaque().
  41 public abstract class UploadedTexture extends BasicTexture {
  42     // To prevent keeping allocation the borders, we store those used borders here.
  43     // Since the length will be power of two, it won&#x27;t use too much memory.
  44     private static HashMap&lt;BorderKey, Bitmap&gt; sBorderLines = new HashMap&lt;BorderKey, Bitmap&gt;();
  45 
  46     private static BorderKey sBorderKey = new BorderKey();
  47 
  48     @SuppressWarnings(&quot;unused&quot;)
  49     private static final String TAG = &quot;Texture&quot;;
  50 
  51     private boolean mContentValid = true;
  52 
  53     // indicate this textures is being uploaded in background
  54     // indicate this textures is being uploaded in background
  55     private boolean mIsUploading = false;
  56 
  57     private boolean mOpaque = true;
  58 
  59     private boolean mThrottled = false;
  60 
  61     private static int sUploadedCount;
  62 
  63     private static final int UPLOAD_LIMIT = 100;
  64 
  65     protected Bitmap mBitmap;
  66 
  67     private int mBorder;
  68 
  69     protected UploadedTexture() {
  70         this(false);
  71     }
  72 
  73     protected UploadedTexture(boolean hasBorder) {
  74         super(null, 0, STATE_UNLOADED);
  75         if (hasBorder) {
  76             setBorder(true);
  77             mBorder = 1;
  78         }
  79     }
  80 
  81     protected void setIsUploading(boolean uploading) {
  82         mIsUploading = uploading;
  83     }
  84 
  85     public boolean isUploading() {
  86         return mIsUploading;
  87     }
  88 
  89     @Thunk
  90     static class BorderKey implements Cloneable {
  91         public boolean vertical;
  92 
  93         public Config config;
  94 
  95         public int length;
  96 
  97         @Override
  98         public int hashCode() {
  99             int x = config.hashCode() ^ length;
 100             return vertical ? x : -x;
 101         }
 102 
 103         @Override
 104         public boolean equals(Object object) {
 105             if (!(object instanceof BorderKey)) return false;
 106             BorderKey o = (BorderKey) object;
 107             return vertical == o.vertical
 108                     &amp;&amp; config == o.config &amp;&amp; length == o.length;
 109         }
 110 
 111         @Override
 112         public BorderKey clone() {
 113             try {
 114                 return (BorderKey) super.clone();
 115             } catch (CloneNotSupportedException e) {
 116                 throw new AssertionError(e);
 117             }
 118         }
 119     }
 120 
 121     protected void setThrottled(boolean throttled) {
 122         mThrottled = throttled;
 123     }
 124 
 125     private static Bitmap getBorderLine(
 126             boolean vertical, Config config, int length) {
 127         BorderKey key = sBorderKey;
 128         key.vertical = vertical;
 129         key.config = config;
 130         key.length = length;
 131         Bitmap bitmap = sBorderLines.get(key);
 132         if (bitmap == null) {
 133             bitmap = vertical
 134                     ? Bitmap.createBitmap(1, length, config)
 135                     : Bitmap.createBitmap(length, 1, config);
 136             sBorderLines.put(key.clone(), bitmap);
 137         }
 138         return bitmap;
 139     }
 140 
 141     private Bitmap getBitmap() {
 142         if (mBitmap == null) {
 143             mBitmap = onGetBitmap();
 144             int w = mBitmap.getWidth() + mBorder * 2;
 145             int h = mBitmap.getHeight() + mBorder * 2;
 146             if (mWidth == UNSPECIFIED) {
 147                 setSize(w, h);
 148             }
 149         }
 150         return mBitmap;
 151     }
 152 
 153     private void freeBitmap() {
 154         Utils.assertTrue(mBitmap != null);
 155         onFreeBitmap(mBitmap);
 156         mBitmap = null;
 157     }
 158 
 159     @Override
 160     public int getWidth() {
 161         if (mWidth == UNSPECIFIED) getBitmap();
 162         return mWidth;
 163     }
 164 
 165     @Override
 166     public int getHeight() {
 167         if (mWidth == UNSPECIFIED) getBitmap();
 168         return mHeight;
 169     }
 170 
 171     protected abstract Bitmap onGetBitmap();
 172 
 173     protected abstract void onFreeBitmap(Bitmap bitmap);
 174 
 175     protected void invalidateContent() {
 176         if (mBitmap != null) freeBitmap();
 177         mContentValid = false;
 178         mWidth = UNSPECIFIED;
 179         mHeight = UNSPECIFIED;
 180     }
 181 
 182     /**
 183      * Whether the content on GPU is valid.
 184      */
 185     public boolean isContentValid() {
 186         return isLoaded() &amp;&amp; mContentValid;
 187     }
 188 
 189     /**
 190      * Updates the content on GPU&#x27;s memory.
 191      * @param canvas
 192      */
 193     public void updateContent(GLCanvas canvas) {
 194         if (!isLoaded()) {
 195             if (mThrottled &amp;&amp; ++sUploadedCount &gt; UPLOAD_LIMIT) {
 196                 return;
 197             }
 198             uploadToCanvas(canvas);
 199         } else if (!mContentValid) {
 200             Bitmap bitmap = getBitmap();
 201             int format = GLUtils.getInternalFormat(bitmap);
 202             int type = GLUtils.getType(bitmap);
 203             canvas.texSubImage2D(this, mBorder, mBorder, bitmap, format, type);
 204             freeBitmap();
 205             mContentValid = true;
 206         }
 207     }
 208 
 209     public static void resetUploadLimit() {
 210         sUploadedCount = 0;
 211     }
 212 
 213     public static boolean uploadLimitReached() {
 214         return sUploadedCount &gt; UPLOAD_LIMIT;
 215     }
 216 
 217     private void uploadToCanvas(GLCanvas canvas) {
 218         Bitmap bitmap = getBitmap();
 219         if (bitmap != null) {
 220             try {
 221                 int bWidth = bitmap.getWidth();
 222                 int bHeight = bitmap.getHeight();
 223                 int width = bWidth + (mBorder * 2);
 224                 int height = bHeight + (mBorder * 2);
 225                 int texWidth = getTextureWidth();
 226                 int texHeight = getTextureHeight();
 227                 assertTrue((bWidth &lt;= texWidth) &amp;&amp; (bHeight &lt;= texHeight));
 228                 // Upload the bitmap to a new texture.
 229                 mId = canvas.getGLId().generateTexture();
 230                 canvas.setTextureParameters(this);
 231                 if ((bWidth == texWidth) &amp;&amp; (bHeight == texHeight)) {
 232                     canvas.initializeTexture(this, bitmap);
 233                 } else {
 234                     int format = GLUtils.getInternalFormat(bitmap);
 235                     int type = GLUtils.getType(bitmap);
 236                     Config config = bitmap.getConfig();
 237                     canvas.initializeTextureSize(this, format, type);
 238                     canvas.texSubImage2D(this, mBorder, mBorder, bitmap, format, type);
 239                     if (mBorder &gt; 0) {
 240                         // Left border
 241                         Bitmap line = getBorderLine(true, config, texHeight);
 242                         canvas.texSubImage2D(this, 0, 0, line, format, type);
 243                         // Top border
 244                         line = getBorderLine(false, config, texWidth);
 245                         canvas.texSubImage2D(this, 0, 0, line, format, type);
 246                     }
 247                     // Right border
 248                     if ((mBorder + bWidth) &lt; texWidth) {
 249                         Bitmap line = getBorderLine(true, config, texHeight);
 250                         canvas.texSubImage2D(this, mBorder + bWidth, 0, line, format, type);
 251                     }
 252                     // Bottom border
 253                     if ((mBorder + bHeight) &lt; texHeight) {
 254                         Bitmap line = getBorderLine(false, config, texWidth);
 255                         canvas.texSubImage2D(this, 0, mBorder + bHeight, line, format, type);
 256                     }
 257                 }
 258             } finally {
 259                 freeBitmap();
 260             }
 261             // Update texture state.
 262             setAssociatedCanvas(canvas);
 263             mState = STATE_LOADED;
 264             mContentValid = true;
 265         } else {
 266             mState = STATE_ERROR;
 267             throw new RuntimeException(&quot;Texture load fail, no bitmap&quot;);
 268         }
 269     }
 270 
 271     @Override
 272     protected boolean onBind(GLCanvas canvas) {
 273         updateContent(canvas);
 274         return isContentValid();
 275     }
 276 
 277     @Override
 278     protected int getTarget() {
 279         return GL11.GL_TEXTURE_2D;
 280     }
 281 
 282     public void setOpaque(boolean isOpaque) {
 283         mOpaque = isOpaque;
 284     }
 285 
 286     @Override
 287     public boolean isOpaque() {
 288         return mOpaque;
 289     }
 290 
 291     @Override
 292     public void recycle() {
 293         super.recycle();
 294         if (mBitmap != null) freeBitmap();
 295     }
 296 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2010 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.gallery3d.glrenderer;
  18  
  19  import android.graphics.Bitmap;
  20  import android.graphics.Bitmap.Config;
  21  import android.opengl.GLUtils;
  22  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  23 -import junit.framework.Assert;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  24 +import com.android.gallery3d.common.Utils;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  25 +import com.android.launcher3.util.Thunk;</span>
  26  
  27  import java.util.HashMap;
  28  
  29  import javax.microedition.khronos.opengles.GL11;
  30  
  31  // UploadedTextures use a Bitmap for the content of the texture.
  32  //
  33  // Subclasses should implement onGetBitmap() to provide the Bitmap and
  34  // implement onFreeBitmap(mBitmap) which will be called when the Bitmap
  35  // is not needed anymore.
  36  //
  37  // isContentValid() is meaningful only when the isLoaded() returns true.
  38  // It means whether the content needs to be updated.
  39  //
  40  // The user of this class should call recycle() when the texture is not
  41  // needed anymore.
  42  //
  43  // By default an UploadedTexture is opaque (so it can be drawn faster without
  44  // blending). The user or subclass can override it using setOpaque().
  45  public abstract class UploadedTexture extends BasicTexture {
  46  
  47      // To prevent keeping allocation the borders, we store those used borders here.
  48      // Since the length will be power of two, it won&#x27;t use too much memory.
  49      private static HashMap&lt;BorderKey, Bitmap&gt; sBorderLines =
  50              new HashMap&lt;BorderKey, Bitmap&gt;();
  51      private static BorderKey sBorderKey = new BorderKey();
  52  
  53      @SuppressWarnings(&quot;unused&quot;)
  54      private static final String TAG = &quot;Texture&quot;;
  55      private boolean mContentValid = true;
  56  
  57      // indicate this textures is being uploaded in background
  58      private boolean mIsUploading = false;
  59      private boolean mOpaque = true;
  60      private boolean mThrottled = false;
  61      private static int sUploadedCount;
  62      private static final int UPLOAD_LIMIT = 100;
  63  
  64      protected Bitmap mBitmap;
  65      private int mBorder;
  66  
  67      protected UploadedTexture() {
  68          this(false);
  69      }
  70  
  71      protected UploadedTexture(boolean hasBorder) {
  72          super(null, 0, STATE_UNLOADED);
  73          if (hasBorder) {
  74              setBorder(true);
  75              mBorder = 1;
  76          }
  77      }
  78  
  79      protected void setIsUploading(boolean uploading) {
  80          mIsUploading = uploading;
  81      }
  82  
  83      public boolean isUploading() {
  84          return mIsUploading;
  85      }
  86  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  87 -    private static class BorderKey implements Cloneable {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  88 +    @Thunk static class BorderKey implements Cloneable {</span>
  89          public boolean vertical;
  90          public Config config;
  91          public int length;
  92  
  93          @Override
  94          public int hashCode() {
  95              int x = config.hashCode() ^ length;
  96              return vertical ? x : -x;
  97          }
  98  
  99          @Override
 100          public boolean equals(Object object) {
 101              if (!(object instanceof BorderKey)) return false;
 102              BorderKey o = (BorderKey) object;
 103              return vertical == o.vertical
 104                      &amp;&amp; config == o.config &amp;&amp; length == o.length;
 105          }
 106  
 107          @Override
 108          public BorderKey clone() {
 109              try {
 110                  return (BorderKey) super.clone();
 111              } catch (CloneNotSupportedException e) {
 112                  throw new AssertionError(e);
 113              }
 114          }
 115      }
 116  
 117      protected void setThrottled(boolean throttled) {
 118          mThrottled = throttled;
 119      }
 120  
 121      private static Bitmap getBorderLine(
 122              boolean vertical, Config config, int length) {
 123          BorderKey key = sBorderKey;
 124          key.vertical = vertical;
 125          key.config = config;
 126          key.length = length;
 127          Bitmap bitmap = sBorderLines.get(key);
 128          if (bitmap == null) {
 129              bitmap = vertical
 130                      ? Bitmap.createBitmap(1, length, config)
 131                      : Bitmap.createBitmap(length, 1, config);
 132              sBorderLines.put(key.clone(), bitmap);
 133          }
 134          return bitmap;
 135      }
 136  
 137      private Bitmap getBitmap() {
 138          if (mBitmap == null) {
 139              mBitmap = onGetBitmap();
 140              int w = mBitmap.getWidth() + mBorder * 2;
 141              int h = mBitmap.getHeight() + mBorder * 2;
 142              if (mWidth == UNSPECIFIED) {
 143                  setSize(w, h);
 144              }
 145          }
 146          return mBitmap;
 147      }
 148  
 149      private void freeBitmap() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 150 -        Assert.assertTrue(mBitmap != null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 151 +        Utils.assertTrue(mBitmap != null);</span>
 152          onFreeBitmap(mBitmap);
 153          mBitmap = null;
 154      }
 155  
 156      @Override
 157      public int getWidth() {
 158          if (mWidth == UNSPECIFIED) getBitmap();
 159          return mWidth;
 160      }
 161  
 162      @Override
 163      public int getHeight() {
 164          if (mWidth == UNSPECIFIED) getBitmap();
 165          return mHeight;
 166      }
 167  
 168      protected abstract Bitmap onGetBitmap();
 169  
 170      protected abstract void onFreeBitmap(Bitmap bitmap);
 171  
 172      protected void invalidateContent() {
 173          if (mBitmap != null) freeBitmap();
 174          mContentValid = false;
 175          mWidth = UNSPECIFIED;
 176          mHeight = UNSPECIFIED;
 177      }
 178  
 179      /**
 180       * Whether the content on GPU is valid.
 181       */
 182      public boolean isContentValid() {
 183          return isLoaded() &amp;&amp; mContentValid;
 184      }
 185  
 186      /**
 187       * Updates the content on GPU&#x27;s memory.
 188       * @param canvas
 189       */
 190      public void updateContent(GLCanvas canvas) {
 191          if (!isLoaded()) {
 192              if (mThrottled &amp;&amp; ++sUploadedCount &gt; UPLOAD_LIMIT) {
 193                  return;
 194              }
 195              uploadToCanvas(canvas);
 196          } else if (!mContentValid) {
 197              Bitmap bitmap = getBitmap();
 198              int format = GLUtils.getInternalFormat(bitmap);
 199              int type = GLUtils.getType(bitmap);
 200              canvas.texSubImage2D(this, mBorder, mBorder, bitmap, format, type);
 201              freeBitmap();
 202              mContentValid = true;
 203          }
 204      }
 205  
 206      public static void resetUploadLimit() {
 207          sUploadedCount = 0;
 208      }
 209  
 210      public static boolean uploadLimitReached() {
 211          return sUploadedCount &gt; UPLOAD_LIMIT;
 212      }
 213  
 214      private void uploadToCanvas(GLCanvas canvas) {
 215  
 216          Bitmap bitmap = getBitmap();
 217          if (bitmap != null) {
 218              try {
 219                  int bWidth = bitmap.getWidth();
 220                  int bHeight = bitmap.getHeight();
 221                  int width = bWidth + mBorder * 2;
 222                  int height = bHeight + mBorder * 2;
 223                  int texWidth = getTextureWidth();
 224                  int texHeight = getTextureHeight();
 225  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 226 -                Assert.assertTrue(bWidth &lt;= texWidth &amp;&amp; bHeight &lt;= texHeight);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 227 +                Utils.assertTrue(bWidth &lt;= texWidth &amp;&amp; bHeight &lt;= texHeight);</span>
 228  
 229                  // Upload the bitmap to a new texture.
 230                  mId = canvas.getGLId().generateTexture();
 231                  canvas.setTextureParameters(this);
 232  
 233                  if (bWidth == texWidth &amp;&amp; bHeight == texHeight) {
 234                      canvas.initializeTexture(this, bitmap);
 235                  } else {
 236                      int format = GLUtils.getInternalFormat(bitmap);
 237                      int type = GLUtils.getType(bitmap);
 238                      Config config = bitmap.getConfig();
 239  
 240                      canvas.initializeTextureSize(this, format, type);
 241                      canvas.texSubImage2D(this, mBorder, mBorder, bitmap, format, type);
 242  
 243                      if (mBorder &gt; 0) {
 244                          // Left border
 245                          Bitmap line = getBorderLine(true, config, texHeight);
 246                          canvas.texSubImage2D(this, 0, 0, line, format, type);
 247  
 248                          // Top border
 249                          line = getBorderLine(false, config, texWidth);
 250                          canvas.texSubImage2D(this, 0, 0, line, format, type);
 251                      }
 252  
 253                      // Right border
 254                      if (mBorder + bWidth &lt; texWidth) {
 255                          Bitmap line = getBorderLine(true, config, texHeight);
 256                          canvas.texSubImage2D(this, mBorder + bWidth, 0, line, format, type);
 257                      }
 258  
 259                      // Bottom border
 260                      if (mBorder + bHeight &lt; texHeight) {
 261                          Bitmap line = getBorderLine(false, config, texWidth);
 262                          canvas.texSubImage2D(this, 0, mBorder + bHeight, line, format, type);
 263                      }
 264                  }
 265              } finally {
 266                  freeBitmap();
 267              }
 268              // Update texture state.
 269              setAssociatedCanvas(canvas);
 270              mState = STATE_LOADED;
 271              mContentValid = true;
 272          } else {
 273              mState = STATE_ERROR;
 274              throw new RuntimeException(&quot;Texture load fail, no bitmap&quot;);
 275          }
 276      }
 277  
 278      @Override
 279      protected boolean onBind(GLCanvas canvas) {
 280          updateContent(canvas);
 281          return isContentValid();
 282      }
 283  
 284      @Override
 285      protected int getTarget() {
 286          return GL11.GL_TEXTURE_2D;
 287      }
 288  
 289      public void setOpaque(boolean isOpaque) {
 290          mOpaque = isOpaque;
 291      }
 292  
 293      @Override
 294      public boolean isOpaque() {
 295          return mOpaque;
 296      }
 297  
 298      @Override
 299      public void recycle() {
 300          super.recycle();
 301          if (mBitmap != null) freeBitmap();
 302      }
 303  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2010 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.gallery3d.glrenderer;
  18  
  19  import android.graphics.Bitmap;
  20  import android.graphics.Bitmap.Config;
  21  import android.opengl.GLUtils;
  22  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  23 -import junit.framework.Assert;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  24 +import com.android.gallery3d.common.Utils;</span>

  25  
  26  import java.util.HashMap;
  27  
  28  import javax.microedition.khronos.opengles.GL11;
  29  
  30  // UploadedTextures use a Bitmap for the content of the texture.
  31  //
  32  // Subclasses should implement onGetBitmap() to provide the Bitmap and
  33  // implement onFreeBitmap(mBitmap) which will be called when the Bitmap
  34  // is not needed anymore.
  35  //
  36  // isContentValid() is meaningful only when the isLoaded() returns true.
  37  // It means whether the content needs to be updated.
  38  //
  39  // The user of this class should call recycle() when the texture is not
  40  // needed anymore.
  41  //
  42  // By default an UploadedTexture is opaque (so it can be drawn faster without
  43  // blending). The user or subclass can override it using setOpaque().
  44  public abstract class UploadedTexture extends BasicTexture {
  45  
  46      // To prevent keeping allocation the borders, we store those used borders here.
  47      // Since the length will be power of two, it won&#x27;t use too much memory.
  48      private static HashMap&lt;BorderKey, Bitmap&gt; sBorderLines =
  49              new HashMap&lt;BorderKey, Bitmap&gt;();
  50      private static BorderKey sBorderKey = new BorderKey();
  51  
  52      @SuppressWarnings(&quot;unused&quot;)
  53      private static final String TAG = &quot;Texture&quot;;
  54      private boolean mContentValid = true;
  55  
  56      // indicate this textures is being uploaded in background
  57      private boolean mIsUploading = false;
  58      private boolean mOpaque = true;
  59      private boolean mThrottled = false;
  60      private static int sUploadedCount;
  61      private static final int UPLOAD_LIMIT = 100;
  62  
  63      protected Bitmap mBitmap;
  64      private int mBorder;
  65  
  66      protected UploadedTexture() {
  67          this(false);
  68      }
  69  
  70      protected UploadedTexture(boolean hasBorder) {
  71          super(null, 0, STATE_UNLOADED);
  72          if (hasBorder) {
  73              setBorder(true);
  74              mBorder = 1;
  75          }
  76      }
  77  
  78      protected void setIsUploading(boolean uploading) {
  79          mIsUploading = uploading;
  80      }
  81  
  82      public boolean isUploading() {
  83          return mIsUploading;
  84      }
  85  
  86      private static class BorderKey implements Cloneable {

  87          public boolean vertical;
  88          public Config config;
  89          public int length;
  90  
  91          @Override
  92          public int hashCode() {
  93              int x = config.hashCode() ^ length;
  94              return vertical ? x : -x;
  95          }
  96  
  97          @Override
  98          public boolean equals(Object object) {
  99              if (!(object instanceof BorderKey)) return false;
 100              BorderKey o = (BorderKey) object;
 101              return vertical == o.vertical
 102                      &amp;&amp; config == o.config &amp;&amp; length == o.length;
 103          }
 104  
 105          @Override
 106          public BorderKey clone() {
 107              try {
 108                  return (BorderKey) super.clone();
 109              } catch (CloneNotSupportedException e) {
 110                  throw new AssertionError(e);
 111              }
 112          }
 113      }
 114  
 115      protected void setThrottled(boolean throttled) {
 116          mThrottled = throttled;
 117      }
 118  
 119      private static Bitmap getBorderLine(
 120              boolean vertical, Config config, int length) {
 121          BorderKey key = sBorderKey;
 122          key.vertical = vertical;
 123          key.config = config;
 124          key.length = length;
 125          Bitmap bitmap = sBorderLines.get(key);
 126          if (bitmap == null) {
 127              bitmap = vertical
 128                      ? Bitmap.createBitmap(1, length, config)
 129                      : Bitmap.createBitmap(length, 1, config);
 130              sBorderLines.put(key.clone(), bitmap);
 131          }
 132          return bitmap;
 133      }
 134  
 135      private Bitmap getBitmap() {
 136          if (mBitmap == null) {
 137              mBitmap = onGetBitmap();
 138              int w = mBitmap.getWidth() + mBorder * 2;
 139              int h = mBitmap.getHeight() + mBorder * 2;
 140              if (mWidth == UNSPECIFIED) {
 141                  setSize(w, h);
 142              }
 143          }
 144          return mBitmap;
 145      }
 146  
 147      private void freeBitmap() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 148 -        Assert.assertTrue(mBitmap != null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 149 +        Utils.assertTrue(mBitmap != null);</span>
 150          onFreeBitmap(mBitmap);
 151          mBitmap = null;
 152      }
 153  
 154      @Override
 155      public int getWidth() {
 156          if (mWidth == UNSPECIFIED) getBitmap();
 157          return mWidth;
 158      }
 159  
 160      @Override
 161      public int getHeight() {
 162          if (mWidth == UNSPECIFIED) getBitmap();
 163          return mHeight;
 164      }
 165  
 166      protected abstract Bitmap onGetBitmap();
 167  
 168      protected abstract void onFreeBitmap(Bitmap bitmap);
 169  
 170      protected void invalidateContent() {
 171          if (mBitmap != null) freeBitmap();
 172          mContentValid = false;
 173          mWidth = UNSPECIFIED;
 174          mHeight = UNSPECIFIED;
 175      }
 176  
 177      /**
 178       * Whether the content on GPU is valid.
 179       */
 180      public boolean isContentValid() {
 181          return isLoaded() &amp;&amp; mContentValid;
 182      }
 183  
 184      /**
 185       * Updates the content on GPU&#x27;s memory.
 186       * @param canvas
 187       */
 188      public void updateContent(GLCanvas canvas) {
 189          if (!isLoaded()) {
 190              if (mThrottled &amp;&amp; ++sUploadedCount &gt; UPLOAD_LIMIT) {
 191                  return;
 192              }
 193              uploadToCanvas(canvas);
 194          } else if (!mContentValid) {
 195              Bitmap bitmap = getBitmap();
 196              int format = GLUtils.getInternalFormat(bitmap);
 197              int type = GLUtils.getType(bitmap);
 198              canvas.texSubImage2D(this, mBorder, mBorder, bitmap, format, type);
 199              freeBitmap();
 200              mContentValid = true;
 201          }
 202      }
 203  
 204      public static void resetUploadLimit() {
 205          sUploadedCount = 0;
 206      }
 207  
 208      public static boolean uploadLimitReached() {
 209          return sUploadedCount &gt; UPLOAD_LIMIT;
 210      }
 211  
 212      private void uploadToCanvas(GLCanvas canvas) {
 213  
 214          Bitmap bitmap = getBitmap();
 215          if (bitmap != null) {
 216              try {
 217                  int bWidth = bitmap.getWidth();
 218                  int bHeight = bitmap.getHeight();
 219                  int width = bWidth + mBorder * 2;
 220                  int height = bHeight + mBorder * 2;
 221                  int texWidth = getTextureWidth();
 222                  int texHeight = getTextureHeight();
 223  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 224 -                Assert.assertTrue(bWidth &lt;= texWidth &amp;&amp; bHeight &lt;= texHeight);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 225 +                assertTrue(bWidth &lt;= texWidth &amp;&amp; bHeight &lt;= texHeight);</span>
 226  
 227                  // Upload the bitmap to a new texture.
 228                  mId = canvas.getGLId().generateTexture();
 229                  canvas.setTextureParameters(this);
 230  
 231                  if (bWidth == texWidth &amp;&amp; bHeight == texHeight) {
 232                      canvas.initializeTexture(this, bitmap);
 233                  } else {
 234                      int format = GLUtils.getInternalFormat(bitmap);
 235                      int type = GLUtils.getType(bitmap);
 236                      Config config = bitmap.getConfig();
 237  
 238                      canvas.initializeTextureSize(this, format, type);
 239                      canvas.texSubImage2D(this, mBorder, mBorder, bitmap, format, type);
 240  
 241                      if (mBorder &gt; 0) {
 242                          // Left border
 243                          Bitmap line = getBorderLine(true, config, texHeight);
 244                          canvas.texSubImage2D(this, 0, 0, line, format, type);
 245  
 246                          // Top border
 247                          line = getBorderLine(false, config, texWidth);
 248                          canvas.texSubImage2D(this, 0, 0, line, format, type);
 249                      }
 250  
 251                      // Right border
 252                      if (mBorder + bWidth &lt; texWidth) {
 253                          Bitmap line = getBorderLine(true, config, texHeight);
 254                          canvas.texSubImage2D(this, mBorder + bWidth, 0, line, format, type);
 255                      }
 256  
 257                      // Bottom border
 258                      if (mBorder + bHeight &lt; texHeight) {
 259                          Bitmap line = getBorderLine(false, config, texWidth);
 260                          canvas.texSubImage2D(this, 0, mBorder + bHeight, line, format, type);
 261                      }
 262                  }
 263              } finally {
 264                  freeBitmap();
 265              }
 266              // Update texture state.
 267              setAssociatedCanvas(canvas);
 268              mState = STATE_LOADED;
 269              mContentValid = true;
 270          } else {
 271              mState = STATE_ERROR;
 272              throw new RuntimeException(&quot;Texture load fail, no bitmap&quot;);
 273          }
 274      }
 275  
 276      @Override
 277      protected boolean onBind(GLCanvas canvas) {
 278          updateContent(canvas);
 279          return isContentValid();
 280      }
 281  
 282      @Override
 283      protected int getTarget() {
 284          return GL11.GL_TEXTURE_2D;
 285      }
 286  
 287      public void setOpaque(boolean isOpaque) {
 288          mOpaque = isOpaque;
 289      }
 290  
 291      @Override
 292      public boolean isOpaque() {
 293          return mOpaque;
 294      }
 295  
 296      @Override
 297      public void recycle() {
 298          super.recycle();
 299          if (mBitmap != null) freeBitmap();
 300      }
 301  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            