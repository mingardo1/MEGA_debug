<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>206</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    206
                    <a href="205.html">prev</a>
                    <a href="207.html">next</a>
                    <a href="206_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    BroadleafCommerce/BroadleafCommerce_e7f6e916645f3d1f94924346de9c404ec2256c68_admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/service/persistence/module/BasicPersistenceModule.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;e7f6e916645f3d1f94924346de9c404ec2256c68:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/service/persistence/module/BasicPersistenceModule.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;e7f6e916645f3d1f94924346de9c404ec2256c68^1:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/service/persistence/module/BasicPersistenceModule.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;e7f6e916645f3d1f94924346de9c404ec2256c68^2:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/service/persistence/module/BasicPersistenceModule.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;bd88c420aa58267bc3f5f4c47a59d49fc79429eb:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/service/persistence/module/BasicPersistenceModule.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b], [b]], subset: [[b], [b], [b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Open Admin Platform
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  * 
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 
  19 package org.broadleafcommerce.openadmin.server.service.persistence.module;
  20 
  21 import org.apache.commons.beanutils.PropertyUtils;
  22 import org.apache.commons.collections.CollectionUtils;
  23 import org.apache.commons.lang.ArrayUtils;
  24 import org.apache.commons.lang.StringUtils;
  25 import org.apache.commons.lang3.BooleanUtils;
  26 import org.apache.commons.lang3.reflect.FieldUtils;
  27 import org.apache.commons.lang3.reflect.MethodUtils;
  28 import org.apache.commons.logging.Log;
  29 import org.apache.commons.logging.LogFactory;
  30 import org.broadleafcommerce.common.admin.domain.AdminMainEntity;
  31 import org.broadleafcommerce.common.exception.ExceptionHelper;
  32 import org.broadleafcommerce.common.exception.SecurityServiceException;
  33 import org.broadleafcommerce.common.exception.ServiceException;
  34 import org.broadleafcommerce.common.extension.ExtensionResultHolder;
  35 import org.broadleafcommerce.common.i18n.domain.TranslatedEntity;
  36 import org.broadleafcommerce.common.i18n.domain.TranslationImpl;
  37 import org.broadleafcommerce.common.locale.service.LocaleService;
  38 import org.broadleafcommerce.common.money.Money;
  39 import org.broadleafcommerce.common.presentation.client.OperationType;
  40 import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  41 import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  42 import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  43 import org.broadleafcommerce.common.util.FormatUtil;
  44 import org.broadleafcommerce.common.util.StringUtil;
  45 import org.broadleafcommerce.common.util.ValidationUtil;
  46 import org.broadleafcommerce.common.util.dao.TQJoin;
  47 import org.broadleafcommerce.common.util.dao.TQOrder;
  48 import org.broadleafcommerce.common.util.dao.TQRestriction;
  49 import org.broadleafcommerce.common.util.dao.TypedQueryBuilder;
  50 import org.broadleafcommerce.common.web.BroadleafRequestContext;
  51 import org.broadleafcommerce.openadmin.dto.*;
<abbr title="  52 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.AdvancedCollectionFieldMetadataProvider;">  52 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.AdvancedCollectionFieldMetadataProvidðŸ”µ</abbr>
  53 import org.broadleafcommerce.openadmin.server.service.ValidationException;
  54 import org.broadleafcommerce.openadmin.server.service.persistence.ParentEntityPersistenceException;
  55 import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceException;
  56 import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceManager;
  57 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  58 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.*;</span>
  59 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  60 import org.broadleafcommerce.openadmin.dto.FilterAndSortCriteria;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  61 import org.broadleafcommerce.openadmin.dto.ForeignKey;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  62 import org.broadleafcommerce.openadmin.dto.MergedPropertyType;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  63 import org.broadleafcommerce.openadmin.dto.PersistencePackage;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  64 import org.broadleafcommerce.openadmin.dto.PersistencePerspective;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  65 import org.broadleafcommerce.openadmin.dto.Property;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  66 import org.broadleafcommerce.openadmin.dto.SortDirection;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="  67 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.AdvancedCollectionFieldMetadataProvider;">  67 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.AdvancedCollectionFieldMetadataProvidðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  68 import org.broadleafcommerce.openadmin.server.service.ValidationException;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  69 import org.broadleafcommerce.openadmin.server.service.persistence.ParentEntityPersistenceException;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  70 import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceException;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  71 import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceManager;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="  72 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.CriteriaConversionException;">  72 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.CriteriaConversionExcepðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  73 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.CriteriaTranslator;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  74 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  75 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FilterMapping;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  76 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.RestrictionFactory;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="  77 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.converter.FilterValueConverter;">  77 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.converter.FilterValueCoðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="  78 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.EqPredicateProvider;">  78 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.EqPredicatePrðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="  79 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.LikePredicateProvider;">  79 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.LikePredicateðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="  80 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvider;">  80 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="  81 import org.broadleafcommerce.openadmin.server.service.persistence.module.extension.BasicPersistenceModuleExtensionManager;">  81 import org.broadleafcommerce.openadmin.server.service.persistence.module.extension.BasicPersistenceModuleðŸ”µ</abbr></span>
  82 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title="  83 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.CriteriaConversionException;">  83 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.CriteriaConversionExcepðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  84 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.CriteriaTranslator;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  85 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  86 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPathBuilder;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  87 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FilterMapping;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  88 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.Restriction;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  89 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.RestrictionFactory;</span>
  90 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
<abbr title="  91 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.converter.FilterValueConverter;">  91 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.converter.FilterValueCoðŸ”µ</abbr>
<abbr title="  92 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.EqPredicateProvider;">  92 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.EqPredicatePrðŸ”µ</abbr>
<abbr title="  93 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.LikePredicateProvider;">  93 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.LikePredicateðŸ”µ</abbr>
<abbr title="  94 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvider;">  94 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvðŸ”µ</abbr>
<abbr title="  95 import org.broadleafcommerce.openadmin.server.service.persistence.module.extension.BasicPersistenceModuleExtensionManager;">  95 import org.broadleafcommerce.openadmin.server.service.persistence.module.extension.BasicPersistenceModuleðŸ”µ</abbr>
<abbr title="  96 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.FieldPersistenceProvider;">  96 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.FieldPersistenceProvideðŸ”µ</abbr>
<abbr title="  97 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddFilterPropertiesRequest;">  97 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddFilterProperðŸ”µ</abbr>
<abbr title="  98 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddSearchMappingRequest;">  98 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddSearchMappinðŸ”µ</abbr>
<abbr title="  99 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.ExtractValueRequest;">  99 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.ExtractValueReqðŸ”µ</abbr>
<abbr title=" 100 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.PopulateValueRequest;"> 100 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.PopulateValueReðŸ”µ</abbr>
 101 import org.broadleafcommerce.openadmin.server.service.persistence.validation.EntityValidatorService;
<abbr title=" 102 import org.broadleafcommerce.openadmin.server.service.persistence.validation.PopulateValueRequestValidator;"> 102 import org.broadleafcommerce.openadmin.server.service.persistence.validation.PopulateValueRequestValidatoðŸ”µ</abbr>
 103 import org.broadleafcommerce.openadmin.server.service.persistence.validation.PropertyValidationResult;
 104 import org.broadleafcommerce.openadmin.server.service.type.MetadataProviderResponse;
 105 import org.hibernate.FlushMode;
 106 import org.hibernate.Session;
 107 import org.springframework.beans.BeansException;
 108 import org.springframework.beans.factory.annotation.Value;
 109 import org.springframework.context.ApplicationContext;
 110 import org.springframework.context.ApplicationContextAware;
 111 import org.springframework.context.annotation.Primary;
 112 import org.springframework.context.annotation.Scope;
 113 import org.springframework.stereotype.Component;
 114 import org.springframework.util.Assert;
 115 
 116 import javax.annotation.PostConstruct;
 117 import javax.annotation.Resource;
 118 import java.io.Serializable;
 119 import java.lang.reflect.Field;
 120 import java.lang.reflect.InvocationTargetException;
 121 import java.lang.reflect.Method;
 122 import java.lang.reflect.ParameterizedType;
 123 import java.math.BigDecimal;
 124 import java.sql.Timestamp;
 125 import java.text.DecimalFormat;
 126 import java.text.NumberFormat;
 127 import java.text.SimpleDateFormat;
 128 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 129 import java.util.*;</span>
 130 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 131 import org.springframework.context.annotation.Scope;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 132 import org.springframework.stereotype.Component;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 133 import org.springframework.util.Assert;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 134 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 135 import java.io.Serializable;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 136 import java.lang.reflect.Field;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 137 import java.lang.reflect.InvocationTargetException;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 138 import java.lang.reflect.Method;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 139 import java.lang.reflect.ParameterizedType;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 140 import java.math.BigDecimal;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 141 import java.sql.Timestamp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 142 import java.text.DecimalFormat;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 143 import java.text.NumberFormat;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 144 import java.text.SimpleDateFormat;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 145 import java.util.ArrayList;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 146 import java.util.Arrays;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 147 import java.util.Calendar;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 148 import java.util.Collection;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 149 import java.util.Collections;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 150 import java.util.Comparator;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 151 import java.util.Date;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 152 import java.util.HashMap;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 153 import java.util.List;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 154 import java.util.Locale;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 155 import java.util.Map;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 156 import java.util.Map.Entry;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 157 import java.util.StringTokenizer;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 158 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 159 import javax.annotation.PostConstruct;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 160 import javax.annotation.Resource;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 161 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 162 /**</span>
 163 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 164 import java.util.ArrayList;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 165 import java.util.Arrays;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 166 import java.util.Calendar;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 167 import java.util.Collection;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 168 import java.util.Collections;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 169 import java.util.Comparator;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 170 import java.util.Date;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 171 import java.util.HashMap;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 172 import java.util.Iterator;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 173 import java.util.List;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 174 import java.util.Locale;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 175 import java.util.Map;</span>
 176 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 177 import java.util.Map.Entry;
 178 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
 179 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 180 import org.springframework.util.Assert;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 181 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 182 import java.io.Serializable;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 183 import java.lang.reflect.Field;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 184 import java.lang.reflect.InvocationTargetException;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 185 import java.lang.reflect.Method;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 186 import java.lang.reflect.ParameterizedType;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 187 import java.math.BigDecimal;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 188 import java.sql.Timestamp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 189 import java.text.DecimalFormat;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 190 import java.text.NumberFormat;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 191 import java.text.SimpleDateFormat;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 192 import java.util.ArrayList;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 193 import java.util.Arrays;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 194 import java.util.Calendar;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 195 import java.util.Collection;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 196 import java.util.Collections;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 197 import java.util.Comparator;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 198 import java.util.Date;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 199 import java.util.HashMap;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 200 import java.util.List;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 201 import java.util.Locale;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 202 import java.util.Map;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 203 import java.util.Map.Entry;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 204 import java.util.StringTokenizer;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 205 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 206 import javax.annotation.PostConstruct;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 207 import javax.annotation.Resource;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 208 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 209 /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 210  * @author jfischer</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 211  */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 212 @Primary</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 213 @Component(&quot;blBasicPersistenceModule&quot;)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 214 @Scope(&quot;prototype&quot;)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 215 public class BasicPersistenceModule implements PersistenceModule, RecordHelper, ApplicationContextAware {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 216 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 217     private static final Log LOG = LogFactory.getLog(BasicPersistenceModule.class);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 218 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 219     public static final String MAIN_ENTITY_NAME_PROPERTY = &quot;MAIN_ENTITY_NAME&quot;;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 220     public static final String ALTERNATE_ID_PROPERTY = &quot;ALTERNATE_ID&quot;;</span>
 221 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 222 import java.util.StringTokenizer;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 223 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 224 import javax.annotation.PostConstruct;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 225 import javax.annotation.Resource;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 226 import javax.persistence.criteria.CriteriaBuilder;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 227 import javax.persistence.criteria.From;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 228 import javax.persistence.criteria.Path;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 229 import javax.persistence.criteria.Predicate;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 230 import javax.persistence.criteria.Root;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 231 import javax.persistence.criteria.Subquery;</span>
 232 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 233 
 234 /**
 235  * @author jfischer
 236  */
 237 @Primary
 238 @Component(&quot;blBasicPersistenceModule&quot;)
 239 @Scope(&quot;prototype&quot;)
 240 public class BasicPersistenceModule implements PersistenceModule, RecordHelper, ApplicationContextAware {
 241 
 242     private static final Log LOG = LogFactory.getLog(BasicPersistenceModule.class);
 243 
 244     public static final String MAIN_ENTITY_NAME_PROPERTY = &quot;MAIN_ENTITY_NAME&quot;;
 245     public static final String ALTERNATE_ID_PROPERTY = &quot;ALTERNATE_ID&quot;;
 246 
 247     protected ApplicationContext applicationContext;
 248     protected PersistenceManager persistenceManager;
 249 
 250     @Resource(name = &quot;blEntityValidatorService&quot;)
 251     protected EntityValidatorService entityValidatorService;
 252 
 253     @Resource(name = &quot;blPersistenceProviders&quot;)
<abbr title=" 254     protected List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders = new ArrayList&lt;FieldPersistenceProvider&gt;();"> 254     protected List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders = new ArrayList&lt;FieldPersistencePrðŸ”µ</abbr>
 255 
 256     @Resource(name = &quot;blPopulateValueRequestValidators&quot;)
 257     protected List&lt;PopulateValueRequestValidator&gt; populateValidators;
 258 
 259     @Resource(name = &quot;blDefaultFieldPersistenceProvider&quot;)
 260     protected FieldPersistenceProvider defaultFieldPersistenceProvider;
 261 
 262     @Resource(name = &quot;blCriteriaTranslator&quot;)
 263     protected CriteriaTranslator criteriaTranslator;
 264 
 265     @Resource(name = &quot;blRestrictionFactory&quot;)
 266     protected RestrictionFactory restrictionFactory;
 267 
 268     @Resource(name = &quot;blBasicPersistenceModuleExtensionManager&quot;)
 269     protected BasicPersistenceModuleExtensionManager extensionManager;
 270 
 271     @Resource(name = &quot;blFetchWrapper&quot;)
 272     protected FetchWrapper fetchWrapper;
 273 
 274     @Value(&quot;${use.translation.search:false}&quot;)
 275     protected boolean useTranslationSearch;
 276 
 277     @Resource(name = &quot;blLocaleService&quot;)
 278     protected LocaleService localeService;
 279 
 280     @PostConstruct
 281     public void init() {
 282         Collections.sort(fieldPersistenceProviders, new Comparator&lt;FieldPersistenceProvider&gt;() {
 283 
 284             @Override
 285             public int compare(FieldPersistenceProvider o1, FieldPersistenceProvider o2) {
 286                 return Integer.compare(o1.getOrder(), o2.getOrder());
 287             }
 288         });
 289         Collections.sort(populateValidators, new Comparator&lt;PopulateValueRequestValidator&gt;() {
 290 
 291             @Override
 292             public int compare(PopulateValueRequestValidator o1, PopulateValueRequestValidator o2) {
 293                 return Integer.compare(o1.getOrder(), o2.getOrder());
 294             }
 295         });
 296     }
 297 
 298     @Override
 299     public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
 300         this.applicationContext = applicationContext;
 301     }
 302 
 303     @Override
 304     public boolean isCompatible(OperationType operationType) {
<abbr title=" 305         return OperationType.BASIC == operationType || OperationType.NONDESTRUCTIVEREMOVE == operationType;"> 305         return OperationType.BASIC == operationType || OperationType.NONDESTRUCTIVEREMOVE == operationTypðŸ”µ</abbr>
 306     }
 307 
 308     @Override
 309     public FieldManager getFieldManager() {
 310         return persistenceManager.getDynamicEntityDao().getFieldManager();
 311     }
 312 
 313     @Override
 314     public FieldManager getFieldManager(boolean cleanFieldManger) {
 315         return persistenceManager.getDynamicEntityDao().getFieldManager(cleanFieldManger);
 316     }
 317 
 318     @Override
 319     public DecimalFormat getDecimalFormatter() {
 320         BroadleafRequestContext brc = BroadleafRequestContext.getBroadleafRequestContext();
 321         Locale locale = brc.getJavaLocale();
 322         DecimalFormat format = (DecimalFormat) NumberFormat.getInstance(locale);
 323         format.applyPattern(&quot;0.########&quot;);
 324         format.setGroupingUsed(false);
 325         return format;
 326     }
 327 
 328     @Override
 329     public SimpleDateFormat getSimpleDateFormatter() {
 330         return FormatUtil.getDateFormat();
 331     }
 332 
<abbr title=" 333     protected Map&lt;String, FieldMetadata&gt; filterOutCollectionMetadata(Map&lt;String, FieldMetadata&gt; metadata) {"> 333     protected Map&lt;String, FieldMetadata&gt; filterOutCollectionMetadata(Map&lt;String, FieldMetadata&gt; metadata)ðŸ”µ</abbr>
 334         if (metadata == null) {
 335             return null;
 336         }
 337         Map&lt;String, FieldMetadata&gt; newMap = new HashMap&lt;String, FieldMetadata&gt;();
 338         for (Map.Entry&lt;String, FieldMetadata&gt; entry : metadata.entrySet()) {
 339             String fieldName = entry.getKey();
 340             FieldMetadata md = entry.getValue();
<abbr title=" 341             // Detect instances where the actual metadata for the field is some sort of CollectionMetadata but also corresponds"> 341             // Detect instances where the actual metadata for the field is some sort of CollectionMetadatðŸ”µ</abbr>
<abbr title=" 342             // to a ForeignKey and ensure that gets included in the filtered map. That way the {@link BasicPersistenceModule}"> 342             // to a ForeignKey and ensure that gets included in the filtered map. That way the {@link BasðŸ”µ</abbr>
 343             // can appropriate handle filtration and population
 344             if (entry.getValue() instanceof BasicFieldMetadata) {
 345                 newMap.put(fieldName, md);
<abbr title=" 346             } else if (md.getAdditionalMetadata().containsKey(AdvancedCollectionFieldMetadataProvider.FOREIGN_KEY_ADDITIONAL_METADATA_KEY)) {"> 346             } else if (md.getAdditionalMetadata().containsKey(AdvancedCollectionFieldMetadataProvider.FORðŸ”µ</abbr>
 347                 newMap.put(fieldName,
<abbr title=" 348                         (BasicFieldMetadata) md.getAdditionalMetadata().get(AdvancedCollectionFieldMetadataProvider.FOREIGN_KEY_ADDITIONAL_METADATA_KEY));"> 348                         (BasicFieldMetadata) md.getAdditionalMetadata().get(AdvancedCollectionFieldMetadaðŸ”µ</abbr>
 349             }
 350         }
 351 
 352         return newMap;
 353     }
 354 
 355     protected Class&lt;?&gt; getBasicBroadleafType(SupportedFieldType fieldType) {
 356         Class&lt;?&gt; response;
 357         switch (fieldType) {
 358             case BOOLEAN:
 359                 response = Boolean.TYPE;
 360                 break;
 361             case DATE:
 362                 response = Date.class;
 363                 break;
 364             case DECIMAL:
 365                 response = BigDecimal.class;
 366                 break;
 367             case MONEY:
 368                 response = Money.class;
 369                 break;
 370             case INTEGER:
 371                 response = Integer.TYPE;
 372                 break;
 373             case UNKNOWN:
 374                 response = null;
 375                 break;
 376             default:
 377                 response = String.class;
 378                 break;
 379         }
 380 
 381         return response;
 382     }
 383 
 384     @Override
 385     public Serializable createPopulatedInstance(Serializable instance, Entity entity,
 386             Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId) throws ValidationException {
 387         return createPopulatedInstance(instance, entity, unfilteredProperties, setId, true);
 388     }
 389 
 390     @Override
 391     public Serializable createPopulatedInstance(Serializable instance, Entity entity,
<abbr title=" 392             Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId, Boolean validateUnsubmittedProperties) throws ValidationException {"> 392             Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId, Boolean validateUnsubmittedPrðŸ”µ</abbr>
<abbr title=" 393         final Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(unfilteredProperties);"> 393         final Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(unfilteredPropertðŸ”µ</abbr>
 394         FieldManager fieldManager = getFieldManager();
 395         boolean handled = false;
 396         for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {
<abbr title=" 397             MetadataProviderResponse response = fieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfilteredProperties);"> 397             MetadataProviderResponse response = fieldPersistenceProvider.filterProperties(new AddFilterPrðŸ”µ</abbr>
 398             if (MetadataProviderResponse.NOT_HANDLED != response) {
 399                 handled = true;
 400             }
 401             if (MetadataProviderResponse.HANDLED_BREAK == response) {
 402                 break;
 403             }
 404         }
 405         if (!handled) {
<abbr title=" 406             defaultFieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfilteredProperties);"> 406             defaultFieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfiðŸ”µ</abbr>
 407         }
<abbr title=" 408         //Order media field, map field and rule builder fields last, as they will have some validation components that depend on previous values"> 408         //Order media field, map field and rule builder fields last, as they will have some validation coðŸ”µ</abbr>
 409         Property[] sortedProperties = entity.getProperties();
 410         Arrays.sort(sortedProperties, new Comparator&lt;Property&gt;() {
 411 
 412             @Override
 413             public int compare(Property o1, Property o2) {
 414                 BasicFieldMetadata mo1 = (BasicFieldMetadata) mergedProperties.get(o1.getName());
 415                 BasicFieldMetadata mo2 = (BasicFieldMetadata) mergedProperties.get(o2.getName());
<abbr title=" 416                 boolean isLate1 = mo1 != null &amp;&amp; mo1.getFieldType() != null &amp;&amp; mo1.getName() != null &amp;&amp; (SupportedFieldType.RULE_SIMPLE==mo1.getFieldType() ||"> 416                 boolean isLate1 = mo1 != null &amp;&amp; mo1.getFieldType() != null &amp;&amp; mo1.getName() != null &amp;&amp; (ðŸ”µ</abbr>
 417                         SupportedFieldType.RULE_WITH_QUANTITY==mo1.getFieldType() ||
 418                         SupportedFieldType.RULE_SIMPLE_TIME==mo1.getFieldType() ||
<abbr title=" 419                         SupportedFieldType.MEDIA==mo1.getFieldType() || o1.getName().contains(FieldManager.MAPFIELDSEPARATOR));"> 419                         SupportedFieldType.MEDIA==mo1.getFieldType() || o1.getName().contains(FieldManageðŸ”µ</abbr>
<abbr title=" 420                 boolean isLate2 = mo2 != null &amp;&amp; mo2.getFieldType() != null &amp;&amp; mo2.getName() != null &amp;&amp; (SupportedFieldType.RULE_SIMPLE==mo2.getFieldType() ||"> 420                 boolean isLate2 = mo2 != null &amp;&amp; mo2.getFieldType() != null &amp;&amp; mo2.getName() != null &amp;&amp; (ðŸ”µ</abbr>
 421                         SupportedFieldType.RULE_WITH_QUANTITY==mo2.getFieldType() ||
 422                         SupportedFieldType.RULE_SIMPLE_TIME==mo2.getFieldType() ||
<abbr title=" 423                         SupportedFieldType.MEDIA==mo2.getFieldType() || o2.getName().contains(FieldManager.MAPFIELDSEPARATOR));"> 423                         SupportedFieldType.MEDIA==mo2.getFieldType() || o2.getName().contains(FieldManageðŸ”µ</abbr>
 424                 if (isLate1 &amp;&amp; !isLate2) {
 425                     return 1;
 426                 } else if (!isLate1 &amp;&amp; isLate2) {
 427                     return -1;
 428                 }
 429                 return 0;
 430             }
 431         });
<abbr title=" 432         Session session = getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().unwrap(Session.class);"> 432         Session session = getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().unwrapðŸ”µ</abbr>
 433         FlushMode originalFlushMode = session.getHibernateFlushMode();
 434         try {
 435             session.setHibernateFlushMode(FlushMode.MANUAL);
 436             RuntimeException entityPersistenceException = null;
 437             for (Property property : sortedProperties) {
<abbr title=" 438                 BasicFieldMetadata metadata = (BasicFieldMetadata) mergedProperties.get(property.getName());"> 438                 BasicFieldMetadata metadata = (BasicFieldMetadata) mergedProperties.get(property.getName(ðŸ”µ</abbr>
 439                 Class&lt;?&gt; returnType;
<abbr title=" 440                 if (!property.getName().contains(FieldManager.MAPFIELDSEPARATOR) &amp;&amp; !property.getName().startsWith(&quot;__&quot;)) {"> 440                 if (!property.getName().contains(FieldManager.MAPFIELDSEPARATOR) &amp;&amp; !property.getName().sðŸ”µ</abbr>
 441                     Field field = fieldManager.getField(instance.getClass(), property.getName());
 442                     if (field == null) {
<abbr title=" 443                         LOG.debug(&quot;Unable to find a bean property for the reported property: &quot; + StringUtil.sanitize(property.getName()) + &quot;. Ignoring property.&quot;);"> 443                         LOG.debug(&quot;Unable to find a bean property for the reported property: &quot; + StringUtðŸ”µ</abbr>
 444                         continue;
 445                     }
 446                     returnType = field.getType();
 447                 } else {
 448                     if (metadata == null) {
<abbr title=" 449                         LOG.debug(&quot;Unable to find a metadata property for the reported property: &quot; + StringUtil.sanitize(property.getName()) + &quot;. Ignoring property.&quot;);"> 449                         LOG.debug(&quot;Unable to find a metadata property for the reported property: &quot; + StriðŸ”µ</abbr>
 450                         continue;
 451                     }
 452                     returnType = getMapFieldType(instance, fieldManager, property);
 453                     if (returnType == null) {
 454                         returnType = getBasicBroadleafType(metadata.getFieldType());
 455                     }
 456                 }
 457                 if (returnType == null) {
<abbr title=" 458                     throw new IllegalAccessException(&quot;Unable to determine the value type for the property (&quot; + property.getName() + &quot;)&quot;);"> 458                     throw new IllegalAccessException(&quot;Unable to determine the value type for the propertyðŸ”µ</abbr>
 459                 }
 460                 String value = property.getValue();
 461                 if (metadata != null) {
 462 
 463                     if (metadata.getFieldType().equals(SupportedFieldType.BOOLEAN)) {
 464                         if (value == null) {
 465                             String defaultValue = metadata.getDefaultValue();
 466                             value = StringUtils.isBlank(defaultValue)? &quot;false&quot; : defaultValue;
 467                         }
 468                     } else if (metadata.getFieldType().equals(SupportedFieldType.DATE)) {
 469                         if (StringUtils.isEmpty(value)) {
 470                             value = null;
 471                         }
 472                     }
 473 
<abbr title=" 474                     if (attemptToPopulateValue(property, fieldManager, instance, setId, metadata, entity, value)) {"> 474                     if (attemptToPopulateValue(property, fieldManager, instance, setId, metadata, entity,ðŸ”µ</abbr>
 475                         boolean isValid = true;
<abbr title=" 476                         PopulateValueRequest request = new PopulateValueRequest(setId, fieldManager, property, metadata, returnType, value, persistenceManager, this, entity.isPreAdd());"> 476                         PopulateValueRequest request = new PopulateValueRequest(setId, fieldManager, propðŸ”µ</abbr>
 477                         handled = false;
 478                         if (value != null) {
 479                             for (PopulateValueRequestValidator validator : populateValidators) {
<abbr title=" 480                                 PropertyValidationResult validationResult = validator.validate(request, instance);"> 480                                 PropertyValidationResult validationResult = validator.validate(request, iðŸ”µ</abbr>
 481                                 if (!validationResult.isValid()) {
<abbr title=" 482                                     entity.addValidationError(property.getName(), validationResult.getErrorMessage());"> 482                                     entity.addValidationError(property.getName(), validationResult.getErrðŸ”µ</abbr>
 483                                     isValid = false;
 484                                 }
 485                             }
 486                         }
 487                         if (isValid) {
 488                             try {
 489                                 boolean isBreakDetected = false;
<abbr title=" 490                                 for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {"> 490                                 for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceðŸ”µ</abbr>
<abbr title=" 491                                     if ((!isBreakDetected || fieldPersistenceProvider.alwaysRun()) &amp;&amp; (value != null || fieldPersistenceProvider.canHandlePopulateNull())) {"> 491                                     if ((!isBreakDetected || fieldPersistenceProvider.alwaysRun()) &amp;&amp; (vaðŸ”µ</abbr>
<abbr title=" 492                                         MetadataProviderResponse response = fieldPersistenceProvider.populateValue(request, instance);"> 492                                         MetadataProviderResponse response = fieldPersistenceProvider.popuðŸ”µ</abbr>
 493                                         if (MetadataProviderResponse.NOT_HANDLED != response) {
 494                                             handled = true;
 495                                         }
 496                                         if (MetadataProviderResponse.HANDLED_BREAK == response) {
 497                                             isBreakDetected = true;
 498                                         }
 499                                     }
 500                                 }
 501                                 if (!handled) {
 502                                     if (value == null) {
 503                                         property.setIsDirty(true);
 504                                     }
<abbr title=" 505                                     defaultFieldPersistenceProvider.populateValue(new PopulateValueRequest(setId, fieldManager, property, metadata, returnType, value, persistenceManager, this, entity.isPreAdd()), instance);"> 505                                     defaultFieldPersistenceProvider.populateValue(new PopulateValueRequesðŸ”µ</abbr>
 506                                     if (value == null) {
 507                                         fieldManager.setFieldValue(instance, property.getName(), null);
 508                                     }
 509                                 }
<abbr title=" 510                             } catch (ParentEntityPersistenceException | javax.validation.ValidationException e) {"> 510                             } catch (ParentEntityPersistenceException | javax.validation.ValidationExceptðŸ”µ</abbr>
 511                                 entityPersistenceException = e;
 512                                 cleanupFailedPersistenceAttempt(instance);
 513                                 break;
 514                             }
 515                         }
 516                     }
 517                 }
 518             }
 519             // Only check validation if not the initial add
 520             if (!entity.isPreAdd()) {
 521                 validate(entity, instance, mergedProperties, validateUnsubmittedProperties);
 522             }
<abbr title=" 523             //if validation failed, refresh the current instance so that none of the changes will be persisted"> 523             //if validation failed, refresh the current instance so that none of the changes will be persðŸ”µ</abbr>
 524             if (entity.isValidationFailure()) {
 525                 //only refresh the instance if it was managed to begin with
<abbr title=" 526                 if (persistenceManager.getDynamicEntityDao().getStandardEntityManager().contains(instance)) {"> 526                 if (persistenceManager.getDynamicEntityDao().getStandardEntityManager().contains(instanceðŸ”µ</abbr>
 527                     persistenceManager.getDynamicEntityDao().refresh(instance);
 528                 }
 529 
<abbr title=" 530                 //re-initialize the valid properties for the entity in order to deal with the potential of not"> 530                 //re-initialize the valid properties for the entity in order to deal with the potential oðŸ”µ</abbr>
 531                 //completely sending over all checkbox/radio fields
 532                 List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
 533                 entityList.add(instance);
 534                 Entity invalid = getRecords(mergedProperties, entityList, null, null, null)[0];
 535                 invalid.setPropertyValidationErrors(entity.getPropertyValidationErrors());
 536                 invalid.setGlobalValidationErrors(entity.getGlobalValidationErrors());
 537                 invalid.overridePropertyValues(entity);
 538 
<abbr title=" 539                 String message = ValidationUtil.buildErrorMessage(invalid.getPropertyValidationErrors(), invalid.getGlobalValidationErrors());"> 539                 String message = ValidationUtil.buildErrorMessage(invalid.getPropertyValidationErrors(), ðŸ”µ</abbr>
 540                 throw new ValidationException(invalid, message);
 541             } else if (entityPersistenceException != null) {
 542                 throw ExceptionHelper.refineException(entityPersistenceException.getCause());
 543             } else {
 544                 fieldManager.persistMiddleEntities();
 545             }
 546         } catch (IllegalAccessException e) {
 547             throw new PersistenceException(e);
 548         } catch (InstantiationException e) {
 549             throw new PersistenceException(e);
 550         } finally {
 551             session.setHibernateFlushMode(originalFlushMode);
 552         }
 553         return instance;
 554     }
 555 
<abbr title=" 556     protected boolean attemptToPopulateValue(Property property, FieldManager fieldManager, Serializable instance,"> 556     protected boolean attemptToPopulateValue(Property property, FieldManager fieldManager, Serializable iðŸ”µ</abbr>
<abbr title=" 557                                              Boolean setId, BasicFieldMetadata metadata, Entity entity, String value) throws IllegalAccessException {"> 557                                              Boolean setId, BasicFieldMetadata metadata, Entity entity, SðŸ”µ</abbr>
 558         Boolean mutable = metadata.getMutable();
 559         Boolean readOnly = metadata.getReadOnly();
<abbr title=" 560         boolean generalConditionsMet = (mutable == null || mutable) &amp;&amp; (readOnly == null || !readOnly) &amp;&amp; property.getEnabled();"> 560         boolean generalConditionsMet = (mutable == null || mutable) &amp;&amp; (readOnly == null || !readOnly) &amp;&amp;ðŸ”µ</abbr>
 561 
 562         if (generalConditionsMet &amp;&amp; value == null) {
 563             boolean currentValueIsNotNull = false;
 564             try {
 565                 currentValueIsNotNull = fieldManager.getFieldValue(instance, property.getName()) != null;
 566             } catch (FieldNotAvailableException e) {
 567                 throw new IllegalArgumentException(e);
 568             }
 569 
 570             boolean valueIsNotNullId = metadata.getFieldType() != SupportedFieldType.ID || setId;
 571             boolean valueIsNotPassword = metadata.getFieldType() != SupportedFieldType.PASSWORD;
 572 
 573             return currentValueIsNotNull &amp;&amp; !entity.isPreAdd() &amp;&amp; valueIsNotNullId &amp;&amp; valueIsNotPassword;
 574         }
 575         return generalConditionsMet;
 576     }
 577 
 578     @Override
<abbr title=" 579     public Entity getRecord(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, Serializable record, Map&lt;String, FieldMetadata&gt; alternateMergedProperties, String pathToTargetObject) {"> 579     public Entity getRecord(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, Serializable record, Map&lt;ðŸ”µ</abbr>
 580         List&lt;Serializable&gt; records = new ArrayList&lt;Serializable&gt;(1);
 581         records.add(record);
<abbr title=" 582         Entity[] productEntities = getRecords(primaryMergedProperties, records, alternateMergedProperties, pathToTargetObject, null);"> 582         Entity[] productEntities = getRecords(primaryMergedProperties, records, alternateMergedPropertiesðŸ”µ</abbr>
 583         return productEntities[0];
 584     }
 585 
 586     @Override
<abbr title=" 587     public Entity getRecord(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, Serializable record) {"> 587     public Entity getRecord(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, SðŸ”µ</abbr>
<abbr title=" 588         Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persistencePerspective);"> 588         Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getNamðŸ”µ</abbr>
 589         return getRecord(mergedProperties, record, null, null);
 590     }
 591 
 592     @Override
<abbr title=" 593     public Entity[] getRecords(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, List&lt;? extends Serializable&gt; records) {"> 593     public Entity[] getRecords(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspectiveðŸ”µ</abbr>
<abbr title=" 594         Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persistencePerspective);"> 594         Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getNamðŸ”µ</abbr>
 595         return getRecords(mergedProperties, records, null, null, null);
 596     }
 597 
 598     @Override
<abbr title=" 599     public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persistencePerspective) {"> 599     public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspectiveðŸ”µ</abbr>
<abbr title=" 600         return persistenceManager.getDynamicEntityDao().getSimpleMergedProperties(entityName, persistencePerspective);"> 600         return persistenceManager.getDynamicEntityDao().getSimpleMergedProperties(entityName, persistenceðŸ”µ</abbr>
 601     }
 602 
 603     @Override
<abbr title=" 604     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, List&lt;? extends Serializable&gt; records) {"> 604     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, List&lt;? extends SerialiðŸ”µ</abbr>
 605         return getRecords(primaryMergedProperties, records, null, null, null);
 606     }
 607 
 608     @Override
 609     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryUnfilteredMergedProperties,
 610                                List&lt;? extends Serializable&gt; records,
 611                                Map&lt;String, FieldMetadata&gt; alternateUnfilteredMergedProperties,
 612                                String pathToTargetObject) {
<abbr title=" 613         return getRecords(primaryUnfilteredMergedProperties, records, alternateUnfilteredMergedProperties, pathToTargetObject, null);"> 613         return getRecords(primaryUnfilteredMergedProperties, records, alternateUnfilteredMergedPropertiesðŸ”µ</abbr>
 614     }
 615 
 616     @Override
 617     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryUnfilteredMergedProperties,
 618                                List&lt;? extends Serializable&gt; records,
 619                                Map&lt;String, FieldMetadata&gt; alternateUnfilteredMergedProperties,
 620                                String pathToTargetObject,
 621                                String[] customCriteria) {
<abbr title=" 622         Map&lt;String, FieldMetadata&gt; primaryMergedProperties = filterOutCollectionMetadata(primaryUnfilteredMergedProperties);"> 622         Map&lt;String, FieldMetadata&gt; primaryMergedProperties = filterOutCollectionMetadata(primaryUnfiltereðŸ”µ</abbr>
<abbr title=" 623         Map&lt;String, FieldMetadata&gt; alternateMergedProperties = filterOutCollectionMetadata(alternateUnfilteredMergedProperties);"> 623         Map&lt;String, FieldMetadata&gt; alternateMergedProperties = filterOutCollectionMetadata(alternateUnfilðŸ”µ</abbr>
 624         Entity[] entities = new Entity[records.size()];
 625         int j = 0;
 626         for (Serializable recordEntity : records) {
 627             Serializable entity;
 628             if (pathToTargetObject != null) {
 629                 try {
<abbr title=" 630                     entity = (Serializable) getFieldManager().getFieldValue(recordEntity, pathToTargetObject);"> 630                     entity = (Serializable) getFieldManager().getFieldValue(recordEntity, pathToTargetObjðŸ”µ</abbr>
 631                 } catch (Exception e) {
 632                     throw new PersistenceException(e);
 633                 }
 634             } else {
 635                 entity = recordEntity;
 636             }
 637             Entity entityItem = new Entity();
 638             entityItem.setType(new String[] { entity.getClass().getName() });
 639             entities[j] = entityItem;
 640 
 641             List&lt;Property&gt; props = new ArrayList&lt;Property&gt;(primaryMergedProperties.size());
<abbr title=" 642             extractPropertiesFromPersistentEntity(primaryMergedProperties, entity, props, customCriteria);"> 642             extractPropertiesFromPersistentEntity(primaryMergedProperties, entity, props, customCriteria)ðŸ”µ</abbr>
 643             if (alternateMergedProperties != null) {
<abbr title=" 644                 extractPropertiesFromPersistentEntity(alternateMergedProperties, recordEntity, props, customCriteria);"> 644                 extractPropertiesFromPersistentEntity(alternateMergedProperties, recordEntity, props, cusðŸ”µ</abbr>
 645             }
 646 
 647             // Try to add the &quot;main name&quot; property. Log a debug message if we can&#x27;t
 648             try {
 649                 Property p = new Property();
 650                 p.setName(MAIN_ENTITY_NAME_PROPERTY);
 651                 String mainEntityName = (String) MethodUtils.invokeMethod(entity, &quot;getMainEntityName&quot;);
 652                 p.setValue(mainEntityName);
 653                 props.add(p);
 654             } catch (Exception e) {
 655                 LOG.debug(String.format(&quot;Could not execute the getMainEntityName() method for [%s]&quot;,
 656                         entity.getClass().getName()), e);
 657             }
 658 
 659             // Try to add the alternate id property if available
 660             if (alternateMergedProperties != null) {
 661                 for (Entry&lt;String, FieldMetadata&gt; entry : alternateMergedProperties.entrySet()) {
 662                     if (entry.getValue() instanceof BasicFieldMetadata) {
<abbr title=" 663                         if (((BasicFieldMetadata) entry.getValue()).getFieldType() == SupportedFieldType.ID) {"> 663                         if (((BasicFieldMetadata) entry.getValue()).getFieldType() == SupportedFieldType.ðŸ”µ</abbr>
<abbr title=" 664                             Map&lt;String, FieldMetadata&gt; alternateOnEntity = new HashMap&lt;String, FieldMetadata&gt;();"> 664                             Map&lt;String, FieldMetadata&gt; alternateOnEntity = new HashMap&lt;String, FieldMetadðŸ”µ</abbr>
 665                             alternateOnEntity.put(entry.getKey(), entry.getValue());
 666                             List&lt;Property&gt; props2 = new ArrayList&lt;Property&gt;();
<abbr title=" 667                             extractPropertiesFromPersistentEntity(alternateOnEntity, recordEntity, props2, customCriteria);"> 667                             extractPropertiesFromPersistentEntity(alternateOnEntity, recordEntity, props2ðŸ”µ</abbr>
 668                             List&lt;Property&gt; filtered = new ArrayList&lt;Property&gt;();
 669                             for (Property prop : props2) {
 670                                 if (!prop.getName().startsWith(&quot;__&quot;)) {
 671                                     filtered.add(prop);
 672                                 }
 673                             }
 674                             if (filtered.size() == 1 &amp;&amp; !filtered.get(0).getName().contains(&quot;.&quot;)) {
 675                                 Property alternateIdProp = filtered.get(0);
 676                                 alternateIdProp.setName(ALTERNATE_ID_PROPERTY);
 677                                 props.add(alternateIdProp);
 678                             }
 679                         }
 680                     }
 681                 }
 682             }
 683 
 684             Property[] properties = new Property[props.size()];
 685             properties = props.toArray(properties);
 686             entityItem.setProperties(properties);
 687             j++;
 688         }
 689 
 690         return entities;
 691     }
 692 
 693     @Override
 694     public Entity[] getRecords(FetchExtractionRequest fetchExtractionRequest) {
 695         return fetchWrapper.getRecords(fetchExtractionRequest);
 696     }
 697 
 698     protected void extractPropertiesFromPersistentEntity(Map&lt;String, FieldMetadata&gt; mergedProperties,
 699                                                          Serializable entity,
 700                                                          List&lt;Property&gt; props,
 701                                                          String[] customCriteria) {
 702         FieldManager fieldManager = getFieldManager();
 703         try {
 704             if (entity instanceof AdminMainEntity) {
 705                 //Create an invisible property for the admin main entity name, if applicable.
 706                 //This is useful for ToOneLookups if that ToOneLookup uses AdminMainEntity to drive
 707                 //its display name.
 708                 try {
 709                     Property propertyItem = new Property();
 710                     propertyItem.setName(AdminMainEntity.MAIN_ENTITY_NAME_PROPERTY);
 711                     propertyItem.setValue(((AdminMainEntity) entity).getMainEntityName());
 712                     props.add(propertyItem);
 713                 } catch (Exception e) {
<abbr title=" 714                     //do nothing here except for not add the property. Exceptions could occur when there is a validation"> 714                     //do nothing here except for not add the property. Exceptions could occur when there ðŸ”µ</abbr>
<abbr title=" 715                     //issue and some properties/relationships that are used for gleaning the main entity name end up"> 715                     //issue and some properties/relationships that are used for gleaning the main entity ðŸ”µ</abbr>
 716                     //not being set
 717                 }
 718             }
 719             for (Entry&lt;String, FieldMetadata&gt; entry : mergedProperties.entrySet()) {
 720                 String property = entry.getKey();
 721                 BasicFieldMetadata metadata = (BasicFieldMetadata) entry.getValue();
<abbr title=" 722                 if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(entity.getClass()) || entity.getClass().isAssignableFrom(Class.forName(metadata.getInheritedFromType()))) {"> 722                 if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(entity.getClass()) ||ðŸ”µ</abbr>
 723                     boolean proceed = true;
 724                     if (property.contains(&quot;.&quot;)) {
 725                         StringTokenizer tokens = new StringTokenizer(property, &quot;.&quot;);
 726                         Object testObject = entity;
 727                         while (tokens.hasMoreTokens()) {
 728                             String token = tokens.nextToken();
 729                             if (tokens.hasMoreTokens()) {
 730                                 try {
 731                                     testObject = fieldManager.getFieldValue(testObject, token);
 732                                 } catch (FieldNotAvailableException e) {
 733                                     proceed = false;
 734                                     break;
 735                                 }
 736                                 if (testObject == null) {
 737                                     Property propertyItem = new Property();
 738                                     propertyItem.setName(property);
 739                                     if (props.contains(propertyItem)) {
 740                                         proceed = false;
 741                                         break;
 742                                     }
 743                                     propertyItem.setValue(null);
 744                                     props.add(propertyItem);
 745                                     proceed = false;
 746                                     break;
 747                                 }
 748                             }
 749                         }
 750                     }
 751                     if (!proceed) {
 752                         continue;
 753                     }
 754 
 755                     boolean isFieldAccessible = true;
 756                     Object value = null;
 757                     try {
 758                         value = fieldManager.getFieldValue(entity, property);
 759                     } catch (FieldNotAvailableException e) {
 760                         isFieldAccessible = false;
 761                     }
 762                     checkField:
 763                     {
 764                         if (isFieldAccessible) {
 765                             Property propertyItem = new Property();
 766                             propertyItem.setName(property);
 767                             if (props.contains(propertyItem)) {
 768                                 continue;
 769                             }
 770                             props.add(propertyItem);
 771                             String displayVal = propertyItem.getDisplayValue();
 772                             boolean handled = false;
<abbr title=" 773                             for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {"> 773                             for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProvðŸ”µ</abbr>
<abbr title=" 774                                 MetadataProviderResponse response = fieldPersistenceProvider.extractValue("> 774                                 MetadataProviderResponse response = fieldPersistenceProvider.extractValueðŸ”µ</abbr>
<abbr title=" 775                                         new ExtractValueRequest(props, fieldManager, metadata, value, displayVal,"> 775                                         new ExtractValueRequest(props, fieldManager, metadata, value, disðŸ”µ</abbr>
<abbr title=" 776                                                 persistenceManager, this, entity, customCriteria), propertyItem);"> 776                                                 persistenceManager, this, entity, customCriteria), properðŸ”µ</abbr>
 777                                 if (MetadataProviderResponse.NOT_HANDLED != response) {
 778                                     handled = true;
 779                                 }
 780                                 if (MetadataProviderResponse.HANDLED_BREAK == response) {
 781                                     break;
 782                                 }
 783                             }
 784                             if (!handled) {
 785                                 defaultFieldPersistenceProvider.extractValue(
<abbr title=" 786                                         new ExtractValueRequest(props, fieldManager, metadata, value, displayVal,"> 786                                         new ExtractValueRequest(props, fieldManager, metadata, value, disðŸ”µ</abbr>
<abbr title=" 787                                                 persistenceManager, this, entity, customCriteria), propertyItem);"> 787                                                 persistenceManager, this, entity, customCriteria), properðŸ”µ</abbr>
 788                             }
 789                             break checkField;
 790                         }
 791                         //try a direct property acquisition via reflection
 792                         try {
 793                             String strVal = null;
 794                             Method method;
 795                             try {
 796                                 //try a &#x27;get&#x27; prefixed mutator first
<abbr title=" 797                                 String temp = &quot;get&quot; + property.substring(0, 1).toUpperCase() + property.substring(1, property.length());"> 797                                 String temp = &quot;get&quot; + property.substring(0, 1).toUpperCase() + property.sðŸ”µ</abbr>
 798                                 method = entity.getClass().getMethod(temp, new Class[] {});
 799                             } catch (NoSuchMethodException e) {
 800                                 method = entity.getClass().getMethod(property, new Class[] {});
 801                             }
 802                             value = method.invoke(entity, new String[] {});
 803                             Property propertyItem = new Property();
 804                             propertyItem.setName(property);
 805                             if (props.contains(propertyItem)) {
 806                                 continue;
 807                             }
 808                             props.add(propertyItem);
 809                             if (value == null) {
 810                                 strVal = null;
 811                             } else {
 812                                 if (Date.class.isAssignableFrom(value.getClass())) {
 813                                     strVal = getSimpleDateFormatter().format((Date) value);
 814                                 } else if (Timestamp.class.isAssignableFrom(value.getClass())) {
<abbr title=" 815                                     strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value).getTime()));"> 815                                     strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value)ðŸ”µ</abbr>
 816                                 } else if (Calendar.class.isAssignableFrom(value.getClass())) {
<abbr title=" 817                                     strVal = getSimpleDateFormatter().format(((Calendar) value).getTime());"> 817                                     strVal = getSimpleDateFormatter().format(((Calendar) value).getTime()ðŸ”µ</abbr>
 818                                 } else if (Double.class.isAssignableFrom(value.getClass())) {
 819                                     strVal = getDecimalFormatter().format(value);
 820                                 } else if (BigDecimal.class.isAssignableFrom(value.getClass())) {
 821                                     strVal = getDecimalFormatter().format(value);
 822                                 } else {
 823                                     strVal = value.toString();
 824                                 }
 825                             }
 826                             propertyItem.setValue(strVal);
 827                         } catch (NoSuchMethodException e) {
<abbr title=" 828                             LOG.debug(&quot;Unable to find a specified property in the entity: &quot; + StringUtil.sanitize(property));"> 828                             LOG.debug(&quot;Unable to find a specified property in the entity: &quot; + StringUtil.ðŸ”µ</abbr>
 829                             //do nothing - this property is simply not in the bean
 830                         }
 831                     }
 832                 }
 833             }
 834         } catch (ClassNotFoundException e) {
 835             throw new PersistenceException(e);
 836         } catch (IllegalAccessException e) {
 837             throw new PersistenceException(e);
 838         } catch (InvocationTargetException e) {
 839             throw new PersistenceException(e);
 840         }
 841     }
 842 
 843     @Override
 844     public String getStringValueFromGetter(Serializable instance, String propertyName)
 845             throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
 846         Object value = PropertyUtils.getProperty(instance, propertyName);
 847         return formatValue(value);
 848     }
 849 
 850     @Override
 851     public String formatValue(Object value) {
 852         String strVal;
 853         if (value == null) {
 854             strVal = null;
 855         } else {
 856             if (Date.class.isAssignableFrom(value.getClass())) {
 857                 strVal = getSimpleDateFormatter().format((Date) value);
 858             } else if (Timestamp.class.isAssignableFrom(value.getClass())) {
 859                 strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value).getTime()));
 860             } else if (Calendar.class.isAssignableFrom(value.getClass())) {
 861                 strVal = getSimpleDateFormatter().format(((Calendar) value).getTime());
 862             } else if (Double.class.isAssignableFrom(value.getClass())) {
 863                 strVal = getDecimalFormatter().format(value);
 864             } else if (BigDecimal.class.isAssignableFrom(value.getClass())) {
 865                 strVal = getDecimalFormatter().format(value);
 866             } else {
 867                 strVal = value.toString();
 868             }
 869         }
 870         return strVal;
 871     }
 872 
<abbr title=" 873     protected EntityResult update(PersistencePackage persistencePackage, Object primaryKey, boolean includeRealEntity) throws ServiceException {"> 873     protected EntityResult update(PersistencePackage persistencePackage, Object primaryKey, boolean incluðŸ”µ</abbr>
 874         EntityResult entityResult = new EntityResult();
 875         Entity entity = persistencePackage.getEntity();
 876         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title=" 877         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);"> 877         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(ðŸ”µ</abbr>
 878         if (foreignKey != null &amp;&amp; !foreignKey.getMutable()) {
 879             throw new SecurityServiceException(&quot;Entity not mutable&quot;);
 880         }
 881         try {
<abbr title=" 882             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());"> 882             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingðŸ”µ</abbr>
<abbr title=" 883             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties("> 883             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMerðŸ”µ</abbr>
 884                     persistencePackage.getCeilingEntityFullyQualifiedClassname(),
 885                     entities,
 886                     foreignKey,
 887                     persistencePerspective.getAdditionalNonPersistentProperties(),
 888                     persistencePerspective.getAdditionalForeignKeys(),
 889                     MergedPropertyType.PRIMARY,
 890                     persistencePerspective.getPopulateToOneFields(),
 891                     persistencePerspective.getIncludeFields(),
 892                     persistencePerspective.getExcludeFields(),
 893                     persistencePerspective.getConfigurationKey(),
 894                     &quot;&quot;
 895                     );
 896             if (primaryKey == null) {
 897                 primaryKey = getPrimaryKey(entity, mergedProperties);
 898             }
<abbr title=" 899             Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getType()[0]), primaryKey);"> 899             Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entitðŸ”µ</abbr>
 900 
 901             Assert.isTrue(instance != null, &quot;Entity not found&quot;);
 902 
 903             if (!entity.isValidationFailure()) {
 904                 //Re-Balance the list if it is a Foreign Key toMany collection with a sort field property
 905                 if (foreignKey != null &amp;&amp; foreignKey.getSortField() != null &amp;&amp;
 906                         entity.findProperty(foreignKey.getSortField()) != null &amp;&amp;
 907                         entity.findProperty(foreignKey.getSortField()).getValue() != null) {
<abbr title=" 908                     ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;();"> 908                     ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;(ðŸ”µ</abbr>
 909                     extensionManager.getProxy().rebalanceForUpdate(this, persistencePackage, instance,
 910                             mergedProperties, primaryKey, result);
 911                     instance = result.getResult();
 912                 } else {
<abbr title=" 913                     instance = createPopulatedInstance(instance, entity, mergedProperties, false, persistencePackage.isValidateUnsubmittedProperties());"> 913                     instance = createPopulatedInstance(instance, entity, mergedProperties, false, persistðŸ”µ</abbr>
 914                 }
 915 
 916                 instance = persistenceManager.getDynamicEntityDao().merge(instance);
 917                 if (includeRealEntity) {
 918                     entityResult.setEntityBackingObject(instance);
 919                 }
 920 
 921                 List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
 922                 entityList.add(instance);
 923 
 924                 entity = getRecords(mergedProperties, entityList, null, null, null)[0];
 925                 entityResult.setEntity(entity);
 926                 return entityResult;
 927             } else {
 928                 entityResult.setEntity(entity);
 929                 return entityResult;
 930             }
 931         } catch (Exception e) {
 932             throw new ServiceException(&quot;Problem updating entity : &quot; + e.getMessage(), e);
 933         }
 934     }
 935 
 936     @Override
 937     public String getIdPropertyName(String entityClass) {
 938         return persistenceManager.getIdPropertyName(entityClass);
 939     }
 940 
 941     public String getIdPropertyName(Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
<abbr title=" 942         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);"> 942         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredPropertðŸ”µ</abbr>
 943         for (String property : mergedProperties.keySet()) {
 944             BasicFieldMetadata temp = (BasicFieldMetadata) mergedProperties.get(property);
 945             if (temp.getFieldType() == SupportedFieldType.ID &amp;&amp; !property.contains(&quot;.&quot;)) {
 946                 return property;
 947             }
 948         }
 949 
<abbr title=" 950         throw new RuntimeException(&quot;Could not find a primary key property in the passed merged properties list&quot;);"> 950         throw new RuntimeException(&quot;Could not find a primary key property in the passed merged propertiesðŸ”µ</abbr>
 951     }
 952 
 953     @Override
 954     public Object getPrimaryKey(Entity entity, Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
<abbr title=" 955         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);"> 955         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredPropertðŸ”µ</abbr>
 956         Object primaryKey = null;
 957         String idPropertyName = null;
 958         BasicFieldMetadata metaData = null;
 959         for (String property : mergedProperties.keySet()) {
 960             BasicFieldMetadata temp = (BasicFieldMetadata) mergedProperties.get(property);
 961             if (temp.getFieldType() == SupportedFieldType.ID &amp;&amp; !property.contains(&quot;.&quot;)) {
 962                 idPropertyName = property;
 963                 metaData = temp;
 964                 break;
 965             }
 966         }
 967         if (idPropertyName == null) {
<abbr title=" 968             throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: &quot; + entity.getType()[0]);"> 968             throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with tðŸ”µ</abbr>
 969         }
 970         for (Property property : entity.getProperties()) {
 971             if (property.getName().equals(idPropertyName)) {
 972                 switch (metaData.getSecondaryType()) {
 973                     case INTEGER:
<abbr title=" 974                         primaryKey = (property.getValue() == null) ? null : Long.valueOf(property.getValue());"> 974                         primaryKey = (property.getValue() == null) ? null : Long.valueOf(property.getValuðŸ”µ</abbr>
 975                         break;
 976                     case STRING:
 977                         primaryKey = property.getValue();
 978                         break;
 979                 }
 980                 break;
 981             }
 982         }
 983         if (primaryKey == null) {
<abbr title=" 984             throw new RuntimeException(&quot;Could not find the primary key property (&quot; + idPropertyName + &quot;) in the passed entity with type: &quot; + entity.getType()[0]);"> 984             throw new RuntimeException(&quot;Could not find the primary key property (&quot; + idPropertyName + &quot;) ðŸ”µ</abbr>
 985         }
 986         return primaryKey;
 987     }
 988 
 989     @Override
 990     public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective,
 991             CriteriaTransferObject cto,
 992             String ceilingEntityFullyQualifiedClassname,
 993             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties,
 994             RestrictionFactory customRestrictionFactory) {
<abbr title=" 995         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);"> 995         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredPropertðŸ”µ</abbr>
 996         List&lt;FilterMapping&gt; filterMappings = new ArrayList&lt;FilterMapping&gt;();
 997 
 998         for (String propertyId : cto.getCriteriaMap().keySet()) {
 999             if (mergedProperties.containsKey(propertyId)) {
1000                 boolean handled = false;
1001                 for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {
1002                     MetadataProviderResponse response = fieldPersistenceProvider.addSearchMapping(
1003                             new AddSearchMappingRequest(persistencePerspective, cto,
1004                                     ceilingEntityFullyQualifiedClassname, mergedProperties,
<abbr title="1005                                     propertyId, getFieldManager(), this, this, customRestrictionFactory==null?restrictionFactory">1005                                     propertyId, getFieldManager(), this, this, customRestrictionFactory==ðŸ”µ</abbr>
1006                                     :customRestrictionFactory), filterMappings);
1007                     if (MetadataProviderResponse.NOT_HANDLED != response) {
1008                         handled = true;
1009                     }
1010                     if (MetadataProviderResponse.HANDLED_BREAK == response) {
1011                         break;
1012                     }
1013                 }
1014                 if (!handled) {
1015                     defaultFieldPersistenceProvider.addSearchMapping(
1016                             new AddSearchMappingRequest(persistencePerspective, cto,
1017                                     ceilingEntityFullyQualifiedClassname, mergedProperties, propertyId,
<abbr title="1018                                     getFieldManager(), this, this, customRestrictionFactory == null ? restrictionFactory">1018                                     getFieldManager(), this, this, customRestrictionFactory == null ? resðŸ”µ</abbr>
1019                                             : customRestrictionFactory), filterMappings);
1020                 }
1021             }
1022         }
1023         return filterMappings;
1024     }
1025 
1026     @Override
1027     public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective,
1028             CriteriaTransferObject cto,
1029             String ceilingEntityFullyQualifiedClassname,
1030             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
<abbr title="1031         return getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergedUnfilteredProperties, null);">1031         return getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergeðŸ”µ</abbr>
1032     }
1033 
1034     @Override
<abbr title="1035     public void extractProperties(Class&lt;?&gt;[] inheritanceLine, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; mergedProperties, List&lt;Property&gt; properties) {">1035     public void extractProperties(Class&lt;?&gt;[] inheritanceLine, Map&lt;MergedPropertyType, Map&lt;String, FieldMeðŸ”µ</abbr>
<abbr title="1036         extractPropertiesFromMetadata(inheritanceLine, mergedProperties.get(MergedPropertyType.PRIMARY), properties, false, MergedPropertyType.PRIMARY);">1036         extractPropertiesFromMetadata(inheritanceLine, mergedProperties.get(MergedPropertyType.PRIMARY), ðŸ”µ</abbr>
1037     }
1038 
<abbr title="1039     protected void extractPropertiesFromMetadata(Class&lt;?&gt;[] inheritanceLine, Map&lt;String, FieldMetadata&gt; mergedProperties, List&lt;Property&gt; properties, Boolean isHiddenOverride, MergedPropertyType type) {">1039     protected void extractPropertiesFromMetadata(Class&lt;?&gt;[] inheritanceLine, Map&lt;String, FieldMetadata&gt; mðŸ”µ</abbr>
1040         Comparator&lt;Property&gt; comparator = new Comparator&lt;Property&gt;() {
1041 
1042             @Override
1043             public int compare(Property o1, Property o2) {
1044                 return o1.getName().compareTo(o2.getName());
1045             }
1046         };
1047         Collections.sort(properties, comparator);
1048         for (Map.Entry&lt;String, FieldMetadata&gt; entry : mergedProperties.entrySet()) {
1049             String property = entry.getKey();
1050             Property prop = new Property();
1051             FieldMetadata metadata = mergedProperties.get(property);
1052             prop.setName(property);
1053 
1054             int pos = Collections.binarySearch(properties, prop, comparator);
<abbr title="1055             if (pos &gt;= 0 &amp;&amp; MergedPropertyType.MAPSTRUCTUREKEY != type &amp;&amp; MergedPropertyType.MAPSTRUCTUREVALUE != type) {">1055             if (pos &gt;= 0 &amp;&amp; MergedPropertyType.MAPSTRUCTUREKEY != type &amp;&amp; MergedPropertyType.MAPSTRUCTUREðŸ”µ</abbr>
1056                 logWarn: {
<abbr title="1057                     if ((metadata instanceof BasicFieldMetadata) &amp;&amp; SupportedFieldType.ID.equals(((BasicFieldMetadata) metadata).getFieldType())) {">1057                     if ((metadata instanceof BasicFieldMetadata) &amp;&amp; SupportedFieldType.ID.equals(((BasicFðŸ”µ</abbr>
1058                         //don&#x27;t warn for id field collisions, but still ignore the colliding fields
1059                         break logWarn;
1060                     }
<abbr title="1061                     //LOG.warn(&quot;Detected a field name collision (&quot; + metadata.getTargetClass() + &quot;.&quot; + property + &quot;) during inspection for the inheritance line starting with (&quot; + inheritanceLine[0].getName() + &quot;). Ignoring the additional field. This can occur most commonly when using the @AdminPresentationAdornedTargetCollection and the collection type and target class have field names in common. This situation should be avoided, as the system will strip the repeated fields, which can cause unpredictable behavior.&quot;);">1061                     //LOG.warn(&quot;Detected a field name collision (&quot; + metadata.getTargetClass() + &quot;.&quot; + prðŸ”µ</abbr>
1062                 }
1063                 continue;
1064             } else if (pos &lt; 0) {
1065                 pos = -pos - 1; // calculate position to insert
1066             }
1067             properties.add(pos, prop);
1068             prop.setMetadata(metadata);
1069             if (isHiddenOverride &amp;&amp; prop.getMetadata() instanceof BasicFieldMetadata) {
1070                 //this only makes sense for non collection types
1071                 ((BasicFieldMetadata) prop.getMetadata()).setVisibility(VisibilityEnum.HIDDEN_ALL);
1072             }
1073         }
1074     }
1075 
1076     @Override
<abbr title="1077     public void updateMergedProperties(PersistencePackage persistencePackage, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; allMergedProperties) throws ServiceException {">1077     public void updateMergedProperties(PersistencePackage persistencePackage, Map&lt;MergedPropertyType, MapðŸ”µ</abbr>
<abbr title="1078         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();">1078         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
1079         try {
<abbr title="1080             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();">1080             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective(ðŸ”µ</abbr>
<abbr title="1081             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(ceilingEntityFullyQualifiedClassname);">1081             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(ceilingEntityFullyQualifiedClðŸ”µ</abbr>
<abbr title="1082             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(">1082             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMerðŸ”µ</abbr>
1083                     ceilingEntityFullyQualifiedClassname,
1084                     entities,
<abbr title="1085                     (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),">1085                     (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePðŸ”µ</abbr>
1086                     persistencePerspective.getAdditionalNonPersistentProperties(),
1087                     persistencePerspective.getAdditionalForeignKeys(),
1088                     MergedPropertyType.PRIMARY,
1089                     persistencePerspective.getPopulateToOneFields(),
1090                     persistencePerspective.getIncludeFields(),
1091                     persistencePerspective.getExcludeFields(),
1092                     persistencePerspective.getConfigurationKey(),
1093                     &quot;&quot;
1094                     );
1095             allMergedProperties.put(MergedPropertyType.PRIMARY, mergedProperties);
1096         } catch (Exception e) {
<abbr title="1097             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);">1097             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassnðŸ”µ</abbr>
1098         }
1099     }
1100 
1101     @Override
<abbr title="1102     public EntityResult update(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServiceException {">1102     public EntityResult update(PersistencePackage persistencePackage, boolean includeRealEntityObject) thðŸ”µ</abbr>
1103         return update(persistencePackage, null, true);
1104     }
1105 
1106     @Override
1107     public Entity update(PersistencePackage persistencePackage) throws ServiceException {
1108         EntityResult er = update(persistencePackage, null, false);
1109         return er.getEntity();
1110     }
1111 
1112     @Override
1113     public Entity add(PersistencePackage persistencePackage) throws ServiceException {
1114         EntityResult entityResult = add(persistencePackage, false);
1115         return entityResult.getEntity();
1116     }
1117 
1118     @Override
<abbr title="1119     public EntityResult add(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServiceException {">1119     public EntityResult add(PersistencePackage persistencePackage, boolean includeRealEntityObject) throwðŸ”µ</abbr>
1120         EntityResult entityResult = new EntityResult();
1121         Entity entity = persistencePackage.getEntity();
1122         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1123         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1123         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(ðŸ”µ</abbr>
1124         if (foreignKey != null &amp;&amp; !foreignKey.getMutable()) {
1125             throw new SecurityServiceException(&quot;Entity not mutable&quot;);
1126         }
1127         try {
<abbr title="1128             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());">1128             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingðŸ”µ</abbr>
<abbr title="1129             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(">1129             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDaðŸ”µ</abbr>
1130                     persistencePackage.getCeilingEntityFullyQualifiedClassname(),
1131                     entities,
1132                     foreignKey,
1133                     persistencePerspective.getAdditionalNonPersistentProperties(),
1134                     persistencePerspective.getAdditionalForeignKeys(),
1135                     MergedPropertyType.PRIMARY,
1136                     persistencePerspective.getPopulateToOneFields(),
1137                     persistencePerspective.getIncludeFields(),
1138                     persistencePerspective.getExcludeFields(),
1139                     persistencePerspective.getConfigurationKey(),
1140                     &quot;&quot;
1141                     );
<abbr title="1142             Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);">1142             Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProðŸ”µ</abbr>
1143 
1144             String idProperty = null;
1145             for (String property : mergedProperties.keySet()) {
<abbr title="1146                 if (((BasicFieldMetadata) mergedProperties.get(property)).getFieldType() == SupportedFieldType.ID) {">1146                 if (((BasicFieldMetadata) mergedProperties.get(property)).getFieldType() == SupportedFielðŸ”µ</abbr>
1147                     idProperty = property;
1148                     break;
1149                 }
1150             }
1151             if (idProperty == null) {
<abbr title="1152                 throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: &quot; + entity.getType()[0]);">1152                 throw new RuntimeException(&quot;Could not find a primary key property in the passed entity wiðŸ”µ</abbr>
1153             }
1154             Object primaryKey = null;
1155             try {
1156                 primaryKey = getPrimaryKey(entity, mergedProperties);
1157             } catch (Exception e) {
1158                 //don&#x27;t do anything - this is a valid case
1159             }
1160             if (primaryKey == null) {
1161 
1162                 Serializable instance = (Serializable) Class.forName(entity.getType()[0]).newInstance();
1163 
1164                 instance = createPopulatedInstance(instance, entity, mergedProperties, false);
1165 
1166                 if (foreignKey != null &amp;&amp; foreignKey.getSortField() != null) {
<abbr title="1167                     ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;();">1167                     ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;(ðŸ”µ</abbr>
<abbr title="1168                     extensionManager.getProxy().rebalanceForAdd(this, persistencePackage, instance, mergedProperties, result);">1168                     extensionManager.getProxy().rebalanceForAdd(this, persistencePackage, instance, mergeðŸ”µ</abbr>
1169                     instance = result.getResult();
1170                 }
1171 
1172                 instance = persistenceManager.getDynamicEntityDao().merge(instance);
1173                 if (includeRealEntityObject) {
1174                     entityResult.setEntityBackingObject(instance);
1175                 }
1176                 List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
1177                 entityList.add(instance);
1178 
1179                 entity = getRecords(mergedProperties, entityList, null, null, null)[0];
1180                 entityResult.setEntity(entity);
1181                 return entityResult;
1182             } else {
1183                 return update(persistencePackage, primaryKey, includeRealEntityObject);
1184             }
1185         } catch (Exception e) {
1186             throw new ServiceException(&quot;Problem adding new entity : &quot; + e.getMessage(), e);
1187         }
1188     }
1189 
1190     @Override
1191     public void remove(PersistencePackage persistencePackage) throws ServiceException {
1192         Entity entity = persistencePackage.getEntity();
1193         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1194         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1194         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(ðŸ”µ</abbr>
1195         if (foreignKey != null &amp;&amp; !foreignKey.getMutable()) {
1196             throw new SecurityServiceException(&quot;Entity not mutable&quot;);
1197         }
1198         try {
<abbr title="1199             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());">1199             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingðŸ”µ</abbr>
<abbr title="1200             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(">1200             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDaðŸ”µ</abbr>
1201                     persistencePackage.getCeilingEntityFullyQualifiedClassname(),
1202                     entities,
1203                     foreignKey,
1204                     persistencePerspective.getAdditionalNonPersistentProperties(),
1205                     persistencePerspective.getAdditionalForeignKeys(),
1206                     MergedPropertyType.PRIMARY,
1207                     persistencePerspective.getPopulateToOneFields(),
1208                     persistencePerspective.getIncludeFields(),
1209                     persistencePerspective.getExcludeFields(),
1210                     persistencePerspective.getConfigurationKey(),
1211                     &quot;&quot;
1212                     );
<abbr title="1213             Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);">1213             Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProðŸ”µ</abbr>
1214             Object primaryKey = getPrimaryKey(entity, mergedProperties);
<abbr title="1215             Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getType()[0]), primaryKey);">1215             Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entitðŸ”µ</abbr>
1216 
1217             Assert.isTrue(instance != null, &quot;Entity not found&quot;);
1218 
1219             switch (persistencePerspective.getOperationTypes().getRemoveType()) {
1220                 case NONDESTRUCTIVEREMOVE:
1221                     FieldManager fieldManager = getFieldManager();
<abbr title="1222                     FieldMetadata manyToFieldMetadata = mergedUnfilteredProperties.get(foreignKey.getManyToField());">1222                     FieldMetadata manyToFieldMetadata = mergedUnfilteredProperties.get(foreignKey.getManyðŸ”µ</abbr>
<abbr title="1223                     Object foreignKeyValue = entity.getPMap().get(foreignKey.getManyToField()).getValue();">1223                     Object foreignKeyValue = entity.getPMap().get(foreignKey.getManyToField()).getValue()ðŸ”µ</abbr>
1224                     try {
1225                         foreignKeyValue = Long.valueOf((String) foreignKeyValue);
1226                     } catch (NumberFormatException e) {
<abbr title="1227                         LOG.warn(&quot;Foreign primary key is not of type Long, assuming String for remove lookup&quot;);">1227                         LOG.warn(&quot;Foreign primary key is not of type Long, assuming String for remove looðŸ”µ</abbr>
1228                     }
<abbr title="1229                     Serializable foreignInstance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(foreignKey.getForeignKeyClass()), foreignKeyValue);">1229                     Serializable foreignInstance = persistenceManager.getDynamicEntityDao().retrieve(ClasðŸ”µ</abbr>
<abbr title="1230                     Collection collection = (Collection) fieldManager.getFieldValue(foreignInstance, foreignKey.getOriginatingField());">1230                     Collection collection = (Collection) fieldManager.getFieldValue(foreignInstance, foreðŸ”µ</abbr>
1231                     collection.remove(instance);
<abbr title="1232                     // if this is a bi-directional @OneToMany/@ManyToOne and there is no @JoinTable (just a foreign key on">1232                     // if this is a bi-directional @OneToMany/@ManyToOne and there is no @JoinTable (justðŸ”µ</abbr>
<abbr title="1233                     // the @ManyToOne side) then it will not be updated. In that instance, we have to explicitly">1233                     // the @ManyToOne side) then it will not be updated. In that instance, we have to expðŸ”µ</abbr>
1234                     // set the manyTo field to null so that subsequent lookups will not find it
1235                     if (manyToFieldMetadata instanceof BasicFieldMetadata) {
<abbr title="1236                         if (BooleanUtils.isTrue(((BasicFieldMetadata) manyToFieldMetadata).getRequired())) {">1236                         if (BooleanUtils.isTrue(((BasicFieldMetadata) manyToFieldMetadata).getRequired())ðŸ”µ</abbr>
<abbr title="1237                             throw new ServiceException(&quot;Could not remove from the collection as the ManyToOne side is a&quot;">1237                             throw new ServiceException(&quot;Could not remove from the collection as the ManyTðŸ”µ</abbr>
<abbr title="1238                                     + &quot; non-optional relationship. Consider changing &#x27;optional=true&#x27; in the @ManyToOne annotation&quot;">1238                                     + &quot; non-optional relationship. Consider changing &#x27;optional=true&#x27; in tðŸ”µ</abbr>
1239                                     + &quot; or nullable=true within the @JoinColumn annotation&quot;);
1240                         }
<abbr title="1241                         //Since this is occuring on a remove persistence package, merge up-front (before making a change) for proper operation in the presence of the enterprise module">1241                         //Since this is occuring on a remove persistence package, merge up-front (before ðŸ”µ</abbr>
1242                         instance = persistenceManager.getDynamicEntityDao().merge(instance);
<abbr title="1243                         Field manyToField = fieldManager.getField(instance.getClass(), foreignKey.getManyToField());">1243                         Field manyToField = fieldManager.getField(instance.getClass(), foreignKey.getManyðŸ”µ</abbr>
1244                         Object manyToObject = manyToField.get(instance);
<abbr title="1245                         if (manyToObject != null &amp;&amp; !(manyToObject instanceof Collection) &amp;&amp; !(manyToObject instanceof Map)) {">1245                         if (manyToObject != null &amp;&amp; !(manyToObject instanceof Collection) &amp;&amp; !(manyToObjeðŸ”µ</abbr>
1246                             manyToField.set(instance, null);
1247                             instance = persistenceManager.getDynamicEntityDao().merge(instance);
1248                         }
1249                     }
1250                     break;
1251                 case BASIC:
1252                     persistenceManager.getDynamicEntityDao().remove(instance);
1253                     break;
1254             }
1255         } catch (Exception e) {
1256             throw new ServiceException(&quot;Problem removing entity : &quot; + e.getMessage(), e);
1257         }
1258     }
1259 
1260     public Map&lt;String, FieldMetadata&gt; getMergedProperties(PersistencePackage persistencePackage,
1261             CriteriaTransferObject cto) throws ServiceException {
1262         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1263         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();">1263         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
1264 
1265         if (StringUtils.isEmpty(persistencePackage.getFetchTypeFullyQualifiedClassname())) {
1266             persistencePackage.setFetchTypeFullyQualifiedClassname(ceilingEntityFullyQualifiedClassname);
1267         }
1268 
1269         try {
<abbr title="1270             Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualifiedClassname));">1270             Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCðŸ”µ</abbr>
1271 
<abbr title="1272             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(">1272             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMerðŸ”µ</abbr>
1273                     ceilingEntityFullyQualifiedClassname,
1274                     entities,
<abbr title="1275                     (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),">1275                     (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePðŸ”µ</abbr>
1276                     persistencePerspective.getAdditionalNonPersistentProperties(),
1277                     persistencePerspective.getAdditionalForeignKeys(),
1278                     MergedPropertyType.PRIMARY,
1279                     persistencePerspective.getPopulateToOneFields(),
1280                     persistencePerspective.getIncludeFields(),
1281                     persistencePerspective.getExcludeFields(),
1282                     persistencePerspective.getConfigurationKey(),
1283                     &quot;&quot;
1284                     );
1285 
1286             return mergedProperties;
1287         } catch (Exception e) {
<abbr title="1288             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);">1288             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassnðŸ”µ</abbr>
1289         }
1290     }
1291 
1292     @Override
<abbr title="1293     public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto) throws ServiceException {">1293     public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto) throðŸ”µ</abbr>
1294         Entity[] payload;
1295         int totalRecords;
1296         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1297         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();">1297         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
<abbr title="1298         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1298         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(ðŸ”µ</abbr>
1299 
1300         try {
1301             if (foreignKey != null &amp;&amp; foreignKey.getSortField() != null) {
1302                 FilterAndSortCriteria sortCriteria = cto.get(foreignKey.getSortField());
1303                 sortCriteria.setSortAscending(foreignKey.getSortAscending());
1304             }
1305 
1306             Map&lt;String, FieldMetadata&gt; mergedProperties = getMergedProperties(persistencePackage, cto);
1307             if (useTranslationSearch) {
1308                 addTranslationSearchIfNeeded(cto, mergedProperties);
1309             }
<abbr title="1310             List&lt;FilterMapping&gt; filterMappings = getFilterMappings(persistencePerspective, cto, persistencePackage">1310             List&lt;FilterMapping&gt; filterMappings = getFilterMappings(persistencePerspective, cto, persistenðŸ”µ</abbr>
1311                     .getFetchTypeFullyQualifiedClassname(), mergedProperties);
1312             List&lt;FilterMapping&gt; standardFilterMappings = new ArrayList&lt;FilterMapping&gt;(filterMappings);
1313             if (CollectionUtils.isNotEmpty(cto.getAdditionalFilterMappings())) {
1314                 standardFilterMappings.addAll(cto.getAdditionalFilterMappings());
1315             }
1316             if (CollectionUtils.isNotEmpty(cto.getNonCountAdditionalFilterMappings())) {
1317                 standardFilterMappings.addAll(cto.getNonCountAdditionalFilterMappings());
1318             }
1319 
1320             FetchRequest fetchRequest = new FetchRequest(persistencePackage, cto,
1321                     persistencePackage.getFetchTypeFullyQualifiedClassname(), standardFilterMappings);
1322             List&lt;Serializable&gt; records = getPersistentRecords(fetchRequest);
1323 
1324             List&lt;FilterMapping&gt; countFilterMappings = new ArrayList&lt;FilterMapping&gt;(filterMappings);
1325             if (CollectionUtils.isNotEmpty(cto.getAdditionalFilterMappings())) {
1326                 countFilterMappings.addAll(cto.getAdditionalFilterMappings());
1327             }
1328             FetchRequest countFetchRequest = new FetchRequest(persistencePackage, cto,
1329                     persistencePackage.getFetchTypeFullyQualifiedClassname(), countFilterMappings);
1330             totalRecords = getTotalRecords(countFetchRequest);
1331 
<abbr title="1332             FetchExtractionRequest fetchExtractionRequest = new FetchExtractionRequest(persistencePackage, cto,">1332             FetchExtractionRequest fetchExtractionRequest = new FetchExtractionRequest(persistencePackageðŸ”µ</abbr>
1333                     persistencePackage.getFetchTypeFullyQualifiedClassname(), mergedProperties, records);
1334             payload = getRecords(fetchExtractionRequest);
1335         } catch (Exception e) {
<abbr title="1336             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);">1336             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassnðŸ”µ</abbr>
1337         }
1338 
1339         return new DynamicResultSet(null, payload, totalRecords);
1340     }
1341 
<abbr title="1342     private void addTranslationSearchIfNeeded(CriteriaTransferObject cto, Map&lt;String, FieldMetadata&gt; mergedProperties) {">1342     private void addTranslationSearchIfNeeded(CriteriaTransferObject cto, Map&lt;String, FieldMetadata&gt; mergðŸ”µ</abbr>
1343         Map&lt;String, FilterAndSortCriteria&gt; criteriaMap = cto.getCriteriaMap();
1344         FilterAndSortCriteria fsc = criteriaMap.get(&quot;translationLocale&quot;);
1345         List&lt;String&gt; filterValues = new ArrayList&lt;&gt;();
1346         if (fsc != null) {
1347             filterValues = fsc.getFilterValues();
1348             criteriaMap.remove(&quot;translationLocale&quot;);
1349         }
1350         //If locale is generic - than we use all locales of this language
1351         //For example, if locale = &quot;en&quot; than we use also &quot;en_GB&quot; and &quot;en_US&quot;
1352         if (filterValues.size() &gt; 0 &amp;&amp; filterValues.get(0).indexOf(&quot;_&quot;) &lt; 0) {
1353             String currentLocaleCode = filterValues.get(0);
<abbr title="1354             List&lt;org.broadleafcommerce.common.locale.domain.Locale&gt; locales = localeService.findAllLocales();">1354             List&lt;org.broadleafcommerce.common.locale.domain.Locale&gt; locales = localeService.findAllLocaleðŸ”µ</abbr>
1355             for (org.broadleafcommerce.common.locale.domain.Locale locale : locales) {
<abbr title="1356                 if (!locale.getLocaleCode().equals(currentLocaleCode) &amp;&amp; currentLocaleCode.equals(locale.getLocaleCode().substring(0,2))) {">1356                 if (!locale.getLocaleCode().equals(currentLocaleCode) &amp;&amp; currentLocaleCode.equals(locale.ðŸ”µ</abbr>
1357                     filterValues.add(locale.getLocaleCode());
1358                 }
1359             }
1360         }
1361         Iterator&lt;Entry&lt;String, FilterAndSortCriteria&gt;&gt; iterator = criteriaMap.entrySet().iterator();
1362         while (iterator.hasNext()) {
1363             Entry&lt;String, FilterAndSortCriteria&gt; next = iterator.next();
1364 
1365             final String key = next.getKey();
1366             FieldMetadata fieldMetadata = mergedProperties.get(key);
<abbr title="1367             if (fieldMetadata != null &amp;&amp; fieldMetadata instanceof BasicFieldMetadata &amp;&amp; ((BasicFieldMetadata) fieldMetadata).getTranslatable()!=null &amp;&amp; ((BasicFieldMetadata) fieldMetadata).getTranslatable()) {">1367             if (fieldMetadata != null &amp;&amp; fieldMetadata instanceof BasicFieldMetadata &amp;&amp; ((BasicFieldMetadðŸ”µ</abbr>
1368                 BasicFieldMetadata basicFieldMetadata = ((BasicFieldMetadata) fieldMetadata);
1369                 if (next.getValue().getFilterValues().size() &gt; 0) {
1370                     final String value = next.getValue().getFilterValues().get(0);
1371                     final String targetClass = basicFieldMetadata.getTargetClass();
1372                     final String fieldName = basicFieldMetadata.getFieldName();
1373                     final String friendlyType = getTranslationFriendlyType(targetClass);
1374                     final List&lt;String&gt; localeValues = filterValues;
1375                     if (friendlyType != null) {
1376                         iterator.remove();
1377                         cto.getAdditionalFilterMappings().add(new FilterMapping()
1378                                 .withDirectFilterValues(new EmptyFilterValues())
1379                                 .withRestriction(
1380                                         new Restriction().withPredicateProvider(new PredicateProvider() {
1381                                             @Override
1382                                             public Predicate buildPredicate(CriteriaBuilder builder,
<abbr title="1383                                                                             FieldPathBuilder fieldPathBuilder,">1383                                                                             FieldPathBuilder fieldPathBuiðŸ”µ</abbr>
1384                                                                             From root,
1385                                                                             String ceilingEntity,
1386                                                                             String fullPropertyName,
1387                                                                             Path explicitPath,
1388                                                                             List directValues) {
1389                                                 Subquery subquery =
<abbr title="1390                                                         fieldPathBuilder.getCriteria().subquery(Long.class);">1390                                                         fieldPathBuilder.getCriteria().subquery(Long.clasðŸ”µ</abbr>
1391                                                 Root transRoot = subquery.from(TranslationImpl.class);
1392                                                 subquery.select(builder.count(transRoot.get(&quot;id&quot;)));
1393                                                 Predicate type =
<abbr title="1394                                                         builder.equal(transRoot.get(&quot;entityType&quot;), friendlyType);">1394                                                         builder.equal(transRoot.get(&quot;entityType&quot;), friendðŸ”µ</abbr>
1395                                                 Predicate name =
<abbr title="1396                                                         builder.equal(transRoot.get(&quot;fieldName&quot;), fieldName);">1396                                                         builder.equal(transRoot.get(&quot;fieldName&quot;), fieldNaðŸ”µ</abbr>
1397                                                 String[] split = key.split(&quot;\\.&quot;);
1398                                                 Path x = null;
1399                                                 for (int i = 0; i &lt; split.length; i++) {
1400                                                     if (x == null) {
1401                                                         x = root.get(split[i]);
1402                                                     } else {
1403                                                         x = x.get(split[i]);
1404                                                     }
1405                                                 }
1406 
1407                                                 String likeValue = &quot;%&quot; + value + &quot;%&quot;;
1408                                                 Predicate transValue =
<abbr title="1409                                                         builder.like(transRoot.get(&quot;translatedValue&quot;), likeValue);">1409                                                         builder.like(transRoot.get(&quot;translatedValue&quot;), liðŸ”µ</abbr>
1410                                                 Predicate localeValue =
<abbr title="1411                                                         builder.isTrue(transRoot.get(&quot;localeCode&quot;).in(localeValues));">1411                                                         builder.isTrue(transRoot.get(&quot;localeCode&quot;).in(locðŸ”µ</abbr>
<abbr title="1412                                                 Path y = split.length &gt; 1 ? root.get(split[0]).get(&quot;id&quot;) : root.get(&quot;id&quot;);">1412                                                 Path y = split.length &gt; 1 ? root.get(split[0]).get(&quot;id&quot;) ðŸ”µ</abbr>
<abbr title="1413                                                 Predicate entityId = builder.equal(transRoot.get(&quot;entityId&quot;),">1413                                                 Predicate entityId = builder.equal(transRoot.get(&quot;entityIðŸ”µ</abbr>
1414                                                         y);
1415                                                 if (localeValues.size() &gt; 0) {
<abbr title="1416                                                     subquery.where(builder.and(type, entityId, transValue, name, localeValue));">1416                                                     subquery.where(builder.and(type, entityId, transValueðŸ”µ</abbr>
1417                                                 } else {
<abbr title="1418                                                     subquery.where(builder.and(type, entityId, transValue, name));">1418                                                     subquery.where(builder.and(type, entityId, transValueðŸ”µ</abbr>
1419                                                 }
1420 
1421                                                 Predicate like = builder.like(x,
1422                                                         likeValue);
<abbr title="1423                                                 Predicate predicate = builder.or(like, builder.greaterThan(subquery, 0));">1423                                                 Predicate predicate = builder.or(like, builder.greaterThaðŸ”µ</abbr>
1424                                                 return predicate;
1425                                             }
1426                                         })));
1427                     }
1428                 }
1429                 System.out.println(&quot;&quot;);
1430             }
1431         }
1432     }
1433 
1434     private String getTranslationFriendlyType(String targetClass) {
1435 
1436         TranslatedEntity instance = TranslatedEntity.getInstance(targetClass);
1437         if (instance == null) {
1438             try {
1439                 Class&lt;?&gt;[] interfaces = Class.forName(targetClass).getInterfaces();
1440                 int i = 0;
1441                 while (instance == null &amp;&amp; i &lt; interfaces.length) {
1442                     instance = TranslatedEntity.getInstance(interfaces[i].getName());
1443                     i++;
1444                 }
1445             } catch (ClassNotFoundException e) {
1446 
1447             }
1448         }
1449 
1450         return instance == null ? null : instance.getFriendlyType();
1451     }
1452 
1453     @Override
1454     public Integer getTotalRecords(FetchRequest fetchRequest) {
1455         return fetchWrapper.getTotalRecords(fetchRequest);
1456     }
1457 
1458     @Override
1459     public Integer getTotalRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings) {
1460         try {
<abbr title="1461             return ((Long) criteriaTranslator.translateCountQuery(persistenceManager.getDynamicEntityDao(),">1461             return ((Long) criteriaTranslator.translateCountQuery(persistenceManager.getDynamicEntityDao(ðŸ”µ</abbr>
1462                     ceilingEntity, filterMappings).getSingleResult()).intValue();
1463         } catch (CriteriaConversionException e) {
<abbr title="1464             TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntity);">1464             TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilðŸ”µ</abbr>
<abbr title="1465             return ((Long) builder.toCountQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManager()).getSingleResult()).intValue();">1465             return ((Long) builder.toCountQuery(getPersistenceManager().getDynamicEntityDao().getStandardðŸ”µ</abbr>
1466         }
1467     }
1468 
1469     @Override
<abbr title="1470     public Serializable getMaxValue(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, String maxField) {">1470     public Serializable getMaxValue(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, String maxFðŸ”µ</abbr>
1471         return criteriaTranslator.translateMaxQuery(persistenceManager.getDynamicEntityDao(),
1472                 ceilingEntity, filterMappings, maxField).getSingleResult();
1473     }
1474 
1475     @Override
1476     public List&lt;Serializable&gt; getPersistentRecords(FetchRequest fetchRequest) {
1477         return fetchWrapper.getPersistentRecords(fetchRequest);
1478     }
1479 
1480     @Override
<abbr title="1481     public List&lt;Serializable&gt; getPersistentRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, Integer firstResult, Integer maxResults) {">1481     public List&lt;Serializable&gt; getPersistentRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappinðŸ”µ</abbr>
1482         try {
<abbr title="1483             return criteriaTranslator.translateQuery(persistenceManager.getDynamicEntityDao(), ceilingEntity, filterMappings, firstResult, maxResults).getResultList();">1483             return criteriaTranslator.translateQuery(persistenceManager.getDynamicEntityDao(), ceilingEntðŸ”µ</abbr>
1484         } catch (CriteriaConversionException e) {
<abbr title="1485             TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntity);">1485             TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilðŸ”µ</abbr>
<abbr title="1486             return builder.toQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManager()).getResultList();">1486             return builder.toQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManagerðŸ”µ</abbr>
1487         }
1488     }
1489 
1490     @Override
<abbr title="1491     public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperties) {">1491     public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; merðŸ”µ</abbr>
1492         return validate(entity, populatedInstance, mergedProperties, true);
1493     }
1494 
1495     @Override
<abbr title="1496     public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperties,">1496     public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; merðŸ”µ</abbr>
1497             boolean validateUnsubmittedProperties) {
<abbr title="1498         entityValidatorService.validate(entity, populatedInstance, mergedProperties, this, validateUnsubmittedProperties);">1498         entityValidatorService.validate(entity, populatedInstance, mergedProperties, this, validateUnsubmðŸ”µ</abbr>
1499         return !entity.isValidationFailure();
1500     }
1501 
1502     @Override
1503     public void setPersistenceManager(PersistenceManager persistenceManager) {
1504         this.persistenceManager = persistenceManager;
1505     }
1506 
1507     @Override
1508     public PersistenceModule getCompatibleModule(OperationType operationType) {
1509         return ((InspectHelper) persistenceManager).getCompatibleModule(operationType);
1510     }
1511 
1512     public FieldPersistenceProvider getDefaultFieldPersistenceProvider() {
1513         return defaultFieldPersistenceProvider;
1514     }
1515 
<abbr title="1516     public void setDefaultFieldPersistenceProvider(FieldPersistenceProvider defaultFieldPersistenceProvider) {">1516     public void setDefaultFieldPersistenceProvider(FieldPersistenceProvider defaultFieldPersistenceProvidðŸ”µ</abbr>
1517         this.defaultFieldPersistenceProvider = defaultFieldPersistenceProvider;
1518     }
1519 
1520     public List&lt;FieldPersistenceProvider&gt; getFieldPersistenceProviders() {
1521         return fieldPersistenceProviders;
1522     }
1523 
1524     public void setFieldPersistenceProviders(List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders) {
1525         this.fieldPersistenceProviders = fieldPersistenceProviders;
1526     }
1527 
1528     public CriteriaTranslator getCriteriaTranslator() {
1529         return criteriaTranslator;
1530     }
1531 
1532     public void setCriteriaTranslator(CriteriaTranslator criteriaTranslator) {
1533         this.criteriaTranslator = criteriaTranslator;
1534     }
1535 
1536     public EntityValidatorService getEntityValidatorService() {
1537         return entityValidatorService;
1538     }
1539 
1540     public void setEntityValidatorService(EntityValidatorService entityValidatorService) {
1541         this.entityValidatorService = entityValidatorService;
1542     }
1543 
1544     public RestrictionFactory getRestrictionFactory() {
1545         return restrictionFactory;
1546     }
1547 
1548     public void setRestrictionFactory(RestrictionFactory restrictionFactory) {
1549         this.restrictionFactory = restrictionFactory;
1550     }
1551 
1552     public PersistenceManager getPersistenceManager() {
1553         return persistenceManager;
1554     }
1555 
1556     /**
<abbr title="1557      * Use an alternate approach to generating a fetch query for a collection located inside of an @Embeddable object. Related">1557      * Use an alternate approach to generating a fetch query for a collection located inside of an @EmbedðŸ”µ</abbr>
<abbr title="1558      * to https://hibernate.atlassian.net/browse/HHH-8802. The alternate approach leverages HQL rather than JPA criteria,">1558      * to https://hibernate.atlassian.net/browse/HHH-8802. The alternate approach leverages HQL rather thðŸ”µ</abbr>
1559      * which seems to alleviate the problem.
1560      *
1561      * @param embeddedCollectionPath the path to the collection field itself
1562      * @param filterMappings all the fetch restrictions for this request
1563      * @param collectionClass the type of the collection members
1564      * @return the builder capable of generating an appropriate HQL query
1565      */
<abbr title="1566     protected TypedQueryBuilder getSpecialCaseQueryBuilder(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; filterMappings, String collectionClass) {">1566     protected TypedQueryBuilder getSpecialCaseQueryBuilder(FieldPath embeddedCollectionPath, List&lt;FilterMðŸ”µ</abbr>
1567         String specialPath = embeddedCollectionPath.getTargetProperty();
1568         String[] pieces = specialPath.split(&quot;\\.&quot;);
1569         if (pieces.length != 3) {
<abbr title="1570             throw new CriteriaConversionException(String.format(&quot;Expected to find a target property of format [embedded field].[collection field].[property] for the embedded collection path (%s)&quot;, specialPath), embeddedCollectionPath);">1570             throw new CriteriaConversionException(String.format(&quot;Expected to find a target property of foðŸ”µ</abbr>
1571         }
1572         String expression = specialPath.substring(0, specialPath.lastIndexOf(&quot;.&quot;));
1573         TypedQueryBuilder builder;
1574         try {
1575             builder = new TypedQueryBuilder(Class.forName(collectionClass), &quot;specialEntity&quot;)
1576                     .addJoin(new TQJoin(&quot;specialEntity.&quot; + expression, &quot;embeddedCollection&quot;));
1577         } catch (Exception e) {
1578             throw ExceptionHelper.refineException(e);
1579         }
1580         for (TQRestriction restriction : buildSpecialRestrictions(expression, filterMappings)) {
1581             builder = builder.addRestriction(restriction);
1582         }
<abbr title="1583         for (TQRestriction restriction : buildStandardRestrictions(embeddedCollectionPath, filterMappings)) {">1583         for (TQRestriction restriction : buildStandardRestrictions(embeddedCollectionPath, filterMappingsðŸ”µ</abbr>
1584             builder = builder.addRestriction(restriction);
1585         }
1586         for (FilterMapping mapping : filterMappings) {
1587             if (mapping.getSortDirection() != null) {
<abbr title="1588                 String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().getTargetProperty();">1588                 String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().gðŸ”µ</abbr>
1589                 if (StringUtils.isEmpty(mappingProperty)) {
1590                     mappingProperty = mapping.getFullPropertyName();
1591                 }
<abbr title="1592                 builder = builder.addOrder(new TQOrder(&quot;specialEntity.&quot; + mappingProperty, SortDirection.ASCENDING == mapping.getSortDirection()));">1592                 builder = builder.addOrder(new TQOrder(&quot;specialEntity.&quot; + mappingProperty, SortDirection.ðŸ”µ</abbr>
1593             }
1594         }
1595 
1596         return builder;
1597     }
1598 
1599     /**
<abbr title="1600      * Generate LIKE or EQUALS restrictions for any filter property specified on the root entity (not the collection field in the @Embeddable object)">1600      * Generate LIKE or EQUALS restrictions for any filter property specified on the root entity (not theðŸ”µ</abbr>
1601      *
<abbr title="1602      * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath, java.util.List, String)">1602      * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.moduleðŸ”µ</abbr>
<abbr title="1603      * @param embeddedCollectionPath the path for the collection field in the @Embeddable object - this is what caused the whole thing">1603      * @param embeddedCollectionPath the path for the collection field in the @Embeddable object - this iðŸ”µ</abbr>
1604      * @param filterMappings all the fetch restrictions for this request
1605      * @return the list of restrictions on the root entity
1606      */
<abbr title="1607     protected List&lt;TQRestriction&gt; buildStandardRestrictions(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; filterMappings) {">1607     protected List&lt;TQRestriction&gt; buildStandardRestrictions(FieldPath embeddedCollectionPath, List&lt;FilterðŸ”µ</abbr>
<abbr title="1608         String expression = embeddedCollectionPath.getTargetProperty().substring(0, embeddedCollectionPath.getTargetProperty().lastIndexOf(&quot;.&quot;));">1608         String expression = embeddedCollectionPath.getTargetProperty().substring(0, embeddedCollectionPatðŸ”µ</abbr>
1609         List&lt;TQRestriction&gt; restrictions = new ArrayList&lt;TQRestriction&gt;();
1610         for (FilterMapping mapping : filterMappings) {
1611             checkProperty: {
<abbr title="1612                 String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().getTargetProperty();">1612                 String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().gðŸ”µ</abbr>
1613                 if (StringUtils.isEmpty(mappingProperty)) {
1614                     mappingProperty = mapping.getFullPropertyName();
1615                 }
<abbr title="1616                 if (!embeddedCollectionPath.getTargetProperty().equals(mappingProperty) &amp;&amp; !StringUtils.isEmpty(mappingProperty)) {">1616                 if (!embeddedCollectionPath.getTargetProperty().equals(mappingProperty) &amp;&amp; !StringUtils.iðŸ”µ</abbr>
<abbr title="1617                     PredicateProvider predicateProvider = mapping.getRestriction().getPredicateProvider();">1617                     PredicateProvider predicateProvider = mapping.getRestriction().getPredicateProvider()ðŸ”µ</abbr>
1618                     if (predicateProvider != null) {
<abbr title="1619                         FilterValueConverter converter = mapping.getRestriction().getFilterValueConverter();">1619                         FilterValueConverter converter = mapping.getRestriction().getFilterValueConverterðŸ”µ</abbr>
1620                         if (converter != null &amp;&amp; CollectionUtils.isNotEmpty(mapping.getFilterValues())) {
1621                             Object val = converter.convert(mapping.getFilterValues().get(0));
1622                             if (predicateProvider instanceof LikePredicateProvider) {
<abbr title="1623                                 restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;LIKE&quot;, val + &quot;%&quot;));">1623                                 restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;LðŸ”µ</abbr>
1624                                 break checkProperty;
1625                             } else if (predicateProvider instanceof EqPredicateProvider) {
<abbr title="1626                                 restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;=&quot;, val));">1626                                 restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;=ðŸ”µ</abbr>
1627                                 break checkProperty;
1628                             }
1629                         }
1630                     }
<abbr title="1631                     LOG.warn(String.format(&quot;Unable to filter the embedded collection (%s) on an additional property (%s)&quot;,">1631                     LOG.warn(String.format(&quot;Unable to filter the embedded collection (%s) on an additionaðŸ”µ</abbr>
1632                             StringUtil.sanitize(expression),
1633                             StringUtil.sanitize(mappingProperty)));
1634                 }
1635             }
1636         }
1637 
1638         return restrictions;
1639     }
1640 
1641     /**
<abbr title="1642      * Generate EQUALS restrictions for any filter property specified on the entity member of the collection field in the @Embeddable object">1642      * Generate EQUALS restrictions for any filter property specified on the entity member of the collectðŸ”µ</abbr>
1643      *
<abbr title="1644      * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath, java.util.List, String)">1644      * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.moduleðŸ”µ</abbr>
<abbr title="1645      * @param specialExpression the String representation of the path for the collection field in the @Embeddable object">1645      * @param specialExpression the String representation of the path for the collection field in the @EmðŸ”µ</abbr>
1646      * @param filterMappings all the fetch restrictions for this request
1647      * @return the list of restrictions on the collection in the @Embeddable object
1648      */
<abbr title="1649     protected List&lt;TQRestriction&gt; buildSpecialRestrictions(String specialExpression, List&lt;FilterMapping&gt; filterMappings) {">1649     protected List&lt;TQRestriction&gt; buildSpecialRestrictions(String specialExpression, List&lt;FilterMapping&gt; ðŸ”µ</abbr>
1650         List&lt;TQRestriction&gt; restrictions = new ArrayList&lt;TQRestriction&gt;();
1651         for (FilterMapping mapping : filterMappings) {
<abbr title="1652             if (mapping.getFieldPath() != null &amp;&amp; mapping.getFieldPath().getTargetProperty() != null &amp;&amp; mapping.getFieldPath().getTargetProperty().startsWith(specialExpression)) {">1652             if (mapping.getFieldPath() != null &amp;&amp; mapping.getFieldPath().getTargetProperty() != null &amp;&amp; mðŸ”µ</abbr>
1653                 FilterValueConverter converter = mapping.getRestriction().getFilterValueConverter();
1654                 if (converter != null &amp;&amp; CollectionUtils.isNotEmpty(mapping.getFilterValues())) {
1655                     Object val = converter.convert(mapping.getFilterValues().get(0));
<abbr title="1656                     String property = mapping.getFieldPath().getTargetProperty().substring(mapping.getFieldPath().getTargetProperty().lastIndexOf(&quot;.&quot;) + 1, mapping.getFieldPath().getTargetProperty().length());">1656                     String property = mapping.getFieldPath().getTargetProperty().substring(mapping.getFieðŸ”µ</abbr>
1657                     restrictions.add(new TQRestriction(&quot;embeddedCollection.&quot; + property, &quot;=&quot;, val));
1658                 }
1659             }
1660         }
1661         return restrictions;
1662     }
1663 
1664     protected void cleanupFailedPersistenceAttempt(Serializable instance) throws IllegalAccessException {
1665         //Remove the entity from ORM management - no further attempts to persist
<abbr title="1666         if (getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().contains(instance)) {">1666         if (getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().contains(instance)) ðŸ”µ</abbr>
1667             getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().detach(instance);
1668         }
1669         //Remove the id field value, if it&#x27;s set
<abbr title="1670         String idFieldName = (String) getPersistenceManager().getDynamicEntityDao().getIdMetadata(instance.getClass()).get(&quot;name&quot;);">1670         String idFieldName = (String) getPersistenceManager().getDynamicEntityDao().getIdMetadata(instancðŸ”µ</abbr>
1671         Field idField = FieldUtils.getField(instance.getClass(), idFieldName, true);
1672         if (idField == null) {
<abbr title="1673             throw ExceptionHelper.refineException(new NoSuchFieldException(&quot;Entity &quot; + instance.getClass().getName() + &quot; does not contain id field &quot; + idFieldName));">1673             throw ExceptionHelper.refineException(new NoSuchFieldException(&quot;Entity &quot; + instance.getClass(ðŸ”µ</abbr>
1674         }
1675         idField.setAccessible(true);
1676         if (idField.get(instance) != null) {
1677             idField.set(instance, null);
1678         }
1679     }
1680 
<abbr title="1681     protected Class&lt;?&gt; getMapFieldType(Serializable instance, FieldManager fieldManager, Property property) {">1681     protected Class&lt;?&gt; getMapFieldType(Serializable instance, FieldManager fieldManager, Property propertðŸ”µ</abbr>
1682         Class&lt;?&gt; returnType = null;
<abbr title="1683         Field field = fieldManager.getField(instance.getClass(), property.getName().substring(0, property.getName().indexOf(FieldManager.MAPFIELDSEPARATOR)));">1683         Field field = fieldManager.getField(instance.getClass(), property.getName().substring(0, propertyðŸ”µ</abbr>
1684         java.lang.reflect.Type type = field.getGenericType();
1685         if (type instanceof ParameterizedType) {
1686             ParameterizedType pType = (ParameterizedType) type;
1687             Class&lt;?&gt; clazz;
1688             if (pType.getActualTypeArguments().length &lt; 2) {
1689                 clazz = (Class&lt;?&gt;) pType.getActualTypeArguments()[0];
1690             } else {
1691                 clazz = (Class&lt;?&gt;) pType.getActualTypeArguments()[1];
1692             }
<abbr title="1693             Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(clazz);">1693             Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCðŸ”µ</abbr>
1694             if (!ArrayUtils.isEmpty(entities)) {
1695                 returnType = entities[entities.length - 1];
1696             }
1697         }
1698         return returnType;
1699     }
1700 }</pre></td>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Open Admin Platform
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 
  19 package org.broadleafcommerce.openadmin.server.service.persistence.module;
  20 
  21 import org.apache.commons.beanutils.PropertyUtils;
  22 import org.apache.commons.collections.CollectionUtils;
  23 import org.apache.commons.lang.ArrayUtils;
  24 import org.apache.commons.lang.StringUtils;
  25 import org.apache.commons.lang3.BooleanUtils;
  26 import org.apache.commons.lang3.reflect.FieldUtils;
  27 import org.apache.commons.lang3.reflect.MethodUtils;
  28 import org.apache.commons.logging.Log;
  29 import org.apache.commons.logging.LogFactory;
  30 import org.broadleafcommerce.common.admin.domain.AdminMainEntity;
  31 import org.broadleafcommerce.common.exception.ExceptionHelper;
  32 import org.broadleafcommerce.common.exception.SecurityServiceException;
  33 import org.broadleafcommerce.common.exception.ServiceException;
  34 import org.broadleafcommerce.common.extension.ExtensionResultHolder;
  35 import org.broadleafcommerce.common.i18n.domain.TranslatedEntity;
  36 import org.broadleafcommerce.common.i18n.domain.TranslationImpl;
  37 import org.broadleafcommerce.common.locale.service.LocaleService;
  38 import org.broadleafcommerce.common.money.Money;
  39 import org.broadleafcommerce.common.presentation.client.OperationType;
  40 import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  41 import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  42 import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  43 import org.broadleafcommerce.common.util.FormatUtil;
  44 import org.broadleafcommerce.common.util.StringUtil;
  45 import org.broadleafcommerce.common.util.ValidationUtil;
  46 import org.broadleafcommerce.common.util.dao.TQJoin;
  47 import org.broadleafcommerce.common.util.dao.TQOrder;
  48 import org.broadleafcommerce.common.util.dao.TQRestriction;
  49 import org.broadleafcommerce.common.util.dao.TypedQueryBuilder;
  50 import org.broadleafcommerce.common.web.BroadleafRequestContext;
  51 import org.broadleafcommerce.openadmin.dto.*;
<abbr title="  52 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.AdvancedCollectionFieldMetadataProvider;">  52 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.AdvancedCollectionFieldMetadataProvidðŸ”µ</abbr>
  53 import org.broadleafcommerce.openadmin.server.service.ValidationException;
  54 import org.broadleafcommerce.openadmin.server.service.persistence.ParentEntityPersistenceException;
  55 import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceException;
  56 import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceManager;
  57 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.*;
  58 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPathBuilder;
  59 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.Restriction;
<abbr title="  60 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.converter.FilterValueConverter;">  60 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.converter.FilterValueCoðŸ”µ</abbr>
<abbr title="  61 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.EqPredicateProvider;">  61 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.EqPredicatePrðŸ”µ</abbr>
<abbr title="  62 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.LikePredicateProvider;">  62 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.LikePredicateðŸ”µ</abbr>
<abbr title="  63 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvider;">  63 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvðŸ”µ</abbr>
<abbr title="  64 import org.broadleafcommerce.openadmin.server.service.persistence.module.extension.BasicPersistenceModuleExtensionManager;">  64 import org.broadleafcommerce.openadmin.server.service.persistence.module.extension.BasicPersistenceModuleðŸ”µ</abbr>
<abbr title="  65 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.FieldPersistenceProvider;">  65 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.FieldPersistenceProvideðŸ”µ</abbr>
<abbr title="  66 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddFilterPropertiesRequest;">  66 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddFilterProperðŸ”µ</abbr>
<abbr title="  67 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddSearchMappingRequest;">  67 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddSearchMappinðŸ”µ</abbr>
<abbr title="  68 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.ExtractValueRequest;">  68 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.ExtractValueReqðŸ”µ</abbr>
<abbr title="  69 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.PopulateValueRequest;">  69 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.PopulateValueReðŸ”µ</abbr>
  70 import org.broadleafcommerce.openadmin.server.service.persistence.validation.EntityValidatorService;
<abbr title="  71 import org.broadleafcommerce.openadmin.server.service.persistence.validation.PopulateValueRequestValidator;">  71 import org.broadleafcommerce.openadmin.server.service.persistence.validation.PopulateValueRequestValidatoðŸ”µ</abbr>
  72 import org.broadleafcommerce.openadmin.server.service.persistence.validation.PropertyValidationResult;
  73 import org.broadleafcommerce.openadmin.server.service.type.MetadataProviderResponse;
  74 import org.hibernate.FlushMode;
  75 import org.hibernate.Session;
  76 import org.springframework.beans.BeansException;
  77 import org.springframework.beans.factory.annotation.Value;
  78 import org.springframework.context.ApplicationContext;
  79 import org.springframework.context.ApplicationContextAware;
  80 import org.springframework.context.annotation.Primary;
  81 import org.springframework.context.annotation.Scope;
  82 import org.springframework.stereotype.Component;
  83 import org.springframework.util.Assert;
  84 import java.io.Serializable;
  85 import java.lang.reflect.Field;
  86 import java.lang.reflect.InvocationTargetException;
  87 import java.lang.reflect.Method;
  88 import java.lang.reflect.ParameterizedType;
  89 import java.math.BigDecimal;
  90 import java.sql.Timestamp;
  91 import java.text.DecimalFormat;
  92 import java.text.NumberFormat;
  93 import java.text.SimpleDateFormat;
  94 import java.util.*;
  95 import java.util.Iterator;
  96 import java.util.Map.Entry;
  97 
  98 import javax.annotation.PostConstruct;
  99 import javax.annotation.Resource;
 100 import javax.persistence.criteria.CriteriaBuilder;
 101 import javax.persistence.criteria.From;
 102 import javax.persistence.criteria.Path;
 103 import javax.persistence.criteria.Predicate;
 104 import javax.persistence.criteria.Root;
 105 import javax.persistence.criteria.Subquery;
 106 
 107 /**
 108  * @author jfischer
 109  */
 110 @Primary
 111 @Component(&quot;blBasicPersistenceModule&quot;)
 112 @Scope(&quot;prototype&quot;)
 113 public class BasicPersistenceModule implements PersistenceModule, RecordHelper, ApplicationContextAware {
 114 
 115     private static final Log LOG = LogFactory.getLog(BasicPersistenceModule.class);
 116 
 117     public static final String MAIN_ENTITY_NAME_PROPERTY = &quot;MAIN_ENTITY_NAME&quot;;
 118     public static final String ALTERNATE_ID_PROPERTY = &quot;ALTERNATE_ID&quot;;
 119 
 120     protected ApplicationContext applicationContext;
 121     protected PersistenceManager persistenceManager;
 122 
 123     @Resource(name = &quot;blEntityValidatorService&quot;)
 124     protected EntityValidatorService entityValidatorService;
 125 
 126     @Resource(name = &quot;blPersistenceProviders&quot;)
<abbr title=" 127     protected List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders = new ArrayList&lt;FieldPersistenceProvider&gt;();"> 127     protected List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders = new ArrayList&lt;FieldPersistencePrðŸ”µ</abbr>
 128 
 129     @Resource(name = &quot;blPopulateValueRequestValidators&quot;)
 130     protected List&lt;PopulateValueRequestValidator&gt; populateValidators;
 131 
 132     @Resource(name = &quot;blDefaultFieldPersistenceProvider&quot;)
 133     protected FieldPersistenceProvider defaultFieldPersistenceProvider;
 134 
 135     @Resource(name = &quot;blCriteriaTranslator&quot;)
 136     protected CriteriaTranslator criteriaTranslator;
 137 
 138     @Resource(name = &quot;blRestrictionFactory&quot;)
 139     protected RestrictionFactory restrictionFactory;
 140 
 141     @Resource(name = &quot;blBasicPersistenceModuleExtensionManager&quot;)
 142     protected BasicPersistenceModuleExtensionManager extensionManager;
 143 
 144     @Resource(name = &quot;blFetchWrapper&quot;)
 145     protected FetchWrapper fetchWrapper;
 146 
 147     @Value(&quot;${use.translation.search:false}&quot;)
 148     protected boolean useTranslationSearch;
 149 
 150     @Resource(name = &quot;blLocaleService&quot;)
 151     protected LocaleService localeService;
 152 
 153     @PostConstruct
 154     public void init() {
 155         Collections.sort(fieldPersistenceProviders, new Comparator&lt;FieldPersistenceProvider&gt;() {
 156 
 157             @Override
 158             public int compare(FieldPersistenceProvider o1, FieldPersistenceProvider o2) {
 159                 return Integer.compare(o1.getOrder(), o2.getOrder());
 160             }
 161         });
 162         Collections.sort(populateValidators, new Comparator&lt;PopulateValueRequestValidator&gt;() {
 163 
 164             @Override
 165             public int compare(PopulateValueRequestValidator o1, PopulateValueRequestValidator o2) {
 166                 return Integer.compare(o1.getOrder(), o2.getOrder());
 167             }
 168         });
 169     }
 170 
 171     @Override
 172     public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
 173         this.applicationContext = applicationContext;
 174     }
 175 
 176     @Override
 177     public boolean isCompatible(OperationType operationType) {
<abbr title=" 178         return OperationType.BASIC == operationType || OperationType.NONDESTRUCTIVEREMOVE == operationType;"> 178         return OperationType.BASIC == operationType || OperationType.NONDESTRUCTIVEREMOVE == operationTypðŸ”µ</abbr>
 179     }
 180 
 181     @Override
 182     public FieldManager getFieldManager() {
 183         return persistenceManager.getDynamicEntityDao().getFieldManager();
 184     }
 185 
 186     @Override
 187     public FieldManager getFieldManager(boolean cleanFieldManger) {
 188         return persistenceManager.getDynamicEntityDao().getFieldManager(cleanFieldManger);
 189     }
 190 
 191     @Override
 192     public DecimalFormat getDecimalFormatter() {
 193         BroadleafRequestContext brc = BroadleafRequestContext.getBroadleafRequestContext();
 194         Locale locale = brc.getJavaLocale();
 195         DecimalFormat format = (DecimalFormat) NumberFormat.getInstance(locale);
 196         format.applyPattern(&quot;0.########&quot;);
 197         format.setGroupingUsed(false);
 198         return format;
 199     }
 200 
 201     @Override
 202     public SimpleDateFormat getSimpleDateFormatter() {
 203         return FormatUtil.getDateFormat();
 204     }
 205 
<abbr title=" 206     protected Map&lt;String, FieldMetadata&gt; filterOutCollectionMetadata(Map&lt;String, FieldMetadata&gt; metadata) {"> 206     protected Map&lt;String, FieldMetadata&gt; filterOutCollectionMetadata(Map&lt;String, FieldMetadata&gt; metadata)ðŸ”µ</abbr>
 207         if (metadata == null) {
 208             return null;
 209         }
 210         Map&lt;String, FieldMetadata&gt; newMap = new HashMap&lt;String, FieldMetadata&gt;();
 211         for (Map.Entry&lt;String, FieldMetadata&gt; entry : metadata.entrySet()) {
 212             String fieldName = entry.getKey();
 213             FieldMetadata md = entry.getValue();
<abbr title=" 214             // Detect instances where the actual metadata for the field is some sort of CollectionMetadata but also corresponds"> 214             // Detect instances where the actual metadata for the field is some sort of CollectionMetadatðŸ”µ</abbr>
<abbr title=" 215             // to a ForeignKey and ensure that gets included in the filtered map. That way the {@link BasicPersistenceModule}"> 215             // to a ForeignKey and ensure that gets included in the filtered map. That way the {@link BasðŸ”µ</abbr>
 216             // can appropriate handle filtration and population
 217             if (entry.getValue() instanceof BasicFieldMetadata) {
 218                 newMap.put(fieldName, md);
<abbr title=" 219             } else if (md.getAdditionalMetadata().containsKey(AdvancedCollectionFieldMetadataProvider.FOREIGN_KEY_ADDITIONAL_METADATA_KEY)) {"> 219             } else if (md.getAdditionalMetadata().containsKey(AdvancedCollectionFieldMetadataProvider.FORðŸ”µ</abbr>
 220                 newMap.put(fieldName,
<abbr title=" 221                         (BasicFieldMetadata) md.getAdditionalMetadata().get(AdvancedCollectionFieldMetadataProvider.FOREIGN_KEY_ADDITIONAL_METADATA_KEY));"> 221                         (BasicFieldMetadata) md.getAdditionalMetadata().get(AdvancedCollectionFieldMetadaðŸ”µ</abbr>
 222             }
 223         }
 224 
 225         return newMap;
 226     }
 227 
 228     protected Class&lt;?&gt; getBasicBroadleafType(SupportedFieldType fieldType) {
 229         Class&lt;?&gt; response;
 230         switch (fieldType) {
 231             case BOOLEAN:
 232                 response = Boolean.TYPE;
 233                 break;
 234             case DATE:
 235                 response = Date.class;
 236                 break;
 237             case DECIMAL:
 238                 response = BigDecimal.class;
 239                 break;
 240             case MONEY:
 241                 response = Money.class;
 242                 break;
 243             case INTEGER:
 244                 response = Integer.TYPE;
 245                 break;
 246             case UNKNOWN:
 247                 response = null;
 248                 break;
 249             default:
 250                 response = String.class;
 251                 break;
 252         }
 253 
 254         return response;
 255     }
 256 
 257     @Override
 258     public Serializable createPopulatedInstance(Serializable instance, Entity entity,
 259             Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId) throws ValidationException {
 260         return createPopulatedInstance(instance, entity, unfilteredProperties, setId, true);
 261     }
 262 
 263     @Override
 264     public Serializable createPopulatedInstance(Serializable instance, Entity entity,
<abbr title=" 265             Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId, Boolean validateUnsubmittedProperties) throws ValidationException {"> 265             Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId, Boolean validateUnsubmittedPrðŸ”µ</abbr>
<abbr title=" 266         final Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(unfilteredProperties);"> 266         final Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(unfilteredPropertðŸ”µ</abbr>
 267         FieldManager fieldManager = getFieldManager();
 268         boolean handled = false;
 269         for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {
<abbr title=" 270             MetadataProviderResponse response = fieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfilteredProperties);"> 270             MetadataProviderResponse response = fieldPersistenceProvider.filterProperties(new AddFilterPrðŸ”µ</abbr>
 271             if (MetadataProviderResponse.NOT_HANDLED != response) {
 272                 handled = true;
 273             }
 274             if (MetadataProviderResponse.HANDLED_BREAK == response) {
 275                 break;
 276             }
 277         }
 278         if (!handled) {
<abbr title=" 279             defaultFieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfilteredProperties);"> 279             defaultFieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfiðŸ”µ</abbr>
 280         }
<abbr title=" 281         //Order media field, map field and rule builder fields last, as they will have some validation components that depend on previous values"> 281         //Order media field, map field and rule builder fields last, as they will have some validation coðŸ”µ</abbr>
 282         Property[] sortedProperties = entity.getProperties();
 283         Arrays.sort(sortedProperties, new Comparator&lt;Property&gt;() {
 284 
 285             @Override
 286             public int compare(Property o1, Property o2) {
 287                 BasicFieldMetadata mo1 = (BasicFieldMetadata) mergedProperties.get(o1.getName());
 288                 BasicFieldMetadata mo2 = (BasicFieldMetadata) mergedProperties.get(o2.getName());
<abbr title=" 289                 boolean isLate1 = mo1 != null &amp;&amp; mo1.getFieldType() != null &amp;&amp; mo1.getName() != null &amp;&amp; (SupportedFieldType.RULE_SIMPLE==mo1.getFieldType() ||"> 289                 boolean isLate1 = mo1 != null &amp;&amp; mo1.getFieldType() != null &amp;&amp; mo1.getName() != null &amp;&amp; (ðŸ”µ</abbr>
 290                         SupportedFieldType.RULE_WITH_QUANTITY==mo1.getFieldType() ||
 291                         SupportedFieldType.RULE_SIMPLE_TIME==mo1.getFieldType() ||
<abbr title=" 292                         SupportedFieldType.MEDIA==mo1.getFieldType() || o1.getName().contains(FieldManager.MAPFIELDSEPARATOR));"> 292                         SupportedFieldType.MEDIA==mo1.getFieldType() || o1.getName().contains(FieldManageðŸ”µ</abbr>
<abbr title=" 293                 boolean isLate2 = mo2 != null &amp;&amp; mo2.getFieldType() != null &amp;&amp; mo2.getName() != null &amp;&amp; (SupportedFieldType.RULE_SIMPLE==mo2.getFieldType() ||"> 293                 boolean isLate2 = mo2 != null &amp;&amp; mo2.getFieldType() != null &amp;&amp; mo2.getName() != null &amp;&amp; (ðŸ”µ</abbr>
 294                         SupportedFieldType.RULE_WITH_QUANTITY==mo2.getFieldType() ||
 295                         SupportedFieldType.RULE_SIMPLE_TIME==mo2.getFieldType() ||
<abbr title=" 296                         SupportedFieldType.MEDIA==mo2.getFieldType() || o2.getName().contains(FieldManager.MAPFIELDSEPARATOR));"> 296                         SupportedFieldType.MEDIA==mo2.getFieldType() || o2.getName().contains(FieldManageðŸ”µ</abbr>
 297                 if (isLate1 &amp;&amp; !isLate2) {
 298                     return 1;
 299                 } else if (!isLate1 &amp;&amp; isLate2) {
 300                     return -1;
 301                 }
 302                 return 0;
 303             }
 304         });
<abbr title=" 305         Session session = getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().unwrap(Session.class);"> 305         Session session = getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().unwrapðŸ”µ</abbr>
 306         FlushMode originalFlushMode = session.getHibernateFlushMode();
 307         try {
 308             session.setHibernateFlushMode(FlushMode.MANUAL);
 309             RuntimeException entityPersistenceException = null;
 310             for (Property property : sortedProperties) {
<abbr title=" 311                 BasicFieldMetadata metadata = (BasicFieldMetadata) mergedProperties.get(property.getName());"> 311                 BasicFieldMetadata metadata = (BasicFieldMetadata) mergedProperties.get(property.getName(ðŸ”µ</abbr>
 312                 Class&lt;?&gt; returnType;
<abbr title=" 313                 if (!property.getName().contains(FieldManager.MAPFIELDSEPARATOR) &amp;&amp; !property.getName().startsWith(&quot;__&quot;)) {"> 313                 if (!property.getName().contains(FieldManager.MAPFIELDSEPARATOR) &amp;&amp; !property.getName().sðŸ”µ</abbr>
 314                     Field field = fieldManager.getField(instance.getClass(), property.getName());
 315                     if (field == null) {
<abbr title=" 316                         LOG.debug(&quot;Unable to find a bean property for the reported property: &quot; + StringUtil.sanitize(property.getName()) + &quot;. Ignoring property.&quot;);"> 316                         LOG.debug(&quot;Unable to find a bean property for the reported property: &quot; + StringUtðŸ”µ</abbr>
 317                         continue;
 318                     }
 319                     returnType = field.getType();
 320                 } else {
 321                     if (metadata == null) {
<abbr title=" 322                         LOG.debug(&quot;Unable to find a metadata property for the reported property: &quot; + StringUtil.sanitize(property.getName()) + &quot;. Ignoring property.&quot;);"> 322                         LOG.debug(&quot;Unable to find a metadata property for the reported property: &quot; + StriðŸ”µ</abbr>
 323                         continue;
 324                     }
 325                     returnType = getMapFieldType(instance, fieldManager, property);
 326                     if (returnType == null) {
 327                         returnType = getBasicBroadleafType(metadata.getFieldType());
 328                     }
 329                 }
 330                 if (returnType == null) {
<abbr title=" 331                     throw new IllegalAccessException(&quot;Unable to determine the value type for the property (&quot; + property.getName() + &quot;)&quot;);"> 331                     throw new IllegalAccessException(&quot;Unable to determine the value type for the propertyðŸ”µ</abbr>
 332                 }
 333                 String value = property.getValue();
 334                 if (metadata != null) {
 335 
 336                     if (metadata.getFieldType().equals(SupportedFieldType.BOOLEAN)) {
 337                         if (value == null) {
 338                             String defaultValue = metadata.getDefaultValue();
 339                             value = StringUtils.isBlank(defaultValue)? &quot;false&quot; : defaultValue;
 340                         }
 341                     } else if (metadata.getFieldType().equals(SupportedFieldType.DATE)) {
 342                         if (StringUtils.isEmpty(value)) {
 343                             value = null;
 344                         }
 345                     }
 346 
<abbr title=" 347                     if (attemptToPopulateValue(property, fieldManager, instance, setId, metadata, entity, value)) {"> 347                     if (attemptToPopulateValue(property, fieldManager, instance, setId, metadata, entity,ðŸ”µ</abbr>
 348                         boolean isValid = true;
<abbr title=" 349                         PopulateValueRequest request = new PopulateValueRequest(setId, fieldManager, property, metadata, returnType, value, persistenceManager, this, entity.isPreAdd());"> 349                         PopulateValueRequest request = new PopulateValueRequest(setId, fieldManager, propðŸ”µ</abbr>
 350                         handled = false;
 351                         if (value != null) {
 352                             for (PopulateValueRequestValidator validator : populateValidators) {
<abbr title=" 353                                 PropertyValidationResult validationResult = validator.validate(request, instance);"> 353                                 PropertyValidationResult validationResult = validator.validate(request, iðŸ”µ</abbr>
 354                                 if (!validationResult.isValid()) {
<abbr title=" 355                                     entity.addValidationError(property.getName(), validationResult.getErrorMessage());"> 355                                     entity.addValidationError(property.getName(), validationResult.getErrðŸ”µ</abbr>
 356                                     isValid = false;
 357                                 }
 358                             }
 359                         }
 360                         if (isValid) {
 361                             try {
 362                                 boolean isBreakDetected = false;
<abbr title=" 363                                 for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {"> 363                                 for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceðŸ”µ</abbr>
<abbr title=" 364                                     if ((!isBreakDetected || fieldPersistenceProvider.alwaysRun()) &amp;&amp; (value != null || fieldPersistenceProvider.canHandlePopulateNull())) {"> 364                                     if ((!isBreakDetected || fieldPersistenceProvider.alwaysRun()) &amp;&amp; (vaðŸ”µ</abbr>
<abbr title=" 365                                         MetadataProviderResponse response = fieldPersistenceProvider.populateValue(request, instance);"> 365                                         MetadataProviderResponse response = fieldPersistenceProvider.popuðŸ”µ</abbr>
 366                                         if (MetadataProviderResponse.NOT_HANDLED != response) {
 367                                             handled = true;
 368                                         }
 369                                         if (MetadataProviderResponse.HANDLED_BREAK == response) {
 370                                             isBreakDetected = true;
 371                                         }
 372                                     }
 373                                 }
 374                                 if (!handled) {
 375                                     if (value == null) {
 376                                         property.setIsDirty(true);
 377                                     }
<abbr title=" 378                                     defaultFieldPersistenceProvider.populateValue(new PopulateValueRequest(setId, fieldManager, property, metadata, returnType, value, persistenceManager, this, entity.isPreAdd()), instance);"> 378                                     defaultFieldPersistenceProvider.populateValue(new PopulateValueRequesðŸ”µ</abbr>
 379                                     if (value == null) {
 380                                         fieldManager.setFieldValue(instance, property.getName(), null);
 381                                     }
 382                                 }
<abbr title=" 383                             } catch (ParentEntityPersistenceException | javax.validation.ValidationException e) {"> 383                             } catch (ParentEntityPersistenceException | javax.validation.ValidationExceptðŸ”µ</abbr>
 384                                 entityPersistenceException = e;
 385                                 cleanupFailedPersistenceAttempt(instance);
 386                                 break;
 387                             }
 388                         }
 389                     }
 390                 }
 391             }
 392             // Only check validation if not the initial add
 393             if (!entity.isPreAdd()) {
 394                 validate(entity, instance, mergedProperties, validateUnsubmittedProperties);
 395             }
<abbr title=" 396             //if validation failed, refresh the current instance so that none of the changes will be persisted"> 396             //if validation failed, refresh the current instance so that none of the changes will be persðŸ”µ</abbr>
 397             if (entity.isValidationFailure()) {
 398                 //only refresh the instance if it was managed to begin with
<abbr title=" 399                 if (persistenceManager.getDynamicEntityDao().getStandardEntityManager().contains(instance)) {"> 399                 if (persistenceManager.getDynamicEntityDao().getStandardEntityManager().contains(instanceðŸ”µ</abbr>
 400                     persistenceManager.getDynamicEntityDao().refresh(instance);
 401                 }
 402 
<abbr title=" 403                 //re-initialize the valid properties for the entity in order to deal with the potential of not"> 403                 //re-initialize the valid properties for the entity in order to deal with the potential oðŸ”µ</abbr>
 404                 //completely sending over all checkbox/radio fields
 405                 List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
 406                 entityList.add(instance);
 407                 Entity invalid = getRecords(mergedProperties, entityList, null, null, null)[0];
 408                 invalid.setPropertyValidationErrors(entity.getPropertyValidationErrors());
 409                 invalid.setGlobalValidationErrors(entity.getGlobalValidationErrors());
 410                 invalid.overridePropertyValues(entity);
 411 
<abbr title=" 412                 String message = ValidationUtil.buildErrorMessage(invalid.getPropertyValidationErrors(), invalid.getGlobalValidationErrors());"> 412                 String message = ValidationUtil.buildErrorMessage(invalid.getPropertyValidationErrors(), ðŸ”µ</abbr>
 413                 throw new ValidationException(invalid, message);
 414             } else if (entityPersistenceException != null) {
 415                 throw ExceptionHelper.refineException(entityPersistenceException.getCause());
 416             } else {
 417                 fieldManager.persistMiddleEntities();
 418             }
 419         } catch (IllegalAccessException e) {
 420             throw new PersistenceException(e);
 421         } catch (InstantiationException e) {
 422             throw new PersistenceException(e);
 423         } finally {
 424             session.setHibernateFlushMode(originalFlushMode);
 425         }
 426         return instance;
 427     }
 428 
<abbr title=" 429     protected boolean attemptToPopulateValue(Property property, FieldManager fieldManager, Serializable instance,"> 429     protected boolean attemptToPopulateValue(Property property, FieldManager fieldManager, Serializable iðŸ”µ</abbr>
<abbr title=" 430                                              Boolean setId, BasicFieldMetadata metadata, Entity entity, String value) throws IllegalAccessException {"> 430                                              Boolean setId, BasicFieldMetadata metadata, Entity entity, SðŸ”µ</abbr>
 431         Boolean mutable = metadata.getMutable();
 432         Boolean readOnly = metadata.getReadOnly();
<abbr title=" 433         boolean generalConditionsMet = (mutable == null || mutable) &amp;&amp; (readOnly == null || !readOnly) &amp;&amp; property.getEnabled();"> 433         boolean generalConditionsMet = (mutable == null || mutable) &amp;&amp; (readOnly == null || !readOnly) &amp;&amp;ðŸ”µ</abbr>
 434 
 435         if (generalConditionsMet &amp;&amp; value == null) {
 436             boolean currentValueIsNotNull = false;
 437             try {
 438                 currentValueIsNotNull = fieldManager.getFieldValue(instance, property.getName()) != null;
 439             } catch (FieldNotAvailableException e) {
 440                 throw new IllegalArgumentException(e);
 441             }
 442 
 443             boolean valueIsNotNullId = metadata.getFieldType() != SupportedFieldType.ID || setId;
 444             boolean valueIsNotPassword = metadata.getFieldType() != SupportedFieldType.PASSWORD;
 445 
 446             return currentValueIsNotNull &amp;&amp; !entity.isPreAdd() &amp;&amp; valueIsNotNullId &amp;&amp; valueIsNotPassword;
 447         }
 448         return generalConditionsMet;
 449     }
 450 
 451     @Override
<abbr title=" 452     public Entity getRecord(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, Serializable record, Map&lt;String, FieldMetadata&gt; alternateMergedProperties, String pathToTargetObject) {"> 452     public Entity getRecord(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, Serializable record, Map&lt;ðŸ”µ</abbr>
 453         List&lt;Serializable&gt; records = new ArrayList&lt;Serializable&gt;(1);
 454         records.add(record);
<abbr title=" 455         Entity[] productEntities = getRecords(primaryMergedProperties, records, alternateMergedProperties, pathToTargetObject, null);"> 455         Entity[] productEntities = getRecords(primaryMergedProperties, records, alternateMergedPropertiesðŸ”µ</abbr>
 456         return productEntities[0];
 457     }
 458 
 459     @Override
<abbr title=" 460     public Entity getRecord(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, Serializable record) {"> 460     public Entity getRecord(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, SðŸ”µ</abbr>
<abbr title=" 461         Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persistencePerspective);"> 461         Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getNamðŸ”µ</abbr>
 462         return getRecord(mergedProperties, record, null, null);
 463     }
 464 
 465     @Override
<abbr title=" 466     public Entity[] getRecords(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, List&lt;? extends Serializable&gt; records) {"> 466     public Entity[] getRecords(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspectiveðŸ”µ</abbr>
<abbr title=" 467         Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persistencePerspective);"> 467         Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getNamðŸ”µ</abbr>
 468         return getRecords(mergedProperties, records, null, null, null);
 469     }
 470 
 471     @Override
<abbr title=" 472     public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persistencePerspective) {"> 472     public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspectiveðŸ”µ</abbr>
<abbr title=" 473         return persistenceManager.getDynamicEntityDao().getSimpleMergedProperties(entityName, persistencePerspective);"> 473         return persistenceManager.getDynamicEntityDao().getSimpleMergedProperties(entityName, persistenceðŸ”µ</abbr>
 474     }
 475 
 476     @Override
<abbr title=" 477     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, List&lt;? extends Serializable&gt; records) {"> 477     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, List&lt;? extends SerialiðŸ”µ</abbr>
 478         return getRecords(primaryMergedProperties, records, null, null, null);
 479     }
 480 
 481     @Override
 482     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryUnfilteredMergedProperties,
 483                                List&lt;? extends Serializable&gt; records,
 484                                Map&lt;String, FieldMetadata&gt; alternateUnfilteredMergedProperties,
 485                                String pathToTargetObject) {
<abbr title=" 486         return getRecords(primaryUnfilteredMergedProperties, records, alternateUnfilteredMergedProperties, pathToTargetObject, null);"> 486         return getRecords(primaryUnfilteredMergedProperties, records, alternateUnfilteredMergedPropertiesðŸ”µ</abbr>
 487     }
 488 
 489     @Override
 490     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryUnfilteredMergedProperties,
 491                                List&lt;? extends Serializable&gt; records,
 492                                Map&lt;String, FieldMetadata&gt; alternateUnfilteredMergedProperties,
 493                                String pathToTargetObject,
 494                                String[] customCriteria) {
<abbr title=" 495         Map&lt;String, FieldMetadata&gt; primaryMergedProperties = filterOutCollectionMetadata(primaryUnfilteredMergedProperties);"> 495         Map&lt;String, FieldMetadata&gt; primaryMergedProperties = filterOutCollectionMetadata(primaryUnfiltereðŸ”µ</abbr>
<abbr title=" 496         Map&lt;String, FieldMetadata&gt; alternateMergedProperties = filterOutCollectionMetadata(alternateUnfilteredMergedProperties);"> 496         Map&lt;String, FieldMetadata&gt; alternateMergedProperties = filterOutCollectionMetadata(alternateUnfilðŸ”µ</abbr>
 497         Entity[] entities = new Entity[records.size()];
 498         int j = 0;
 499         for (Serializable recordEntity : records) {
 500             Serializable entity;
 501             if (pathToTargetObject != null) {
 502                 try {
<abbr title=" 503                     entity = (Serializable) getFieldManager().getFieldValue(recordEntity, pathToTargetObject);"> 503                     entity = (Serializable) getFieldManager().getFieldValue(recordEntity, pathToTargetObjðŸ”µ</abbr>
 504                 } catch (Exception e) {
 505                     throw new PersistenceException(e);
 506                 }
 507             } else {
 508                 entity = recordEntity;
 509             }
 510             Entity entityItem = new Entity();
 511             entityItem.setType(new String[] { entity.getClass().getName() });
 512             entities[j] = entityItem;
 513 
 514             List&lt;Property&gt; props = new ArrayList&lt;Property&gt;(primaryMergedProperties.size());
<abbr title=" 515             extractPropertiesFromPersistentEntity(primaryMergedProperties, entity, props, customCriteria);"> 515             extractPropertiesFromPersistentEntity(primaryMergedProperties, entity, props, customCriteria)ðŸ”µ</abbr>
 516             if (alternateMergedProperties != null) {
<abbr title=" 517                 extractPropertiesFromPersistentEntity(alternateMergedProperties, recordEntity, props, customCriteria);"> 517                 extractPropertiesFromPersistentEntity(alternateMergedProperties, recordEntity, props, cusðŸ”µ</abbr>
 518             }
 519 
 520             // Try to add the &quot;main name&quot; property. Log a debug message if we can&#x27;t
 521             try {
 522                 Property p = new Property();
 523                 p.setName(MAIN_ENTITY_NAME_PROPERTY);
 524                 String mainEntityName = (String) MethodUtils.invokeMethod(entity, &quot;getMainEntityName&quot;);
 525                 p.setValue(mainEntityName);
 526                 props.add(p);
 527             } catch (Exception e) {
 528                 LOG.debug(String.format(&quot;Could not execute the getMainEntityName() method for [%s]&quot;,
 529                         entity.getClass().getName()), e);
 530             }
 531 
 532             // Try to add the alternate id property if available
 533             if (alternateMergedProperties != null) {
 534                 for (Entry&lt;String, FieldMetadata&gt; entry : alternateMergedProperties.entrySet()) {
 535                     if (entry.getValue() instanceof BasicFieldMetadata) {
<abbr title=" 536                         if (((BasicFieldMetadata) entry.getValue()).getFieldType() == SupportedFieldType.ID) {"> 536                         if (((BasicFieldMetadata) entry.getValue()).getFieldType() == SupportedFieldType.ðŸ”µ</abbr>
<abbr title=" 537                             Map&lt;String, FieldMetadata&gt; alternateOnEntity = new HashMap&lt;String, FieldMetadata&gt;();"> 537                             Map&lt;String, FieldMetadata&gt; alternateOnEntity = new HashMap&lt;String, FieldMetadðŸ”µ</abbr>
 538                             alternateOnEntity.put(entry.getKey(), entry.getValue());
 539                             List&lt;Property&gt; props2 = new ArrayList&lt;Property&gt;();
<abbr title=" 540                             extractPropertiesFromPersistentEntity(alternateOnEntity, recordEntity, props2, customCriteria);"> 540                             extractPropertiesFromPersistentEntity(alternateOnEntity, recordEntity, props2ðŸ”µ</abbr>
 541                             List&lt;Property&gt; filtered = new ArrayList&lt;Property&gt;();
 542                             for (Property prop : props2) {
 543                                 if (!prop.getName().startsWith(&quot;__&quot;)) {
 544                                     filtered.add(prop);
 545                                 }
 546                             }
 547                             if (filtered.size() == 1 &amp;&amp; !filtered.get(0).getName().contains(&quot;.&quot;)) {
 548                                 Property alternateIdProp = filtered.get(0);
 549                                 alternateIdProp.setName(ALTERNATE_ID_PROPERTY);
 550                                 props.add(alternateIdProp);
 551                             }
 552                         }
 553                     }
 554                 }
 555             }
 556 
 557             Property[] properties = new Property[props.size()];
 558             properties = props.toArray(properties);
 559             entityItem.setProperties(properties);
 560             j++;
 561         }
 562 
 563         return entities;
 564     }
 565 
 566     @Override
 567     public Entity[] getRecords(FetchExtractionRequest fetchExtractionRequest) {
 568         return fetchWrapper.getRecords(fetchExtractionRequest);
 569     }
 570 
 571     protected void extractPropertiesFromPersistentEntity(Map&lt;String, FieldMetadata&gt; mergedProperties,
 572                                                          Serializable entity,
 573                                                          List&lt;Property&gt; props,
 574                                                          String[] customCriteria) {
 575         FieldManager fieldManager = getFieldManager();
 576         try {
 577             if (entity instanceof AdminMainEntity) {
 578                 //Create an invisible property for the admin main entity name, if applicable.
 579                 //This is useful for ToOneLookups if that ToOneLookup uses AdminMainEntity to drive
 580                 //its display name.
 581                 try {
 582                     Property propertyItem = new Property();
 583                     propertyItem.setName(AdminMainEntity.MAIN_ENTITY_NAME_PROPERTY);
 584                     propertyItem.setValue(((AdminMainEntity) entity).getMainEntityName());
 585                     props.add(propertyItem);
 586                 } catch (Exception e) {
<abbr title=" 587                     //do nothing here except for not add the property. Exceptions could occur when there is a validation"> 587                     //do nothing here except for not add the property. Exceptions could occur when there ðŸ”µ</abbr>
<abbr title=" 588                     //issue and some properties/relationships that are used for gleaning the main entity name end up"> 588                     //issue and some properties/relationships that are used for gleaning the main entity ðŸ”µ</abbr>
 589                     //not being set
 590                 }
 591             }
 592             for (Entry&lt;String, FieldMetadata&gt; entry : mergedProperties.entrySet()) {
 593                 String property = entry.getKey();
 594                 BasicFieldMetadata metadata = (BasicFieldMetadata) entry.getValue();
<abbr title=" 595                 if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(entity.getClass()) || entity.getClass().isAssignableFrom(Class.forName(metadata.getInheritedFromType()))) {"> 595                 if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(entity.getClass()) ||ðŸ”µ</abbr>
 596                     boolean proceed = true;
 597                     if (property.contains(&quot;.&quot;)) {
 598                         StringTokenizer tokens = new StringTokenizer(property, &quot;.&quot;);
 599                         Object testObject = entity;
 600                         while (tokens.hasMoreTokens()) {
 601                             String token = tokens.nextToken();
 602                             if (tokens.hasMoreTokens()) {
 603                                 try {
 604                                     testObject = fieldManager.getFieldValue(testObject, token);
 605                                 } catch (FieldNotAvailableException e) {
 606                                     proceed = false;
 607                                     break;
 608                                 }
 609                                 if (testObject == null) {
 610                                     Property propertyItem = new Property();
 611                                     propertyItem.setName(property);
 612                                     if (props.contains(propertyItem)) {
 613                                         proceed = false;
 614                                         break;
 615                                     }
 616                                     propertyItem.setValue(null);
 617                                     props.add(propertyItem);
 618                                     proceed = false;
 619                                     break;
 620                                 }
 621                             }
 622                         }
 623                     }
 624                     if (!proceed) {
 625                         continue;
 626                     }
 627 
 628                     boolean isFieldAccessible = true;
 629                     Object value = null;
 630                     try {
 631                         value = fieldManager.getFieldValue(entity, property);
 632                     } catch (FieldNotAvailableException e) {
 633                         isFieldAccessible = false;
 634                     }
 635                     checkField:
 636                     {
 637                         if (isFieldAccessible) {
 638                             Property propertyItem = new Property();
 639                             propertyItem.setName(property);
 640                             if (props.contains(propertyItem)) {
 641                                 continue;
 642                             }
 643                             props.add(propertyItem);
 644                             String displayVal = propertyItem.getDisplayValue();
 645                             boolean handled = false;
<abbr title=" 646                             for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {"> 646                             for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProvðŸ”µ</abbr>
<abbr title=" 647                                 MetadataProviderResponse response = fieldPersistenceProvider.extractValue("> 647                                 MetadataProviderResponse response = fieldPersistenceProvider.extractValueðŸ”µ</abbr>
<abbr title=" 648                                         new ExtractValueRequest(props, fieldManager, metadata, value, displayVal,"> 648                                         new ExtractValueRequest(props, fieldManager, metadata, value, disðŸ”µ</abbr>
<abbr title=" 649                                                 persistenceManager, this, entity, customCriteria), propertyItem);"> 649                                                 persistenceManager, this, entity, customCriteria), properðŸ”µ</abbr>
 650                                 if (MetadataProviderResponse.NOT_HANDLED != response) {
 651                                     handled = true;
 652                                 }
 653                                 if (MetadataProviderResponse.HANDLED_BREAK == response) {
 654                                     break;
 655                                 }
 656                             }
 657                             if (!handled) {
 658                                 defaultFieldPersistenceProvider.extractValue(
<abbr title=" 659                                         new ExtractValueRequest(props, fieldManager, metadata, value, displayVal,"> 659                                         new ExtractValueRequest(props, fieldManager, metadata, value, disðŸ”µ</abbr>
<abbr title=" 660                                                 persistenceManager, this, entity, customCriteria), propertyItem);"> 660                                                 persistenceManager, this, entity, customCriteria), properðŸ”µ</abbr>
 661                             }
 662                             break checkField;
 663                         }
 664                         //try a direct property acquisition via reflection
 665                         try {
 666                             String strVal = null;
 667                             Method method;
 668                             try {
 669                                 //try a &#x27;get&#x27; prefixed mutator first
<abbr title=" 670                                 String temp = &quot;get&quot; + property.substring(0, 1).toUpperCase() + property.substring(1, property.length());"> 670                                 String temp = &quot;get&quot; + property.substring(0, 1).toUpperCase() + property.sðŸ”µ</abbr>
 671                                 method = entity.getClass().getMethod(temp, new Class[] {});
 672                             } catch (NoSuchMethodException e) {
 673                                 method = entity.getClass().getMethod(property, new Class[] {});
 674                             }
 675                             value = method.invoke(entity, new String[] {});
 676                             Property propertyItem = new Property();
 677                             propertyItem.setName(property);
 678                             if (props.contains(propertyItem)) {
 679                                 continue;
 680                             }
 681                             props.add(propertyItem);
 682                             if (value == null) {
 683                                 strVal = null;
 684                             } else {
 685                                 if (Date.class.isAssignableFrom(value.getClass())) {
 686                                     strVal = getSimpleDateFormatter().format((Date) value);
 687                                 } else if (Timestamp.class.isAssignableFrom(value.getClass())) {
<abbr title=" 688                                     strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value).getTime()));"> 688                                     strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value)ðŸ”µ</abbr>
 689                                 } else if (Calendar.class.isAssignableFrom(value.getClass())) {
<abbr title=" 690                                     strVal = getSimpleDateFormatter().format(((Calendar) value).getTime());"> 690                                     strVal = getSimpleDateFormatter().format(((Calendar) value).getTime()ðŸ”µ</abbr>
 691                                 } else if (Double.class.isAssignableFrom(value.getClass())) {
 692                                     strVal = getDecimalFormatter().format(value);
 693                                 } else if (BigDecimal.class.isAssignableFrom(value.getClass())) {
 694                                     strVal = getDecimalFormatter().format(value);
 695                                 } else {
 696                                     strVal = value.toString();
 697                                 }
 698                             }
 699                             propertyItem.setValue(strVal);
 700                         } catch (NoSuchMethodException e) {
<abbr title=" 701                             LOG.debug(&quot;Unable to find a specified property in the entity: &quot; + StringUtil.sanitize(property));"> 701                             LOG.debug(&quot;Unable to find a specified property in the entity: &quot; + StringUtil.ðŸ”µ</abbr>
 702                             //do nothing - this property is simply not in the bean
 703                         }
 704                     }
 705                 }
 706             }
 707         } catch (ClassNotFoundException e) {
 708             throw new PersistenceException(e);
 709         } catch (IllegalAccessException e) {
 710             throw new PersistenceException(e);
 711         } catch (InvocationTargetException e) {
 712             throw new PersistenceException(e);
 713         }
 714     }
 715 
 716     @Override
 717     public String getStringValueFromGetter(Serializable instance, String propertyName)
 718             throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
 719         Object value = PropertyUtils.getProperty(instance, propertyName);
 720         return formatValue(value);
 721     }
 722 
 723     @Override
 724     public String formatValue(Object value) {
 725         String strVal;
 726         if (value == null) {
 727             strVal = null;
 728         } else {
 729             if (Date.class.isAssignableFrom(value.getClass())) {
 730                 strVal = getSimpleDateFormatter().format((Date) value);
 731             } else if (Timestamp.class.isAssignableFrom(value.getClass())) {
 732                 strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value).getTime()));
 733             } else if (Calendar.class.isAssignableFrom(value.getClass())) {
 734                 strVal = getSimpleDateFormatter().format(((Calendar) value).getTime());
 735             } else if (Double.class.isAssignableFrom(value.getClass())) {
 736                 strVal = getDecimalFormatter().format(value);
 737             } else if (BigDecimal.class.isAssignableFrom(value.getClass())) {
 738                 strVal = getDecimalFormatter().format(value);
 739             } else {
 740                 strVal = value.toString();
 741             }
 742         }
 743         return strVal;
 744     }
 745 
<abbr title=" 746     protected EntityResult update(PersistencePackage persistencePackage, Object primaryKey, boolean includeRealEntity) throws ServiceException {"> 746     protected EntityResult update(PersistencePackage persistencePackage, Object primaryKey, boolean incluðŸ”µ</abbr>
 747         EntityResult entityResult = new EntityResult();
 748         Entity entity = persistencePackage.getEntity();
 749         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title=" 750         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);"> 750         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(ðŸ”µ</abbr>
 751         if (foreignKey != null &amp;&amp; !foreignKey.getMutable()) {
 752             throw new SecurityServiceException(&quot;Entity not mutable&quot;);
 753         }
 754         try {
<abbr title=" 755             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());"> 755             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingðŸ”µ</abbr>
<abbr title=" 756             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties("> 756             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMerðŸ”µ</abbr>
 757                     persistencePackage.getCeilingEntityFullyQualifiedClassname(),
 758                     entities,
 759                     foreignKey,
 760                     persistencePerspective.getAdditionalNonPersistentProperties(),
 761                     persistencePerspective.getAdditionalForeignKeys(),
 762                     MergedPropertyType.PRIMARY,
 763                     persistencePerspective.getPopulateToOneFields(),
 764                     persistencePerspective.getIncludeFields(),
 765                     persistencePerspective.getExcludeFields(),
 766                     persistencePerspective.getConfigurationKey(),
 767                     &quot;&quot;
 768                     );
 769             if (primaryKey == null) {
 770                 primaryKey = getPrimaryKey(entity, mergedProperties);
 771             }
<abbr title=" 772             Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getType()[0]), primaryKey);"> 772             Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entitðŸ”µ</abbr>
 773 
 774             Assert.isTrue(instance != null, &quot;Entity not found&quot;);
 775 
 776             if (!entity.isValidationFailure()) {
 777                 //Re-Balance the list if it is a Foreign Key toMany collection with a sort field property
 778                 if (foreignKey != null &amp;&amp; foreignKey.getSortField() != null &amp;&amp;
 779                         entity.findProperty(foreignKey.getSortField()) != null &amp;&amp;
 780                         entity.findProperty(foreignKey.getSortField()).getValue() != null) {
<abbr title=" 781                     ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;();"> 781                     ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;(ðŸ”µ</abbr>
 782                     extensionManager.getProxy().rebalanceForUpdate(this, persistencePackage, instance,
 783                             mergedProperties, primaryKey, result);
 784                     instance = result.getResult();
 785                 } else {
<abbr title=" 786                     instance = createPopulatedInstance(instance, entity, mergedProperties, false, persistencePackage.isValidateUnsubmittedProperties());"> 786                     instance = createPopulatedInstance(instance, entity, mergedProperties, false, persistðŸ”µ</abbr>
 787                 }
 788 
 789                 instance = persistenceManager.getDynamicEntityDao().merge(instance);
 790                 if (includeRealEntity) {
 791                     entityResult.setEntityBackingObject(instance);
 792                 }
 793 
 794                 List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
 795                 entityList.add(instance);
 796 
 797                 entity = getRecords(mergedProperties, entityList, null, null, null)[0];
 798                 entityResult.setEntity(entity);
 799                 return entityResult;
 800             } else {
 801                 entityResult.setEntity(entity);
 802                 return entityResult;
 803             }
 804         } catch (Exception e) {
 805             throw new ServiceException(&quot;Problem updating entity : &quot; + e.getMessage(), e);
 806         }
 807     }
 808 
 809     @Override
 810     public String getIdPropertyName(String entityClass) {
 811         return persistenceManager.getIdPropertyName(entityClass);
 812     }
 813 
 814     public String getIdPropertyName(Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
<abbr title=" 815         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);"> 815         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredPropertðŸ”µ</abbr>
 816         for (String property : mergedProperties.keySet()) {
 817             BasicFieldMetadata temp = (BasicFieldMetadata) mergedProperties.get(property);
 818             if (temp.getFieldType() == SupportedFieldType.ID &amp;&amp; !property.contains(&quot;.&quot;)) {
 819                 return property;
 820             }
 821         }
 822 
<abbr title=" 823         throw new RuntimeException(&quot;Could not find a primary key property in the passed merged properties list&quot;);"> 823         throw new RuntimeException(&quot;Could not find a primary key property in the passed merged propertiesðŸ”µ</abbr>
 824     }
 825 
 826     @Override
 827     public Object getPrimaryKey(Entity entity, Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
<abbr title=" 828         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);"> 828         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredPropertðŸ”µ</abbr>
 829         Object primaryKey = null;
 830         String idPropertyName = null;
 831         BasicFieldMetadata metaData = null;
 832         for (String property : mergedProperties.keySet()) {
 833             BasicFieldMetadata temp = (BasicFieldMetadata) mergedProperties.get(property);
 834             if (temp.getFieldType() == SupportedFieldType.ID &amp;&amp; !property.contains(&quot;.&quot;)) {
 835                 idPropertyName = property;
 836                 metaData = temp;
 837                 break;
 838             }
 839         }
 840         if (idPropertyName == null) {
<abbr title=" 841             throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: &quot; + entity.getType()[0]);"> 841             throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with tðŸ”µ</abbr>
 842         }
 843         for (Property property : entity.getProperties()) {
 844             if (property.getName().equals(idPropertyName)) {
 845                 switch (metaData.getSecondaryType()) {
 846                     case INTEGER:
<abbr title=" 847                         primaryKey = (property.getValue() == null) ? null : Long.valueOf(property.getValue());"> 847                         primaryKey = (property.getValue() == null) ? null : Long.valueOf(property.getValuðŸ”µ</abbr>
 848                         break;
 849                     case STRING:
 850                         primaryKey = property.getValue();
 851                         break;
 852                 }
 853                 break;
 854             }
 855         }
 856         if (primaryKey == null) {
<abbr title=" 857             throw new RuntimeException(&quot;Could not find the primary key property (&quot; + idPropertyName + &quot;) in the passed entity with type: &quot; + entity.getType()[0]);"> 857             throw new RuntimeException(&quot;Could not find the primary key property (&quot; + idPropertyName + &quot;) ðŸ”µ</abbr>
 858         }
 859         return primaryKey;
 860     }
 861 
 862     @Override
 863     public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective,
 864             CriteriaTransferObject cto,
 865             String ceilingEntityFullyQualifiedClassname,
 866             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties,
 867             RestrictionFactory customRestrictionFactory) {
<abbr title=" 868         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);"> 868         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredPropertðŸ”µ</abbr>
 869         List&lt;FilterMapping&gt; filterMappings = new ArrayList&lt;FilterMapping&gt;();
 870 
 871         for (String propertyId : cto.getCriteriaMap().keySet()) {
 872             if (mergedProperties.containsKey(propertyId)) {
 873                 boolean handled = false;
 874                 for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {
 875                     MetadataProviderResponse response = fieldPersistenceProvider.addSearchMapping(
 876                             new AddSearchMappingRequest(persistencePerspective, cto,
 877                                     ceilingEntityFullyQualifiedClassname, mergedProperties,
<abbr title=" 878                                     propertyId, getFieldManager(), this, this, customRestrictionFactory==null?restrictionFactory"> 878                                     propertyId, getFieldManager(), this, this, customRestrictionFactory==ðŸ”µ</abbr>
 879                                     :customRestrictionFactory), filterMappings);
 880                     if (MetadataProviderResponse.NOT_HANDLED != response) {
 881                         handled = true;
 882                     }
 883                     if (MetadataProviderResponse.HANDLED_BREAK == response) {
 884                         break;
 885                     }
 886                 }
 887                 if (!handled) {
 888                     defaultFieldPersistenceProvider.addSearchMapping(
 889                             new AddSearchMappingRequest(persistencePerspective, cto,
 890                                     ceilingEntityFullyQualifiedClassname, mergedProperties, propertyId,
<abbr title=" 891                                     getFieldManager(), this, this, customRestrictionFactory == null ? restrictionFactory"> 891                                     getFieldManager(), this, this, customRestrictionFactory == null ? resðŸ”µ</abbr>
 892                                             : customRestrictionFactory), filterMappings);
 893                 }
 894             }
 895         }
 896         return filterMappings;
 897     }
 898 
 899     @Override
 900     public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective,
 901             CriteriaTransferObject cto,
 902             String ceilingEntityFullyQualifiedClassname,
 903             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
<abbr title=" 904         return getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergedUnfilteredProperties, null);"> 904         return getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergeðŸ”µ</abbr>
 905     }
 906 
 907     @Override
<abbr title=" 908     public void extractProperties(Class&lt;?&gt;[] inheritanceLine, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; mergedProperties, List&lt;Property&gt; properties) {"> 908     public void extractProperties(Class&lt;?&gt;[] inheritanceLine, Map&lt;MergedPropertyType, Map&lt;String, FieldMeðŸ”µ</abbr>
<abbr title=" 909         extractPropertiesFromMetadata(inheritanceLine, mergedProperties.get(MergedPropertyType.PRIMARY), properties, false, MergedPropertyType.PRIMARY);"> 909         extractPropertiesFromMetadata(inheritanceLine, mergedProperties.get(MergedPropertyType.PRIMARY), ðŸ”µ</abbr>
 910     }
 911 
<abbr title=" 912     protected void extractPropertiesFromMetadata(Class&lt;?&gt;[] inheritanceLine, Map&lt;String, FieldMetadata&gt; mergedProperties, List&lt;Property&gt; properties, Boolean isHiddenOverride, MergedPropertyType type) {"> 912     protected void extractPropertiesFromMetadata(Class&lt;?&gt;[] inheritanceLine, Map&lt;String, FieldMetadata&gt; mðŸ”µ</abbr>
 913         Comparator&lt;Property&gt; comparator = new Comparator&lt;Property&gt;() {
 914 
 915             @Override
 916             public int compare(Property o1, Property o2) {
 917                 return o1.getName().compareTo(o2.getName());
 918             }
 919         };
 920         Collections.sort(properties, comparator);
 921         for (Map.Entry&lt;String, FieldMetadata&gt; entry : mergedProperties.entrySet()) {
 922             String property = entry.getKey();
 923             Property prop = new Property();
 924             FieldMetadata metadata = mergedProperties.get(property);
 925             prop.setName(property);
 926 
 927             int pos = Collections.binarySearch(properties, prop, comparator);
<abbr title=" 928             if (pos &gt;= 0 &amp;&amp; MergedPropertyType.MAPSTRUCTUREKEY != type &amp;&amp; MergedPropertyType.MAPSTRUCTUREVALUE != type) {"> 928             if (pos &gt;= 0 &amp;&amp; MergedPropertyType.MAPSTRUCTUREKEY != type &amp;&amp; MergedPropertyType.MAPSTRUCTUREðŸ”µ</abbr>
 929                 logWarn: {
<abbr title=" 930                     if ((metadata instanceof BasicFieldMetadata) &amp;&amp; SupportedFieldType.ID.equals(((BasicFieldMetadata) metadata).getFieldType())) {"> 930                     if ((metadata instanceof BasicFieldMetadata) &amp;&amp; SupportedFieldType.ID.equals(((BasicFðŸ”µ</abbr>
 931                         //don&#x27;t warn for id field collisions, but still ignore the colliding fields
 932                         break logWarn;
 933                     }
<abbr title=" 934                     //LOG.warn(&quot;Detected a field name collision (&quot; + metadata.getTargetClass() + &quot;.&quot; + property + &quot;) during inspection for the inheritance line starting with (&quot; + inheritanceLine[0].getName() + &quot;). Ignoring the additional field. This can occur most commonly when using the @AdminPresentationAdornedTargetCollection and the collection type and target class have field names in common. This situation should be avoided, as the system will strip the repeated fields, which can cause unpredictable behavior.&quot;);"> 934                     //LOG.warn(&quot;Detected a field name collision (&quot; + metadata.getTargetClass() + &quot;.&quot; + prðŸ”µ</abbr>
 935                 }
 936                 continue;
 937             } else if (pos &lt; 0) {
 938                 pos = -pos - 1; // calculate position to insert
 939             }
 940             properties.add(pos, prop);
 941             prop.setMetadata(metadata);
 942             if (isHiddenOverride &amp;&amp; prop.getMetadata() instanceof BasicFieldMetadata) {
 943                 //this only makes sense for non collection types
 944                 ((BasicFieldMetadata) prop.getMetadata()).setVisibility(VisibilityEnum.HIDDEN_ALL);
 945             }
 946         }
 947     }
 948 
 949     @Override
<abbr title=" 950     public void updateMergedProperties(PersistencePackage persistencePackage, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; allMergedProperties) throws ServiceException {"> 950     public void updateMergedProperties(PersistencePackage persistencePackage, Map&lt;MergedPropertyType, MapðŸ”µ</abbr>
<abbr title=" 951         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();"> 951         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
 952         try {
<abbr title=" 953             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();"> 953             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective(ðŸ”µ</abbr>
<abbr title=" 954             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(ceilingEntityFullyQualifiedClassname);"> 954             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(ceilingEntityFullyQualifiedClðŸ”µ</abbr>
<abbr title=" 955             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties("> 955             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMerðŸ”µ</abbr>
 956                     ceilingEntityFullyQualifiedClassname,
 957                     entities,
<abbr title=" 958                     (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),"> 958                     (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePðŸ”µ</abbr>
 959                     persistencePerspective.getAdditionalNonPersistentProperties(),
 960                     persistencePerspective.getAdditionalForeignKeys(),
 961                     MergedPropertyType.PRIMARY,
 962                     persistencePerspective.getPopulateToOneFields(),
 963                     persistencePerspective.getIncludeFields(),
 964                     persistencePerspective.getExcludeFields(),
 965                     persistencePerspective.getConfigurationKey(),
 966                     &quot;&quot;
 967                     );
 968             allMergedProperties.put(MergedPropertyType.PRIMARY, mergedProperties);
 969         } catch (Exception e) {
<abbr title=" 970             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);"> 970             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassnðŸ”µ</abbr>
 971         }
 972     }
 973 
 974     @Override
<abbr title=" 975     public EntityResult update(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServiceException {"> 975     public EntityResult update(PersistencePackage persistencePackage, boolean includeRealEntityObject) thðŸ”µ</abbr>
 976         return update(persistencePackage, null, true);
 977     }
 978 
 979     @Override
 980     public Entity update(PersistencePackage persistencePackage) throws ServiceException {
 981         EntityResult er = update(persistencePackage, null, false);
 982         return er.getEntity();
 983     }
 984 
 985     @Override
 986     public Entity add(PersistencePackage persistencePackage) throws ServiceException {
 987         EntityResult entityResult = add(persistencePackage, false);
 988         return entityResult.getEntity();
 989     }
 990 
 991     @Override
<abbr title=" 992     public EntityResult add(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServiceException {"> 992     public EntityResult add(PersistencePackage persistencePackage, boolean includeRealEntityObject) throwðŸ”µ</abbr>
 993         EntityResult entityResult = new EntityResult();
 994         Entity entity = persistencePackage.getEntity();
 995         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title=" 996         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);"> 996         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(ðŸ”µ</abbr>
 997         if (foreignKey != null &amp;&amp; !foreignKey.getMutable()) {
 998             throw new SecurityServiceException(&quot;Entity not mutable&quot;);
 999         }
1000         try {
<abbr title="1001             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());">1001             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingðŸ”µ</abbr>
<abbr title="1002             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(">1002             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDaðŸ”µ</abbr>
1003                     persistencePackage.getCeilingEntityFullyQualifiedClassname(),
1004                     entities,
1005                     foreignKey,
1006                     persistencePerspective.getAdditionalNonPersistentProperties(),
1007                     persistencePerspective.getAdditionalForeignKeys(),
1008                     MergedPropertyType.PRIMARY,
1009                     persistencePerspective.getPopulateToOneFields(),
1010                     persistencePerspective.getIncludeFields(),
1011                     persistencePerspective.getExcludeFields(),
1012                     persistencePerspective.getConfigurationKey(),
1013                     &quot;&quot;
1014                     );
<abbr title="1015             Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);">1015             Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProðŸ”µ</abbr>
1016 
1017             String idProperty = null;
1018             for (String property : mergedProperties.keySet()) {
<abbr title="1019                 if (((BasicFieldMetadata) mergedProperties.get(property)).getFieldType() == SupportedFieldType.ID) {">1019                 if (((BasicFieldMetadata) mergedProperties.get(property)).getFieldType() == SupportedFielðŸ”µ</abbr>
1020                     idProperty = property;
1021                     break;
1022                 }
1023             }
1024             if (idProperty == null) {
<abbr title="1025                 throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: &quot; + entity.getType()[0]);">1025                 throw new RuntimeException(&quot;Could not find a primary key property in the passed entity wiðŸ”µ</abbr>
1026             }
1027             Object primaryKey = null;
1028             try {
1029                 primaryKey = getPrimaryKey(entity, mergedProperties);
1030             } catch (Exception e) {
1031                 //don&#x27;t do anything - this is a valid case
1032             }
1033             if (primaryKey == null) {
1034 
1035                 Serializable instance = (Serializable) Class.forName(entity.getType()[0]).newInstance();
1036 
1037                 instance = createPopulatedInstance(instance, entity, mergedProperties, false);
1038 
1039                 if (foreignKey != null &amp;&amp; foreignKey.getSortField() != null) {
<abbr title="1040                     ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;();">1040                     ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;(ðŸ”µ</abbr>
<abbr title="1041                     extensionManager.getProxy().rebalanceForAdd(this, persistencePackage, instance, mergedProperties, result);">1041                     extensionManager.getProxy().rebalanceForAdd(this, persistencePackage, instance, mergeðŸ”µ</abbr>
1042                     instance = result.getResult();
1043                 }
1044 
1045                 instance = persistenceManager.getDynamicEntityDao().merge(instance);
1046                 if (includeRealEntityObject) {
1047                     entityResult.setEntityBackingObject(instance);
1048                 }
1049                 List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
1050                 entityList.add(instance);
1051 
1052                 entity = getRecords(mergedProperties, entityList, null, null, null)[0];
1053                 entityResult.setEntity(entity);
1054                 return entityResult;
1055             } else {
1056                 return update(persistencePackage, primaryKey, includeRealEntityObject);
1057             }
1058         } catch (Exception e) {
1059             throw new ServiceException(&quot;Problem adding new entity : &quot; + e.getMessage(), e);
1060         }
1061     }
1062 
1063     @Override
1064     public void remove(PersistencePackage persistencePackage) throws ServiceException {
1065         Entity entity = persistencePackage.getEntity();
1066         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1067         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1067         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(ðŸ”µ</abbr>
1068         if (foreignKey != null &amp;&amp; !foreignKey.getMutable()) {
1069             throw new SecurityServiceException(&quot;Entity not mutable&quot;);
1070         }
1071         try {
<abbr title="1072             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());">1072             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingðŸ”µ</abbr>
<abbr title="1073             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(">1073             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDaðŸ”µ</abbr>
1074                     persistencePackage.getCeilingEntityFullyQualifiedClassname(),
1075                     entities,
1076                     foreignKey,
1077                     persistencePerspective.getAdditionalNonPersistentProperties(),
1078                     persistencePerspective.getAdditionalForeignKeys(),
1079                     MergedPropertyType.PRIMARY,
1080                     persistencePerspective.getPopulateToOneFields(),
1081                     persistencePerspective.getIncludeFields(),
1082                     persistencePerspective.getExcludeFields(),
1083                     persistencePerspective.getConfigurationKey(),
1084                     &quot;&quot;
1085                     );
<abbr title="1086             Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);">1086             Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProðŸ”µ</abbr>
1087             Object primaryKey = getPrimaryKey(entity, mergedProperties);
<abbr title="1088             Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getType()[0]), primaryKey);">1088             Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entitðŸ”µ</abbr>
1089 
1090             Assert.isTrue(instance != null, &quot;Entity not found&quot;);
1091 
1092             switch (persistencePerspective.getOperationTypes().getRemoveType()) {
1093                 case NONDESTRUCTIVEREMOVE:
1094                     FieldManager fieldManager = getFieldManager();
<abbr title="1095                     FieldMetadata manyToFieldMetadata = mergedUnfilteredProperties.get(foreignKey.getManyToField());">1095                     FieldMetadata manyToFieldMetadata = mergedUnfilteredProperties.get(foreignKey.getManyðŸ”µ</abbr>
<abbr title="1096                     Object foreignKeyValue = entity.getPMap().get(foreignKey.getManyToField()).getValue();">1096                     Object foreignKeyValue = entity.getPMap().get(foreignKey.getManyToField()).getValue()ðŸ”µ</abbr>
1097                     try {
1098                         foreignKeyValue = Long.valueOf((String) foreignKeyValue);
1099                     } catch (NumberFormatException e) {
<abbr title="1100                         LOG.warn(&quot;Foreign primary key is not of type Long, assuming String for remove lookup&quot;);">1100                         LOG.warn(&quot;Foreign primary key is not of type Long, assuming String for remove looðŸ”µ</abbr>
1101                     }
<abbr title="1102                     Serializable foreignInstance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(foreignKey.getForeignKeyClass()), foreignKeyValue);">1102                     Serializable foreignInstance = persistenceManager.getDynamicEntityDao().retrieve(ClasðŸ”µ</abbr>
<abbr title="1103                     Collection collection = (Collection) fieldManager.getFieldValue(foreignInstance, foreignKey.getOriginatingField());">1103                     Collection collection = (Collection) fieldManager.getFieldValue(foreignInstance, foreðŸ”µ</abbr>
1104                     collection.remove(instance);
<abbr title="1105                     // if this is a bi-directional @OneToMany/@ManyToOne and there is no @JoinTable (just a foreign key on">1105                     // if this is a bi-directional @OneToMany/@ManyToOne and there is no @JoinTable (justðŸ”µ</abbr>
<abbr title="1106                     // the @ManyToOne side) then it will not be updated. In that instance, we have to explicitly">1106                     // the @ManyToOne side) then it will not be updated. In that instance, we have to expðŸ”µ</abbr>
1107                     // set the manyTo field to null so that subsequent lookups will not find it
1108                     if (manyToFieldMetadata instanceof BasicFieldMetadata) {
<abbr title="1109                         if (BooleanUtils.isTrue(((BasicFieldMetadata) manyToFieldMetadata).getRequired())) {">1109                         if (BooleanUtils.isTrue(((BasicFieldMetadata) manyToFieldMetadata).getRequired())ðŸ”µ</abbr>
<abbr title="1110                             throw new ServiceException(&quot;Could not remove from the collection as the ManyToOne side is a&quot;">1110                             throw new ServiceException(&quot;Could not remove from the collection as the ManyTðŸ”µ</abbr>
<abbr title="1111                                     + &quot; non-optional relationship. Consider changing &#x27;optional=true&#x27; in the @ManyToOne annotation&quot;">1111                                     + &quot; non-optional relationship. Consider changing &#x27;optional=true&#x27; in tðŸ”µ</abbr>
1112                                     + &quot; or nullable=true within the @JoinColumn annotation&quot;);
1113                         }
<abbr title="1114                         //Since this is occuring on a remove persistence package, merge up-front (before making a change) for proper operation in the presence of the enterprise module">1114                         //Since this is occuring on a remove persistence package, merge up-front (before ðŸ”µ</abbr>
1115                         instance = persistenceManager.getDynamicEntityDao().merge(instance);
<abbr title="1116                         Field manyToField = fieldManager.getField(instance.getClass(), foreignKey.getManyToField());">1116                         Field manyToField = fieldManager.getField(instance.getClass(), foreignKey.getManyðŸ”µ</abbr>
1117                         Object manyToObject = manyToField.get(instance);
<abbr title="1118                         if (manyToObject != null &amp;&amp; !(manyToObject instanceof Collection) &amp;&amp; !(manyToObject instanceof Map)) {">1118                         if (manyToObject != null &amp;&amp; !(manyToObject instanceof Collection) &amp;&amp; !(manyToObjeðŸ”µ</abbr>
1119                             manyToField.set(instance, null);
1120                             instance = persistenceManager.getDynamicEntityDao().merge(instance);
1121                         }
1122                     }
1123                     break;
1124                 case BASIC:
1125                     persistenceManager.getDynamicEntityDao().remove(instance);
1126                     break;
1127             }
1128         } catch (Exception e) {
1129             throw new ServiceException(&quot;Problem removing entity : &quot; + e.getMessage(), e);
1130         }
1131     }
1132 
1133     public Map&lt;String, FieldMetadata&gt; getMergedProperties(PersistencePackage persistencePackage,
1134             CriteriaTransferObject cto) throws ServiceException {
1135         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1136         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();">1136         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
1137 
1138         if (StringUtils.isEmpty(persistencePackage.getFetchTypeFullyQualifiedClassname())) {
1139             persistencePackage.setFetchTypeFullyQualifiedClassname(ceilingEntityFullyQualifiedClassname);
1140         }
1141 
1142         try {
<abbr title="1143             Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualifiedClassname));">1143             Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCðŸ”µ</abbr>
1144 
<abbr title="1145             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(">1145             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMerðŸ”µ</abbr>
1146                     ceilingEntityFullyQualifiedClassname,
1147                     entities,
<abbr title="1148                     (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),">1148                     (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePðŸ”µ</abbr>
1149                     persistencePerspective.getAdditionalNonPersistentProperties(),
1150                     persistencePerspective.getAdditionalForeignKeys(),
1151                     MergedPropertyType.PRIMARY,
1152                     persistencePerspective.getPopulateToOneFields(),
1153                     persistencePerspective.getIncludeFields(),
1154                     persistencePerspective.getExcludeFields(),
1155                     persistencePerspective.getConfigurationKey(),
1156                     &quot;&quot;
1157                     );
1158 
1159             return mergedProperties;
1160         } catch (Exception e) {
<abbr title="1161             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);">1161             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassnðŸ”µ</abbr>
1162         }
1163     }
1164 
1165     @Override
<abbr title="1166     public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto) throws ServiceException {">1166     public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto) throðŸ”µ</abbr>
1167         Entity[] payload;
1168         int totalRecords;
1169         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1170         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();">1170         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
<abbr title="1171         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1171         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(ðŸ”µ</abbr>
1172 
1173         try {
1174             if (foreignKey != null &amp;&amp; foreignKey.getSortField() != null) {
1175                 FilterAndSortCriteria sortCriteria = cto.get(foreignKey.getSortField());
1176                 sortCriteria.setSortAscending(foreignKey.getSortAscending());
1177             }
1178 
1179             Map&lt;String, FieldMetadata&gt; mergedProperties = getMergedProperties(persistencePackage, cto);
1180             if (useTranslationSearch) {
1181                 addTranslationSearchIfNeeded(cto, mergedProperties);
1182             }
<abbr title="1183             List&lt;FilterMapping&gt; filterMappings = getFilterMappings(persistencePerspective, cto, persistencePackage">1183             List&lt;FilterMapping&gt; filterMappings = getFilterMappings(persistencePerspective, cto, persistenðŸ”µ</abbr>
1184                     .getFetchTypeFullyQualifiedClassname(), mergedProperties);
1185             List&lt;FilterMapping&gt; standardFilterMappings = new ArrayList&lt;FilterMapping&gt;(filterMappings);
1186             if (CollectionUtils.isNotEmpty(cto.getAdditionalFilterMappings())) {
1187                 standardFilterMappings.addAll(cto.getAdditionalFilterMappings());
1188             }
1189             if (CollectionUtils.isNotEmpty(cto.getNonCountAdditionalFilterMappings())) {
1190                 standardFilterMappings.addAll(cto.getNonCountAdditionalFilterMappings());
1191             }
1192 
1193             FetchRequest fetchRequest = new FetchRequest(persistencePackage, cto,
1194                     persistencePackage.getFetchTypeFullyQualifiedClassname(), standardFilterMappings);
1195             List&lt;Serializable&gt; records = getPersistentRecords(fetchRequest);
1196 
1197             List&lt;FilterMapping&gt; countFilterMappings = new ArrayList&lt;FilterMapping&gt;(filterMappings);
1198             if (CollectionUtils.isNotEmpty(cto.getAdditionalFilterMappings())) {
1199                 countFilterMappings.addAll(cto.getAdditionalFilterMappings());
1200             }
1201             FetchRequest countFetchRequest = new FetchRequest(persistencePackage, cto,
1202                     persistencePackage.getFetchTypeFullyQualifiedClassname(), countFilterMappings);
1203             totalRecords = getTotalRecords(countFetchRequest);
1204 
<abbr title="1205             FetchExtractionRequest fetchExtractionRequest = new FetchExtractionRequest(persistencePackage, cto,">1205             FetchExtractionRequest fetchExtractionRequest = new FetchExtractionRequest(persistencePackageðŸ”µ</abbr>
1206                     persistencePackage.getFetchTypeFullyQualifiedClassname(), mergedProperties, records);
1207             payload = getRecords(fetchExtractionRequest);
1208         } catch (Exception e) {
<abbr title="1209             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);">1209             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassnðŸ”µ</abbr>
1210         }
1211 
1212         return new DynamicResultSet(null, payload, totalRecords);
1213     }
1214 
<abbr title="1215     private void addTranslationSearchIfNeeded(CriteriaTransferObject cto, Map&lt;String, FieldMetadata&gt; mergedProperties) {">1215     private void addTranslationSearchIfNeeded(CriteriaTransferObject cto, Map&lt;String, FieldMetadata&gt; mergðŸ”µ</abbr>
1216         Map&lt;String, FilterAndSortCriteria&gt; criteriaMap = cto.getCriteriaMap();
1217         FilterAndSortCriteria fsc = criteriaMap.get(&quot;translationLocale&quot;);
1218         List&lt;String&gt; filterValues = new ArrayList&lt;&gt;();
1219         if (fsc != null) {
1220             filterValues = fsc.getFilterValues();
1221             criteriaMap.remove(&quot;translationLocale&quot;);
1222         }
1223         //If locale is generic - than we use all locales of this language
1224         //For example, if locale = &quot;en&quot; than we use also &quot;en_GB&quot; and &quot;en_US&quot;
1225         if (filterValues.size() &gt; 0 &amp;&amp; filterValues.get(0).indexOf(&quot;_&quot;) &lt; 0) {
1226             String currentLocaleCode = filterValues.get(0);
<abbr title="1227             List&lt;org.broadleafcommerce.common.locale.domain.Locale&gt; locales = localeService.findAllLocales();">1227             List&lt;org.broadleafcommerce.common.locale.domain.Locale&gt; locales = localeService.findAllLocaleðŸ”µ</abbr>
1228             for (org.broadleafcommerce.common.locale.domain.Locale locale : locales) {
<abbr title="1229                 if (!locale.getLocaleCode().equals(currentLocaleCode) &amp;&amp; currentLocaleCode.equals(locale.getLocaleCode().substring(0,2))) {">1229                 if (!locale.getLocaleCode().equals(currentLocaleCode) &amp;&amp; currentLocaleCode.equals(locale.ðŸ”µ</abbr>
1230                     filterValues.add(locale.getLocaleCode());
1231                 }
1232             }
1233         }
1234         Iterator&lt;Entry&lt;String, FilterAndSortCriteria&gt;&gt; iterator = criteriaMap.entrySet().iterator();
1235         while (iterator.hasNext()) {
1236             Entry&lt;String, FilterAndSortCriteria&gt; next = iterator.next();
1237 
1238             final String key = next.getKey();
1239             FieldMetadata fieldMetadata = mergedProperties.get(key);
<abbr title="1240             if (fieldMetadata != null &amp;&amp; fieldMetadata instanceof BasicFieldMetadata &amp;&amp; ((BasicFieldMetadata) fieldMetadata).getTranslatable()!=null &amp;&amp; ((BasicFieldMetadata) fieldMetadata).getTranslatable()) {">1240             if (fieldMetadata != null &amp;&amp; fieldMetadata instanceof BasicFieldMetadata &amp;&amp; ((BasicFieldMetadðŸ”µ</abbr>
1241                 BasicFieldMetadata basicFieldMetadata = ((BasicFieldMetadata) fieldMetadata);
1242                 if (next.getValue().getFilterValues().size() &gt; 0) {
1243                     final String value = next.getValue().getFilterValues().get(0);
1244                     final String targetClass = basicFieldMetadata.getTargetClass();
1245                     final String fieldName = basicFieldMetadata.getFieldName();
1246                     final String friendlyType = getTranslationFriendlyType(targetClass);
1247                     final List&lt;String&gt; localeValues = filterValues;
1248                     if (friendlyType != null) {
1249                         iterator.remove();
1250                         cto.getAdditionalFilterMappings().add(new FilterMapping()
1251                                 .withDirectFilterValues(new EmptyFilterValues())
1252                                 .withRestriction(
1253                                         new Restriction().withPredicateProvider(new PredicateProvider() {
1254                                             @Override
1255                                             public Predicate buildPredicate(CriteriaBuilder builder,
<abbr title="1256                                                                             FieldPathBuilder fieldPathBuilder,">1256                                                                             FieldPathBuilder fieldPathBuiðŸ”µ</abbr>
1257                                                                             From root,
1258                                                                             String ceilingEntity,
1259                                                                             String fullPropertyName,
1260                                                                             Path explicitPath,
1261                                                                             List directValues) {
1262                                                 Subquery subquery =
<abbr title="1263                                                         fieldPathBuilder.getCriteria().subquery(Long.class);">1263                                                         fieldPathBuilder.getCriteria().subquery(Long.clasðŸ”µ</abbr>
1264                                                 Root transRoot = subquery.from(TranslationImpl.class);
1265                                                 subquery.select(builder.count(transRoot.get(&quot;id&quot;)));
1266                                                 Predicate type =
<abbr title="1267                                                         builder.equal(transRoot.get(&quot;entityType&quot;), friendlyType);">1267                                                         builder.equal(transRoot.get(&quot;entityType&quot;), friendðŸ”µ</abbr>
1268                                                 Predicate name =
<abbr title="1269                                                         builder.equal(transRoot.get(&quot;fieldName&quot;), fieldName);">1269                                                         builder.equal(transRoot.get(&quot;fieldName&quot;), fieldNaðŸ”µ</abbr>
1270                                                 String[] split = key.split(&quot;\\.&quot;);
1271                                                 Path x = null;
1272                                                 for (int i = 0; i &lt; split.length; i++) {
1273                                                     if (x == null) {
1274                                                         x = root.get(split[i]);
1275                                                     } else {
1276                                                         x = x.get(split[i]);
1277                                                     }
1278                                                 }
1279 
1280                                                 String likeValue = &quot;%&quot; + value + &quot;%&quot;;
1281                                                 Predicate transValue =
<abbr title="1282                                                         builder.like(transRoot.get(&quot;translatedValue&quot;), likeValue);">1282                                                         builder.like(transRoot.get(&quot;translatedValue&quot;), liðŸ”µ</abbr>
1283                                                 Predicate localeValue =
<abbr title="1284                                                         builder.isTrue(transRoot.get(&quot;localeCode&quot;).in(localeValues));">1284                                                         builder.isTrue(transRoot.get(&quot;localeCode&quot;).in(locðŸ”µ</abbr>
<abbr title="1285                                                 Path y = split.length &gt; 1 ? root.get(split[0]).get(&quot;id&quot;) : root.get(&quot;id&quot;);">1285                                                 Path y = split.length &gt; 1 ? root.get(split[0]).get(&quot;id&quot;) ðŸ”µ</abbr>
<abbr title="1286                                                 Predicate entityId = builder.equal(transRoot.get(&quot;entityId&quot;),">1286                                                 Predicate entityId = builder.equal(transRoot.get(&quot;entityIðŸ”µ</abbr>
1287                                                         y);
1288                                                 if (localeValues.size() &gt; 0) {
<abbr title="1289                                                     subquery.where(builder.and(type, entityId, transValue, name, localeValue));">1289                                                     subquery.where(builder.and(type, entityId, transValueðŸ”µ</abbr>
1290                                                 } else {
<abbr title="1291                                                     subquery.where(builder.and(type, entityId, transValue, name));">1291                                                     subquery.where(builder.and(type, entityId, transValueðŸ”µ</abbr>
1292                                                 }
1293 
1294                                                 Predicate like = builder.like(x,
1295                                                         likeValue);
<abbr title="1296                                                 Predicate predicate = builder.or(like, builder.greaterThan(subquery, 0));">1296                                                 Predicate predicate = builder.or(like, builder.greaterThaðŸ”µ</abbr>
1297                                                 return predicate;
1298                                             }
1299                                         })));
1300                     }
1301                 }
1302                 System.out.println(&quot;&quot;);
1303             }
1304         }
1305     }
1306 
1307     private String getTranslationFriendlyType(String targetClass) {
1308 
1309         TranslatedEntity instance = TranslatedEntity.getInstance(targetClass);
1310         if (instance == null) {
1311             try {
1312                 Class&lt;?&gt;[] interfaces = Class.forName(targetClass).getInterfaces();
1313                 int i = 0;
1314                 while (instance == null &amp;&amp; i &lt; interfaces.length) {
1315                     instance = TranslatedEntity.getInstance(interfaces[i].getName());
1316                     i++;
1317                 }
1318             } catch (ClassNotFoundException e) {
1319 
1320             }
1321         }
1322 
1323         return instance == null ? null : instance.getFriendlyType();
1324     }
1325 
1326     @Override
1327     public Integer getTotalRecords(FetchRequest fetchRequest) {
1328         return fetchWrapper.getTotalRecords(fetchRequest);
1329     }
1330 
1331     @Override
1332     public Integer getTotalRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings) {
1333         try {
<abbr title="1334             return ((Long) criteriaTranslator.translateCountQuery(persistenceManager.getDynamicEntityDao(),">1334             return ((Long) criteriaTranslator.translateCountQuery(persistenceManager.getDynamicEntityDao(ðŸ”µ</abbr>
1335                     ceilingEntity, filterMappings).getSingleResult()).intValue();
1336         } catch (CriteriaConversionException e) {
<abbr title="1337             TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntity);">1337             TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilðŸ”µ</abbr>
<abbr title="1338             return ((Long) builder.toCountQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManager()).getSingleResult()).intValue();">1338             return ((Long) builder.toCountQuery(getPersistenceManager().getDynamicEntityDao().getStandardðŸ”µ</abbr>
1339         }
1340     }
1341 
1342     @Override
<abbr title="1343     public Serializable getMaxValue(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, String maxField) {">1343     public Serializable getMaxValue(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, String maxFðŸ”µ</abbr>
1344         return criteriaTranslator.translateMaxQuery(persistenceManager.getDynamicEntityDao(),
1345                 ceilingEntity, filterMappings, maxField).getSingleResult();
1346     }
1347 
1348     @Override
1349     public List&lt;Serializable&gt; getPersistentRecords(FetchRequest fetchRequest) {
1350         return fetchWrapper.getPersistentRecords(fetchRequest);
1351     }
1352 
1353     @Override
<abbr title="1354     public List&lt;Serializable&gt; getPersistentRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, Integer firstResult, Integer maxResults) {">1354     public List&lt;Serializable&gt; getPersistentRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappinðŸ”µ</abbr>
1355         try {
<abbr title="1356             return criteriaTranslator.translateQuery(persistenceManager.getDynamicEntityDao(), ceilingEntity, filterMappings, firstResult, maxResults).getResultList();">1356             return criteriaTranslator.translateQuery(persistenceManager.getDynamicEntityDao(), ceilingEntðŸ”µ</abbr>
1357         } catch (CriteriaConversionException e) {
<abbr title="1358             TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntity);">1358             TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilðŸ”µ</abbr>
<abbr title="1359             return builder.toQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManager()).getResultList();">1359             return builder.toQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManagerðŸ”µ</abbr>
1360         }
1361     }
1362 
1363     @Override
<abbr title="1364     public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperties) {">1364     public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; merðŸ”µ</abbr>
1365         return validate(entity, populatedInstance, mergedProperties, true);
1366     }
1367 
1368     @Override
<abbr title="1369     public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperties,">1369     public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; merðŸ”µ</abbr>
1370             boolean validateUnsubmittedProperties) {
<abbr title="1371         entityValidatorService.validate(entity, populatedInstance, mergedProperties, this, validateUnsubmittedProperties);">1371         entityValidatorService.validate(entity, populatedInstance, mergedProperties, this, validateUnsubmðŸ”µ</abbr>
1372         return !entity.isValidationFailure();
1373     }
1374 
1375     @Override
1376     public void setPersistenceManager(PersistenceManager persistenceManager) {
1377         this.persistenceManager = persistenceManager;
1378     }
1379 
1380     @Override
1381     public PersistenceModule getCompatibleModule(OperationType operationType) {
1382         return ((InspectHelper) persistenceManager).getCompatibleModule(operationType);
1383     }
1384 
1385     public FieldPersistenceProvider getDefaultFieldPersistenceProvider() {
1386         return defaultFieldPersistenceProvider;
1387     }
1388 
<abbr title="1389     public void setDefaultFieldPersistenceProvider(FieldPersistenceProvider defaultFieldPersistenceProvider) {">1389     public void setDefaultFieldPersistenceProvider(FieldPersistenceProvider defaultFieldPersistenceProvidðŸ”µ</abbr>
1390         this.defaultFieldPersistenceProvider = defaultFieldPersistenceProvider;
1391     }
1392 
1393     public List&lt;FieldPersistenceProvider&gt; getFieldPersistenceProviders() {
1394         return fieldPersistenceProviders;
1395     }
1396 
1397     public void setFieldPersistenceProviders(List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders) {
1398         this.fieldPersistenceProviders = fieldPersistenceProviders;
1399     }
1400 
1401     public CriteriaTranslator getCriteriaTranslator() {
1402         return criteriaTranslator;
1403     }
1404 
1405     public void setCriteriaTranslator(CriteriaTranslator criteriaTranslator) {
1406         this.criteriaTranslator = criteriaTranslator;
1407     }
1408 
1409     public EntityValidatorService getEntityValidatorService() {
1410         return entityValidatorService;
1411     }
1412 
1413     public void setEntityValidatorService(EntityValidatorService entityValidatorService) {
1414         this.entityValidatorService = entityValidatorService;
1415     }
1416 
1417     public RestrictionFactory getRestrictionFactory() {
1418         return restrictionFactory;
1419     }
1420 
1421     public void setRestrictionFactory(RestrictionFactory restrictionFactory) {
1422         this.restrictionFactory = restrictionFactory;
1423     }
1424 
1425     public PersistenceManager getPersistenceManager() {
1426         return persistenceManager;
1427     }
1428 
1429     /**
<abbr title="1430      * Use an alternate approach to generating a fetch query for a collection located inside of an @Embeddable object. Related">1430      * Use an alternate approach to generating a fetch query for a collection located inside of an @EmbedðŸ”µ</abbr>
<abbr title="1431      * to https://hibernate.atlassian.net/browse/HHH-8802. The alternate approach leverages HQL rather than JPA criteria,">1431      * to https://hibernate.atlassian.net/browse/HHH-8802. The alternate approach leverages HQL rather thðŸ”µ</abbr>
1432      * which seems to alleviate the problem.
1433      *
1434      * @param embeddedCollectionPath the path to the collection field itself
1435      * @param filterMappings all the fetch restrictions for this request
1436      * @param collectionClass the type of the collection members
1437      * @return the builder capable of generating an appropriate HQL query
1438      */
<abbr title="1439     protected TypedQueryBuilder getSpecialCaseQueryBuilder(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; filterMappings, String collectionClass) {">1439     protected TypedQueryBuilder getSpecialCaseQueryBuilder(FieldPath embeddedCollectionPath, List&lt;FilterMðŸ”µ</abbr>
1440         String specialPath = embeddedCollectionPath.getTargetProperty();
1441         String[] pieces = specialPath.split(&quot;\\.&quot;);
1442         if (pieces.length != 3) {
<abbr title="1443             throw new CriteriaConversionException(String.format(&quot;Expected to find a target property of format [embedded field].[collection field].[property] for the embedded collection path (%s)&quot;, specialPath), embeddedCollectionPath);">1443             throw new CriteriaConversionException(String.format(&quot;Expected to find a target property of foðŸ”µ</abbr>
1444         }
1445         String expression = specialPath.substring(0, specialPath.lastIndexOf(&quot;.&quot;));
1446         TypedQueryBuilder builder;
1447         try {
1448             builder = new TypedQueryBuilder(Class.forName(collectionClass), &quot;specialEntity&quot;)
1449                     .addJoin(new TQJoin(&quot;specialEntity.&quot; + expression, &quot;embeddedCollection&quot;));
1450         } catch (Exception e) {
1451             throw ExceptionHelper.refineException(e);
1452         }
1453         for (TQRestriction restriction : buildSpecialRestrictions(expression, filterMappings)) {
1454             builder = builder.addRestriction(restriction);
1455         }
<abbr title="1456         for (TQRestriction restriction : buildStandardRestrictions(embeddedCollectionPath, filterMappings)) {">1456         for (TQRestriction restriction : buildStandardRestrictions(embeddedCollectionPath, filterMappingsðŸ”µ</abbr>
1457             builder = builder.addRestriction(restriction);
1458         }
1459         for (FilterMapping mapping : filterMappings) {
1460             if (mapping.getSortDirection() != null) {
<abbr title="1461                 String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().getTargetProperty();">1461                 String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().gðŸ”µ</abbr>
1462                 if (StringUtils.isEmpty(mappingProperty)) {
1463                     mappingProperty = mapping.getFullPropertyName();
1464                 }
<abbr title="1465                 builder = builder.addOrder(new TQOrder(&quot;specialEntity.&quot; + mappingProperty, SortDirection.ASCENDING == mapping.getSortDirection()));">1465                 builder = builder.addOrder(new TQOrder(&quot;specialEntity.&quot; + mappingProperty, SortDirection.ðŸ”µ</abbr>
1466             }
1467         }
1468 
1469         return builder;
1470     }
1471 
1472     /**
<abbr title="1473      * Generate LIKE or EQUALS restrictions for any filter property specified on the root entity (not the collection field in the @Embeddable object)">1473      * Generate LIKE or EQUALS restrictions for any filter property specified on the root entity (not theðŸ”µ</abbr>
1474      *
<abbr title="1475      * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath, java.util.List, String)">1475      * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.moduleðŸ”µ</abbr>
<abbr title="1476      * @param embeddedCollectionPath the path for the collection field in the @Embeddable object - this is what caused the whole thing">1476      * @param embeddedCollectionPath the path for the collection field in the @Embeddable object - this iðŸ”µ</abbr>
1477      * @param filterMappings all the fetch restrictions for this request
1478      * @return the list of restrictions on the root entity
1479      */
<abbr title="1480     protected List&lt;TQRestriction&gt; buildStandardRestrictions(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; filterMappings) {">1480     protected List&lt;TQRestriction&gt; buildStandardRestrictions(FieldPath embeddedCollectionPath, List&lt;FilterðŸ”µ</abbr>
<abbr title="1481         String expression = embeddedCollectionPath.getTargetProperty().substring(0, embeddedCollectionPath.getTargetProperty().lastIndexOf(&quot;.&quot;));">1481         String expression = embeddedCollectionPath.getTargetProperty().substring(0, embeddedCollectionPatðŸ”µ</abbr>
1482         List&lt;TQRestriction&gt; restrictions = new ArrayList&lt;TQRestriction&gt;();
1483         for (FilterMapping mapping : filterMappings) {
1484             checkProperty: {
<abbr title="1485                 String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().getTargetProperty();">1485                 String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().gðŸ”µ</abbr>
1486                 if (StringUtils.isEmpty(mappingProperty)) {
1487                     mappingProperty = mapping.getFullPropertyName();
1488                 }
<abbr title="1489                 if (!embeddedCollectionPath.getTargetProperty().equals(mappingProperty) &amp;&amp; !StringUtils.isEmpty(mappingProperty)) {">1489                 if (!embeddedCollectionPath.getTargetProperty().equals(mappingProperty) &amp;&amp; !StringUtils.iðŸ”µ</abbr>
<abbr title="1490                     PredicateProvider predicateProvider = mapping.getRestriction().getPredicateProvider();">1490                     PredicateProvider predicateProvider = mapping.getRestriction().getPredicateProvider()ðŸ”µ</abbr>
1491                     if (predicateProvider != null) {
<abbr title="1492                         FilterValueConverter converter = mapping.getRestriction().getFilterValueConverter();">1492                         FilterValueConverter converter = mapping.getRestriction().getFilterValueConverterðŸ”µ</abbr>
1493                         if (converter != null &amp;&amp; CollectionUtils.isNotEmpty(mapping.getFilterValues())) {
1494                             Object val = converter.convert(mapping.getFilterValues().get(0));
1495                             if (predicateProvider instanceof LikePredicateProvider) {
<abbr title="1496                                 restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;LIKE&quot;, val + &quot;%&quot;));">1496                                 restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;LðŸ”µ</abbr>
1497                                 break checkProperty;
1498                             } else if (predicateProvider instanceof EqPredicateProvider) {
<abbr title="1499                                 restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;=&quot;, val));">1499                                 restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;=ðŸ”µ</abbr>
1500                                 break checkProperty;
1501                             }
1502                         }
1503                     }
<abbr title="1504                     LOG.warn(String.format(&quot;Unable to filter the embedded collection (%s) on an additional property (%s)&quot;,">1504                     LOG.warn(String.format(&quot;Unable to filter the embedded collection (%s) on an additionaðŸ”µ</abbr>
1505                             StringUtil.sanitize(expression),
1506                             StringUtil.sanitize(mappingProperty)));
1507                 }
1508             }
1509         }
1510 
1511         return restrictions;
1512     }
1513 
1514     /**
<abbr title="1515      * Generate EQUALS restrictions for any filter property specified on the entity member of the collection field in the @Embeddable object">1515      * Generate EQUALS restrictions for any filter property specified on the entity member of the collectðŸ”µ</abbr>
1516      *
<abbr title="1517      * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath, java.util.List, String)">1517      * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.moduleðŸ”µ</abbr>
<abbr title="1518      * @param specialExpression the String representation of the path for the collection field in the @Embeddable object">1518      * @param specialExpression the String representation of the path for the collection field in the @EmðŸ”µ</abbr>
1519      * @param filterMappings all the fetch restrictions for this request
1520      * @return the list of restrictions on the collection in the @Embeddable object
1521      */
<abbr title="1522     protected List&lt;TQRestriction&gt; buildSpecialRestrictions(String specialExpression, List&lt;FilterMapping&gt; filterMappings) {">1522     protected List&lt;TQRestriction&gt; buildSpecialRestrictions(String specialExpression, List&lt;FilterMapping&gt; ðŸ”µ</abbr>
1523         List&lt;TQRestriction&gt; restrictions = new ArrayList&lt;TQRestriction&gt;();
1524         for (FilterMapping mapping : filterMappings) {
<abbr title="1525             if (mapping.getFieldPath() != null &amp;&amp; mapping.getFieldPath().getTargetProperty() != null &amp;&amp; mapping.getFieldPath().getTargetProperty().startsWith(specialExpression)) {">1525             if (mapping.getFieldPath() != null &amp;&amp; mapping.getFieldPath().getTargetProperty() != null &amp;&amp; mðŸ”µ</abbr>
1526                 FilterValueConverter converter = mapping.getRestriction().getFilterValueConverter();
1527                 if (converter != null &amp;&amp; CollectionUtils.isNotEmpty(mapping.getFilterValues())) {
1528                     Object val = converter.convert(mapping.getFilterValues().get(0));
<abbr title="1529                     String property = mapping.getFieldPath().getTargetProperty().substring(mapping.getFieldPath().getTargetProperty().lastIndexOf(&quot;.&quot;) + 1, mapping.getFieldPath().getTargetProperty().length());">1529                     String property = mapping.getFieldPath().getTargetProperty().substring(mapping.getFieðŸ”µ</abbr>
1530                     restrictions.add(new TQRestriction(&quot;embeddedCollection.&quot; + property, &quot;=&quot;, val));
1531                 }
1532             }
1533         }
1534         return restrictions;
1535     }
1536 
1537     protected void cleanupFailedPersistenceAttempt(Serializable instance) throws IllegalAccessException {
1538         //Remove the entity from ORM management - no further attempts to persist
<abbr title="1539         if (getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().contains(instance)) {">1539         if (getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().contains(instance)) ðŸ”µ</abbr>
1540             getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().detach(instance);
1541         }
1542         //Remove the id field value, if it&#x27;s set
<abbr title="1543         String idFieldName = (String) getPersistenceManager().getDynamicEntityDao().getIdMetadata(instance.getClass()).get(&quot;name&quot;);">1543         String idFieldName = (String) getPersistenceManager().getDynamicEntityDao().getIdMetadata(instancðŸ”µ</abbr>
1544         Field idField = FieldUtils.getField(instance.getClass(), idFieldName, true);
1545         if (idField == null) {
<abbr title="1546             throw ExceptionHelper.refineException(new NoSuchFieldException(&quot;Entity &quot; + instance.getClass().getName() + &quot; does not contain id field &quot; + idFieldName));">1546             throw ExceptionHelper.refineException(new NoSuchFieldException(&quot;Entity &quot; + instance.getClass(ðŸ”µ</abbr>
1547         }
1548         idField.setAccessible(true);
1549         if (idField.get(instance) != null) {
1550             idField.set(instance, null);
1551         }
1552     }
1553 
<abbr title="1554     protected Class&lt;?&gt; getMapFieldType(Serializable instance, FieldManager fieldManager, Property property) {">1554     protected Class&lt;?&gt; getMapFieldType(Serializable instance, FieldManager fieldManager, Property propertðŸ”µ</abbr>
1555         Class&lt;?&gt; returnType = null;
<abbr title="1556         Field field = fieldManager.getField(instance.getClass(), property.getName().substring(0, property.getName().indexOf(FieldManager.MAPFIELDSEPARATOR)));">1556         Field field = fieldManager.getField(instance.getClass(), property.getName().substring(0, propertyðŸ”µ</abbr>
1557         java.lang.reflect.Type type = field.getGenericType();
1558         if (type instanceof ParameterizedType) {
1559             ParameterizedType pType = (ParameterizedType) type;
1560             Class&lt;?&gt; clazz;
1561             if (pType.getActualTypeArguments().length &lt; 2) {
1562                 clazz = (Class&lt;?&gt;) pType.getActualTypeArguments()[0];
1563             } else {
1564                 clazz = (Class&lt;?&gt;) pType.getActualTypeArguments()[1];
1565             }
<abbr title="1566             Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(clazz);">1566             Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCðŸ”µ</abbr>
1567             if (!ArrayUtils.isEmpty(entities)) {
1568                 returnType = entities[entities.length - 1];
1569             }
1570         }
1571         return returnType;
1572     }
1573 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Open Admin Platform
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.openadmin.server.service.persistence.module;
  19 
  20 import java.io.Serializable;
  21 import java.lang.reflect.Field;
  22 import java.lang.reflect.InvocationTargetException;
  23 import java.lang.reflect.Method;
  24 import java.lang.reflect.ParameterizedType;
  25 import java.math.BigDecimal;
  26 import java.sql.Timestamp;
  27 import java.text.DecimalFormat;
  28 import java.text.NumberFormat;
  29 import java.text.SimpleDateFormat;
  30 import java.util.*;
  31 import java.util.Iterator;
  32 import java.util.Map.Entry;
  33 import javax.annotation.PostConstruct;
  34 import javax.annotation.Resource;
  35 import javax.persistence.criteria.CriteriaBuilder;
  36 import javax.persistence.criteria.From;
  37 import javax.persistence.criteria.Path;
  38 import javax.persistence.criteria.Predicate;
  39 import javax.persistence.criteria.Root;
  40 import javax.persistence.criteria.Subquery;
  41 import org.apache.commons.beanutils.PropertyUtils;
  42 import org.apache.commons.collections.CollectionUtils;
  43 import org.apache.commons.lang.ArrayUtils;
  44 import org.apache.commons.lang.StringUtils;
  45 import org.apache.commons.lang3.BooleanUtils;
  46 import org.apache.commons.lang3.reflect.FieldUtils;
  47 import org.apache.commons.lang3.reflect.MethodUtils;
  48 import org.apache.commons.logging.Log;
  49 import org.apache.commons.logging.LogFactory;
  50 import org.broadleafcommerce.common.admin.domain.AdminMainEntity;
  51 import org.broadleafcommerce.common.exception.ExceptionHelper;
  52 import org.broadleafcommerce.common.exception.SecurityServiceException;
  53 import org.broadleafcommerce.common.exception.ServiceException;
  54 import org.broadleafcommerce.common.extension.ExtensionResultHolder;
  55 import org.broadleafcommerce.common.i18n.domain.TranslatedEntity;
  56 import org.broadleafcommerce.common.i18n.domain.TranslationImpl;
  57 import org.broadleafcommerce.common.locale.service.LocaleService;
  58 import org.broadleafcommerce.common.money.Money;
  59 import org.broadleafcommerce.common.presentation.client.OperationType;
  60 import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  61 import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  62 import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  63 import org.broadleafcommerce.common.util.FormatUtil;
  64 import org.broadleafcommerce.common.util.StringUtil;
  65 import org.broadleafcommerce.common.util.ValidationUtil;
  66 import org.broadleafcommerce.common.util.dao.TQJoin;
  67 import org.broadleafcommerce.common.util.dao.TQOrder;
  68 import org.broadleafcommerce.common.util.dao.TQRestriction;
  69 import org.broadleafcommerce.common.util.dao.TypedQueryBuilder;
  70 import org.broadleafcommerce.common.web.BroadleafRequestContext;
  71 import org.broadleafcommerce.openadmin.dto.*;
<abbr title="  72 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.AdvancedCollectionFieldMetadataProvider;">  72 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.AdvancedCollectionFieldMetadataProvidðŸ”µ</abbr>
  73 import org.broadleafcommerce.openadmin.server.service.ValidationException;
  74 import org.broadleafcommerce.openadmin.server.service.persistence.ParentEntityPersistenceException;
  75 import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceException;
  76 import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceManager;
  77 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.*;
  78 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPathBuilder;
  79 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.Restriction;
<abbr title="  80 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.converter.FilterValueConverter;">  80 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.converter.FilterValueCoðŸ”µ</abbr>
<abbr title="  81 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.EqPredicateProvider;">  81 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.EqPredicatePrðŸ”µ</abbr>
<abbr title="  82 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.LikePredicateProvider;">  82 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.LikePredicateðŸ”µ</abbr>
<abbr title="  83 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvider;">  83 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvðŸ”µ</abbr>
<abbr title="  84 import org.broadleafcommerce.openadmin.server.service.persistence.module.extension.BasicPersistenceModuleExtensionManager;">  84 import org.broadleafcommerce.openadmin.server.service.persistence.module.extension.BasicPersistenceModuleðŸ”µ</abbr>
<abbr title="  85 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.FieldPersistenceProvider;">  85 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.FieldPersistenceProvideðŸ”µ</abbr>
<abbr title="  86 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddFilterPropertiesRequest;">  86 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddFilterProperðŸ”µ</abbr>
<abbr title="  87 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddSearchMappingRequest;">  87 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddSearchMappinðŸ”µ</abbr>
<abbr title="  88 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.ExtractValueRequest;">  88 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.ExtractValueReqðŸ”µ</abbr>
<abbr title="  89 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.PopulateValueRequest;">  89 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.PopulateValueReðŸ”µ</abbr>
  90 import org.broadleafcommerce.openadmin.server.service.persistence.validation.EntityValidatorService;
<abbr title="  91 import org.broadleafcommerce.openadmin.server.service.persistence.validation.PopulateValueRequestValidator;">  91 import org.broadleafcommerce.openadmin.server.service.persistence.validation.PopulateValueRequestValidatoðŸ”µ</abbr>
  92 import org.broadleafcommerce.openadmin.server.service.persistence.validation.PropertyValidationResult;
  93 import org.broadleafcommerce.openadmin.server.service.type.MetadataProviderResponse;
  94 import org.hibernate.FlushMode;
  95 import org.hibernate.Session;
  96 import org.springframework.beans.BeansException;
  97 import org.springframework.beans.factory.annotation.Value;
  98 import org.springframework.context.ApplicationContext;
  99 import org.springframework.context.ApplicationContextAware;
 100 import org.springframework.context.annotation.Primary;
 101 import org.springframework.context.annotation.Scope;
 102 import org.springframework.stereotype.Component;
 103 import org.springframework.util.Assert;
 104 
 105 
 106 /**
 107  * @author jfischer
 108  */
 109 @Primary
 110 @Component(&quot;blBasicPersistenceModule&quot;)
 111 @Scope(&quot;prototype&quot;)
<abbr title=" 112 public class BasicPersistenceModule implements PersistenceModule , RecordHelper , ApplicationContextAware {"> 112 public class BasicPersistenceModule implements PersistenceModule , RecordHelper , ApplicationContextAwareðŸ”µ</abbr>
 113     private static final Log LOG = LogFactory.getLog(BasicPersistenceModule.class);
 114 
 115     public static final String MAIN_ENTITY_NAME_PROPERTY = &quot;MAIN_ENTITY_NAME&quot;;
 116 
 117     public static final String ALTERNATE_ID_PROPERTY = &quot;ALTERNATE_ID&quot;;
 118 
 119     protected ApplicationContext applicationContext;
 120 
 121     protected PersistenceManager persistenceManager;
 122 
 123     @Resource(name = &quot;blEntityValidatorService&quot;)
 124     protected EntityValidatorService entityValidatorService;
 125 
 126     @Resource(name = &quot;blPersistenceProviders&quot;)
<abbr title=" 127     protected List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders = new ArrayList&lt;FieldPersistenceProvider&gt;();"> 127     protected List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders = new ArrayList&lt;FieldPersistencePrðŸ”µ</abbr>
 128 
 129     @Resource(name = &quot;blPopulateValueRequestValidators&quot;)
 130     protected List&lt;PopulateValueRequestValidator&gt; populateValidators;
 131 
 132     @Resource(name = &quot;blDefaultFieldPersistenceProvider&quot;)
 133     protected FieldPersistenceProvider defaultFieldPersistenceProvider;
 134 
 135     @Resource(name = &quot;blCriteriaTranslator&quot;)
 136     protected CriteriaTranslator criteriaTranslator;
 137 
 138     @Resource(name = &quot;blRestrictionFactory&quot;)
 139     protected RestrictionFactory restrictionFactory;
 140 
 141     @Resource(name = &quot;blBasicPersistenceModuleExtensionManager&quot;)
 142     protected BasicPersistenceModuleExtensionManager extensionManager;
 143 
 144     @Resource(name = &quot;blFetchWrapper&quot;)
 145     protected FetchWrapper fetchWrapper;
 146 
 147     @Value(&quot;${use.translation.search:false}&quot;)
 148     protected boolean useTranslationSearch;
 149 
 150     @Resource(name = &quot;blLocaleService&quot;)
 151     protected LocaleService localeService;
 152 
 153     @PostConstruct
 154     public void init() {
 155         Collections.sort(fieldPersistenceProviders, new Comparator&lt;FieldPersistenceProvider&gt;() {
 156 
 157             @Override
 158             public int compare(FieldPersistenceProvider o1, FieldPersistenceProvider o2) {
 159                 return Integer.compare(o1.getOrder(), o2.getOrder());
 160             }
 161         });
 162         Collections.sort(populateValidators, new Comparator&lt;PopulateValueRequestValidator&gt;() {
 163 
 164             @Override
 165             public int compare(PopulateValueRequestValidator o1, PopulateValueRequestValidator o2) {
 166                 return Integer.compare(o1.getOrder(), o2.getOrder());
 167             }
 168         });
 169     }
 170 
 171     @Override
 172     public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
 173         this.applicationContext = applicationContext;
 174     }
 175 
 176     @Override
 177     public boolean isCompatible(OperationType operationType) {
<abbr title=" 178         return OperationType.BASIC == operationType || OperationType.NONDESTRUCTIVEREMOVE == operationType;"> 178         return OperationType.BASIC == operationType || OperationType.NONDESTRUCTIVEREMOVE == operationTypðŸ”µ</abbr>
 179     }
 180 
 181     @Override
 182     public FieldManager getFieldManager() {
 183         return persistenceManager.getDynamicEntityDao().getFieldManager();
 184     }
 185 
 186     @Override
 187     public FieldManager getFieldManager(boolean cleanFieldManger) {
 188         return persistenceManager.getDynamicEntityDao().getFieldManager(cleanFieldManger);
 189     }
 190 
 191     @Override
 192     public DecimalFormat getDecimalFormatter() {
 193         BroadleafRequestContext brc = BroadleafRequestContext.getBroadleafRequestContext();
 194         Locale locale = brc.getJavaLocale();
 195         DecimalFormat format = (DecimalFormat) NumberFormat.getInstance(locale);
 196         format.applyPattern(&quot;0.########&quot;);
 197         format.setGroupingUsed(false);
 198         return format;
 199     }
 200 
 201     @Override
 202     public SimpleDateFormat getSimpleDateFormatter() {
 203         return FormatUtil.getDateFormat();
 204     }
 205 
<abbr title=" 206     protected Map&lt;String, FieldMetadata&gt; filterOutCollectionMetadata(Map&lt;String, FieldMetadata&gt; metadata) {"> 206     protected Map&lt;String, FieldMetadata&gt; filterOutCollectionMetadata(Map&lt;String, FieldMetadata&gt; metadata)ðŸ”µ</abbr>
 207         if (metadata == null) {
 208             return null;
 209         }
 210         Map&lt;String, FieldMetadata&gt; newMap = new HashMap&lt;String, FieldMetadata&gt;();
 211         for (Map.Entry&lt;String, FieldMetadata&gt; entry : metadata.entrySet()) {
 212             String fieldName = entry.getKey();
 213             FieldMetadata md = entry.getValue();
<abbr title=" 214             // Detect instances where the actual metadata for the field is some sort of CollectionMetadata but also corresponds"> 214             // Detect instances where the actual metadata for the field is some sort of CollectionMetadatðŸ”µ</abbr>
<abbr title=" 215             // to a ForeignKey and ensure that gets included in the filtered map. That way the {@link BasicPersistenceModule}"> 215             // to a ForeignKey and ensure that gets included in the filtered map. That way the {@link BasðŸ”µ</abbr>
 216             // can appropriate handle filtration and population
 217             if (entry.getValue() instanceof BasicFieldMetadata) {
 218                 newMap.put(fieldName, md);
<abbr title=" 219             } else if (md.getAdditionalMetadata().containsKey(AdvancedCollectionFieldMetadataProvider.FOREIGN_KEY_ADDITIONAL_METADATA_KEY)) {"> 219             } else if (md.getAdditionalMetadata().containsKey(AdvancedCollectionFieldMetadataProvider.FORðŸ”µ</abbr>
<abbr title=" 220                 newMap.put(fieldName, ((BasicFieldMetadata) (md.getAdditionalMetadata().get(AdvancedCollectionFieldMetadataProvider.FOREIGN_KEY_ADDITIONAL_METADATA_KEY))));"> 220                 newMap.put(fieldName, ((BasicFieldMetadata) (md.getAdditionalMetadata().get(AdvancedColleðŸ”µ</abbr>
 221             }
 222         }
 223         return newMap;
 224     }
 225 
 226     protected Class&lt;?&gt; getBasicBroadleafType(SupportedFieldType fieldType) {
 227         Class&lt;?&gt; response;
 228         switch (fieldType) {
 229             case BOOLEAN:
 230                 response = Boolean.TYPE;
 231                 break;
 232             case DATE:
 233                 response = Date.class;
 234                 break;
 235             case DECIMAL:
 236                 response = BigDecimal.class;
 237                 break;
 238             case MONEY:
 239                 response = Money.class;
 240                 break;
 241             case INTEGER:
 242                 response = Integer.TYPE;
 243                 break;
 244             case UNKNOWN:
 245                 response = null;
 246                 break;
 247             default:
 248                 response = String.class;
 249                 break;
 250         }
 251 
 252         return response;
 253     }
 254 
 255     @Override
<abbr title=" 256     public Serializable createPopulatedInstance(Serializable instance, Entity entity, Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId) throws ValidationException {"> 256     public Serializable createPopulatedInstance(Serializable instance, Entity entity, Map&lt;String, FieldMeðŸ”µ</abbr>
 257         return createPopulatedInstance(instance, entity, unfilteredProperties, setId, true);
 258     }
 259 
 260     @Override
<abbr title=" 261     public Serializable createPopulatedInstance(Serializable instance, Entity entity, Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId, Boolean validateUnsubmittedProperties) throws ValidationException {"> 261     public Serializable createPopulatedInstance(Serializable instance, Entity entity, Map&lt;String, FieldMeðŸ”µ</abbr>
<abbr title=" 262         final Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(unfilteredProperties);"> 262         final Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(unfilteredPropertðŸ”µ</abbr>
 263         FieldManager fieldManager = getFieldManager();
 264         boolean handled = false;
 265         for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {
<abbr title=" 266             MetadataProviderResponse response = fieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfilteredProperties);"> 266             MetadataProviderResponse response = fieldPersistenceProvider.filterProperties(new AddFilterPrðŸ”µ</abbr>
 267             if (MetadataProviderResponse.NOT_HANDLED != response) {
 268                 handled = true;
 269             }
 270             if (MetadataProviderResponse.HANDLED_BREAK == response) {
 271                 break;
 272             }
 273         }
 274         if (!handled) {
<abbr title=" 275             defaultFieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfilteredProperties);"> 275             defaultFieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfiðŸ”µ</abbr>
 276         }
<abbr title=" 277         //Order media field, map field and rule builder fields last, as they will have some validation components that depend on previous values"> 277         //Order media field, map field and rule builder fields last, as they will have some validation coðŸ”µ</abbr>
 278         Property[] sortedProperties = entity.getProperties();
 279         Arrays.sort(sortedProperties, new Comparator&lt;Property&gt;() {
 280             @Override
 281             public int compare(Property o1, Property o2) {
 282                 BasicFieldMetadata mo1 = ((BasicFieldMetadata) (mergedProperties.get(o1.getName())));
 283                 BasicFieldMetadata mo2 = ((BasicFieldMetadata) (mergedProperties.get(o2.getName())));
<abbr title=" 284                 boolean isLate1 = (((mo1 != null) &amp;&amp; (mo1.getFieldType() != null)) &amp;&amp; (mo1.getName() != null)) &amp;&amp; (((((SupportedFieldType.RULE_SIMPLE == mo1.getFieldType()) || (SupportedFieldType.RULE_WITH_QUANTITY == mo1.getFieldType())) || (SupportedFieldType.RULE_SIMPLE_TIME == mo1.getFieldType())) || (SupportedFieldType.MEDIA == mo1.getFieldType())) || o1.getName().contains(FieldManager.MAPFIELDSEPARATOR));"> 284                 boolean isLate1 = (((mo1 != null) &amp;&amp; (mo1.getFieldType() != null)) &amp;&amp; (mo1.getName() != nðŸ”µ</abbr>
<abbr title=" 285                 boolean isLate2 = (((mo2 != null) &amp;&amp; (mo2.getFieldType() != null)) &amp;&amp; (mo2.getName() != null)) &amp;&amp; (((((SupportedFieldType.RULE_SIMPLE == mo2.getFieldType()) || (SupportedFieldType.RULE_WITH_QUANTITY == mo2.getFieldType())) || (SupportedFieldType.RULE_SIMPLE_TIME == mo2.getFieldType())) || (SupportedFieldType.MEDIA == mo2.getFieldType())) || o2.getName().contains(FieldManager.MAPFIELDSEPARATOR));"> 285                 boolean isLate2 = (((mo2 != null) &amp;&amp; (mo2.getFieldType() != null)) &amp;&amp; (mo2.getName() != nðŸ”µ</abbr>
 286                 if (isLate1 &amp;&amp; (!isLate2)) {
 287                     return 1;
 288                 } else if ((!isLate1) &amp;&amp; isLate2) {
 289                     return -1;
 290                 }
 291                 return 0;
 292             }
 293         });
<abbr title=" 294         Session session = getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().unwrap(Session.class);"> 294         Session session = getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().unwrapðŸ”µ</abbr>
 295         FlushMode originalFlushMode = session.getHibernateFlushMode();
 296         try {
 297             session.setHibernateFlushMode(FlushMode.MANUAL);
 298             RuntimeException entityPersistenceException = null;
 299             for (Property property : sortedProperties) {
<abbr title=" 300                 BasicFieldMetadata metadata = ((BasicFieldMetadata) (mergedProperties.get(property.getName())));"> 300                 BasicFieldMetadata metadata = ((BasicFieldMetadata) (mergedProperties.get(property.getNamðŸ”µ</abbr>
 301                 Class&lt;?&gt; returnType;
<abbr title=" 302                 if ((!property.getName().contains(FieldManager.MAPFIELDSEPARATOR)) &amp;&amp; (!property.getName().startsWith(&quot;__&quot;))) {"> 302                 if ((!property.getName().contains(FieldManager.MAPFIELDSEPARATOR)) &amp;&amp; (!property.getName(ðŸ”µ</abbr>
 303                     Field field = fieldManager.getField(instance.getClass(), property.getName());
 304                     if (field == null) {
<abbr title=" 305                         LOG.debug((&quot;Unable to find a bean property for the reported property: &quot; + StringUtil.sanitize(property.getName())) + &quot;. Ignoring property.&quot;);"> 305                         LOG.debug((&quot;Unable to find a bean property for the reported property: &quot; + StringUðŸ”µ</abbr>
 306                         continue;
 307                     }
 308                     returnType = field.getType();
 309                 } else {
 310                     if (metadata == null) {
<abbr title=" 311                         LOG.debug((&quot;Unable to find a metadata property for the reported property: &quot; + StringUtil.sanitize(property.getName())) + &quot;. Ignoring property.&quot;);"> 311                         LOG.debug((&quot;Unable to find a metadata property for the reported property: &quot; + StrðŸ”µ</abbr>
 312                         continue;
 313                     }
 314                     returnType = getMapFieldType(instance, fieldManager, property);
 315                     if (returnType == null) {
 316                         returnType = getBasicBroadleafType(metadata.getFieldType());
 317                     }
 318                 }
 319                 if (returnType == null) {
<abbr title=" 320                     throw new IllegalAccessException((&quot;Unable to determine the value type for the property (&quot; + property.getName()) + &quot;)&quot;);"> 320                     throw new IllegalAccessException((&quot;Unable to determine the value type for the propertðŸ”µ</abbr>
 321                 }
 322                 String value = property.getValue();
 323                 if (metadata != null) {
 324                     if (metadata.getFieldType().equals(SupportedFieldType.BOOLEAN)) {
 325                         if (value == null) {
 326                             String defaultValue = metadata.getDefaultValue();
 327                             value = (StringUtils.isBlank(defaultValue)) ? &quot;false&quot; : defaultValue;
 328                         }
 329                     } else if (metadata.getFieldType().equals(SupportedFieldType.DATE)) {
 330                         if (StringUtils.isEmpty(value)) {
 331                             value = null;
 332                         }
 333                     }
<abbr title=" 334                     if (attemptToPopulateValue(property, fieldManager, instance, setId, metadata, entity, value)) {"> 334                     if (attemptToPopulateValue(property, fieldManager, instance, setId, metadata, entity,ðŸ”µ</abbr>
 335                         boolean isValid = true;
<abbr title=" 336                         PopulateValueRequest request = new PopulateValueRequest(setId, fieldManager, property, metadata, returnType, value, persistenceManager, this, entity.isPreAdd());"> 336                         PopulateValueRequest request = new PopulateValueRequest(setId, fieldManager, propðŸ”µ</abbr>
 337                         handled = false;
 338                         if (value != null) {
 339                             for (PopulateValueRequestValidator validator : populateValidators) {
<abbr title=" 340                                 PropertyValidationResult validationResult = validator.validate(request, instance);"> 340                                 PropertyValidationResult validationResult = validator.validate(request, iðŸ”µ</abbr>
 341                                 if (!validationResult.isValid()) {
<abbr title=" 342                                     entity.addValidationError(property.getName(), validationResult.getErrorMessage());"> 342                                     entity.addValidationError(property.getName(), validationResult.getErrðŸ”µ</abbr>
 343                                     isValid = false;
 344                                 }
 345                             }
 346                         }
 347                         if (isValid) {
 348                             try {
 349                                 boolean isBreakDetected = false;
<abbr title=" 350                                 for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {"> 350                                 for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceðŸ”µ</abbr>
<abbr title=" 351                                     if (((!isBreakDetected) || fieldPersistenceProvider.alwaysRun()) &amp;&amp; ((value != null) || fieldPersistenceProvider.canHandlePopulateNull())) {"> 351                                     if (((!isBreakDetected) || fieldPersistenceProvider.alwaysRun()) &amp;&amp; (ðŸ”µ</abbr>
<abbr title=" 352                                         MetadataProviderResponse response = fieldPersistenceProvider.populateValue(request, instance);"> 352                                         MetadataProviderResponse response = fieldPersistenceProvider.popuðŸ”µ</abbr>
 353                                         if (MetadataProviderResponse.NOT_HANDLED != response) {
 354                                             handled = true;
 355                                         }
 356                                         if (MetadataProviderResponse.HANDLED_BREAK == response) {
 357                                             isBreakDetected = true;
 358                                         }
 359                                     }
 360                                 }
 361                                 if (!handled) {
 362                                     if (value == null) {
 363                                         property.setIsDirty(true);
 364                                     }
<abbr title=" 365                                     defaultFieldPersistenceProvider.populateValue(new PopulateValueRequest(setId, fieldManager, property, metadata, returnType, value, persistenceManager, this, entity.isPreAdd()), instance);"> 365                                     defaultFieldPersistenceProvider.populateValue(new PopulateValueRequesðŸ”µ</abbr>
 366                                     if (value == null) {
 367                                         fieldManager.setFieldValue(instance, property.getName(), null);
 368                                     }
 369                                 }
 370                             } catch (ParentEntityPersistenceException | validation e) {
 371                                 entityPersistenceException = e;
 372                                 cleanupFailedPersistenceAttempt(instance);
 373                                 break;
 374                             }
 375                         }
 376                     }
 377                 }
 378             }
 379             // Only check validation if not the initial add
 380             if (!entity.isPreAdd()) {
 381                 validate(entity, instance, mergedProperties, validateUnsubmittedProperties);
 382             }
<abbr title=" 383             //if validation failed, refresh the current instance so that none of the changes will be persisted"> 383             //if validation failed, refresh the current instance so that none of the changes will be persðŸ”µ</abbr>
 384             if (entity.isValidationFailure()) {
 385                 // only refresh the instance if it was managed to begin with
<abbr title=" 386                 if (persistenceManager.getDynamicEntityDao().getStandardEntityManager().contains(instance)) {"> 386                 if (persistenceManager.getDynamicEntityDao().getStandardEntityManager().contains(instanceðŸ”µ</abbr>
 387                     persistenceManager.getDynamicEntityDao().refresh(instance);
 388                 }
<abbr title=" 389                 // re-initialize the valid properties for the entity in order to deal with the potential of not"> 389                 // re-initialize the valid properties for the entity in order to deal with the potential ðŸ”µ</abbr>
 390                 // completely sending over all checkbox/radio fields
 391                 List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
 392                 entityList.add(instance);
 393                 Entity invalid = getRecords(mergedProperties, entityList, null, null, null)[0];
 394                 invalid.setPropertyValidationErrors(entity.getPropertyValidationErrors());
 395                 invalid.setGlobalValidationErrors(entity.getGlobalValidationErrors());
 396                 invalid.overridePropertyValues(entity);
<abbr title=" 397                 String message = ValidationUtil.buildErrorMessage(invalid.getPropertyValidationErrors(), invalid.getGlobalValidationErrors());"> 397                 String message = ValidationUtil.buildErrorMessage(invalid.getPropertyValidationErrors(), ðŸ”µ</abbr>
 398                 throw new ValidationException(invalid, message);
 399             } else if (entityPersistenceException != null) {
 400                 throw ExceptionHelper.refineException(entityPersistenceException.getCause());
 401             } else {
 402                 fieldManager.persistMiddleEntities();
 403             }
 404         } catch (java.lang.IllegalAccessException e) {
 405             throw new PersistenceException(e);
 406         } catch (java.lang.InstantiationException e) {
 407             throw new PersistenceException(e);
 408         } finally {
 409             session.setHibernateFlushMode(originalFlushMode);
 410         }
 411         return instance;
 412     }
 413 
<abbr title=" 414     protected boolean attemptToPopulateValue(Property property, FieldManager fieldManager, Serializable instance, Boolean setId, BasicFieldMetadata metadata, Entity entity, String value) throws IllegalAccessException {"> 414     protected boolean attemptToPopulateValue(Property property, FieldManager fieldManager, Serializable iðŸ”µ</abbr>
 415         Boolean mutable = metadata.getMutable();
 416         Boolean readOnly = metadata.getReadOnly();
<abbr title=" 417         boolean generalConditionsMet = (((mutable == null) || mutable) &amp;&amp; ((readOnly == null) || (!readOnly))) &amp;&amp; property.getEnabled();"> 417         boolean generalConditionsMet = (((mutable == null) || mutable) &amp;&amp; ((readOnly == null) || (!readOnðŸ”µ</abbr>
 418         if (generalConditionsMet &amp;&amp; (value == null)) {
 419             boolean currentValueIsNotNull = false;
 420             try {
 421                 currentValueIsNotNull = fieldManager.getFieldValue(instance, property.getName()) != null;
 422             } catch (FieldNotAvailableException e) {
 423                 throw new IllegalArgumentException(e);
 424             }
 425             boolean valueIsNotNullId = (metadata.getFieldType() != SupportedFieldType.ID) || setId;
 426             boolean valueIsNotPassword = metadata.getFieldType() != SupportedFieldType.PASSWORD;
<abbr title=" 427             return ((currentValueIsNotNull &amp;&amp; (!entity.isPreAdd())) &amp;&amp; valueIsNotNullId) &amp;&amp; valueIsNotPassword;"> 427             return ((currentValueIsNotNull &amp;&amp; (!entity.isPreAdd())) &amp;&amp; valueIsNotNullId) &amp;&amp; valueIsNotPasðŸ”µ</abbr>
 428         }
 429         return generalConditionsMet;
 430     }
 431 
 432     @Override
<abbr title=" 433     public Entity getRecord(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, Serializable record, Map&lt;String, FieldMetadata&gt; alternateMergedProperties, String pathToTargetObject) {"> 433     public Entity getRecord(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, Serializable record, Map&lt;ðŸ”µ</abbr>
 434         List&lt;Serializable&gt; records = new ArrayList&lt;Serializable&gt;(1);
 435         records.add(record);
<abbr title=" 436         Entity[] productEntities = getRecords(primaryMergedProperties, records, alternateMergedProperties, pathToTargetObject, null);"> 436         Entity[] productEntities = getRecords(primaryMergedProperties, records, alternateMergedPropertiesðŸ”µ</abbr>
 437         return productEntities[0];
 438     }
 439 
 440     @Override
<abbr title=" 441     public Entity getRecord(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, Serializable record) {"> 441     public Entity getRecord(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, SðŸ”µ</abbr>
<abbr title=" 442         Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persistencePerspective);"> 442         Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getNamðŸ”µ</abbr>
 443         return getRecord(mergedProperties, record, null, null);
 444     }
 445 
 446     @Override
<abbr title=" 447     public Entity[] getRecords(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, List&lt;? extends Serializable&gt; records) {"> 447     public Entity[] getRecords(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspectiveðŸ”µ</abbr>
<abbr title=" 448         Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persistencePerspective);"> 448         Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getNamðŸ”µ</abbr>
 449         return getRecords(mergedProperties, records, null, null, null);
 450     }
 451 
 452     @Override
<abbr title=" 453     public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persistencePerspective) {"> 453     public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspectiveðŸ”µ</abbr>
<abbr title=" 454         return persistenceManager.getDynamicEntityDao().getSimpleMergedProperties(entityName, persistencePerspective);"> 454         return persistenceManager.getDynamicEntityDao().getSimpleMergedProperties(entityName, persistenceðŸ”µ</abbr>
 455     }
 456 
 457     @Override
<abbr title=" 458     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, List&lt;? extends Serializable&gt; records) {"> 458     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, List&lt;? extends SerialiðŸ”µ</abbr>
 459         return getRecords(primaryMergedProperties, records, null, null, null);
 460     }
 461 
 462     @Override
<abbr title=" 463     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryUnfilteredMergedProperties, List&lt;? extends Serializable&gt; records, Map&lt;String, FieldMetadata&gt; alternateUnfilteredMergedProperties, String pathToTargetObject) {"> 463     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryUnfilteredMergedProperties, List&lt;? extenðŸ”µ</abbr>
<abbr title=" 464         return getRecords(primaryUnfilteredMergedProperties, records, alternateUnfilteredMergedProperties, pathToTargetObject, null);"> 464         return getRecords(primaryUnfilteredMergedProperties, records, alternateUnfilteredMergedPropertiesðŸ”µ</abbr>
 465     }
 466 
 467     @Override
<abbr title=" 468     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryUnfilteredMergedProperties, List&lt;? extends Serializable&gt; records, Map&lt;String, FieldMetadata&gt; alternateUnfilteredMergedProperties, String pathToTargetObject, String[] customCriteria) {"> 468     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryUnfilteredMergedProperties, List&lt;? extenðŸ”µ</abbr>
<abbr title=" 469         Map&lt;String, FieldMetadata&gt; primaryMergedProperties = filterOutCollectionMetadata(primaryUnfilteredMergedProperties);"> 469         Map&lt;String, FieldMetadata&gt; primaryMergedProperties = filterOutCollectionMetadata(primaryUnfiltereðŸ”µ</abbr>
<abbr title=" 470         Map&lt;String, FieldMetadata&gt; alternateMergedProperties = filterOutCollectionMetadata(alternateUnfilteredMergedProperties);"> 470         Map&lt;String, FieldMetadata&gt; alternateMergedProperties = filterOutCollectionMetadata(alternateUnfilðŸ”µ</abbr>
 471         Entity[] entities = new Entity[records.size()];
 472         int j = 0;
 473         for (Serializable recordEntity : records) {
 474             Serializable entity;
 475             if (pathToTargetObject != null) {
 476                 try {
<abbr title=" 477                     entity = ((Serializable) (getFieldManager().getFieldValue(recordEntity, pathToTargetObject)));"> 477                     entity = ((Serializable) (getFieldManager().getFieldValue(recordEntity, pathToTargetOðŸ”µ</abbr>
 478                 } catch (java.lang.Exception e) {
 479                     throw new PersistenceException(e);
 480                 }
 481             } else {
 482                 entity = recordEntity;
 483             }
 484             Entity entityItem = new Entity();
 485             entityItem.setType(new String[]{ entity.getClass().getName() });
 486             entities[j] = entityItem;
 487             List&lt;Property&gt; props = new ArrayList&lt;Property&gt;(primaryMergedProperties.size());
<abbr title=" 488             extractPropertiesFromPersistentEntity(primaryMergedProperties, entity, props, customCriteria);"> 488             extractPropertiesFromPersistentEntity(primaryMergedProperties, entity, props, customCriteria)ðŸ”µ</abbr>
 489             if (alternateMergedProperties != null) {
<abbr title=" 490                 extractPropertiesFromPersistentEntity(alternateMergedProperties, recordEntity, props, customCriteria);"> 490                 extractPropertiesFromPersistentEntity(alternateMergedProperties, recordEntity, props, cusðŸ”µ</abbr>
 491             }
 492             // Try to add the &quot;main name&quot; property. Log a debug message if we can&#x27;t
 493             try {
 494                 Property p = new Property();
 495                 p.setName(MAIN_ENTITY_NAME_PROPERTY);
<abbr title=" 496                 String mainEntityName = ((String) (MethodUtils.invokeMethod(entity, &quot;getMainEntityName&quot;)));"> 496                 String mainEntityName = ((String) (MethodUtils.invokeMethod(entity, &quot;getMainEntityName&quot;))ðŸ”µ</abbr>
 497                 p.setValue(mainEntityName);
 498                 props.add(p);
 499             } catch (java.lang.Exception e) {
<abbr title=" 500                 LOG.debug(String.format(&quot;Could not execute the getMainEntityName() method for [%s]&quot;, entity.getClass().getName()), e);"> 500                 LOG.debug(String.format(&quot;Could not execute the getMainEntityName() method for [%s]&quot;, entiðŸ”µ</abbr>
 501             }
 502             // Try to add the alternate id property if available
 503             if (alternateMergedProperties != null) {
 504                 for (Entry&lt;String, FieldMetadata&gt; entry : alternateMergedProperties.entrySet()) {
 505                     if (entry.getValue() instanceof BasicFieldMetadata) {
<abbr title=" 506                         if (((BasicFieldMetadata) (entry.getValue())).getFieldType() == SupportedFieldType.ID) {"> 506                         if (((BasicFieldMetadata) (entry.getValue())).getFieldType() == SupportedFieldTypðŸ”µ</abbr>
<abbr title=" 507                             Map&lt;String, FieldMetadata&gt; alternateOnEntity = new HashMap&lt;String, FieldMetadata&gt;();"> 507                             Map&lt;String, FieldMetadata&gt; alternateOnEntity = new HashMap&lt;String, FieldMetadðŸ”µ</abbr>
 508                             alternateOnEntity.put(entry.getKey(), entry.getValue());
 509                             List&lt;Property&gt; props2 = new ArrayList&lt;Property&gt;();
<abbr title=" 510                             extractPropertiesFromPersistentEntity(alternateOnEntity, recordEntity, props2, customCriteria);"> 510                             extractPropertiesFromPersistentEntity(alternateOnEntity, recordEntity, props2ðŸ”µ</abbr>
 511                             List&lt;Property&gt; filtered = new ArrayList&lt;Property&gt;();
 512                             for (Property prop : props2) {
 513                                 if (!prop.getName().startsWith(&quot;__&quot;)) {
 514                                     filtered.add(prop);
 515                                 }
 516                             }
 517                             if ((filtered.size() == 1) &amp;&amp; (!filtered.get(0).getName().contains(&quot;.&quot;))) {
 518                                 Property alternateIdProp = filtered.get(0);
 519                                 alternateIdProp.setName(ALTERNATE_ID_PROPERTY);
 520                                 props.add(alternateIdProp);
 521                             }
 522                         }
 523                     }
 524                 }
 525             }
 526             Property[] properties = new Property[props.size()];
 527             properties = props.toArray(properties);
 528             entityItem.setProperties(properties);
 529             j++;
 530         }
 531         return entities;
 532     }
 533 
 534     @Override
 535     public Entity[] getRecords(FetchExtractionRequest fetchExtractionRequest) {
 536         return fetchWrapper.getRecords(fetchExtractionRequest);
 537     }
 538 
<abbr title=" 539     protected void extractPropertiesFromPersistentEntity(Map&lt;String, FieldMetadata&gt; mergedProperties, Serializable entity, List&lt;Property&gt; props, String[] customCriteria) {"> 539     protected void extractPropertiesFromPersistentEntity(Map&lt;String, FieldMetadata&gt; mergedProperties, SerðŸ”µ</abbr>
 540         FieldManager fieldManager = getFieldManager();
 541         try {
 542             if (entity instanceof AdminMainEntity) {
 543                 //Create an invisible property for the admin main entity name, if applicable.
 544                 //This is useful for ToOneLookups if that ToOneLookup uses AdminMainEntity to drive
 545                 //its display name.
 546                 try {
 547                     Property propertyItem = new Property();
 548                     propertyItem.setName(AdminMainEntity.MAIN_ENTITY_NAME_PROPERTY);
 549                     propertyItem.setValue(((AdminMainEntity) (entity)).getMainEntityName());
 550                     props.add(propertyItem);
 551                 } catch (java.lang.Exception e) {
<abbr title=" 552                     // do nothing here except for not add the property. Exceptions could occur when there is a validation"> 552                     // do nothing here except for not add the property. Exceptions could occur when thereðŸ”µ</abbr>
<abbr title=" 553                     // issue and some properties/relationships that are used for gleaning the main entity name end up"> 553                     // issue and some properties/relationships that are used for gleaning the main entityðŸ”µ</abbr>
 554                     // not being set
 555                 }
 556             }
 557             for (Entry&lt;String, FieldMetadata&gt; entry : mergedProperties.entrySet()) {
 558                 String property = entry.getKey();
 559                 BasicFieldMetadata metadata = ((BasicFieldMetadata) (entry.getValue()));
<abbr title=" 560                 if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(entity.getClass()) || entity.getClass().isAssignableFrom(Class.forName(metadata.getInheritedFromType()))) {"> 560                 if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(entity.getClass()) ||ðŸ”µ</abbr>
 561                     boolean proceed = true;
 562                     if (property.contains(&quot;.&quot;)) {
 563                         StringTokenizer tokens = new StringTokenizer(property, &quot;.&quot;);
 564                         Object testObject = entity;
 565                         while (tokens.hasMoreTokens()) {
 566                             String token = tokens.nextToken();
 567                             if (tokens.hasMoreTokens()) {
 568                                 try {
 569                                     testObject = fieldManager.getFieldValue(testObject, token);
 570                                 } catch (FieldNotAvailableException e) {
 571                                     proceed = false;
 572                                     break;
 573                                 }
 574                                 if (testObject == null) {
 575                                     Property propertyItem = new Property();
 576                                     propertyItem.setName(property);
 577                                     if (props.contains(propertyItem)) {
 578                                         proceed = false;
 579                                         break;
 580                                     }
 581                                     propertyItem.setValue(null);
 582                                     props.add(propertyItem);
 583                                     proceed = false;
 584                                     break;
 585                                 }
 586                             }
 587                         }
 588                     }
 589                     if (!proceed) {
 590                         continue;
 591                     }
 592                     boolean isFieldAccessible = true;
 593                     Object value = null;
 594                     try {
 595                         value = fieldManager.getFieldValue(entity, property);
 596                     } catch (FieldNotAvailableException e) {
 597                         isFieldAccessible = false;
 598                     }
 599                     checkField : {
 600                         if (isFieldAccessible) {
 601                             Property propertyItem = new Property();
 602                             propertyItem.setName(property);
 603                             if (props.contains(propertyItem)) {
 604                                 continue;
 605                             }
 606                             props.add(propertyItem);
 607                             String displayVal = propertyItem.getDisplayValue();
 608                             boolean handled = false;
<abbr title=" 609                             for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {"> 609                             for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProvðŸ”µ</abbr>
<abbr title=" 610                                 MetadataProviderResponse response = fieldPersistenceProvider.extractValue(new ExtractValueRequest(props, fieldManager, metadata, value, displayVal, persistenceManager, this, entity, customCriteria), propertyItem);"> 610                                 MetadataProviderResponse response = fieldPersistenceProvider.extractValueðŸ”µ</abbr>
 611                                 if (MetadataProviderResponse.NOT_HANDLED != response) {
 612                                     handled = true;
 613                                 }
 614                                 if (MetadataProviderResponse.HANDLED_BREAK == response) {
 615                                     break;
 616                                 }
 617                             }
 618                             if (!handled) {
<abbr title=" 619                                 defaultFieldPersistenceProvider.extractValue(new ExtractValueRequest(props, fieldManager, metadata, value, displayVal, persistenceManager, this, entity, customCriteria), propertyItem);"> 619                                 defaultFieldPersistenceProvider.extractValue(new ExtractValueRequest(propðŸ”µ</abbr>
 620                             }
 621                             break checkField;
 622                         }
 623                         //try a direct property acquisition via reflection
 624                         try {
 625                             String strVal = null;
 626                             Method method;
 627                             try {
 628                                 // try a &#x27;get&#x27; prefixed mutator first
<abbr title=" 629                                 String temp = (&quot;get&quot; + property.substring(0, 1).toUpperCase()) + property.substring(1, property.length());"> 629                                 String temp = (&quot;get&quot; + property.substring(0, 1).toUpperCase()) + propertyðŸ”µ</abbr>
 630                                 method = entity.getClass().getMethod(temp, new Class[]{  });
 631                             } catch (java.lang.NoSuchMethodException e) {
 632                                 method = entity.getClass().getMethod(property, new Class[]{  });
 633                             }
 634                             value = method.invoke(entity, new String[]{  });
 635                             Property propertyItem = new Property();
 636                             propertyItem.setName(property);
 637                             if (props.contains(propertyItem)) {
 638                                 continue;
 639                             }
 640                             props.add(propertyItem);
 641                             if (value == null) {
 642                                 strVal = null;
 643                             } else if (Date.class.isAssignableFrom(value.getClass())) {
 644                                 strVal = getSimpleDateFormatter().format(((Date) (value)));
 645                             } else if (Timestamp.class.isAssignableFrom(value.getClass())) {
<abbr title=" 646                                 strVal = getSimpleDateFormatter().format(new Date(((Timestamp) (value)).getTime()));"> 646                                 strVal = getSimpleDateFormatter().format(new Date(((Timestamp) (value)).gðŸ”µ</abbr>
 647                             } else if (Calendar.class.isAssignableFrom(value.getClass())) {
 648                                 strVal = getSimpleDateFormatter().format(((Calendar) (value)).getTime());
 649                             } else if (java.lang.Double.class.isAssignableFrom(value.getClass())) {
 650                                 strVal = getDecimalFormatter().format(value);
 651                             } else if (BigDecimal.class.isAssignableFrom(value.getClass())) {
 652                                 strVal = getDecimalFormatter().format(value);
 653                             } else {
 654                                 strVal = value.toString();
 655                             }
 656                             propertyItem.setValue(strVal);
 657                         } catch (java.lang.NoSuchMethodException e) {
<abbr title=" 658                             LOG.debug(&quot;Unable to find a specified property in the entity: &quot; + StringUtil.sanitize(property));"> 658                             LOG.debug(&quot;Unable to find a specified property in the entity: &quot; + StringUtil.ðŸ”µ</abbr>
 659                             // do nothing - this property is simply not in the bean
 660                         }
 661                     }
 662                 }
 663             }
 664         } catch (java.lang.ClassNotFoundException e) {
 665             throw new PersistenceException(e);
 666         } catch (java.lang.IllegalAccessException e) {
 667             throw new PersistenceException(e);
 668         } catch (InvocationTargetException e) {
 669             throw new PersistenceException(e);
 670         }
 671     }
 672 
 673     @Override
 674     public String getStringValueFromGetter(Serializable instance, String propertyName)
 675             throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
 676         Object value = PropertyUtils.getProperty(instance, propertyName);
 677         return formatValue(value);
 678     }
 679 
 680     @Override
 681     public String formatValue(Object value) {
 682         String strVal;
 683         if (value == null) {
 684             strVal = null;
 685         } else {
 686             if (Date.class.isAssignableFrom(value.getClass())) {
 687                 strVal = getSimpleDateFormatter().format((Date) value);
 688             } else if (Timestamp.class.isAssignableFrom(value.getClass())) {
 689                 strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value).getTime()));
 690             } else if (Calendar.class.isAssignableFrom(value.getClass())) {
 691                 strVal = getSimpleDateFormatter().format(((Calendar) value).getTime());
 692             } else if (Double.class.isAssignableFrom(value.getClass())) {
 693                 strVal = getDecimalFormatter().format(value);
 694             } else if (BigDecimal.class.isAssignableFrom(value.getClass())) {
 695                 strVal = getDecimalFormatter().format(value);
 696             } else {
 697                 strVal = value.toString();
 698             }
 699         }
 700         return strVal;
 701     }
 702 
<abbr title=" 703     protected EntityResult update(PersistencePackage persistencePackage, Object primaryKey, boolean includeRealEntity) throws ServiceException {"> 703     protected EntityResult update(PersistencePackage persistencePackage, Object primaryKey, boolean incluðŸ”µ</abbr>
 704         EntityResult entityResult = new EntityResult();
 705         Entity entity = persistencePackage.getEntity();
 706         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title=" 707         ForeignKey foreignKey = ((ForeignKey) (persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY)));"> 707         ForeignKey foreignKey = ((ForeignKey) (persistencePerspective.getPersistencePerspectiveItems().geðŸ”µ</abbr>
 708         if ((foreignKey != null) &amp;&amp; (!foreignKey.getMutable())) {
 709             throw new SecurityServiceException(&quot;Entity not mutable&quot;);
 710         }
 711         try {
<abbr title=" 712             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());"> 712             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingðŸ”µ</abbr>
<abbr title=" 713             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(persistencePackage.getCeilingEntityFullyQualifiedClassname(), entities, foreignKey, persistencePerspective.getAdditionalNonPersistentProperties(), persistencePerspective.getAdditionalForeignKeys(), MergedPropertyType.PRIMARY, persistencePerspective.getPopulateToOneFields(), persistencePerspective.getIncludeFields(), persistencePerspective.getExcludeFields(), persistencePerspective.getConfigurationKey(), &quot;&quot;);"> 713             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMerðŸ”µ</abbr>
 714             if (primaryKey == null) {
 715                 primaryKey = getPrimaryKey(entity, mergedProperties);
 716             }
<abbr title=" 717             Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getType()[0]), primaryKey);"> 717             Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entitðŸ”µ</abbr>
 718             Assert.isTrue(instance != null, &quot;Entity not found&quot;);
 719             if (!entity.isValidationFailure()) {
 720                 //Re-Balance the list if it is a Foreign Key toMany collection with a sort field property
<abbr title=" 721                 if ((((foreignKey != null) &amp;&amp; (foreignKey.getSortField() != null)) &amp;&amp; (entity.findProperty(foreignKey.getSortField()) != null)) &amp;&amp; (entity.findProperty(foreignKey.getSortField()).getValue() != null)) {"> 721                 if ((((foreignKey != null) &amp;&amp; (foreignKey.getSortField() != null)) &amp;&amp; (entity.findPropertðŸ”µ</abbr>
<abbr title=" 722                     ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;();"> 722                     ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;(ðŸ”µ</abbr>
<abbr title=" 723                     extensionManager.getProxy().rebalanceForUpdate(this, persistencePackage, instance, mergedProperties, primaryKey, result);"> 723                     extensionManager.getProxy().rebalanceForUpdate(this, persistencePackage, instance, meðŸ”µ</abbr>
 724                     instance = result.getResult();
 725                 } else {
<abbr title=" 726                     instance = createPopulatedInstance(instance, entity, mergedProperties, false, persistencePackage.isValidateUnsubmittedProperties());"> 726                     instance = createPopulatedInstance(instance, entity, mergedProperties, false, persistðŸ”µ</abbr>
 727                 }
 728                 instance = persistenceManager.getDynamicEntityDao().merge(instance);
 729                 if (includeRealEntity) {
 730                     entityResult.setEntityBackingObject(instance);
 731                 }
 732                 List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
 733                 entityList.add(instance);
 734                 entity = getRecords(mergedProperties, entityList, null, null, null)[0];
 735                 entityResult.setEntity(entity);
 736                 return entityResult;
 737             } else {
 738                 entityResult.setEntity(entity);
 739                 return entityResult;
 740             }
 741         } catch (java.lang.Exception e) {
 742             throw new ServiceException(&quot;Problem updating entity : &quot; + e.getMessage(), e);
 743         }
 744     }
 745 
 746     @Override
 747     public String getIdPropertyName(String entityClass) {
 748         return persistenceManager.getIdPropertyName(entityClass);
 749     }
 750 
 751     public String getIdPropertyName(Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
<abbr title=" 752         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);"> 752         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredPropertðŸ”µ</abbr>
 753         for (String property : mergedProperties.keySet()) {
 754             BasicFieldMetadata temp = ((BasicFieldMetadata) (mergedProperties.get(property)));
 755             if ((temp.getFieldType() == SupportedFieldType.ID) &amp;&amp; (!property.contains(&quot;.&quot;))) {
 756                 return property;
 757             }
 758         }
<abbr title=" 759         throw new RuntimeException(&quot;Could not find a primary key property in the passed merged properties list&quot;);"> 759         throw new RuntimeException(&quot;Could not find a primary key property in the passed merged propertiesðŸ”µ</abbr>
 760     }
 761 
 762     @Override
 763     public Object getPrimaryKey(Entity entity, Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
<abbr title=" 764         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);"> 764         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredPropertðŸ”µ</abbr>
 765         Object primaryKey = null;
 766         String idPropertyName = null;
 767         BasicFieldMetadata metaData = null;
 768         for (String property : mergedProperties.keySet()) {
 769             BasicFieldMetadata temp = ((BasicFieldMetadata) (mergedProperties.get(property)));
 770             if ((temp.getFieldType() == SupportedFieldType.ID) &amp;&amp; (!property.contains(&quot;.&quot;))) {
 771                 idPropertyName = property;
 772                 metaData = temp;
 773                 break;
 774             }
 775         }
 776         if (idPropertyName == null) {
<abbr title=" 777             throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: &quot; + entity.getType()[0]);"> 777             throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with tðŸ”µ</abbr>
 778         }
 779         for (Property property : entity.getProperties()) {
 780             if (property.getName().equals(idPropertyName)) {
 781                 switch (metaData.getSecondaryType()) {
 782                     case INTEGER :
<abbr title=" 783                         primaryKey = (property.getValue() == null) ? null : Long.valueOf(property.getValue());"> 783                         primaryKey = (property.getValue() == null) ? null : Long.valueOf(property.getValuðŸ”µ</abbr>
 784                         break;
 785                     case STRING :
 786                         primaryKey = property.getValue();
 787                         break;
 788                 }
 789                 break;
 790             }
 791         }
 792         if (primaryKey == null) {
<abbr title=" 793             throw new RuntimeException(((&quot;Could not find the primary key property (&quot; + idPropertyName) + &quot;) in the passed entity with type: &quot;) + entity.getType()[0]);"> 793             throw new RuntimeException(((&quot;Could not find the primary key property (&quot; + idPropertyName) + ðŸ”µ</abbr>
 794         }
 795         return primaryKey;
 796     }
 797 
 798     @Override
<abbr title=" 799     public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective, CriteriaTransferObject cto, String ceilingEntityFullyQualifiedClassname, Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties, RestrictionFactory customRestrictionFactory) {"> 799     public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective, CriteriaTðŸ”µ</abbr>
<abbr title=" 800         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);"> 800         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredPropertðŸ”µ</abbr>
 801         List&lt;FilterMapping&gt; filterMappings = new ArrayList&lt;FilterMapping&gt;();
 802         for (String propertyId : cto.getCriteriaMap().keySet()) {
 803             if (mergedProperties.containsKey(propertyId)) {
 804                 boolean handled = false;
 805                 for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {
<abbr title=" 806                     MetadataProviderResponse response = fieldPersistenceProvider.addSearchMapping(new AddSearchMappingRequest(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergedProperties, propertyId, getFieldManager(), this, this, customRestrictionFactory == null ? restrictionFactory : customRestrictionFactory), filterMappings);"> 806                     MetadataProviderResponse response = fieldPersistenceProvider.addSearchMapping(new AddðŸ”µ</abbr>
 807                     if (MetadataProviderResponse.NOT_HANDLED != response) {
 808                         handled = true;
 809                     }
 810                     if (MetadataProviderResponse.HANDLED_BREAK == response) {
 811                         break;
 812                     }
 813                 }
 814                 if (!handled) {
<abbr title=" 815                     defaultFieldPersistenceProvider.addSearchMapping(new AddSearchMappingRequest(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergedProperties, propertyId, getFieldManager(), this, this, customRestrictionFactory == null ? restrictionFactory : customRestrictionFactory), filterMappings);"> 815                     defaultFieldPersistenceProvider.addSearchMapping(new AddSearchMappingRequest(persisteðŸ”µ</abbr>
 816                 }
 817             }
 818         }
 819         return filterMappings;
 820     }
 821 
 822     @Override
<abbr title=" 823     public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective, CriteriaTransferObject cto, String ceilingEntityFullyQualifiedClassname, Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {"> 823     public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective, CriteriaTðŸ”µ</abbr>
<abbr title=" 824         return getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergedUnfilteredProperties, null);"> 824         return getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergeðŸ”µ</abbr>
 825     }
 826 
 827     @Override
<abbr title=" 828     public void extractProperties(Class&lt;?&gt;[] inheritanceLine, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; mergedProperties, List&lt;Property&gt; properties) {"> 828     public void extractProperties(Class&lt;?&gt;[] inheritanceLine, Map&lt;MergedPropertyType, Map&lt;String, FieldMeðŸ”µ</abbr>
<abbr title=" 829         extractPropertiesFromMetadata(inheritanceLine, mergedProperties.get(MergedPropertyType.PRIMARY), properties, false, MergedPropertyType.PRIMARY);"> 829         extractPropertiesFromMetadata(inheritanceLine, mergedProperties.get(MergedPropertyType.PRIMARY), ðŸ”µ</abbr>
 830     }
 831 
<abbr title=" 832     protected void extractPropertiesFromMetadata(Class&lt;?&gt;[] inheritanceLine, Map&lt;String, FieldMetadata&gt; mergedProperties, List&lt;Property&gt; properties, Boolean isHiddenOverride, MergedPropertyType type) {"> 832     protected void extractPropertiesFromMetadata(Class&lt;?&gt;[] inheritanceLine, Map&lt;String, FieldMetadata&gt; mðŸ”µ</abbr>
 833         Comparator&lt;Property&gt; comparator = new Comparator&lt;Property&gt;() {
 834             @Override
 835             public int compare(Property o1, Property o2) {
 836                 return o1.getName().compareTo(o2.getName());
 837             }
 838         };
 839         Collections.sort(properties, comparator);
 840         for (Map.Entry&lt;String, FieldMetadata&gt; entry : mergedProperties.entrySet()) {
 841             String property = entry.getKey();
 842             Property prop = new Property();
 843             FieldMetadata metadata = mergedProperties.get(property);
 844             prop.setName(property);
 845             int pos = Collections.binarySearch(properties, prop, comparator);
<abbr title=" 846             if (((pos &gt;= 0) &amp;&amp; (MergedPropertyType.MAPSTRUCTUREKEY != type)) &amp;&amp; (MergedPropertyType.MAPSTRUCTUREVALUE != type)) {"> 846             if (((pos &gt;= 0) &amp;&amp; (MergedPropertyType.MAPSTRUCTUREKEY != type)) &amp;&amp; (MergedPropertyType.MAPSTðŸ”µ</abbr>
 847                 logWarn : {
<abbr title=" 848                     if ((metadata instanceof BasicFieldMetadata) &amp;&amp; SupportedFieldType.ID.equals(((BasicFieldMetadata) (metadata)).getFieldType())) {"> 848                     if ((metadata instanceof BasicFieldMetadata) &amp;&amp; SupportedFieldType.ID.equals(((BasicFðŸ”µ</abbr>
 849                         // don&#x27;t warn for id field collisions, but still ignore the colliding fields
 850                         break logWarn;
 851                     }
<abbr title=" 852                     //LOG.warn(&quot;Detected a field name collision (&quot; + metadata.getTargetClass() + &quot;.&quot; + property + &quot;) during inspection for the inheritance line starting with (&quot; + inheritanceLine[0].getName() + &quot;). Ignoring the additional field. This can occur most commonly when using the @AdminPresentationAdornedTargetCollection and the collection type and target class have field names in common. This situation should be avoided, as the system will strip the repeated fields, which can cause unpredictable behavior.&quot;);"> 852                     //LOG.warn(&quot;Detected a field name collision (&quot; + metadata.getTargetClass() + &quot;.&quot; + prðŸ”µ</abbr>
 853                 }
 854                 continue;
 855             } else if (pos &lt; 0) {
 856                 pos = (-pos) - 1;// calculate position to insert
 857 
 858             }
 859             properties.add(pos, prop);
 860             prop.setMetadata(metadata);
 861             if (isHiddenOverride &amp;&amp; (prop.getMetadata() instanceof BasicFieldMetadata)) {
 862                 //this only makes sense for non collection types
 863                 ((BasicFieldMetadata) (prop.getMetadata())).setVisibility(VisibilityEnum.HIDDEN_ALL);
 864             }
 865         }
 866     }
 867 
 868     @Override
<abbr title=" 869     public void updateMergedProperties(PersistencePackage persistencePackage, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; allMergedProperties) throws ServiceException {"> 869     public void updateMergedProperties(PersistencePackage persistencePackage, Map&lt;MergedPropertyType, MapðŸ”µ</abbr>
<abbr title=" 870         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();"> 870         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
 871         try {
<abbr title=" 872             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();"> 872             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective(ðŸ”µ</abbr>
<abbr title=" 873             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(ceilingEntityFullyQualifiedClassname);"> 873             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(ceilingEntityFullyQualifiedClðŸ”µ</abbr>
<abbr title=" 874             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(ceilingEntityFullyQualifiedClassname, entities, ((ForeignKey) (persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY))), persistencePerspective.getAdditionalNonPersistentProperties(), persistencePerspective.getAdditionalForeignKeys(), MergedPropertyType.PRIMARY, persistencePerspective.getPopulateToOneFields(), persistencePerspective.getIncludeFields(), persistencePerspective.getExcludeFields(), persistencePerspective.getConfigurationKey(), &quot;&quot;);"> 874             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMerðŸ”µ</abbr>
 875             allMergedProperties.put(MergedPropertyType.PRIMARY, mergedProperties);
 876         } catch (java.lang.Exception e) {
<abbr title=" 877             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);"> 877             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassnðŸ”µ</abbr>
 878         }
 879     }
 880 
 881     @Override
<abbr title=" 882     public EntityResult update(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServiceException {"> 882     public EntityResult update(PersistencePackage persistencePackage, boolean includeRealEntityObject) thðŸ”µ</abbr>
 883         return update(persistencePackage, null, true);
 884     }
 885 
 886     @Override
 887     public Entity update(PersistencePackage persistencePackage) throws ServiceException {
 888         EntityResult er = update(persistencePackage, null, false);
 889         return er.getEntity();
 890     }
 891 
 892     @Override
 893     public Entity add(PersistencePackage persistencePackage) throws ServiceException {
 894         EntityResult entityResult = add(persistencePackage, false);
 895         return entityResult.getEntity();
 896     }
 897 
 898     @Override
<abbr title=" 899     public EntityResult add(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServiceException {"> 899     public EntityResult add(PersistencePackage persistencePackage, boolean includeRealEntityObject) throwðŸ”µ</abbr>
 900         EntityResult entityResult = new EntityResult();
 901         Entity entity = persistencePackage.getEntity();
 902         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title=" 903         ForeignKey foreignKey = ((ForeignKey) (persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY)));"> 903         ForeignKey foreignKey = ((ForeignKey) (persistencePerspective.getPersistencePerspectiveItems().geðŸ”µ</abbr>
 904         if ((foreignKey != null) &amp;&amp; (!foreignKey.getMutable())) {
 905             throw new SecurityServiceException(&quot;Entity not mutable&quot;);
 906         }
 907         try {
<abbr title=" 908             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());"> 908             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingðŸ”µ</abbr>
<abbr title=" 909             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(persistencePackage.getCeilingEntityFullyQualifiedClassname(), entities, foreignKey, persistencePerspective.getAdditionalNonPersistentProperties(), persistencePerspective.getAdditionalForeignKeys(), MergedPropertyType.PRIMARY, persistencePerspective.getPopulateToOneFields(), persistencePerspective.getIncludeFields(), persistencePerspective.getExcludeFields(), persistencePerspective.getConfigurationKey(), &quot;&quot;);"> 909             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDaðŸ”µ</abbr>
<abbr title=" 910             Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);"> 910             Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProðŸ”µ</abbr>
 911             String idProperty = null;
 912             for (String property : mergedProperties.keySet()) {
<abbr title=" 913                 if (((BasicFieldMetadata) (mergedProperties.get(property))).getFieldType() == SupportedFieldType.ID) {"> 913                 if (((BasicFieldMetadata) (mergedProperties.get(property))).getFieldType() == SupportedFiðŸ”µ</abbr>
 914                     idProperty = property;
 915                     break;
 916                 }
 917             }
 918             if (idProperty == null) {
<abbr title=" 919                 throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: &quot; + entity.getType()[0]);"> 919                 throw new RuntimeException(&quot;Could not find a primary key property in the passed entity wiðŸ”µ</abbr>
 920             }
 921             Object primaryKey = null;
 922             try {
 923                 primaryKey = getPrimaryKey(entity, mergedProperties);
 924             } catch (java.lang.Exception e) {
 925                 // don&#x27;t do anything - this is a valid case
 926             }
 927             if (primaryKey == null) {
<abbr title=" 928                 Serializable instance = ((Serializable) (Class.forName(entity.getType()[0]).newInstance()));"> 928                 Serializable instance = ((Serializable) (Class.forName(entity.getType()[0]).newInstance()ðŸ”µ</abbr>
 929                 instance = createPopulatedInstance(instance, entity, mergedProperties, false);
 930                 if ((foreignKey != null) &amp;&amp; (foreignKey.getSortField() != null)) {
<abbr title=" 931                     ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;();"> 931                     ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;(ðŸ”µ</abbr>
<abbr title=" 932                     extensionManager.getProxy().rebalanceForAdd(this, persistencePackage, instance, mergedProperties, result);"> 932                     extensionManager.getProxy().rebalanceForAdd(this, persistencePackage, instance, mergeðŸ”µ</abbr>
 933                     instance = result.getResult();
 934                 }
 935                 instance = persistenceManager.getDynamicEntityDao().merge(instance);
 936                 if (includeRealEntityObject) {
 937                     entityResult.setEntityBackingObject(instance);
 938                 }
 939                 List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
 940                 entityList.add(instance);
 941                 entity = getRecords(mergedProperties, entityList, null, null, null)[0];
 942                 entityResult.setEntity(entity);
 943                 return entityResult;
 944             } else {
 945                 return update(persistencePackage, primaryKey, includeRealEntityObject);
 946             }
 947         } catch (java.lang.Exception e) {
 948             throw new ServiceException(&quot;Problem adding new entity : &quot; + e.getMessage(), e);
 949         }
 950     }
 951 
 952     @Override
 953     public void remove(PersistencePackage persistencePackage) throws ServiceException {
 954         Entity entity = persistencePackage.getEntity();
 955         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title=" 956         ForeignKey foreignKey = ((ForeignKey) (persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY)));"> 956         ForeignKey foreignKey = ((ForeignKey) (persistencePerspective.getPersistencePerspectiveItems().geðŸ”µ</abbr>
 957         if ((foreignKey != null) &amp;&amp; (!foreignKey.getMutable())) {
 958             throw new SecurityServiceException(&quot;Entity not mutable&quot;);
 959         }
 960         try {
<abbr title=" 961             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());"> 961             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingðŸ”µ</abbr>
<abbr title=" 962             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(persistencePackage.getCeilingEntityFullyQualifiedClassname(), entities, foreignKey, persistencePerspective.getAdditionalNonPersistentProperties(), persistencePerspective.getAdditionalForeignKeys(), MergedPropertyType.PRIMARY, persistencePerspective.getPopulateToOneFields(), persistencePerspective.getIncludeFields(), persistencePerspective.getExcludeFields(), persistencePerspective.getConfigurationKey(), &quot;&quot;);"> 962             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDaðŸ”µ</abbr>
<abbr title=" 963             Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);"> 963             Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProðŸ”µ</abbr>
 964             Object primaryKey = getPrimaryKey(entity, mergedProperties);
<abbr title=" 965             Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getType()[0]), primaryKey);"> 965             Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entitðŸ”µ</abbr>
 966             Assert.isTrue(instance != null, &quot;Entity not found&quot;);
 967             switch (persistencePerspective.getOperationTypes().getRemoveType()) {
 968                 case NONDESTRUCTIVEREMOVE :
 969                     FieldManager fieldManager = getFieldManager();
<abbr title=" 970                     FieldMetadata manyToFieldMetadata = mergedUnfilteredProperties.get(foreignKey.getManyToField());"> 970                     FieldMetadata manyToFieldMetadata = mergedUnfilteredProperties.get(foreignKey.getManyðŸ”µ</abbr>
<abbr title=" 971                     Object foreignKeyValue = entity.getPMap().get(foreignKey.getManyToField()).getValue();"> 971                     Object foreignKeyValue = entity.getPMap().get(foreignKey.getManyToField()).getValue()ðŸ”µ</abbr>
 972                     try {
 973                         foreignKeyValue = Long.valueOf(((String) (foreignKeyValue)));
 974                     } catch (java.lang.NumberFormatException e) {
<abbr title=" 975                         LOG.warn(&quot;Foreign primary key is not of type Long, assuming String for remove lookup&quot;);"> 975                         LOG.warn(&quot;Foreign primary key is not of type Long, assuming String for remove looðŸ”µ</abbr>
 976                     }
<abbr title=" 977                     Serializable foreignInstance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(foreignKey.getForeignKeyClass()), foreignKeyValue);"> 977                     Serializable foreignInstance = persistenceManager.getDynamicEntityDao().retrieve(ClasðŸ”µ</abbr>
<abbr title=" 978                     Collection collection = ((Collection) (fieldManager.getFieldValue(foreignInstance, foreignKey.getOriginatingField())));"> 978                     Collection collection = ((Collection) (fieldManager.getFieldValue(foreignInstance, foðŸ”µ</abbr>
 979                     collection.remove(instance);
<abbr title=" 980                     // if this is a bi-directional @OneToMany/@ManyToOne and there is no @JoinTable (just a foreign key on"> 980                     // if this is a bi-directional @OneToMany/@ManyToOne and there is no @JoinTable (justðŸ”µ</abbr>
<abbr title=" 981                     // the @ManyToOne side) then it will not be updated. In that instance, we have to explicitly"> 981                     // the @ManyToOne side) then it will not be updated. In that instance, we have to expðŸ”µ</abbr>
 982                     // set the manyTo field to null so that subsequent lookups will not find it
 983                     if (manyToFieldMetadata instanceof BasicFieldMetadata) {
<abbr title=" 984                         if (BooleanUtils.isTrue(((BasicFieldMetadata) (manyToFieldMetadata)).getRequired())) {"> 984                         if (BooleanUtils.isTrue(((BasicFieldMetadata) (manyToFieldMetadata)).getRequired(ðŸ”µ</abbr>
<abbr title=" 985                             throw new ServiceException(&quot;Could not remove from the collection as the ManyToOne side is a&quot; + (&quot; non-optional relationship. Consider changing &#x27;optional=true&#x27; in the @ManyToOne annotation&quot; + &quot; or nullable=true within the @JoinColumn annotation&quot;));"> 985                             throw new ServiceException(&quot;Could not remove from the collection as the ManyTðŸ”µ</abbr>
 986                         }
<abbr title=" 987                         // Since this is occuring on a remove persistence package, merge up-front (before making a change) for proper operation in the presence of the enterprise module"> 987                         // Since this is occuring on a remove persistence package, merge up-front (beforeðŸ”µ</abbr>
 988                         instance = persistenceManager.getDynamicEntityDao().merge(instance);
<abbr title=" 989                         Field manyToField = fieldManager.getField(instance.getClass(), foreignKey.getManyToField());"> 989                         Field manyToField = fieldManager.getField(instance.getClass(), foreignKey.getManyðŸ”µ</abbr>
 990                         Object manyToObject = manyToField.get(instance);
<abbr title=" 991                         if (((manyToObject != null) &amp;&amp; (!(manyToObject instanceof Collection))) &amp;&amp; (!(manyToObject instanceof Map))) {"> 991                         if (((manyToObject != null) &amp;&amp; (!(manyToObject instanceof Collection))) &amp;&amp; (!(manðŸ”µ</abbr>
 992                             manyToField.set(instance, null);
 993                             instance = persistenceManager.getDynamicEntityDao().merge(instance);
 994                         }
 995                     }
 996                     break;
 997                 case BASIC :
 998                     persistenceManager.getDynamicEntityDao().remove(instance);
 999                     break;
1000             }
1001         } catch (java.lang.Exception e) {
1002             throw new ServiceException(&quot;Problem removing entity : &quot; + e.getMessage(), e);
1003         }
1004     }
1005 
<abbr title="1006     public Map&lt;String, FieldMetadata&gt; getMergedProperties(PersistencePackage persistencePackage, CriteriaTransferObject cto) throws ServiceException {">1006     public Map&lt;String, FieldMetadata&gt; getMergedProperties(PersistencePackage persistencePackage, CriteriaðŸ”µ</abbr>
1007         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1008         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();">1008         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
1009         if (StringUtils.isEmpty(persistencePackage.getFetchTypeFullyQualifiedClassname())) {
1010             persistencePackage.setFetchTypeFullyQualifiedClassname(ceilingEntityFullyQualifiedClassname);
1011         }
1012         try {
<abbr title="1013             Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualifiedClassname));">1013             Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCðŸ”µ</abbr>
<abbr title="1014             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(ceilingEntityFullyQualifiedClassname, entities, ((ForeignKey) (persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY))), persistencePerspective.getAdditionalNonPersistentProperties(), persistencePerspective.getAdditionalForeignKeys(), MergedPropertyType.PRIMARY, persistencePerspective.getPopulateToOneFields(), persistencePerspective.getIncludeFields(), persistencePerspective.getExcludeFields(), persistencePerspective.getConfigurationKey(), &quot;&quot;);">1014             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMerðŸ”µ</abbr>
1015             return mergedProperties;
1016         } catch (java.lang.Exception e) {
<abbr title="1017             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);">1017             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassnðŸ”µ</abbr>
1018         }
1019     }
1020 
1021     @Override
<abbr title="1022     public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto) throws ServiceException {">1022     public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto) throðŸ”µ</abbr>
1023         Entity[] payload;
1024         int totalRecords;
1025         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1026         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();">1026         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
<abbr title="1027         ForeignKey foreignKey = ((ForeignKey) (persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY)));">1027         ForeignKey foreignKey = ((ForeignKey) (persistencePerspective.getPersistencePerspectiveItems().geðŸ”µ</abbr>
1028         try {
1029             if ((foreignKey != null) &amp;&amp; (foreignKey.getSortField() != null)) {
1030                 FilterAndSortCriteria sortCriteria = cto.get(foreignKey.getSortField());
1031                 sortCriteria.setSortAscending(foreignKey.getSortAscending());
1032             }
1033             Map&lt;String, FieldMetadata&gt; mergedProperties = getMergedProperties(persistencePackage, cto);
1034             if (useTranslationSearch) {
1035                 addTranslationSearchIfNeeded(cto, mergedProperties);
1036             }
<abbr title="1037             List&lt;FilterMapping&gt; filterMappings = getFilterMappings(persistencePerspective, cto, persistencePackage.getFetchTypeFullyQualifiedClassname(), mergedProperties);">1037             List&lt;FilterMapping&gt; filterMappings = getFilterMappings(persistencePerspective, cto, persistenðŸ”µ</abbr>
1038             List&lt;FilterMapping&gt; standardFilterMappings = new ArrayList&lt;FilterMapping&gt;(filterMappings);
1039             if (CollectionUtils.isNotEmpty(cto.getAdditionalFilterMappings())) {
1040                 standardFilterMappings.addAll(cto.getAdditionalFilterMappings());
1041             }
1042             if (CollectionUtils.isNotEmpty(cto.getNonCountAdditionalFilterMappings())) {
1043                 standardFilterMappings.addAll(cto.getNonCountAdditionalFilterMappings());
1044             }
<abbr title="1045             FetchRequest fetchRequest = new FetchRequest(persistencePackage, cto, persistencePackage.getFetchTypeFullyQualifiedClassname(), standardFilterMappings);">1045             FetchRequest fetchRequest = new FetchRequest(persistencePackage, cto, persistencePackage.getFðŸ”µ</abbr>
1046             List&lt;Serializable&gt; records = getPersistentRecords(fetchRequest);
1047             List&lt;FilterMapping&gt; countFilterMappings = new ArrayList&lt;FilterMapping&gt;(filterMappings);
1048             if (CollectionUtils.isNotEmpty(cto.getAdditionalFilterMappings())) {
1049                 countFilterMappings.addAll(cto.getAdditionalFilterMappings());
1050             }
<abbr title="1051             FetchRequest countFetchRequest = new FetchRequest(persistencePackage, cto, persistencePackage.getFetchTypeFullyQualifiedClassname(), countFilterMappings);">1051             FetchRequest countFetchRequest = new FetchRequest(persistencePackage, cto, persistencePackageðŸ”µ</abbr>
1052             totalRecords = getTotalRecords(countFetchRequest);
<abbr title="1053             FetchExtractionRequest fetchExtractionRequest = new FetchExtractionRequest(persistencePackage, cto, persistencePackage.getFetchTypeFullyQualifiedClassname(), mergedProperties, records);">1053             FetchExtractionRequest fetchExtractionRequest = new FetchExtractionRequest(persistencePackageðŸ”µ</abbr>
1054             payload = getRecords(fetchExtractionRequest);
1055         } catch (java.lang.Exception e) {
<abbr title="1056             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);">1056             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassnðŸ”µ</abbr>
1057         }
1058         return new DynamicResultSet(null, payload, totalRecords);
1059     }
1060 
<abbr title="1061     private void addTranslationSearchIfNeeded(CriteriaTransferObject cto, Map&lt;String, FieldMetadata&gt; mergedProperties) {">1061     private void addTranslationSearchIfNeeded(CriteriaTransferObject cto, Map&lt;String, FieldMetadata&gt; mergðŸ”µ</abbr>
1062         Map&lt;String, FilterAndSortCriteria&gt; criteriaMap = cto.getCriteriaMap();
1063         FilterAndSortCriteria fsc = criteriaMap.get(&quot;translationLocale&quot;);
1064         List&lt;String&gt; filterValues = new ArrayList&lt;&gt;();
1065         if (fsc != null) {
1066             filterValues = fsc.getFilterValues();
1067             criteriaMap.remove(&quot;translationLocale&quot;);
1068         }
1069         //If locale is generic - than we use all locales of this language
1070         //For example, if locale = &quot;en&quot; than we use also &quot;en_GB&quot; and &quot;en_US&quot;
1071         if (filterValues.size() &gt; 0 &amp;&amp; filterValues.get(0).indexOf(&quot;_&quot;) &lt; 0) {
1072             String currentLocaleCode = filterValues.get(0);
<abbr title="1073             List&lt;org.broadleafcommerce.common.locale.domain.Locale&gt; locales = localeService.findAllLocales();">1073             List&lt;org.broadleafcommerce.common.locale.domain.Locale&gt; locales = localeService.findAllLocaleðŸ”µ</abbr>
1074             for (org.broadleafcommerce.common.locale.domain.Locale locale : locales) {
<abbr title="1075                 if (!locale.getLocaleCode().equals(currentLocaleCode) &amp;&amp; currentLocaleCode.equals(locale.getLocaleCode().substring(0,2))) {">1075                 if (!locale.getLocaleCode().equals(currentLocaleCode) &amp;&amp; currentLocaleCode.equals(locale.ðŸ”µ</abbr>
1076                     filterValues.add(locale.getLocaleCode());
1077                 }
1078             }
1079         }
1080         Iterator&lt;Entry&lt;String, FilterAndSortCriteria&gt;&gt; iterator = criteriaMap.entrySet().iterator();
1081         while (iterator.hasNext()) {
1082             Entry&lt;String, FilterAndSortCriteria&gt; next = iterator.next();
1083 
1084             final String key = next.getKey();
1085             FieldMetadata fieldMetadata = mergedProperties.get(key);
<abbr title="1086             if (fieldMetadata != null &amp;&amp; fieldMetadata instanceof BasicFieldMetadata &amp;&amp; ((BasicFieldMetadata) fieldMetadata).getTranslatable()!=null &amp;&amp; ((BasicFieldMetadata) fieldMetadata).getTranslatable()) {">1086             if (fieldMetadata != null &amp;&amp; fieldMetadata instanceof BasicFieldMetadata &amp;&amp; ((BasicFieldMetadðŸ”µ</abbr>
1087                 BasicFieldMetadata basicFieldMetadata = ((BasicFieldMetadata) fieldMetadata);
1088                 if (next.getValue().getFilterValues().size() &gt; 0) {
1089                     final String value = next.getValue().getFilterValues().get(0);
1090                     final String targetClass = basicFieldMetadata.getTargetClass();
1091                     final String fieldName = basicFieldMetadata.getFieldName();
1092                     final String friendlyType = getTranslationFriendlyType(targetClass);
1093                     final List&lt;String&gt; localeValues = filterValues;
1094                     if (friendlyType != null) {
1095                         iterator.remove();
1096                         cto.getAdditionalFilterMappings().add(new FilterMapping()
1097                                 .withDirectFilterValues(new EmptyFilterValues())
1098                                 .withRestriction(
1099                                         new Restriction().withPredicateProvider(new PredicateProvider() {
1100                                             @Override
1101                                             public Predicate buildPredicate(CriteriaBuilder builder,
<abbr title="1102                                                                             FieldPathBuilder fieldPathBuilder,">1102                                                                             FieldPathBuilder fieldPathBuiðŸ”µ</abbr>
1103                                                                             From root,
1104                                                                             String ceilingEntity,
1105                                                                             String fullPropertyName,
1106                                                                             Path explicitPath,
1107                                                                             List directValues) {
1108                                                 Subquery subquery =
<abbr title="1109                                                         fieldPathBuilder.getCriteria().subquery(Long.class);">1109                                                         fieldPathBuilder.getCriteria().subquery(Long.clasðŸ”µ</abbr>
1110                                                 Root transRoot = subquery.from(TranslationImpl.class);
1111                                                 subquery.select(builder.count(transRoot.get(&quot;id&quot;)));
1112                                                 Predicate type =
<abbr title="1113                                                         builder.equal(transRoot.get(&quot;entityType&quot;), friendlyType);">1113                                                         builder.equal(transRoot.get(&quot;entityType&quot;), friendðŸ”µ</abbr>
1114                                                 Predicate name =
<abbr title="1115                                                         builder.equal(transRoot.get(&quot;fieldName&quot;), fieldName);">1115                                                         builder.equal(transRoot.get(&quot;fieldName&quot;), fieldNaðŸ”µ</abbr>
1116                                                 String[] split = key.split(&quot;\\.&quot;);
1117                                                 Path x = null;
1118                                                 for (int i = 0; i &lt; split.length; i++) {
1119                                                     if (x == null) {
1120                                                         x = root.get(split[i]);
1121                                                     } else {
1122                                                         x = x.get(split[i]);
1123                                                     }
1124                                                 }
1125 
1126                                                 String likeValue = &quot;%&quot; + value + &quot;%&quot;;
1127                                                 Predicate transValue =
<abbr title="1128                                                         builder.like(transRoot.get(&quot;translatedValue&quot;), likeValue);">1128                                                         builder.like(transRoot.get(&quot;translatedValue&quot;), liðŸ”µ</abbr>
1129                                                 Predicate localeValue =
<abbr title="1130                                                         builder.isTrue(transRoot.get(&quot;localeCode&quot;).in(localeValues));">1130                                                         builder.isTrue(transRoot.get(&quot;localeCode&quot;).in(locðŸ”µ</abbr>
<abbr title="1131                                                 Path y = split.length &gt; 1 ? root.get(split[0]).get(&quot;id&quot;) : root.get(&quot;id&quot;);">1131                                                 Path y = split.length &gt; 1 ? root.get(split[0]).get(&quot;id&quot;) ðŸ”µ</abbr>
<abbr title="1132                                                 Predicate entityId = builder.equal(transRoot.get(&quot;entityId&quot;),">1132                                                 Predicate entityId = builder.equal(transRoot.get(&quot;entityIðŸ”µ</abbr>
1133                                                         y);
1134                                                 if (localeValues.size() &gt; 0) {
<abbr title="1135                                                     subquery.where(builder.and(type, entityId, transValue, name, localeValue));">1135                                                     subquery.where(builder.and(type, entityId, transValueðŸ”µ</abbr>
1136                                                 } else {
<abbr title="1137                                                     subquery.where(builder.and(type, entityId, transValue, name));">1137                                                     subquery.where(builder.and(type, entityId, transValueðŸ”µ</abbr>
1138                                                 }
1139 
1140                                                 Predicate like = builder.like(x,
1141                                                         likeValue);
<abbr title="1142                                                 Predicate predicate = builder.or(like, builder.greaterThan(subquery, 0));">1142                                                 Predicate predicate = builder.or(like, builder.greaterThaðŸ”µ</abbr>
1143                                                 return predicate;
1144                                             }
1145                                         })));
1146                     }
1147                 }
1148                 System.out.println(&quot;&quot;);
1149             }
1150         }
1151     }
1152 
1153     private String getTranslationFriendlyType(String targetClass) {
1154 
1155         TranslatedEntity instance = TranslatedEntity.getInstance(targetClass);
1156         if (instance == null) {
1157             try {
1158                 Class&lt;?&gt;[] interfaces = Class.forName(targetClass).getInterfaces();
1159                 int i = 0;
1160                 while (instance == null &amp;&amp; i &lt; interfaces.length) {
1161                     instance = TranslatedEntity.getInstance(interfaces[i].getName());
1162                     i++;
1163                 }
1164             } catch (ClassNotFoundException e) {
1165 
1166             }
1167         }
1168 
1169         return instance == null ? null : instance.getFriendlyType();
1170     }
1171 
1172     @Override
1173     public Integer getTotalRecords(FetchRequest fetchRequest) {
1174         return fetchWrapper.getTotalRecords(fetchRequest);
1175     }
1176 
1177     @Override
1178     public Integer getTotalRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings) {
1179         try {
<abbr title="1180             return ((Long) (criteriaTranslator.translateCountQuery(persistenceManager.getDynamicEntityDao(), ceilingEntity, filterMappings).getSingleResult())).intValue();">1180             return ((Long) (criteriaTranslator.translateCountQuery(persistenceManager.getDynamicEntityDaoðŸ”µ</abbr>
1181         } catch (CriteriaConversionException e) {
<abbr title="1182             TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntity);">1182             TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilðŸ”µ</abbr>
<abbr title="1183             return ((Long) (builder.toCountQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManager()).getSingleResult())).intValue();">1183             return ((Long) (builder.toCountQuery(getPersistenceManager().getDynamicEntityDao().getStandarðŸ”µ</abbr>
1184         }
1185     }
1186 
1187     @Override
<abbr title="1188     public Serializable getMaxValue(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, String maxField) {">1188     public Serializable getMaxValue(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, String maxFðŸ”µ</abbr>
<abbr title="1189         return criteriaTranslator.translateMaxQuery(persistenceManager.getDynamicEntityDao(), ceilingEntity, filterMappings, maxField).getSingleResult();">1189         return criteriaTranslator.translateMaxQuery(persistenceManager.getDynamicEntityDao(), ceilingEntiðŸ”µ</abbr>
1190     }
1191 
1192     @Override
1193     public List&lt;Serializable&gt; getPersistentRecords(FetchRequest fetchRequest) {
1194         return fetchWrapper.getPersistentRecords(fetchRequest);
1195     }
1196 
1197     @Override
<abbr title="1198     public List&lt;Serializable&gt; getPersistentRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, Integer firstResult, Integer maxResults) {">1198     public List&lt;Serializable&gt; getPersistentRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappinðŸ”µ</abbr>
1199         try {
<abbr title="1200             return criteriaTranslator.translateQuery(persistenceManager.getDynamicEntityDao(), ceilingEntity, filterMappings, firstResult, maxResults).getResultList();">1200             return criteriaTranslator.translateQuery(persistenceManager.getDynamicEntityDao(), ceilingEntðŸ”µ</abbr>
1201         } catch (CriteriaConversionException e) {
<abbr title="1202             TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntity);">1202             TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilðŸ”µ</abbr>
<abbr title="1203             return builder.toQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManager()).getResultList();">1203             return builder.toQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManagerðŸ”µ</abbr>
1204         }
1205     }
1206 
1207     @Override
<abbr title="1208     public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperties) {">1208     public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; merðŸ”µ</abbr>
1209         return validate(entity, populatedInstance, mergedProperties, true);
1210     }
1211 
1212     @Override
<abbr title="1213     public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperties, boolean validateUnsubmittedProperties) {">1213     public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; merðŸ”µ</abbr>
<abbr title="1214         entityValidatorService.validate(entity, populatedInstance, mergedProperties, this, validateUnsubmittedProperties);">1214         entityValidatorService.validate(entity, populatedInstance, mergedProperties, this, validateUnsubmðŸ”µ</abbr>
1215         return !entity.isValidationFailure();
1216     }
1217 
1218     @Override
1219     public void setPersistenceManager(PersistenceManager persistenceManager) {
1220         this.persistenceManager = persistenceManager;
1221     }
1222 
1223     @Override
1224     public PersistenceModule getCompatibleModule(OperationType operationType) {
1225         return ((InspectHelper) (persistenceManager)).getCompatibleModule(operationType);
1226     }
1227 
1228     public FieldPersistenceProvider getDefaultFieldPersistenceProvider() {
1229         return defaultFieldPersistenceProvider;
1230     }
1231 
<abbr title="1232     public void setDefaultFieldPersistenceProvider(FieldPersistenceProvider defaultFieldPersistenceProvider) {">1232     public void setDefaultFieldPersistenceProvider(FieldPersistenceProvider defaultFieldPersistenceProvidðŸ”µ</abbr>
1233         this.defaultFieldPersistenceProvider = defaultFieldPersistenceProvider;
1234     }
1235 
1236     public List&lt;FieldPersistenceProvider&gt; getFieldPersistenceProviders() {
1237         return fieldPersistenceProviders;
1238     }
1239 
1240     public void setFieldPersistenceProviders(List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders) {
1241         this.fieldPersistenceProviders = fieldPersistenceProviders;
1242     }
1243 
1244     public CriteriaTranslator getCriteriaTranslator() {
1245         return criteriaTranslator;
1246     }
1247 
1248     public void setCriteriaTranslator(CriteriaTranslator criteriaTranslator) {
1249         this.criteriaTranslator = criteriaTranslator;
1250     }
1251 
1252     public EntityValidatorService getEntityValidatorService() {
1253         return entityValidatorService;
1254     }
1255 
1256     public void setEntityValidatorService(EntityValidatorService entityValidatorService) {
1257         this.entityValidatorService = entityValidatorService;
1258     }
1259 
1260     public RestrictionFactory getRestrictionFactory() {
1261         return restrictionFactory;
1262     }
1263 
1264     public void setRestrictionFactory(RestrictionFactory restrictionFactory) {
1265         this.restrictionFactory = restrictionFactory;
1266     }
1267 
1268     public PersistenceManager getPersistenceManager() {
1269         return persistenceManager;
1270     }
1271 
1272     /**
<abbr title="1273      * Use an alternate approach to generating a fetch query for a collection located inside of an @Embeddable object. Related">1273      * Use an alternate approach to generating a fetch query for a collection located inside of an @EmbedðŸ”µ</abbr>
<abbr title="1274      * to https://hibernate.atlassian.net/browse/HHH-8802. The alternate approach leverages HQL rather than JPA criteria,">1274      * to https://hibernate.atlassian.net/browse/HHH-8802. The alternate approach leverages HQL rather thðŸ”µ</abbr>
1275      * which seems to alleviate the problem.
1276      *
1277      * @param embeddedCollectionPath the path to the collection field itself
1278      * @param filterMappings all the fetch restrictions for this request
1279      * @param collectionClass the type of the collection members
1280      * @return the builder capable of generating an appropriate HQL query
1281      */
<abbr title="1282     protected TypedQueryBuilder getSpecialCaseQueryBuilder(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; filterMappings, String collectionClass) {">1282     protected TypedQueryBuilder getSpecialCaseQueryBuilder(FieldPath embeddedCollectionPath, List&lt;FilterMðŸ”µ</abbr>
1283         String specialPath = embeddedCollectionPath.getTargetProperty();
1284         String[] pieces = specialPath.split(&quot;\\.&quot;);
1285         if (pieces.length != 3) {
<abbr title="1286             throw new CriteriaConversionException(String.format(&quot;Expected to find a target property of format [embedded field].[collection field].[property] for the embedded collection path (%s)&quot;, specialPath), embeddedCollectionPath);">1286             throw new CriteriaConversionException(String.format(&quot;Expected to find a target property of foðŸ”µ</abbr>
1287         }
1288         String expression = specialPath.substring(0, specialPath.lastIndexOf(&quot;.&quot;));
1289         TypedQueryBuilder builder;
1290         try {
<abbr title="1291             builder = new TypedQueryBuilder(Class.forName(collectionClass), &quot;specialEntity&quot;).addJoin(new TQJoin(&quot;specialEntity.&quot; + expression, &quot;embeddedCollection&quot;));">1291             builder = new TypedQueryBuilder(Class.forName(collectionClass), &quot;specialEntity&quot;).addJoin(new ðŸ”µ</abbr>
1292         } catch (java.lang.Exception e) {
1293             throw ExceptionHelper.refineException(e);
1294         }
1295         for (TQRestriction restriction : buildSpecialRestrictions(expression, filterMappings)) {
1296             builder = builder.addRestriction(restriction);
1297         }
<abbr title="1298         for (TQRestriction restriction : buildStandardRestrictions(embeddedCollectionPath, filterMappings)) {">1298         for (TQRestriction restriction : buildStandardRestrictions(embeddedCollectionPath, filterMappingsðŸ”µ</abbr>
1299             builder = builder.addRestriction(restriction);
1300         }
1301         for (FilterMapping mapping : filterMappings) {
1302             if (mapping.getSortDirection() != null) {
<abbr title="1303                 String mappingProperty = (mapping.getFieldPath() == null) ? null : mapping.getFieldPath().getTargetProperty();">1303                 String mappingProperty = (mapping.getFieldPath() == null) ? null : mapping.getFieldPath()ðŸ”µ</abbr>
1304                 if (StringUtils.isEmpty(mappingProperty)) {
1305                     mappingProperty = mapping.getFullPropertyName();
1306                 }
<abbr title="1307                 builder = builder.addOrder(new TQOrder(&quot;specialEntity.&quot; + mappingProperty, SortDirection.ASCENDING == mapping.getSortDirection()));">1307                 builder = builder.addOrder(new TQOrder(&quot;specialEntity.&quot; + mappingProperty, SortDirection.ðŸ”µ</abbr>
1308             }
1309         }
1310         return builder;
1311     }
1312 
1313     /**
<abbr title="1314      * Generate LIKE or EQUALS restrictions for any filter property specified on the root entity (not the collection field in the @Embeddable object)">1314      * Generate LIKE or EQUALS restrictions for any filter property specified on the root entity (not theðŸ”µ</abbr>
1315      *
<abbr title="1316      * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath, java.util.List, String)">1316      * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.moduleðŸ”µ</abbr>
<abbr title="1317      * @param embeddedCollectionPath the path for the collection field in the @Embeddable object - this is what caused the whole thing">1317      * @param embeddedCollectionPath the path for the collection field in the @Embeddable object - this iðŸ”µ</abbr>
1318      * @param filterMappings all the fetch restrictions for this request
1319      * @return the list of restrictions on the root entity
1320      */
<abbr title="1321     protected List&lt;TQRestriction&gt; buildStandardRestrictions(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; filterMappings) {">1321     protected List&lt;TQRestriction&gt; buildStandardRestrictions(FieldPath embeddedCollectionPath, List&lt;FilterðŸ”µ</abbr>
<abbr title="1322         String expression = embeddedCollectionPath.getTargetProperty().substring(0, embeddedCollectionPath.getTargetProperty().lastIndexOf(&quot;.&quot;));">1322         String expression = embeddedCollectionPath.getTargetProperty().substring(0, embeddedCollectionPatðŸ”µ</abbr>
1323         List&lt;TQRestriction&gt; restrictions = new ArrayList&lt;TQRestriction&gt;();
1324         for (FilterMapping mapping : filterMappings) {
1325             checkProperty : {
<abbr title="1326                 String mappingProperty = (mapping.getFieldPath() == null) ? null : mapping.getFieldPath().getTargetProperty();">1326                 String mappingProperty = (mapping.getFieldPath() == null) ? null : mapping.getFieldPath()ðŸ”µ</abbr>
1327                 if (StringUtils.isEmpty(mappingProperty)) {
1328                     mappingProperty = mapping.getFullPropertyName();
1329                 }
<abbr title="1330                 if ((!embeddedCollectionPath.getTargetProperty().equals(mappingProperty)) &amp;&amp; (!StringUtils.isEmpty(mappingProperty))) {">1330                 if ((!embeddedCollectionPath.getTargetProperty().equals(mappingProperty)) &amp;&amp; (!StringUtilðŸ”µ</abbr>
<abbr title="1331                     PredicateProvider predicateProvider = mapping.getRestriction().getPredicateProvider();">1331                     PredicateProvider predicateProvider = mapping.getRestriction().getPredicateProvider()ðŸ”µ</abbr>
1332                     if (predicateProvider != null) {
<abbr title="1333                         FilterValueConverter converter = mapping.getRestriction().getFilterValueConverter();">1333                         FilterValueConverter converter = mapping.getRestriction().getFilterValueConverterðŸ”µ</abbr>
<abbr title="1334                         if ((converter != null) &amp;&amp; CollectionUtils.isNotEmpty(mapping.getFilterValues())) {">1334                         if ((converter != null) &amp;&amp; CollectionUtils.isNotEmpty(mapping.getFilterValues()))ðŸ”µ</abbr>
1335                             Object val = converter.convert(mapping.getFilterValues().get(0));
1336                             if (predicateProvider instanceof LikePredicateProvider) {
<abbr title="1337                                 restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;LIKE&quot;, val + &quot;%&quot;));">1337                                 restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;LðŸ”µ</abbr>
1338                                 break checkProperty;
1339                             } else if (predicateProvider instanceof EqPredicateProvider) {
<abbr title="1340                                 restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;=&quot;, val));">1340                                 restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;=ðŸ”µ</abbr>
1341                                 break checkProperty;
1342                             }
1343                         }
1344                     }
<abbr title="1345                     LOG.warn(String.format(&quot;Unable to filter the embedded collection (%s) on an additional property (%s)&quot;, StringUtil.sanitize(expression), StringUtil.sanitize(mappingProperty)));">1345                     LOG.warn(String.format(&quot;Unable to filter the embedded collection (%s) on an additionaðŸ”µ</abbr>
1346                 }
1347             }
1348         }
1349         return restrictions;
1350     }
1351 
1352     /**
<abbr title="1353      * Generate EQUALS restrictions for any filter property specified on the entity member of the collection field in the @Embeddable object">1353      * Generate EQUALS restrictions for any filter property specified on the entity member of the collectðŸ”µ</abbr>
1354      *
<abbr title="1355      * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath, java.util.List, String)">1355      * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.moduleðŸ”µ</abbr>
<abbr title="1356      * @param specialExpression the String representation of the path for the collection field in the @Embeddable object">1356      * @param specialExpression the String representation of the path for the collection field in the @EmðŸ”µ</abbr>
1357      * @param filterMappings all the fetch restrictions for this request
1358      * @return the list of restrictions on the collection in the @Embeddable object
1359      */
<abbr title="1360     protected List&lt;TQRestriction&gt; buildSpecialRestrictions(String specialExpression, List&lt;FilterMapping&gt; filterMappings) {">1360     protected List&lt;TQRestriction&gt; buildSpecialRestrictions(String specialExpression, List&lt;FilterMapping&gt; ðŸ”µ</abbr>
1361         List&lt;TQRestriction&gt; restrictions = new ArrayList&lt;TQRestriction&gt;();
1362         for (FilterMapping mapping : filterMappings) {
<abbr title="1363             if (((mapping.getFieldPath() != null) &amp;&amp; (mapping.getFieldPath().getTargetProperty() != null)) &amp;&amp; mapping.getFieldPath().getTargetProperty().startsWith(specialExpression)) {">1363             if (((mapping.getFieldPath() != null) &amp;&amp; (mapping.getFieldPath().getTargetProperty() != null)ðŸ”µ</abbr>
1364                 FilterValueConverter converter = mapping.getRestriction().getFilterValueConverter();
1365                 if ((converter != null) &amp;&amp; CollectionUtils.isNotEmpty(mapping.getFilterValues())) {
1366                     Object val = converter.convert(mapping.getFilterValues().get(0));
<abbr title="1367                     String property = mapping.getFieldPath().getTargetProperty().substring(mapping.getFieldPath().getTargetProperty().lastIndexOf(&quot;.&quot;) + 1, mapping.getFieldPath().getTargetProperty().length());">1367                     String property = mapping.getFieldPath().getTargetProperty().substring(mapping.getFieðŸ”µ</abbr>
1368                     restrictions.add(new TQRestriction(&quot;embeddedCollection.&quot; + property, &quot;=&quot;, val));
1369                 }
1370             }
1371         }
1372         return restrictions;
1373     }
1374 
1375     protected void cleanupFailedPersistenceAttempt(Serializable instance) throws IllegalAccessException {
1376         //Remove the entity from ORM management - no further attempts to persist
<abbr title="1377         if (getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().contains(instance)) {">1377         if (getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().contains(instance)) ðŸ”µ</abbr>
1378             getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().detach(instance);
1379         }
1380         //Remove the id field value, if it&#x27;s set
<abbr title="1381         String idFieldName = (String) getPersistenceManager().getDynamicEntityDao().getIdMetadata(instance.getClass()).get(&quot;name&quot;);">1381         String idFieldName = (String) getPersistenceManager().getDynamicEntityDao().getIdMetadata(instancðŸ”µ</abbr>
1382         Field idField = FieldUtils.getField(instance.getClass(), idFieldName, true);
1383         if (idField == null) {
<abbr title="1384             throw ExceptionHelper.refineException(new NoSuchFieldException(&quot;Entity &quot; + instance.getClass().getName() + &quot; does not contain id field &quot; + idFieldName));">1384             throw ExceptionHelper.refineException(new NoSuchFieldException(&quot;Entity &quot; + instance.getClass(ðŸ”µ</abbr>
1385         }
1386         idField.setAccessible(true);
1387         if (idField.get(instance) != null) {
1388             idField.set(instance, null);
1389         }
1390     }
1391 
<abbr title="1392     protected Class&lt;?&gt; getMapFieldType(Serializable instance, FieldManager fieldManager, Property property) {">1392     protected Class&lt;?&gt; getMapFieldType(Serializable instance, FieldManager fieldManager, Property propertðŸ”µ</abbr>
1393         Class&lt;?&gt; returnType = null;
<abbr title="1394         Field field = fieldManager.getField(instance.getClass(), property.getName().substring(0, property.getName().indexOf(FieldManager.MAPFIELDSEPARATOR)));">1394         Field field = fieldManager.getField(instance.getClass(), property.getName().substring(0, propertyðŸ”µ</abbr>
1395         java.lang.reflect.Type type = field.getGenericType();
1396         if (type instanceof ParameterizedType) {
1397             ParameterizedType pType = ((ParameterizedType) (type));
1398             Class&lt;?&gt; clazz;
1399             if (pType.getActualTypeArguments().length &lt; 2) {
1400                 clazz = ((Class&lt;?&gt;) (pType.getActualTypeArguments()[0]));
1401             } else {
1402                 clazz = ((Class&lt;?&gt;) (pType.getActualTypeArguments()[1]));
1403             }
<abbr title="1404             Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(clazz);">1404             Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCðŸ”µ</abbr>
1405             if (!ArrayUtils.isEmpty(entities)) {
1406                 returnType = entities[entities.length - 1];
1407             }
1408         }
1409         return returnType;
1410     }
1411 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * #%L
   3   * BroadleafCommerce Open Admin Platform
   4   * %%
   5   * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6   * %%
   7   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10   * the Broadleaf End User License Agreement (EULA), Version 1.1
  11   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12   * shall apply.
  13   *
<abbr title="  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  15   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  16   * #L%
  17   */
  18  
  19  package org.broadleafcommerce.openadmin.server.service.persistence.module;
  20  
  21  import org.apache.commons.beanutils.PropertyUtils;
  22  import org.apache.commons.collections.CollectionUtils;
  23  import org.apache.commons.lang.ArrayUtils;
  24  import org.apache.commons.lang.StringUtils;
  25  import org.apache.commons.lang3.BooleanUtils;
  26  import org.apache.commons.lang3.reflect.FieldUtils;
  27  import org.apache.commons.lang3.reflect.MethodUtils;
  28  import org.apache.commons.logging.Log;
  29  import org.apache.commons.logging.LogFactory;
  30  import org.broadleafcommerce.common.admin.domain.AdminMainEntity;
  31  import org.broadleafcommerce.common.exception.ExceptionHelper;
  32  import org.broadleafcommerce.common.exception.SecurityServiceException;
  33  import org.broadleafcommerce.common.exception.ServiceException;
  34  import org.broadleafcommerce.common.extension.ExtensionResultHolder;



  35  import org.broadleafcommerce.common.money.Money;
  36  import org.broadleafcommerce.common.presentation.client.OperationType;
  37  import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  38  import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  39  import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  40  import org.broadleafcommerce.common.util.FormatUtil;
  41  import org.broadleafcommerce.common.util.StringUtil;
  42  import org.broadleafcommerce.common.util.ValidationUtil;
  43  import org.broadleafcommerce.common.util.dao.TQJoin;
  44  import org.broadleafcommerce.common.util.dao.TQOrder;
  45  import org.broadleafcommerce.common.util.dao.TQRestriction;
  46  import org.broadleafcommerce.common.util.dao.TypedQueryBuilder;
  47  import org.broadleafcommerce.common.web.BroadleafRequestContext;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  48 -import org.broadleafcommerce.openadmin.dto.BasicFieldMetadata;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  49 -import org.broadleafcommerce.openadmin.dto.CriteriaTransferObject;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  50 -import org.broadleafcommerce.openadmin.dto.DynamicResultSet;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  51 -import org.broadleafcommerce.openadmin.dto.Entity;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  52 -import org.broadleafcommerce.openadmin.dto.EntityResult;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  53 -import org.broadleafcommerce.openadmin.dto.FieldMetadata;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  54 -import org.broadleafcommerce.openadmin.dto.FilterAndSortCriteria;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  55 -import org.broadleafcommerce.openadmin.dto.ForeignKey;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  56 -import org.broadleafcommerce.openadmin.dto.MergedPropertyType;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  57 -import org.broadleafcommerce.openadmin.dto.PersistencePackage;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  58 -import org.broadleafcommerce.openadmin.dto.PersistencePerspective;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  59 -import org.broadleafcommerce.openadmin.dto.Property;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  60 -import org.broadleafcommerce.openadmin.dto.SortDirection;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  61 +import org.broadleafcommerce.openadmin.dto.*;</span>
  62  import org.broadleafcommerce.openadmin.server.dao.provider.metadata.AdvancedCollectionFieldMetadataProvider;
  63  import org.broadleafcommerce.openadmin.server.service.ValidationException;
  64  import org.broadleafcommerce.openadmin.server.service.persistence.ParentEntityPersistenceException;
  65  import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceException;
  66  import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceManager;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  67 -import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.CriteriaConversionException;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  68 -import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.CriteriaTranslator;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  69 -import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath;</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  70 -import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FilterMapping;</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  71 -import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.RestrictionFactory;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  72 +import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.*;</span>
  73  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.converter.FilterValueConverter;
  74  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.EqPredicateProvider;
  75  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.LikePredicateProvider;
  76  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvider;
<abbr title="  77  import org.broadleafcommerce.openadmin.server.service.persistence.module.extension.BasicPersistenceModuleExtensionManager;">  77  import org.broadleafcommerce.openadmin.server.service.persistence.module.extension.BasicPersistenceModuleExtensionðŸ”µ</abbr>
  78  import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.FieldPersistenceProvider;
<abbr title="  79  import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddFilterPropertiesRequest;">  79  import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddFilterPropertiesRequeðŸ”µ</abbr>
  80  import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddSearchMappingRequest;
  81  import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.ExtractValueRequest;
  82  import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.PopulateValueRequest;
  83  import org.broadleafcommerce.openadmin.server.service.persistence.validation.EntityValidatorService;
  84  import org.broadleafcommerce.openadmin.server.service.persistence.validation.PopulateValueRequestValidator;
  85  import org.broadleafcommerce.openadmin.server.service.persistence.validation.PropertyValidationResult;
  86  import org.broadleafcommerce.openadmin.server.service.type.MetadataProviderResponse;
  87  import org.hibernate.FlushMode;
  88  import org.hibernate.Session;
  89  import org.springframework.beans.BeansException;

  90  import org.springframework.context.ApplicationContext;
  91  import org.springframework.context.ApplicationContextAware;
  92  import org.springframework.context.annotation.Primary;
  93  import org.springframework.context.annotation.Scope;
  94  import org.springframework.stereotype.Component;
  95  import org.springframework.util.Assert;
  96  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  97 +import javax.annotation.PostConstruct;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  98 +import javax.annotation.Resource;</span>
  99  import java.io.Serializable;
 100  import java.lang.reflect.Field;
 101  import java.lang.reflect.InvocationTargetException;
 102  import java.lang.reflect.Method;
 103  import java.lang.reflect.ParameterizedType;
 104  import java.math.BigDecimal;
 105  import java.sql.Timestamp;
 106  import java.text.DecimalFormat;
 107  import java.text.NumberFormat;
 108  import java.text.SimpleDateFormat;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 109 -import java.util.ArrayList;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 110 -import java.util.Arrays;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 111 -import java.util.Calendar;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 112 -import java.util.Collection;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 113 -import java.util.Collections;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 114 -import java.util.Comparator;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 115 -import java.util.Date;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 116 -import java.util.HashMap;</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 117 -import java.util.List;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 118 -import java.util.Locale;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 119 -import java.util.Map;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 120 +import java.util.*;</span>
 121  import java.util.Map.Entry;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 122 -import java.util.StringTokenizer;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 123 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 124 -import javax.annotation.PostConstruct;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 125 -import javax.annotation.Resource;</span>






 126  
 127  /**
 128   * @author jfischer
 129   */
 130  @Primary
 131  @Component(&quot;blBasicPersistenceModule&quot;)
 132  @Scope(&quot;prototype&quot;)
 133  public class BasicPersistenceModule implements PersistenceModule, RecordHelper, ApplicationContextAware {
 134  
 135      private static final Log LOG = LogFactory.getLog(BasicPersistenceModule.class);
 136  
 137      public static final String MAIN_ENTITY_NAME_PROPERTY = &quot;MAIN_ENTITY_NAME&quot;;
 138      public static final String ALTERNATE_ID_PROPERTY = &quot;ALTERNATE_ID&quot;;
 139  
 140      protected ApplicationContext applicationContext;
 141      protected PersistenceManager persistenceManager;
 142  
 143      @Resource(name = &quot;blEntityValidatorService&quot;)
 144      protected EntityValidatorService entityValidatorService;
 145  
 146      @Resource(name = &quot;blPersistenceProviders&quot;)
<abbr title=" 147      protected List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders = new ArrayList&lt;FieldPersistenceProvider&gt;();"> 147      protected List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders = new ArrayList&lt;FieldPersistenceProvider&gt;()ðŸ”µ</abbr>
 148  
 149      @Resource(name = &quot;blPopulateValueRequestValidators&quot;)
 150      protected List&lt;PopulateValueRequestValidator&gt; populateValidators;
 151  
 152      @Resource(name = &quot;blDefaultFieldPersistenceProvider&quot;)
 153      protected FieldPersistenceProvider defaultFieldPersistenceProvider;
 154  
 155      @Resource(name = &quot;blCriteriaTranslator&quot;)
 156      protected CriteriaTranslator criteriaTranslator;
 157  
 158      @Resource(name = &quot;blRestrictionFactory&quot;)
 159      protected RestrictionFactory restrictionFactory;
 160  
 161      @Resource(name = &quot;blBasicPersistenceModuleExtensionManager&quot;)
 162      protected BasicPersistenceModuleExtensionManager extensionManager;
 163  
 164      @Resource(name = &quot;blFetchWrapper&quot;)
 165      protected FetchWrapper fetchWrapper;






 166  
 167      @PostConstruct
 168      public void init() {
 169          Collections.sort(fieldPersistenceProviders, new Comparator&lt;FieldPersistenceProvider&gt;() {
 170  
 171              @Override
 172              public int compare(FieldPersistenceProvider o1, FieldPersistenceProvider o2) {
 173                  return Integer.compare(o1.getOrder(), o2.getOrder());
 174              }
 175          });
 176          Collections.sort(populateValidators, new Comparator&lt;PopulateValueRequestValidator&gt;() {
 177  
 178              @Override
 179              public int compare(PopulateValueRequestValidator o1, PopulateValueRequestValidator o2) {
 180                  return Integer.compare(o1.getOrder(), o2.getOrder());
 181              }
 182          });
 183      }
 184  
 185      @Override
 186      public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
 187          this.applicationContext = applicationContext;
 188      }
 189  
 190      @Override
 191      public boolean isCompatible(OperationType operationType) {
 192          return OperationType.BASIC == operationType || OperationType.NONDESTRUCTIVEREMOVE == operationType;
 193      }
 194  
 195      @Override
 196      public FieldManager getFieldManager() {
 197          return persistenceManager.getDynamicEntityDao().getFieldManager();
 198      }
 199  
 200      @Override
 201      public FieldManager getFieldManager(boolean cleanFieldManger) {
 202          return persistenceManager.getDynamicEntityDao().getFieldManager(cleanFieldManger);
 203      }
 204  
 205      @Override
 206      public DecimalFormat getDecimalFormatter() {
 207          BroadleafRequestContext brc = BroadleafRequestContext.getBroadleafRequestContext();
 208          Locale locale = brc.getJavaLocale();
 209          DecimalFormat format = (DecimalFormat) NumberFormat.getInstance(locale);
 210          format.applyPattern(&quot;0.########&quot;);
 211          format.setGroupingUsed(false);
 212          return format;
 213      }
 214  
 215      @Override
 216      public SimpleDateFormat getSimpleDateFormatter() {
 217          return FormatUtil.getDateFormat();
 218      }
 219  
 220      protected Map&lt;String, FieldMetadata&gt; filterOutCollectionMetadata(Map&lt;String, FieldMetadata&gt; metadata) {
 221          if (metadata == null) {
 222              return null;
 223          }
 224          Map&lt;String, FieldMetadata&gt; newMap = new HashMap&lt;String, FieldMetadata&gt;();
 225          for (Map.Entry&lt;String, FieldMetadata&gt; entry : metadata.entrySet()) {
 226              String fieldName = entry.getKey();
 227              FieldMetadata md = entry.getValue();
<abbr title=" 228              // Detect instances where the actual metadata for the field is some sort of CollectionMetadata but also corresponds"> 228              // Detect instances where the actual metadata for the field is some sort of CollectionMetadata but alsðŸ”µ</abbr>
<abbr title=" 229              // to a ForeignKey and ensure that gets included in the filtered map. That way the {@link BasicPersistenceModule}"> 229              // to a ForeignKey and ensure that gets included in the filtered map. That way the {@link BasicPersistðŸ”µ</abbr>
 230              // can appropriate handle filtration and population
 231              if (entry.getValue() instanceof BasicFieldMetadata) {
 232                  newMap.put(fieldName, md);
<abbr title=" 233              } else if (md.getAdditionalMetadata().containsKey(AdvancedCollectionFieldMetadataProvider.FOREIGN_KEY_ADDITIONAL_METADATA_KEY)) {"> 233              } else if (md.getAdditionalMetadata().containsKey(AdvancedCollectionFieldMetadataProvider.FOREIGN_KEY_ðŸ”µ</abbr>
 234                  newMap.put(fieldName,
<abbr title=" 235                          (BasicFieldMetadata) md.getAdditionalMetadata().get(AdvancedCollectionFieldMetadataProvider.FOREIGN_KEY_ADDITIONAL_METADATA_KEY));"> 235                          (BasicFieldMetadata) md.getAdditionalMetadata().get(AdvancedCollectionFieldMetadataProvideðŸ”µ</abbr>
 236              }
 237          }
 238  
 239          return newMap;
 240      }
 241  
 242      protected Class&lt;?&gt; getBasicBroadleafType(SupportedFieldType fieldType) {
 243          Class&lt;?&gt; response;
 244          switch (fieldType) {
 245              case BOOLEAN:
 246                  response = Boolean.TYPE;
 247                  break;
 248              case DATE:
 249                  response = Date.class;
 250                  break;
 251              case DECIMAL:
 252                  response = BigDecimal.class;
 253                  break;
 254              case MONEY:
 255                  response = Money.class;
 256                  break;
 257              case INTEGER:
 258                  response = Integer.TYPE;
 259                  break;
 260              case UNKNOWN:
 261                  response = null;
 262                  break;
 263              default:
 264                  response = String.class;
 265                  break;
 266          }
 267  
 268          return response;
 269      }
 270  
 271      @Override
 272      public Serializable createPopulatedInstance(Serializable instance, Entity entity,
 273              Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId) throws ValidationException {
 274          return createPopulatedInstance(instance, entity, unfilteredProperties, setId, true);
 275      }
 276  
 277      @Override
 278      public Serializable createPopulatedInstance(Serializable instance, Entity entity,
<abbr title=" 279              Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId, Boolean validateUnsubmittedProperties) throws ValidationException {"> 279              Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId, Boolean validateUnsubmittedProperties)ðŸ”µ</abbr>
 280          final Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(unfilteredProperties);
 281          FieldManager fieldManager = getFieldManager();
 282          boolean handled = false;
 283          for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {
<abbr title=" 284              MetadataProviderResponse response = fieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfilteredProperties);"> 284              MetadataProviderResponse response = fieldPersistenceProvider.filterProperties(new AddFilterPropertiesRðŸ”µ</abbr>
 285              if (MetadataProviderResponse.NOT_HANDLED != response) {
 286                  handled = true;
 287              }
 288              if (MetadataProviderResponse.HANDLED_BREAK == response) {
 289                  break;
 290              }
 291          }
 292          if (!handled) {
<abbr title=" 293              defaultFieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfilteredProperties);"> 293              defaultFieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfilteredProðŸ”µ</abbr>
 294          }
<abbr title=" 295          //Order media field, map field and rule builder fields last, as they will have some validation components that depend on previous values"> 295          //Order media field, map field and rule builder fields last, as they will have some validation components ðŸ”µ</abbr>
 296          Property[] sortedProperties = entity.getProperties();
 297          Arrays.sort(sortedProperties, new Comparator&lt;Property&gt;() {
 298  
 299              @Override
 300              public int compare(Property o1, Property o2) {
 301                  BasicFieldMetadata mo1 = (BasicFieldMetadata) mergedProperties.get(o1.getName());
 302                  BasicFieldMetadata mo2 = (BasicFieldMetadata) mergedProperties.get(o2.getName());
<abbr title=" 303                  boolean isLate1 = mo1 != null &amp;&amp; mo1.getFieldType() != null &amp;&amp; mo1.getName() != null &amp;&amp; (SupportedFieldType.RULE_SIMPLE==mo1.getFieldType() ||"> 303                  boolean isLate1 = mo1 != null &amp;&amp; mo1.getFieldType() != null &amp;&amp; mo1.getName() != null &amp;&amp; (SupportedðŸ”µ</abbr>
 304                          SupportedFieldType.RULE_WITH_QUANTITY==mo1.getFieldType() ||
 305                          SupportedFieldType.RULE_SIMPLE_TIME==mo1.getFieldType() ||
<abbr title=" 306                          SupportedFieldType.MEDIA==mo1.getFieldType() || o1.getName().contains(FieldManager.MAPFIELDSEPARATOR));"> 306                          SupportedFieldType.MEDIA==mo1.getFieldType() || o1.getName().contains(FieldManager.MAPFIELðŸ”µ</abbr>
<abbr title=" 307                  boolean isLate2 = mo2 != null &amp;&amp; mo2.getFieldType() != null &amp;&amp; mo2.getName() != null &amp;&amp; (SupportedFieldType.RULE_SIMPLE==mo2.getFieldType() ||"> 307                  boolean isLate2 = mo2 != null &amp;&amp; mo2.getFieldType() != null &amp;&amp; mo2.getName() != null &amp;&amp; (SupportedðŸ”µ</abbr>
 308                          SupportedFieldType.RULE_WITH_QUANTITY==mo2.getFieldType() ||
 309                          SupportedFieldType.RULE_SIMPLE_TIME==mo2.getFieldType() ||
<abbr title=" 310                          SupportedFieldType.MEDIA==mo2.getFieldType() || o2.getName().contains(FieldManager.MAPFIELDSEPARATOR));"> 310                          SupportedFieldType.MEDIA==mo2.getFieldType() || o2.getName().contains(FieldManager.MAPFIELðŸ”µ</abbr>
 311                  if (isLate1 &amp;&amp; !isLate2) {
 312                      return 1;
 313                  } else if (!isLate1 &amp;&amp; isLate2) {
 314                      return -1;
 315                  }
 316                  return 0;
 317              }
 318          });
<abbr title=" 319          Session session = getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().unwrap(Session.class);"> 319          Session session = getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().unwrap(Session.ðŸ”µ</abbr>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 320 -        FlushMode originalFlushMode = session.getFlushMode();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 321 +        FlushMode originalFlushMode = session.getHibernateFlushMode();</span>
 322          try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 323 -            session.setFlushMode(FlushMode.MANUAL);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 324 +            session.setHibernateFlushMode(FlushMode.MANUAL);</span>
 325              RuntimeException entityPersistenceException = null;
 326              for (Property property : sortedProperties) {
 327                  BasicFieldMetadata metadata = (BasicFieldMetadata) mergedProperties.get(property.getName());
 328                  Class&lt;?&gt; returnType;
<abbr title=" 329                  if (!property.getName().contains(FieldManager.MAPFIELDSEPARATOR) &amp;&amp; !property.getName().startsWith(&quot;__&quot;)) {"> 329                  if (!property.getName().contains(FieldManager.MAPFIELDSEPARATOR) &amp;&amp; !property.getName().startsWithðŸ”µ</abbr>
 330                      Field field = fieldManager.getField(instance.getClass(), property.getName());
 331                      if (field == null) {
<abbr title=" 332                          LOG.debug(&quot;Unable to find a bean property for the reported property: &quot; + StringUtil.sanitize(property.getName()) + &quot;. Ignoring property.&quot;);"> 332                          LOG.debug(&quot;Unable to find a bean property for the reported property: &quot; + StringUtil.sanitiðŸ”µ</abbr>
 333                          continue;
 334                      }
 335                      returnType = field.getType();
 336                  } else {
 337                      if (metadata == null) {
<abbr title=" 338                          LOG.debug(&quot;Unable to find a metadata property for the reported property: &quot; + StringUtil.sanitize(property.getName()) + &quot;. Ignoring property.&quot;);"> 338                          LOG.debug(&quot;Unable to find a metadata property for the reported property: &quot; + StringUtil.saðŸ”µ</abbr>
 339                          continue;
 340                      }
 341                      returnType = getMapFieldType(instance, fieldManager, property);
 342                      if (returnType == null) {
 343                          returnType = getBasicBroadleafType(metadata.getFieldType());
 344                      }
 345                  }
 346                  if (returnType == null) {
<abbr title=" 347                      throw new IllegalAccessException(&quot;Unable to determine the value type for the property (&quot; + property.getName() + &quot;)&quot;);"> 347                      throw new IllegalAccessException(&quot;Unable to determine the value type for the property (&quot; + proðŸ”µ</abbr>
 348                  }
 349                  String value = property.getValue();
 350                  if (metadata != null) {
 351  
 352                      if (metadata.getFieldType().equals(SupportedFieldType.BOOLEAN)) {
 353                          if (value == null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 354 -                            value = &quot;false&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 355 +                            String defaultValue = metadata.getDefaultValue();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 356 +                            value = StringUtils.isBlank(defaultValue)? &quot;false&quot; : defaultValue;</span>
 357                          }
 358                      } else if (metadata.getFieldType().equals(SupportedFieldType.DATE)) {
 359                          if (StringUtils.isEmpty(value)) {
 360                              value = null;
 361                          }
 362                      }
 363  
<abbr title=" 364                      if (attemptToPopulateValue(property, fieldManager, instance, setId, metadata, entity, value)) {"> 364                      if (attemptToPopulateValue(property, fieldManager, instance, setId, metadata, entity, value)) ðŸ”µ</abbr>
 365                          boolean isValid = true;
<abbr title=" 366                          PopulateValueRequest request = new PopulateValueRequest(setId, fieldManager, property, metadata, returnType, value, persistenceManager, this, entity.isPreAdd());"> 366                          PopulateValueRequest request = new PopulateValueRequest(setId, fieldManager, property, metðŸ”µ</abbr>
 367                          handled = false;
 368                          if (value != null) {
 369                              for (PopulateValueRequestValidator validator : populateValidators) {
 370                                  PropertyValidationResult validationResult = validator.validate(request, instance);
 371                                  if (!validationResult.isValid()) {
<abbr title=" 372                                      entity.addValidationError(property.getName(), validationResult.getErrorMessage());"> 372                                      entity.addValidationError(property.getName(), validationResult.getErrorMessageðŸ”µ</abbr>
 373                                      isValid = false;
 374                                  }
 375                              }
 376                          }
 377                          if (isValid) {
 378                              try {
 379                                  boolean isBreakDetected = false;
<abbr title=" 380                                  for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {"> 380                                  for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProvidersðŸ”µ</abbr>
<abbr title=" 381                                      if ((!isBreakDetected || fieldPersistenceProvider.alwaysRun()) &amp;&amp; (value != null || fieldPersistenceProvider.canHandlePopulateNull())) {"> 381                                      if ((!isBreakDetected || fieldPersistenceProvider.alwaysRun()) &amp;&amp; (value != nuðŸ”µ</abbr>
<abbr title=" 382                                          MetadataProviderResponse response = fieldPersistenceProvider.populateValue(request, instance);"> 382                                          MetadataProviderResponse response = fieldPersistenceProvider.populateValueðŸ”µ</abbr>
 383                                          if (MetadataProviderResponse.NOT_HANDLED != response) {
 384                                              handled = true;
 385                                          }
 386                                          if (MetadataProviderResponse.HANDLED_BREAK == response) {
 387                                              isBreakDetected = true;
 388                                          }
 389                                      }
 390                                  }
 391                                  if (!handled) {
 392                                      if (value == null) {
 393                                          property.setIsDirty(true);
 394                                      }
<abbr title=" 395                                      defaultFieldPersistenceProvider.populateValue(new PopulateValueRequest(setId, fieldManager, property, metadata, returnType, value, persistenceManager, this, entity.isPreAdd()), instance);"> 395                                      defaultFieldPersistenceProvider.populateValue(new PopulateValueRequest(setId, ðŸ”µ</abbr>
 396                                      if (value == null) {
 397                                          fieldManager.setFieldValue(instance, property.getName(), null);
 398                                      }
 399                                  }
 400                              } catch (ParentEntityPersistenceException | javax.validation.ValidationException e) {
 401                                  entityPersistenceException = e;
 402                                  cleanupFailedPersistenceAttempt(instance);
 403                                  break;
 404                              }
 405                          }
 406                      }
 407                  }
 408              }
 409              // Only check validation if not the initial add
 410              if (!entity.isPreAdd()) {
 411                  validate(entity, instance, mergedProperties, validateUnsubmittedProperties);
 412              }
 413              //if validation failed, refresh the current instance so that none of the changes will be persisted
 414              if (entity.isValidationFailure()) {
 415                  //only refresh the instance if it was managed to begin with
 416                  if (persistenceManager.getDynamicEntityDao().getStandardEntityManager().contains(instance)) {
 417                      persistenceManager.getDynamicEntityDao().refresh(instance);
 418                  }
 419  
 420                  //re-initialize the valid properties for the entity in order to deal with the potential of not
 421                  //completely sending over all checkbox/radio fields
 422                  List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
 423                  entityList.add(instance);
 424                  Entity invalid = getRecords(mergedProperties, entityList, null, null, null)[0];
 425                  invalid.setPropertyValidationErrors(entity.getPropertyValidationErrors());
 426                  invalid.setGlobalValidationErrors(entity.getGlobalValidationErrors());
 427                  invalid.overridePropertyValues(entity);
 428  
<abbr title=" 429                  String message = ValidationUtil.buildErrorMessage(invalid.getPropertyValidationErrors(), invalid.getGlobalValidationErrors());"> 429                  String message = ValidationUtil.buildErrorMessage(invalid.getPropertyValidationErrors(), invalid.gðŸ”µ</abbr>
 430                  throw new ValidationException(invalid, message);
 431              } else if (entityPersistenceException != null) {
 432                  throw ExceptionHelper.refineException(entityPersistenceException.getCause());
 433              } else {
 434                  fieldManager.persistMiddleEntities();
 435              }
 436          } catch (IllegalAccessException e) {
 437              throw new PersistenceException(e);
 438          } catch (InstantiationException e) {
 439              throw new PersistenceException(e);
 440          } finally {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 441 -            session.setFlushMode(originalFlushMode);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 442 +            session.setHibernateFlushMode(originalFlushMode);</span>
 443          }
 444          return instance;
 445      }
 446  
 447      protected boolean attemptToPopulateValue(Property property, FieldManager fieldManager, Serializable instance,
<abbr title=" 448                                               Boolean setId, BasicFieldMetadata metadata, Entity entity, String value) throws IllegalAccessException {"> 448                                               Boolean setId, BasicFieldMetadata metadata, Entity entity, String valðŸ”µ</abbr>
 449          Boolean mutable = metadata.getMutable();
 450          Boolean readOnly = metadata.getReadOnly();
<abbr title=" 451          boolean generalConditionsMet = (mutable == null || mutable) &amp;&amp; (readOnly == null || !readOnly) &amp;&amp; property.getEnabled();"> 451          boolean generalConditionsMet = (mutable == null || mutable) &amp;&amp; (readOnly == null || !readOnly) &amp;&amp; propertyðŸ”µ</abbr>
 452  
 453          if (generalConditionsMet &amp;&amp; value == null) {
 454              boolean currentValueIsNotNull = false;
 455              try {
 456                  currentValueIsNotNull = fieldManager.getFieldValue(instance, property.getName()) != null;
 457              } catch (FieldNotAvailableException e) {
 458                  throw new IllegalArgumentException(e);
 459              }
 460  
 461              boolean valueIsNotNullId = metadata.getFieldType() != SupportedFieldType.ID || setId;
 462              boolean valueIsNotPassword = metadata.getFieldType() != SupportedFieldType.PASSWORD;
 463  
 464              return currentValueIsNotNull &amp;&amp; !entity.isPreAdd() &amp;&amp; valueIsNotNullId &amp;&amp; valueIsNotPassword;
 465          }
 466          return generalConditionsMet;
 467      }
 468  
 469      @Override
<abbr title=" 470      public Entity getRecord(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, Serializable record, Map&lt;String, FieldMetadata&gt; alternateMergedProperties, String pathToTargetObject) {"> 470      public Entity getRecord(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, Serializable record, Map&lt;String, FðŸ”µ</abbr>
 471          List&lt;Serializable&gt; records = new ArrayList&lt;Serializable&gt;(1);
 472          records.add(record);
<abbr title=" 473          Entity[] productEntities = getRecords(primaryMergedProperties, records, alternateMergedProperties, pathToTargetObject, null);"> 473          Entity[] productEntities = getRecords(primaryMergedProperties, records, alternateMergedProperties, pathToTðŸ”µ</abbr>
 474          return productEntities[0];
 475      }
 476  
 477      @Override
<abbr title=" 478      public Entity getRecord(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, Serializable record) {"> 478      public Entity getRecord(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, SerializabðŸ”µ</abbr>
<abbr title=" 479          Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persistencePerspective);"> 479          Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persðŸ”µ</abbr>
 480          return getRecord(mergedProperties, record, null, null);
 481      }
 482  
 483      @Override
<abbr title=" 484      public Entity[] getRecords(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, List&lt;? extends Serializable&gt; records) {"> 484      public Entity[] getRecords(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, List&lt;? ðŸ”µ</abbr>
<abbr title=" 485          Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persistencePerspective);"> 485          Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persðŸ”µ</abbr>
 486          return getRecords(mergedProperties, records, null, null, null);
 487      }
 488  
 489      @Override
<abbr title=" 490      public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persistencePerspective) {"> 490      public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persisteðŸ”µ</abbr>
<abbr title=" 491          return persistenceManager.getDynamicEntityDao().getSimpleMergedProperties(entityName, persistencePerspective);"> 491          return persistenceManager.getDynamicEntityDao().getSimpleMergedProperties(entityName, persistencePerspectiðŸ”µ</abbr>
 492      }
 493  
 494      @Override
<abbr title=" 495      public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, List&lt;? extends Serializable&gt; records) {"> 495      public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, List&lt;? extends Serializable&gt; reðŸ”µ</abbr>
 496          return getRecords(primaryMergedProperties, records, null, null, null);
 497      }
 498  
 499      @Override
 500      public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryUnfilteredMergedProperties,
 501                                 List&lt;? extends Serializable&gt; records,
 502                                 Map&lt;String, FieldMetadata&gt; alternateUnfilteredMergedProperties,
 503                                 String pathToTargetObject) {
<abbr title=" 504          return getRecords(primaryUnfilteredMergedProperties, records, alternateUnfilteredMergedProperties, pathToTargetObject, null);"> 504          return getRecords(primaryUnfilteredMergedProperties, records, alternateUnfilteredMergedProperties, pathToTðŸ”µ</abbr>
 505      }
 506  
 507      @Override
 508      public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryUnfilteredMergedProperties,
 509                                 List&lt;? extends Serializable&gt; records,
 510                                 Map&lt;String, FieldMetadata&gt; alternateUnfilteredMergedProperties,
 511                                 String pathToTargetObject,
 512                                 String[] customCriteria) {
<abbr title=" 513          Map&lt;String, FieldMetadata&gt; primaryMergedProperties = filterOutCollectionMetadata(primaryUnfilteredMergedProperties);"> 513          Map&lt;String, FieldMetadata&gt; primaryMergedProperties = filterOutCollectionMetadata(primaryUnfilteredMergedPrðŸ”µ</abbr>
<abbr title=" 514          Map&lt;String, FieldMetadata&gt; alternateMergedProperties = filterOutCollectionMetadata(alternateUnfilteredMergedProperties);"> 514          Map&lt;String, FieldMetadata&gt; alternateMergedProperties = filterOutCollectionMetadata(alternateUnfilteredMergðŸ”µ</abbr>
 515          Entity[] entities = new Entity[records.size()];
 516          int j = 0;
 517          for (Serializable recordEntity : records) {
 518              Serializable entity;
 519              if (pathToTargetObject != null) {
 520                  try {
 521                      entity = (Serializable) getFieldManager().getFieldValue(recordEntity, pathToTargetObject);
 522                  } catch (Exception e) {
 523                      throw new PersistenceException(e);
 524                  }
 525              } else {
 526                  entity = recordEntity;
 527              }
 528              Entity entityItem = new Entity();
 529              entityItem.setType(new String[] { entity.getClass().getName() });
 530              entities[j] = entityItem;
 531  
 532              List&lt;Property&gt; props = new ArrayList&lt;Property&gt;(primaryMergedProperties.size());
 533              extractPropertiesFromPersistentEntity(primaryMergedProperties, entity, props, customCriteria);
 534              if (alternateMergedProperties != null) {
<abbr title=" 535                  extractPropertiesFromPersistentEntity(alternateMergedProperties, recordEntity, props, customCriteria);"> 535                  extractPropertiesFromPersistentEntity(alternateMergedProperties, recordEntity, props, customCriterðŸ”µ</abbr>
 536              }
 537  
 538              // Try to add the &quot;main name&quot; property. Log a debug message if we can&#x27;t
 539              try {
 540                  Property p = new Property();
 541                  p.setName(MAIN_ENTITY_NAME_PROPERTY);
 542                  String mainEntityName = (String) MethodUtils.invokeMethod(entity, &quot;getMainEntityName&quot;);
 543                  p.setValue(mainEntityName);
 544                  props.add(p);
 545              } catch (Exception e) {
 546                  LOG.debug(String.format(&quot;Could not execute the getMainEntityName() method for [%s]&quot;,
 547                          entity.getClass().getName()), e);
 548              }
 549  
 550              // Try to add the alternate id property if available
 551              if (alternateMergedProperties != null) {
 552                  for (Entry&lt;String, FieldMetadata&gt; entry : alternateMergedProperties.entrySet()) {
 553                      if (entry.getValue() instanceof BasicFieldMetadata) {
 554                          if (((BasicFieldMetadata) entry.getValue()).getFieldType() == SupportedFieldType.ID) {
 555                              Map&lt;String, FieldMetadata&gt; alternateOnEntity = new HashMap&lt;String, FieldMetadata&gt;();
 556                              alternateOnEntity.put(entry.getKey(), entry.getValue());
 557                              List&lt;Property&gt; props2 = new ArrayList&lt;Property&gt;();
<abbr title=" 558                              extractPropertiesFromPersistentEntity(alternateOnEntity, recordEntity, props2, customCriteria);"> 558                              extractPropertiesFromPersistentEntity(alternateOnEntity, recordEntity, props2, customCðŸ”µ</abbr>
 559                              List&lt;Property&gt; filtered = new ArrayList&lt;Property&gt;();
 560                              for (Property prop : props2) {
 561                                  if (!prop.getName().startsWith(&quot;__&quot;)) {
 562                                      filtered.add(prop);
 563                                  }
 564                              }
 565                              if (filtered.size() == 1 &amp;&amp; !filtered.get(0).getName().contains(&quot;.&quot;)) {
 566                                  Property alternateIdProp = filtered.get(0);
 567                                  alternateIdProp.setName(ALTERNATE_ID_PROPERTY);
 568                                  props.add(alternateIdProp);
 569                              }
 570                          }
 571                      }
 572                  }
 573              }
 574  
 575              Property[] properties = new Property[props.size()];
 576              properties = props.toArray(properties);
 577              entityItem.setProperties(properties);
 578              j++;
 579          }
 580  
 581          return entities;
 582      }
 583  
 584      @Override
 585      public Entity[] getRecords(FetchExtractionRequest fetchExtractionRequest) {
 586          return fetchWrapper.getRecords(fetchExtractionRequest);
 587      }
 588  
 589      protected void extractPropertiesFromPersistentEntity(Map&lt;String, FieldMetadata&gt; mergedProperties,
 590                                                           Serializable entity,
 591                                                           List&lt;Property&gt; props,
 592                                                           String[] customCriteria) {
 593          FieldManager fieldManager = getFieldManager();
 594          try {
 595              if (entity instanceof AdminMainEntity) {
 596                  //Create an invisible property for the admin main entity name, if applicable.
 597                  //This is useful for ToOneLookups if that ToOneLookup uses AdminMainEntity to drive
 598                  //its display name.
 599                  try {
 600                      Property propertyItem = new Property();
 601                      propertyItem.setName(AdminMainEntity.MAIN_ENTITY_NAME_PROPERTY);
 602                      propertyItem.setValue(((AdminMainEntity) entity).getMainEntityName());
 603                      props.add(propertyItem);
 604                  } catch (Exception e) {
<abbr title=" 605                      //do nothing here except for not add the property. Exceptions could occur when there is a validation"> 605                      //do nothing here except for not add the property. Exceptions could occur when there is a valiðŸ”µ</abbr>
<abbr title=" 606                      //issue and some properties/relationships that are used for gleaning the main entity name end up"> 606                      //issue and some properties/relationships that are used for gleaning the main entity name end ðŸ”µ</abbr>
 607                      //not being set
 608                  }
 609              }
 610              for (Entry&lt;String, FieldMetadata&gt; entry : mergedProperties.entrySet()) {
 611                  String property = entry.getKey();
 612                  BasicFieldMetadata metadata = (BasicFieldMetadata) entry.getValue();
<abbr title=" 613                  if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(entity.getClass()) || entity.getClass().isAssignableFrom(Class.forName(metadata.getInheritedFromType()))) {"> 613                  if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(entity.getClass()) || entity.gðŸ”µ</abbr>
 614                      boolean proceed = true;
 615                      if (property.contains(&quot;.&quot;)) {
 616                          StringTokenizer tokens = new StringTokenizer(property, &quot;.&quot;);
 617                          Object testObject = entity;
 618                          while (tokens.hasMoreTokens()) {
 619                              String token = tokens.nextToken();
 620                              if (tokens.hasMoreTokens()) {
 621                                  try {
 622                                      testObject = fieldManager.getFieldValue(testObject, token);
 623                                  } catch (FieldNotAvailableException e) {
 624                                      proceed = false;
 625                                      break;
 626                                  }
 627                                  if (testObject == null) {
 628                                      Property propertyItem = new Property();
 629                                      propertyItem.setName(property);
 630                                      if (props.contains(propertyItem)) {
 631                                          proceed = false;
 632                                          break;
 633                                      }
 634                                      propertyItem.setValue(null);
 635                                      props.add(propertyItem);
 636                                      proceed = false;
 637                                      break;
 638                                  }
 639                              }
 640                          }
 641                      }
 642                      if (!proceed) {
 643                          continue;
 644                      }
 645  
 646                      boolean isFieldAccessible = true;
 647                      Object value = null;
 648                      try {
 649                          value = fieldManager.getFieldValue(entity, property);
 650                      } catch (FieldNotAvailableException e) {
 651                          isFieldAccessible = false;
 652                      }
 653                      checkField:
 654                      {
 655                          if (isFieldAccessible) {
 656                              Property propertyItem = new Property();
 657                              propertyItem.setName(property);
 658                              if (props.contains(propertyItem)) {
 659                                  continue;
 660                              }
 661                              props.add(propertyItem);
 662                              String displayVal = propertyItem.getDisplayValue();
 663                              boolean handled = false;
 664                              for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {
 665                                  MetadataProviderResponse response = fieldPersistenceProvider.extractValue(
 666                                          new ExtractValueRequest(props, fieldManager, metadata, value, displayVal,
 667                                                  persistenceManager, this, entity, customCriteria), propertyItem);
 668                                  if (MetadataProviderResponse.NOT_HANDLED != response) {
 669                                      handled = true;
 670                                  }
 671                                  if (MetadataProviderResponse.HANDLED_BREAK == response) {
 672                                      break;
 673                                  }
 674                              }
 675                              if (!handled) {
 676                                  defaultFieldPersistenceProvider.extractValue(
 677                                          new ExtractValueRequest(props, fieldManager, metadata, value, displayVal,
 678                                                  persistenceManager, this, entity, customCriteria), propertyItem);
 679                              }
 680                              break checkField;
 681                          }
 682                          //try a direct property acquisition via reflection
 683                          try {
 684                              String strVal = null;
 685                              Method method;
 686                              try {
 687                                  //try a &#x27;get&#x27; prefixed mutator first
<abbr title=" 688                                  String temp = &quot;get&quot; + property.substring(0, 1).toUpperCase() + property.substring(1, property.length());"> 688                                  String temp = &quot;get&quot; + property.substring(0, 1).toUpperCase() + property.substring(ðŸ”µ</abbr>
 689                                  method = entity.getClass().getMethod(temp, new Class[] {});
 690                              } catch (NoSuchMethodException e) {
 691                                  method = entity.getClass().getMethod(property, new Class[] {});
 692                              }
 693                              value = method.invoke(entity, new String[] {});
 694                              Property propertyItem = new Property();
 695                              propertyItem.setName(property);
 696                              if (props.contains(propertyItem)) {
 697                                  continue;
 698                              }
 699                              props.add(propertyItem);
 700                              if (value == null) {
 701                                  strVal = null;
 702                              } else {
 703                                  if (Date.class.isAssignableFrom(value.getClass())) {
 704                                      strVal = getSimpleDateFormatter().format((Date) value);
 705                                  } else if (Timestamp.class.isAssignableFrom(value.getClass())) {
<abbr title=" 706                                      strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value).getTime()));"> 706                                      strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value).getTime(ðŸ”µ</abbr>
 707                                  } else if (Calendar.class.isAssignableFrom(value.getClass())) {
 708                                      strVal = getSimpleDateFormatter().format(((Calendar) value).getTime());
 709                                  } else if (Double.class.isAssignableFrom(value.getClass())) {
 710                                      strVal = getDecimalFormatter().format(value);
 711                                  } else if (BigDecimal.class.isAssignableFrom(value.getClass())) {
 712                                      strVal = getDecimalFormatter().format(value);
 713                                  } else {
 714                                      strVal = value.toString();
 715                                  }
 716                              }
 717                              propertyItem.setValue(strVal);
 718                          } catch (NoSuchMethodException e) {
<abbr title=" 719                              LOG.debug(&quot;Unable to find a specified property in the entity: &quot; + StringUtil.sanitize(property));"> 719                              LOG.debug(&quot;Unable to find a specified property in the entity: &quot; + StringUtil.sanitize(ðŸ”µ</abbr>
 720                              //do nothing - this property is simply not in the bean
 721                          }
 722                      }
 723                  }
 724              }
 725          } catch (ClassNotFoundException e) {
 726              throw new PersistenceException(e);
 727          } catch (IllegalAccessException e) {
 728              throw new PersistenceException(e);
 729          } catch (InvocationTargetException e) {
 730              throw new PersistenceException(e);
 731          }
 732      }
 733  
 734      @Override
 735      public String getStringValueFromGetter(Serializable instance, String propertyName)
 736              throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
 737          Object value = PropertyUtils.getProperty(instance, propertyName);
 738          return formatValue(value);
 739      }
 740  
 741      @Override
 742      public String formatValue(Object value) {
 743          String strVal;
 744          if (value == null) {
 745              strVal = null;
 746          } else {
 747              if (Date.class.isAssignableFrom(value.getClass())) {
 748                  strVal = getSimpleDateFormatter().format((Date) value);
 749              } else if (Timestamp.class.isAssignableFrom(value.getClass())) {
 750                  strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value).getTime()));
 751              } else if (Calendar.class.isAssignableFrom(value.getClass())) {
 752                  strVal = getSimpleDateFormatter().format(((Calendar) value).getTime());
 753              } else if (Double.class.isAssignableFrom(value.getClass())) {
 754                  strVal = getDecimalFormatter().format(value);
 755              } else if (BigDecimal.class.isAssignableFrom(value.getClass())) {
 756                  strVal = getDecimalFormatter().format(value);
 757              } else {
 758                  strVal = value.toString();
 759              }
 760          }
 761          return strVal;
 762      }
 763  
<abbr title=" 764      protected EntityResult update(PersistencePackage persistencePackage, Object primaryKey, boolean includeRealEntity) throws ServiceException {"> 764      protected EntityResult update(PersistencePackage persistencePackage, Object primaryKey, boolean includeRealEntðŸ”µ</abbr>
 765          EntityResult entityResult = new EntityResult();
 766          Entity entity = persistencePackage.getEntity();
 767          PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title=" 768          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);"> 768          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistenðŸ”µ</abbr>
 769          if (foreignKey != null &amp;&amp; !foreignKey.getMutable()) {
 770              throw new SecurityServiceException(&quot;Entity not mutable&quot;);
 771          }
 772          try {
<abbr title=" 773              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());"> 773              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFulðŸ”µ</abbr>
<abbr title=" 774              Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties("> 774              Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperðŸ”µ</abbr>
 775                      persistencePackage.getCeilingEntityFullyQualifiedClassname(),
 776                      entities,
 777                      foreignKey,
 778                      persistencePerspective.getAdditionalNonPersistentProperties(),
 779                      persistencePerspective.getAdditionalForeignKeys(),
 780                      MergedPropertyType.PRIMARY,
 781                      persistencePerspective.getPopulateToOneFields(),
 782                      persistencePerspective.getIncludeFields(),
 783                      persistencePerspective.getExcludeFields(),
 784                      persistencePerspective.getConfigurationKey(),
 785                      &quot;&quot;
 786                      );
 787              if (primaryKey == null) {
 788                  primaryKey = getPrimaryKey(entity, mergedProperties);
 789              }
<abbr title=" 790              Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getType()[0]), primaryKey);"> 790              Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getTypeðŸ”µ</abbr>
 791  
 792              Assert.isTrue(instance != null, &quot;Entity not found&quot;);
 793  
 794              if (!entity.isValidationFailure()) {
 795                  //Re-Balance the list if it is a Foreign Key toMany collection with a sort field property
 796                  if (foreignKey != null &amp;&amp; foreignKey.getSortField() != null &amp;&amp;
 797                          entity.findProperty(foreignKey.getSortField()) != null &amp;&amp;
 798                          entity.findProperty(foreignKey.getSortField()).getValue() != null) {
 799                      ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;();
 800                      extensionManager.getProxy().rebalanceForUpdate(this, persistencePackage, instance,
 801                              mergedProperties, primaryKey, result);
 802                      instance = result.getResult();
 803                  } else {
<abbr title=" 804                      instance = createPopulatedInstance(instance, entity, mergedProperties, false, persistencePackage.isValidateUnsubmittedProperties());"> 804                      instance = createPopulatedInstance(instance, entity, mergedProperties, false, persistencePackaðŸ”µ</abbr>
 805                  }
 806  
 807                  instance = persistenceManager.getDynamicEntityDao().merge(instance);
 808                  if (includeRealEntity) {
 809                      entityResult.setEntityBackingObject(instance);
 810                  }
 811  
 812                  List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
 813                  entityList.add(instance);
 814  
 815                  entity = getRecords(mergedProperties, entityList, null, null, null)[0];
 816                  entityResult.setEntity(entity);
 817                  return entityResult;
 818              } else {
 819                  entityResult.setEntity(entity);
 820                  return entityResult;
 821              }
 822          } catch (Exception e) {
 823              throw new ServiceException(&quot;Problem updating entity : &quot; + e.getMessage(), e);
 824          }
 825      }
 826  
 827      @Override
 828      public String getIdPropertyName(String entityClass) {
 829          return persistenceManager.getIdPropertyName(entityClass);
 830      }
 831  
 832      public String getIdPropertyName(Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
 833          Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);
 834          for (String property : mergedProperties.keySet()) {
 835              BasicFieldMetadata temp = (BasicFieldMetadata) mergedProperties.get(property);
 836              if (temp.getFieldType() == SupportedFieldType.ID &amp;&amp; !property.contains(&quot;.&quot;)) {
 837                  return property;
 838              }
 839          }
 840  
 841          throw new RuntimeException(&quot;Could not find a primary key property in the passed merged properties list&quot;);
 842      }
 843  
 844      @Override
 845      public Object getPrimaryKey(Entity entity, Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
 846          Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);
 847          Object primaryKey = null;
 848          String idPropertyName = null;
 849          BasicFieldMetadata metaData = null;
 850          for (String property : mergedProperties.keySet()) {
 851              BasicFieldMetadata temp = (BasicFieldMetadata) mergedProperties.get(property);
 852              if (temp.getFieldType() == SupportedFieldType.ID &amp;&amp; !property.contains(&quot;.&quot;)) {
 853                  idPropertyName = property;
 854                  metaData = temp;
 855                  break;
 856              }
 857          }
 858          if (idPropertyName == null) {
<abbr title=" 859              throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: &quot; + entity.getType()[0]);"> 859              throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: &quot; + ðŸ”µ</abbr>
 860          }
 861          for (Property property : entity.getProperties()) {
 862              if (property.getName().equals(idPropertyName)) {
 863                  switch (metaData.getSecondaryType()) {
 864                      case INTEGER:
 865                          primaryKey = (property.getValue() == null) ? null : Long.valueOf(property.getValue());
 866                          break;
 867                      case STRING:
 868                          primaryKey = property.getValue();
 869                          break;
 870                  }
 871                  break;
 872              }
 873          }
 874          if (primaryKey == null) {
<abbr title=" 875              throw new RuntimeException(&quot;Could not find the primary key property (&quot; + idPropertyName + &quot;) in the passed entity with type: &quot; + entity.getType()[0]);"> 875              throw new RuntimeException(&quot;Could not find the primary key property (&quot; + idPropertyName + &quot;) in the paðŸ”µ</abbr>
 876          }
 877          return primaryKey;
 878      }
 879  
 880      @Override
 881      public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective,
 882              CriteriaTransferObject cto,
 883              String ceilingEntityFullyQualifiedClassname,
 884              Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties,
 885              RestrictionFactory customRestrictionFactory) {
 886          Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);
 887          List&lt;FilterMapping&gt; filterMappings = new ArrayList&lt;FilterMapping&gt;();
 888  
 889          for (String propertyId : cto.getCriteriaMap().keySet()) {
 890              if (mergedProperties.containsKey(propertyId)) {
 891                  boolean handled = false;
 892                  for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {
 893                      MetadataProviderResponse response = fieldPersistenceProvider.addSearchMapping(
 894                              new AddSearchMappingRequest(persistencePerspective, cto,
 895                                      ceilingEntityFullyQualifiedClassname, mergedProperties,
<abbr title=" 896                                      propertyId, getFieldManager(), this, this, customRestrictionFactory==null?restrictionFactory"> 896                                      propertyId, getFieldManager(), this, this, customRestrictionFactory==null?restðŸ”µ</abbr>
 897                                      :customRestrictionFactory), filterMappings);
 898                      if (MetadataProviderResponse.NOT_HANDLED != response) {
 899                          handled = true;
 900                      }
 901                      if (MetadataProviderResponse.HANDLED_BREAK == response) {
 902                          break;
 903                      }
 904                  }
 905                  if (!handled) {
 906                      defaultFieldPersistenceProvider.addSearchMapping(
 907                              new AddSearchMappingRequest(persistencePerspective, cto,
 908                                      ceilingEntityFullyQualifiedClassname, mergedProperties, propertyId,
<abbr title=" 909                                      getFieldManager(), this, this, customRestrictionFactory == null ? restrictionFactory"> 909                                      getFieldManager(), this, this, customRestrictionFactory == null ? restrictionFðŸ”µ</abbr>
 910                                              : customRestrictionFactory), filterMappings);
 911                  }
 912              }
 913          }
 914          return filterMappings;
 915      }
 916  
 917      @Override
 918      public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective,
 919              CriteriaTransferObject cto,
 920              String ceilingEntityFullyQualifiedClassname,
 921              Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
<abbr title=" 922          return getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergedUnfilteredProperties, null);"> 922          return getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergedUnfilterðŸ”µ</abbr>
 923      }
 924  
 925      @Override
<abbr title=" 926      public void extractProperties(Class&lt;?&gt;[] inheritanceLine, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; mergedProperties, List&lt;Property&gt; properties) {"> 926      public void extractProperties(Class&lt;?&gt;[] inheritanceLine, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; ðŸ”µ</abbr>
<abbr title=" 927          extractPropertiesFromMetadata(inheritanceLine, mergedProperties.get(MergedPropertyType.PRIMARY), properties, false, MergedPropertyType.PRIMARY);"> 927          extractPropertiesFromMetadata(inheritanceLine, mergedProperties.get(MergedPropertyType.PRIMARY), propertieðŸ”µ</abbr>
 928      }
 929  
<abbr title=" 930      protected void extractPropertiesFromMetadata(Class&lt;?&gt;[] inheritanceLine, Map&lt;String, FieldMetadata&gt; mergedProperties, List&lt;Property&gt; properties, Boolean isHiddenOverride, MergedPropertyType type) {"> 930      protected void extractPropertiesFromMetadata(Class&lt;?&gt;[] inheritanceLine, Map&lt;String, FieldMetadata&gt; mergedPropðŸ”µ</abbr>
 931          Comparator&lt;Property&gt; comparator = new Comparator&lt;Property&gt;() {
 932  
 933              @Override
 934              public int compare(Property o1, Property o2) {
 935                  return o1.getName().compareTo(o2.getName());
 936              }
 937          };
 938          Collections.sort(properties, comparator);
 939          for (Map.Entry&lt;String, FieldMetadata&gt; entry : mergedProperties.entrySet()) {
 940              String property = entry.getKey();
 941              Property prop = new Property();
 942              FieldMetadata metadata = mergedProperties.get(property);
 943              prop.setName(property);
 944  
 945              int pos = Collections.binarySearch(properties, prop, comparator);
<abbr title=" 946              if (pos &gt;= 0 &amp;&amp; MergedPropertyType.MAPSTRUCTUREKEY != type &amp;&amp; MergedPropertyType.MAPSTRUCTUREVALUE != type) {"> 946              if (pos &gt;= 0 &amp;&amp; MergedPropertyType.MAPSTRUCTUREKEY != type &amp;&amp; MergedPropertyType.MAPSTRUCTUREVALUE != ðŸ”µ</abbr>
 947                  logWarn: {
<abbr title=" 948                      if ((metadata instanceof BasicFieldMetadata) &amp;&amp; SupportedFieldType.ID.equals(((BasicFieldMetadata) metadata).getFieldType())) {"> 948                      if ((metadata instanceof BasicFieldMetadata) &amp;&amp; SupportedFieldType.ID.equals(((BasicFieldMetadðŸ”µ</abbr>
 949                          //don&#x27;t warn for id field collisions, but still ignore the colliding fields
 950                          break logWarn;
 951                      }
<abbr title=" 952                      //LOG.warn(&quot;Detected a field name collision (&quot; + metadata.getTargetClass() + &quot;.&quot; + property + &quot;) during inspection for the inheritance line starting with (&quot; + inheritanceLine[0].getName() + &quot;). Ignoring the additional field. This can occur most commonly when using the @AdminPresentationAdornedTargetCollection and the collection type and target class have field names in common. This situation should be avoided, as the system will strip the repeated fields, which can cause unpredictable behavior.&quot;);"> 952                      //LOG.warn(&quot;Detected a field name collision (&quot; + metadata.getTargetClass() + &quot;.&quot; + property + ðŸ”µ</abbr>
 953                  }
 954                  continue;
 955              } else if (pos &lt; 0) {
 956                  pos = -pos - 1; // calculate position to insert
 957              }
 958              properties.add(pos, prop);
 959              prop.setMetadata(metadata);
 960              if (isHiddenOverride &amp;&amp; prop.getMetadata() instanceof BasicFieldMetadata) {
 961                  //this only makes sense for non collection types
 962                  ((BasicFieldMetadata) prop.getMetadata()).setVisibility(VisibilityEnum.HIDDEN_ALL);
 963              }
 964          }
 965      }
 966  
 967      @Override
<abbr title=" 968      public void updateMergedProperties(PersistencePackage persistencePackage, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; allMergedProperties) throws ServiceException {"> 968      public void updateMergedProperties(PersistencePackage persistencePackage, Map&lt;MergedPropertyType, Map&lt;String, ðŸ”µ</abbr>
<abbr title=" 969          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();"> 969          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname()ðŸ”µ</abbr>
 970          try {
 971              PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
 972              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(ceilingEntityFullyQualifiedClassname);
<abbr title=" 973              Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties("> 973              Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperðŸ”µ</abbr>
 974                      ceilingEntityFullyQualifiedClassname,
 975                      entities,
<abbr title=" 976                      (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),"> 976                      (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectivðŸ”µ</abbr>
 977                      persistencePerspective.getAdditionalNonPersistentProperties(),
 978                      persistencePerspective.getAdditionalForeignKeys(),
 979                      MergedPropertyType.PRIMARY,
 980                      persistencePerspective.getPopulateToOneFields(),
 981                      persistencePerspective.getIncludeFields(),
 982                      persistencePerspective.getExcludeFields(),
 983                      persistencePerspective.getConfigurationKey(),
 984                      &quot;&quot;
 985                      );
 986              allMergedProperties.put(MergedPropertyType.PRIMARY, mergedProperties);
 987          } catch (Exception e) {
 988              throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);
 989          }
 990      }
 991  
 992      @Override
<abbr title=" 993      public EntityResult update(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServiceException {"> 993      public EntityResult update(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServðŸ”µ</abbr>
 994          return update(persistencePackage, null, true);
 995      }
 996  
 997      @Override
 998      public Entity update(PersistencePackage persistencePackage) throws ServiceException {
 999          EntityResult er = update(persistencePackage, null, false);
1000          return er.getEntity();
1001      }
1002  
1003      @Override
1004      public Entity add(PersistencePackage persistencePackage) throws ServiceException {
1005          EntityResult entityResult = add(persistencePackage, false);
1006          return entityResult.getEntity();
1007      }
1008  
1009      @Override
<abbr title="1010      public EntityResult add(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServiceException {">1010      public EntityResult add(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServiceðŸ”µ</abbr>
1011          EntityResult entityResult = new EntityResult();
1012          Entity entity = persistencePackage.getEntity();
1013          PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1014          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1014          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistenðŸ”µ</abbr>
1015          if (foreignKey != null &amp;&amp; !foreignKey.getMutable()) {
1016              throw new SecurityServiceException(&quot;Entity not mutable&quot;);
1017          }
1018          try {
<abbr title="1019              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());">1019              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFulðŸ”µ</abbr>
<abbr title="1020              Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(">1020              Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMeðŸ”µ</abbr>
1021                      persistencePackage.getCeilingEntityFullyQualifiedClassname(),
1022                      entities,
1023                      foreignKey,
1024                      persistencePerspective.getAdditionalNonPersistentProperties(),
1025                      persistencePerspective.getAdditionalForeignKeys(),
1026                      MergedPropertyType.PRIMARY,
1027                      persistencePerspective.getPopulateToOneFields(),
1028                      persistencePerspective.getIncludeFields(),
1029                      persistencePerspective.getExcludeFields(),
1030                      persistencePerspective.getConfigurationKey(),
1031                      &quot;&quot;
1032                      );
1033              Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);
1034  
1035              String idProperty = null;
1036              for (String property : mergedProperties.keySet()) {
<abbr title="1037                  if (((BasicFieldMetadata) mergedProperties.get(property)).getFieldType() == SupportedFieldType.ID) {">1037                  if (((BasicFieldMetadata) mergedProperties.get(property)).getFieldType() == SupportedFieldType.ID)ðŸ”µ</abbr>
1038                      idProperty = property;
1039                      break;
1040                  }
1041              }
1042              if (idProperty == null) {
<abbr title="1043                  throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: &quot; + entity.getType()[0]);">1043                  throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: ðŸ”µ</abbr>
1044              }
1045              Object primaryKey = null;
1046              try {
1047                  primaryKey = getPrimaryKey(entity, mergedProperties);
1048              } catch (Exception e) {
1049                  //don&#x27;t do anything - this is a valid case
1050              }
1051              if (primaryKey == null) {
1052  
1053                  Serializable instance = (Serializable) Class.forName(entity.getType()[0]).newInstance();
1054  
1055                  instance = createPopulatedInstance(instance, entity, mergedProperties, false);
1056  
1057                  if (foreignKey != null &amp;&amp; foreignKey.getSortField() != null) {
1058                      ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;();
<abbr title="1059                      extensionManager.getProxy().rebalanceForAdd(this, persistencePackage, instance, mergedProperties, result);">1059                      extensionManager.getProxy().rebalanceForAdd(this, persistencePackage, instance, mergedPropertiðŸ”µ</abbr>
1060                      instance = result.getResult();
1061                  }
1062  
1063                  instance = persistenceManager.getDynamicEntityDao().merge(instance);
1064                  if (includeRealEntityObject) {
1065                      entityResult.setEntityBackingObject(instance);
1066                  }
1067                  List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
1068                  entityList.add(instance);
1069  
1070                  entity = getRecords(mergedProperties, entityList, null, null, null)[0];
1071                  entityResult.setEntity(entity);
1072                  return entityResult;
1073              } else {
1074                  return update(persistencePackage, primaryKey, includeRealEntityObject);
1075              }
1076          } catch (Exception e) {
1077              throw new ServiceException(&quot;Problem adding new entity : &quot; + e.getMessage(), e);
1078          }
1079      }
1080  
1081      @Override
1082      public void remove(PersistencePackage persistencePackage) throws ServiceException {
1083          Entity entity = persistencePackage.getEntity();
1084          PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1085          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1085          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistenðŸ”µ</abbr>
1086          if (foreignKey != null &amp;&amp; !foreignKey.getMutable()) {
1087              throw new SecurityServiceException(&quot;Entity not mutable&quot;);
1088          }
1089          try {
<abbr title="1090              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());">1090              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFulðŸ”µ</abbr>
<abbr title="1091              Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(">1091              Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMeðŸ”µ</abbr>
1092                      persistencePackage.getCeilingEntityFullyQualifiedClassname(),
1093                      entities,
1094                      foreignKey,
1095                      persistencePerspective.getAdditionalNonPersistentProperties(),
1096                      persistencePerspective.getAdditionalForeignKeys(),
1097                      MergedPropertyType.PRIMARY,
1098                      persistencePerspective.getPopulateToOneFields(),
1099                      persistencePerspective.getIncludeFields(),
1100                      persistencePerspective.getExcludeFields(),
1101                      persistencePerspective.getConfigurationKey(),
1102                      &quot;&quot;
1103                      );
1104              Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);
1105              Object primaryKey = getPrimaryKey(entity, mergedProperties);
<abbr title="1106              Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getType()[0]), primaryKey);">1106              Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getTypeðŸ”µ</abbr>
1107  
1108              Assert.isTrue(instance != null, &quot;Entity not found&quot;);
1109  
1110              switch (persistencePerspective.getOperationTypes().getRemoveType()) {
1111                  case NONDESTRUCTIVEREMOVE:
1112                      FieldManager fieldManager = getFieldManager();
<abbr title="1113                      FieldMetadata manyToFieldMetadata = mergedUnfilteredProperties.get(foreignKey.getManyToField());">1113                      FieldMetadata manyToFieldMetadata = mergedUnfilteredProperties.get(foreignKey.getManyToField()ðŸ”µ</abbr>
1114                      Object foreignKeyValue = entity.getPMap().get(foreignKey.getManyToField()).getValue();
1115                      try {
1116                          foreignKeyValue = Long.valueOf((String) foreignKeyValue);
1117                      } catch (NumberFormatException e) {
1118                          LOG.warn(&quot;Foreign primary key is not of type Long, assuming String for remove lookup&quot;);
1119                      }
<abbr title="1120                      Serializable foreignInstance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(foreignKey.getForeignKeyClass()), foreignKeyValue);">1120                      Serializable foreignInstance = persistenceManager.getDynamicEntityDao().retrieve(Class.forNameðŸ”µ</abbr>
<abbr title="1121                      Collection collection = (Collection) fieldManager.getFieldValue(foreignInstance, foreignKey.getOriginatingField());">1121                      Collection collection = (Collection) fieldManager.getFieldValue(foreignInstance, foreignKey.geðŸ”µ</abbr>
1122                      collection.remove(instance);
<abbr title="1123                      // if this is a bi-directional @OneToMany/@ManyToOne and there is no @JoinTable (just a foreign key on">1123                      // if this is a bi-directional @OneToMany/@ManyToOne and there is no @JoinTable (just a foreigðŸ”µ</abbr>
1124                      // the @ManyToOne side) then it will not be updated. In that instance, we have to explicitly
1125                      // set the manyTo field to null so that subsequent lookups will not find it
1126                      if (manyToFieldMetadata instanceof BasicFieldMetadata) {
1127                          if (BooleanUtils.isTrue(((BasicFieldMetadata) manyToFieldMetadata).getRequired())) {
<abbr title="1128                              throw new ServiceException(&quot;Could not remove from the collection as the ManyToOne side is a&quot;">1128                              throw new ServiceException(&quot;Could not remove from the collection as the ManyToOne sideðŸ”µ</abbr>
<abbr title="1129                                      + &quot; non-optional relationship. Consider changing &#x27;optional=true&#x27; in the @ManyToOne annotation&quot;">1129                                      + &quot; non-optional relationship. Consider changing &#x27;optional=true&#x27; in the @ManyTðŸ”µ</abbr>
1130                                      + &quot; or nullable=true within the @JoinColumn annotation&quot;);
1131                          }
<abbr title="1132                          //Since this is occuring on a remove persistence package, merge up-front (before making a change) for proper operation in the presence of the enterprise module">1132                          //Since this is occuring on a remove persistence package, merge up-front (before making a ðŸ”µ</abbr>
1133                          instance = persistenceManager.getDynamicEntityDao().merge(instance);
<abbr title="1134                          Field manyToField = fieldManager.getField(instance.getClass(), foreignKey.getManyToField());">1134                          Field manyToField = fieldManager.getField(instance.getClass(), foreignKey.getManyToField()ðŸ”µ</abbr>
1135                          Object manyToObject = manyToField.get(instance);
<abbr title="1136                          if (manyToObject != null &amp;&amp; !(manyToObject instanceof Collection) &amp;&amp; !(manyToObject instanceof Map)) {">1136                          if (manyToObject != null &amp;&amp; !(manyToObject instanceof Collection) &amp;&amp; !(manyToObject instanðŸ”µ</abbr>
1137                              manyToField.set(instance, null);
1138                              instance = persistenceManager.getDynamicEntityDao().merge(instance);
1139                          }
1140                      }
1141                      break;
1142                  case BASIC:
1143                      persistenceManager.getDynamicEntityDao().remove(instance);
1144                      break;
1145              }
1146          } catch (Exception e) {
1147              throw new ServiceException(&quot;Problem removing entity : &quot; + e.getMessage(), e);
1148          }
1149      }
1150  
1151      public Map&lt;String, FieldMetadata&gt; getMergedProperties(PersistencePackage persistencePackage,
1152              CriteriaTransferObject cto) throws ServiceException {
1153          PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1154          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();">1154          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname()ðŸ”µ</abbr>
1155  
1156          if (StringUtils.isEmpty(persistencePackage.getFetchTypeFullyQualifiedClassname())) {
1157              persistencePackage.setFetchTypeFullyQualifiedClassname(ceilingEntityFullyQualifiedClassname);
1158          }
1159  
1160          try {
<abbr title="1161              Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualifiedClassname));">1161              Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(ClðŸ”µ</abbr>
1162  
<abbr title="1163              Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(">1163              Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperðŸ”µ</abbr>
1164                      ceilingEntityFullyQualifiedClassname,
1165                      entities,
<abbr title="1166                      (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),">1166                      (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectivðŸ”µ</abbr>
1167                      persistencePerspective.getAdditionalNonPersistentProperties(),
1168                      persistencePerspective.getAdditionalForeignKeys(),
1169                      MergedPropertyType.PRIMARY,
1170                      persistencePerspective.getPopulateToOneFields(),
1171                      persistencePerspective.getIncludeFields(),
1172                      persistencePerspective.getExcludeFields(),
1173                      persistencePerspective.getConfigurationKey(),
1174                      &quot;&quot;
1175                      );
1176  
1177              return mergedProperties;
1178          } catch (Exception e) {
1179              throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);
1180          }
1181      }
1182  
1183      @Override
<abbr title="1184      public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto) throws ServiceException {">1184      public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto) throws ServicðŸ”µ</abbr>
1185          Entity[] payload;
1186          int totalRecords;
1187          PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1188          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();">1188          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname()ðŸ”µ</abbr>
<abbr title="1189          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1189          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistenðŸ”µ</abbr>
1190  
1191          try {
1192              if (foreignKey != null &amp;&amp; foreignKey.getSortField() != null) {
1193                  FilterAndSortCriteria sortCriteria = cto.get(foreignKey.getSortField());
1194                  sortCriteria.setSortAscending(foreignKey.getSortAscending());
1195              }
1196  
1197              Map&lt;String, FieldMetadata&gt; mergedProperties = getMergedProperties(persistencePackage, cto);
1198  



1199              List&lt;FilterMapping&gt; filterMappings = getFilterMappings(persistencePerspective, cto, persistencePackage
1200                      .getFetchTypeFullyQualifiedClassname(), mergedProperties);
1201              List&lt;FilterMapping&gt; standardFilterMappings = new ArrayList&lt;FilterMapping&gt;(filterMappings);
1202              if (CollectionUtils.isNotEmpty(cto.getAdditionalFilterMappings())) {
1203                  standardFilterMappings.addAll(cto.getAdditionalFilterMappings());
1204              }
1205              if (CollectionUtils.isNotEmpty(cto.getNonCountAdditionalFilterMappings())) {
1206                  standardFilterMappings.addAll(cto.getNonCountAdditionalFilterMappings());
1207              }
1208  
1209              FetchRequest fetchRequest = new FetchRequest(persistencePackage, cto,
1210                      persistencePackage.getFetchTypeFullyQualifiedClassname(), standardFilterMappings);
1211              List&lt;Serializable&gt; records = getPersistentRecords(fetchRequest);
1212  
1213              List&lt;FilterMapping&gt; countFilterMappings = new ArrayList&lt;FilterMapping&gt;(filterMappings);
1214              if (CollectionUtils.isNotEmpty(cto.getAdditionalFilterMappings())) {
1215                  countFilterMappings.addAll(cto.getAdditionalFilterMappings());
1216              }
1217              FetchRequest countFetchRequest = new FetchRequest(persistencePackage, cto,
1218                      persistencePackage.getFetchTypeFullyQualifiedClassname(), countFilterMappings);
1219              totalRecords = getTotalRecords(countFetchRequest);
1220  
1221              FetchExtractionRequest fetchExtractionRequest = new FetchExtractionRequest(persistencePackage, cto,
1222                      persistencePackage.getFetchTypeFullyQualifiedClassname(), mergedProperties, records);
1223              payload = getRecords(fetchExtractionRequest);
1224          } catch (Exception e) {
1225              throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);
1226          }
1227  
1228          return new DynamicResultSet(null, payload, totalRecords);















































































































1229      }
1230  
1231      @Override
1232      public Integer getTotalRecords(FetchRequest fetchRequest) {
1233          return fetchWrapper.getTotalRecords(fetchRequest);
1234      }
1235  
1236      @Override
1237      public Integer getTotalRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings) {
1238          try {
1239              return ((Long) criteriaTranslator.translateCountQuery(persistenceManager.getDynamicEntityDao(),
1240                      ceilingEntity, filterMappings).getSingleResult()).intValue();
1241          } catch (CriteriaConversionException e) {
<abbr title="1242              TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntity);">1242              TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntityðŸ”µ</abbr>
<abbr title="1243              return ((Long) builder.toCountQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManager()).getSingleResult()).intValue();">1243              return ((Long) builder.toCountQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManðŸ”µ</abbr>
1244          }
1245      }
1246  
1247      @Override
1248      public Serializable getMaxValue(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, String maxField) {
1249          return criteriaTranslator.translateMaxQuery(persistenceManager.getDynamicEntityDao(),
1250                  ceilingEntity, filterMappings, maxField).getSingleResult();
1251      }
1252  
1253      @Override
1254      public List&lt;Serializable&gt; getPersistentRecords(FetchRequest fetchRequest) {
1255          return fetchWrapper.getPersistentRecords(fetchRequest);
1256      }
1257  
1258      @Override
<abbr title="1259      public List&lt;Serializable&gt; getPersistentRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, Integer firstResult, Integer maxResults) {">1259      public List&lt;Serializable&gt; getPersistentRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, IntegðŸ”µ</abbr>
1260          try {
<abbr title="1261              return criteriaTranslator.translateQuery(persistenceManager.getDynamicEntityDao(), ceilingEntity, filterMappings, firstResult, maxResults).getResultList();">1261              return criteriaTranslator.translateQuery(persistenceManager.getDynamicEntityDao(), ceilingEntity, filtðŸ”µ</abbr>
1262          } catch (CriteriaConversionException e) {
<abbr title="1263              TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntity);">1263              TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntityðŸ”µ</abbr>
<abbr title="1264              return builder.toQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManager()).getResultList();">1264              return builder.toQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManager()).getReðŸ”µ</abbr>
1265          }
1266      }
1267  
1268      @Override
<abbr title="1269      public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperties) {">1269      public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperðŸ”µ</abbr>
1270          return validate(entity, populatedInstance, mergedProperties, true);
1271      }
1272  
1273      @Override
<abbr title="1274      public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperties,">1274      public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperðŸ”µ</abbr>
1275              boolean validateUnsubmittedProperties) {
<abbr title="1276          entityValidatorService.validate(entity, populatedInstance, mergedProperties, this, validateUnsubmittedProperties);">1276          entityValidatorService.validate(entity, populatedInstance, mergedProperties, this, validateUnsubmittedPropðŸ”µ</abbr>
1277          return !entity.isValidationFailure();
1278      }
1279  
1280      @Override
1281      public void setPersistenceManager(PersistenceManager persistenceManager) {
1282          this.persistenceManager = persistenceManager;
1283      }
1284  
1285      @Override
1286      public PersistenceModule getCompatibleModule(OperationType operationType) {
1287          return ((InspectHelper) persistenceManager).getCompatibleModule(operationType);
1288      }
1289  
1290      public FieldPersistenceProvider getDefaultFieldPersistenceProvider() {
1291          return defaultFieldPersistenceProvider;
1292      }
1293  
1294      public void setDefaultFieldPersistenceProvider(FieldPersistenceProvider defaultFieldPersistenceProvider) {
1295          this.defaultFieldPersistenceProvider = defaultFieldPersistenceProvider;
1296      }
1297  
1298      public List&lt;FieldPersistenceProvider&gt; getFieldPersistenceProviders() {
1299          return fieldPersistenceProviders;
1300      }
1301  
1302      public void setFieldPersistenceProviders(List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders) {
1303          this.fieldPersistenceProviders = fieldPersistenceProviders;
1304      }
1305  
1306      public CriteriaTranslator getCriteriaTranslator() {
1307          return criteriaTranslator;
1308      }
1309  
1310      public void setCriteriaTranslator(CriteriaTranslator criteriaTranslator) {
1311          this.criteriaTranslator = criteriaTranslator;
1312      }
1313  
1314      public EntityValidatorService getEntityValidatorService() {
1315          return entityValidatorService;
1316      }
1317  
1318      public void setEntityValidatorService(EntityValidatorService entityValidatorService) {
1319          this.entityValidatorService = entityValidatorService;
1320      }
1321  
1322      public RestrictionFactory getRestrictionFactory() {
1323          return restrictionFactory;
1324      }
1325  
1326      public void setRestrictionFactory(RestrictionFactory restrictionFactory) {
1327          this.restrictionFactory = restrictionFactory;
1328      }
1329  
1330      public PersistenceManager getPersistenceManager() {
1331          return persistenceManager;
1332      }
1333  
1334      /**
<abbr title="1335       * Use an alternate approach to generating a fetch query for a collection located inside of an @Embeddable object. Related">1335       * Use an alternate approach to generating a fetch query for a collection located inside of an @Embeddable objðŸ”µ</abbr>
<abbr title="1336       * to https://hibernate.atlassian.net/browse/HHH-8802. The alternate approach leverages HQL rather than JPA criteria,">1336       * to https://hibernate.atlassian.net/browse/HHH-8802. The alternate approach leverages HQL rather than JPA crðŸ”µ</abbr>
1337       * which seems to alleviate the problem.
1338       *
1339       * @param embeddedCollectionPath the path to the collection field itself
1340       * @param filterMappings all the fetch restrictions for this request
1341       * @param collectionClass the type of the collection members
1342       * @return the builder capable of generating an appropriate HQL query
1343       */
<abbr title="1344      protected TypedQueryBuilder getSpecialCaseQueryBuilder(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; filterMappings, String collectionClass) {">1344      protected TypedQueryBuilder getSpecialCaseQueryBuilder(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; fðŸ”µ</abbr>
1345          String specialPath = embeddedCollectionPath.getTargetProperty();
1346          String[] pieces = specialPath.split(&quot;\\.&quot;);
1347          if (pieces.length != 3) {
<abbr title="1348              throw new CriteriaConversionException(String.format(&quot;Expected to find a target property of format [embedded field].[collection field].[property] for the embedded collection path (%s)&quot;, specialPath), embeddedCollectionPath);">1348              throw new CriteriaConversionException(String.format(&quot;Expected to find a target property of format [embðŸ”µ</abbr>
1349          }
1350          String expression = specialPath.substring(0, specialPath.lastIndexOf(&quot;.&quot;));
1351          TypedQueryBuilder builder;
1352          try {
1353              builder = new TypedQueryBuilder(Class.forName(collectionClass), &quot;specialEntity&quot;)
1354                      .addJoin(new TQJoin(&quot;specialEntity.&quot; + expression, &quot;embeddedCollection&quot;));
1355          } catch (Exception e) {
1356              throw ExceptionHelper.refineException(e);
1357          }
1358          for (TQRestriction restriction : buildSpecialRestrictions(expression, filterMappings)) {
1359              builder = builder.addRestriction(restriction);
1360          }
1361          for (TQRestriction restriction : buildStandardRestrictions(embeddedCollectionPath, filterMappings)) {
1362              builder = builder.addRestriction(restriction);
1363          }
1364          for (FilterMapping mapping : filterMappings) {
1365              if (mapping.getSortDirection() != null) {
<abbr title="1366                  String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().getTargetProperty();">1366                  String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().getTargetPðŸ”µ</abbr>
1367                  if (StringUtils.isEmpty(mappingProperty)) {
1368                      mappingProperty = mapping.getFullPropertyName();
1369                  }
<abbr title="1370                  builder = builder.addOrder(new TQOrder(&quot;specialEntity.&quot; + mappingProperty, SortDirection.ASCENDING == mapping.getSortDirection()));">1370                  builder = builder.addOrder(new TQOrder(&quot;specialEntity.&quot; + mappingProperty, SortDirection.ASCENDINGðŸ”µ</abbr>
1371              }
1372          }
1373  
1374          return builder;
1375      }
1376  
1377      /**
<abbr title="1378       * Generate LIKE or EQUALS restrictions for any filter property specified on the root entity (not the collection field in the @Embeddable object)">1378       * Generate LIKE or EQUALS restrictions for any filter property specified on the root entity (not the collectiðŸ”µ</abbr>
1379       *
<abbr title="1380       * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath, java.util.List, String)">1380       * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteriaðŸ”µ</abbr>
<abbr title="1381       * @param embeddedCollectionPath the path for the collection field in the @Embeddable object - this is what caused the whole thing">1381       * @param embeddedCollectionPath the path for the collection field in the @Embeddable object - this is what caðŸ”µ</abbr>
1382       * @param filterMappings all the fetch restrictions for this request
1383       * @return the list of restrictions on the root entity
1384       */
<abbr title="1385      protected List&lt;TQRestriction&gt; buildStandardRestrictions(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; filterMappings) {">1385      protected List&lt;TQRestriction&gt; buildStandardRestrictions(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; ðŸ”µ</abbr>
<abbr title="1386          String expression = embeddedCollectionPath.getTargetProperty().substring(0, embeddedCollectionPath.getTargetProperty().lastIndexOf(&quot;.&quot;));">1386          String expression = embeddedCollectionPath.getTargetProperty().substring(0, embeddedCollectionPath.getTargðŸ”µ</abbr>
1387          List&lt;TQRestriction&gt; restrictions = new ArrayList&lt;TQRestriction&gt;();
1388          for (FilterMapping mapping : filterMappings) {
1389              checkProperty: {
<abbr title="1390                  String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().getTargetProperty();">1390                  String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().getTargetPðŸ”µ</abbr>
1391                  if (StringUtils.isEmpty(mappingProperty)) {
1392                      mappingProperty = mapping.getFullPropertyName();
1393                  }
<abbr title="1394                  if (!embeddedCollectionPath.getTargetProperty().equals(mappingProperty) &amp;&amp; !StringUtils.isEmpty(mappingProperty)) {">1394                  if (!embeddedCollectionPath.getTargetProperty().equals(mappingProperty) &amp;&amp; !StringUtils.isEmpty(maðŸ”µ</abbr>
1395                      PredicateProvider predicateProvider = mapping.getRestriction().getPredicateProvider();
1396                      if (predicateProvider != null) {
1397                          FilterValueConverter converter = mapping.getRestriction().getFilterValueConverter();
1398                          if (converter != null &amp;&amp; CollectionUtils.isNotEmpty(mapping.getFilterValues())) {
1399                              Object val = converter.convert(mapping.getFilterValues().get(0));
1400                              if (predicateProvider instanceof LikePredicateProvider) {
<abbr title="1401                                  restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;LIKE&quot;, val + &quot;%&quot;));">1401                                  restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;LIKE&quot;, valðŸ”µ</abbr>
1402                                  break checkProperty;
1403                              } else if (predicateProvider instanceof EqPredicateProvider) {
1404                                  restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;=&quot;, val));
1405                                  break checkProperty;
1406                              }
1407                          }
1408                      }
<abbr title="1409                      LOG.warn(String.format(&quot;Unable to filter the embedded collection (%s) on an additional property (%s)&quot;,">1409                      LOG.warn(String.format(&quot;Unable to filter the embedded collection (%s) on an additional propertðŸ”µ</abbr>
1410                              StringUtil.sanitize(expression),
1411                              StringUtil.sanitize(mappingProperty)));
1412                  }
1413              }
1414          }
1415  
1416          return restrictions;
1417      }
1418  
1419      /**
<abbr title="1420       * Generate EQUALS restrictions for any filter property specified on the entity member of the collection field in the @Embeddable object">1420       * Generate EQUALS restrictions for any filter property specified on the entity member of the collection fieldðŸ”µ</abbr>
1421       *
<abbr title="1422       * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath, java.util.List, String)">1422       * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteriaðŸ”µ</abbr>
<abbr title="1423       * @param specialExpression the String representation of the path for the collection field in the @Embeddable object">1423       * @param specialExpression the String representation of the path for the collection field in the @Embeddable ðŸ”µ</abbr>
1424       * @param filterMappings all the fetch restrictions for this request
1425       * @return the list of restrictions on the collection in the @Embeddable object
1426       */
<abbr title="1427      protected List&lt;TQRestriction&gt; buildSpecialRestrictions(String specialExpression, List&lt;FilterMapping&gt; filterMappings) {">1427      protected List&lt;TQRestriction&gt; buildSpecialRestrictions(String specialExpression, List&lt;FilterMapping&gt; filterMapðŸ”µ</abbr>
1428          List&lt;TQRestriction&gt; restrictions = new ArrayList&lt;TQRestriction&gt;();
1429          for (FilterMapping mapping : filterMappings) {
<abbr title="1430              if (mapping.getFieldPath() != null &amp;&amp; mapping.getFieldPath().getTargetProperty() != null &amp;&amp; mapping.getFieldPath().getTargetProperty().startsWith(specialExpression)) {">1430              if (mapping.getFieldPath() != null &amp;&amp; mapping.getFieldPath().getTargetProperty() != null &amp;&amp; mapping.geðŸ”µ</abbr>
1431                  FilterValueConverter converter = mapping.getRestriction().getFilterValueConverter();
1432                  if (converter != null &amp;&amp; CollectionUtils.isNotEmpty(mapping.getFilterValues())) {
1433                      Object val = converter.convert(mapping.getFilterValues().get(0));
<abbr title="1434                      String property = mapping.getFieldPath().getTargetProperty().substring(mapping.getFieldPath().getTargetProperty().lastIndexOf(&quot;.&quot;) + 1, mapping.getFieldPath().getTargetProperty().length());">1434                      String property = mapping.getFieldPath().getTargetProperty().substring(mapping.getFieldPath().ðŸ”µ</abbr>
1435                      restrictions.add(new TQRestriction(&quot;embeddedCollection.&quot; + property, &quot;=&quot;, val));
1436                  }
1437              }
1438          }
1439          return restrictions;
1440      }
1441  
1442      protected void cleanupFailedPersistenceAttempt(Serializable instance) throws IllegalAccessException {
1443          //Remove the entity from ORM management - no further attempts to persist
1444          if (getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().contains(instance)) {
1445              getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().detach(instance);
1446          }
1447          //Remove the id field value, if it&#x27;s set
<abbr title="1448          String idFieldName = (String) getPersistenceManager().getDynamicEntityDao().getIdMetadata(instance.getClass()).get(&quot;name&quot;);">1448          String idFieldName = (String) getPersistenceManager().getDynamicEntityDao().getIdMetadata(instance.getClasðŸ”µ</abbr>
1449          Field idField = FieldUtils.getField(instance.getClass(), idFieldName, true);
1450          if (idField == null) {
<abbr title="1451              throw ExceptionHelper.refineException(new NoSuchFieldException(&quot;Entity &quot; + instance.getClass().getName() + &quot; does not contain id field &quot; + idFieldName));">1451              throw ExceptionHelper.refineException(new NoSuchFieldException(&quot;Entity &quot; + instance.getClass().getNameðŸ”µ</abbr>
1452          }
1453          idField.setAccessible(true);
1454          if (idField.get(instance) != null) {
1455              idField.set(instance, null);
1456          }
1457      }
1458  
1459      protected Class&lt;?&gt; getMapFieldType(Serializable instance, FieldManager fieldManager, Property property) {
1460          Class&lt;?&gt; returnType = null;
<abbr title="1461          Field field = fieldManager.getField(instance.getClass(), property.getName().substring(0, property.getName().indexOf(FieldManager.MAPFIELDSEPARATOR)));">1461          Field field = fieldManager.getField(instance.getClass(), property.getName().substring(0, property.getName(ðŸ”µ</abbr>
1462          java.lang.reflect.Type type = field.getGenericType();
1463          if (type instanceof ParameterizedType) {
1464              ParameterizedType pType = (ParameterizedType) type;
1465              Class&lt;?&gt; clazz;
1466              if (pType.getActualTypeArguments().length &lt; 2) {
1467                  clazz = (Class&lt;?&gt;) pType.getActualTypeArguments()[0];
1468              } else {
1469                  clazz = (Class&lt;?&gt;) pType.getActualTypeArguments()[1];
1470              }
<abbr title="1471              Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(clazz);">1471              Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(clðŸ”µ</abbr>
1472              if (!ArrayUtils.isEmpty(entities)) {
1473                  returnType = entities[entities.length - 1];
1474              }
1475          }
1476          return returnType;
1477      }
1478  }</pre></td>
                            <td><pre>   1  /*
   2   * #%L
   3   * BroadleafCommerce Open Admin Platform
   4   * %%
   5   * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6   * %%
   7   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10   * the Broadleaf End User License Agreement (EULA), Version 1.1
  11   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12   * shall apply.
  13   *
<abbr title="  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  15   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  16   * #L%
  17   */
  18  
  19  package org.broadleafcommerce.openadmin.server.service.persistence.module;
  20  
  21  import org.apache.commons.beanutils.PropertyUtils;
  22  import org.apache.commons.collections.CollectionUtils;
  23  import org.apache.commons.lang.ArrayUtils;
  24  import org.apache.commons.lang.StringUtils;
  25  import org.apache.commons.lang3.BooleanUtils;
  26  import org.apache.commons.lang3.reflect.FieldUtils;
  27  import org.apache.commons.lang3.reflect.MethodUtils;
  28  import org.apache.commons.logging.Log;
  29  import org.apache.commons.logging.LogFactory;
  30  import org.broadleafcommerce.common.admin.domain.AdminMainEntity;
  31  import org.broadleafcommerce.common.exception.ExceptionHelper;
  32  import org.broadleafcommerce.common.exception.SecurityServiceException;
  33  import org.broadleafcommerce.common.exception.ServiceException;
  34  import org.broadleafcommerce.common.extension.ExtensionResultHolder;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  35 +import org.broadleafcommerce.common.i18n.domain.TranslatedEntity;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  36 +import org.broadleafcommerce.common.i18n.domain.TranslationImpl;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  37 +import org.broadleafcommerce.common.locale.service.LocaleService;</span>
  38  import org.broadleafcommerce.common.money.Money;
  39  import org.broadleafcommerce.common.presentation.client.OperationType;
  40  import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  41  import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  42  import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  43  import org.broadleafcommerce.common.util.FormatUtil;
  44  import org.broadleafcommerce.common.util.StringUtil;
  45  import org.broadleafcommerce.common.util.ValidationUtil;
  46  import org.broadleafcommerce.common.util.dao.TQJoin;
  47  import org.broadleafcommerce.common.util.dao.TQOrder;
  48  import org.broadleafcommerce.common.util.dao.TQRestriction;
  49  import org.broadleafcommerce.common.util.dao.TypedQueryBuilder;
  50  import org.broadleafcommerce.common.web.BroadleafRequestContext;
  51  import org.broadleafcommerce.openadmin.dto.BasicFieldMetadata;
  52  import org.broadleafcommerce.openadmin.dto.CriteriaTransferObject;
  53  import org.broadleafcommerce.openadmin.dto.DynamicResultSet;
  54  import org.broadleafcommerce.openadmin.dto.Entity;
  55  import org.broadleafcommerce.openadmin.dto.EntityResult;
  56  import org.broadleafcommerce.openadmin.dto.FieldMetadata;
  57  import org.broadleafcommerce.openadmin.dto.FilterAndSortCriteria;
  58  import org.broadleafcommerce.openadmin.dto.ForeignKey;
  59  import org.broadleafcommerce.openadmin.dto.MergedPropertyType;
  60  import org.broadleafcommerce.openadmin.dto.PersistencePackage;
  61  import org.broadleafcommerce.openadmin.dto.PersistencePerspective;
  62  import org.broadleafcommerce.openadmin.dto.Property;
  63  import org.broadleafcommerce.openadmin.dto.SortDirection;

  64  import org.broadleafcommerce.openadmin.server.dao.provider.metadata.AdvancedCollectionFieldMetadataProvider;
  65  import org.broadleafcommerce.openadmin.server.service.ValidationException;
  66  import org.broadleafcommerce.openadmin.server.service.persistence.ParentEntityPersistenceException;
  67  import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceException;
  68  import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceManager;
  69  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.CriteriaConversionException;
  70  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.CriteriaTranslator;
  71  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  72 +import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPathBuilder;</span>
  73  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FilterMapping;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  74 +import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.Restriction;</span>
  75  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.RestrictionFactory;

  76  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.converter.FilterValueConverter;
  77  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.EqPredicateProvider;
  78  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.LikePredicateProvider;
  79  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvider;
<abbr title="  80  import org.broadleafcommerce.openadmin.server.service.persistence.module.extension.BasicPersistenceModuleExtensionManager;">  80  import org.broadleafcommerce.openadmin.server.service.persistence.module.extension.BasicPersistenceModuleExtensionðŸ”µ</abbr>
  81  import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.FieldPersistenceProvider;
<abbr title="  82  import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddFilterPropertiesRequest;">  82  import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddFilterPropertiesRequeðŸ”µ</abbr>
  83  import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddSearchMappingRequest;
  84  import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.ExtractValueRequest;
  85  import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.PopulateValueRequest;
  86  import org.broadleafcommerce.openadmin.server.service.persistence.validation.EntityValidatorService;
  87  import org.broadleafcommerce.openadmin.server.service.persistence.validation.PopulateValueRequestValidator;
  88  import org.broadleafcommerce.openadmin.server.service.persistence.validation.PropertyValidationResult;
  89  import org.broadleafcommerce.openadmin.server.service.type.MetadataProviderResponse;
  90  import org.hibernate.FlushMode;
  91  import org.hibernate.Session;
  92  import org.springframework.beans.BeansException;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  93 +import org.springframework.beans.factory.annotation.Value;</span>
  94  import org.springframework.context.ApplicationContext;
  95  import org.springframework.context.ApplicationContextAware;
  96  import org.springframework.context.annotation.Primary;
  97  import org.springframework.context.annotation.Scope;
  98  import org.springframework.stereotype.Component;
  99  import org.springframework.util.Assert;
 100  


 101  import java.io.Serializable;
 102  import java.lang.reflect.Field;
 103  import java.lang.reflect.InvocationTargetException;
 104  import java.lang.reflect.Method;
 105  import java.lang.reflect.ParameterizedType;
 106  import java.math.BigDecimal;
 107  import java.sql.Timestamp;
 108  import java.text.DecimalFormat;
 109  import java.text.NumberFormat;
 110  import java.text.SimpleDateFormat;
 111  import java.util.ArrayList;
 112  import java.util.Arrays;
 113  import java.util.Calendar;
 114  import java.util.Collection;
 115  import java.util.Collections;
 116  import java.util.Comparator;
 117  import java.util.Date;
 118  import java.util.HashMap;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 119 +import java.util.Iterator;</span>
 120  import java.util.List;
 121  import java.util.Locale;
 122  import java.util.Map;

 123  import java.util.Map.Entry;
 124  import java.util.StringTokenizer;
 125  
 126  import javax.annotation.PostConstruct;
 127  import javax.annotation.Resource;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 128 +import javax.persistence.criteria.CriteriaBuilder;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 129 +import javax.persistence.criteria.From;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 130 +import javax.persistence.criteria.Path;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 131 +import javax.persistence.criteria.Predicate;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 132 +import javax.persistence.criteria.Root;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 133 +import javax.persistence.criteria.Subquery;</span>
 134  
 135  /**
 136   * @author jfischer
 137   */
 138  @Primary
 139  @Component(&quot;blBasicPersistenceModule&quot;)
 140  @Scope(&quot;prototype&quot;)
 141  public class BasicPersistenceModule implements PersistenceModule, RecordHelper, ApplicationContextAware {
 142  
 143      private static final Log LOG = LogFactory.getLog(BasicPersistenceModule.class);
 144  
 145      public static final String MAIN_ENTITY_NAME_PROPERTY = &quot;MAIN_ENTITY_NAME&quot;;
 146      public static final String ALTERNATE_ID_PROPERTY = &quot;ALTERNATE_ID&quot;;
 147  
 148      protected ApplicationContext applicationContext;
 149      protected PersistenceManager persistenceManager;
 150  
 151      @Resource(name = &quot;blEntityValidatorService&quot;)
 152      protected EntityValidatorService entityValidatorService;
 153  
 154      @Resource(name = &quot;blPersistenceProviders&quot;)
<abbr title=" 155      protected List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders = new ArrayList&lt;FieldPersistenceProvider&gt;();"> 155      protected List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders = new ArrayList&lt;FieldPersistenceProvider&gt;()ðŸ”µ</abbr>
 156  
 157      @Resource(name = &quot;blPopulateValueRequestValidators&quot;)
 158      protected List&lt;PopulateValueRequestValidator&gt; populateValidators;
 159  
 160      @Resource(name = &quot;blDefaultFieldPersistenceProvider&quot;)
 161      protected FieldPersistenceProvider defaultFieldPersistenceProvider;
 162  
 163      @Resource(name = &quot;blCriteriaTranslator&quot;)
 164      protected CriteriaTranslator criteriaTranslator;
 165  
 166      @Resource(name = &quot;blRestrictionFactory&quot;)
 167      protected RestrictionFactory restrictionFactory;
 168  
 169      @Resource(name = &quot;blBasicPersistenceModuleExtensionManager&quot;)
 170      protected BasicPersistenceModuleExtensionManager extensionManager;
 171  
 172      @Resource(name = &quot;blFetchWrapper&quot;)
 173      protected FetchWrapper fetchWrapper;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 174 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 175 +    @Value(&quot;${use.translation.search:false}&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 176 +    protected boolean useTranslationSearch;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 177 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 178 +    @Resource(name = &quot;blLocaleService&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 179 +    protected LocaleService localeService;</span>
 180  
 181      @PostConstruct
 182      public void init() {
 183          Collections.sort(fieldPersistenceProviders, new Comparator&lt;FieldPersistenceProvider&gt;() {
 184  
 185              @Override
 186              public int compare(FieldPersistenceProvider o1, FieldPersistenceProvider o2) {
 187                  return Integer.compare(o1.getOrder(), o2.getOrder());
 188              }
 189          });
 190          Collections.sort(populateValidators, new Comparator&lt;PopulateValueRequestValidator&gt;() {
 191  
 192              @Override
 193              public int compare(PopulateValueRequestValidator o1, PopulateValueRequestValidator o2) {
 194                  return Integer.compare(o1.getOrder(), o2.getOrder());
 195              }
 196          });
 197      }
 198  
 199      @Override
 200      public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
 201          this.applicationContext = applicationContext;
 202      }
 203  
 204      @Override
 205      public boolean isCompatible(OperationType operationType) {
 206          return OperationType.BASIC == operationType || OperationType.NONDESTRUCTIVEREMOVE == operationType;
 207      }
 208  
 209      @Override
 210      public FieldManager getFieldManager() {
 211          return persistenceManager.getDynamicEntityDao().getFieldManager();
 212      }
 213  
 214      @Override
 215      public FieldManager getFieldManager(boolean cleanFieldManger) {
 216          return persistenceManager.getDynamicEntityDao().getFieldManager(cleanFieldManger);
 217      }
 218  
 219      @Override
 220      public DecimalFormat getDecimalFormatter() {
 221          BroadleafRequestContext brc = BroadleafRequestContext.getBroadleafRequestContext();
 222          Locale locale = brc.getJavaLocale();
 223          DecimalFormat format = (DecimalFormat) NumberFormat.getInstance(locale);
 224          format.applyPattern(&quot;0.########&quot;);
 225          format.setGroupingUsed(false);
 226          return format;
 227      }
 228  
 229      @Override
 230      public SimpleDateFormat getSimpleDateFormatter() {
 231          return FormatUtil.getDateFormat();
 232      }
 233  
 234      protected Map&lt;String, FieldMetadata&gt; filterOutCollectionMetadata(Map&lt;String, FieldMetadata&gt; metadata) {
 235          if (metadata == null) {
 236              return null;
 237          }
 238          Map&lt;String, FieldMetadata&gt; newMap = new HashMap&lt;String, FieldMetadata&gt;();
 239          for (Map.Entry&lt;String, FieldMetadata&gt; entry : metadata.entrySet()) {
 240              String fieldName = entry.getKey();
 241              FieldMetadata md = entry.getValue();
<abbr title=" 242              // Detect instances where the actual metadata for the field is some sort of CollectionMetadata but also corresponds"> 242              // Detect instances where the actual metadata for the field is some sort of CollectionMetadata but alsðŸ”µ</abbr>
<abbr title=" 243              // to a ForeignKey and ensure that gets included in the filtered map. That way the {@link BasicPersistenceModule}"> 243              // to a ForeignKey and ensure that gets included in the filtered map. That way the {@link BasicPersistðŸ”µ</abbr>
 244              // can appropriate handle filtration and population
 245              if (entry.getValue() instanceof BasicFieldMetadata) {
 246                  newMap.put(fieldName, md);
<abbr title=" 247              } else if (md.getAdditionalMetadata().containsKey(AdvancedCollectionFieldMetadataProvider.FOREIGN_KEY_ADDITIONAL_METADATA_KEY)) {"> 247              } else if (md.getAdditionalMetadata().containsKey(AdvancedCollectionFieldMetadataProvider.FOREIGN_KEY_ðŸ”µ</abbr>
 248                  newMap.put(fieldName,
<abbr title=" 249                          (BasicFieldMetadata) md.getAdditionalMetadata().get(AdvancedCollectionFieldMetadataProvider.FOREIGN_KEY_ADDITIONAL_METADATA_KEY));"> 249                          (BasicFieldMetadata) md.getAdditionalMetadata().get(AdvancedCollectionFieldMetadataProvideðŸ”µ</abbr>
 250              }
 251          }
 252  
 253          return newMap;
 254      }
 255  
 256      protected Class&lt;?&gt; getBasicBroadleafType(SupportedFieldType fieldType) {
 257          Class&lt;?&gt; response;
 258          switch (fieldType) {
 259              case BOOLEAN:
 260                  response = Boolean.TYPE;
 261                  break;
 262              case DATE:
 263                  response = Date.class;
 264                  break;
 265              case DECIMAL:
 266                  response = BigDecimal.class;
 267                  break;
 268              case MONEY:
 269                  response = Money.class;
 270                  break;
 271              case INTEGER:
 272                  response = Integer.TYPE;
 273                  break;
 274              case UNKNOWN:
 275                  response = null;
 276                  break;
 277              default:
 278                  response = String.class;
 279                  break;
 280          }
 281  
 282          return response;
 283      }
 284  
 285      @Override
 286      public Serializable createPopulatedInstance(Serializable instance, Entity entity,
 287              Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId) throws ValidationException {
 288          return createPopulatedInstance(instance, entity, unfilteredProperties, setId, true);
 289      }
 290  
 291      @Override
 292      public Serializable createPopulatedInstance(Serializable instance, Entity entity,
<abbr title=" 293              Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId, Boolean validateUnsubmittedProperties) throws ValidationException {"> 293              Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId, Boolean validateUnsubmittedProperties)ðŸ”µ</abbr>
 294          final Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(unfilteredProperties);
 295          FieldManager fieldManager = getFieldManager();
 296          boolean handled = false;
 297          for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {
<abbr title=" 298              MetadataProviderResponse response = fieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfilteredProperties);"> 298              MetadataProviderResponse response = fieldPersistenceProvider.filterProperties(new AddFilterPropertiesRðŸ”µ</abbr>
 299              if (MetadataProviderResponse.NOT_HANDLED != response) {
 300                  handled = true;
 301              }
 302              if (MetadataProviderResponse.HANDLED_BREAK == response) {
 303                  break;
 304              }
 305          }
 306          if (!handled) {
<abbr title=" 307              defaultFieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfilteredProperties);"> 307              defaultFieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfilteredProðŸ”µ</abbr>
 308          }
<abbr title=" 309          //Order media field, map field and rule builder fields last, as they will have some validation components that depend on previous values"> 309          //Order media field, map field and rule builder fields last, as they will have some validation components ðŸ”µ</abbr>
 310          Property[] sortedProperties = entity.getProperties();
 311          Arrays.sort(sortedProperties, new Comparator&lt;Property&gt;() {
 312  
 313              @Override
 314              public int compare(Property o1, Property o2) {
 315                  BasicFieldMetadata mo1 = (BasicFieldMetadata) mergedProperties.get(o1.getName());
 316                  BasicFieldMetadata mo2 = (BasicFieldMetadata) mergedProperties.get(o2.getName());
<abbr title=" 317                  boolean isLate1 = mo1 != null &amp;&amp; mo1.getFieldType() != null &amp;&amp; mo1.getName() != null &amp;&amp; (SupportedFieldType.RULE_SIMPLE==mo1.getFieldType() ||"> 317                  boolean isLate1 = mo1 != null &amp;&amp; mo1.getFieldType() != null &amp;&amp; mo1.getName() != null &amp;&amp; (SupportedðŸ”µ</abbr>
 318                          SupportedFieldType.RULE_WITH_QUANTITY==mo1.getFieldType() ||
 319                          SupportedFieldType.RULE_SIMPLE_TIME==mo1.getFieldType() ||
<abbr title=" 320                          SupportedFieldType.MEDIA==mo1.getFieldType() || o1.getName().contains(FieldManager.MAPFIELDSEPARATOR));"> 320                          SupportedFieldType.MEDIA==mo1.getFieldType() || o1.getName().contains(FieldManager.MAPFIELðŸ”µ</abbr>
<abbr title=" 321                  boolean isLate2 = mo2 != null &amp;&amp; mo2.getFieldType() != null &amp;&amp; mo2.getName() != null &amp;&amp; (SupportedFieldType.RULE_SIMPLE==mo2.getFieldType() ||"> 321                  boolean isLate2 = mo2 != null &amp;&amp; mo2.getFieldType() != null &amp;&amp; mo2.getName() != null &amp;&amp; (SupportedðŸ”µ</abbr>
 322                          SupportedFieldType.RULE_WITH_QUANTITY==mo2.getFieldType() ||
 323                          SupportedFieldType.RULE_SIMPLE_TIME==mo2.getFieldType() ||
<abbr title=" 324                          SupportedFieldType.MEDIA==mo2.getFieldType() || o2.getName().contains(FieldManager.MAPFIELDSEPARATOR));"> 324                          SupportedFieldType.MEDIA==mo2.getFieldType() || o2.getName().contains(FieldManager.MAPFIELðŸ”µ</abbr>
 325                  if (isLate1 &amp;&amp; !isLate2) {
 326                      return 1;
 327                  } else if (!isLate1 &amp;&amp; isLate2) {
 328                      return -1;
 329                  }
 330                  return 0;
 331              }
 332          });
<abbr title=" 333          Session session = getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().unwrap(Session.class);"> 333          Session session = getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().unwrap(Session.ðŸ”µ</abbr>
 334          FlushMode originalFlushMode = session.getFlushMode();

 335          try {
 336              session.setFlushMode(FlushMode.MANUAL);

 337              RuntimeException entityPersistenceException = null;
 338              for (Property property : sortedProperties) {
 339                  BasicFieldMetadata metadata = (BasicFieldMetadata) mergedProperties.get(property.getName());
 340                  Class&lt;?&gt; returnType;
<abbr title=" 341                  if (!property.getName().contains(FieldManager.MAPFIELDSEPARATOR) &amp;&amp; !property.getName().startsWith(&quot;__&quot;)) {"> 341                  if (!property.getName().contains(FieldManager.MAPFIELDSEPARATOR) &amp;&amp; !property.getName().startsWithðŸ”µ</abbr>
 342                      Field field = fieldManager.getField(instance.getClass(), property.getName());
 343                      if (field == null) {
<abbr title=" 344                          LOG.debug(&quot;Unable to find a bean property for the reported property: &quot; + StringUtil.sanitize(property.getName()) + &quot;. Ignoring property.&quot;);"> 344                          LOG.debug(&quot;Unable to find a bean property for the reported property: &quot; + StringUtil.sanitiðŸ”µ</abbr>
 345                          continue;
 346                      }
 347                      returnType = field.getType();
 348                  } else {
 349                      if (metadata == null) {
<abbr title=" 350                          LOG.debug(&quot;Unable to find a metadata property for the reported property: &quot; + StringUtil.sanitize(property.getName()) + &quot;. Ignoring property.&quot;);"> 350                          LOG.debug(&quot;Unable to find a metadata property for the reported property: &quot; + StringUtil.saðŸ”µ</abbr>
 351                          continue;
 352                      }
 353                      returnType = getMapFieldType(instance, fieldManager, property);
 354                      if (returnType == null) {
 355                          returnType = getBasicBroadleafType(metadata.getFieldType());
 356                      }
 357                  }
 358                  if (returnType == null) {
<abbr title=" 359                      throw new IllegalAccessException(&quot;Unable to determine the value type for the property (&quot; + property.getName() + &quot;)&quot;);"> 359                      throw new IllegalAccessException(&quot;Unable to determine the value type for the property (&quot; + proðŸ”µ</abbr>
 360                  }
 361                  String value = property.getValue();
 362                  if (metadata != null) {
 363  
 364                      if (metadata.getFieldType().equals(SupportedFieldType.BOOLEAN)) {
 365                          if (value == null) {
 366                              value = &quot;false&quot;;


 367                          }
 368                      } else if (metadata.getFieldType().equals(SupportedFieldType.DATE)) {
 369                          if (StringUtils.isEmpty(value)) {
 370                              value = null;
 371                          }
 372                      }
 373  
<abbr title=" 374                      if (attemptToPopulateValue(property, fieldManager, instance, setId, metadata, entity, value)) {"> 374                      if (attemptToPopulateValue(property, fieldManager, instance, setId, metadata, entity, value)) ðŸ”µ</abbr>
 375                          boolean isValid = true;
<abbr title=" 376                          PopulateValueRequest request = new PopulateValueRequest(setId, fieldManager, property, metadata, returnType, value, persistenceManager, this, entity.isPreAdd());"> 376                          PopulateValueRequest request = new PopulateValueRequest(setId, fieldManager, property, metðŸ”µ</abbr>
 377                          handled = false;
 378                          if (value != null) {
 379                              for (PopulateValueRequestValidator validator : populateValidators) {
 380                                  PropertyValidationResult validationResult = validator.validate(request, instance);
 381                                  if (!validationResult.isValid()) {
<abbr title=" 382                                      entity.addValidationError(property.getName(), validationResult.getErrorMessage());"> 382                                      entity.addValidationError(property.getName(), validationResult.getErrorMessageðŸ”µ</abbr>
 383                                      isValid = false;
 384                                  }
 385                              }
 386                          }
 387                          if (isValid) {
 388                              try {
 389                                  boolean isBreakDetected = false;
<abbr title=" 390                                  for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {"> 390                                  for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProvidersðŸ”µ</abbr>
<abbr title=" 391                                      if ((!isBreakDetected || fieldPersistenceProvider.alwaysRun()) &amp;&amp; (value != null || fieldPersistenceProvider.canHandlePopulateNull())) {"> 391                                      if ((!isBreakDetected || fieldPersistenceProvider.alwaysRun()) &amp;&amp; (value != nuðŸ”µ</abbr>
<abbr title=" 392                                          MetadataProviderResponse response = fieldPersistenceProvider.populateValue(request, instance);"> 392                                          MetadataProviderResponse response = fieldPersistenceProvider.populateValueðŸ”µ</abbr>
 393                                          if (MetadataProviderResponse.NOT_HANDLED != response) {
 394                                              handled = true;
 395                                          }
 396                                          if (MetadataProviderResponse.HANDLED_BREAK == response) {
 397                                              isBreakDetected = true;
 398                                          }
 399                                      }
 400                                  }
 401                                  if (!handled) {
 402                                      if (value == null) {
 403                                          property.setIsDirty(true);
 404                                      }
<abbr title=" 405                                      defaultFieldPersistenceProvider.populateValue(new PopulateValueRequest(setId, fieldManager, property, metadata, returnType, value, persistenceManager, this, entity.isPreAdd()), instance);"> 405                                      defaultFieldPersistenceProvider.populateValue(new PopulateValueRequest(setId, ðŸ”µ</abbr>
 406                                      if (value == null) {
 407                                          fieldManager.setFieldValue(instance, property.getName(), null);
 408                                      }
 409                                  }
 410                              } catch (ParentEntityPersistenceException | javax.validation.ValidationException e) {
 411                                  entityPersistenceException = e;
 412                                  cleanupFailedPersistenceAttempt(instance);
 413                                  break;
 414                              }
 415                          }
 416                      }
 417                  }
 418              }
 419              // Only check validation if not the initial add
 420              if (!entity.isPreAdd()) {
 421                  validate(entity, instance, mergedProperties, validateUnsubmittedProperties);
 422              }
 423              //if validation failed, refresh the current instance so that none of the changes will be persisted
 424              if (entity.isValidationFailure()) {
 425                  //only refresh the instance if it was managed to begin with
 426                  if (persistenceManager.getDynamicEntityDao().getStandardEntityManager().contains(instance)) {
 427                      persistenceManager.getDynamicEntityDao().refresh(instance);
 428                  }
 429  
 430                  //re-initialize the valid properties for the entity in order to deal with the potential of not
 431                  //completely sending over all checkbox/radio fields
 432                  List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
 433                  entityList.add(instance);
 434                  Entity invalid = getRecords(mergedProperties, entityList, null, null, null)[0];
 435                  invalid.setPropertyValidationErrors(entity.getPropertyValidationErrors());
 436                  invalid.setGlobalValidationErrors(entity.getGlobalValidationErrors());
 437                  invalid.overridePropertyValues(entity);
 438  
<abbr title=" 439                  String message = ValidationUtil.buildErrorMessage(invalid.getPropertyValidationErrors(), invalid.getGlobalValidationErrors());"> 439                  String message = ValidationUtil.buildErrorMessage(invalid.getPropertyValidationErrors(), invalid.gðŸ”µ</abbr>
 440                  throw new ValidationException(invalid, message);
 441              } else if (entityPersistenceException != null) {
 442                  throw ExceptionHelper.refineException(entityPersistenceException.getCause());
 443              } else {
 444                  fieldManager.persistMiddleEntities();
 445              }
 446          } catch (IllegalAccessException e) {
 447              throw new PersistenceException(e);
 448          } catch (InstantiationException e) {
 449              throw new PersistenceException(e);
 450          } finally {
 451              session.setFlushMode(originalFlushMode);

 452          }
 453          return instance;
 454      }
 455  
 456      protected boolean attemptToPopulateValue(Property property, FieldManager fieldManager, Serializable instance,
<abbr title=" 457                                               Boolean setId, BasicFieldMetadata metadata, Entity entity, String value) throws IllegalAccessException {"> 457                                               Boolean setId, BasicFieldMetadata metadata, Entity entity, String valðŸ”µ</abbr>
 458          Boolean mutable = metadata.getMutable();
 459          Boolean readOnly = metadata.getReadOnly();
<abbr title=" 460          boolean generalConditionsMet = (mutable == null || mutable) &amp;&amp; (readOnly == null || !readOnly) &amp;&amp; property.getEnabled();"> 460          boolean generalConditionsMet = (mutable == null || mutable) &amp;&amp; (readOnly == null || !readOnly) &amp;&amp; propertyðŸ”µ</abbr>
 461  
 462          if (generalConditionsMet &amp;&amp; value == null) {
 463              boolean currentValueIsNotNull = false;
 464              try {
 465                  currentValueIsNotNull = fieldManager.getFieldValue(instance, property.getName()) != null;
 466              } catch (FieldNotAvailableException e) {
 467                  throw new IllegalArgumentException(e);
 468              }
 469  
 470              boolean valueIsNotNullId = metadata.getFieldType() != SupportedFieldType.ID || setId;
 471              boolean valueIsNotPassword = metadata.getFieldType() != SupportedFieldType.PASSWORD;
 472  
 473              return currentValueIsNotNull &amp;&amp; !entity.isPreAdd() &amp;&amp; valueIsNotNullId &amp;&amp; valueIsNotPassword;
 474          }
 475          return generalConditionsMet;
 476      }
 477  
 478      @Override
<abbr title=" 479      public Entity getRecord(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, Serializable record, Map&lt;String, FieldMetadata&gt; alternateMergedProperties, String pathToTargetObject) {"> 479      public Entity getRecord(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, Serializable record, Map&lt;String, FðŸ”µ</abbr>
 480          List&lt;Serializable&gt; records = new ArrayList&lt;Serializable&gt;(1);
 481          records.add(record);
<abbr title=" 482          Entity[] productEntities = getRecords(primaryMergedProperties, records, alternateMergedProperties, pathToTargetObject, null);"> 482          Entity[] productEntities = getRecords(primaryMergedProperties, records, alternateMergedProperties, pathToTðŸ”µ</abbr>
 483          return productEntities[0];
 484      }
 485  
 486      @Override
<abbr title=" 487      public Entity getRecord(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, Serializable record) {"> 487      public Entity getRecord(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, SerializabðŸ”µ</abbr>
<abbr title=" 488          Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persistencePerspective);"> 488          Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persðŸ”µ</abbr>
 489          return getRecord(mergedProperties, record, null, null);
 490      }
 491  
 492      @Override
<abbr title=" 493      public Entity[] getRecords(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, List&lt;? extends Serializable&gt; records) {"> 493      public Entity[] getRecords(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, List&lt;? ðŸ”µ</abbr>
<abbr title=" 494          Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persistencePerspective);"> 494          Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persðŸ”µ</abbr>
 495          return getRecords(mergedProperties, records, null, null, null);
 496      }
 497  
 498      @Override
<abbr title=" 499      public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persistencePerspective) {"> 499      public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persisteðŸ”µ</abbr>
<abbr title=" 500          return persistenceManager.getDynamicEntityDao().getSimpleMergedProperties(entityName, persistencePerspective);"> 500          return persistenceManager.getDynamicEntityDao().getSimpleMergedProperties(entityName, persistencePerspectiðŸ”µ</abbr>
 501      }
 502  
 503      @Override
<abbr title=" 504      public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, List&lt;? extends Serializable&gt; records) {"> 504      public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, List&lt;? extends Serializable&gt; reðŸ”µ</abbr>
 505          return getRecords(primaryMergedProperties, records, null, null, null);
 506      }
 507  
 508      @Override
 509      public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryUnfilteredMergedProperties,
 510                                 List&lt;? extends Serializable&gt; records,
 511                                 Map&lt;String, FieldMetadata&gt; alternateUnfilteredMergedProperties,
 512                                 String pathToTargetObject) {
<abbr title=" 513          return getRecords(primaryUnfilteredMergedProperties, records, alternateUnfilteredMergedProperties, pathToTargetObject, null);"> 513          return getRecords(primaryUnfilteredMergedProperties, records, alternateUnfilteredMergedProperties, pathToTðŸ”µ</abbr>
 514      }
 515  
 516      @Override
 517      public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryUnfilteredMergedProperties,
 518                                 List&lt;? extends Serializable&gt; records,
 519                                 Map&lt;String, FieldMetadata&gt; alternateUnfilteredMergedProperties,
 520                                 String pathToTargetObject,
 521                                 String[] customCriteria) {
<abbr title=" 522          Map&lt;String, FieldMetadata&gt; primaryMergedProperties = filterOutCollectionMetadata(primaryUnfilteredMergedProperties);"> 522          Map&lt;String, FieldMetadata&gt; primaryMergedProperties = filterOutCollectionMetadata(primaryUnfilteredMergedPrðŸ”µ</abbr>
<abbr title=" 523          Map&lt;String, FieldMetadata&gt; alternateMergedProperties = filterOutCollectionMetadata(alternateUnfilteredMergedProperties);"> 523          Map&lt;String, FieldMetadata&gt; alternateMergedProperties = filterOutCollectionMetadata(alternateUnfilteredMergðŸ”µ</abbr>
 524          Entity[] entities = new Entity[records.size()];
 525          int j = 0;
 526          for (Serializable recordEntity : records) {
 527              Serializable entity;
 528              if (pathToTargetObject != null) {
 529                  try {
 530                      entity = (Serializable) getFieldManager().getFieldValue(recordEntity, pathToTargetObject);
 531                  } catch (Exception e) {
 532                      throw new PersistenceException(e);
 533                  }
 534              } else {
 535                  entity = recordEntity;
 536              }
 537              Entity entityItem = new Entity();
 538              entityItem.setType(new String[] { entity.getClass().getName() });
 539              entities[j] = entityItem;
 540  
 541              List&lt;Property&gt; props = new ArrayList&lt;Property&gt;(primaryMergedProperties.size());
 542              extractPropertiesFromPersistentEntity(primaryMergedProperties, entity, props, customCriteria);
 543              if (alternateMergedProperties != null) {
<abbr title=" 544                  extractPropertiesFromPersistentEntity(alternateMergedProperties, recordEntity, props, customCriteria);"> 544                  extractPropertiesFromPersistentEntity(alternateMergedProperties, recordEntity, props, customCriterðŸ”µ</abbr>
 545              }
 546  
 547              // Try to add the &quot;main name&quot; property. Log a debug message if we can&#x27;t
 548              try {
 549                  Property p = new Property();
 550                  p.setName(MAIN_ENTITY_NAME_PROPERTY);
 551                  String mainEntityName = (String) MethodUtils.invokeMethod(entity, &quot;getMainEntityName&quot;);
 552                  p.setValue(mainEntityName);
 553                  props.add(p);
 554              } catch (Exception e) {
 555                  LOG.debug(String.format(&quot;Could not execute the getMainEntityName() method for [%s]&quot;,
 556                          entity.getClass().getName()), e);
 557              }
 558  
 559              // Try to add the alternate id property if available
 560              if (alternateMergedProperties != null) {
 561                  for (Entry&lt;String, FieldMetadata&gt; entry : alternateMergedProperties.entrySet()) {
 562                      if (entry.getValue() instanceof BasicFieldMetadata) {
 563                          if (((BasicFieldMetadata) entry.getValue()).getFieldType() == SupportedFieldType.ID) {
 564                              Map&lt;String, FieldMetadata&gt; alternateOnEntity = new HashMap&lt;String, FieldMetadata&gt;();
 565                              alternateOnEntity.put(entry.getKey(), entry.getValue());
 566                              List&lt;Property&gt; props2 = new ArrayList&lt;Property&gt;();
<abbr title=" 567                              extractPropertiesFromPersistentEntity(alternateOnEntity, recordEntity, props2, customCriteria);"> 567                              extractPropertiesFromPersistentEntity(alternateOnEntity, recordEntity, props2, customCðŸ”µ</abbr>
 568                              List&lt;Property&gt; filtered = new ArrayList&lt;Property&gt;();
 569                              for (Property prop : props2) {
 570                                  if (!prop.getName().startsWith(&quot;__&quot;)) {
 571                                      filtered.add(prop);
 572                                  }
 573                              }
 574                              if (filtered.size() == 1 &amp;&amp; !filtered.get(0).getName().contains(&quot;.&quot;)) {
 575                                  Property alternateIdProp = filtered.get(0);
 576                                  alternateIdProp.setName(ALTERNATE_ID_PROPERTY);
 577                                  props.add(alternateIdProp);
 578                              }
 579                          }
 580                      }
 581                  }
 582              }
 583  
 584              Property[] properties = new Property[props.size()];
 585              properties = props.toArray(properties);
 586              entityItem.setProperties(properties);
 587              j++;
 588          }
 589  
 590          return entities;
 591      }
 592  
 593      @Override
 594      public Entity[] getRecords(FetchExtractionRequest fetchExtractionRequest) {
 595          return fetchWrapper.getRecords(fetchExtractionRequest);
 596      }
 597  
 598      protected void extractPropertiesFromPersistentEntity(Map&lt;String, FieldMetadata&gt; mergedProperties,
 599                                                           Serializable entity,
 600                                                           List&lt;Property&gt; props,
 601                                                           String[] customCriteria) {
 602          FieldManager fieldManager = getFieldManager();
 603          try {
 604              if (entity instanceof AdminMainEntity) {
 605                  //Create an invisible property for the admin main entity name, if applicable.
 606                  //This is useful for ToOneLookups if that ToOneLookup uses AdminMainEntity to drive
 607                  //its display name.
 608                  try {
 609                      Property propertyItem = new Property();
 610                      propertyItem.setName(AdminMainEntity.MAIN_ENTITY_NAME_PROPERTY);
 611                      propertyItem.setValue(((AdminMainEntity) entity).getMainEntityName());
 612                      props.add(propertyItem);
 613                  } catch (Exception e) {
<abbr title=" 614                      //do nothing here except for not add the property. Exceptions could occur when there is a validation"> 614                      //do nothing here except for not add the property. Exceptions could occur when there is a valiðŸ”µ</abbr>
<abbr title=" 615                      //issue and some properties/relationships that are used for gleaning the main entity name end up"> 615                      //issue and some properties/relationships that are used for gleaning the main entity name end ðŸ”µ</abbr>
 616                      //not being set
 617                  }
 618              }
 619              for (Entry&lt;String, FieldMetadata&gt; entry : mergedProperties.entrySet()) {
 620                  String property = entry.getKey();
 621                  BasicFieldMetadata metadata = (BasicFieldMetadata) entry.getValue();
<abbr title=" 622                  if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(entity.getClass()) || entity.getClass().isAssignableFrom(Class.forName(metadata.getInheritedFromType()))) {"> 622                  if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(entity.getClass()) || entity.gðŸ”µ</abbr>
 623                      boolean proceed = true;
 624                      if (property.contains(&quot;.&quot;)) {
 625                          StringTokenizer tokens = new StringTokenizer(property, &quot;.&quot;);
 626                          Object testObject = entity;
 627                          while (tokens.hasMoreTokens()) {
 628                              String token = tokens.nextToken();
 629                              if (tokens.hasMoreTokens()) {
 630                                  try {
 631                                      testObject = fieldManager.getFieldValue(testObject, token);
 632                                  } catch (FieldNotAvailableException e) {
 633                                      proceed = false;
 634                                      break;
 635                                  }
 636                                  if (testObject == null) {
 637                                      Property propertyItem = new Property();
 638                                      propertyItem.setName(property);
 639                                      if (props.contains(propertyItem)) {
 640                                          proceed = false;
 641                                          break;
 642                                      }
 643                                      propertyItem.setValue(null);
 644                                      props.add(propertyItem);
 645                                      proceed = false;
 646                                      break;
 647                                  }
 648                              }
 649                          }
 650                      }
 651                      if (!proceed) {
 652                          continue;
 653                      }
 654  
 655                      boolean isFieldAccessible = true;
 656                      Object value = null;
 657                      try {
 658                          value = fieldManager.getFieldValue(entity, property);
 659                      } catch (FieldNotAvailableException e) {
 660                          isFieldAccessible = false;
 661                      }
 662                      checkField:
 663                      {
 664                          if (isFieldAccessible) {
 665                              Property propertyItem = new Property();
 666                              propertyItem.setName(property);
 667                              if (props.contains(propertyItem)) {
 668                                  continue;
 669                              }
 670                              props.add(propertyItem);
 671                              String displayVal = propertyItem.getDisplayValue();
 672                              boolean handled = false;
 673                              for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {
 674                                  MetadataProviderResponse response = fieldPersistenceProvider.extractValue(
 675                                          new ExtractValueRequest(props, fieldManager, metadata, value, displayVal,
 676                                                  persistenceManager, this, entity, customCriteria), propertyItem);
 677                                  if (MetadataProviderResponse.NOT_HANDLED != response) {
 678                                      handled = true;
 679                                  }
 680                                  if (MetadataProviderResponse.HANDLED_BREAK == response) {
 681                                      break;
 682                                  }
 683                              }
 684                              if (!handled) {
 685                                  defaultFieldPersistenceProvider.extractValue(
 686                                          new ExtractValueRequest(props, fieldManager, metadata, value, displayVal,
 687                                                  persistenceManager, this, entity, customCriteria), propertyItem);
 688                              }
 689                              break checkField;
 690                          }
 691                          //try a direct property acquisition via reflection
 692                          try {
 693                              String strVal = null;
 694                              Method method;
 695                              try {
 696                                  //try a &#x27;get&#x27; prefixed mutator first
<abbr title=" 697                                  String temp = &quot;get&quot; + property.substring(0, 1).toUpperCase() + property.substring(1, property.length());"> 697                                  String temp = &quot;get&quot; + property.substring(0, 1).toUpperCase() + property.substring(ðŸ”µ</abbr>
 698                                  method = entity.getClass().getMethod(temp, new Class[] {});
 699                              } catch (NoSuchMethodException e) {
 700                                  method = entity.getClass().getMethod(property, new Class[] {});
 701                              }
 702                              value = method.invoke(entity, new String[] {});
 703                              Property propertyItem = new Property();
 704                              propertyItem.setName(property);
 705                              if (props.contains(propertyItem)) {
 706                                  continue;
 707                              }
 708                              props.add(propertyItem);
 709                              if (value == null) {
 710                                  strVal = null;
 711                              } else {
 712                                  if (Date.class.isAssignableFrom(value.getClass())) {
 713                                      strVal = getSimpleDateFormatter().format((Date) value);
 714                                  } else if (Timestamp.class.isAssignableFrom(value.getClass())) {
<abbr title=" 715                                      strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value).getTime()));"> 715                                      strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value).getTime(ðŸ”µ</abbr>
 716                                  } else if (Calendar.class.isAssignableFrom(value.getClass())) {
 717                                      strVal = getSimpleDateFormatter().format(((Calendar) value).getTime());
 718                                  } else if (Double.class.isAssignableFrom(value.getClass())) {
 719                                      strVal = getDecimalFormatter().format(value);
 720                                  } else if (BigDecimal.class.isAssignableFrom(value.getClass())) {
 721                                      strVal = getDecimalFormatter().format(value);
 722                                  } else {
 723                                      strVal = value.toString();
 724                                  }
 725                              }
 726                              propertyItem.setValue(strVal);
 727                          } catch (NoSuchMethodException e) {
<abbr title=" 728                              LOG.debug(&quot;Unable to find a specified property in the entity: &quot; + StringUtil.sanitize(property));"> 728                              LOG.debug(&quot;Unable to find a specified property in the entity: &quot; + StringUtil.sanitize(ðŸ”µ</abbr>
 729                              //do nothing - this property is simply not in the bean
 730                          }
 731                      }
 732                  }
 733              }
 734          } catch (ClassNotFoundException e) {
 735              throw new PersistenceException(e);
 736          } catch (IllegalAccessException e) {
 737              throw new PersistenceException(e);
 738          } catch (InvocationTargetException e) {
 739              throw new PersistenceException(e);
 740          }
 741      }
 742  
 743      @Override
 744      public String getStringValueFromGetter(Serializable instance, String propertyName)
 745              throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
 746          Object value = PropertyUtils.getProperty(instance, propertyName);
 747          return formatValue(value);
 748      }
 749  
 750      @Override
 751      public String formatValue(Object value) {
 752          String strVal;
 753          if (value == null) {
 754              strVal = null;
 755          } else {
 756              if (Date.class.isAssignableFrom(value.getClass())) {
 757                  strVal = getSimpleDateFormatter().format((Date) value);
 758              } else if (Timestamp.class.isAssignableFrom(value.getClass())) {
 759                  strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value).getTime()));
 760              } else if (Calendar.class.isAssignableFrom(value.getClass())) {
 761                  strVal = getSimpleDateFormatter().format(((Calendar) value).getTime());
 762              } else if (Double.class.isAssignableFrom(value.getClass())) {
 763                  strVal = getDecimalFormatter().format(value);
 764              } else if (BigDecimal.class.isAssignableFrom(value.getClass())) {
 765                  strVal = getDecimalFormatter().format(value);
 766              } else {
 767                  strVal = value.toString();
 768              }
 769          }
 770          return strVal;
 771      }
 772  
<abbr title=" 773      protected EntityResult update(PersistencePackage persistencePackage, Object primaryKey, boolean includeRealEntity) throws ServiceException {"> 773      protected EntityResult update(PersistencePackage persistencePackage, Object primaryKey, boolean includeRealEntðŸ”µ</abbr>
 774          EntityResult entityResult = new EntityResult();
 775          Entity entity = persistencePackage.getEntity();
 776          PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title=" 777          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);"> 777          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistenðŸ”µ</abbr>
 778          if (foreignKey != null &amp;&amp; !foreignKey.getMutable()) {
 779              throw new SecurityServiceException(&quot;Entity not mutable&quot;);
 780          }
 781          try {
<abbr title=" 782              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());"> 782              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFulðŸ”µ</abbr>
<abbr title=" 783              Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties("> 783              Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperðŸ”µ</abbr>
 784                      persistencePackage.getCeilingEntityFullyQualifiedClassname(),
 785                      entities,
 786                      foreignKey,
 787                      persistencePerspective.getAdditionalNonPersistentProperties(),
 788                      persistencePerspective.getAdditionalForeignKeys(),
 789                      MergedPropertyType.PRIMARY,
 790                      persistencePerspective.getPopulateToOneFields(),
 791                      persistencePerspective.getIncludeFields(),
 792                      persistencePerspective.getExcludeFields(),
 793                      persistencePerspective.getConfigurationKey(),
 794                      &quot;&quot;
 795                      );
 796              if (primaryKey == null) {
 797                  primaryKey = getPrimaryKey(entity, mergedProperties);
 798              }
<abbr title=" 799              Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getType()[0]), primaryKey);"> 799              Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getTypeðŸ”µ</abbr>
 800  
 801              Assert.isTrue(instance != null, &quot;Entity not found&quot;);
 802  
 803              if (!entity.isValidationFailure()) {
 804                  //Re-Balance the list if it is a Foreign Key toMany collection with a sort field property
 805                  if (foreignKey != null &amp;&amp; foreignKey.getSortField() != null &amp;&amp;
 806                          entity.findProperty(foreignKey.getSortField()) != null &amp;&amp;
 807                          entity.findProperty(foreignKey.getSortField()).getValue() != null) {
 808                      ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;();
 809                      extensionManager.getProxy().rebalanceForUpdate(this, persistencePackage, instance,
 810                              mergedProperties, primaryKey, result);
 811                      instance = result.getResult();
 812                  } else {
<abbr title=" 813                      instance = createPopulatedInstance(instance, entity, mergedProperties, false, persistencePackage.isValidateUnsubmittedProperties());"> 813                      instance = createPopulatedInstance(instance, entity, mergedProperties, false, persistencePackaðŸ”µ</abbr>
 814                  }
 815  
 816                  instance = persistenceManager.getDynamicEntityDao().merge(instance);
 817                  if (includeRealEntity) {
 818                      entityResult.setEntityBackingObject(instance);
 819                  }
 820  
 821                  List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
 822                  entityList.add(instance);
 823  
 824                  entity = getRecords(mergedProperties, entityList, null, null, null)[0];
 825                  entityResult.setEntity(entity);
 826                  return entityResult;
 827              } else {
 828                  entityResult.setEntity(entity);
 829                  return entityResult;
 830              }
 831          } catch (Exception e) {
 832              throw new ServiceException(&quot;Problem updating entity : &quot; + e.getMessage(), e);
 833          }
 834      }
 835  
 836      @Override
 837      public String getIdPropertyName(String entityClass) {
 838          return persistenceManager.getIdPropertyName(entityClass);
 839      }
 840  
 841      public String getIdPropertyName(Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
 842          Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);
 843          for (String property : mergedProperties.keySet()) {
 844              BasicFieldMetadata temp = (BasicFieldMetadata) mergedProperties.get(property);
 845              if (temp.getFieldType() == SupportedFieldType.ID &amp;&amp; !property.contains(&quot;.&quot;)) {
 846                  return property;
 847              }
 848          }
 849  
 850          throw new RuntimeException(&quot;Could not find a primary key property in the passed merged properties list&quot;);
 851      }
 852  
 853      @Override
 854      public Object getPrimaryKey(Entity entity, Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
 855          Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);
 856          Object primaryKey = null;
 857          String idPropertyName = null;
 858          BasicFieldMetadata metaData = null;
 859          for (String property : mergedProperties.keySet()) {
 860              BasicFieldMetadata temp = (BasicFieldMetadata) mergedProperties.get(property);
 861              if (temp.getFieldType() == SupportedFieldType.ID &amp;&amp; !property.contains(&quot;.&quot;)) {
 862                  idPropertyName = property;
 863                  metaData = temp;
 864                  break;
 865              }
 866          }
 867          if (idPropertyName == null) {
<abbr title=" 868              throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: &quot; + entity.getType()[0]);"> 868              throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: &quot; + ðŸ”µ</abbr>
 869          }
 870          for (Property property : entity.getProperties()) {
 871              if (property.getName().equals(idPropertyName)) {
 872                  switch (metaData.getSecondaryType()) {
 873                      case INTEGER:
 874                          primaryKey = (property.getValue() == null) ? null : Long.valueOf(property.getValue());
 875                          break;
 876                      case STRING:
 877                          primaryKey = property.getValue();
 878                          break;
 879                  }
 880                  break;
 881              }
 882          }
 883          if (primaryKey == null) {
<abbr title=" 884              throw new RuntimeException(&quot;Could not find the primary key property (&quot; + idPropertyName + &quot;) in the passed entity with type: &quot; + entity.getType()[0]);"> 884              throw new RuntimeException(&quot;Could not find the primary key property (&quot; + idPropertyName + &quot;) in the paðŸ”µ</abbr>
 885          }
 886          return primaryKey;
 887      }
 888  
 889      @Override
 890      public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective,
 891              CriteriaTransferObject cto,
 892              String ceilingEntityFullyQualifiedClassname,
 893              Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties,
 894              RestrictionFactory customRestrictionFactory) {
 895          Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);
 896          List&lt;FilterMapping&gt; filterMappings = new ArrayList&lt;FilterMapping&gt;();
 897  
 898          for (String propertyId : cto.getCriteriaMap().keySet()) {
 899              if (mergedProperties.containsKey(propertyId)) {
 900                  boolean handled = false;
 901                  for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {
 902                      MetadataProviderResponse response = fieldPersistenceProvider.addSearchMapping(
 903                              new AddSearchMappingRequest(persistencePerspective, cto,
 904                                      ceilingEntityFullyQualifiedClassname, mergedProperties,
<abbr title=" 905                                      propertyId, getFieldManager(), this, this, customRestrictionFactory==null?restrictionFactory"> 905                                      propertyId, getFieldManager(), this, this, customRestrictionFactory==null?restðŸ”µ</abbr>
 906                                      :customRestrictionFactory), filterMappings);
 907                      if (MetadataProviderResponse.NOT_HANDLED != response) {
 908                          handled = true;
 909                      }
 910                      if (MetadataProviderResponse.HANDLED_BREAK == response) {
 911                          break;
 912                      }
 913                  }
 914                  if (!handled) {
 915                      defaultFieldPersistenceProvider.addSearchMapping(
 916                              new AddSearchMappingRequest(persistencePerspective, cto,
 917                                      ceilingEntityFullyQualifiedClassname, mergedProperties, propertyId,
<abbr title=" 918                                      getFieldManager(), this, this, customRestrictionFactory == null ? restrictionFactory"> 918                                      getFieldManager(), this, this, customRestrictionFactory == null ? restrictionFðŸ”µ</abbr>
 919                                              : customRestrictionFactory), filterMappings);
 920                  }
 921              }
 922          }
 923          return filterMappings;
 924      }
 925  
 926      @Override
 927      public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective,
 928              CriteriaTransferObject cto,
 929              String ceilingEntityFullyQualifiedClassname,
 930              Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
<abbr title=" 931          return getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergedUnfilteredProperties, null);"> 931          return getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergedUnfilterðŸ”µ</abbr>
 932      }
 933  
 934      @Override
<abbr title=" 935      public void extractProperties(Class&lt;?&gt;[] inheritanceLine, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; mergedProperties, List&lt;Property&gt; properties) {"> 935      public void extractProperties(Class&lt;?&gt;[] inheritanceLine, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; ðŸ”µ</abbr>
<abbr title=" 936          extractPropertiesFromMetadata(inheritanceLine, mergedProperties.get(MergedPropertyType.PRIMARY), properties, false, MergedPropertyType.PRIMARY);"> 936          extractPropertiesFromMetadata(inheritanceLine, mergedProperties.get(MergedPropertyType.PRIMARY), propertieðŸ”µ</abbr>
 937      }
 938  
<abbr title=" 939      protected void extractPropertiesFromMetadata(Class&lt;?&gt;[] inheritanceLine, Map&lt;String, FieldMetadata&gt; mergedProperties, List&lt;Property&gt; properties, Boolean isHiddenOverride, MergedPropertyType type) {"> 939      protected void extractPropertiesFromMetadata(Class&lt;?&gt;[] inheritanceLine, Map&lt;String, FieldMetadata&gt; mergedPropðŸ”µ</abbr>
 940          Comparator&lt;Property&gt; comparator = new Comparator&lt;Property&gt;() {
 941  
 942              @Override
 943              public int compare(Property o1, Property o2) {
 944                  return o1.getName().compareTo(o2.getName());
 945              }
 946          };
 947          Collections.sort(properties, comparator);
 948          for (Map.Entry&lt;String, FieldMetadata&gt; entry : mergedProperties.entrySet()) {
 949              String property = entry.getKey();
 950              Property prop = new Property();
 951              FieldMetadata metadata = mergedProperties.get(property);
 952              prop.setName(property);
 953  
 954              int pos = Collections.binarySearch(properties, prop, comparator);
<abbr title=" 955              if (pos &gt;= 0 &amp;&amp; MergedPropertyType.MAPSTRUCTUREKEY != type &amp;&amp; MergedPropertyType.MAPSTRUCTUREVALUE != type) {"> 955              if (pos &gt;= 0 &amp;&amp; MergedPropertyType.MAPSTRUCTUREKEY != type &amp;&amp; MergedPropertyType.MAPSTRUCTUREVALUE != ðŸ”µ</abbr>
 956                  logWarn: {
<abbr title=" 957                      if ((metadata instanceof BasicFieldMetadata) &amp;&amp; SupportedFieldType.ID.equals(((BasicFieldMetadata) metadata).getFieldType())) {"> 957                      if ((metadata instanceof BasicFieldMetadata) &amp;&amp; SupportedFieldType.ID.equals(((BasicFieldMetadðŸ”µ</abbr>
 958                          //don&#x27;t warn for id field collisions, but still ignore the colliding fields
 959                          break logWarn;
 960                      }
<abbr title=" 961                      //LOG.warn(&quot;Detected a field name collision (&quot; + metadata.getTargetClass() + &quot;.&quot; + property + &quot;) during inspection for the inheritance line starting with (&quot; + inheritanceLine[0].getName() + &quot;). Ignoring the additional field. This can occur most commonly when using the @AdminPresentationAdornedTargetCollection and the collection type and target class have field names in common. This situation should be avoided, as the system will strip the repeated fields, which can cause unpredictable behavior.&quot;);"> 961                      //LOG.warn(&quot;Detected a field name collision (&quot; + metadata.getTargetClass() + &quot;.&quot; + property + ðŸ”µ</abbr>
 962                  }
 963                  continue;
 964              } else if (pos &lt; 0) {
 965                  pos = -pos - 1; // calculate position to insert
 966              }
 967              properties.add(pos, prop);
 968              prop.setMetadata(metadata);
 969              if (isHiddenOverride &amp;&amp; prop.getMetadata() instanceof BasicFieldMetadata) {
 970                  //this only makes sense for non collection types
 971                  ((BasicFieldMetadata) prop.getMetadata()).setVisibility(VisibilityEnum.HIDDEN_ALL);
 972              }
 973          }
 974      }
 975  
 976      @Override
<abbr title=" 977      public void updateMergedProperties(PersistencePackage persistencePackage, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; allMergedProperties) throws ServiceException {"> 977      public void updateMergedProperties(PersistencePackage persistencePackage, Map&lt;MergedPropertyType, Map&lt;String, ðŸ”µ</abbr>
<abbr title=" 978          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();"> 978          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname()ðŸ”µ</abbr>
 979          try {
 980              PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
 981              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(ceilingEntityFullyQualifiedClassname);
<abbr title=" 982              Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties("> 982              Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperðŸ”µ</abbr>
 983                      ceilingEntityFullyQualifiedClassname,
 984                      entities,
<abbr title=" 985                      (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),"> 985                      (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectivðŸ”µ</abbr>
 986                      persistencePerspective.getAdditionalNonPersistentProperties(),
 987                      persistencePerspective.getAdditionalForeignKeys(),
 988                      MergedPropertyType.PRIMARY,
 989                      persistencePerspective.getPopulateToOneFields(),
 990                      persistencePerspective.getIncludeFields(),
 991                      persistencePerspective.getExcludeFields(),
 992                      persistencePerspective.getConfigurationKey(),
 993                      &quot;&quot;
 994                      );
 995              allMergedProperties.put(MergedPropertyType.PRIMARY, mergedProperties);
 996          } catch (Exception e) {
 997              throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);
 998          }
 999      }
1000  
1001      @Override
<abbr title="1002      public EntityResult update(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServiceException {">1002      public EntityResult update(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServðŸ”µ</abbr>
1003          return update(persistencePackage, null, true);
1004      }
1005  
1006      @Override
1007      public Entity update(PersistencePackage persistencePackage) throws ServiceException {
1008          EntityResult er = update(persistencePackage, null, false);
1009          return er.getEntity();
1010      }
1011  
1012      @Override
1013      public Entity add(PersistencePackage persistencePackage) throws ServiceException {
1014          EntityResult entityResult = add(persistencePackage, false);
1015          return entityResult.getEntity();
1016      }
1017  
1018      @Override
<abbr title="1019      public EntityResult add(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServiceException {">1019      public EntityResult add(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServiceðŸ”µ</abbr>
1020          EntityResult entityResult = new EntityResult();
1021          Entity entity = persistencePackage.getEntity();
1022          PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1023          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1023          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistenðŸ”µ</abbr>
1024          if (foreignKey != null &amp;&amp; !foreignKey.getMutable()) {
1025              throw new SecurityServiceException(&quot;Entity not mutable&quot;);
1026          }
1027          try {
<abbr title="1028              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());">1028              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFulðŸ”µ</abbr>
<abbr title="1029              Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(">1029              Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMeðŸ”µ</abbr>
1030                      persistencePackage.getCeilingEntityFullyQualifiedClassname(),
1031                      entities,
1032                      foreignKey,
1033                      persistencePerspective.getAdditionalNonPersistentProperties(),
1034                      persistencePerspective.getAdditionalForeignKeys(),
1035                      MergedPropertyType.PRIMARY,
1036                      persistencePerspective.getPopulateToOneFields(),
1037                      persistencePerspective.getIncludeFields(),
1038                      persistencePerspective.getExcludeFields(),
1039                      persistencePerspective.getConfigurationKey(),
1040                      &quot;&quot;
1041                      );
1042              Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);
1043  
1044              String idProperty = null;
1045              for (String property : mergedProperties.keySet()) {
<abbr title="1046                  if (((BasicFieldMetadata) mergedProperties.get(property)).getFieldType() == SupportedFieldType.ID) {">1046                  if (((BasicFieldMetadata) mergedProperties.get(property)).getFieldType() == SupportedFieldType.ID)ðŸ”µ</abbr>
1047                      idProperty = property;
1048                      break;
1049                  }
1050              }
1051              if (idProperty == null) {
<abbr title="1052                  throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: &quot; + entity.getType()[0]);">1052                  throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: ðŸ”µ</abbr>
1053              }
1054              Object primaryKey = null;
1055              try {
1056                  primaryKey = getPrimaryKey(entity, mergedProperties);
1057              } catch (Exception e) {
1058                  //don&#x27;t do anything - this is a valid case
1059              }
1060              if (primaryKey == null) {
1061  
1062                  Serializable instance = (Serializable) Class.forName(entity.getType()[0]).newInstance();
1063  
1064                  instance = createPopulatedInstance(instance, entity, mergedProperties, false);
1065  
1066                  if (foreignKey != null &amp;&amp; foreignKey.getSortField() != null) {
1067                      ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;();
<abbr title="1068                      extensionManager.getProxy().rebalanceForAdd(this, persistencePackage, instance, mergedProperties, result);">1068                      extensionManager.getProxy().rebalanceForAdd(this, persistencePackage, instance, mergedPropertiðŸ”µ</abbr>
1069                      instance = result.getResult();
1070                  }
1071  
1072                  instance = persistenceManager.getDynamicEntityDao().merge(instance);
1073                  if (includeRealEntityObject) {
1074                      entityResult.setEntityBackingObject(instance);
1075                  }
1076                  List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
1077                  entityList.add(instance);
1078  
1079                  entity = getRecords(mergedProperties, entityList, null, null, null)[0];
1080                  entityResult.setEntity(entity);
1081                  return entityResult;
1082              } else {
1083                  return update(persistencePackage, primaryKey, includeRealEntityObject);
1084              }
1085          } catch (Exception e) {
1086              throw new ServiceException(&quot;Problem adding new entity : &quot; + e.getMessage(), e);
1087          }
1088      }
1089  
1090      @Override
1091      public void remove(PersistencePackage persistencePackage) throws ServiceException {
1092          Entity entity = persistencePackage.getEntity();
1093          PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1094          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1094          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistenðŸ”µ</abbr>
1095          if (foreignKey != null &amp;&amp; !foreignKey.getMutable()) {
1096              throw new SecurityServiceException(&quot;Entity not mutable&quot;);
1097          }
1098          try {
<abbr title="1099              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());">1099              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFulðŸ”µ</abbr>
<abbr title="1100              Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(">1100              Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMeðŸ”µ</abbr>
1101                      persistencePackage.getCeilingEntityFullyQualifiedClassname(),
1102                      entities,
1103                      foreignKey,
1104                      persistencePerspective.getAdditionalNonPersistentProperties(),
1105                      persistencePerspective.getAdditionalForeignKeys(),
1106                      MergedPropertyType.PRIMARY,
1107                      persistencePerspective.getPopulateToOneFields(),
1108                      persistencePerspective.getIncludeFields(),
1109                      persistencePerspective.getExcludeFields(),
1110                      persistencePerspective.getConfigurationKey(),
1111                      &quot;&quot;
1112                      );
1113              Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);
1114              Object primaryKey = getPrimaryKey(entity, mergedProperties);
<abbr title="1115              Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getType()[0]), primaryKey);">1115              Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getTypeðŸ”µ</abbr>
1116  
1117              Assert.isTrue(instance != null, &quot;Entity not found&quot;);
1118  
1119              switch (persistencePerspective.getOperationTypes().getRemoveType()) {
1120                  case NONDESTRUCTIVEREMOVE:
1121                      FieldManager fieldManager = getFieldManager();
<abbr title="1122                      FieldMetadata manyToFieldMetadata = mergedUnfilteredProperties.get(foreignKey.getManyToField());">1122                      FieldMetadata manyToFieldMetadata = mergedUnfilteredProperties.get(foreignKey.getManyToField()ðŸ”µ</abbr>
1123                      Object foreignKeyValue = entity.getPMap().get(foreignKey.getManyToField()).getValue();
1124                      try {
1125                          foreignKeyValue = Long.valueOf((String) foreignKeyValue);
1126                      } catch (NumberFormatException e) {
1127                          LOG.warn(&quot;Foreign primary key is not of type Long, assuming String for remove lookup&quot;);
1128                      }
<abbr title="1129                      Serializable foreignInstance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(foreignKey.getForeignKeyClass()), foreignKeyValue);">1129                      Serializable foreignInstance = persistenceManager.getDynamicEntityDao().retrieve(Class.forNameðŸ”µ</abbr>
<abbr title="1130                      Collection collection = (Collection) fieldManager.getFieldValue(foreignInstance, foreignKey.getOriginatingField());">1130                      Collection collection = (Collection) fieldManager.getFieldValue(foreignInstance, foreignKey.geðŸ”µ</abbr>
1131                      collection.remove(instance);
<abbr title="1132                      // if this is a bi-directional @OneToMany/@ManyToOne and there is no @JoinTable (just a foreign key on">1132                      // if this is a bi-directional @OneToMany/@ManyToOne and there is no @JoinTable (just a foreigðŸ”µ</abbr>
1133                      // the @ManyToOne side) then it will not be updated. In that instance, we have to explicitly
1134                      // set the manyTo field to null so that subsequent lookups will not find it
1135                      if (manyToFieldMetadata instanceof BasicFieldMetadata) {
1136                          if (BooleanUtils.isTrue(((BasicFieldMetadata) manyToFieldMetadata).getRequired())) {
<abbr title="1137                              throw new ServiceException(&quot;Could not remove from the collection as the ManyToOne side is a&quot;">1137                              throw new ServiceException(&quot;Could not remove from the collection as the ManyToOne sideðŸ”µ</abbr>
<abbr title="1138                                      + &quot; non-optional relationship. Consider changing &#x27;optional=true&#x27; in the @ManyToOne annotation&quot;">1138                                      + &quot; non-optional relationship. Consider changing &#x27;optional=true&#x27; in the @ManyTðŸ”µ</abbr>
1139                                      + &quot; or nullable=true within the @JoinColumn annotation&quot;);
1140                          }
<abbr title="1141                          //Since this is occuring on a remove persistence package, merge up-front (before making a change) for proper operation in the presence of the enterprise module">1141                          //Since this is occuring on a remove persistence package, merge up-front (before making a ðŸ”µ</abbr>
1142                          instance = persistenceManager.getDynamicEntityDao().merge(instance);
<abbr title="1143                          Field manyToField = fieldManager.getField(instance.getClass(), foreignKey.getManyToField());">1143                          Field manyToField = fieldManager.getField(instance.getClass(), foreignKey.getManyToField()ðŸ”µ</abbr>
1144                          Object manyToObject = manyToField.get(instance);
<abbr title="1145                          if (manyToObject != null &amp;&amp; !(manyToObject instanceof Collection) &amp;&amp; !(manyToObject instanceof Map)) {">1145                          if (manyToObject != null &amp;&amp; !(manyToObject instanceof Collection) &amp;&amp; !(manyToObject instanðŸ”µ</abbr>
1146                              manyToField.set(instance, null);
1147                              instance = persistenceManager.getDynamicEntityDao().merge(instance);
1148                          }
1149                      }
1150                      break;
1151                  case BASIC:
1152                      persistenceManager.getDynamicEntityDao().remove(instance);
1153                      break;
1154              }
1155          } catch (Exception e) {
1156              throw new ServiceException(&quot;Problem removing entity : &quot; + e.getMessage(), e);
1157          }
1158      }
1159  
1160      public Map&lt;String, FieldMetadata&gt; getMergedProperties(PersistencePackage persistencePackage,
1161              CriteriaTransferObject cto) throws ServiceException {
1162          PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1163          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();">1163          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname()ðŸ”µ</abbr>
1164  
1165          if (StringUtils.isEmpty(persistencePackage.getFetchTypeFullyQualifiedClassname())) {
1166              persistencePackage.setFetchTypeFullyQualifiedClassname(ceilingEntityFullyQualifiedClassname);
1167          }
1168  
1169          try {
<abbr title="1170              Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualifiedClassname));">1170              Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(ClðŸ”µ</abbr>
1171  
<abbr title="1172              Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(">1172              Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperðŸ”µ</abbr>
1173                      ceilingEntityFullyQualifiedClassname,
1174                      entities,
<abbr title="1175                      (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),">1175                      (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectivðŸ”µ</abbr>
1176                      persistencePerspective.getAdditionalNonPersistentProperties(),
1177                      persistencePerspective.getAdditionalForeignKeys(),
1178                      MergedPropertyType.PRIMARY,
1179                      persistencePerspective.getPopulateToOneFields(),
1180                      persistencePerspective.getIncludeFields(),
1181                      persistencePerspective.getExcludeFields(),
1182                      persistencePerspective.getConfigurationKey(),
1183                      &quot;&quot;
1184                      );
1185  
1186              return mergedProperties;
1187          } catch (Exception e) {
1188              throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);
1189          }
1190      }
1191  
1192      @Override
<abbr title="1193      public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto) throws ServiceException {">1193      public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto) throws ServicðŸ”µ</abbr>
1194          Entity[] payload;
1195          int totalRecords;
1196          PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1197          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();">1197          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname()ðŸ”µ</abbr>
<abbr title="1198          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1198          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistenðŸ”µ</abbr>
1199  
1200          try {
1201              if (foreignKey != null &amp;&amp; foreignKey.getSortField() != null) {
1202                  FilterAndSortCriteria sortCriteria = cto.get(foreignKey.getSortField());
1203                  sortCriteria.setSortAscending(foreignKey.getSortAscending());
1204              }
1205  
1206              Map&lt;String, FieldMetadata&gt; mergedProperties = getMergedProperties(persistencePackage, cto);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1207 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1208 +            if (useTranslationSearch) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1209 +                addTranslationSearchIfNeeded(cto, mergedProperties);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1210 +            }</span>
1211              List&lt;FilterMapping&gt; filterMappings = getFilterMappings(persistencePerspective, cto, persistencePackage
1212                      .getFetchTypeFullyQualifiedClassname(), mergedProperties);
1213              List&lt;FilterMapping&gt; standardFilterMappings = new ArrayList&lt;FilterMapping&gt;(filterMappings);
1214              if (CollectionUtils.isNotEmpty(cto.getAdditionalFilterMappings())) {
1215                  standardFilterMappings.addAll(cto.getAdditionalFilterMappings());
1216              }
1217              if (CollectionUtils.isNotEmpty(cto.getNonCountAdditionalFilterMappings())) {
1218                  standardFilterMappings.addAll(cto.getNonCountAdditionalFilterMappings());
1219              }
1220  
1221              FetchRequest fetchRequest = new FetchRequest(persistencePackage, cto,
1222                      persistencePackage.getFetchTypeFullyQualifiedClassname(), standardFilterMappings);
1223              List&lt;Serializable&gt; records = getPersistentRecords(fetchRequest);
1224  
1225              List&lt;FilterMapping&gt; countFilterMappings = new ArrayList&lt;FilterMapping&gt;(filterMappings);
1226              if (CollectionUtils.isNotEmpty(cto.getAdditionalFilterMappings())) {
1227                  countFilterMappings.addAll(cto.getAdditionalFilterMappings());
1228              }
1229              FetchRequest countFetchRequest = new FetchRequest(persistencePackage, cto,
1230                      persistencePackage.getFetchTypeFullyQualifiedClassname(), countFilterMappings);
1231              totalRecords = getTotalRecords(countFetchRequest);
1232  
1233              FetchExtractionRequest fetchExtractionRequest = new FetchExtractionRequest(persistencePackage, cto,
1234                      persistencePackage.getFetchTypeFullyQualifiedClassname(), mergedProperties, records);
1235              payload = getRecords(fetchExtractionRequest);
1236          } catch (Exception e) {
1237              throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);
1238          }
1239  
1240          return new DynamicResultSet(null, payload, totalRecords);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1241 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1242 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="1243 +    private void addTranslationSearchIfNeeded(CriteriaTransferObject cto, Map&lt;String, FieldMetadata&gt; mergedProperties) {">1243 +    private void addTranslationSearchIfNeeded(CriteriaTransferObject cto, Map&lt;String, FieldMetadata&gt; mergedPropertðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1244 +        Map&lt;String, FilterAndSortCriteria&gt; criteriaMap = cto.getCriteriaMap();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1245 +        FilterAndSortCriteria fsc = criteriaMap.get(&quot;translationLocale&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1246 +        List&lt;String&gt; filterValues = new ArrayList&lt;&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1247 +        if (fsc != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1248 +            filterValues = fsc.getFilterValues();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1249 +            criteriaMap.remove(&quot;translationLocale&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1250 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1251 +        //If locale is generic - than we use all locales of this language</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1252 +        //For example, if locale = &quot;en&quot; than we use also &quot;en_GB&quot; and &quot;en_US&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1253 +        if (filterValues.size() &gt; 0 &amp;&amp; filterValues.get(0).indexOf(&quot;_&quot;) &lt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1254 +            String currentLocaleCode = filterValues.get(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1255 +            List&lt;org.broadleafcommerce.common.locale.domain.Locale&gt; locales = localeService.findAllLocales();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1256 +            for (org.broadleafcommerce.common.locale.domain.Locale locale : locales) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="1257 +                if (!locale.getLocaleCode().equals(currentLocaleCode) &amp;&amp; currentLocaleCode.equals(locale.getLocaleCode().substring(0,2))) {">1257 +                if (!locale.getLocaleCode().equals(currentLocaleCode) &amp;&amp; currentLocaleCode.equals(locale.getLocaleðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1258 +                    filterValues.add(locale.getLocaleCode());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1259 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1260 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1261 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1262 +        Iterator&lt;Entry&lt;String, FilterAndSortCriteria&gt;&gt; iterator = criteriaMap.entrySet().iterator();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1263 +        while (iterator.hasNext()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1264 +            Entry&lt;String, FilterAndSortCriteria&gt; next = iterator.next();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1265 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1266 +            final String key = next.getKey();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1267 +            FieldMetadata fieldMetadata = mergedProperties.get(key);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="1268 +            if (fieldMetadata != null &amp;&amp; fieldMetadata instanceof BasicFieldMetadata &amp;&amp; ((BasicFieldMetadata) fieldMetadata).getTranslatable()!=null &amp;&amp; ((BasicFieldMetadata) fieldMetadata).getTranslatable()) {">1268 +            if (fieldMetadata != null &amp;&amp; fieldMetadata instanceof BasicFieldMetadata &amp;&amp; ((BasicFieldMetadata) fielðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1269 +                BasicFieldMetadata basicFieldMetadata = ((BasicFieldMetadata) fieldMetadata);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1270 +                if (next.getValue().getFilterValues().size() &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1271 +                    final String value = next.getValue().getFilterValues().get(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1272 +                    final String targetClass = basicFieldMetadata.getTargetClass();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1273 +                    final String fieldName = basicFieldMetadata.getFieldName();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1274 +                    final String friendlyType = getTranslationFriendlyType(targetClass);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1275 +                    final List&lt;String&gt; localeValues = filterValues;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1276 +                    if (friendlyType != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1277 +                        iterator.remove();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1278 +                        cto.getAdditionalFilterMappings().add(new FilterMapping()</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1279 +                                .withDirectFilterValues(new EmptyFilterValues())</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1280 +                                .withRestriction(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1281 +                                        new Restriction().withPredicateProvider(new PredicateProvider() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1282 +                                            @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1283 +                                            public Predicate buildPredicate(CriteriaBuilder builder,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1284 +                                                                            FieldPathBuilder fieldPathBuilder,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1285 +                                                                            From root,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1286 +                                                                            String ceilingEntity,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1287 +                                                                            String fullPropertyName,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1288 +                                                                            Path explicitPath,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1289 +                                                                            List directValues) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1290 +                                                Subquery subquery =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1291 +                                                        fieldPathBuilder.getCriteria().subquery(Long.class);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1292 +                                                Root transRoot = subquery.from(TranslationImpl.class);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1293 +                                                subquery.select(builder.count(transRoot.get(&quot;id&quot;)));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1294 +                                                Predicate type =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1295 +                                                        builder.equal(transRoot.get(&quot;entityType&quot;), friendlyType);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1296 +                                                Predicate name =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1297 +                                                        builder.equal(transRoot.get(&quot;fieldName&quot;), fieldName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1298 +                                                String[] split = key.split(&quot;\\.&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1299 +                                                Path x = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1300 +                                                for (int i = 0; i &lt; split.length; i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1301 +                                                    if (x == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1302 +                                                        x = root.get(split[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1303 +                                                    } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1304 +                                                        x = x.get(split[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1305 +                                                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1306 +                                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1307 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1308 +                                                String likeValue = &quot;%&quot; + value + &quot;%&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1309 +                                                Predicate transValue =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1310 +                                                        builder.like(transRoot.get(&quot;translatedValue&quot;), likeValue);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1311 +                                                Predicate localeValue =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="1312 +                                                        builder.isTrue(transRoot.get(&quot;localeCode&quot;).in(localeValues));">1312 +                                                        builder.isTrue(transRoot.get(&quot;localeCode&quot;).in(localeValuesðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="1313 +                                                Path y = split.length &gt; 1 ? root.get(split[0]).get(&quot;id&quot;) : root.get(&quot;id&quot;);">1313 +                                                Path y = split.length &gt; 1 ? root.get(split[0]).get(&quot;id&quot;) : root.geðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1314 +                                                Predicate entityId = builder.equal(transRoot.get(&quot;entityId&quot;),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1315 +                                                        y);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1316 +                                                if (localeValues.size() &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="1317 +                                                    subquery.where(builder.and(type, entityId, transValue, name, localeValue));">1317 +                                                    subquery.where(builder.and(type, entityId, transValue, name, lðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1318 +                                                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1319 +                                                    subquery.where(builder.and(type, entityId, transValue, name));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1320 +                                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1321 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1322 +                                                Predicate like = builder.like(x,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1323 +                                                        likeValue);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="1324 +                                                Predicate predicate = builder.or(like, builder.greaterThan(subquery, 0));">1324 +                                                Predicate predicate = builder.or(like, builder.greaterThan(subquerðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1325 +                                                return predicate;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1326 +                                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1327 +                                        })));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1328 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1329 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1330 +                System.out.println(&quot;&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1331 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1332 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1333 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1334 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1335 +    private String getTranslationFriendlyType(String targetClass) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1336 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1337 +        TranslatedEntity instance = TranslatedEntity.getInstance(targetClass);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1338 +        if (instance == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1339 +            try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1340 +                Class&lt;?&gt;[] interfaces = Class.forName(targetClass).getInterfaces();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1341 +                int i = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1342 +                while (instance == null &amp;&amp; i &lt; interfaces.length) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1343 +                    instance = TranslatedEntity.getInstance(interfaces[i].getName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1344 +                    i++;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1345 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1346 +            } catch (ClassNotFoundException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1347 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1348 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1349 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1350 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1351 +        return instance == null ? null : instance.getFriendlyType();</span>
1352      }
1353  
1354      @Override
1355      public Integer getTotalRecords(FetchRequest fetchRequest) {
1356          return fetchWrapper.getTotalRecords(fetchRequest);
1357      }
1358  
1359      @Override
1360      public Integer getTotalRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings) {
1361          try {
1362              return ((Long) criteriaTranslator.translateCountQuery(persistenceManager.getDynamicEntityDao(),
1363                      ceilingEntity, filterMappings).getSingleResult()).intValue();
1364          } catch (CriteriaConversionException e) {
<abbr title="1365              TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntity);">1365              TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntityðŸ”µ</abbr>
<abbr title="1366              return ((Long) builder.toCountQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManager()).getSingleResult()).intValue();">1366              return ((Long) builder.toCountQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManðŸ”µ</abbr>
1367          }
1368      }
1369  
1370      @Override
1371      public Serializable getMaxValue(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, String maxField) {
1372          return criteriaTranslator.translateMaxQuery(persistenceManager.getDynamicEntityDao(),
1373                  ceilingEntity, filterMappings, maxField).getSingleResult();
1374      }
1375  
1376      @Override
1377      public List&lt;Serializable&gt; getPersistentRecords(FetchRequest fetchRequest) {
1378          return fetchWrapper.getPersistentRecords(fetchRequest);
1379      }
1380  
1381      @Override
<abbr title="1382      public List&lt;Serializable&gt; getPersistentRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, Integer firstResult, Integer maxResults) {">1382      public List&lt;Serializable&gt; getPersistentRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, IntegðŸ”µ</abbr>
1383          try {
<abbr title="1384              return criteriaTranslator.translateQuery(persistenceManager.getDynamicEntityDao(), ceilingEntity, filterMappings, firstResult, maxResults).getResultList();">1384              return criteriaTranslator.translateQuery(persistenceManager.getDynamicEntityDao(), ceilingEntity, filtðŸ”µ</abbr>
1385          } catch (CriteriaConversionException e) {
<abbr title="1386              TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntity);">1386              TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntityðŸ”µ</abbr>
<abbr title="1387              return builder.toQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManager()).getResultList();">1387              return builder.toQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManager()).getReðŸ”µ</abbr>
1388          }
1389      }
1390  
1391      @Override
<abbr title="1392      public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperties) {">1392      public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperðŸ”µ</abbr>
1393          return validate(entity, populatedInstance, mergedProperties, true);
1394      }
1395  
1396      @Override
<abbr title="1397      public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperties,">1397      public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperðŸ”µ</abbr>
1398              boolean validateUnsubmittedProperties) {
<abbr title="1399          entityValidatorService.validate(entity, populatedInstance, mergedProperties, this, validateUnsubmittedProperties);">1399          entityValidatorService.validate(entity, populatedInstance, mergedProperties, this, validateUnsubmittedPropðŸ”µ</abbr>
1400          return !entity.isValidationFailure();
1401      }
1402  
1403      @Override
1404      public void setPersistenceManager(PersistenceManager persistenceManager) {
1405          this.persistenceManager = persistenceManager;
1406      }
1407  
1408      @Override
1409      public PersistenceModule getCompatibleModule(OperationType operationType) {
1410          return ((InspectHelper) persistenceManager).getCompatibleModule(operationType);
1411      }
1412  
1413      public FieldPersistenceProvider getDefaultFieldPersistenceProvider() {
1414          return defaultFieldPersistenceProvider;
1415      }
1416  
1417      public void setDefaultFieldPersistenceProvider(FieldPersistenceProvider defaultFieldPersistenceProvider) {
1418          this.defaultFieldPersistenceProvider = defaultFieldPersistenceProvider;
1419      }
1420  
1421      public List&lt;FieldPersistenceProvider&gt; getFieldPersistenceProviders() {
1422          return fieldPersistenceProviders;
1423      }
1424  
1425      public void setFieldPersistenceProviders(List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders) {
1426          this.fieldPersistenceProviders = fieldPersistenceProviders;
1427      }
1428  
1429      public CriteriaTranslator getCriteriaTranslator() {
1430          return criteriaTranslator;
1431      }
1432  
1433      public void setCriteriaTranslator(CriteriaTranslator criteriaTranslator) {
1434          this.criteriaTranslator = criteriaTranslator;
1435      }
1436  
1437      public EntityValidatorService getEntityValidatorService() {
1438          return entityValidatorService;
1439      }
1440  
1441      public void setEntityValidatorService(EntityValidatorService entityValidatorService) {
1442          this.entityValidatorService = entityValidatorService;
1443      }
1444  
1445      public RestrictionFactory getRestrictionFactory() {
1446          return restrictionFactory;
1447      }
1448  
1449      public void setRestrictionFactory(RestrictionFactory restrictionFactory) {
1450          this.restrictionFactory = restrictionFactory;
1451      }
1452  
1453      public PersistenceManager getPersistenceManager() {
1454          return persistenceManager;
1455      }
1456  
1457      /**
<abbr title="1458       * Use an alternate approach to generating a fetch query for a collection located inside of an @Embeddable object. Related">1458       * Use an alternate approach to generating a fetch query for a collection located inside of an @Embeddable objðŸ”µ</abbr>
<abbr title="1459       * to https://hibernate.atlassian.net/browse/HHH-8802. The alternate approach leverages HQL rather than JPA criteria,">1459       * to https://hibernate.atlassian.net/browse/HHH-8802. The alternate approach leverages HQL rather than JPA crðŸ”µ</abbr>
1460       * which seems to alleviate the problem.
1461       *
1462       * @param embeddedCollectionPath the path to the collection field itself
1463       * @param filterMappings all the fetch restrictions for this request
1464       * @param collectionClass the type of the collection members
1465       * @return the builder capable of generating an appropriate HQL query
1466       */
<abbr title="1467      protected TypedQueryBuilder getSpecialCaseQueryBuilder(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; filterMappings, String collectionClass) {">1467      protected TypedQueryBuilder getSpecialCaseQueryBuilder(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; fðŸ”µ</abbr>
1468          String specialPath = embeddedCollectionPath.getTargetProperty();
1469          String[] pieces = specialPath.split(&quot;\\.&quot;);
1470          if (pieces.length != 3) {
<abbr title="1471              throw new CriteriaConversionException(String.format(&quot;Expected to find a target property of format [embedded field].[collection field].[property] for the embedded collection path (%s)&quot;, specialPath), embeddedCollectionPath);">1471              throw new CriteriaConversionException(String.format(&quot;Expected to find a target property of format [embðŸ”µ</abbr>
1472          }
1473          String expression = specialPath.substring(0, specialPath.lastIndexOf(&quot;.&quot;));
1474          TypedQueryBuilder builder;
1475          try {
1476              builder = new TypedQueryBuilder(Class.forName(collectionClass), &quot;specialEntity&quot;)
1477                      .addJoin(new TQJoin(&quot;specialEntity.&quot; + expression, &quot;embeddedCollection&quot;));
1478          } catch (Exception e) {
1479              throw ExceptionHelper.refineException(e);
1480          }
1481          for (TQRestriction restriction : buildSpecialRestrictions(expression, filterMappings)) {
1482              builder = builder.addRestriction(restriction);
1483          }
1484          for (TQRestriction restriction : buildStandardRestrictions(embeddedCollectionPath, filterMappings)) {
1485              builder = builder.addRestriction(restriction);
1486          }
1487          for (FilterMapping mapping : filterMappings) {
1488              if (mapping.getSortDirection() != null) {
<abbr title="1489                  String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().getTargetProperty();">1489                  String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().getTargetPðŸ”µ</abbr>
1490                  if (StringUtils.isEmpty(mappingProperty)) {
1491                      mappingProperty = mapping.getFullPropertyName();
1492                  }
<abbr title="1493                  builder = builder.addOrder(new TQOrder(&quot;specialEntity.&quot; + mappingProperty, SortDirection.ASCENDING == mapping.getSortDirection()));">1493                  builder = builder.addOrder(new TQOrder(&quot;specialEntity.&quot; + mappingProperty, SortDirection.ASCENDINGðŸ”µ</abbr>
1494              }
1495          }
1496  
1497          return builder;
1498      }
1499  
1500      /**
<abbr title="1501       * Generate LIKE or EQUALS restrictions for any filter property specified on the root entity (not the collection field in the @Embeddable object)">1501       * Generate LIKE or EQUALS restrictions for any filter property specified on the root entity (not the collectiðŸ”µ</abbr>
1502       *
<abbr title="1503       * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath, java.util.List, String)">1503       * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteriaðŸ”µ</abbr>
<abbr title="1504       * @param embeddedCollectionPath the path for the collection field in the @Embeddable object - this is what caused the whole thing">1504       * @param embeddedCollectionPath the path for the collection field in the @Embeddable object - this is what caðŸ”µ</abbr>
1505       * @param filterMappings all the fetch restrictions for this request
1506       * @return the list of restrictions on the root entity
1507       */
<abbr title="1508      protected List&lt;TQRestriction&gt; buildStandardRestrictions(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; filterMappings) {">1508      protected List&lt;TQRestriction&gt; buildStandardRestrictions(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; ðŸ”µ</abbr>
<abbr title="1509          String expression = embeddedCollectionPath.getTargetProperty().substring(0, embeddedCollectionPath.getTargetProperty().lastIndexOf(&quot;.&quot;));">1509          String expression = embeddedCollectionPath.getTargetProperty().substring(0, embeddedCollectionPath.getTargðŸ”µ</abbr>
1510          List&lt;TQRestriction&gt; restrictions = new ArrayList&lt;TQRestriction&gt;();
1511          for (FilterMapping mapping : filterMappings) {
1512              checkProperty: {
<abbr title="1513                  String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().getTargetProperty();">1513                  String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().getTargetPðŸ”µ</abbr>
1514                  if (StringUtils.isEmpty(mappingProperty)) {
1515                      mappingProperty = mapping.getFullPropertyName();
1516                  }
<abbr title="1517                  if (!embeddedCollectionPath.getTargetProperty().equals(mappingProperty) &amp;&amp; !StringUtils.isEmpty(mappingProperty)) {">1517                  if (!embeddedCollectionPath.getTargetProperty().equals(mappingProperty) &amp;&amp; !StringUtils.isEmpty(maðŸ”µ</abbr>
1518                      PredicateProvider predicateProvider = mapping.getRestriction().getPredicateProvider();
1519                      if (predicateProvider != null) {
1520                          FilterValueConverter converter = mapping.getRestriction().getFilterValueConverter();
1521                          if (converter != null &amp;&amp; CollectionUtils.isNotEmpty(mapping.getFilterValues())) {
1522                              Object val = converter.convert(mapping.getFilterValues().get(0));
1523                              if (predicateProvider instanceof LikePredicateProvider) {
<abbr title="1524                                  restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;LIKE&quot;, val + &quot;%&quot;));">1524                                  restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;LIKE&quot;, valðŸ”µ</abbr>
1525                                  break checkProperty;
1526                              } else if (predicateProvider instanceof EqPredicateProvider) {
1527                                  restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;=&quot;, val));
1528                                  break checkProperty;
1529                              }
1530                          }
1531                      }
<abbr title="1532                      LOG.warn(String.format(&quot;Unable to filter the embedded collection (%s) on an additional property (%s)&quot;,">1532                      LOG.warn(String.format(&quot;Unable to filter the embedded collection (%s) on an additional propertðŸ”µ</abbr>
1533                              StringUtil.sanitize(expression),
1534                              StringUtil.sanitize(mappingProperty)));
1535                  }
1536              }
1537          }
1538  
1539          return restrictions;
1540      }
1541  
1542      /**
<abbr title="1543       * Generate EQUALS restrictions for any filter property specified on the entity member of the collection field in the @Embeddable object">1543       * Generate EQUALS restrictions for any filter property specified on the entity member of the collection fieldðŸ”µ</abbr>
1544       *
<abbr title="1545       * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath, java.util.List, String)">1545       * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteriaðŸ”µ</abbr>
<abbr title="1546       * @param specialExpression the String representation of the path for the collection field in the @Embeddable object">1546       * @param specialExpression the String representation of the path for the collection field in the @Embeddable ðŸ”µ</abbr>
1547       * @param filterMappings all the fetch restrictions for this request
1548       * @return the list of restrictions on the collection in the @Embeddable object
1549       */
<abbr title="1550      protected List&lt;TQRestriction&gt; buildSpecialRestrictions(String specialExpression, List&lt;FilterMapping&gt; filterMappings) {">1550      protected List&lt;TQRestriction&gt; buildSpecialRestrictions(String specialExpression, List&lt;FilterMapping&gt; filterMapðŸ”µ</abbr>
1551          List&lt;TQRestriction&gt; restrictions = new ArrayList&lt;TQRestriction&gt;();
1552          for (FilterMapping mapping : filterMappings) {
<abbr title="1553              if (mapping.getFieldPath() != null &amp;&amp; mapping.getFieldPath().getTargetProperty() != null &amp;&amp; mapping.getFieldPath().getTargetProperty().startsWith(specialExpression)) {">1553              if (mapping.getFieldPath() != null &amp;&amp; mapping.getFieldPath().getTargetProperty() != null &amp;&amp; mapping.geðŸ”µ</abbr>
1554                  FilterValueConverter converter = mapping.getRestriction().getFilterValueConverter();
1555                  if (converter != null &amp;&amp; CollectionUtils.isNotEmpty(mapping.getFilterValues())) {
1556                      Object val = converter.convert(mapping.getFilterValues().get(0));
<abbr title="1557                      String property = mapping.getFieldPath().getTargetProperty().substring(mapping.getFieldPath().getTargetProperty().lastIndexOf(&quot;.&quot;) + 1, mapping.getFieldPath().getTargetProperty().length());">1557                      String property = mapping.getFieldPath().getTargetProperty().substring(mapping.getFieldPath().ðŸ”µ</abbr>
1558                      restrictions.add(new TQRestriction(&quot;embeddedCollection.&quot; + property, &quot;=&quot;, val));
1559                  }
1560              }
1561          }
1562          return restrictions;
1563      }
1564  
1565      protected void cleanupFailedPersistenceAttempt(Serializable instance) throws IllegalAccessException {
1566          //Remove the entity from ORM management - no further attempts to persist
1567          if (getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().contains(instance)) {
1568              getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().detach(instance);
1569          }
1570          //Remove the id field value, if it&#x27;s set
<abbr title="1571          String idFieldName = (String) getPersistenceManager().getDynamicEntityDao().getIdMetadata(instance.getClass()).get(&quot;name&quot;);">1571          String idFieldName = (String) getPersistenceManager().getDynamicEntityDao().getIdMetadata(instance.getClasðŸ”µ</abbr>
1572          Field idField = FieldUtils.getField(instance.getClass(), idFieldName, true);
1573          if (idField == null) {
<abbr title="1574              throw ExceptionHelper.refineException(new NoSuchFieldException(&quot;Entity &quot; + instance.getClass().getName() + &quot; does not contain id field &quot; + idFieldName));">1574              throw ExceptionHelper.refineException(new NoSuchFieldException(&quot;Entity &quot; + instance.getClass().getNameðŸ”µ</abbr>
1575          }
1576          idField.setAccessible(true);
1577          if (idField.get(instance) != null) {
1578              idField.set(instance, null);
1579          }
1580      }
1581  
1582      protected Class&lt;?&gt; getMapFieldType(Serializable instance, FieldManager fieldManager, Property property) {
1583          Class&lt;?&gt; returnType = null;
<abbr title="1584          Field field = fieldManager.getField(instance.getClass(), property.getName().substring(0, property.getName().indexOf(FieldManager.MAPFIELDSEPARATOR)));">1584          Field field = fieldManager.getField(instance.getClass(), property.getName().substring(0, property.getName(ðŸ”µ</abbr>
1585          java.lang.reflect.Type type = field.getGenericType();
1586          if (type instanceof ParameterizedType) {
1587              ParameterizedType pType = (ParameterizedType) type;
1588              Class&lt;?&gt; clazz;
1589              if (pType.getActualTypeArguments().length &lt; 2) {
1590                  clazz = (Class&lt;?&gt;) pType.getActualTypeArguments()[0];
1591              } else {
1592                  clazz = (Class&lt;?&gt;) pType.getActualTypeArguments()[1];
1593              }
<abbr title="1594              Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(clazz);">1594              Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(clðŸ”µ</abbr>
1595              if (!ArrayUtils.isEmpty(entities)) {
1596                  returnType = entities[entities.length - 1];
1597              }
1598          }
1599          return returnType;
1600      }
1601  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            