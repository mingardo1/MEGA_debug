<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>247</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    247
                    <a href="246.html">prev</a>
                    <a href="248.html">next</a>
                    <a href="247_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_b3a8f80e2ea8de4fb305d7a4141980bc98d629a8_src/com/android/launcher3/DefaultLayoutParser.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;b3a8f80e2ea8de4fb305d7a4141980bc98d629a8:src/com/android/launcher3/DefaultLayoutParser.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;b3a8f80e2ea8de4fb305d7a4141980bc98d629a8^1:src/com/android/launcher3/DefaultLayoutParser.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;b3a8f80e2ea8de4fb305d7a4141980bc98d629a8^2:src/com/android/launcher3/DefaultLayoutParser.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;71701f8145f0eb1017b2d3590fc87babad1d1bd3:src/com/android/launcher3/DefaultLayoutParser.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 package com.android.launcher3;
   2 
   3 import android.appwidget.AppWidgetHost;
   4 import android.content.Context;
   5 import android.content.Intent;
   6 import android.content.pm.ActivityInfo;
   7 import android.content.pm.ApplicationInfo;
   8 import android.content.pm.PackageManager;
   9 import android.content.pm.ResolveInfo;
  10 import android.content.res.Resources;
  11 import android.content.res.XmlResourceParser;
  12 import android.text.TextUtils;
  13 import android.util.Log;
  14 
  15 import com.android.launcher3.LauncherSettings.Favorites;
  16 
  17 import org.xmlpull.v1.XmlPullParser;
  18 import org.xmlpull.v1.XmlPullParserException;
  19 
  20 import java.io.IOException;
  21 import java.net.URISyntaxException;
  22 import java.util.HashMap;
  23 import java.util.List;
  24 
  25 /**
  26  * Implements the layout parser with rules for internal layouts and partner layouts.
  27  */
  28 public class DefaultLayoutParser extends AutoInstallsLayout {
  29     private static final String TAG = &quot;DefaultLayoutParser&quot;;
  30 
  31     protected static final String TAG_RESOLVE = &quot;resolve&quot;;
  32     private static final String TAG_FAVORITES = &quot;favorites&quot;;
  33     protected static final String TAG_FAVORITE = &quot;favorite&quot;;
  34     private static final String TAG_APPWIDGET = &quot;appwidget&quot;;
  35     private static final String TAG_SHORTCUT = &quot;shortcut&quot;;
  36     private static final String TAG_FOLDER = &quot;folder&quot;;
  37     private static final String TAG_PARTNER_FOLDER = &quot;partner-folder&quot;;
  38 
  39 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  40     protected static final String ATTR_URI = &quot;uri&quot;;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  41     private static final String ATTR_WORKSPACE = &quot;workspace&quot;;</span>
  42 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  43     private static final String TAG_INCLUDE = &quot;include&quot;;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  44 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  45     private static final String ATTR_URI = &quot;uri&quot;;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  46     private static final String ATTR_WORKSPACE = &quot;workspace&quot;;</span>
  47 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  48     private static final String ATTR_URI = &quot;uri&quot;;</span>
  49 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  50     private static final String ATTR_CONTAINER = &quot;container&quot;;
  51     private static final String ATTR_SCREEN = &quot;screen&quot;;
  52     private static final String ATTR_FOLDER_ITEMS = &quot;folderItems&quot;;
  53 
  54     public DefaultLayoutParser(Context context, AppWidgetHost appWidgetHost,
  55             LayoutParserCallback callback, Resources sourceRes, int layoutId) {
  56         super(context, appWidgetHost, callback, sourceRes, layoutId, TAG_FAVORITES);
  57     }
  58 
  59     public DefaultLayoutParser(Context context, AppWidgetHost appWidgetHost,
  60             LayoutParserCallback callback, Resources sourceRes, int layoutId, String rootTag,
  61             int hotseatAllAppsRank) {
  62         super(context, appWidgetHost, callback, sourceRes, layoutId, rootTag, hotseatAllAppsRank);
  63     }
  64 
  65     @Override
  66     protected HashMap&lt;String, TagParser&gt; getFolderElementsMap() {
  67         return getFolderElementsMap(mSourceRes);
  68     }
  69 
  70     private HashMap&lt;String, TagParser&gt; getFolderElementsMap(Resources res) {
  71         HashMap&lt;String, TagParser&gt; parsers = new HashMap&lt;String, TagParser&gt;();
  72         parsers.put(TAG_FAVORITE, new AppShortcutWithUriParser());
  73         parsers.put(TAG_SHORTCUT, new UriShortcutParser(res));
  74         return parsers;
  75     }
  76 
  77     @Override
  78     protected HashMap&lt;String, TagParser&gt; getLayoutElementsMap() {
  79         HashMap&lt;String, TagParser&gt; parsers = new HashMap&lt;String, TagParser&gt;();
  80         parsers.put(TAG_FAVORITE, new AppShortcutWithUriParser());
  81         parsers.put(TAG_APPWIDGET, new AppWidgetParser());
  82         parsers.put(TAG_SHORTCUT, new UriShortcutParser(mSourceRes));
  83         parsers.put(TAG_RESOLVE, new ResolveParser());
  84         parsers.put(TAG_FOLDER, new MyFolderParser());
  85         parsers.put(TAG_PARTNER_FOLDER, new PartnerFolderParser());
  86         return parsers;
  87     }
  88 
  89     @Override
  90     protected void parseContainerAndScreen(XmlResourceParser parser, long[] out) {
  91         out[0] = LauncherSettings.Favorites.CONTAINER_DESKTOP;
  92         String strContainer = getAttributeValue(parser, ATTR_CONTAINER);
  93         if (strContainer != null) {
  94             out[0] = Long.valueOf(strContainer);
  95         }
  96         out[1] = Long.parseLong(getAttributeValue(parser, ATTR_SCREEN));
  97     }
  98 
  99     /**
 100      * AppShortcutParser which also supports adding URI based intents
 101      */
 102     private class AppShortcutWithUriParser extends AppShortcutParser {
 103 
 104         @Override
 105         protected long invalidPackageOrClass(XmlResourceParser parser) {
 106             final String uri = getAttributeValue(parser, ATTR_URI);
 107             if (TextUtils.isEmpty(uri)) {
 108                 Log.e(TAG, &quot;Skipping invalid &lt;favorite&gt; with no component or uri&quot;);
 109                 return -1;
 110             }
 111 
 112             final Intent metaIntent;
 113             try {
 114                 metaIntent = Intent.parseUri(uri, 0);
 115             } catch (URISyntaxException e) {
 116                 Log.e(TAG, &quot;Unable to add meta-favorite: &quot; + uri, e);
 117                 return -1;
 118             }
 119 
 120             ResolveInfo resolved = mPackageManager.resolveActivity(metaIntent,
 121                     PackageManager.MATCH_DEFAULT_ONLY);
 122             final List&lt;ResolveInfo&gt; appList = mPackageManager.queryIntentActivities(
 123                     metaIntent, PackageManager.MATCH_DEFAULT_ONLY);
 124 
 125             // Verify that the result is an app and not just the resolver dialog asking which
 126             // app to use.
 127             if (wouldLaunchResolverActivity(resolved, appList)) {
 128                 // If only one of the results is a system app then choose that as the default.
 129                 final ResolveInfo systemApp = getSingleSystemActivity(appList);
 130                 if (systemApp == null) {
 131                     // There is no logical choice for this meta-favorite, so rather than making
 132                     // a bad choice just add nothing.
 133                     Log.w(TAG, &quot;No preference or single system activity found for &quot;
 134                             + metaIntent.toString());
 135                     return -1;
 136                 }
 137                 resolved = systemApp;
 138             }
 139             final ActivityInfo info = resolved.activityInfo;
 140             final Intent intent = mPackageManager.getLaunchIntentForPackage(info.packageName);
 141             if (intent == null) {
 142                 return -1;
 143             }
 144             intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
 145                     Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
 146 
 147             return addShortcut(info.loadLabel(mPackageManager).toString(), intent,
 148                     Favorites.ITEM_TYPE_APPLICATION);
 149         }
 150 
 151         private ResolveInfo getSingleSystemActivity(List&lt;ResolveInfo&gt; appList) {
 152             ResolveInfo systemResolve = null;
 153             final int N = appList.size();
 154             for (int i = 0; i &lt; N; ++i) {
 155                 try {
 156                     ApplicationInfo info = mPackageManager.getApplicationInfo(
 157                             appList.get(i).activityInfo.packageName, 0);
 158                     if ((info.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) {
 159                         if (systemResolve != null) {
 160                             return null;
 161                         } else {
 162                             systemResolve = appList.get(i);
 163                         }
 164                     }
 165                 } catch (PackageManager.NameNotFoundException e) {
 166                     Log.w(TAG, &quot;Unable to get info about resolve results&quot;, e);
 167                     return null;
 168                 }
 169             }
 170             return systemResolve;
 171         }
 172 
 173         private boolean wouldLaunchResolverActivity(ResolveInfo resolved,
 174                 List&lt;ResolveInfo&gt; appList) {
 175             // If the list contains the above resolved activity, then it can&#x27;t be
 176             // ResolverActivity itself.
 177             for (int i = 0; i &lt; appList.size(); ++i) {
 178                 ResolveInfo tmp = appList.get(i);
 179                 if (tmp.activityInfo.name.equals(resolved.activityInfo.name)
 180                         &amp;&amp; tmp.activityInfo.packageName.equals(resolved.activityInfo.packageName)) {
 181                     return false;
 182                 }
 183             }
 184             return true;
 185         }
 186     }
 187 
 188 
 189     /**
 190      * Shortcut parser which allows any uri and not just web urls.
 191      */
 192     private class UriShortcutParser extends ShortcutParser {
 193 
 194         public UriShortcutParser(Resources iconRes) {
 195             super(iconRes);
 196         }
 197 
 198         @Override
 199         protected Intent parseIntent(XmlResourceParser parser) {
 200             String uri = null;
 201             try {
 202                 uri = getAttributeValue(parser, ATTR_URI);
 203                 return Intent.parseUri(uri, 0);
 204             } catch (URISyntaxException e) {
 205                 Log.w(TAG, &quot;Shortcut has malformed uri: &quot; + uri);
 206                 return null; // Oh well
 207             }
 208         }
 209     }
 210 
 211     /**
 212      * Contains a list of &lt;favorite&gt; nodes, and accepts the first successfully parsed node.
 213      */
 214     protected class ResolveParser implements TagParser {
 215 
 216         private final AppShortcutWithUriParser mChildParser = new AppShortcutWithUriParser();
 217 
 218         @Override
 219         public long parseAndAdd(XmlResourceParser parser) throws XmlPullParserException,
 220                 IOException {
 221             final int groupDepth = parser.getDepth();
 222             int type;
 223             long addedId = -1;
 224             while ((type = parser.next()) != XmlPullParser.END_TAG ||
 225                     parser.getDepth() &gt; groupDepth) {
 226                 if (type != XmlPullParser.START_TAG || addedId &gt; -1) {
 227                     continue;
 228                 }
 229                 final String fallback_item_name = parser.getName();
 230                 if (TAG_FAVORITE.equals(fallback_item_name)) {
 231                     addedId = mChildParser.parseAndAdd(parser);
 232                 } else {
 233                     Log.e(TAG, &quot;Fallback groups can contain only favorites, found &quot;
 234                             + fallback_item_name);
 235                 }
 236             }
 237             return addedId;
 238         }
 239     }
 240 
 241     /**
 242      * A parser which adds a folder whose contents come from partner apk.
 243      */
 244     private class PartnerFolderParser implements TagParser {
 245 
 246         @Override
 247         public long parseAndAdd(XmlResourceParser parser) throws XmlPullParserException,
 248                 IOException {
 249             // Folder contents come from an external XML resource
 250             final Partner partner = Partner.get(mPackageManager);
 251             if (partner != null) {
 252                 final Resources partnerRes = partner.getResources();
 253                 final int resId = partnerRes.getIdentifier(Partner.RES_FOLDER,
 254                         &quot;xml&quot;, partner.getPackageName());
 255                 if (resId != 0) {
 256                     final XmlResourceParser partnerParser = partnerRes.getXml(resId);
 257                     beginDocument(partnerParser, TAG_FOLDER);
 258 
 259                     FolderParser folderParser = new FolderParser(getFolderElementsMap(partnerRes));
 260                     return folderParser.parseAndAdd(partnerParser);
 261                 }
 262             }
 263             return -1;
 264         }
 265     }
 266 
 267     /**
 268      * An extension of FolderParser which allows adding items from a different xml.
 269      */
 270     private class MyFolderParser extends FolderParser {
 271 
 272         @Override
 273         public long parseAndAdd(XmlResourceParser parser) throws XmlPullParserException,
 274                 IOException {
 275             final int resId = getAttributeResourceValue(parser, ATTR_FOLDER_ITEMS, 0);
 276             if (resId != 0) {
 277                 parser = mSourceRes.getXml(resId);
 278                 beginDocument(parser, TAG_FOLDER);
 279             }
 280             return super.parseAndAdd(parser);
 281         }
 282     }
 283 }</pre></td>
                            <td><pre>   1 package com.android.launcher3;
   2 
   3 import android.appwidget.AppWidgetHost;
   4 import android.content.Context;
   5 import android.content.Intent;
   6 import android.content.pm.ActivityInfo;
   7 import android.content.pm.ApplicationInfo;
   8 import android.content.pm.PackageManager;
   9 import android.content.pm.ResolveInfo;
  10 import android.content.res.Resources;
  11 import android.content.res.XmlResourceParser;
  12 import android.text.TextUtils;
  13 import android.util.Log;
  14 
  15 import com.android.launcher3.LauncherSettings.Favorites;
  16 
  17 import org.xmlpull.v1.XmlPullParser;
  18 import org.xmlpull.v1.XmlPullParserException;
  19 
  20 import java.io.IOException;
  21 import java.net.URISyntaxException;
  22 import java.util.HashMap;
  23 import java.util.List;
  24 
  25 /**
  26  * Implements the layout parser with rules for internal layouts and partner layouts.
  27  */
  28 public class DefaultLayoutParser extends AutoInstallsLayout {
  29     private static final String TAG = &quot;DefaultLayoutParser&quot;;
  30 
  31     protected static final String TAG_RESOLVE = &quot;resolve&quot;;
  32     private static final String TAG_FAVORITES = &quot;favorites&quot;;
  33     protected static final String TAG_FAVORITE = &quot;favorite&quot;;
  34     private static final String TAG_APPWIDGET = &quot;appwidget&quot;;
  35     private static final String TAG_SHORTCUT = &quot;shortcut&quot;;
  36     private static final String TAG_FOLDER = &quot;folder&quot;;
  37     private static final String TAG_PARTNER_FOLDER = &quot;partner-folder&quot;;
  38 
  39     protected static final String ATTR_URI = &quot;uri&quot;;
  40     private static final String ATTR_CONTAINER = &quot;container&quot;;
  41     private static final String ATTR_SCREEN = &quot;screen&quot;;
  42     private static final String ATTR_FOLDER_ITEMS = &quot;folderItems&quot;;
  43 
  44     public DefaultLayoutParser(Context context, AppWidgetHost appWidgetHost,
  45             LayoutParserCallback callback, Resources sourceRes, int layoutId) {
  46         super(context, appWidgetHost, callback, sourceRes, layoutId, TAG_FAVORITES);
  47     }
  48 
  49     public DefaultLayoutParser(Context context, AppWidgetHost appWidgetHost,
  50             LayoutParserCallback callback, Resources sourceRes, int layoutId, String rootTag,
  51             int hotseatAllAppsRank) {
  52         super(context, appWidgetHost, callback, sourceRes, layoutId, rootTag, hotseatAllAppsRank);
  53     }
  54 
  55     @Override
  56     protected HashMap&lt;String, TagParser&gt; getFolderElementsMap() {
  57         return getFolderElementsMap(mSourceRes);
  58     }
  59 
  60     private HashMap&lt;String, TagParser&gt; getFolderElementsMap(Resources res) {
  61         HashMap&lt;String, TagParser&gt; parsers = new HashMap&lt;String, TagParser&gt;();
  62         parsers.put(TAG_FAVORITE, new AppShortcutWithUriParser());
  63         parsers.put(TAG_SHORTCUT, new UriShortcutParser(res));
  64         return parsers;
  65     }
  66 
  67     @Override
  68     protected HashMap&lt;String, TagParser&gt; getLayoutElementsMap() {
  69         HashMap&lt;String, TagParser&gt; parsers = new HashMap&lt;String, TagParser&gt;();
  70         parsers.put(TAG_FAVORITE, new AppShortcutWithUriParser());
  71         parsers.put(TAG_APPWIDGET, new AppWidgetParser());
  72         parsers.put(TAG_SHORTCUT, new UriShortcutParser(mSourceRes));
  73         parsers.put(TAG_RESOLVE, new ResolveParser());
  74         parsers.put(TAG_FOLDER, new MyFolderParser());
  75         parsers.put(TAG_PARTNER_FOLDER, new PartnerFolderParser());
  76         return parsers;
  77     }
  78 
  79     @Override
  80     protected void parseContainerAndScreen(XmlResourceParser parser, long[] out) {
  81         out[0] = LauncherSettings.Favorites.CONTAINER_DESKTOP;
  82         String strContainer = getAttributeValue(parser, ATTR_CONTAINER);
  83         if (strContainer != null) {
  84             out[0] = Long.valueOf(strContainer);
  85         }
  86         out[1] = Long.parseLong(getAttributeValue(parser, ATTR_SCREEN));
  87     }
  88 
  89     /**
  90      * AppShortcutParser which also supports adding URI based intents
  91      */
  92     private class AppShortcutWithUriParser extends AppShortcutParser {
  93 
  94         @Override
  95         protected long invalidPackageOrClass(XmlResourceParser parser) {
  96             final String uri = getAttributeValue(parser, ATTR_URI);
  97             if (TextUtils.isEmpty(uri)) {
  98                 Log.e(TAG, &quot;Skipping invalid &lt;favorite&gt; with no component or uri&quot;);
  99                 return -1;
 100             }
 101 
 102             final Intent metaIntent;
 103             try {
 104                 metaIntent = Intent.parseUri(uri, 0);
 105             } catch (URISyntaxException e) {
 106                 Log.e(TAG, &quot;Unable to add meta-favorite: &quot; + uri, e);
 107                 return -1;
 108             }
 109 
 110             ResolveInfo resolved = mPackageManager.resolveActivity(metaIntent,
 111                     PackageManager.MATCH_DEFAULT_ONLY);
 112             final List&lt;ResolveInfo&gt; appList = mPackageManager.queryIntentActivities(
 113                     metaIntent, PackageManager.MATCH_DEFAULT_ONLY);
 114 
 115             // Verify that the result is an app and not just the resolver dialog asking which
 116             // app to use.
 117             if (wouldLaunchResolverActivity(resolved, appList)) {
 118                 // If only one of the results is a system app then choose that as the default.
 119                 final ResolveInfo systemApp = getSingleSystemActivity(appList);
 120                 if (systemApp == null) {
 121                     // There is no logical choice for this meta-favorite, so rather than making
 122                     // a bad choice just add nothing.
 123                     Log.w(TAG, &quot;No preference or single system activity found for &quot;
 124                             + metaIntent.toString());
 125                     return -1;
 126                 }
 127                 resolved = systemApp;
 128             }
 129             final ActivityInfo info = resolved.activityInfo;
 130             final Intent intent = mPackageManager.getLaunchIntentForPackage(info.packageName);
 131             if (intent == null) {
 132                 return -1;
 133             }
 134             intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
 135                     Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
 136 
 137             return addShortcut(info.loadLabel(mPackageManager).toString(), intent,
 138                     Favorites.ITEM_TYPE_APPLICATION);
 139         }
 140 
 141         private ResolveInfo getSingleSystemActivity(List&lt;ResolveInfo&gt; appList) {
 142             ResolveInfo systemResolve = null;
 143             final int N = appList.size();
 144             for (int i = 0; i &lt; N; ++i) {
 145                 try {
 146                     ApplicationInfo info = mPackageManager.getApplicationInfo(
 147                             appList.get(i).activityInfo.packageName, 0);
 148                     if ((info.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) {
 149                         if (systemResolve != null) {
 150                             return null;
 151                         } else {
 152                             systemResolve = appList.get(i);
 153                         }
 154                     }
 155                 } catch (PackageManager.NameNotFoundException e) {
 156                     Log.w(TAG, &quot;Unable to get info about resolve results&quot;, e);
 157                     return null;
 158                 }
 159             }
 160             return systemResolve;
 161         }
 162 
 163         private boolean wouldLaunchResolverActivity(ResolveInfo resolved,
 164                 List&lt;ResolveInfo&gt; appList) {
 165             // If the list contains the above resolved activity, then it can&#x27;t be
 166             // ResolverActivity itself.
 167             for (int i = 0; i &lt; appList.size(); ++i) {
 168                 ResolveInfo tmp = appList.get(i);
 169                 if (tmp.activityInfo.name.equals(resolved.activityInfo.name)
 170                         &amp;&amp; tmp.activityInfo.packageName.equals(resolved.activityInfo.packageName)) {
 171                     return false;
 172                 }
 173             }
 174             return true;
 175         }
 176     }
 177 
 178 
 179     /**
 180      * Shortcut parser which allows any uri and not just web urls.
 181      */
 182     private class UriShortcutParser extends ShortcutParser {
 183 
 184         public UriShortcutParser(Resources iconRes) {
 185             super(iconRes);
 186         }
 187 
 188         @Override
 189         protected Intent parseIntent(XmlResourceParser parser) {
 190             String uri = null;
 191             try {
 192                 uri = getAttributeValue(parser, ATTR_URI);
 193                 return Intent.parseUri(uri, 0);
 194             } catch (URISyntaxException e) {
 195                 Log.w(TAG, &quot;Shortcut has malformed uri: &quot; + uri);
 196                 return null; // Oh well
 197             }
 198         }
 199     }
 200 
 201     /**
 202      * Contains a list of &lt;favorite&gt; nodes, and accepts the first successfully parsed node.
 203      */
 204     protected class ResolveParser implements TagParser {
 205 
 206         private final AppShortcutWithUriParser mChildParser = new AppShortcutWithUriParser();
 207 
 208         @Override
 209         public long parseAndAdd(XmlResourceParser parser) throws XmlPullParserException,
 210                 IOException {
 211             final int groupDepth = parser.getDepth();
 212             int type;
 213             long addedId = -1;
 214             while ((type = parser.next()) != XmlPullParser.END_TAG ||
 215                     parser.getDepth() &gt; groupDepth) {
 216                 if (type != XmlPullParser.START_TAG || addedId &gt; -1) {
 217                     continue;
 218                 }
 219                 final String fallback_item_name = parser.getName();
 220                 if (TAG_FAVORITE.equals(fallback_item_name)) {
 221                     addedId = mChildParser.parseAndAdd(parser);
 222                 } else {
 223                     Log.e(TAG, &quot;Fallback groups can contain only favorites, found &quot;
 224                             + fallback_item_name);
 225                 }
 226             }
 227             return addedId;
 228         }
 229     }
 230 
 231     /**
 232      * A parser which adds a folder whose contents come from partner apk.
 233      */
 234     private class PartnerFolderParser implements TagParser {
 235 
 236         @Override
 237         public long parseAndAdd(XmlResourceParser parser) throws XmlPullParserException,
 238                 IOException {
 239             // Folder contents come from an external XML resource
 240             final Partner partner = Partner.get(mPackageManager);
 241             if (partner != null) {
 242                 final Resources partnerRes = partner.getResources();
 243                 final int resId = partnerRes.getIdentifier(Partner.RES_FOLDER,
 244                         &quot;xml&quot;, partner.getPackageName());
 245                 if (resId != 0) {
 246                     final XmlResourceParser partnerParser = partnerRes.getXml(resId);
 247                     beginDocument(partnerParser, TAG_FOLDER);
 248 
 249                     FolderParser folderParser = new FolderParser(getFolderElementsMap(partnerRes));
 250                     return folderParser.parseAndAdd(partnerParser);
 251                 }
 252             }
 253             return -1;
 254         }
 255     }
 256 
 257     /**
 258      * An extension of FolderParser which allows adding items from a different xml.
 259      */
 260     private class MyFolderParser extends FolderParser {
 261 
 262         @Override
 263         public long parseAndAdd(XmlResourceParser parser) throws XmlPullParserException,
 264                 IOException {
 265             final int resId = getAttributeResourceValue(parser, ATTR_FOLDER_ITEMS, 0);
 266             if (resId != 0) {
 267                 parser = mSourceRes.getXml(resId);
 268                 beginDocument(parser, TAG_FOLDER);
 269             }
 270             return super.parseAndAdd(parser);
 271         }
 272     }
 273 }
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 package com.android.launcher3;
   2 
   3 import android.appwidget.AppWidgetHost;
   4 import android.content.Context;
   5 import android.content.Intent;
   6 import android.content.pm.ActivityInfo;
   7 import android.content.pm.ApplicationInfo;
   8 import android.content.pm.PackageManager;
   9 import android.content.pm.ResolveInfo;
  10 import android.content.res.Resources;
  11 import android.content.res.XmlResourceParser;
  12 import android.text.TextUtils;
  13 import android.util.Log;
  14 import com.android.launcher3.LauncherSettings.Favorites;
  15 import java.io.IOException;
  16 import java.net.URISyntaxException;
  17 import java.util.HashMap;
  18 import java.util.List;
  19 import org.xmlpull.v1.XmlPullParser;
  20 import org.xmlpull.v1.XmlPullParserException;
  21 
  22 
  23 /**
  24  * Implements the layout parser with rules for internal layouts and partner layouts.
  25  */
  26 public class DefaultLayoutParser extends AutoInstallsLayout {
  27     private static final String TAG = &quot;DefaultLayoutParser&quot;;
  28 
  29     protected static final String TAG_RESOLVE = &quot;resolve&quot;;
  30 
  31     private static final String TAG_FAVORITES = &quot;favorites&quot;;
  32 
  33     protected static final String TAG_FAVORITE = &quot;favorite&quot;;
  34 
  35     private static final String TAG_APPWIDGET = &quot;appwidget&quot;;
  36 
  37     private static final String TAG_SHORTCUT = &quot;shortcut&quot;;
  38 
  39     private static final String TAG_FOLDER = &quot;folder&quot;;
  40 
  41     private static final String TAG_PARTNER_FOLDER = &quot;partner-folder&quot;;
  42 
  43     protected static final String ATTR_URI = &quot;uri&quot;;
  44 
  45     private static final String ATTR_CONTAINER = &quot;container&quot;;
  46 
  47     private static final String ATTR_SCREEN = &quot;screen&quot;;
  48 
  49     private static final String ATTR_FOLDER_ITEMS = &quot;folderItems&quot;;
  50 
<abbr title="  51     public DefaultLayoutParser(Context context, AppWidgetHost appWidgetHost, LayoutParserCallback callback, Resources sourceRes, int layoutId) {">  51     public DefaultLayoutParser(Context context, AppWidgetHost appWidgetHost, LayoutParserCallback callbacðŸ”µ</abbr>
  52         super(context, appWidgetHost, callback, sourceRes, layoutId, TAG_FAVORITES);
  53     }
  54 
<abbr title="  55     public DefaultLayoutParser(Context context, AppWidgetHost appWidgetHost, LayoutParserCallback callback, Resources sourceRes, int layoutId, String rootTag, int hotseatAllAppsRank) {">  55     public DefaultLayoutParser(Context context, AppWidgetHost appWidgetHost, LayoutParserCallback callbacðŸ”µ</abbr>
  56         super(context, appWidgetHost, callback, sourceRes, layoutId, rootTag, hotseatAllAppsRank);
  57     }
  58 
  59     @Override
  60     protected HashMap&lt;String, TagParser&gt; getFolderElementsMap() {
  61         return getFolderElementsMap(mSourceRes);
  62     }
  63 
  64     private HashMap&lt;String, TagParser&gt; getFolderElementsMap(Resources res) {
  65         HashMap&lt;String, TagParser&gt; parsers = new HashMap&lt;String, TagParser&gt;();
  66         parsers.put(TAG_FAVORITE, new AppShortcutWithUriParser());
  67         parsers.put(TAG_SHORTCUT, new UriShortcutParser(res));
  68         return parsers;
  69     }
  70 
  71     @Override
  72     protected HashMap&lt;String, TagParser&gt; getLayoutElementsMap() {
  73         HashMap&lt;String, TagParser&gt; parsers = new HashMap&lt;String, TagParser&gt;();
  74         parsers.put(TAG_FAVORITE, new AppShortcutWithUriParser());
  75         parsers.put(TAG_APPWIDGET, new AppWidgetParser());
  76         parsers.put(TAG_SHORTCUT, new UriShortcutParser(mSourceRes));
  77         parsers.put(TAG_RESOLVE, new ResolveParser());
  78         parsers.put(TAG_FOLDER, new MyFolderParser());
  79         parsers.put(TAG_PARTNER_FOLDER, new PartnerFolderParser());
  80         return parsers;
  81     }
  82 
  83     @Override
  84     protected void parseContainerAndScreen(XmlResourceParser parser, long[] out) {
  85         out[0] = LauncherSettings.Favorites.CONTAINER_DESKTOP;
  86         String strContainer = getAttributeValue(parser, ATTR_CONTAINER);
  87         if (strContainer != null) {
  88             out[0] = Long.valueOf(strContainer);
  89         }
  90         out[1] = Long.parseLong(getAttributeValue(parser, ATTR_SCREEN));
  91     }
  92 
  93     /**
  94      * AppShortcutParser which also supports adding URI based intents
  95      */
  96     private class AppShortcutWithUriParser extends AppShortcutParser {
  97         @Override
  98         protected long invalidPackageOrClass(XmlResourceParser parser) {
  99             final String uri = getAttributeValue(parser, ATTR_URI);
 100             if (TextUtils.isEmpty(uri)) {
 101                 Log.e(TAG, &quot;Skipping invalid &lt;favorite&gt; with no component or uri&quot;);
 102                 return -1;
 103             }
 104             final Intent metaIntent;
 105             try {
 106                 metaIntent = Intent.parseUri(uri, 0);
 107             } catch (URISyntaxException e) {
 108                 Log.e(TAG, &quot;Unable to add meta-favorite: &quot; + uri, e);
 109                 return -1;
 110             }
<abbr title=" 111             ResolveInfo resolved = mPackageManager.resolveActivity(metaIntent, PackageManager.MATCH_DEFAULT_ONLY);"> 111             ResolveInfo resolved = mPackageManager.resolveActivity(metaIntent, PackageManager.MATCH_DEFAUðŸ”µ</abbr>
<abbr title=" 112             final List&lt;ResolveInfo&gt; appList = mPackageManager.queryIntentActivities(metaIntent, PackageManager.MATCH_DEFAULT_ONLY);"> 112             final List&lt;ResolveInfo&gt; appList = mPackageManager.queryIntentActivities(metaIntent, PackageMaðŸ”µ</abbr>
 113             // Verify that the result is an app and not just the resolver dialog asking which
 114             // app to use.
 115             if (wouldLaunchResolverActivity(resolved, appList)) {
 116                 // If only one of the results is a system app then choose that as the default.
 117                 final ResolveInfo systemApp = getSingleSystemActivity(appList);
 118                 if (systemApp == null) {
 119                     // There is no logical choice for this meta-favorite, so rather than making
 120                     // a bad choice just add nothing.
<abbr title=" 121                     Log.w(TAG, &quot;No preference or single system activity found for &quot; + metaIntent.toString());"> 121                     Log.w(TAG, &quot;No preference or single system activity found for &quot; + metaIntent.toStringðŸ”µ</abbr>
 122                     return -1;
 123                 }
 124                 resolved = systemApp;
 125             }
 126             final ActivityInfo info = resolved.activityInfo;
 127             final Intent intent = mPackageManager.getLaunchIntentForPackage(info.packageName);
 128             if (intent == null) {
 129                 return -1;
 130             }
 131             intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
<abbr title=" 132             return addShortcut(info.loadLabel(mPackageManager).toString(), intent, Favorites.ITEM_TYPE_APPLICATION);"> 132             return addShortcut(info.loadLabel(mPackageManager).toString(), intent, Favorites.ITEM_TYPE_APðŸ”µ</abbr>
 133         }
 134 
 135         private ResolveInfo getSingleSystemActivity(List&lt;ResolveInfo&gt; appList) {
 136             ResolveInfo systemResolve = null;
 137             final int N = appList.size();
 138             for (int i = 0; i &lt; N; ++i) {
 139                 try {
<abbr title=" 140                     ApplicationInfo info = mPackageManager.getApplicationInfo(appList.get(i).activityInfo.packageName, 0);"> 140                     ApplicationInfo info = mPackageManager.getApplicationInfo(appList.get(i).activityInfoðŸ”µ</abbr>
 141                     if ((info.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) {
 142                         if (systemResolve != null) {
 143                             return null;
 144                         } else {
 145                             systemResolve = appList.get(i);
 146                         }
 147                     }
 148                 } catch (PackageManager e) {
 149                     Log.w(TAG, &quot;Unable to get info about resolve results&quot;, e);
 150                     return null;
 151                 }
 152             }
 153             return systemResolve;
 154         }
 155 
 156         private boolean wouldLaunchResolverActivity(ResolveInfo resolved, List&lt;ResolveInfo&gt; appList) {
 157             // If the list contains the above resolved activity, then it can&#x27;t be
 158             // ResolverActivity itself.
 159             for (int i = 0; i &lt; appList.size(); ++i) {
 160                 ResolveInfo tmp = appList.get(i);
<abbr title=" 161                 if (tmp.activityInfo.name.equals(resolved.activityInfo.name) &amp;&amp; tmp.activityInfo.packageName.equals(resolved.activityInfo.packageName)) {"> 161                 if (tmp.activityInfo.name.equals(resolved.activityInfo.name) &amp;&amp; tmp.activityInfo.packageNðŸ”µ</abbr>
 162                     return false;
 163                 }
 164             }
 165             return true;
 166         }
 167     }
 168 
 169     /**
 170      * Shortcut parser which allows any uri and not just web urls.
 171      */
 172     private class UriShortcutParser extends ShortcutParser {
 173         public UriShortcutParser(Resources iconRes) {
 174             super(iconRes);
 175         }
 176 
 177         @Override
 178         protected Intent parseIntent(XmlResourceParser parser) {
 179             String uri = null;
 180             try {
 181                 uri = getAttributeValue(parser, ATTR_URI);
 182                 return Intent.parseUri(uri, 0);
 183             } catch (URISyntaxException e) {
 184                 Log.w(TAG, &quot;Shortcut has malformed uri: &quot; + uri);
 185                 return null;// Oh well
 186 
 187             }
 188         }
 189     }
 190 
 191     /**
 192      * Contains a list of &lt;favorite&gt; nodes, and accepts the first successfully parsed node.
 193      */
 194     protected class ResolveParser implements TagParser {
 195         private final AppShortcutWithUriParser mChildParser = new AppShortcutWithUriParser();
 196 
 197         @Override
 198         public long parseAndAdd(XmlResourceParser parser) throws XmlPullParserException,
 199                 IOException {
 200             final int groupDepth = parser.getDepth();
 201             int type;
 202             long addedId = -1;
 203             while ((type = parser.next()) != XmlPullParser.END_TAG ||
 204                     parser.getDepth() &gt; groupDepth) {
 205                 if (type != XmlPullParser.START_TAG || addedId &gt; -1) {
 206                     continue;
 207                 }
 208                 final String fallback_item_name = parser.getName();
 209                 if (TAG_FAVORITE.equals(fallback_item_name)) {
 210                     addedId = mChildParser.parseAndAdd(parser);
 211                 } else {
 212                     Log.e(TAG, &quot;Fallback groups can contain only favorites, found &quot;
 213                             + fallback_item_name);
 214                 }
 215             }
 216             return addedId;
 217         }
 218     }
 219 
 220     /**
 221      * A parser which adds a folder whose contents come from partner apk.
 222      */
 223     private class PartnerFolderParser implements TagParser {
 224         @Override
 225         public long parseAndAdd(XmlResourceParser parser) throws XmlPullParserException, IOException {
 226             // Folder contents come from an external XML resource
 227             final Partner partner = Partner.get(mPackageManager);
 228             if (partner != null) {
 229                 final Resources partnerRes = partner.getResources();
<abbr title=" 230                 final int resId = partnerRes.getIdentifier(Partner.RES_FOLDER, &quot;xml&quot;, partner.getPackageName());"> 230                 final int resId = partnerRes.getIdentifier(Partner.RES_FOLDER, &quot;xml&quot;, partner.getPackageNðŸ”µ</abbr>
 231                 if (resId != 0) {
 232                     final XmlResourceParser partnerParser = partnerRes.getXml(resId);
 233                     beginDocument(partnerParser, TAG_FOLDER);
 234                     FolderParser folderParser = new FolderParser(getFolderElementsMap(partnerRes));
 235                     return folderParser.parseAndAdd(partnerParser);
 236                 }
 237             }
 238             return -1;
 239         }
 240     }
 241 
 242     /**
 243      * An extension of FolderParser which allows adding items from a different xml.
 244      */
 245     private class MyFolderParser extends FolderParser {
 246         @Override
 247         public long parseAndAdd(XmlResourceParser parser) throws XmlPullParserException, IOException {
 248             final int resId = getAttributeResourceValue(parser, ATTR_FOLDER_ITEMS, 0);
 249             if (resId != 0) {
 250                 parser = mSourceRes.getXml(resId);
 251                 beginDocument(parser, TAG_FOLDER);
 252             }
 253             return super.parseAndAdd(parser);
 254         }
 255     }
 256 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  package com.android.launcher3;
   2  
   3  import android.appwidget.AppWidgetHost;
   4  import android.content.Context;
   5  import android.content.Intent;
   6  import android.content.pm.ActivityInfo;
   7  import android.content.pm.ApplicationInfo;
   8  import android.content.pm.PackageManager;
   9  import android.content.pm.ResolveInfo;
  10  import android.content.res.Resources;
  11  import android.content.res.XmlResourceParser;
  12  import android.text.TextUtils;
  13  import android.util.Log;
  14  
  15  import com.android.launcher3.LauncherSettings.Favorites;
  16  
  17  import org.xmlpull.v1.XmlPullParser;
  18  import org.xmlpull.v1.XmlPullParserException;
  19  
  20  import java.io.IOException;
  21  import java.net.URISyntaxException;
  22  import java.util.ArrayList;
  23  import java.util.HashMap;
  24  import java.util.List;
  25  
  26  /**
  27   * Implements the layout parser with rules for internal layouts and partner layouts.
  28   */
  29  public class DefaultLayoutParser extends AutoInstallsLayout {
  30      private static final String TAG = &quot;DefaultLayoutParser&quot;;
  31  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  32 -    private static final String TAG_RESOLVE = &quot;resolve&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  33 +    protected static final String TAG_RESOLVE = &quot;resolve&quot;;</span>
  34      private static final String TAG_FAVORITES = &quot;favorites&quot;;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  35 -    private static final String TAG_FAVORITE = &quot;favorite&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  36 +    protected static final String TAG_FAVORITE = &quot;favorite&quot;;</span>
  37      private static final String TAG_APPWIDGET = &quot;appwidget&quot;;
  38      private static final String TAG_SHORTCUT = &quot;shortcut&quot;;
  39      private static final String TAG_FOLDER = &quot;folder&quot;;
  40      private static final String TAG_PARTNER_FOLDER = &quot;partner-folder&quot;;
  41      private static final String TAG_INCLUDE = &quot;include&quot;;
  42  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  43 -    private static final String ATTR_URI = &quot;uri&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  44 +    protected static final String ATTR_URI = &quot;uri&quot;;</span>
  45      private static final String ATTR_WORKSPACE = &quot;workspace&quot;;
  46      private static final String ATTR_CONTAINER = &quot;container&quot;;
  47      private static final String ATTR_SCREEN = &quot;screen&quot;;
  48      private static final String ATTR_FOLDER_ITEMS = &quot;folderItems&quot;;
  49  
  50      public DefaultLayoutParser(Context context, AppWidgetHost appWidgetHost,
  51              LayoutParserCallback callback, Resources sourceRes, int layoutId) {
  52          super(context, appWidgetHost, callback, sourceRes, layoutId, TAG_FAVORITES);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  53 -        Log.e(TAG, &quot;Default layout parser initialized&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  54 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  55 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  56 +    public DefaultLayoutParser(Context context, AppWidgetHost appWidgetHost,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  57 +            LayoutParserCallback callback, Resources sourceRes, int layoutId, String rootTag,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  58 +            int hotseatAllAppsRank) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  59 +        super(context, appWidgetHost, callback, sourceRes, layoutId, rootTag, hotseatAllAppsRank);</span>
  60      }
  61  
  62      @Override
  63      protected HashMap&lt;String, TagParser&gt; getFolderElementsMap() {
  64          return getFolderElementsMap(mSourceRes);
  65      }
  66  
  67      private HashMap&lt;String, TagParser&gt; getFolderElementsMap(Resources res) {
  68          HashMap&lt;String, TagParser&gt; parsers = new HashMap&lt;String, TagParser&gt;();
  69          parsers.put(TAG_FAVORITE, new AppShortcutWithUriParser());
  70          parsers.put(TAG_SHORTCUT, new UriShortcutParser(res));
  71          return parsers;
  72      }
  73  
  74      @Override
  75      protected HashMap&lt;String, TagParser&gt; getLayoutElementsMap() {
  76          HashMap&lt;String, TagParser&gt; parsers = new HashMap&lt;String, TagParser&gt;();
  77          parsers.put(TAG_FAVORITE, new AppShortcutWithUriParser());
  78          parsers.put(TAG_APPWIDGET, new AppWidgetParser());
  79          parsers.put(TAG_SHORTCUT, new UriShortcutParser(mSourceRes));
  80          parsers.put(TAG_RESOLVE, new ResolveParser());
  81          parsers.put(TAG_FOLDER, new MyFolderParser());
  82          parsers.put(TAG_PARTNER_FOLDER, new PartnerFolderParser());
  83          return parsers;
  84      }
  85  
  86      @Override
  87      protected void parseContainerAndScreen(XmlResourceParser parser, long[] out) {
  88          out[0] = LauncherSettings.Favorites.CONTAINER_DESKTOP;
  89          String strContainer = getAttributeValue(parser, ATTR_CONTAINER);
  90          if (strContainer != null) {
  91              out[0] = Long.valueOf(strContainer);
  92          }
  93          out[1] = Long.parseLong(getAttributeValue(parser, ATTR_SCREEN));
  94      }
  95  
  96      @Override
  97      protected int parseAndAddNode(
  98              XmlResourceParser parser,
  99              HashMap&lt;String, TagParser&gt; tagParserMap,
 100              ArrayList&lt;Long&gt; screenIds)
 101                      throws XmlPullParserException, IOException {
 102          if (TAG_INCLUDE.equals(parser.getName())) {
 103              final int resId = getAttributeResourceValue(parser, ATTR_WORKSPACE, 0);
 104              if (resId != 0) {
 105                  // recursively load some more favorites, why not?
 106                  return parseLayout(resId, screenIds);
 107              } else {
 108                  return 0;
 109              }
 110          } else {
 111              return super.parseAndAddNode(parser, tagParserMap, screenIds);
 112          }
 113      }
 114  
 115      /**
 116       * AppShortcutParser which also supports adding URI based intents
 117       */
 118      private class AppShortcutWithUriParser extends AppShortcutParser {
 119  
 120          @Override
 121          protected long invalidPackageOrClass(XmlResourceParser parser) {
 122              final String uri = getAttributeValue(parser, ATTR_URI);
 123              if (TextUtils.isEmpty(uri)) {
 124                  Log.e(TAG, &quot;Skipping invalid &lt;favorite&gt; with no component or uri&quot;);
 125                  return -1;
 126              }
 127  
 128              final Intent metaIntent;
 129              try {
 130                  metaIntent = Intent.parseUri(uri, 0);
 131              } catch (URISyntaxException e) {
 132                  Log.e(TAG, &quot;Unable to add meta-favorite: &quot; + uri, e);
 133                  return -1;
 134              }
 135  
 136              ResolveInfo resolved = mPackageManager.resolveActivity(metaIntent,
 137                      PackageManager.MATCH_DEFAULT_ONLY);
 138              final List&lt;ResolveInfo&gt; appList = mPackageManager.queryIntentActivities(
 139                      metaIntent, PackageManager.MATCH_DEFAULT_ONLY);
 140  
 141              // Verify that the result is an app and not just the resolver dialog asking which
 142              // app to use.
 143              if (wouldLaunchResolverActivity(resolved, appList)) {
 144                  // If only one of the results is a system app then choose that as the default.
 145                  final ResolveInfo systemApp = getSingleSystemActivity(appList);
 146                  if (systemApp == null) {
 147                      // There is no logical choice for this meta-favorite, so rather than making
 148                      // a bad choice just add nothing.
 149                      Log.w(TAG, &quot;No preference or single system activity found for &quot;
 150                              + metaIntent.toString());
 151                      return -1;
 152                  }
 153                  resolved = systemApp;
 154              }
 155              final ActivityInfo info = resolved.activityInfo;
 156              final Intent intent = mPackageManager.getLaunchIntentForPackage(info.packageName);
 157              if (intent == null) {
 158                  return -1;
 159              }
 160              intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
 161                      Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
 162  
 163              return addShortcut(info.loadLabel(mPackageManager).toString(), intent,
 164                      Favorites.ITEM_TYPE_APPLICATION);
 165          }
 166  
 167          private ResolveInfo getSingleSystemActivity(List&lt;ResolveInfo&gt; appList) {
 168              ResolveInfo systemResolve = null;
 169              final int N = appList.size();
 170              for (int i = 0; i &lt; N; ++i) {
 171                  try {
 172                      ApplicationInfo info = mPackageManager.getApplicationInfo(
 173                              appList.get(i).activityInfo.packageName, 0);
 174                      if ((info.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) {
 175                          if (systemResolve != null) {
 176                              return null;
 177                          } else {
 178                              systemResolve = appList.get(i);
 179                          }
 180                      }
 181                  } catch (PackageManager.NameNotFoundException e) {
 182                      Log.w(TAG, &quot;Unable to get info about resolve results&quot;, e);
 183                      return null;
 184                  }
 185              }
 186              return systemResolve;
 187          }
 188  
 189          private boolean wouldLaunchResolverActivity(ResolveInfo resolved,
 190                  List&lt;ResolveInfo&gt; appList) {
 191              // If the list contains the above resolved activity, then it can&#x27;t be
 192              // ResolverActivity itself.
 193              for (int i = 0; i &lt; appList.size(); ++i) {
 194                  ResolveInfo tmp = appList.get(i);
 195                  if (tmp.activityInfo.name.equals(resolved.activityInfo.name)
 196                          &amp;&amp; tmp.activityInfo.packageName.equals(resolved.activityInfo.packageName)) {
 197                      return false;
 198                  }
 199              }
 200              return true;
 201          }
 202      }
 203  
 204  
 205      /**
 206       * Shortcut parser which allows any uri and not just web urls.
 207       */
 208      private class UriShortcutParser extends ShortcutParser {
 209  
 210          public UriShortcutParser(Resources iconRes) {
 211              super(iconRes);
 212          }
 213  
 214          @Override
 215          protected Intent parseIntent(XmlResourceParser parser) {
 216              String uri = null;
 217              try {
 218                  uri = getAttributeValue(parser, ATTR_URI);
 219                  return Intent.parseUri(uri, 0);
 220              } catch (URISyntaxException e) {
 221                  Log.w(TAG, &quot;Shortcut has malformed uri: &quot; + uri);
 222                  return null; // Oh well
 223              }
 224          }
 225      }
 226  
 227      /**
 228       * Contains a list of &lt;favorite&gt; nodes, and accepts the first successfully parsed node.
 229       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 230 -    private class ResolveParser implements TagParser {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 231 +    protected class ResolveParser implements TagParser {</span>
 232  
 233          private final AppShortcutWithUriParser mChildParser = new AppShortcutWithUriParser();
 234  
 235          @Override
 236          public long parseAndAdd(XmlResourceParser parser) throws XmlPullParserException,
 237                  IOException {
 238              final int groupDepth = parser.getDepth();
 239              int type;
 240              long addedId = -1;
 241              while ((type = parser.next()) != XmlPullParser.END_TAG ||
 242                      parser.getDepth() &gt; groupDepth) {
 243                  if (type != XmlPullParser.START_TAG || addedId &gt; -1) {
 244                      continue;
 245                  }
 246                  final String fallback_item_name = parser.getName();
 247                  if (TAG_FAVORITE.equals(fallback_item_name)) {
 248                      addedId = mChildParser.parseAndAdd(parser);
 249                  } else {
 250                      Log.e(TAG, &quot;Fallback groups can contain only favorites, found &quot;
 251                              + fallback_item_name);
 252                  }
 253              }
 254              return addedId;
 255          }
 256      }
 257  
 258      /**
 259       * A parser which adds a folder whose contents come from partner apk.
 260       */
 261      private class PartnerFolderParser implements TagParser {
 262  
 263          @Override
 264          public long parseAndAdd(XmlResourceParser parser) throws XmlPullParserException,
 265                  IOException {
 266              // Folder contents come from an external XML resource
 267              final Partner partner = Partner.get(mPackageManager);
 268              if (partner != null) {
 269                  final Resources partnerRes = partner.getResources();
 270                  final int resId = partnerRes.getIdentifier(Partner.RES_FOLDER,
 271                          &quot;xml&quot;, partner.getPackageName());
 272                  if (resId != 0) {
 273                      final XmlResourceParser partnerParser = partnerRes.getXml(resId);
 274                      beginDocument(partnerParser, TAG_FOLDER);
 275  
 276                      FolderParser folderParser = new FolderParser(getFolderElementsMap(partnerRes));
 277                      return folderParser.parseAndAdd(partnerParser);
 278                  }
 279              }
 280              return -1;
 281          }
 282      }
 283  
 284      /**
 285       * An extension of FolderParser which allows adding items from a different xml.
 286       */
 287      private class MyFolderParser extends FolderParser {
 288  
 289          @Override
 290          public long parseAndAdd(XmlResourceParser parser) throws XmlPullParserException,
 291                  IOException {
 292              final int resId = getAttributeResourceValue(parser, ATTR_FOLDER_ITEMS, 0);
 293              if (resId != 0) {
 294                  parser = mSourceRes.getXml(resId);
 295                  beginDocument(parser, TAG_FOLDER);
 296              }
 297              return super.parseAndAdd(parser);
 298          }
 299      }
 300  }</pre></td>
                            <td><pre>   1  package com.android.launcher3;
   2  
   3  import android.appwidget.AppWidgetHost;
   4  import android.content.Context;
   5  import android.content.Intent;
   6  import android.content.pm.ActivityInfo;
   7  import android.content.pm.ApplicationInfo;
   8  import android.content.pm.PackageManager;
   9  import android.content.pm.ResolveInfo;
  10  import android.content.res.Resources;
  11  import android.content.res.XmlResourceParser;
  12  import android.text.TextUtils;
  13  import android.util.Log;
  14  
  15  import com.android.launcher3.LauncherSettings.Favorites;
  16  
  17  import org.xmlpull.v1.XmlPullParser;
  18  import org.xmlpull.v1.XmlPullParserException;
  19  
  20  import java.io.IOException;
  21  import java.net.URISyntaxException;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  22 -import java.util.ArrayList;</span>
  23  import java.util.HashMap;
  24  import java.util.List;
  25  
  26  /**
  27   * Implements the layout parser with rules for internal layouts and partner layouts.
  28   */
  29  public class DefaultLayoutParser extends AutoInstallsLayout {
  30      private static final String TAG = &quot;DefaultLayoutParser&quot;;
  31  
  32      private static final String TAG_RESOLVE = &quot;resolve&quot;;

  33      private static final String TAG_FAVORITES = &quot;favorites&quot;;
  34      private static final String TAG_FAVORITE = &quot;favorite&quot;;

  35      private static final String TAG_APPWIDGET = &quot;appwidget&quot;;
  36      private static final String TAG_SHORTCUT = &quot;shortcut&quot;;
  37      private static final String TAG_FOLDER = &quot;folder&quot;;
  38      private static final String TAG_PARTNER_FOLDER = &quot;partner-folder&quot;;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  39 -    private static final String TAG_INCLUDE = &quot;include&quot;;</span>
  40  
  41      private static final String ATTR_URI = &quot;uri&quot;;

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  42 -    private static final String ATTR_WORKSPACE = &quot;workspace&quot;;</span>
  43      private static final String ATTR_CONTAINER = &quot;container&quot;;
  44      private static final String ATTR_SCREEN = &quot;screen&quot;;
  45      private static final String ATTR_FOLDER_ITEMS = &quot;folderItems&quot;;
  46  
  47      public DefaultLayoutParser(Context context, AppWidgetHost appWidgetHost,
  48              LayoutParserCallback callback, Resources sourceRes, int layoutId) {
  49          super(context, appWidgetHost, callback, sourceRes, layoutId, TAG_FAVORITES);
  50          Log.e(TAG, &quot;Default layout parser initialized&quot;);






  51      }
  52  
  53      @Override
  54      protected HashMap&lt;String, TagParser&gt; getFolderElementsMap() {
  55          return getFolderElementsMap(mSourceRes);
  56      }
  57  
  58      private HashMap&lt;String, TagParser&gt; getFolderElementsMap(Resources res) {
  59          HashMap&lt;String, TagParser&gt; parsers = new HashMap&lt;String, TagParser&gt;();
  60          parsers.put(TAG_FAVORITE, new AppShortcutWithUriParser());
  61          parsers.put(TAG_SHORTCUT, new UriShortcutParser(res));
  62          return parsers;
  63      }
  64  
  65      @Override
  66      protected HashMap&lt;String, TagParser&gt; getLayoutElementsMap() {
  67          HashMap&lt;String, TagParser&gt; parsers = new HashMap&lt;String, TagParser&gt;();
  68          parsers.put(TAG_FAVORITE, new AppShortcutWithUriParser());
  69          parsers.put(TAG_APPWIDGET, new AppWidgetParser());
  70          parsers.put(TAG_SHORTCUT, new UriShortcutParser(mSourceRes));
  71          parsers.put(TAG_RESOLVE, new ResolveParser());
  72          parsers.put(TAG_FOLDER, new MyFolderParser());
  73          parsers.put(TAG_PARTNER_FOLDER, new PartnerFolderParser());
  74          return parsers;
  75      }
  76  
  77      @Override
  78      protected void parseContainerAndScreen(XmlResourceParser parser, long[] out) {
  79          out[0] = LauncherSettings.Favorites.CONTAINER_DESKTOP;
  80          String strContainer = getAttributeValue(parser, ATTR_CONTAINER);
  81          if (strContainer != null) {
  82              out[0] = Long.valueOf(strContainer);
  83          }
  84          out[1] = Long.parseLong(getAttributeValue(parser, ATTR_SCREEN));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  85 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  86 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  87 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  88 -    protected int parseAndAddNode(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  89 -            XmlResourceParser parser,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  90 -            HashMap&lt;String, TagParser&gt; tagParserMap,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  91 -            ArrayList&lt;Long&gt; screenIds)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  92 -                    throws XmlPullParserException, IOException {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  93 -        if (TAG_INCLUDE.equals(parser.getName())) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  94 -            final int resId = getAttributeResourceValue(parser, ATTR_WORKSPACE, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  95 -            if (resId != 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  96 -                // recursively load some more favorites, why not?</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  97 -                return parseLayout(resId, screenIds);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  98 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  99 -                return 0;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 100 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 101 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 102 -            return super.parseAndAddNode(parser, tagParserMap, screenIds);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 103 -        }</span>
 104      }
 105  
 106      /**
 107       * AppShortcutParser which also supports adding URI based intents
 108       */
 109      private class AppShortcutWithUriParser extends AppShortcutParser {
 110  
 111          @Override
 112          protected long invalidPackageOrClass(XmlResourceParser parser) {
 113              final String uri = getAttributeValue(parser, ATTR_URI);
 114              if (TextUtils.isEmpty(uri)) {
 115                  Log.e(TAG, &quot;Skipping invalid &lt;favorite&gt; with no component or uri&quot;);
 116                  return -1;
 117              }
 118  
 119              final Intent metaIntent;
 120              try {
 121                  metaIntent = Intent.parseUri(uri, 0);
 122              } catch (URISyntaxException e) {
 123                  Log.e(TAG, &quot;Unable to add meta-favorite: &quot; + uri, e);
 124                  return -1;
 125              }
 126  
 127              ResolveInfo resolved = mPackageManager.resolveActivity(metaIntent,
 128                      PackageManager.MATCH_DEFAULT_ONLY);
 129              final List&lt;ResolveInfo&gt; appList = mPackageManager.queryIntentActivities(
 130                      metaIntent, PackageManager.MATCH_DEFAULT_ONLY);
 131  
 132              // Verify that the result is an app and not just the resolver dialog asking which
 133              // app to use.
 134              if (wouldLaunchResolverActivity(resolved, appList)) {
 135                  // If only one of the results is a system app then choose that as the default.
 136                  final ResolveInfo systemApp = getSingleSystemActivity(appList);
 137                  if (systemApp == null) {
 138                      // There is no logical choice for this meta-favorite, so rather than making
 139                      // a bad choice just add nothing.
 140                      Log.w(TAG, &quot;No preference or single system activity found for &quot;
 141                              + metaIntent.toString());
 142                      return -1;
 143                  }
 144                  resolved = systemApp;
 145              }
 146              final ActivityInfo info = resolved.activityInfo;
 147              final Intent intent = mPackageManager.getLaunchIntentForPackage(info.packageName);
 148              if (intent == null) {
 149                  return -1;
 150              }
 151              intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
 152                      Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
 153  
 154              return addShortcut(info.loadLabel(mPackageManager).toString(), intent,
 155                      Favorites.ITEM_TYPE_APPLICATION);
 156          }
 157  
 158          private ResolveInfo getSingleSystemActivity(List&lt;ResolveInfo&gt; appList) {
 159              ResolveInfo systemResolve = null;
 160              final int N = appList.size();
 161              for (int i = 0; i &lt; N; ++i) {
 162                  try {
 163                      ApplicationInfo info = mPackageManager.getApplicationInfo(
 164                              appList.get(i).activityInfo.packageName, 0);
 165                      if ((info.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) {
 166                          if (systemResolve != null) {
 167                              return null;
 168                          } else {
 169                              systemResolve = appList.get(i);
 170                          }
 171                      }
 172                  } catch (PackageManager.NameNotFoundException e) {
 173                      Log.w(TAG, &quot;Unable to get info about resolve results&quot;, e);
 174                      return null;
 175                  }
 176              }
 177              return systemResolve;
 178          }
 179  
 180          private boolean wouldLaunchResolverActivity(ResolveInfo resolved,
 181                  List&lt;ResolveInfo&gt; appList) {
 182              // If the list contains the above resolved activity, then it can&#x27;t be
 183              // ResolverActivity itself.
 184              for (int i = 0; i &lt; appList.size(); ++i) {
 185                  ResolveInfo tmp = appList.get(i);
 186                  if (tmp.activityInfo.name.equals(resolved.activityInfo.name)
 187                          &amp;&amp; tmp.activityInfo.packageName.equals(resolved.activityInfo.packageName)) {
 188                      return false;
 189                  }
 190              }
 191              return true;
 192          }
 193      }
 194  
 195  
 196      /**
 197       * Shortcut parser which allows any uri and not just web urls.
 198       */
 199      private class UriShortcutParser extends ShortcutParser {
 200  
 201          public UriShortcutParser(Resources iconRes) {
 202              super(iconRes);
 203          }
 204  
 205          @Override
 206          protected Intent parseIntent(XmlResourceParser parser) {
 207              String uri = null;
 208              try {
 209                  uri = getAttributeValue(parser, ATTR_URI);
 210                  return Intent.parseUri(uri, 0);
 211              } catch (URISyntaxException e) {
 212                  Log.w(TAG, &quot;Shortcut has malformed uri: &quot; + uri);
 213                  return null; // Oh well
 214              }
 215          }
 216      }
 217  
 218      /**
 219       * Contains a list of &lt;favorite&gt; nodes, and accepts the first successfully parsed node.
 220       */
 221      private class ResolveParser implements TagParser {

 222  
 223          private final AppShortcutWithUriParser mChildParser = new AppShortcutWithUriParser();
 224  
 225          @Override
 226          public long parseAndAdd(XmlResourceParser parser) throws XmlPullParserException,
 227                  IOException {
 228              final int groupDepth = parser.getDepth();
 229              int type;
 230              long addedId = -1;
 231              while ((type = parser.next()) != XmlPullParser.END_TAG ||
 232                      parser.getDepth() &gt; groupDepth) {
 233                  if (type != XmlPullParser.START_TAG || addedId &gt; -1) {
 234                      continue;
 235                  }
 236                  final String fallback_item_name = parser.getName();
 237                  if (TAG_FAVORITE.equals(fallback_item_name)) {
 238                      addedId = mChildParser.parseAndAdd(parser);
 239                  } else {
 240                      Log.e(TAG, &quot;Fallback groups can contain only favorites, found &quot;
 241                              + fallback_item_name);
 242                  }
 243              }
 244              return addedId;
 245          }
 246      }
 247  
 248      /**
 249       * A parser which adds a folder whose contents come from partner apk.
 250       */
 251      private class PartnerFolderParser implements TagParser {
 252  
 253          @Override
 254          public long parseAndAdd(XmlResourceParser parser) throws XmlPullParserException,
 255                  IOException {
 256              // Folder contents come from an external XML resource
 257              final Partner partner = Partner.get(mPackageManager);
 258              if (partner != null) {
 259                  final Resources partnerRes = partner.getResources();
 260                  final int resId = partnerRes.getIdentifier(Partner.RES_FOLDER,
 261                          &quot;xml&quot;, partner.getPackageName());
 262                  if (resId != 0) {
 263                      final XmlResourceParser partnerParser = partnerRes.getXml(resId);
 264                      beginDocument(partnerParser, TAG_FOLDER);
 265  
 266                      FolderParser folderParser = new FolderParser(getFolderElementsMap(partnerRes));
 267                      return folderParser.parseAndAdd(partnerParser);
 268                  }
 269              }
 270              return -1;
 271          }
 272      }
 273  
 274      /**
 275       * An extension of FolderParser which allows adding items from a different xml.
 276       */
 277      private class MyFolderParser extends FolderParser {
 278  
 279          @Override
 280          public long parseAndAdd(XmlResourceParser parser) throws XmlPullParserException,
 281                  IOException {
 282              final int resId = getAttributeResourceValue(parser, ATTR_FOLDER_ITEMS, 0);
 283              if (resId != 0) {
 284                  parser = mSourceRes.getXml(resId);
 285                  beginDocument(parser, TAG_FOLDER);
 286              }
 287              return super.parseAndAdd(parser);
 288          }
 289      }
 290  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            