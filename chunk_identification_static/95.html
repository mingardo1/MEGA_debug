<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>95</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    95
                    <a href="94.html">prev</a>
                    <a href="96.html">next</a>
                    <a href="95_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    Automattic/simplenote-android_1e298f34be2f44e37efc3458b5e8cb06acf71f47_Simplenote/src/main/java/com/automattic/simplenote/NoteEditorFragment.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;1e298f34be2f44e37efc3458b5e8cb06acf71f47:Simplenote/src/main/java/com/automattic/simplenote/NoteEditorFragment.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;1e298f34be2f44e37efc3458b5e8cb06acf71f47^1:Simplenote/src/main/java/com/automattic/simplenote/NoteEditorFragment.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;1e298f34be2f44e37efc3458b5e8cb06acf71f47^2:Simplenote/src/main/java/com/automattic/simplenote/NoteEditorFragment.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;448d5ef9a9f59dc7a0a62a85a925a02a93d3bf44:Simplenote/src/main/java/com/automattic/simplenote/NoteEditorFragment.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 package com.automattic.simplenote;
   2 
   3 import android.app.Activity;
   4 import android.content.Context;
   5 import android.content.SharedPreferences;
   6 import android.content.res.ColorStateList;
   7 import android.database.Cursor;
   8 import android.graphics.Typeface;
   9 import android.graphics.drawable.Drawable;
  10 import android.os.AsyncTask;
  11 import android.os.Bundle;
  12 import android.os.Handler;
  13 import android.text.Editable;
  14 import android.text.Layout;
  15 import android.text.Spanned;
  16 import android.text.TextUtils.SimpleStringSplitter;
  17 import android.text.TextWatcher;
  18 import android.text.style.MetricAffectingSpan;
  19 import android.text.style.RelativeSizeSpan;
  20 import android.text.style.StyleSpan;
  21 import android.text.style.URLSpan;
  22 import android.text.util.Linkify;
  23 import android.util.TypedValue;
  24 import android.view.LayoutInflater;
  25 import android.view.Menu;
  26 import android.view.MenuInflater;
  27 import android.view.MenuItem;
  28 import android.view.View;
  29 import android.view.ViewGroup;
  30 import android.view.ViewTreeObserver;
  31 import android.view.inputmethod.InputMethodManager;
  32 import android.webkit.WebView;
  33 import android.widget.CompoundButton;
  34 import android.widget.CursorAdapter;
  35 import android.widget.LinearLayout;
  36 import android.widget.TextView;
  37 import android.widget.Toast;
  38 
  39 import androidx.annotation.NonNull;
  40 import androidx.appcompat.app.AppCompatActivity;
  41 import androidx.appcompat.view.ActionMode;
  42 import androidx.core.app.ShareCompat;
  43 import androidx.core.view.MenuCompat;
  44 import androidx.core.widget.NestedScrollView;
  45 import androidx.fragment.app.Fragment;
  46 import androidx.fragment.app.FragmentTransaction;
  47 import androidx.preference.PreferenceManager;
  48 
  49 import com.automattic.simplenote.analytics.AnalyticsTracker;
  50 import com.automattic.simplenote.models.Note;
  51 import com.automattic.simplenote.models.Tag;
  52 import com.automattic.simplenote.utils.AutoBullet;
  53 import com.automattic.simplenote.utils.BrowserUtils;
  54 import com.automattic.simplenote.utils.ContextUtils;
  55 import com.automattic.simplenote.utils.DisplayUtils;
  56 import com.automattic.simplenote.utils.DrawableUtils;
  57 import com.automattic.simplenote.utils.MatchOffsetHighlighter;
  58 import com.automattic.simplenote.utils.NetworkUtils;
  59 import com.automattic.simplenote.utils.NoteUtils;
  60 import com.automattic.simplenote.utils.PrefUtils;
  61 import com.automattic.simplenote.utils.SimplenoteLinkify;
  62 import com.automattic.simplenote.utils.SimplenoteMovementMethod;
  63 import com.automattic.simplenote.utils.SpaceTokenizer;
  64 import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;
  65 import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;
  66 import com.automattic.simplenote.utils.TextHighlighter;
  67 import com.automattic.simplenote.utils.ThemeUtils;
  68 import com.automattic.simplenote.utils.WidgetUtils;
  69 import com.automattic.simplenote.widgets.SimplenoteEditText;
  70 import com.google.android.material.chip.Chip;
  71 import com.google.android.material.chip.ChipGroup;
  72 import com.google.android.material.snackbar.Snackbar;
  73 import com.simperium.client.Bucket;
  74 import com.simperium.client.BucketObjectMissingException;
  75 import com.simperium.client.Query;
  76 
  77 import java.lang.ref.WeakReference;
  78 import java.util.Calendar;
  79 
  80 import static com.automattic.simplenote.analytics.AnalyticsTracker.CATEGORY_NOTE;
  81 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_CHECKLIST_INSERTED;
  82 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_CONTENT_SHARED;
  83 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_EDITED;
  84 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_PUBLISHED;
  85 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_UNPUBLISHED;
  86 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_ADDED;
  87 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_REMOVED;
  88 import static com.automattic.simplenote.utils.SearchTokenizer.SPACE;
  89 
  90 public class NoteEditorFragment extends Fragment implements Bucket.Listener&lt;Note&gt;,
  91         TextWatcher, OnTagAddedListener, View.OnFocusChangeListener,
  92         SimplenoteEditText.OnSelectionChangedListener,
  93         ShareBottomSheetDialog.ShareSheetListener,
  94         HistoryBottomSheetDialog.HistorySheetListener,
  95         SimplenoteEditText.OnCheckboxToggledListener {
  96 
  97     public static final String ARG_IS_FROM_WIDGET = &quot;is_from_widget&quot;;
  98     public static final String ARG_ITEM_ID = &quot;item_id&quot;;
  99     public static final String ARG_NEW_NOTE = &quot;new_note&quot;;
 100     public static final String ARG_MATCH_OFFSETS = &quot;match_offsets&quot;;
 101     public static final String ARG_MARKDOWN_ENABLED = &quot;markdown_enabled&quot;;
 102     public static final String ARG_PREVIEW_ENABLED = &quot;preview_enabled&quot;;
 103     private static final String STATE_NOTE_ID = &quot;state_note_id&quot;;
 104     private static final int AUTOSAVE_DELAY_MILLIS = 2000;
 105     private static final int MAX_REVISIONS = 30;
 106     private static final int PUBLISH_TIMEOUT = 20000;
 107     private static final int HISTORY_TIMEOUT = 10000;
 108     private Note mNote;
 109     private final Runnable mAutoSaveRunnable = new Runnable() {
 110         @Override
 111         public void run() {
 112             saveAndSyncNote();
 113         }
 114     };
 115     private Bucket&lt;Note&gt; mNotesBucket;
 116     private View mRootView;
 117     private View mTagPadding;
 118     private SimplenoteEditText mContentEditText;
 119     private ChipGroup mTagChips;
 120     private TagsMultiAutoCompleteTextView mTagInput;
 121     private Handler mAutoSaveHandler;
 122     private Handler mPublishTimeoutHandler;
 123     private Handler mHistoryTimeoutHandler;
 124     private LinearLayout mPlaceholderView;
 125     private CursorAdapter mAutocompleteAdapter;
 126     private boolean mIsLoadingNote;
 127     private boolean mIsMarkdownEnabled;
 128     private boolean mIsPreviewEnabled;
 129     private boolean mShouldScrollToSearchMatch;
 130     private ActionMode mActionMode;
 131     private MenuItem mChecklistMenuItem;
 132     private MenuItem mCopyMenuItem;
 133     private MenuItem mInformationMenuItem;
 134     private MenuItem mShareMenuItem;
 135     private MenuItem mViewLinkMenuItem;
 136     private String mLinkUrl;
 137     private String mLinkText;
 138     private MatchOffsetHighlighter mHighlighter;
 139     private Drawable mCallIcon;
 140     private Drawable mCopyIcon;
 141     private Drawable mEmailIcon;
 142     private Drawable mMapIcon;
 143     private Drawable mShareIcon;
 144     private Drawable mBrowserIcon;
 145     private MatchOffsetHighlighter.SpanFactory mMatchHighlighter;
 146     private String mMatchOffsets;
 147     private int mCurrentCursorPosition;
 148     private HistoryBottomSheetDialog mHistoryBottomSheet;
 149     private boolean mIsPaused;
 150     private boolean mIsFromWidget;
 151 
 152     // Hides the history bottom sheet if no revisions are loaded
 153     private final Runnable mHistoryTimeoutRunnable = new Runnable() {
 154         @Override
 155         public void run() {
 156             if (!isAdded()) {
 157                 return;
 158             }
 159 
 160             requireActivity().runOnUiThread(new Runnable() {
 161                 @Override
 162                 public void run() {
<abbr title=" 163                     if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; !mHistoryBottomSheet.isHistoryLoaded()) {"> 163                     if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowðŸ”µ</abbr>
 164                         mHistoryBottomSheet.dismiss();
 165                         Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 166                     }
 167                 }
 168             });
 169         }
 170     };
 171     private InfoBottomSheetDialog mInfoBottomSheet;
 172     private ShareBottomSheetDialog mShareBottomSheet;
 173     // Contextual action bar for dealing with links
 174     private final ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
 175         // Called when the action mode is created; startActionMode() was called
 176         @Override
 177         public boolean onCreateActionMode(ActionMode mode, Menu menu) {
 178             // Inflate a menu resource providing context menu items
 179             MenuInflater inflater = mode.getMenuInflater();
 180 
 181             if (inflater != null) {
 182                 inflater.inflate(R.menu.view_link, menu);
 183                 mCopyMenuItem = menu.findItem(R.id.menu_copy);
 184                 mShareMenuItem = menu.findItem(R.id.menu_share);
 185                 mViewLinkMenuItem = menu.findItem(R.id.menu_view_link);
 186                 mode.setTitle(getString(R.string.link));
 187                 mode.setTitleOptionalHint(false);
 188 
 189                 DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 190             }
 191 
<abbr title=" 192             int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.background_dark;"> 192             int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.colðŸ”µ</abbr>
<abbr title=" 193             requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().getTheme()));"> 193             requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireAcðŸ”µ</abbr>
 194             return true;
 195         }
 196 
 197         // Called each time the action mode is shown. Always called after onCreateActionMode, but
 198         // may be called multiple times if the mode is invalidated.
 199         @Override
 200         public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 201             return false; // Return false if nothing is done
 202         }
 203 
 204         // Called when the user selects a contextual menu item
 205         @Override
 206         public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 207             switch (item.getItemId()) {
 208                 case R.id.menu_view_link:
 209                     if (mLinkUrl != null) {
 210                         try {
 211                             BrowserUtils.launchBrowserOrShowError(requireContext(), mLinkUrl);
 212                         } catch (Exception e) {
 213                             e.printStackTrace();
 214                         }
 215 
 216                         mode.finish(); // Action picked, so close the CAB
 217                     }
 218                     return true;
 219                 case R.id.menu_copy:
 220                     if (mLinkText != null &amp;&amp; getActivity() != null) {
 221                         BrowserUtils.copyToClipboard(requireContext(), mLinkText);
 222                         Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 223                         mode.finish();
 224                     }
 225                     return true;
 226                 case R.id.menu_share:
 227                     if (mLinkText != null) {
 228                         showShare(mLinkText);
 229                         mode.finish();
 230                     }
 231                     return true;
 232                 default:
 233                     return false;
 234             }
 235         }
 236 
 237         // Called when the user exits the action mode
 238         @Override
 239         public void onDestroyActionMode(ActionMode mode) {
 240             mActionMode = null;
 241             new Handler().postDelayed(
 242                 new Runnable() {
 243                     @Override
 244                     public void run() {
<abbr title=" 245                         requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 245                         requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.RðŸ”µ</abbr>
 246                     }
 247                 },
 248                 requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime)
 249             );
 250         }
 251     };
 252     private Snackbar mPublishingSnackbar;
 253     private boolean mHideActionOnSuccess;
 254     // Resets note publish status if Simperium never returned the new publish status
 255     private final Runnable mPublishTimeoutRunnable = new Runnable() {
 256         @Override
 257         public void run() {
 258             if (!isAdded()) return;
 259 
 260             requireActivity().runOnUiThread(new Runnable() {
 261                 @Override
 262                 public void run() {
 263 
 264                     mNote.setPublished(!mNote.isPublished());
 265                     mNote.save();
 266 
 267                     updatePublishedState(false);
 268                 }
 269             });
 270         }
 271     };
 272     private NoteMarkdownFragment mNoteMarkdownFragment;
 273     private String mCss;
 274     private WebView mMarkdown;
 275 
 276     /**
 277      * Mandatory empty constructor for the fragment manager to instantiate the
 278      * fragment (e.g. upon screen orientation changes).
 279      */
 280     public NoteEditorFragment() {
 281     }
 282 
 283     @Override
 284     public void onCreate(Bundle savedInstanceState) {
 285         super.onCreate(savedInstanceState);
 286         mInfoBottomSheet = new InfoBottomSheetDialog(this);
 287         mShareBottomSheet = new ShareBottomSheetDialog(this, this);
 288         mHistoryBottomSheet = new HistoryBottomSheetDialog(this, this);
 289 
 290         Simplenote currentApp = (Simplenote) requireActivity().getApplication();
 291         mNotesBucket = currentApp.getNotesBucket();
 292 
<abbr title=" 293         mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.actionModeTextColor);"> 293         mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp,ðŸ”µ</abbr>
<abbr title=" 294         mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.attr.actionModeTextColor);"> 294         mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.aðŸ”µ</abbr>
<abbr title=" 295         mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.actionModeTextColor);"> 295         mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.ðŸ”µ</abbr>
<abbr title=" 296         mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp, R.attr.actionModeTextColor);"> 296         mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp,ðŸ”µ</abbr>
<abbr title=" 297         mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attr.actionModeTextColor);"> 297         mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attðŸ”µ</abbr>
<abbr title=" 298         mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.attr.actionModeTextColor);"> 298         mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.aðŸ”µ</abbr>
 299 
 300         mAutoSaveHandler = new Handler();
 301         mPublishTimeoutHandler = new Handler();
 302         mHistoryTimeoutHandler = new Handler();
 303 
 304         mMatchHighlighter = new TextHighlighter(requireActivity(),
<abbr title=" 305                 R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor);"> 305                 R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor)ðŸ”µ</abbr>
 306         mAutocompleteAdapter = new CursorAdapter(getActivity(), null, 0x0) {
 307             @Override
 308             public View newView(Context context, Cursor cursor, ViewGroup parent) {
 309                 Activity activity = (Activity) context;
 310                 if (activity == null) return null;
 311                 return activity.getLayoutInflater().inflate(R.layout.tag_autocomplete_list_item, null);
 312             }
 313 
 314             @Override
 315             public void bindView(View view, Context context, Cursor cursor) {
 316                 TextView textView = (TextView) view;
 317                 textView.setText(convertToString(cursor));
 318             }
 319 
 320             @Override
 321             public CharSequence convertToString(Cursor cursor) {
 322                 return cursor.getString(cursor.getColumnIndex(Tag.NAME_PROPERTY));
 323             }
 324 
 325             @Override
 326             public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 327                 Activity activity = getActivity();
 328                 if (activity == null) return null;
 329                 Simplenote application = (Simplenote) activity.getApplication();
 330                 Query&lt;Tag&gt; query = application.getTagsBucket().query();
 331                 // make the tag name available to the cursor
 332                 query.include(Tag.NAME_PROPERTY);
 333                 // sort the tags by their names
 334                 query.order(Tag.NAME_PROPERTY);
 335                 // if there&#x27;s a filter string find only matching tag names
 336                 if (filter != null)
<abbr title=" 337                     query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filter));"> 337                     query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filteðŸ”µ</abbr>
 338                 return query.execute();
 339             }
 340         };
 341 
 342         WidgetUtils.updateNoteWidgets(requireActivity().getApplicationContext());
 343     }
 344 
 345     @Override
<abbr title=" 346     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {"> 346     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceSðŸ”µ</abbr>
 347         mRootView = inflater.inflate(R.layout.fragment_note_editor, container, false);
 348         mContentEditText = mRootView.findViewById(R.id.note_content);
 349         mContentEditText.addOnSelectionChangedListener(this);
 350         mContentEditText.setOnCheckboxToggledListener(this);
 351         mContentEditText.setMovementMethod(SimplenoteMovementMethod.getInstance());
 352         mContentEditText.setOnFocusChangeListener(this);
 353         mTagInput = mRootView.findViewById(R.id.tag_input);
 354         mTagInput.setDropDownBackgroundResource(R.drawable.bg_list_popup);
 355         mTagInput.setTokenizer(new SpaceTokenizer());
 356         mTagInput.setOnFocusChangeListener(this);
 357         mTagChips = mRootView.findViewById(R.id.tag_chips);
 358         mTagPadding = mRootView.findViewById(R.id.tag_padding);
 359         mHighlighter = new MatchOffsetHighlighter(mMatchHighlighter, mContentEditText);
 360         mPlaceholderView = mRootView.findViewById(R.id.placeholder);
 361 
 362         if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote == null) {
 363             mPlaceholderView.setVisibility(View.VISIBLE);
 364             requireActivity().invalidateOptionsMenu();
 365             mMarkdown = mRootView.findViewById(R.id.markdown);
 366             mCss = ThemeUtils.isLightTheme(requireContext())
 367                     ? ContextUtils.readCssFile(requireContext(), &quot;light.css&quot;)
 368                     : ContextUtils.readCssFile(requireContext(), &quot;dark.css&quot;);
 369         }
 370 
 371         mTagInput.setAdapter(mAutocompleteAdapter);
 372         Bundle arguments = getArguments();
 373 
 374         if (arguments != null &amp;&amp; arguments.containsKey(ARG_ITEM_ID)) {
 375             // Load note if we were passed a note Id
 376             String key = arguments.getString(ARG_ITEM_ID);
 377 
 378             if (arguments.containsKey(ARG_MATCH_OFFSETS)) {
 379                 mMatchOffsets = arguments.getString(ARG_MATCH_OFFSETS);
 380             }
 381 
 382             mIsFromWidget = arguments.getBoolean(ARG_IS_FROM_WIDGET);
 383             new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, key);
 384         } else if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; savedInstanceState != null) {
 385             // Restore selected note when in dual pane mode
 386             String noteId = savedInstanceState.getString(STATE_NOTE_ID);
 387 
 388             if (noteId != null) {
 389                 setNote(noteId);
 390             }
 391         }
 392 
 393         ViewTreeObserver viewTreeObserver = mContentEditText.getViewTreeObserver();
 394         viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
 395             @Override
 396             public void onGlobalLayout() {
 397                 // If a note was loaded with search matches, scroll to the first match in the editor
 398                 if (mShouldScrollToSearchMatch &amp;&amp; mMatchOffsets != null) {
 399                     if (!isAdded()) {
 400                         return;
 401                     }
 402 
 403                     // Get the character location of the first search match
 404                     int matchLocation = MatchOffsetHighlighter.getFirstMatchLocation(
 405                             mContentEditText.getText(),
 406                             mMatchOffsets
 407                     );
 408                     if (matchLocation == 0) {
 409                         return;
 410                     }
 411 
 412                     // Calculate how far to scroll to bring the match into view
 413                     Layout layout = mContentEditText.getLayout();
 414                     int lineTop = layout.getLineTop(layout.getLineForOffset(matchLocation));
 415                     ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 416                     mShouldScrollToSearchMatch = false;
 417                 }
 418             }
 419         });
 420         setHasOptionsMenu(true);
 421         return mRootView;
 422     }
 423 
 424     public void scrollToMatch(int location) {
 425         if (isAdded()) {
 426             // Calculate how far to scroll to bring the match into view
 427             Layout layout = mContentEditText.getLayout();
 428             int lineTop = layout.getLineTop(layout.getLineForOffset(location));
 429             ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 430         }
 431     }
 432 
 433     @Override
 434     public void onResume() {
 435         super.onResume();
 436         mNotesBucket.start();
 437         mNotesBucket.addListener(this);
 438         mTagInput.setOnTagAddedListener(this);
 439 
 440         if (mContentEditText != null) {
<abbr title=" 441             mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(getActivity()));"> 441             mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(getActivity())ðŸ”µ</abbr>
 442 
 443             if (mContentEditText.hasFocus()) {
 444                 showSoftKeyboard();
 445             }
 446         }
 447     }
 448 
 449     private void showSoftKeyboard() {
 450         new Handler().postDelayed(new Runnable() {
 451             @Override
 452             public void run() {
 453                 if (getActivity() == null) {
 454                     return;
 455                 }
 456 
<abbr title=" 457                 InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);"> 457                 InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemServiðŸ”µ</abbr>
 458                 if (inputMethodManager != null) {
 459                     inputMethodManager.showSoftInput(mContentEditText, 0);
 460                 }
 461             }
 462         }, 100);
 463     }
 464 
 465     @Override
 466     public void onPause() {
 467         super.onPause();  // Always call the superclass method first
 468         mIsPaused = true;
 469 
 470         // Hide soft keyboard if it is showing...
 471         DisplayUtils.hideKeyboard(mContentEditText);
 472 
 473         mTagInput.setOnTagAddedListener(null);
 474 
 475         if (mAutoSaveHandler != null) {
 476             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 477         }
 478 
 479         if (mPublishTimeoutHandler != null) {
 480             mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
 481         }
 482 
 483         if (mHistoryTimeoutHandler != null) {
 484             mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 485         }
 486 
 487         mHighlighter.stop();
 488         saveNote();
 489     }
 490 
 491     @Override
 492     public void onDestroy() {
 493         super.onDestroy();
 494         mNotesBucket.removeListener(this);
 495         mNotesBucket.stop();
 496     }
 497 
 498     @Override
 499     public void onSaveInstanceState(@NonNull Bundle outState) {
 500         super.onSaveInstanceState(outState);
 501 
 502         if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote != null) {
 503             outState.putString(STATE_NOTE_ID, mNote.getSimperiumKey());
 504         }
 505     }
 506 
 507     @Override
 508     public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
 509         super.onCreateOptionsMenu(menu, inflater);
 510 
<abbr title=" 511         if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFragment == null)) {"> 511         if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMðŸ”µ</abbr>
 512             return;
 513         }
 514 
 515         inflater.inflate(R.menu.note_editor, menu);
 516         MenuCompat.setGroupDividerEnabled(menu, true);
 517     }
 518 
 519     @Override
 520     public boolean onOptionsItemSelected(@NonNull MenuItem item) {
 521         switch (item.getItemId()) {
 522             case R.id.menu_checklist:
 523                 insertChecklist();
 524                 return true;
 525             case R.id.menu_copy:
 526                 BrowserUtils.copyToClipboard(requireContext(), mNote.getPublishedUrl());
 527                 Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 528                 return true;
 529             case R.id.menu_history:
 530                 showHistory();
 531                 return true;
 532             case R.id.menu_info:
 533                 showInfo();
 534                 return true;
 535             case R.id.menu_markdown:
 536                 setMarkdown(!item.isChecked());
 537                 return true;
 538             case R.id.menu_pin:
 539                 NoteUtils.setNotePin(mNote, !item.isChecked());
 540                 requireActivity().invalidateOptionsMenu();
 541                 return true;
 542             case R.id.menu_publish:
 543                 if (item.isChecked()) {
 544                     unpublishNote();
 545                 } else {
 546                     publishNote();
 547                 }
 548 
 549                 return true;
 550             case R.id.menu_share:
 551                 shareNote();
 552                 return true;
 553             case R.id.menu_trash:
 554                 if (!isAdded()) {
 555                     return false;
 556                 }
 557 
 558                 deleteNote();
 559                 return true;
 560             case android.R.id.home:
 561                 if (!isAdded()) {
 562                     return false;
 563                 }
 564 
 565                 requireActivity().finish();
 566                 return true;
 567             default:
 568                 return super.onOptionsItemSelected(item);
 569         }
 570     }
 571 
 572     @Override
 573     public void onPrepareOptionsMenu(@NonNull Menu menu) {
 574         if (mNote != null) {
 575             MenuItem pinItem = menu.findItem(R.id.menu_pin);
 576             MenuItem shareItem = menu.findItem(R.id.menu_share);
 577             MenuItem historyItem = menu.findItem(R.id.menu_history);
 578             MenuItem publishItem = menu.findItem(R.id.menu_publish);
 579             MenuItem copyLinkItem = menu.findItem(R.id.menu_copy);
 580             MenuItem markdownItem = menu.findItem(R.id.menu_markdown);
 581             MenuItem trashItem = menu.findItem(R.id.menu_trash);
 582             mChecklistMenuItem = menu.findItem(R.id.menu_checklist);
 583             mInformationMenuItem = menu.findItem(R.id.menu_info).setVisible(true);
 584 
 585             pinItem.setChecked(mNote.isPinned());
 586             publishItem.setChecked(mNote.isPublished());
 587             markdownItem.setChecked(mNote.isMarkdownEnabled());
 588 
 589             // Disable actions when note is in Trash or markdown view is shown on large device.
 590             if (mNote.isDeleted() || (mMarkdown != null &amp;&amp; mMarkdown.getVisibility() == View.VISIBLE)) {
 591                 pinItem.setEnabled(false);
 592                 shareItem.setEnabled(false);
 593                 historyItem.setEnabled(false);
 594                 publishItem.setEnabled(false);
 595                 copyLinkItem.setEnabled(false);
 596                 markdownItem.setEnabled(false);
 597                 mChecklistMenuItem.setEnabled(false);
 598                 DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 0.3);  // 0.3 is 30% opacity.
 599             } else {
 600                 pinItem.setEnabled(true);
 601                 shareItem.setEnabled(true);
 602                 historyItem.setEnabled(true);
 603                 publishItem.setEnabled(true);
 604                 copyLinkItem.setEnabled(mNote.isPublished());
 605                 markdownItem.setEnabled(true);
 606                 mChecklistMenuItem.setEnabled(true);
 607                 DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 1.0);  // 1.0 is 100% opacity.
 608             }
 609 
 610             if (mNote.isDeleted()) {
 611                 trashItem.setTitle(R.string.restore);
 612             } else {
 613                 trashItem.setTitle(R.string.trash);
 614             }
 615         }
 616 
 617         DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 618         super.onPrepareOptionsMenu(menu);
 619     }
 620 
 621     public void insertChecklist() {
 622         DrawableUtils.startAnimatedVectorDrawable(mChecklistMenuItem.getIcon());
 623 
 624         try {
 625             mContentEditText.insertChecklist();
 626         } catch (Exception e) {
 627             e.printStackTrace();
 628             return;
 629         }
 630 
 631         AnalyticsTracker.track(
 632             EDITOR_CHECKLIST_INSERTED,
 633             CATEGORY_NOTE,
 634             &quot;toolbar_button&quot;
 635         );
 636     }
 637 
 638     @Override
 639     public void onCheckboxToggled() {
 640         // Save note (using delay) after toggling a checkbox
 641         if (mAutoSaveHandler != null) {
 642             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 643             mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 644         }
 645     }
 646 
 647     private void deleteNote() {
 648         NoteUtils.deleteNote(mNote, getActivity());
 649         requireActivity().finish();
 650     }
 651 
 652     protected void clearMarkdown() {
 653         mMarkdown.loadDataWithBaseURL(&quot;file:///android_asset/&quot;, mCss + &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 654     }
 655 
 656     protected void hideMarkdown() {
 657         mMarkdown.setVisibility(View.INVISIBLE);
 658     }
 659 
 660     protected void showMarkdown() {
 661         loadMarkdownData();
 662         mMarkdown.setVisibility(View.VISIBLE);
 663 
 664         new Handler().postDelayed(
 665             new Runnable() {
 666                 @Override
 667                 public void run() {
 668                     requireActivity().invalidateOptionsMenu();
 669                 }
 670             },
 671             getResources().getInteger(R.integer.time_animation)
 672         );
 673     }
 674 
 675     public void shareNote() {
 676         if (mNote != null) {
 677             mContentEditText.clearFocus();
 678             showShareSheet();
 679             AnalyticsTracker.track(
 680                 EDITOR_NOTE_CONTENT_SHARED,
 681                 CATEGORY_NOTE,
 682                 &quot;action_bar_share_button&quot;
 683             );
 684         }
 685     }
 686 
 687     public void showHistory() {
 688         if (mNote != null &amp;&amp; mNote.getVersion() &gt; 1) {
 689             mContentEditText.clearFocus();
 690             mHistoryTimeoutHandler.postDelayed(mHistoryTimeoutRunnable, HISTORY_TIMEOUT);
 691             showHistorySheet();
 692         } else {
 693             Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 694         }
 695     }
 696 
 697     public void showInfo() {
 698         DrawableUtils.startAnimatedVectorDrawable(mInformationMenuItem.getIcon());
 699 
 700         if (mNote != null) {
 701             mContentEditText.clearFocus();
 702             saveNote();
 703             showInfoSheet();
 704         }
 705     }
 706 
 707     private void setMarkdown(boolean isChecked) {
 708         mIsMarkdownEnabled = isChecked;
 709         Activity activity = getActivity();
 710 
 711         if (activity instanceof NoteEditorActivity) {
 712             NoteEditorActivity editorActivity = (NoteEditorActivity) activity;
 713 
 714             if (mIsMarkdownEnabled) {
 715                 editorActivity.showTabs();
 716 
 717                 if (mNoteMarkdownFragment == null) {
 718                     // Get markdown fragment and update content
 719                     mNoteMarkdownFragment = editorActivity.getNoteMarkdownFragment();
 720                     mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPlainTextContent());
 721                 }
 722             } else {
 723                 editorActivity.hideTabs();
 724             }
 725         } else if (activity instanceof NotesActivity) {
 726             setMarkdownEnabled(mIsMarkdownEnabled);
 727             ((NotesActivity) getActivity()).setMarkdownShowing(false);
 728         }
 729 
 730         saveNote();
 731 
 732         // Set preference so that next new note will have markdown enabled.
 733         SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(requireContext());
 734         SharedPreferences.Editor editor = prefs.edit();
 735         editor.putBoolean(PrefUtils.PREF_MARKDOWN_ENABLED, isChecked);
 736         editor.apply();
 737     }
 738 
 739     protected void setMarkdownEnabled(boolean enabled) {
 740         mIsMarkdownEnabled = enabled;
 741 
 742         if (mIsMarkdownEnabled) {
 743             loadMarkdownData();
 744         }
 745     }
 746 
 747     private void loadMarkdownData() {
 748         String formattedContent = NoteMarkdownFragment.getMarkdownFormattedContent(
 749                 mCss,
 750                 mContentEditText.getPlainTextContent()
 751         );
 752 
 753         mMarkdown.loadDataWithBaseURL(null, formattedContent, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 754     }
 755 
 756     public void setNote(String noteID, String matchOffsets) {
 757         if (mAutoSaveHandler != null)
 758             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 759 
 760         mPlaceholderView.setVisibility(View.GONE);
 761 
 762         if (matchOffsets != null) {
 763             mMatchOffsets = matchOffsets;
 764         } else {
 765             mMatchOffsets = null;
 766         }
 767 
 768 
 769         saveNote();
 770 
 771         new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteID);
 772     }
 773 
 774     private void updateNote(Note updatedNote) {
 775         // update note if network change arrived
 776         mNote = updatedNote;
 777         refreshContent(true);
 778     }
 779 
 780     private void refreshContent(boolean isNoteUpdate) {
 781         if (mNote != null) {
 782             // Restore the cursor position if possible.
<abbr title=" 783             int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.getSelectionEnd());"> 783             int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEdðŸ”µ</abbr>
 784             mContentEditText.setText(mNote.getContent());
 785 
 786             if (isNoteUpdate) {
 787                 // Update markdown and preview flags from updated note.
 788                 mIsMarkdownEnabled = mNote.isMarkdownEnabled();
 789                 mIsPreviewEnabled = mNote.isPreviewEnabled();
 790 
 791                 // Show/Hide tabs based on markdown flag.
 792                 setMarkdown(mIsMarkdownEnabled);
 793 
 794                 // Save note so any local changes get synced.
 795                 mNote.save();
 796 
 797                 // Update current note object on large screen devices in landscape orientation.
 798                 if (DisplayUtils.isLargeScreenLandscape(requireContext())) {
 799                     ((NotesActivity) requireActivity()).setCurrentNote(mNote);
 800                 }
 801 
 802                 // Update overflow popup menu.
 803                 requireActivity().invalidateOptionsMenu();
 804 
 805                 if (mContentEditText.hasFocus()
 806                         &amp;&amp; cursorPosition != mContentEditText.getSelectionEnd()
 807                         &amp;&amp; cursorPosition &lt; mContentEditText.getText().length()) {
 808                     mContentEditText.setSelection(cursorPosition);
 809                 }
 810             }
 811 
 812             afterTextChanged(mContentEditText.getText());
 813             mContentEditText.processChecklists();
 814             updateTagList();
 815         }
 816     }
 817 
 818     private void updateTagList() {
 819         setChips(mNote.getTagString());
 820         mTagInput.setText(&quot;&quot;);
 821     }
 822 
 823     private int newCursorLocation(String newText, String oldText, int cursorLocation) {
 824         // Ported from the iOS app :)
 825         // Cases:
 826         // 0. All text after cursor (and possibly more) was removed ==&gt; put cursor at end
 827         // 1. Text was added after the cursor ==&gt; no change
 828         // 2. Text was added before the cursor ==&gt; location advances
 829         // 3. Text was removed after the cursor ==&gt; no change
 830         // 4. Text was removed before the cursor ==&gt; location retreats
 831         // 5. Text was added/removed on both sides of the cursor ==&gt; not handled
 832 
 833         cursorLocation = Math.max(cursorLocation, 0);
 834 
 835         int newCursorLocation = cursorLocation;
 836 
 837         int deltaLength = newText.length() - oldText.length();
 838 
 839         // Case 0
 840         if (newText.length() &lt; cursorLocation)
 841             return newText.length();
 842 
 843         boolean beforeCursorMatches = false;
 844         boolean afterCursorMatches = false;
 845 
 846         try {
<abbr title=" 847             beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation));"> 847             beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorðŸ”µ</abbr>
<abbr title=" 848             afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaLength));"> 848             afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocatioðŸ”µ</abbr>
 849         } catch (Exception e) {
 850             e.printStackTrace();
 851         }
 852 
 853         // Cases 2 and 4
 854         if (!beforeCursorMatches &amp;&amp; afterCursorMatches)
 855             newCursorLocation += deltaLength;
 856 
 857         // Cases 1, 3 and 5 have no change
 858         return newCursorLocation;
 859     }
 860 
 861     @Override
 862     public void onTagAdded(String tag) {
 863         if (mNote == null || !isAdded()) {
 864             return;
 865         }
 866 
 867         if (mNote.getTagString() != null &amp;&amp; tag.length() &gt; mNote.getTagString().length()) {
 868             AnalyticsTracker.track(
 869                 EDITOR_TAG_ADDED,
 870                 CATEGORY_NOTE,
 871                 &quot;tag_added_to_note&quot;
 872             );
 873         }
 874 
 875         mNote.setTagString(mNote.getTagString() + String.valueOf(SPACE) + tag);
 876         mNote.setModificationDate(Calendar.getInstance());
 877         updateTagList();
 878         mNote.save();
 879     }
 880 
 881     @Override
 882     public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
 883         // Unused
 884     }
 885 
 886     @Override
 887     public void afterTextChanged(Editable editable) {
 888         attemptAutoList(editable);
 889         setTitleSpan(editable);
 890         mContentEditText.fixLineSpacing();
 891     }
 892 
 893     @Override
 894     public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
 895         // When text changes, start timer that will fire after AUTOSAVE_DELAY_MILLIS passes
 896         if (mAutoSaveHandler != null) {
 897             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 898             mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 899         }
 900 
 901         // Remove search highlight spans when note content changes
 902         if (mMatchOffsets != null) {
 903             mMatchOffsets = null;
 904             mHighlighter.removeMatches();
 905         }
 906 
 907         if (!DisplayUtils.isLargeScreenLandscape(requireContext())) {
 908             ((NoteEditorActivity) requireActivity()).setSearchMatchBarVisible(false);
 909         }
 910 
 911         // Temporarily remove the text watcher as we process checklists to prevent callback looping
 912         mContentEditText.removeTextChangedListener(this);
 913         mContentEditText.processChecklists();
 914         mContentEditText.addTextChangedListener(this);
 915     }
 916 
 917     /**
 918      * Set the note title to be a larger size and bold style.
 919      *
 920      * Remove all existing spans before applying spans or performance issues will occur.  Since both
 921      * {@link RelativeSizeSpan} and {@link StyleSpan} inherit from {@link MetricAffectingSpan}, all
 922      * spans are removed when {@link MetricAffectingSpan} is removed.
 923      */
 924     private void setTitleSpan(Editable editable) {
<abbr title=" 925         for (MetricAffectingSpan span : editable.getSpans(0, editable.length(), MetricAffectingSpan.class)) {"> 925         for (MetricAffectingSpan span : editable.getSpans(0, editable.length(), MetricAffectingSpan.classðŸ”µ</abbr>
 926             if (span instanceof RelativeSizeSpan || span instanceof StyleSpan) {
 927                 editable.removeSpan(span);
 928             }
 929         }
 930 
 931         int newLinePosition = getNoteContentString().indexOf(&quot;\n&quot;);
 932 
 933         if (newLinePosition == 0) {
 934             return;
 935         }
 936 
 937         int titleEndPosition = (newLinePosition &gt; 0) ? newLinePosition : editable.length();
<abbr title=" 938         editable.setSpan(new RelativeSizeSpan(1.3f), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);"> 938         editable.setSpan(new RelativeSizeSpan(1.3f), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVðŸ”µ</abbr>
<abbr title=" 939         editable.setSpan(new StyleSpan(Typeface.BOLD), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);"> 939         editable.setSpan(new StyleSpan(Typeface.BOLD), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSðŸ”µ</abbr>
 940     }
 941 
 942     private void attemptAutoList(Editable editable) {
 943         int oldCursorPosition = mCurrentCursorPosition;
 944         mCurrentCursorPosition = mContentEditText.getSelectionStart();
 945         AutoBullet.apply(editable, oldCursorPosition, mCurrentCursorPosition);
 946         mCurrentCursorPosition = mContentEditText.getSelectionStart();
 947     }
 948 
 949     private void saveAndSyncNote() {
 950         if (mNote == null) {
 951             return;
 952         }
 953 
 954         new SaveNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 955     }
 956 
 957     public boolean isPlaceholderVisible() {
 958         if (mPlaceholderView != null) {
 959             return mPlaceholderView.getVisibility() == View.VISIBLE;
 960         } else {
 961             return false;
 962         }
 963     }
 964 
 965     public void setPlaceholderVisible(boolean isVisible) {
 966         if (isVisible) {
 967             mNote = null;
 968             mContentEditText.setText(&quot;&quot;);
 969         }
 970 
 971         if (mPlaceholderView != null) {
 972             mPlaceholderView.setVisibility(isVisible ? View.VISIBLE : View.GONE);
 973         }
 974     }
 975 
 976     @Override
 977     public void onFocusChange(View v, boolean hasFocus) {
 978         if (!hasFocus) {
 979             String tags = getNoteTagsString().trim();
 980 
 981             if (mTagInput.getText().toString().trim().length() &gt; 0) {
 982                 onTagAdded(mTagInput.getText().toString());
 983             } else if (tags.length() &gt; 0) {
 984                 setChips(tags);
 985             }
 986         }
 987     }
 988 
 989     private Note getNote() {
 990         return mNote;
 991     }
 992 
 993     public void setNote(String noteID) {
 994         setNote(noteID, null);
 995     }
 996 
 997     private String getNoteContentString() {
 998         if (mContentEditText == null || mContentEditText.getText() == null) {
 999             return &quot;&quot;;
1000         } else {
1001             return mContentEditText.getText().toString();
1002         }
1003     }
1004 
1005     private String getNoteTagsString() {
1006         StringBuilder tags = new StringBuilder();
1007 
1008         for (int i= 0; i &lt; mTagChips.getChildCount(); i++) {
1009             tags.append(((Chip) mTagChips.getChildAt(i)).getText()).append(&quot; &quot;);
1010         }
1011 
1012         return tags.toString();
1013     }
1014 
1015     /**
1016      * Share bottom sheet callbacks
1017      */
1018 
1019     @Override
1020     public void onSharePublishClicked() {
1021         publishNote();
1022         if (mShareBottomSheet != null) {
1023             mShareBottomSheet.dismiss();
1024         }
1025     }
1026 
1027     @Override
1028     public void onShareUnpublishClicked() {
1029         unpublishNote();
1030         if (mShareBottomSheet != null) {
1031             mShareBottomSheet.dismiss();
1032         }
1033     }
1034 
1035     @Override
1036     public void onWordPressPostClicked() {
1037         if (mShareBottomSheet != null) {
1038             mShareBottomSheet.dismiss();
1039         }
1040 
1041         if (getFragmentManager() == null) {
1042             return;
1043         }
1044 
1045         FragmentTransaction ft = getFragmentManager().beginTransaction();
1046         Fragment prev = getFragmentManager().findFragmentByTag(WordPressDialogFragment.DIALOG_TAG);
1047         if (prev != null) {
1048             ft.remove(prev);
1049         }
1050         ft.addToBackStack(null);
1051 
1052         // Create and show the dialog.
1053         WordPressDialogFragment wpDialogFragment = new WordPressDialogFragment();
1054         wpDialogFragment.setNote(mNote);
1055         wpDialogFragment.show(ft, WordPressDialogFragment.DIALOG_TAG);
1056     }
1057 
1058     @Override
1059     public void onShareCollaborateClicked() {
1060         Toast.makeText(getActivity(), R.string.collaborate_message, Toast.LENGTH_LONG).show();
1061     }
1062 
1063     @Override
1064     public void onShareDismissed() {
1065 
1066     }
1067 
1068     /**
1069      * History bottom sheet listeners
1070      */
1071 
1072     @Override
1073     public void onHistoryCancelClicked() {
1074         mContentEditText.setText(mNote.getContent());
1075         if (mHistoryBottomSheet != null) {
1076             mHistoryBottomSheet.dismiss();
1077         }
1078     }
1079 
1080     @Override
1081     public void onHistoryRestoreClicked() {
1082         if (mHistoryBottomSheet != null) {
1083             mHistoryBottomSheet.dismiss();
1084         }
1085         saveAndSyncNote();
1086     }
1087 
1088     @Override
1089     public void onHistoryDismissed() {
1090         if (!mHistoryBottomSheet.didTapOnButton()) {
1091             mContentEditText.setText(mNote.getContent());
1092         }
1093 
1094         if (mHistoryTimeoutHandler != null) {
1095             mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
1096         }
1097     }
1098 
1099     @Override
1100     public void onHistoryUpdateNote(String content) {
1101         mContentEditText.setText(content);
1102     }
1103 
1104     protected void saveNote() {
1105         try {
1106             if (mNote == null || mNotesBucket == null || mContentEditText == null || mIsLoadingNote ||
<abbr title="1107                 (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing())) {">1107                 (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomðŸ”µ</abbr>
1108                 return;
1109             } else {
1110                 mNote = mNotesBucket.get(mNote.getSimperiumKey());
1111                 mIsPreviewEnabled = mNote.isPreviewEnabled();
1112             }
1113 
1114             String content = mContentEditText.getPlainTextContent();
1115             String tagString = getNoteTagsString();
1116 
<abbr title="1117             if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnabled)) {">1117             if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPrevðŸ”µ</abbr>
1118                 mNote.setContent(content);
1119                 mNote.setTagString(tagString);
1120                 mNote.setModificationDate(Calendar.getInstance());
1121                 mNote.setMarkdownEnabled(mIsMarkdownEnabled);
1122                 mNote.setPreviewEnabled(mIsPreviewEnabled);
1123                 mNote.save();
1124 
1125                 AnalyticsTracker.track(
1126                     EDITOR_NOTE_EDITED,
1127                     CATEGORY_NOTE,
1128                     &quot;editor_save&quot;
1129                 );
1130             }
1131         } catch (BucketObjectMissingException exception) {
1132             exception.printStackTrace();
1133         }
1134     }
1135 
1136     // Checks if cursor is at a URL when the selection changes
1137     // If it is a URL, show the contextual action bar
1138     @Override
1139     public void onSelectionChanged(int selStart, int selEnd) {
1140         mCurrentCursorPosition = selEnd;
1141         if (selStart == selEnd) {
1142             Editable noteContent = mContentEditText.getText();
1143             if (noteContent == null)
1144                 return;
1145 
1146             URLSpan[] urlSpans = noteContent.getSpans(selStart, selStart, URLSpan.class);
1147             if (urlSpans.length &gt; 0) {
1148                 URLSpan urlSpan = urlSpans[0];
1149                 mLinkUrl = urlSpan.getURL();
<abbr title="1150                 mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSpan)).toString();">1150                 mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpaðŸ”µ</abbr>
1151                 if (mActionMode != null) {
1152                     mActionMode.setSubtitle(mLinkText);
1153                     updateMenuItems();
1154                     return;
1155                 }
1156 
1157                 // Show the Contextual Action Bar
1158                 if (getActivity() != null) {
<abbr title="1159                     mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCallback);">1159                     mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCðŸ”µ</abbr>
1160                     if (mActionMode != null) {
1161                         mActionMode.setSubtitle(mLinkText);
1162                     }
1163 
1164                     updateMenuItems();
1165                 }
1166             } else if (mActionMode != null) {
1167                 mActionMode.finish();
1168                 mActionMode = null;
1169             }
1170         } else if (mActionMode != null) {
1171             mActionMode.finish();
1172             mActionMode = null;
1173         }
1174     }
1175 
1176     private void updateMenuItems() {
1177         mCopyMenuItem.setIcon(mCopyIcon);
1178         mShareMenuItem.setIcon(mShareIcon);
1179 
1180         if (mViewLinkMenuItem != null &amp;&amp; mLinkUrl != null) {
1181             if (mLinkUrl.startsWith(&quot;tel:&quot;)) {
1182                 mViewLinkMenuItem.setIcon(mCallIcon);
1183                 mViewLinkMenuItem.setTitle(getString(R.string.call));
1184             } else if (mLinkUrl.startsWith(&quot;mailto:&quot;)) {
1185                 mViewLinkMenuItem.setIcon(mEmailIcon);
1186                 mViewLinkMenuItem.setTitle(getString(R.string.email));
1187             } else if (mLinkUrl.startsWith(&quot;geo:&quot;)) {
1188                 mViewLinkMenuItem.setIcon(mMapIcon);
1189                 mViewLinkMenuItem.setTitle(getString(R.string.view_map));
1190             } else {
1191                 mViewLinkMenuItem.setIcon(mBrowserIcon);
1192                 mViewLinkMenuItem.setTitle(getString(R.string.view_in_browser));
1193             }
1194         }
1195     }
1196 
1197     private void setPublishedNote(boolean isPublished) {
1198         if (mNote != null) {
1199             mNote.setPublished(isPublished);
1200             mNote.save();
1201 
1202             // reset publish status in 20 seconds if we don&#x27;t hear back from Simperium
1203             mPublishTimeoutHandler.postDelayed(mPublishTimeoutRunnable, PUBLISH_TIMEOUT);
1204 
1205             AnalyticsTracker.track(
1206                 isPublished ? EDITOR_NOTE_PUBLISHED : EDITOR_NOTE_UNPUBLISHED,
1207                 CATEGORY_NOTE,
1208                 &quot;publish_note_button&quot;
1209             );
1210         }
1211     }
1212 
1213     private void updatePublishedState(boolean isSuccess) {
1214         if (mPublishingSnackbar == null) {
1215             return;
1216         }
1217 
1218         mPublishingSnackbar.dismiss();
1219         mPublishingSnackbar = null;
1220 
1221         if (isSuccess &amp;&amp; isAdded()) {
1222             if (mNote.isPublished()) {
1223                 if (mHideActionOnSuccess) {
1224                     Snackbar.make(mRootView, R.string.publish_successful, Snackbar.LENGTH_LONG)
1225                             .show();
1226                 } else {
1227                     Snackbar.make(mRootView, R.string.publish_successful, Snackbar.LENGTH_LONG)
1228                             .setAction(
1229                                 R.string.undo,
1230                                 new View.OnClickListener() {
1231                                     @Override
1232                                     public void onClick(View v) {
1233                                         mHideActionOnSuccess = true;
1234                                         unpublishNote();
1235                                     }
1236                                 }
1237                             )
1238                             .show();
1239                 }
1240 
1241                 BrowserUtils.copyToClipboard(requireContext(), mNote.getPublishedUrl());
1242             } else {
1243                 if (mHideActionOnSuccess) {
1244                     Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG)
1245                             .show();
1246                 } else {
1247                     Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG)
1248                             .setAction(
1249                                 R.string.undo,
1250                                 new View.OnClickListener() {
1251                                     @Override
1252                                     public void onClick(View v) {
1253                                         mHideActionOnSuccess = true;
1254                                         publishNote();
1255                                     }
1256                                 }
1257                             )
1258                             .show();
1259                 }
1260             }
1261         } else {
1262             if (mNote.isPublished()) {
1263                 Snackbar.make(mRootView, R.string.unpublish_error, Snackbar.LENGTH_LONG)
1264                         .setAction(
1265                             R.string.retry,
1266                             new View.OnClickListener() {
1267                                 @Override
1268                                 public void onClick(View v) {
1269                                     mHideActionOnSuccess = true;
1270                                     unpublishNote();
1271                                 }
1272                             }
1273                         ).show();
1274             } else {
1275                 Snackbar.make(mRootView, R.string.publish_error, Snackbar.LENGTH_LONG)
1276                         .setAction(
1277                             R.string.retry,
1278                             new View.OnClickListener() {
1279                                 @Override
1280                                 public void onClick(View v) {
1281                                     mHideActionOnSuccess = true;
1282                                     publishNote();
1283                                 }
1284                             }
1285                         ).show();
1286             }
1287         }
1288 
1289         mHideActionOnSuccess = false;
1290         requireActivity().invalidateOptionsMenu();
1291     }
1292 
1293     private void publishNote() {
1294         if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1295             Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1296             return;
1297         }
1298 
1299         if (isAdded()) {
<abbr title="1300             mPublishingSnackbar = Snackbar.make(mRootView, R.string.publishing, Snackbar.LENGTH_INDEFINITE);">1300             mPublishingSnackbar = Snackbar.make(mRootView, R.string.publishing, Snackbar.LENGTH_INDEFINITðŸ”µ</abbr>
1301             mPublishingSnackbar.show();
1302         }
1303 
1304         setPublishedNote(true);
1305     }
1306 
1307     private void unpublishNote() {
1308         if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1309             Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1310             return;
1311         }
1312 
1313         if (isAdded()) {
<abbr title="1314             mPublishingSnackbar = Snackbar.make(mRootView, R.string.unpublishing, Snackbar.LENGTH_INDEFINITE);">1314             mPublishingSnackbar = Snackbar.make(mRootView, R.string.unpublishing, Snackbar.LENGTH_INDEFINðŸ”µ</abbr>
1315             mPublishingSnackbar.show();
1316         }
1317 
1318         setPublishedNote(false);
1319     }
1320 
1321 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
1322 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1323         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1324 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1325         setPublishedNote(false);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1326     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1327 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1328     private void copyToClipboard(String text) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1329         ClipboardManager clipboard = (ClipboardManager) requireActivity()</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1330                 .getSystemService(Context.CLIPBOARD_SERVICE);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1331         ClipData clip = ClipData.newPlainText(getString(R.string.app_name), text);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1332         if (clipboard != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1333             clipboard.setPrimaryClip(clip);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1334         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1335     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1336 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1337     private void showShareSheet() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1338         if (isAdded() &amp;&amp; mShareBottomSheet != null &amp;&amp; !mShareBottomSheet.isAdded()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1339             mShareBottomSheet.show(requireFragmentManager(), mNote);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1340         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1341     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1342 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1343     private void showInfoSheet() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1344         if (isAdded() &amp;&amp; mInfoBottomSheet != null &amp;&amp; !mInfoBottomSheet.isAdded()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1345             mInfoBottomSheet.show(requireFragmentManager(), mNote);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1346         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1347     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1348 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1349     private void showHistorySheet() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1350         if (isAdded() &amp;&amp; mHistoryBottomSheet != null &amp;&amp; !mHistoryBottomSheet.isAdded()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1351             // Request revisions for the current note</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="1352             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbacks());">1352             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbaðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1353             saveNote();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1354 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1355             mHistoryBottomSheet.show(requireFragmentManager(), mNote);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1356         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1357     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1358 </span>
1359 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1360     private void copyToClipboard(String text) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1361         ClipboardManager clipboard = (ClipboardManager) requireActivity()</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1362                 .getSystemService(Context.CLIPBOARD_SERVICE);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1363         ClipData clip = ClipData.newPlainText(getString(R.string.app_name), text);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1364         if (clipboard != null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1365             clipboard.setPrimaryClip(clip);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1366         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1367     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1368 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1369     private void showShare(String text) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1370         startActivity(</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1371             ShareCompat.IntentBuilder.from(requireActivity())</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1372                 .setText(text)</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1373                 .setType(&quot;text/plain&quot;)</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1374                 .createChooserIntent()</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1375         );</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1376     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1377 </span>
1378 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
1379     private void showShareSheet() {
1380         if (isAdded() &amp;&amp; mShareBottomSheet != null &amp;&amp; !mShareBottomSheet.isAdded()) {
1381             mShareBottomSheet.show(requireFragmentManager(), mNote);
1382         }
1383     }
1384 
1385     private void showInfoSheet() {
1386         if (isAdded() &amp;&amp; mInfoBottomSheet != null &amp;&amp; !mInfoBottomSheet.isAdded()) {
1387             mInfoBottomSheet.show(requireFragmentManager(), mNote);
1388         }
1389     }
1390 
1391     private void showHistorySheet() {
1392         if (isAdded() &amp;&amp; mHistoryBottomSheet != null &amp;&amp; !mHistoryBottomSheet.isAdded()) {
1393             // Request revisions for the current note
<abbr title="1394             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbacks());">1394             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbaðŸ”µ</abbr>
1395             saveNote();
1396 
1397             mHistoryBottomSheet.show(requireFragmentManager(), mNote);
1398         }
1399     }
1400 
1401     /**
1402      * Simperium listeners
1403      */
1404 
1405     @Override
1406     public void onDeleteObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1407 
1408     }
1409 
1410     @Override
<abbr title="1411     public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) {">1411     public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) ðŸ”µ</abbr>
1412         if (changeType == Bucket.ChangeType.MODIFY) {
1413             if (getNote() != null &amp;&amp; getNote().getSimperiumKey().equals(key)) {
1414                 try {
1415                     final Note updatedNote = mNotesBucket.get(key);
1416                     if (getActivity() != null) {
1417                         getActivity().runOnUiThread(new Runnable() {
1418                             @Override
1419                             public void run() {
1420                                 if (mPublishTimeoutHandler != null) {
1421                                     mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
1422                                 }
1423 
1424                                 updateNote(updatedNote);
1425                                 updatePublishedState(true);
1426                             }
1427                         });
1428                     }
1429                 } catch (BucketObjectMissingException e) {
1430                     e.printStackTrace();
1431                 }
1432             }
1433         }
1434     }
1435 
1436     @Override
1437     public void onSaveObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1438         if (mIsPaused) {
1439             mNotesBucket.removeListener(this);
1440             mNotesBucket.stop();
1441         }
1442     }
1443 
1444     @Override
1445     public void onBeforeUpdateObject(Bucket&lt;Note&gt; bucket, Note note) {
1446         // Don&#x27;t apply updates if we haven&#x27;t loaded the note yet
1447         if (mIsLoadingNote)
1448             return;
1449 
1450         Note openNote = getNote();
1451         if (openNote == null || !openNote.getSimperiumKey().equals(note.getSimperiumKey()))
1452             return;
1453 
1454         note.setContent(mContentEditText.getPlainTextContent());
1455     }
1456 
1457     private static class LoadNoteTask extends AsyncTask&lt;String, Void, Void&gt; {
1458         WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1459 
1460         LoadNoteTask(NoteEditorFragment fragment) {
1461             mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1462         }
1463 
1464         @Override
1465         protected void onPreExecute() {
1466             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1467 
1468             if (fragment != null) {
1469                 fragment.mContentEditText.removeTextChangedListener(fragment);
1470                 fragment.mIsLoadingNote = true;
1471             }
1472         }
1473 
1474         @Override
1475         protected Void doInBackground(String... args) {
1476             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1477 
1478             if (fragment == null || fragment.getActivity() == null) {
1479                 return null;
1480             }
1481 
1482             String noteID = args[0];
1483             Simplenote application = (Simplenote) fragment.getActivity().getApplication();
1484             Bucket&lt;Note&gt; notesBucket = application.getNotesBucket();
1485 
1486             try {
1487                 fragment.mNote = notesBucket.get(noteID);
1488 
1489                 // Set the current note in NotesActivity when on a tablet
1490                 if (fragment.getActivity() instanceof NotesActivity) {
1491                     ((NotesActivity) fragment.getActivity()).setCurrentNote(fragment.mNote);
1492                 }
1493 
1494                 // Set markdown and preview flags for current note
1495                 if (fragment.mNote != null) {
1496                     fragment.mIsMarkdownEnabled = fragment.mNote.isMarkdownEnabled();
1497                     fragment.mIsPreviewEnabled = fragment.mNote.isPreviewEnabled();
1498                 }
1499             } catch (BucketObjectMissingException e) {
1500                 // See if the note is in the object store
1501                 Bucket.ObjectCursor&lt;Note&gt; notesCursor = notesBucket.allObjects();
1502 
1503                 while (notesCursor.moveToNext()) {
1504                     Note currentNote = notesCursor.getObject();
1505 
1506                     if (currentNote != null &amp;&amp; currentNote.getSimperiumKey().equals(noteID)) {
1507                         fragment.mNote = currentNote;
1508                         return null;
1509                     }
1510                 }
1511             }
1512 
1513             return null;
1514         }
1515 
1516         @Override
1517         protected void onPostExecute(Void nada) {
1518             final NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
<abbr title="1519             if (fragment == null || fragment.getActivity() == null || fragment.getActivity().isFinishing()) {">1519             if (fragment == null || fragment.getActivity() == null || fragment.getActivity().isFinishing(ðŸ”µ</abbr>
1520                 return;
1521             }
1522 
1523             fragment.refreshContent(false);
1524 
1525             if (fragment.mMatchOffsets != null) {
<abbr title="1526                 int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.CONTENT_PROPERTY);">1526                 int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndeðŸ”µ</abbr>
1527                 fragment.mHighlighter.highlightMatches(fragment.mMatchOffsets, columnIndex);
1528                 fragment.mShouldScrollToSearchMatch = true;
1529             }
1530 
1531             fragment.mContentEditText.addTextChangedListener(fragment);
1532 
1533             if (fragment.mNote != null &amp;&amp; fragment.mNote.getContent().isEmpty()) {
1534                 // Show soft keyboard
1535                 fragment.mContentEditText.requestFocus();
1536 
1537                 new Handler().postDelayed(new Runnable() {
1538                     @Override
1539                     public void run() {
1540                         if (fragment.getActivity() == null) {
1541                             return;
1542                         }
1543 
<abbr title="1544                         InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);">1544                         InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivityðŸ”µ</abbr>
1545 
1546                         if (inputMethodManager != null) {
1547                             inputMethodManager.showSoftInput(fragment.mContentEditText, 0);
1548                         }
1549                     }
1550                 }, 100);
1551             } else if (fragment.mNote != null) {
1552                 // If we have a valid note, hide the placeholder
1553                 fragment.setPlaceholderVisible(false);
1554             }
1555 
1556             fragment.updateMarkdownView();
1557             fragment.requireActivity().invalidateOptionsMenu();
1558             fragment.linkifyEditorContent();
1559             fragment.mIsLoadingNote = false;
1560         }
1561     }
1562 
1563     private static class SaveNoteTask extends AsyncTask&lt;Void, Void, Void&gt; {
1564         WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1565 
1566         SaveNoteTask(NoteEditorFragment fragment) {
1567             mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1568         }
1569 
1570         @Override
1571         protected Void doInBackground(Void... args) {
1572             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1573 
1574             if (fragment != null) {
1575                 fragment.saveNote();
1576             }
1577 
1578             return null;
1579         }
1580 
1581         @Override
1582         protected void onPostExecute(Void nada) {
1583             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1584 
<abbr title="1585             if (fragment != null &amp;&amp; fragment.getActivity() != null &amp;&amp; !fragment.getActivity().isFinishing()) {">1585             if (fragment != null &amp;&amp; fragment.getActivity() != null &amp;&amp; !fragment.getActivity().isFinishingðŸ”µ</abbr>
1586                 // Update links
1587                 fragment.linkifyEditorContent();
1588                 fragment.updateMarkdownView();
1589             }
1590         }
1591     }
1592 
1593     private void linkifyEditorContent() {
1594         if (getActivity() == null || getActivity().isFinishing()) {
1595             return;
1596         }
1597 
1598         if (PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_DETECT_LINKS)) {
1599             SimplenoteLinkify.addLinks(mContentEditText, Linkify.ALL);
1600         }
1601     }
1602 
1603     // Show tabs if markdown is enabled globally, for current note, and not tablet landscape
1604     private void updateMarkdownView() {
1605         if (!mIsMarkdownEnabled) {
1606             return;
1607         }
1608 
1609         Activity activity = getActivity();
1610         if (activity instanceof NotesActivity) {
1611             // This fragment lives in NotesActivity, so load markdown in this fragment&#x27;s WebView.
1612             loadMarkdownData();
1613         } else {
1614             // This fragment lives in the NoteEditorActivity&#x27;s ViewPager.
1615             if (mNoteMarkdownFragment == null) {
1616                 mNoteMarkdownFragment = ((NoteEditorActivity) requireActivity())
1617                         .getNoteMarkdownFragment();
1618                 ((NoteEditorActivity) requireActivity()).showTabs();
1619             }
1620             // Load markdown in the sibling NoteMarkdownFragment&#x27;s WebView.
1621             mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPlainTextContent());
1622         }
1623     }
1624 
1625     private ColorStateList getChipBackgroundColor() {
1626         int[][] states = new int[][] {
1627             new int[] { android.R.attr.state_checked}, // checked
1628             new int[] {-android.R.attr.state_checked}  // unchecked
1629         };
1630 
1631         int[] colors = new int[] {
1632             ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOnBackgroundColor),
1633             ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOffBackgroundColor)
1634         };
1635 
1636         return new ColorStateList(states, colors);
1637     }
1638 
1639     private void setChips(CharSequence text) {
1640         mTagPadding.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1641         mTagChips.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1642         mTagChips.setSingleSelection(true);
1643         mTagChips.removeAllViews();
1644         SimpleStringSplitter tags = new SimpleStringSplitter(SPACE);
1645         tags.setString(text.toString());
1646 
1647         for (String tag : tags) {
1648             final Chip chip = new Chip(requireContext());
1649             chip.setText(tag);
1650             chip.setCheckable(true);
1651             chip.setCheckedIcon(null);
1652             chip.setChipBackgroundColor(getChipBackgroundColor());
1653             chip.setTextColor(ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipTextColor));
1654             chip.setStateListAnimator(null);
1655             chip.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
1656                 @Override
1657                 public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
1658                     chip.setCloseIconVisible(isChecked);
1659                 }
1660             });
1661             chip.setOnCloseIconClickListener(new View.OnClickListener() {
1662                 @Override
1663                 public void onClick(View view) {
1664                     mTagChips.removeView(view);
1665                     updateTags();
1666                     AnalyticsTracker.track(
1667                         EDITOR_TAG_REMOVED,
1668                         CATEGORY_NOTE,
1669                         &quot;tag_removed_from_note&quot;
1670                     );
1671                 }
1672             });
1673             mTagChips.addView(chip);
1674         }
1675     }
1676 
1677     private void updateTags() {
1678         if (mNote == null) {
1679             return;
1680         }
1681 
1682         mNote.setTagString(getNoteTagsString());
1683         mNote.setModificationDate(Calendar.getInstance());
1684         updateTagList();
1685         mNote.save();
1686     }
1687 }</pre></td>
                            <td><pre>   1 package com.automattic.simplenote;
   2 
   3 import android.app.Activity;
   4 import android.content.Context;
   5 import android.content.SharedPreferences;
   6 import android.content.res.ColorStateList;
   7 import android.database.Cursor;
   8 import android.graphics.Typeface;
   9 import android.graphics.drawable.Drawable;
  10 import android.os.AsyncTask;
  11 import android.os.Bundle;
  12 import android.os.Handler;
  13 import android.text.Editable;
  14 import android.text.Layout;
  15 import android.text.Spanned;
  16 import android.text.TextUtils.SimpleStringSplitter;
  17 import android.text.TextWatcher;
  18 import android.text.style.MetricAffectingSpan;
  19 import android.text.style.RelativeSizeSpan;
  20 import android.text.style.StyleSpan;
  21 import android.text.style.URLSpan;
  22 import android.text.util.Linkify;
  23 import android.util.TypedValue;
  24 import android.view.LayoutInflater;
  25 import android.view.Menu;
  26 import android.view.MenuInflater;
  27 import android.view.MenuItem;
  28 import android.view.View;
  29 import android.view.ViewGroup;
  30 import android.view.ViewTreeObserver;
  31 import android.view.inputmethod.InputMethodManager;
  32 import android.webkit.WebView;
  33 import android.widget.CompoundButton;
  34 import android.widget.CursorAdapter;
  35 import android.widget.LinearLayout;
  36 import android.widget.TextView;
  37 import android.widget.Toast;
  38 
  39 import androidx.annotation.NonNull;
  40 import androidx.appcompat.app.AppCompatActivity;
  41 import androidx.appcompat.view.ActionMode;
  42 import androidx.core.app.ShareCompat;
  43 import androidx.core.view.MenuCompat;
  44 import androidx.core.widget.NestedScrollView;
  45 import androidx.fragment.app.Fragment;
  46 import androidx.fragment.app.FragmentTransaction;
  47 import androidx.preference.PreferenceManager;
  48 
  49 import com.automattic.simplenote.analytics.AnalyticsTracker;
  50 import com.automattic.simplenote.models.Note;
  51 import com.automattic.simplenote.models.Tag;
  52 import com.automattic.simplenote.utils.AutoBullet;
  53 import com.automattic.simplenote.utils.BrowserUtils;
  54 import com.automattic.simplenote.utils.ContextUtils;
  55 import com.automattic.simplenote.utils.DisplayUtils;
  56 import com.automattic.simplenote.utils.DrawableUtils;
  57 import com.automattic.simplenote.utils.MatchOffsetHighlighter;
  58 import com.automattic.simplenote.utils.NetworkUtils;
  59 import com.automattic.simplenote.utils.NoteUtils;
  60 import com.automattic.simplenote.utils.PrefUtils;
  61 import com.automattic.simplenote.utils.SimplenoteLinkify;
  62 import com.automattic.simplenote.utils.SimplenoteMovementMethod;
  63 import com.automattic.simplenote.utils.SpaceTokenizer;
  64 import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;
  65 import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;
  66 import com.automattic.simplenote.utils.TextHighlighter;
  67 import com.automattic.simplenote.utils.ThemeUtils;
  68 import com.automattic.simplenote.utils.WidgetUtils;
  69 import com.automattic.simplenote.widgets.SimplenoteEditText;
  70 import com.google.android.material.chip.Chip;
  71 import com.google.android.material.chip.ChipGroup;
  72 import com.google.android.material.snackbar.Snackbar;
  73 import com.simperium.client.Bucket;
  74 import com.simperium.client.BucketObjectMissingException;
  75 import com.simperium.client.Query;
  76 
  77 import java.lang.ref.WeakReference;
  78 import java.util.Calendar;
  79 
  80 import static com.automattic.simplenote.analytics.AnalyticsTracker.CATEGORY_NOTE;
  81 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_CHECKLIST_INSERTED;
  82 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_CONTENT_SHARED;
  83 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_EDITED;
  84 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_PUBLISHED;
  85 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_UNPUBLISHED;
  86 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_ADDED;
  87 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_REMOVED;
  88 import static com.automattic.simplenote.utils.SearchTokenizer.SPACE;
  89 
  90 public class NoteEditorFragment extends Fragment implements Bucket.Listener&lt;Note&gt;,
  91         TextWatcher, OnTagAddedListener, View.OnFocusChangeListener,
  92         SimplenoteEditText.OnSelectionChangedListener,
  93         ShareBottomSheetDialog.ShareSheetListener,
  94         HistoryBottomSheetDialog.HistorySheetListener,
  95         SimplenoteEditText.OnCheckboxToggledListener {
  96 
  97     public static final String ARG_IS_FROM_WIDGET = &quot;is_from_widget&quot;;
  98     public static final String ARG_ITEM_ID = &quot;item_id&quot;;
  99     public static final String ARG_NEW_NOTE = &quot;new_note&quot;;
 100     public static final String ARG_MATCH_OFFSETS = &quot;match_offsets&quot;;
 101     public static final String ARG_MARKDOWN_ENABLED = &quot;markdown_enabled&quot;;
 102     public static final String ARG_PREVIEW_ENABLED = &quot;preview_enabled&quot;;
 103     private static final String STATE_NOTE_ID = &quot;state_note_id&quot;;
 104     private static final int AUTOSAVE_DELAY_MILLIS = 2000;
 105     private static final int MAX_REVISIONS = 30;
 106     private static final int PUBLISH_TIMEOUT = 20000;
 107     private static final int HISTORY_TIMEOUT = 10000;
 108     private Note mNote;
 109     private final Runnable mAutoSaveRunnable = new Runnable() {
 110         @Override
 111         public void run() {
 112             saveAndSyncNote();
 113         }
 114     };
 115     private Bucket&lt;Note&gt; mNotesBucket;
 116     private View mRootView;
 117     private View mTagPadding;
 118     private SimplenoteEditText mContentEditText;
 119     private ChipGroup mTagChips;
 120     private TagsMultiAutoCompleteTextView mTagInput;
 121     private Handler mAutoSaveHandler;
 122     private Handler mPublishTimeoutHandler;
 123     private Handler mHistoryTimeoutHandler;
 124     private LinearLayout mPlaceholderView;
 125     private CursorAdapter mAutocompleteAdapter;
 126     private boolean mIsLoadingNote;
 127     private boolean mIsMarkdownEnabled;
 128     private boolean mIsPreviewEnabled;
 129     private boolean mShouldScrollToSearchMatch;
 130     private ActionMode mActionMode;
 131     private MenuItem mChecklistMenuItem;
 132     private MenuItem mCopyMenuItem;
 133     private MenuItem mInformationMenuItem;
 134     private MenuItem mShareMenuItem;
 135     private MenuItem mViewLinkMenuItem;
 136     private String mLinkUrl;
 137     private String mLinkText;
 138     private MatchOffsetHighlighter mHighlighter;
 139     private Drawable mCallIcon;
 140     private Drawable mCopyIcon;
 141     private Drawable mEmailIcon;
 142     private Drawable mMapIcon;
 143     private Drawable mShareIcon;
 144     private Drawable mBrowserIcon;
 145     private MatchOffsetHighlighter.SpanFactory mMatchHighlighter;
 146     private String mMatchOffsets;
 147     private int mCurrentCursorPosition;
 148     private HistoryBottomSheetDialog mHistoryBottomSheet;
 149     private boolean mIsPaused;
 150     private boolean mIsFromWidget;
 151 
 152     // Hides the history bottom sheet if no revisions are loaded
 153     private final Runnable mHistoryTimeoutRunnable = new Runnable() {
 154         @Override
 155         public void run() {
 156             if (!isAdded()) {
 157                 return;
 158             }
 159 
 160             requireActivity().runOnUiThread(new Runnable() {
 161                 @Override
 162                 public void run() {
<abbr title=" 163                     if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; !mHistoryBottomSheet.isHistoryLoaded()) {"> 163                     if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowðŸ”µ</abbr>
 164                         mHistoryBottomSheet.dismiss();
 165                         Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 166                     }
 167                 }
 168             });
 169         }
 170     };
 171     private InfoBottomSheetDialog mInfoBottomSheet;
 172     private ShareBottomSheetDialog mShareBottomSheet;
 173     // Contextual action bar for dealing with links
 174     private final ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
 175         // Called when the action mode is created; startActionMode() was called
 176         @Override
 177         public boolean onCreateActionMode(ActionMode mode, Menu menu) {
 178             // Inflate a menu resource providing context menu items
 179             MenuInflater inflater = mode.getMenuInflater();
 180 
 181             if (inflater != null) {
 182                 inflater.inflate(R.menu.view_link, menu);
 183                 mCopyMenuItem = menu.findItem(R.id.menu_copy);
 184                 mShareMenuItem = menu.findItem(R.id.menu_share);
 185                 mViewLinkMenuItem = menu.findItem(R.id.menu_view_link);
 186                 mode.setTitle(getString(R.string.link));
 187                 mode.setTitleOptionalHint(false);
 188 
 189                 DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 190             }
 191 
<abbr title=" 192             int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.background_dark;"> 192             int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.colðŸ”µ</abbr>
<abbr title=" 193             requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().getTheme()));"> 193             requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireAcðŸ”µ</abbr>
 194             return true;
 195         }
 196 
 197         // Called each time the action mode is shown. Always called after onCreateActionMode, but
 198         // may be called multiple times if the mode is invalidated.
 199         @Override
 200         public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 201             return false; // Return false if nothing is done
 202         }
 203 
 204         // Called when the user selects a contextual menu item
 205         @Override
 206         public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 207             switch (item.getItemId()) {
 208                 case R.id.menu_view_link:
 209                     if (mLinkUrl != null) {
 210                         try {
 211                             BrowserUtils.launchBrowserOrShowError(requireContext(), mLinkUrl);
 212                         } catch (Exception e) {
 213                             e.printStackTrace();
 214                         }
 215 
 216                         mode.finish(); // Action picked, so close the CAB
 217                     }
 218                     return true;
 219                 case R.id.menu_copy:
 220                     if (mLinkText != null &amp;&amp; getActivity() != null) {
 221                         BrowserUtils.copyToClipboard(requireContext(), mLinkText);
 222                         Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 223                         mode.finish();
 224                     }
 225                     return true;
 226                 case R.id.menu_share:
 227                     if (mLinkText != null) {
 228                         showShare(mLinkText);
 229                         mode.finish();
 230                     }
 231                     return true;
 232                 default:
 233                     return false;
 234             }
 235         }
 236 
 237         // Called when the user exits the action mode
 238         @Override
 239         public void onDestroyActionMode(ActionMode mode) {
 240             mActionMode = null;
 241             new Handler().postDelayed(
 242                 new Runnable() {
 243                     @Override
 244                     public void run() {
<abbr title=" 245                         requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 245                         requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.RðŸ”µ</abbr>
 246                     }
 247                 },
 248                 requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime)
 249             );
 250         }
 251     };
 252     private Snackbar mPublishingSnackbar;
 253     private boolean mHideActionOnSuccess;
 254     // Resets note publish status if Simperium never returned the new publish status
 255     private final Runnable mPublishTimeoutRunnable = new Runnable() {
 256         @Override
 257         public void run() {
 258             if (!isAdded()) return;
 259 
 260             requireActivity().runOnUiThread(new Runnable() {
 261                 @Override
 262                 public void run() {
 263 
 264                     mNote.setPublished(!mNote.isPublished());
 265                     mNote.save();
 266 
 267                     updatePublishedState(false);
 268                 }
 269             });
 270         }
 271     };
 272     private NoteMarkdownFragment mNoteMarkdownFragment;
 273     private String mCss;
 274     private WebView mMarkdown;
 275 
 276     /**
 277      * Mandatory empty constructor for the fragment manager to instantiate the
 278      * fragment (e.g. upon screen orientation changes).
 279      */
 280     public NoteEditorFragment() {
 281     }
 282 
 283     @Override
 284     public void onCreate(Bundle savedInstanceState) {
 285         super.onCreate(savedInstanceState);
 286         mInfoBottomSheet = new InfoBottomSheetDialog(this);
 287         mShareBottomSheet = new ShareBottomSheetDialog(this, this);
 288         mHistoryBottomSheet = new HistoryBottomSheetDialog(this, this);
 289 
 290         Simplenote currentApp = (Simplenote) requireActivity().getApplication();
 291         mNotesBucket = currentApp.getNotesBucket();
 292 
<abbr title=" 293         mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.actionModeTextColor);"> 293         mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp,ðŸ”µ</abbr>
<abbr title=" 294         mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.attr.actionModeTextColor);"> 294         mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.aðŸ”µ</abbr>
<abbr title=" 295         mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.actionModeTextColor);"> 295         mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.ðŸ”µ</abbr>
<abbr title=" 296         mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp, R.attr.actionModeTextColor);"> 296         mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp,ðŸ”µ</abbr>
<abbr title=" 297         mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attr.actionModeTextColor);"> 297         mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attðŸ”µ</abbr>
<abbr title=" 298         mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.attr.actionModeTextColor);"> 298         mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.aðŸ”µ</abbr>
 299 
 300         mAutoSaveHandler = new Handler();
 301         mPublishTimeoutHandler = new Handler();
 302         mHistoryTimeoutHandler = new Handler();
 303 
 304         mMatchHighlighter = new TextHighlighter(requireActivity(),
<abbr title=" 305                 R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor);"> 305                 R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor)ðŸ”µ</abbr>
 306         mAutocompleteAdapter = new CursorAdapter(getActivity(), null, 0x0) {
 307             @Override
 308             public View newView(Context context, Cursor cursor, ViewGroup parent) {
 309                 Activity activity = (Activity) context;
 310                 if (activity == null) return null;
 311                 return activity.getLayoutInflater().inflate(R.layout.tag_autocomplete_list_item, null);
 312             }
 313 
 314             @Override
 315             public void bindView(View view, Context context, Cursor cursor) {
 316                 TextView textView = (TextView) view;
 317                 textView.setText(convertToString(cursor));
 318             }
 319 
 320             @Override
 321             public CharSequence convertToString(Cursor cursor) {
 322                 return cursor.getString(cursor.getColumnIndex(Tag.NAME_PROPERTY));
 323             }
 324 
 325             @Override
 326             public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 327                 Activity activity = getActivity();
 328                 if (activity == null) return null;
 329                 Simplenote application = (Simplenote) activity.getApplication();
 330                 Query&lt;Tag&gt; query = application.getTagsBucket().query();
 331                 // make the tag name available to the cursor
 332                 query.include(Tag.NAME_PROPERTY);
 333                 // sort the tags by their names
 334                 query.order(Tag.NAME_PROPERTY);
 335                 // if there&#x27;s a filter string find only matching tag names
 336                 if (filter != null)
<abbr title=" 337                     query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filter));"> 337                     query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filteðŸ”µ</abbr>
 338                 return query.execute();
 339             }
 340         };
 341 
 342         WidgetUtils.updateNoteWidgets(requireActivity().getApplicationContext());
 343     }
 344 
 345     @Override
<abbr title=" 346     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {"> 346     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceSðŸ”µ</abbr>
 347         mRootView = inflater.inflate(R.layout.fragment_note_editor, container, false);
 348         mContentEditText = mRootView.findViewById(R.id.note_content);
 349         mContentEditText.addOnSelectionChangedListener(this);
 350         mContentEditText.setOnCheckboxToggledListener(this);
 351         mContentEditText.setMovementMethod(SimplenoteMovementMethod.getInstance());
 352         mContentEditText.setOnFocusChangeListener(this);
 353         mTagInput = mRootView.findViewById(R.id.tag_input);
 354         mTagInput.setDropDownBackgroundResource(R.drawable.bg_list_popup);
 355         mTagInput.setTokenizer(new SpaceTokenizer());
 356         mTagInput.setOnFocusChangeListener(this);
 357         mTagChips = mRootView.findViewById(R.id.tag_chips);
 358         mTagPadding = mRootView.findViewById(R.id.tag_padding);
 359         mHighlighter = new MatchOffsetHighlighter(mMatchHighlighter, mContentEditText);
 360         mPlaceholderView = mRootView.findViewById(R.id.placeholder);
 361 
 362         if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote == null) {
 363             mPlaceholderView.setVisibility(View.VISIBLE);
 364             requireActivity().invalidateOptionsMenu();
 365             mMarkdown = mRootView.findViewById(R.id.markdown);
 366             mCss = ThemeUtils.isLightTheme(requireContext())
 367                     ? ContextUtils.readCssFile(requireContext(), &quot;light.css&quot;)
 368                     : ContextUtils.readCssFile(requireContext(), &quot;dark.css&quot;);
 369         }
 370 
 371         mTagInput.setAdapter(mAutocompleteAdapter);
 372         Bundle arguments = getArguments();
 373 
 374         if (arguments != null &amp;&amp; arguments.containsKey(ARG_ITEM_ID)) {
 375             // Load note if we were passed a note Id
 376             String key = arguments.getString(ARG_ITEM_ID);
 377 
 378             if (arguments.containsKey(ARG_MATCH_OFFSETS)) {
 379                 mMatchOffsets = arguments.getString(ARG_MATCH_OFFSETS);
 380             }
 381 
 382             mIsFromWidget = arguments.getBoolean(ARG_IS_FROM_WIDGET);
 383             new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, key);
 384         } else if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; savedInstanceState != null) {
 385             // Restore selected note when in dual pane mode
 386             String noteId = savedInstanceState.getString(STATE_NOTE_ID);
 387 
 388             if (noteId != null) {
 389                 setNote(noteId);
 390             }
 391         }
 392 
 393         ViewTreeObserver viewTreeObserver = mContentEditText.getViewTreeObserver();
 394         viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
 395             @Override
 396             public void onGlobalLayout() {
 397                 // If a note was loaded with search matches, scroll to the first match in the editor
 398                 if (mShouldScrollToSearchMatch &amp;&amp; mMatchOffsets != null) {
 399                     if (!isAdded()) {
 400                         return;
 401                     }
 402 
 403                     // Get the character location of the first search match
 404                     int matchLocation = MatchOffsetHighlighter.getFirstMatchLocation(
 405                             mContentEditText.getText(),
 406                             mMatchOffsets
 407                     );
 408                     if (matchLocation == 0) {
 409                         return;
 410                     }
 411 
 412                     // Calculate how far to scroll to bring the match into view
 413                     Layout layout = mContentEditText.getLayout();
 414                     int lineTop = layout.getLineTop(layout.getLineForOffset(matchLocation));
 415                     ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 416                     mShouldScrollToSearchMatch = false;
 417                 }
 418             }
 419         });
 420         setHasOptionsMenu(true);
 421         return mRootView;
 422     }
 423 
 424     public void scrollToMatch(int location) {
 425         if (isAdded()) {
 426             // Calculate how far to scroll to bring the match into view
 427             Layout layout = mContentEditText.getLayout();
 428             int lineTop = layout.getLineTop(layout.getLineForOffset(location));
 429             ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 430         }
 431     }
 432 
 433     @Override
 434     public void onResume() {
 435         super.onResume();
 436         mNotesBucket.start();
 437         mNotesBucket.addListener(this);
 438         mTagInput.setOnTagAddedListener(this);
 439 
 440         if (mContentEditText != null) {
<abbr title=" 441             mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(getActivity()));"> 441             mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(getActivity())ðŸ”µ</abbr>
 442 
 443             if (mContentEditText.hasFocus()) {
 444                 showSoftKeyboard();
 445             }
 446         }
 447     }
 448 
 449     private void showSoftKeyboard() {
 450         new Handler().postDelayed(new Runnable() {
 451             @Override
 452             public void run() {
 453                 if (getActivity() == null) {
 454                     return;
 455                 }
 456 
<abbr title=" 457                 InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);"> 457                 InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemServiðŸ”µ</abbr>
 458                 if (inputMethodManager != null) {
 459                     inputMethodManager.showSoftInput(mContentEditText, 0);
 460                 }
 461             }
 462         }, 100);
 463     }
 464 
 465     @Override
 466     public void onPause() {
 467         super.onPause();  // Always call the superclass method first
 468         mIsPaused = true;
 469 
 470         // Hide soft keyboard if it is showing...
 471         DisplayUtils.hideKeyboard(mContentEditText);
 472 
 473         mTagInput.setOnTagAddedListener(null);
 474 
 475         if (mAutoSaveHandler != null) {
 476             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 477         }
 478 
 479         if (mPublishTimeoutHandler != null) {
 480             mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
 481         }
 482 
 483         if (mHistoryTimeoutHandler != null) {
 484             mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 485         }
 486 
 487         mHighlighter.stop();
 488         saveNote();
 489     }
 490 
 491     @Override
 492     public void onDestroy() {
 493         super.onDestroy();
 494         mNotesBucket.removeListener(this);
 495         mNotesBucket.stop();
 496     }
 497 
 498     @Override
 499     public void onSaveInstanceState(@NonNull Bundle outState) {
 500         super.onSaveInstanceState(outState);
 501 
 502         if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote != null) {
 503             outState.putString(STATE_NOTE_ID, mNote.getSimperiumKey());
 504         }
 505     }
 506 
 507     @Override
 508     public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
 509         super.onCreateOptionsMenu(menu, inflater);
 510 
<abbr title=" 511         if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFragment == null)) {"> 511         if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMðŸ”µ</abbr>
 512             return;
 513         }
 514 
 515         inflater.inflate(R.menu.note_editor, menu);
 516         MenuCompat.setGroupDividerEnabled(menu, true);
 517     }
 518 
 519     @Override
 520     public boolean onOptionsItemSelected(@NonNull MenuItem item) {
 521         switch (item.getItemId()) {
 522             case R.id.menu_checklist:
 523                 insertChecklist();
 524                 return true;
 525             case R.id.menu_copy:
 526                 BrowserUtils.copyToClipboard(requireContext(), mNote.getPublishedUrl());
 527                 Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 528                 return true;
 529             case R.id.menu_history:
 530                 showHistory();
 531                 return true;
 532             case R.id.menu_info:
 533                 showInfo();
 534                 return true;
 535             case R.id.menu_markdown:
 536                 setMarkdown(!item.isChecked());
 537                 return true;
 538             case R.id.menu_pin:
 539                 NoteUtils.setNotePin(mNote, !item.isChecked());
 540                 requireActivity().invalidateOptionsMenu();
 541                 return true;
 542             case R.id.menu_publish:
 543                 if (item.isChecked()) {
 544                     unpublishNote();
 545                 } else {
 546                     publishNote();
 547                 }
 548 
 549                 return true;
 550             case R.id.menu_share:
 551                 shareNote();
 552                 return true;
 553             case R.id.menu_trash:
 554                 if (!isAdded()) {
 555                     return false;
 556                 }
 557 
 558                 deleteNote();
 559                 return true;
 560             case android.R.id.home:
 561                 if (!isAdded()) {
 562                     return false;
 563                 }
 564 
 565                 requireActivity().finish();
 566                 return true;
 567             default:
 568                 return super.onOptionsItemSelected(item);
 569         }
 570     }
 571 
 572     @Override
 573     public void onPrepareOptionsMenu(@NonNull Menu menu) {
 574         if (mNote != null) {
 575             MenuItem pinItem = menu.findItem(R.id.menu_pin);
 576             MenuItem shareItem = menu.findItem(R.id.menu_share);
 577             MenuItem historyItem = menu.findItem(R.id.menu_history);
 578             MenuItem publishItem = menu.findItem(R.id.menu_publish);
 579             MenuItem copyLinkItem = menu.findItem(R.id.menu_copy);
 580             MenuItem markdownItem = menu.findItem(R.id.menu_markdown);
 581             MenuItem trashItem = menu.findItem(R.id.menu_trash);
 582             mChecklistMenuItem = menu.findItem(R.id.menu_checklist);
 583             mInformationMenuItem = menu.findItem(R.id.menu_info).setVisible(true);
 584 
 585             pinItem.setChecked(mNote.isPinned());
 586             publishItem.setChecked(mNote.isPublished());
 587             markdownItem.setChecked(mNote.isMarkdownEnabled());
 588 
 589             // Disable actions when note is in Trash or markdown view is shown on large device.
 590             if (mNote.isDeleted() || (mMarkdown != null &amp;&amp; mMarkdown.getVisibility() == View.VISIBLE)) {
 591                 pinItem.setEnabled(false);
 592                 shareItem.setEnabled(false);
 593                 historyItem.setEnabled(false);
 594                 publishItem.setEnabled(false);
 595                 copyLinkItem.setEnabled(false);
 596                 markdownItem.setEnabled(false);
 597                 mChecklistMenuItem.setEnabled(false);
 598                 DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 0.3);  // 0.3 is 30% opacity.
 599             } else {
 600                 pinItem.setEnabled(true);
 601                 shareItem.setEnabled(true);
 602                 historyItem.setEnabled(true);
 603                 publishItem.setEnabled(true);
 604                 copyLinkItem.setEnabled(mNote.isPublished());
 605                 markdownItem.setEnabled(true);
 606                 mChecklistMenuItem.setEnabled(true);
 607                 DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 1.0);  // 1.0 is 100% opacity.
 608             }
 609 
 610             if (mNote.isDeleted()) {
 611                 trashItem.setTitle(R.string.restore);
 612             } else {
 613                 trashItem.setTitle(R.string.trash);
 614             }
 615         }
 616 
 617         DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 618         super.onPrepareOptionsMenu(menu);
 619     }
 620 
 621     public void insertChecklist() {
 622         DrawableUtils.startAnimatedVectorDrawable(mChecklistMenuItem.getIcon());
 623 
 624         try {
 625             mContentEditText.insertChecklist();
 626         } catch (Exception e) {
 627             e.printStackTrace();
 628             return;
 629         }
 630 
 631         AnalyticsTracker.track(
 632             EDITOR_CHECKLIST_INSERTED,
 633             CATEGORY_NOTE,
 634             &quot;toolbar_button&quot;
 635         );
 636     }
 637 
 638     @Override
 639     public void onCheckboxToggled() {
 640         // Save note (using delay) after toggling a checkbox
 641         if (mAutoSaveHandler != null) {
 642             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 643             mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 644         }
 645     }
 646 
 647     private void deleteNote() {
 648         NoteUtils.deleteNote(mNote, getActivity());
 649         requireActivity().finish();
 650     }
 651 
 652     protected void clearMarkdown() {
 653         mMarkdown.loadDataWithBaseURL(&quot;file:///android_asset/&quot;, mCss + &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 654     }
 655 
 656     protected void hideMarkdown() {
 657         mMarkdown.setVisibility(View.INVISIBLE);
 658     }
 659 
 660     protected void showMarkdown() {
 661         loadMarkdownData();
 662         mMarkdown.setVisibility(View.VISIBLE);
 663 
 664         new Handler().postDelayed(
 665             new Runnable() {
 666                 @Override
 667                 public void run() {
 668                     requireActivity().invalidateOptionsMenu();
 669                 }
 670             },
 671             getResources().getInteger(R.integer.time_animation)
 672         );
 673     }
 674 
 675     public void shareNote() {
 676         if (mNote != null) {
 677             mContentEditText.clearFocus();
 678             showShareSheet();
 679             AnalyticsTracker.track(
 680                 EDITOR_NOTE_CONTENT_SHARED,
 681                 CATEGORY_NOTE,
 682                 &quot;action_bar_share_button&quot;
 683             );
 684         }
 685     }
 686 
 687     public void showHistory() {
 688         if (mNote != null &amp;&amp; mNote.getVersion() &gt; 1) {
 689             mContentEditText.clearFocus();
 690             mHistoryTimeoutHandler.postDelayed(mHistoryTimeoutRunnable, HISTORY_TIMEOUT);
 691             showHistorySheet();
 692         } else {
 693             Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 694         }
 695     }
 696 
 697     public void showInfo() {
 698         DrawableUtils.startAnimatedVectorDrawable(mInformationMenuItem.getIcon());
 699 
 700         if (mNote != null) {
 701             mContentEditText.clearFocus();
 702             saveNote();
 703             showInfoSheet();
 704         }
 705     }
 706 
 707     private void setMarkdown(boolean isChecked) {
 708         mIsMarkdownEnabled = isChecked;
 709         Activity activity = getActivity();
 710 
 711         if (activity instanceof NoteEditorActivity) {
 712             NoteEditorActivity editorActivity = (NoteEditorActivity) activity;
 713 
 714             if (mIsMarkdownEnabled) {
 715                 editorActivity.showTabs();
 716 
 717                 if (mNoteMarkdownFragment == null) {
 718                     // Get markdown fragment and update content
 719                     mNoteMarkdownFragment = editorActivity.getNoteMarkdownFragment();
 720                     mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPlainTextContent());
 721                 }
 722             } else {
 723                 editorActivity.hideTabs();
 724             }
 725         } else if (activity instanceof NotesActivity) {
 726             setMarkdownEnabled(mIsMarkdownEnabled);
 727             ((NotesActivity) getActivity()).setMarkdownShowing(false);
 728         }
 729 
 730         saveNote();
 731 
 732         // Set preference so that next new note will have markdown enabled.
 733         SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(requireContext());
 734         SharedPreferences.Editor editor = prefs.edit();
 735         editor.putBoolean(PrefUtils.PREF_MARKDOWN_ENABLED, isChecked);
 736         editor.apply();
 737     }
 738 
 739     protected void setMarkdownEnabled(boolean enabled) {
 740         mIsMarkdownEnabled = enabled;
 741 
 742         if (mIsMarkdownEnabled) {
 743             loadMarkdownData();
 744         }
 745     }
 746 
 747     private void loadMarkdownData() {
 748         String formattedContent = NoteMarkdownFragment.getMarkdownFormattedContent(
 749                 mCss,
 750                 mContentEditText.getPlainTextContent()
 751         );
 752 
 753         mMarkdown.loadDataWithBaseURL(null, formattedContent, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 754     }
 755 
 756     public void setNote(String noteID, String matchOffsets) {
 757         if (mAutoSaveHandler != null)
 758             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 759 
 760         mPlaceholderView.setVisibility(View.GONE);
 761 
 762         if (matchOffsets != null) {
 763             mMatchOffsets = matchOffsets;
 764         } else {
 765             mMatchOffsets = null;
 766         }
 767 
 768 
 769         saveNote();
 770 
 771         new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteID);
 772     }
 773 
 774     private void updateNote(Note updatedNote) {
 775         // update note if network change arrived
 776         mNote = updatedNote;
 777         refreshContent(true);
 778     }
 779 
 780     private void refreshContent(boolean isNoteUpdate) {
 781         if (mNote != null) {
 782             // Restore the cursor position if possible.
<abbr title=" 783             int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.getSelectionEnd());"> 783             int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEdðŸ”µ</abbr>
 784             mContentEditText.setText(mNote.getContent());
 785 
 786             if (isNoteUpdate) {
 787                 // Update markdown and preview flags from updated note.
 788                 mIsMarkdownEnabled = mNote.isMarkdownEnabled();
 789                 mIsPreviewEnabled = mNote.isPreviewEnabled();
 790 
 791                 // Show/Hide tabs based on markdown flag.
 792                 setMarkdown(mIsMarkdownEnabled);
 793 
 794                 // Save note so any local changes get synced.
 795                 mNote.save();
 796 
 797                 // Update current note object on large screen devices in landscape orientation.
 798                 if (DisplayUtils.isLargeScreenLandscape(requireContext())) {
 799                     ((NotesActivity) requireActivity()).setCurrentNote(mNote);
 800                 }
 801 
 802                 // Update overflow popup menu.
 803                 requireActivity().invalidateOptionsMenu();
 804 
 805                 if (mContentEditText.hasFocus()
 806                         &amp;&amp; cursorPosition != mContentEditText.getSelectionEnd()
 807                         &amp;&amp; cursorPosition &lt; mContentEditText.getText().length()) {
 808                     mContentEditText.setSelection(cursorPosition);
 809                 }
 810             }
 811 
 812             afterTextChanged(mContentEditText.getText());
 813             mContentEditText.processChecklists();
 814             updateTagList();
 815         }
 816     }
 817 
 818     private void updateTagList() {
 819         setChips(mNote.getTagString());
 820         mTagInput.setText(&quot;&quot;);
 821     }
 822 
 823     private int newCursorLocation(String newText, String oldText, int cursorLocation) {
 824         // Ported from the iOS app :)
 825         // Cases:
 826         // 0. All text after cursor (and possibly more) was removed ==&gt; put cursor at end
 827         // 1. Text was added after the cursor ==&gt; no change
 828         // 2. Text was added before the cursor ==&gt; location advances
 829         // 3. Text was removed after the cursor ==&gt; no change
 830         // 4. Text was removed before the cursor ==&gt; location retreats
 831         // 5. Text was added/removed on both sides of the cursor ==&gt; not handled
 832 
 833         cursorLocation = Math.max(cursorLocation, 0);
 834 
 835         int newCursorLocation = cursorLocation;
 836 
 837         int deltaLength = newText.length() - oldText.length();
 838 
 839         // Case 0
 840         if (newText.length() &lt; cursorLocation)
 841             return newText.length();
 842 
 843         boolean beforeCursorMatches = false;
 844         boolean afterCursorMatches = false;
 845 
 846         try {
<abbr title=" 847             beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation));"> 847             beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorðŸ”µ</abbr>
<abbr title=" 848             afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaLength));"> 848             afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocatioðŸ”µ</abbr>
 849         } catch (Exception e) {
 850             e.printStackTrace();
 851         }
 852 
 853         // Cases 2 and 4
 854         if (!beforeCursorMatches &amp;&amp; afterCursorMatches)
 855             newCursorLocation += deltaLength;
 856 
 857         // Cases 1, 3 and 5 have no change
 858         return newCursorLocation;
 859     }
 860 
 861     @Override
 862     public void onTagAdded(String tag) {
 863         if (mNote == null || !isAdded()) {
 864             return;
 865         }
 866 
 867         if (mNote.getTagString() != null &amp;&amp; tag.length() &gt; mNote.getTagString().length()) {
 868             AnalyticsTracker.track(
 869                 EDITOR_TAG_ADDED,
 870                 CATEGORY_NOTE,
 871                 &quot;tag_added_to_note&quot;
 872             );
 873         }
 874 
 875         mNote.setTagString(mNote.getTagString() + String.valueOf(SPACE) + tag);
 876         mNote.setModificationDate(Calendar.getInstance());
 877         updateTagList();
 878         mNote.save();
 879     }
 880 
 881     @Override
 882     public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
 883         // Unused
 884     }
 885 
 886     @Override
 887     public void afterTextChanged(Editable editable) {
 888         attemptAutoList(editable);
 889         setTitleSpan(editable);
 890         mContentEditText.fixLineSpacing();
 891     }
 892 
 893     @Override
 894     public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
 895         // When text changes, start timer that will fire after AUTOSAVE_DELAY_MILLIS passes
 896         if (mAutoSaveHandler != null) {
 897             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 898             mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 899         }
 900 
 901         // Remove search highlight spans when note content changes
 902         if (mMatchOffsets != null) {
 903             mMatchOffsets = null;
 904             mHighlighter.removeMatches();
 905         }
 906 
 907         if (!DisplayUtils.isLargeScreenLandscape(requireContext())) {
 908             ((NoteEditorActivity) requireActivity()).setSearchMatchBarVisible(false);
 909         }
 910 
 911         // Temporarily remove the text watcher as we process checklists to prevent callback looping
 912         mContentEditText.removeTextChangedListener(this);
 913         mContentEditText.processChecklists();
 914         mContentEditText.addTextChangedListener(this);
 915     }
 916 
 917     /**
 918      * Set the note title to be a larger size and bold style.
 919      *
 920      * Remove all existing spans before applying spans or performance issues will occur.  Since both
 921      * {@link RelativeSizeSpan} and {@link StyleSpan} inherit from {@link MetricAffectingSpan}, all
 922      * spans are removed when {@link MetricAffectingSpan} is removed.
 923      */
 924     private void setTitleSpan(Editable editable) {
<abbr title=" 925         for (MetricAffectingSpan span : editable.getSpans(0, editable.length(), MetricAffectingSpan.class)) {"> 925         for (MetricAffectingSpan span : editable.getSpans(0, editable.length(), MetricAffectingSpan.classðŸ”µ</abbr>
 926             if (span instanceof RelativeSizeSpan || span instanceof StyleSpan) {
 927                 editable.removeSpan(span);
 928             }
 929         }
 930 
 931         int newLinePosition = getNoteContentString().indexOf(&quot;\n&quot;);
 932 
 933         if (newLinePosition == 0) {
 934             return;
 935         }
 936 
 937         int titleEndPosition = (newLinePosition &gt; 0) ? newLinePosition : editable.length();
<abbr title=" 938         editable.setSpan(new RelativeSizeSpan(1.3f), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);"> 938         editable.setSpan(new RelativeSizeSpan(1.3f), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVðŸ”µ</abbr>
<abbr title=" 939         editable.setSpan(new StyleSpan(Typeface.BOLD), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);"> 939         editable.setSpan(new StyleSpan(Typeface.BOLD), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSðŸ”µ</abbr>
 940     }
 941 
 942     private void attemptAutoList(Editable editable) {
 943         int oldCursorPosition = mCurrentCursorPosition;
 944         mCurrentCursorPosition = mContentEditText.getSelectionStart();
 945         AutoBullet.apply(editable, oldCursorPosition, mCurrentCursorPosition);
 946         mCurrentCursorPosition = mContentEditText.getSelectionStart();
 947     }
 948 
 949     private void saveAndSyncNote() {
 950         if (mNote == null) {
 951             return;
 952         }
 953 
 954         new SaveNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 955     }
 956 
 957     public boolean isPlaceholderVisible() {
 958         if (mPlaceholderView != null) {
 959             return mPlaceholderView.getVisibility() == View.VISIBLE;
 960         } else {
 961             return false;
 962         }
 963     }
 964 
 965     public void setPlaceholderVisible(boolean isVisible) {
 966         if (isVisible) {
 967             mNote = null;
 968             mContentEditText.setText(&quot;&quot;);
 969         }
 970 
 971         if (mPlaceholderView != null) {
 972             mPlaceholderView.setVisibility(isVisible ? View.VISIBLE : View.GONE);
 973         }
 974     }
 975 
 976     @Override
 977     public void onFocusChange(View v, boolean hasFocus) {
 978         if (!hasFocus) {
 979             String tags = getNoteTagsString().trim();
 980 
 981             if (mTagInput.getText().toString().trim().length() &gt; 0) {
 982                 onTagAdded(mTagInput.getText().toString());
 983             } else if (tags.length() &gt; 0) {
 984                 setChips(tags);
 985             }
 986         }
 987     }
 988 
 989     private Note getNote() {
 990         return mNote;
 991     }
 992 
 993     public void setNote(String noteID) {
 994         setNote(noteID, null);
 995     }
 996 
 997     private String getNoteContentString() {
 998         if (mContentEditText == null || mContentEditText.getText() == null) {
 999             return &quot;&quot;;
1000         } else {
1001             return mContentEditText.getText().toString();
1002         }
1003     }
1004 
1005     private String getNoteTagsString() {
1006         StringBuilder tags = new StringBuilder();
1007 
1008         for (int i= 0; i &lt; mTagChips.getChildCount(); i++) {
1009             tags.append(((Chip) mTagChips.getChildAt(i)).getText()).append(&quot; &quot;);
1010         }
1011 
1012         return tags.toString();
1013     }
1014 
1015     /**
1016      * Share bottom sheet callbacks
1017      */
1018 
1019     @Override
1020     public void onSharePublishClicked() {
1021         publishNote();
1022         if (mShareBottomSheet != null) {
1023             mShareBottomSheet.dismiss();
1024         }
1025     }
1026 
1027     @Override
1028     public void onShareUnpublishClicked() {
1029         unpublishNote();
1030         if (mShareBottomSheet != null) {
1031             mShareBottomSheet.dismiss();
1032         }
1033     }
1034 
1035     @Override
1036     public void onWordPressPostClicked() {
1037         if (mShareBottomSheet != null) {
1038             mShareBottomSheet.dismiss();
1039         }
1040 
1041         if (getFragmentManager() == null) {
1042             return;
1043         }
1044 
1045         FragmentTransaction ft = getFragmentManager().beginTransaction();
1046         Fragment prev = getFragmentManager().findFragmentByTag(WordPressDialogFragment.DIALOG_TAG);
1047         if (prev != null) {
1048             ft.remove(prev);
1049         }
1050         ft.addToBackStack(null);
1051 
1052         // Create and show the dialog.
1053         WordPressDialogFragment wpDialogFragment = new WordPressDialogFragment();
1054         wpDialogFragment.setNote(mNote);
1055         wpDialogFragment.show(ft, WordPressDialogFragment.DIALOG_TAG);
1056     }
1057 
1058     @Override
1059     public void onShareCollaborateClicked() {
1060         Toast.makeText(getActivity(), R.string.collaborate_message, Toast.LENGTH_LONG).show();
1061     }
1062 
1063     @Override
1064     public void onShareDismissed() {
1065 
1066     }
1067 
1068     /**
1069      * History bottom sheet listeners
1070      */
1071 
1072     @Override
1073     public void onHistoryCancelClicked() {
1074         mContentEditText.setText(mNote.getContent());
1075         if (mHistoryBottomSheet != null) {
1076             mHistoryBottomSheet.dismiss();
1077         }
1078     }
1079 
1080     @Override
1081     public void onHistoryRestoreClicked() {
1082         if (mHistoryBottomSheet != null) {
1083             mHistoryBottomSheet.dismiss();
1084         }
1085         saveAndSyncNote();
1086     }
1087 
1088     @Override
1089     public void onHistoryDismissed() {
1090         if (!mHistoryBottomSheet.didTapOnButton()) {
1091             mContentEditText.setText(mNote.getContent());
1092         }
1093 
1094         if (mHistoryTimeoutHandler != null) {
1095             mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
1096         }
1097     }
1098 
1099     @Override
1100     public void onHistoryUpdateNote(String content) {
1101         mContentEditText.setText(content);
1102     }
1103 
1104     protected void saveNote() {
1105         try {
1106             if (mNote == null || mNotesBucket == null || mContentEditText == null || mIsLoadingNote ||
<abbr title="1107                 (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing())) {">1107                 (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomðŸ”µ</abbr>
1108                 return;
1109             } else {
1110                 mNote = mNotesBucket.get(mNote.getSimperiumKey());
1111                 mIsPreviewEnabled = mNote.isPreviewEnabled();
1112             }
1113 
1114             String content = mContentEditText.getPlainTextContent();
1115             String tagString = getNoteTagsString();
1116 
<abbr title="1117             if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnabled)) {">1117             if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPrevðŸ”µ</abbr>
1118                 mNote.setContent(content);
1119                 mNote.setTagString(tagString);
1120                 mNote.setModificationDate(Calendar.getInstance());
1121                 mNote.setMarkdownEnabled(mIsMarkdownEnabled);
1122                 mNote.setPreviewEnabled(mIsPreviewEnabled);
1123                 mNote.save();
1124 
1125                 AnalyticsTracker.track(
1126                     EDITOR_NOTE_EDITED,
1127                     CATEGORY_NOTE,
1128                     &quot;editor_save&quot;
1129                 );
1130             }
1131         } catch (BucketObjectMissingException exception) {
1132             exception.printStackTrace();
1133         }
1134     }
1135 
1136     // Checks if cursor is at a URL when the selection changes
1137     // If it is a URL, show the contextual action bar
1138     @Override
1139     public void onSelectionChanged(int selStart, int selEnd) {
1140         mCurrentCursorPosition = selEnd;
1141         if (selStart == selEnd) {
1142             Editable noteContent = mContentEditText.getText();
1143             if (noteContent == null)
1144                 return;
1145 
1146             URLSpan[] urlSpans = noteContent.getSpans(selStart, selStart, URLSpan.class);
1147             if (urlSpans.length &gt; 0) {
1148                 URLSpan urlSpan = urlSpans[0];
1149                 mLinkUrl = urlSpan.getURL();
<abbr title="1150                 mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSpan)).toString();">1150                 mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpaðŸ”µ</abbr>
1151                 if (mActionMode != null) {
1152                     mActionMode.setSubtitle(mLinkText);
1153                     updateMenuItems();
1154                     return;
1155                 }
1156 
1157                 // Show the Contextual Action Bar
1158                 if (getActivity() != null) {
<abbr title="1159                     mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCallback);">1159                     mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCðŸ”µ</abbr>
1160                     if (mActionMode != null) {
1161                         mActionMode.setSubtitle(mLinkText);
1162                     }
1163 
1164                     updateMenuItems();
1165                 }
1166             } else if (mActionMode != null) {
1167                 mActionMode.finish();
1168                 mActionMode = null;
1169             }
1170         } else if (mActionMode != null) {
1171             mActionMode.finish();
1172             mActionMode = null;
1173         }
1174     }
1175 
1176     private void updateMenuItems() {
1177         mCopyMenuItem.setIcon(mCopyIcon);
1178         mShareMenuItem.setIcon(mShareIcon);
1179 
1180         if (mViewLinkMenuItem != null &amp;&amp; mLinkUrl != null) {
1181             if (mLinkUrl.startsWith(&quot;tel:&quot;)) {
1182                 mViewLinkMenuItem.setIcon(mCallIcon);
1183                 mViewLinkMenuItem.setTitle(getString(R.string.call));
1184             } else if (mLinkUrl.startsWith(&quot;mailto:&quot;)) {
1185                 mViewLinkMenuItem.setIcon(mEmailIcon);
1186                 mViewLinkMenuItem.setTitle(getString(R.string.email));
1187             } else if (mLinkUrl.startsWith(&quot;geo:&quot;)) {
1188                 mViewLinkMenuItem.setIcon(mMapIcon);
1189                 mViewLinkMenuItem.setTitle(getString(R.string.view_map));
1190             } else {
1191                 mViewLinkMenuItem.setIcon(mBrowserIcon);
1192                 mViewLinkMenuItem.setTitle(getString(R.string.view_in_browser));
1193             }
1194         }
1195     }
1196 
1197     private void setPublishedNote(boolean isPublished) {
1198         if (mNote != null) {
1199             mNote.setPublished(isPublished);
1200             mNote.save();
1201 
1202             // reset publish status in 20 seconds if we don&#x27;t hear back from Simperium
1203             mPublishTimeoutHandler.postDelayed(mPublishTimeoutRunnable, PUBLISH_TIMEOUT);
1204 
1205             AnalyticsTracker.track(
1206                 isPublished ? EDITOR_NOTE_PUBLISHED : EDITOR_NOTE_UNPUBLISHED,
1207                 CATEGORY_NOTE,
1208                 &quot;publish_note_button&quot;
1209             );
1210         }
1211     }
1212 
1213     private void updatePublishedState(boolean isSuccess) {
1214         if (mPublishingSnackbar == null) {
1215             return;
1216         }
1217 
1218         mPublishingSnackbar.dismiss();
1219         mPublishingSnackbar = null;
1220 
1221         if (isSuccess &amp;&amp; isAdded()) {
1222             if (mNote.isPublished()) {
1223                 if (mHideActionOnSuccess) {
1224                     Snackbar.make(mRootView, R.string.publish_successful, Snackbar.LENGTH_LONG)
1225                             .show();
1226                 } else {
1227                     Snackbar.make(mRootView, R.string.publish_successful, Snackbar.LENGTH_LONG)
1228                             .setAction(
1229                                 R.string.undo,
1230                                 new View.OnClickListener() {
1231                                     @Override
1232                                     public void onClick(View v) {
1233                                         mHideActionOnSuccess = true;
1234                                         unpublishNote();
1235                                     }
1236                                 }
1237                             )
1238                             .show();
1239                 }
1240 
1241                 BrowserUtils.copyToClipboard(requireContext(), mNote.getPublishedUrl());
1242             } else {
1243                 if (mHideActionOnSuccess) {
1244                     Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG)
1245                             .show();
1246                 } else {
1247                     Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG)
1248                             .setAction(
1249                                 R.string.undo,
1250                                 new View.OnClickListener() {
1251                                     @Override
1252                                     public void onClick(View v) {
1253                                         mHideActionOnSuccess = true;
1254                                         publishNote();
1255                                     }
1256                                 }
1257                             )
1258                             .show();
1259                 }
1260             }
1261         } else {
1262             if (mNote.isPublished()) {
1263                 Snackbar.make(mRootView, R.string.unpublish_error, Snackbar.LENGTH_LONG)
1264                         .setAction(
1265                             R.string.retry,
1266                             new View.OnClickListener() {
1267                                 @Override
1268                                 public void onClick(View v) {
1269                                     mHideActionOnSuccess = true;
1270                                     unpublishNote();
1271                                 }
1272                             }
1273                         ).show();
1274             } else {
1275                 Snackbar.make(mRootView, R.string.publish_error, Snackbar.LENGTH_LONG)
1276                         .setAction(
1277                             R.string.retry,
1278                             new View.OnClickListener() {
1279                                 @Override
1280                                 public void onClick(View v) {
1281                                     mHideActionOnSuccess = true;
1282                                     publishNote();
1283                                 }
1284                             }
1285                         ).show();
1286             }
1287         }
1288 
1289         mHideActionOnSuccess = false;
1290         requireActivity().invalidateOptionsMenu();
1291     }
1292 
1293     private void publishNote() {
1294         if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1295             Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1296             return;
1297         }
1298 
1299         if (isAdded()) {
<abbr title="1300             mPublishingSnackbar = Snackbar.make(mRootView, R.string.publishing, Snackbar.LENGTH_INDEFINITE);">1300             mPublishingSnackbar = Snackbar.make(mRootView, R.string.publishing, Snackbar.LENGTH_INDEFINITðŸ”µ</abbr>
1301             mPublishingSnackbar.show();
1302         }
1303 
1304         setPublishedNote(true);
1305     }
1306 
1307     private void unpublishNote() {
1308         if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1309             Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1310             return;
1311         }
1312 
1313         if (isAdded()) {
<abbr title="1314             mPublishingSnackbar = Snackbar.make(mRootView, R.string.unpublishing, Snackbar.LENGTH_INDEFINITE);">1314             mPublishingSnackbar = Snackbar.make(mRootView, R.string.unpublishing, Snackbar.LENGTH_INDEFINðŸ”µ</abbr>
1315             mPublishingSnackbar.show();
1316         }
1317 
1318         setPublishedNote(false);
1319     }
1320 
1321     private void showShare(String text) {
1322         startActivity(
1323             ShareCompat.IntentBuilder.from(requireActivity())
1324                 .setText(text)
1325                 .setType(&quot;text/plain&quot;)
1326                 .createChooserIntent()
1327         );
1328     }
1329 
1330     private void showShareSheet() {
1331         if (isAdded() &amp;&amp; mShareBottomSheet != null &amp;&amp; !mShareBottomSheet.isAdded()) {
1332             mShareBottomSheet.show(requireFragmentManager(), mNote);
1333         }
1334     }
1335 
1336     private void showInfoSheet() {
1337         if (isAdded() &amp;&amp; mInfoBottomSheet != null &amp;&amp; !mInfoBottomSheet.isAdded()) {
1338             mInfoBottomSheet.show(requireFragmentManager(), mNote);
1339         }
1340     }
1341 
1342     private void showHistorySheet() {
1343         if (isAdded() &amp;&amp; mHistoryBottomSheet != null &amp;&amp; !mHistoryBottomSheet.isAdded()) {
1344             // Request revisions for the current note
<abbr title="1345             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbacks());">1345             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbaðŸ”µ</abbr>
1346             saveNote();
1347 
1348             mHistoryBottomSheet.show(requireFragmentManager(), mNote);
1349         }
1350     }
1351 
1352     /**
1353      * Simperium listeners
1354      */
1355 
1356     @Override
1357     public void onDeleteObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1358 
1359     }
1360 
1361     @Override
<abbr title="1362     public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) {">1362     public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) ðŸ”µ</abbr>
1363         if (changeType == Bucket.ChangeType.MODIFY) {
1364             if (getNote() != null &amp;&amp; getNote().getSimperiumKey().equals(key)) {
1365                 try {
1366                     final Note updatedNote = mNotesBucket.get(key);
1367                     if (getActivity() != null) {
1368                         getActivity().runOnUiThread(new Runnable() {
1369                             @Override
1370                             public void run() {
1371                                 if (mPublishTimeoutHandler != null) {
1372                                     mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
1373                                 }
1374 
1375                                 updateNote(updatedNote);
1376                                 updatePublishedState(true);
1377                             }
1378                         });
1379                     }
1380                 } catch (BucketObjectMissingException e) {
1381                     e.printStackTrace();
1382                 }
1383             }
1384         }
1385     }
1386 
1387     @Override
1388     public void onSaveObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1389         if (mIsPaused) {
1390             mNotesBucket.removeListener(this);
1391             mNotesBucket.stop();
1392         }
1393     }
1394 
1395     @Override
1396     public void onBeforeUpdateObject(Bucket&lt;Note&gt; bucket, Note note) {
1397         // Don&#x27;t apply updates if we haven&#x27;t loaded the note yet
1398         if (mIsLoadingNote)
1399             return;
1400 
1401         Note openNote = getNote();
1402         if (openNote == null || !openNote.getSimperiumKey().equals(note.getSimperiumKey()))
1403             return;
1404 
1405         note.setContent(mContentEditText.getPlainTextContent());
1406     }
1407 
1408     private static class LoadNoteTask extends AsyncTask&lt;String, Void, Void&gt; {
1409         WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1410 
1411         LoadNoteTask(NoteEditorFragment fragment) {
1412             mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1413         }
1414 
1415         @Override
1416         protected void onPreExecute() {
1417             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1418 
1419             if (fragment != null) {
1420                 fragment.mContentEditText.removeTextChangedListener(fragment);
1421                 fragment.mIsLoadingNote = true;
1422             }
1423         }
1424 
1425         @Override
1426         protected Void doInBackground(String... args) {
1427             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1428 
1429             if (fragment == null || fragment.getActivity() == null) {
1430                 return null;
1431             }
1432 
1433             String noteID = args[0];
1434             Simplenote application = (Simplenote) fragment.getActivity().getApplication();
1435             Bucket&lt;Note&gt; notesBucket = application.getNotesBucket();
1436 
1437             try {
1438                 fragment.mNote = notesBucket.get(noteID);
1439 
1440                 // Set the current note in NotesActivity when on a tablet
1441                 if (fragment.getActivity() instanceof NotesActivity) {
1442                     ((NotesActivity) fragment.getActivity()).setCurrentNote(fragment.mNote);
1443                 }
1444 
1445                 // Set markdown and preview flags for current note
1446                 if (fragment.mNote != null) {
1447                     fragment.mIsMarkdownEnabled = fragment.mNote.isMarkdownEnabled();
1448                     fragment.mIsPreviewEnabled = fragment.mNote.isPreviewEnabled();
1449                 }
1450             } catch (BucketObjectMissingException e) {
1451                 // See if the note is in the object store
1452                 Bucket.ObjectCursor&lt;Note&gt; notesCursor = notesBucket.allObjects();
1453 
1454                 while (notesCursor.moveToNext()) {
1455                     Note currentNote = notesCursor.getObject();
1456 
1457                     if (currentNote != null &amp;&amp; currentNote.getSimperiumKey().equals(noteID)) {
1458                         fragment.mNote = currentNote;
1459                         return null;
1460                     }
1461                 }
1462             }
1463 
1464             return null;
1465         }
1466 
1467         @Override
1468         protected void onPostExecute(Void nada) {
1469             final NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
<abbr title="1470             if (fragment == null || fragment.getActivity() == null || fragment.getActivity().isFinishing()) {">1470             if (fragment == null || fragment.getActivity() == null || fragment.getActivity().isFinishing(ðŸ”µ</abbr>
1471                 return;
1472             }
1473 
1474             fragment.refreshContent(false);
1475 
1476             if (fragment.mMatchOffsets != null) {
<abbr title="1477                 int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.CONTENT_PROPERTY);">1477                 int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndeðŸ”µ</abbr>
1478                 fragment.mHighlighter.highlightMatches(fragment.mMatchOffsets, columnIndex);
1479                 fragment.mShouldScrollToSearchMatch = true;
1480             }
1481 
1482             fragment.mContentEditText.addTextChangedListener(fragment);
1483 
1484             if (fragment.mNote != null &amp;&amp; fragment.mNote.getContent().isEmpty()) {
1485                 // Show soft keyboard
1486                 fragment.mContentEditText.requestFocus();
1487 
1488                 new Handler().postDelayed(new Runnable() {
1489                     @Override
1490                     public void run() {
1491                         if (fragment.getActivity() == null) {
1492                             return;
1493                         }
1494 
<abbr title="1495                         InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);">1495                         InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivityðŸ”µ</abbr>
1496 
1497                         if (inputMethodManager != null) {
1498                             inputMethodManager.showSoftInput(fragment.mContentEditText, 0);
1499                         }
1500                     }
1501                 }, 100);
1502             } else if (fragment.mNote != null) {
1503                 // If we have a valid note, hide the placeholder
1504                 fragment.setPlaceholderVisible(false);
1505             }
1506 
1507             fragment.updateMarkdownView();
1508             fragment.requireActivity().invalidateOptionsMenu();
1509             fragment.linkifyEditorContent();
1510             fragment.mIsLoadingNote = false;
1511         }
1512     }
1513 
1514     private static class SaveNoteTask extends AsyncTask&lt;Void, Void, Void&gt; {
1515         WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1516 
1517         SaveNoteTask(NoteEditorFragment fragment) {
1518             mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1519         }
1520 
1521         @Override
1522         protected Void doInBackground(Void... args) {
1523             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1524 
1525             if (fragment != null) {
1526                 fragment.saveNote();
1527             }
1528 
1529             return null;
1530         }
1531 
1532         @Override
1533         protected void onPostExecute(Void nada) {
1534             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1535 
<abbr title="1536             if (fragment != null &amp;&amp; fragment.getActivity() != null &amp;&amp; !fragment.getActivity().isFinishing()) {">1536             if (fragment != null &amp;&amp; fragment.getActivity() != null &amp;&amp; !fragment.getActivity().isFinishingðŸ”µ</abbr>
1537                 // Update links
1538                 fragment.linkifyEditorContent();
1539                 fragment.updateMarkdownView();
1540             }
1541         }
1542     }
1543 
1544     private void linkifyEditorContent() {
1545         if (getActivity() == null || getActivity().isFinishing()) {
1546             return;
1547         }
1548 
1549         if (PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_DETECT_LINKS)) {
1550             SimplenoteLinkify.addLinks(mContentEditText, Linkify.ALL);
1551         }
1552     }
1553 
1554     // Show tabs if markdown is enabled globally, for current note, and not tablet landscape
1555     private void updateMarkdownView() {
1556         if (!mIsMarkdownEnabled) {
1557             return;
1558         }
1559 
1560         Activity activity = getActivity();
1561         if (activity instanceof NotesActivity) {
1562             // This fragment lives in NotesActivity, so load markdown in this fragment&#x27;s WebView.
1563             loadMarkdownData();
1564         } else {
1565             // This fragment lives in the NoteEditorActivity&#x27;s ViewPager.
1566             if (mNoteMarkdownFragment == null) {
1567                 mNoteMarkdownFragment = ((NoteEditorActivity) requireActivity())
1568                         .getNoteMarkdownFragment();
1569                 ((NoteEditorActivity) requireActivity()).showTabs();
1570             }
1571             // Load markdown in the sibling NoteMarkdownFragment&#x27;s WebView.
1572             mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPlainTextContent());
1573         }
1574     }
1575 
1576     private ColorStateList getChipBackgroundColor() {
1577         int[][] states = new int[][] {
1578             new int[] { android.R.attr.state_checked}, // checked
1579             new int[] {-android.R.attr.state_checked}  // unchecked
1580         };
1581 
1582         int[] colors = new int[] {
1583             ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOnBackgroundColor),
1584             ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOffBackgroundColor)
1585         };
1586 
1587         return new ColorStateList(states, colors);
1588     }
1589 
1590     private void setChips(CharSequence text) {
1591         mTagPadding.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1592         mTagChips.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1593         mTagChips.setSingleSelection(true);
1594         mTagChips.removeAllViews();
1595         SimpleStringSplitter tags = new SimpleStringSplitter(SPACE);
1596         tags.setString(text.toString());
1597 
1598         for (String tag : tags) {
1599             final Chip chip = new Chip(requireContext());
1600             chip.setText(tag);
1601             chip.setCheckable(true);
1602             chip.setCheckedIcon(null);
1603             chip.setChipBackgroundColor(getChipBackgroundColor());
1604             chip.setTextColor(ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipTextColor));
1605             chip.setStateListAnimator(null);
1606             chip.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
1607                 @Override
1608                 public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
1609                     chip.setCloseIconVisible(isChecked);
1610                 }
1611             });
1612             chip.setOnCloseIconClickListener(new View.OnClickListener() {
1613                 @Override
1614                 public void onClick(View view) {
1615                     mTagChips.removeView(view);
1616                     updateTags();
1617                     AnalyticsTracker.track(
1618                         EDITOR_TAG_REMOVED,
1619                         CATEGORY_NOTE,
1620                         &quot;tag_removed_from_note&quot;
1621                     );
1622                 }
1623             });
1624             mTagChips.addView(chip);
1625         }
1626     }
1627 
1628     private void updateTags() {
1629         if (mNote == null) {
1630             return;
1631         }
1632 
1633         mNote.setTagString(getNoteTagsString());
1634         mNote.setModificationDate(Calendar.getInstance());
1635         updateTagList();
1636         mNote.save();
1637     }
1638 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 package com.automattic.simplenote;
   2 
   3 import android.app.Activity;
   4 import android.content.Context;
   5 import android.content.SharedPreferences;
   6 import android.content.res.ColorStateList;
   7 import android.database.Cursor;
   8 import android.graphics.Typeface;
   9 import android.graphics.drawable.Drawable;
  10 import android.os.AsyncTask;
  11 import android.os.Bundle;
  12 import android.os.Handler;
  13 import android.text.Editable;
  14 import android.text.Layout;
  15 import android.text.Spanned;
  16 import android.text.TextUtils.SimpleStringSplitter;
  17 import android.text.TextWatcher;
  18 import android.text.style.MetricAffectingSpan;
  19 import android.text.style.RelativeSizeSpan;
  20 import android.text.style.StyleSpan;
  21 import android.text.style.URLSpan;
  22 import android.text.util.Linkify;
  23 import android.util.TypedValue;
  24 import android.view.LayoutInflater;
  25 import android.view.Menu;
  26 import android.view.MenuInflater;
  27 import android.view.MenuItem;
  28 import android.view.View;
  29 import android.view.ViewGroup;
  30 import android.view.ViewTreeObserver;
  31 import android.view.inputmethod.InputMethodManager;
  32 import android.webkit.WebView;
  33 import android.widget.CompoundButton;
  34 import android.widget.CursorAdapter;
  35 import android.widget.LinearLayout;
  36 import android.widget.TextView;
  37 import android.widget.Toast;
  38 import androidx.annotation.NonNull;
  39 import androidx.appcompat.app.AppCompatActivity;
  40 import androidx.appcompat.view.ActionMode;
  41 import androidx.core.app.ShareCompat;
  42 import androidx.core.view.MenuCompat;
  43 import androidx.core.widget.NestedScrollView;
  44 import androidx.fragment.app.Fragment;
  45 import androidx.fragment.app.FragmentTransaction;
  46 import androidx.preference.PreferenceManager;
  47 import com.automattic.simplenote.analytics.AnalyticsTracker;
  48 import com.automattic.simplenote.models.Note;
  49 import com.automattic.simplenote.models.Tag;
  50 import com.automattic.simplenote.utils.AutoBullet;
  51 import com.automattic.simplenote.utils.BrowserUtils;
  52 import com.automattic.simplenote.utils.ContextUtils;
  53 import com.automattic.simplenote.utils.DisplayUtils;
  54 import com.automattic.simplenote.utils.DrawableUtils;
  55 import com.automattic.simplenote.utils.MatchOffsetHighlighter;
  56 import com.automattic.simplenote.utils.NetworkUtils;
  57 import com.automattic.simplenote.utils.NoteUtils;
  58 import com.automattic.simplenote.utils.PrefUtils;
  59 import com.automattic.simplenote.utils.SimplenoteLinkify;
  60 import com.automattic.simplenote.utils.SimplenoteMovementMethod;
  61 import com.automattic.simplenote.utils.SpaceTokenizer;
  62 import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;
  63 import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;
  64 import com.automattic.simplenote.utils.TextHighlighter;
  65 import com.automattic.simplenote.utils.ThemeUtils;
  66 import com.automattic.simplenote.utils.WidgetUtils;
  67 import com.automattic.simplenote.widgets.SimplenoteEditText;
  68 import com.google.android.material.chip.Chip;
  69 import com.google.android.material.chip.ChipGroup;
  70 import com.google.android.material.snackbar.Snackbar;
  71 import com.simperium.client.Bucket;
  72 import com.simperium.client.BucketObjectMissingException;
  73 import com.simperium.client.Query;
  74 import java.lang.ref.WeakReference;
  75 import java.util.Calendar;
  76 import static com.automattic.simplenote.analytics.AnalyticsTracker.CATEGORY_NOTE;
  77 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_CHECKLIST_INSERTED;
  78 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_CONTENT_SHARED;
  79 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_EDITED;
  80 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_PUBLISHED;
  81 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_UNPUBLISHED;
  82 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_ADDED;
  83 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_REMOVED;
  84 import static com.automattic.simplenote.utils.SearchTokenizer.SPACE;
  85 
  86 
<abbr title="  87 public class NoteEditorFragment extends Fragment implements Bucket.Listener&lt;Note&gt; , TextWatcher , OnTagAddedListener , View.OnFocusChangeListener , SimplenoteEditText.OnSelectionChangedListener , ShareBottomSheetDialog.ShareSheetListener , HistoryBottomSheetDialog.HistorySheetListener , SimplenoteEditText.OnCheckboxToggledListener {">  87 public class NoteEditorFragment extends Fragment implements Bucket.Listener&lt;Note&gt; , TextWatcher , OnTagAdðŸ”µ</abbr>
  88     public static final String ARG_IS_FROM_WIDGET = &quot;is_from_widget&quot;;
  89 
  90     public static final String ARG_ITEM_ID = &quot;item_id&quot;;
  91 
  92     public static final String ARG_NEW_NOTE = &quot;new_note&quot;;
  93 
  94     public static final String ARG_MATCH_OFFSETS = &quot;match_offsets&quot;;
  95 
  96     public static final String ARG_MARKDOWN_ENABLED = &quot;markdown_enabled&quot;;
  97 
  98     public static final String ARG_PREVIEW_ENABLED = &quot;preview_enabled&quot;;
  99 
 100     private static final String STATE_NOTE_ID = &quot;state_note_id&quot;;
 101 
 102     private static final int AUTOSAVE_DELAY_MILLIS = 2000;
 103 
 104     private static final int MAX_REVISIONS = 30;
 105 
 106     private static final int PUBLISH_TIMEOUT = 20000;
 107 
 108     private static final int HISTORY_TIMEOUT = 10000;
 109 
 110     private Note mNote;
 111 
 112     private final Runnable mAutoSaveRunnable = new Runnable() {
 113         @Override
 114         public void run() {
 115             saveAndSyncNote();
 116         }
 117     };
 118 
 119     private Bucket&lt;Note&gt; mNotesBucket;
 120 
 121     private View mRootView;
 122 
 123     private View mTagPadding;
 124 
 125     private SimplenoteEditText mContentEditText;
 126 
 127     private ChipGroup mTagChips;
 128 
 129     private TagsMultiAutoCompleteTextView mTagInput;
 130 
 131     private Handler mAutoSaveHandler;
 132 
 133     private Handler mPublishTimeoutHandler;
 134 
 135     private Handler mHistoryTimeoutHandler;
 136 
 137     private LinearLayout mPlaceholderView;
 138 
 139     private CursorAdapter mAutocompleteAdapter;
 140 
 141     private boolean mIsLoadingNote;
 142 
 143     private boolean mIsMarkdownEnabled;
 144 
 145     private boolean mIsPreviewEnabled;
 146 
 147     private boolean mShouldScrollToSearchMatch;
 148 
 149     private ActionMode mActionMode;
 150 
 151     private MenuItem mChecklistMenuItem;
 152 
 153     private MenuItem mCopyMenuItem;
 154 
 155     private MenuItem mInformationMenuItem;
 156 
 157     private MenuItem mShareMenuItem;
 158 
 159     private MenuItem mViewLinkMenuItem;
 160 
 161     private String mLinkUrl;
 162 
 163     private String mLinkText;
 164 
 165     private MatchOffsetHighlighter mHighlighter;
 166 
 167     private Drawable mCallIcon;
 168 
 169     private Drawable mCopyIcon;
 170 
 171     private Drawable mEmailIcon;
 172 
 173     private Drawable mMapIcon;
 174 
 175     private Drawable mShareIcon;
 176 
 177     private Drawable mBrowserIcon;
 178 
 179     private MatchOffsetHighlighter.SpanFactory mMatchHighlighter;
 180 
 181     private String mMatchOffsets;
 182 
 183     private int mCurrentCursorPosition;
 184 
 185     private HistoryBottomSheetDialog mHistoryBottomSheet;
 186 
 187     private boolean mIsPaused;
 188 
 189     private boolean mIsFromWidget;
 190 
 191     // Hides the history bottom sheet if no revisions are loaded
 192     // Hides the history bottom sheet if no revisions are loaded
 193     private final Runnable mHistoryTimeoutRunnable = new Runnable() {
 194         @Override
 195         public void run() {
 196             if (!isAdded()) {
 197                 return;
 198             }
 199 
 200             requireActivity().runOnUiThread(new Runnable() {
 201                 @Override
 202                 public void run() {
<abbr title=" 203                     if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; !mHistoryBottomSheet.isHistoryLoaded()) {"> 203                     if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowðŸ”µ</abbr>
 204                         mHistoryBottomSheet.dismiss();
 205                         Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 206                     }
 207                 }
 208             });
 209         }
 210     };
 211 
 212     private InfoBottomSheetDialog mInfoBottomSheet;
 213 
 214     private ShareBottomSheetDialog mShareBottomSheet;
 215 
 216     // Contextual action bar for dealing with links
 217     private final ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
 218         // Called when the action mode is created; startActionMode() was called
 219         @Override
 220         public boolean onCreateActionMode(ActionMode mode, Menu menu) {
 221             // Inflate a menu resource providing context menu items
 222             MenuInflater inflater = mode.getMenuInflater();
 223 
 224             if (inflater != null) {
 225                 inflater.inflate(R.menu.view_link, menu);
 226                 mCopyMenuItem = menu.findItem(R.id.menu_copy);
 227                 mShareMenuItem = menu.findItem(R.id.menu_share);
 228                 mViewLinkMenuItem = menu.findItem(R.id.menu_view_link);
 229                 mode.setTitle(getString(R.string.link));
 230                 mode.setTitleOptionalHint(false);
 231 
 232                 DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 233             }
 234 
<abbr title=" 235             int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.background_dark;"> 235             int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.colðŸ”µ</abbr>
<abbr title=" 236             requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().getTheme()));"> 236             requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireAcðŸ”µ</abbr>
 237             return true;
 238         }
 239 
 240         // Called each time the action mode is shown. Always called after onCreateActionMode, but
 241         // may be called multiple times if the mode is invalidated.
 242         @Override
 243         public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 244             return false; // Return false if nothing is done
 245         }
 246 
 247         // Called when the user selects a contextual menu item
 248         @Override
 249         public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 250             switch (item.getItemId()) {
 251                 case R.id.menu_view_link :
 252                     if (mLinkUrl != null) {
 253                         try {
 254                             BrowserUtils.launchBrowserOrShowError(requireContext(), mLinkUrl);
 255                         } catch (java.lang.Exception e) {
 256                             e.printStackTrace();
 257                         }
 258                         mode.finish();// Action picked, so close the CAB
 259 
 260                     }
 261                     return true;
 262                 case R.id.menu_copy :
 263                     if ((mLinkText != null) &amp;&amp; (getActivity() != null)) {
 264                         BrowserUtils.copyToClipboard(requireContext(), mLinkText);
 265                         Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 266                         mode.finish();
 267                     }
 268                     return true;
 269                 case R.id.menu_share :
 270                     if (mLinkText != null) {
 271                         showShare(mLinkText);
 272                         mode.finish();
 273                     }
 274                     return true;
 275                 default :
 276                     return false;
 277             }
 278         }
 279 
 280         // Called when the user exits the action mode
 281         @Override
 282         public void onDestroyActionMode(ActionMode mode) {
 283             mActionMode = null;
 284             new Handler().postDelayed(
 285                 new Runnable() {
 286                     @Override
 287                     public void run() {
<abbr title=" 288                         requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 288                         requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.RðŸ”µ</abbr>
 289                     }
 290                 },
 291                 requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime)
 292             );
 293         }
 294     };
 295 
 296     private Snackbar mPublishingSnackbar;
 297 
 298     private boolean mHideActionOnSuccess;
 299 
 300     // Resets note publish status if Simperium never returned the new publish status
 301     // Resets note publish status if Simperium never returned the new publish status
 302     private final Runnable mPublishTimeoutRunnable = new Runnable() {
 303         @Override
 304         public void run() {
 305             if (!isAdded()) return;
 306 
 307             requireActivity().runOnUiThread(new Runnable() {
 308                 @Override
 309                 public void run() {
 310 
 311                     mNote.setPublished(!mNote.isPublished());
 312                     mNote.save();
 313 
 314                     updatePublishedState(false);
 315                 }
 316             });
 317         }
 318     };
 319 
 320     private NoteMarkdownFragment mNoteMarkdownFragment;
 321 
 322     private String mCss;
 323 
 324     private WebView mMarkdown;
 325 
 326     /**
 327      * Mandatory empty constructor for the fragment manager to instantiate the
 328      * fragment (e.g. upon screen orientation changes).
 329      */
 330     public NoteEditorFragment() {
 331     }
 332 
 333     @Override
 334     public void onCreate(Bundle savedInstanceState) {
 335         super.onCreate(savedInstanceState);
 336         mInfoBottomSheet = new InfoBottomSheetDialog(this);
 337         mShareBottomSheet = new ShareBottomSheetDialog(this, this);
 338         mHistoryBottomSheet = new HistoryBottomSheetDialog(this, this);
 339 
 340         Simplenote currentApp = (Simplenote) requireActivity().getApplication();
 341         mNotesBucket = currentApp.getNotesBucket();
 342 
<abbr title=" 343         mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.actionModeTextColor);"> 343         mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp,ðŸ”µ</abbr>
<abbr title=" 344         mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.attr.actionModeTextColor);"> 344         mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.aðŸ”µ</abbr>
<abbr title=" 345         mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.actionModeTextColor);"> 345         mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.ðŸ”µ</abbr>
<abbr title=" 346         mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp, R.attr.actionModeTextColor);"> 346         mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp,ðŸ”µ</abbr>
<abbr title=" 347         mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attr.actionModeTextColor);"> 347         mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attðŸ”µ</abbr>
<abbr title=" 348         mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.attr.actionModeTextColor);"> 348         mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.aðŸ”µ</abbr>
 349 
 350         mAutoSaveHandler = new Handler();
 351         mPublishTimeoutHandler = new Handler();
 352         mHistoryTimeoutHandler = new Handler();
 353 
 354         mMatchHighlighter = new TextHighlighter(requireActivity(),
<abbr title=" 355                 R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor);"> 355                 R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor)ðŸ”µ</abbr>
 356         mAutocompleteAdapter = new CursorAdapter(getActivity(), null, 0x0) {
 357             @Override
 358             public View newView(Context context, Cursor cursor, ViewGroup parent) {
 359                 Activity activity = (Activity) context;
 360                 if (activity == null) return null;
 361                 return activity.getLayoutInflater().inflate(R.layout.tag_autocomplete_list_item, null);
 362             }
 363 
 364             @Override
 365             public void bindView(View view, Context context, Cursor cursor) {
 366                 TextView textView = (TextView) view;
 367                 textView.setText(convertToString(cursor));
 368             }
 369 
 370             @Override
 371             public CharSequence convertToString(Cursor cursor) {
 372                 return cursor.getString(cursor.getColumnIndex(Tag.NAME_PROPERTY));
 373             }
 374 
 375             @Override
 376             public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 377                 Activity activity = getActivity();
 378                 if (activity == null) return null;
 379                 Simplenote application = (Simplenote) activity.getApplication();
 380                 Query&lt;Tag&gt; query = application.getTagsBucket().query();
 381                 // make the tag name available to the cursor
 382                 query.include(Tag.NAME_PROPERTY);
 383                 // sort the tags by their names
 384                 query.order(Tag.NAME_PROPERTY);
 385                 // if there&#x27;s a filter string find only matching tag names
 386                 if (filter != null)
<abbr title=" 387                     query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filter));"> 387                     query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filteðŸ”µ</abbr>
 388                 return query.execute();
 389             }
 390         };
 391 
 392         WidgetUtils.updateNoteWidgets(requireActivity().getApplicationContext());
 393     }
 394 
 395     @Override
<abbr title=" 396     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {"> 396     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceSðŸ”µ</abbr>
 397         mRootView = inflater.inflate(R.layout.fragment_note_editor, container, false);
 398         mContentEditText = mRootView.findViewById(R.id.note_content);
 399         mContentEditText.addOnSelectionChangedListener(this);
 400         mContentEditText.setOnCheckboxToggledListener(this);
 401         mContentEditText.setMovementMethod(SimplenoteMovementMethod.getInstance());
 402         mContentEditText.setOnFocusChangeListener(this);
 403         mTagInput = mRootView.findViewById(R.id.tag_input);
 404         mTagInput.setDropDownBackgroundResource(R.drawable.bg_list_popup);
 405         mTagInput.setTokenizer(new SpaceTokenizer());
 406         mTagInput.setOnFocusChangeListener(this);
 407         mTagChips = mRootView.findViewById(R.id.tag_chips);
 408         mTagPadding = mRootView.findViewById(R.id.tag_padding);
 409         mHighlighter = new MatchOffsetHighlighter(mMatchHighlighter, mContentEditText);
 410         mPlaceholderView = mRootView.findViewById(R.id.placeholder);
 411 
 412         if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote == null) {
 413             mPlaceholderView.setVisibility(View.VISIBLE);
 414             requireActivity().invalidateOptionsMenu();
 415             mMarkdown = mRootView.findViewById(R.id.markdown);
 416             mCss = ThemeUtils.isLightTheme(requireContext())
 417                     ? ContextUtils.readCssFile(requireContext(), &quot;light.css&quot;)
 418                     : ContextUtils.readCssFile(requireContext(), &quot;dark.css&quot;);
 419         }
 420 
 421         mTagInput.setAdapter(mAutocompleteAdapter);
 422         Bundle arguments = getArguments();
 423 
 424         if (arguments != null &amp;&amp; arguments.containsKey(ARG_ITEM_ID)) {
 425             // Load note if we were passed a note Id
 426             String key = arguments.getString(ARG_ITEM_ID);
 427 
 428             if (arguments.containsKey(ARG_MATCH_OFFSETS)) {
 429                 mMatchOffsets = arguments.getString(ARG_MATCH_OFFSETS);
 430             }
 431 
 432             mIsFromWidget = arguments.getBoolean(ARG_IS_FROM_WIDGET);
 433             new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, key);
 434         } else if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; savedInstanceState != null) {
 435             // Restore selected note when in dual pane mode
 436             String noteId = savedInstanceState.getString(STATE_NOTE_ID);
 437 
 438             if (noteId != null) {
 439                 setNote(noteId);
 440             }
 441         }
 442 
 443         ViewTreeObserver viewTreeObserver = mContentEditText.getViewTreeObserver();
 444         viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
 445             @Override
 446             public void onGlobalLayout() {
 447                 // If a note was loaded with search matches, scroll to the first match in the editor
 448                 if (mShouldScrollToSearchMatch &amp;&amp; mMatchOffsets != null) {
 449                     if (!isAdded()) {
 450                         return;
 451                     }
 452 
 453                     // Get the character location of the first search match
 454                     int matchLocation = MatchOffsetHighlighter.getFirstMatchLocation(
 455                             mContentEditText.getText(),
 456                             mMatchOffsets
 457                     );
 458                     if (matchLocation == 0) {
 459                         return;
 460                     }
 461 
 462                     // Calculate how far to scroll to bring the match into view
 463                     Layout layout = mContentEditText.getLayout();
 464                     int lineTop = layout.getLineTop(layout.getLineForOffset(matchLocation));
 465                     ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 466                     mShouldScrollToSearchMatch = false;
 467                 }
 468             }
 469         });
 470         setHasOptionsMenu(true);
 471         return mRootView;
 472     }
 473 
 474     public void scrollToMatch(int location) {
 475         if (isAdded()) {
 476             // Calculate how far to scroll to bring the match into view
 477             Layout layout = mContentEditText.getLayout();
 478             int lineTop = layout.getLineTop(layout.getLineForOffset(location));
 479             ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 480         }
 481     }
 482 
 483     @Override
 484     public void onResume() {
 485         super.onResume();
 486         mNotesBucket.start();
 487         mNotesBucket.addListener(this);
 488         mTagInput.setOnTagAddedListener(this);
 489 
 490         if (mContentEditText != null) {
<abbr title=" 491             mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(getActivity()));"> 491             mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(getActivity())ðŸ”µ</abbr>
 492 
 493             if (mContentEditText.hasFocus()) {
 494                 showSoftKeyboard();
 495             }
 496         }
 497     }
 498 
 499     private void showSoftKeyboard() {
 500         new Handler().postDelayed(new Runnable() {
 501             @Override
 502             public void run() {
 503                 if (getActivity() == null) {
 504                     return;
 505                 }
 506 
<abbr title=" 507                 InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);"> 507                 InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemServiðŸ”µ</abbr>
 508                 if (inputMethodManager != null) {
 509                     inputMethodManager.showSoftInput(mContentEditText, 0);
 510                 }
 511             }
 512         }, 100);
 513     }
 514 
 515     @Override
 516     public void onPause() {
 517         super.onPause();  // Always call the superclass method first
 518         mIsPaused = true;
 519 
 520         // Hide soft keyboard if it is showing...
 521         DisplayUtils.hideKeyboard(mContentEditText);
 522 
 523         mTagInput.setOnTagAddedListener(null);
 524 
 525         if (mAutoSaveHandler != null) {
 526             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 527         }
 528 
 529         if (mPublishTimeoutHandler != null) {
 530             mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
 531         }
 532 
 533         if (mHistoryTimeoutHandler != null) {
 534             mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 535         }
 536 
 537         mHighlighter.stop();
 538         saveNote();
 539     }
 540 
 541     @Override
 542     public void onDestroy() {
 543         super.onDestroy();
 544         mNotesBucket.removeListener(this);
 545         mNotesBucket.stop();
 546     }
 547 
 548     @Override
 549     public void onSaveInstanceState(@NonNull Bundle outState) {
 550         super.onSaveInstanceState(outState);
 551 
 552         if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote != null) {
 553             outState.putString(STATE_NOTE_ID, mNote.getSimperiumKey());
 554         }
 555     }
 556 
 557     @Override
 558     public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
 559         super.onCreateOptionsMenu(menu, inflater);
 560 
<abbr title=" 561         if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFragment == null)) {"> 561         if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMðŸ”µ</abbr>
 562             return;
 563         }
 564 
 565         inflater.inflate(R.menu.note_editor, menu);
 566         MenuCompat.setGroupDividerEnabled(menu, true);
 567     }
 568 
 569     @Override
 570     public boolean onOptionsItemSelected(@NonNull
 571     MenuItem item) {
 572         switch (item.getItemId()) {
 573             case R.id.menu_checklist :
 574                 insertChecklist();
 575                 return true;
 576             case R.id.menu_copy :
 577                 BrowserUtils.copyToClipboard(requireContext(), mNote.getPublishedUrl());
 578                 Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 579                 return true;
 580             case R.id.menu_history :
 581                 showHistory();
 582                 return true;
 583             case R.id.menu_info :
 584                 showInfo();
 585                 return true;
 586             case R.id.menu_markdown :
 587                 setMarkdown(!item.isChecked());
 588                 return true;
 589             case R.id.menu_pin :
 590                 NoteUtils.setNotePin(mNote, !item.isChecked());
 591                 requireActivity().invalidateOptionsMenu();
 592                 return true;
 593             case R.id.menu_publish :
 594                 if (item.isChecked()) {
 595                     unpublishNote();
 596                 } else {
 597                     publishNote();
 598                 }
 599                 return true;
 600             case R.id.menu_share :
 601                 shareNote();
 602                 return true;
 603             case R.id.menu_trash :
 604                 if (!isAdded()) {
 605                     return false;
 606                 }
 607                 deleteNote();
 608                 return true;
 609             case android.R.id.home :
 610                 if (!isAdded()) {
 611                     return false;
 612                 }
 613                 requireActivity().finish();
 614                 return true;
 615             default :
 616                 return super.onOptionsItemSelected(item);
 617         }
 618     }
 619 
 620     @Override
 621     public void onPrepareOptionsMenu(@NonNull
 622     Menu menu) {
 623         if (mNote != null) {
 624             MenuItem pinItem = menu.findItem(R.id.menu_pin);
 625             MenuItem shareItem = menu.findItem(R.id.menu_share);
 626             MenuItem historyItem = menu.findItem(R.id.menu_history);
 627             MenuItem publishItem = menu.findItem(R.id.menu_publish);
 628             MenuItem copyLinkItem = menu.findItem(R.id.menu_copy);
 629             MenuItem markdownItem = menu.findItem(R.id.menu_markdown);
 630             MenuItem trashItem = menu.findItem(R.id.menu_trash);
 631             mChecklistMenuItem = menu.findItem(R.id.menu_checklist);
 632             mInformationMenuItem = menu.findItem(R.id.menu_info).setVisible(true);
 633             pinItem.setChecked(mNote.isPinned());
 634             publishItem.setChecked(mNote.isPublished());
 635             markdownItem.setChecked(mNote.isMarkdownEnabled());
 636             // Disable actions when note is in Trash or markdown view is shown on large device.
<abbr title=" 637             if (mNote.isDeleted() || ((mMarkdown != null) &amp;&amp; (mMarkdown.getVisibility() == View.VISIBLE))) {"> 637             if (mNote.isDeleted() || ((mMarkdown != null) &amp;&amp; (mMarkdown.getVisibility() == View.VISIBLE))ðŸ”µ</abbr>
 638                 pinItem.setEnabled(false);
 639                 shareItem.setEnabled(false);
 640                 historyItem.setEnabled(false);
 641                 publishItem.setEnabled(false);
 642                 copyLinkItem.setEnabled(false);
 643                 markdownItem.setEnabled(false);
 644                 mChecklistMenuItem.setEnabled(false);
 645                 // 0.3 is 30% opacity.
 646                 DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 0.3);
 647             } else {
 648                 pinItem.setEnabled(true);
 649                 shareItem.setEnabled(true);
 650                 historyItem.setEnabled(true);
 651                 publishItem.setEnabled(true);
 652                 copyLinkItem.setEnabled(mNote.isPublished());
 653                 markdownItem.setEnabled(true);
 654                 mChecklistMenuItem.setEnabled(true);
 655                 // 1.0 is 100% opacity.
 656                 DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 1.0);
 657             }
 658             if (mNote.isDeleted()) {
 659                 trashItem.setTitle(R.string.restore);
 660             } else {
 661                 trashItem.setTitle(R.string.trash);
 662             }
 663         }
 664         DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 665         super.onPrepareOptionsMenu(menu);
 666     }
 667 
 668     public void insertChecklist() {
 669         DrawableUtils.startAnimatedVectorDrawable(mChecklistMenuItem.getIcon());
 670         try {
 671             mContentEditText.insertChecklist();
 672         } catch (java.lang.Exception e) {
 673             e.printStackTrace();
 674             return;
 675         }
 676         AnalyticsTracker.track(EDITOR_CHECKLIST_INSERTED, CATEGORY_NOTE, &quot;toolbar_button&quot;);
 677     }
 678 
 679     @Override
 680     public void onCheckboxToggled() {
 681         // Save note (using delay) after toggling a checkbox
 682         if (mAutoSaveHandler != null) {
 683             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 684             mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 685         }
 686     }
 687 
 688     private void deleteNote() {
 689         NoteUtils.deleteNote(mNote, getActivity());
 690         requireActivity().finish();
 691     }
 692 
 693     protected void clearMarkdown() {
 694         mMarkdown.loadDataWithBaseURL(&quot;file:///android_asset/&quot;, mCss + &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 695     }
 696 
 697     protected void hideMarkdown() {
 698         mMarkdown.setVisibility(View.INVISIBLE);
 699     }
 700 
 701     protected void showMarkdown() {
 702         loadMarkdownData();
 703         mMarkdown.setVisibility(View.VISIBLE);
 704 
 705         new Handler().postDelayed(
 706             new Runnable() {
 707                 @Override
 708                 public void run() {
 709                     requireActivity().invalidateOptionsMenu();
 710                 }
 711             },
 712             getResources().getInteger(R.integer.time_animation)
 713         );
 714     }
 715 
 716     public void shareNote() {
 717         if (mNote != null) {
 718             mContentEditText.clearFocus();
 719             showShareSheet();
 720             AnalyticsTracker.track(EDITOR_NOTE_CONTENT_SHARED, CATEGORY_NOTE, &quot;action_bar_share_button&quot;);
 721         }
 722     }
 723 
 724     public void showHistory() {
 725         if ((mNote != null) &amp;&amp; (mNote.getVersion() &gt; 1)) {
 726             mContentEditText.clearFocus();
 727             mHistoryTimeoutHandler.postDelayed(mHistoryTimeoutRunnable, HISTORY_TIMEOUT);
 728             showHistorySheet();
 729         } else {
 730             Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 731         }
 732     }
 733 
 734     public void showInfo() {
 735         DrawableUtils.startAnimatedVectorDrawable(mInformationMenuItem.getIcon());
 736         if (mNote != null) {
 737             mContentEditText.clearFocus();
 738             saveNote();
 739             showInfoSheet();
 740         }
 741     }
 742 
 743     private void setMarkdown(boolean isChecked) {
 744         mIsMarkdownEnabled = isChecked;
 745         Activity activity = getActivity();
 746 
 747         if (activity instanceof NoteEditorActivity) {
 748             NoteEditorActivity editorActivity = (NoteEditorActivity) activity;
 749 
 750             if (mIsMarkdownEnabled) {
 751                 editorActivity.showTabs();
 752 
 753                 if (mNoteMarkdownFragment == null) {
 754                     // Get markdown fragment and update content
 755                     mNoteMarkdownFragment = editorActivity.getNoteMarkdownFragment();
 756                     mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPlainTextContent());
 757                 }
 758             } else {
 759                 editorActivity.hideTabs();
 760             }
 761         } else if (activity instanceof NotesActivity) {
 762             setMarkdownEnabled(mIsMarkdownEnabled);
 763             ((NotesActivity) getActivity()).setMarkdownShowing(false);
 764         }
 765 
 766         saveNote();
 767 
 768         // Set preference so that next new note will have markdown enabled.
 769         SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(requireContext());
 770         SharedPreferences.Editor editor = prefs.edit();
 771         editor.putBoolean(PrefUtils.PREF_MARKDOWN_ENABLED, isChecked);
 772         editor.apply();
 773     }
 774 
 775     protected void setMarkdownEnabled(boolean enabled) {
 776         mIsMarkdownEnabled = enabled;
 777 
 778         if (mIsMarkdownEnabled) {
 779             loadMarkdownData();
 780         }
 781     }
 782 
 783     private void loadMarkdownData() {
 784         String formattedContent = NoteMarkdownFragment.getMarkdownFormattedContent(
 785                 mCss,
 786                 mContentEditText.getPlainTextContent()
 787         );
 788 
 789         mMarkdown.loadDataWithBaseURL(null, formattedContent, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 790     }
 791 
 792     public void setNote(String noteID, String matchOffsets) {
 793         if (mAutoSaveHandler != null)
 794             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 795 
 796         mPlaceholderView.setVisibility(View.GONE);
 797 
 798         if (matchOffsets != null) {
 799             mMatchOffsets = matchOffsets;
 800         } else {
 801             mMatchOffsets = null;
 802         }
 803 
 804 
 805         saveNote();
 806 
 807         new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteID);
 808     }
 809 
 810     private void updateNote(Note updatedNote) {
 811         // update note if network change arrived
 812         mNote = updatedNote;
 813         refreshContent(true);
 814     }
 815 
 816     private void refreshContent(boolean isNoteUpdate) {
 817         if (mNote != null) {
 818             // Restore the cursor position if possible.
<abbr title=" 819             int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.getSelectionEnd());"> 819             int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEdðŸ”µ</abbr>
 820             mContentEditText.setText(mNote.getContent());
 821 
 822             if (isNoteUpdate) {
 823                 // Update markdown and preview flags from updated note.
 824                 mIsMarkdownEnabled = mNote.isMarkdownEnabled();
 825                 mIsPreviewEnabled = mNote.isPreviewEnabled();
 826 
 827                 // Show/Hide tabs based on markdown flag.
 828                 setMarkdown(mIsMarkdownEnabled);
 829 
 830                 // Save note so any local changes get synced.
 831                 mNote.save();
 832 
 833                 // Update current note object on large screen devices in landscape orientation.
 834                 if (DisplayUtils.isLargeScreenLandscape(requireContext())) {
 835                     ((NotesActivity) requireActivity()).setCurrentNote(mNote);
 836                 }
 837 
 838                 // Update overflow popup menu.
 839                 requireActivity().invalidateOptionsMenu();
 840 
 841                 if (mContentEditText.hasFocus()
 842                         &amp;&amp; cursorPosition != mContentEditText.getSelectionEnd()
 843                         &amp;&amp; cursorPosition &lt; mContentEditText.getText().length()) {
 844                     mContentEditText.setSelection(cursorPosition);
 845                 }
 846             }
 847 
 848             afterTextChanged(mContentEditText.getText());
 849             mContentEditText.processChecklists();
 850             updateTagList();
 851         }
 852     }
 853 
 854     private void updateTagList() {
 855         setChips(mNote.getTagString());
 856         mTagInput.setText(&quot;&quot;);
 857     }
 858 
 859     private int newCursorLocation(String newText, String oldText, int cursorLocation) {
 860         // Ported from the iOS app :)
 861         // Cases:
 862         // 0. All text after cursor (and possibly more) was removed ==&gt; put cursor at end
 863         // 1. Text was added after the cursor ==&gt; no change
 864         // 2. Text was added before the cursor ==&gt; location advances
 865         // 3. Text was removed after the cursor ==&gt; no change
 866         // 4. Text was removed before the cursor ==&gt; location retreats
 867         // 5. Text was added/removed on both sides of the cursor ==&gt; not handled
 868 
 869         cursorLocation = Math.max(cursorLocation, 0);
 870 
 871         int newCursorLocation = cursorLocation;
 872 
 873         int deltaLength = newText.length() - oldText.length();
 874 
 875         // Case 0
 876         if (newText.length() &lt; cursorLocation)
 877             return newText.length();
 878 
 879         boolean beforeCursorMatches = false;
 880         boolean afterCursorMatches = false;
 881 
 882         try {
<abbr title=" 883             beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation));"> 883             beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorðŸ”µ</abbr>
<abbr title=" 884             afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaLength));"> 884             afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocatioðŸ”µ</abbr>
 885         } catch (Exception e) {
 886             e.printStackTrace();
 887         }
 888 
 889         // Cases 2 and 4
 890         if (!beforeCursorMatches &amp;&amp; afterCursorMatches)
 891             newCursorLocation += deltaLength;
 892 
 893         // Cases 1, 3 and 5 have no change
 894         return newCursorLocation;
 895     }
 896 
 897     @Override
 898     public void onTagAdded(String tag) {
 899         if (mNote == null || !isAdded()) {
 900             return;
 901         }
 902 
 903         if (mNote.getTagString() != null &amp;&amp; tag.length() &gt; mNote.getTagString().length()) {
 904             AnalyticsTracker.track(
 905                 EDITOR_TAG_ADDED,
 906                 CATEGORY_NOTE,
 907                 &quot;tag_added_to_note&quot;
 908             );
 909         }
 910 
 911         mNote.setTagString(mNote.getTagString() + String.valueOf(SPACE) + tag);
 912         mNote.setModificationDate(Calendar.getInstance());
 913         updateTagList();
 914         mNote.save();
 915     }
 916 
 917     @Override
 918     public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
 919         // Unused
 920     }
 921 
 922     @Override
 923     public void afterTextChanged(Editable editable) {
 924         attemptAutoList(editable);
 925         setTitleSpan(editable);
 926         mContentEditText.fixLineSpacing();
 927     }
 928 
 929     @Override
 930     public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
 931         // When text changes, start timer that will fire after AUTOSAVE_DELAY_MILLIS passes
 932         if (mAutoSaveHandler != null) {
 933             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 934             mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 935         }
 936 
 937         // Remove search highlight spans when note content changes
 938         if (mMatchOffsets != null) {
 939             mMatchOffsets = null;
 940             mHighlighter.removeMatches();
 941         }
 942 
 943         if (!DisplayUtils.isLargeScreenLandscape(requireContext())) {
 944             ((NoteEditorActivity) requireActivity()).setSearchMatchBarVisible(false);
 945         }
 946 
 947         // Temporarily remove the text watcher as we process checklists to prevent callback looping
 948         mContentEditText.removeTextChangedListener(this);
 949         mContentEditText.processChecklists();
 950         mContentEditText.addTextChangedListener(this);
 951     }
 952 
 953     /**
 954      * Set the note title to be a larger size and bold style.
 955      *
 956      * Remove all existing spans before applying spans or performance issues will occur.  Since both
 957      * {@link RelativeSizeSpan} and {@link StyleSpan} inherit from {@link MetricAffectingSpan}, all
 958      * spans are removed when {@link MetricAffectingSpan} is removed.
 959      */
 960     private void setTitleSpan(Editable editable) {
<abbr title=" 961         for (MetricAffectingSpan span : editable.getSpans(0, editable.length(), MetricAffectingSpan.class)) {"> 961         for (MetricAffectingSpan span : editable.getSpans(0, editable.length(), MetricAffectingSpan.classðŸ”µ</abbr>
 962             if (span instanceof RelativeSizeSpan || span instanceof StyleSpan) {
 963                 editable.removeSpan(span);
 964             }
 965         }
 966 
 967         int newLinePosition = getNoteContentString().indexOf(&quot;\n&quot;);
 968 
 969         if (newLinePosition == 0) {
 970             return;
 971         }
 972 
 973         int titleEndPosition = (newLinePosition &gt; 0) ? newLinePosition : editable.length();
<abbr title=" 974         editable.setSpan(new RelativeSizeSpan(1.3f), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);"> 974         editable.setSpan(new RelativeSizeSpan(1.3f), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVðŸ”µ</abbr>
<abbr title=" 975         editable.setSpan(new StyleSpan(Typeface.BOLD), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);"> 975         editable.setSpan(new StyleSpan(Typeface.BOLD), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSðŸ”µ</abbr>
 976     }
 977 
 978     private void attemptAutoList(Editable editable) {
 979         int oldCursorPosition = mCurrentCursorPosition;
 980         mCurrentCursorPosition = mContentEditText.getSelectionStart();
 981         AutoBullet.apply(editable, oldCursorPosition, mCurrentCursorPosition);
 982         mCurrentCursorPosition = mContentEditText.getSelectionStart();
 983     }
 984 
 985     private void saveAndSyncNote() {
 986         if (mNote == null) {
 987             return;
 988         }
 989 
 990         new SaveNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 991     }
 992 
 993     public boolean isPlaceholderVisible() {
 994         if (mPlaceholderView != null) {
 995             return mPlaceholderView.getVisibility() == View.VISIBLE;
 996         } else {
 997             return false;
 998         }
 999     }
1000 
1001     public void setPlaceholderVisible(boolean isVisible) {
1002         if (isVisible) {
1003             mNote = null;
1004             mContentEditText.setText(&quot;&quot;);
1005         }
1006 
1007         if (mPlaceholderView != null) {
1008             mPlaceholderView.setVisibility(isVisible ? View.VISIBLE : View.GONE);
1009         }
1010     }
1011 
1012     @Override
1013     public void onFocusChange(View v, boolean hasFocus) {
1014         if (!hasFocus) {
1015             String tags = getNoteTagsString().trim();
1016 
1017             if (mTagInput.getText().toString().trim().length() &gt; 0) {
1018                 onTagAdded(mTagInput.getText().toString());
1019             } else if (tags.length() &gt; 0) {
1020                 setChips(tags);
1021             }
1022         }
1023     }
1024 
1025     private Note getNote() {
1026         return mNote;
1027     }
1028 
1029     public void setNote(String noteID) {
1030         setNote(noteID, null);
1031     }
1032 
1033     private String getNoteContentString() {
1034         if (mContentEditText == null || mContentEditText.getText() == null) {
1035             return &quot;&quot;;
1036         } else {
1037             return mContentEditText.getText().toString();
1038         }
1039     }
1040 
1041     private String getNoteTagsString() {
1042         StringBuilder tags = new StringBuilder();
1043 
1044         for (int i= 0; i &lt; mTagChips.getChildCount(); i++) {
1045             tags.append(((Chip) mTagChips.getChildAt(i)).getText()).append(&quot; &quot;);
1046         }
1047 
1048         return tags.toString();
1049     }
1050 
1051     /**
1052      * Share bottom sheet callbacks
1053      */
1054 
1055     @Override
1056     public void onSharePublishClicked() {
1057         publishNote();
1058         if (mShareBottomSheet != null) {
1059             mShareBottomSheet.dismiss();
1060         }
1061     }
1062 
1063     @Override
1064     public void onShareUnpublishClicked() {
1065         unpublishNote();
1066         if (mShareBottomSheet != null) {
1067             mShareBottomSheet.dismiss();
1068         }
1069     }
1070 
1071     @Override
1072     public void onWordPressPostClicked() {
1073         if (mShareBottomSheet != null) {
1074             mShareBottomSheet.dismiss();
1075         }
1076 
1077         if (getFragmentManager() == null) {
1078             return;
1079         }
1080 
1081         FragmentTransaction ft = getFragmentManager().beginTransaction();
1082         Fragment prev = getFragmentManager().findFragmentByTag(WordPressDialogFragment.DIALOG_TAG);
1083         if (prev != null) {
1084             ft.remove(prev);
1085         }
1086         ft.addToBackStack(null);
1087 
1088         // Create and show the dialog.
1089         WordPressDialogFragment wpDialogFragment = new WordPressDialogFragment();
1090         wpDialogFragment.setNote(mNote);
1091         wpDialogFragment.show(ft, WordPressDialogFragment.DIALOG_TAG);
1092     }
1093 
1094     @Override
1095     public void onShareCollaborateClicked() {
1096         Toast.makeText(getActivity(), R.string.collaborate_message, Toast.LENGTH_LONG).show();
1097     }
1098 
1099     @Override
1100     public void onShareDismissed() {
1101 
1102     }
1103 
1104     /**
1105      * History bottom sheet listeners
1106      */
1107 
1108     @Override
1109     public void onHistoryCancelClicked() {
1110         mContentEditText.setText(mNote.getContent());
1111         if (mHistoryBottomSheet != null) {
1112             mHistoryBottomSheet.dismiss();
1113         }
1114     }
1115 
1116     @Override
1117     public void onHistoryRestoreClicked() {
1118         if (mHistoryBottomSheet != null) {
1119             mHistoryBottomSheet.dismiss();
1120         }
1121         saveAndSyncNote();
1122     }
1123 
1124     @Override
1125     public void onHistoryDismissed() {
1126         if (!mHistoryBottomSheet.didTapOnButton()) {
1127             mContentEditText.setText(mNote.getContent());
1128         }
1129 
1130         if (mHistoryTimeoutHandler != null) {
1131             mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
1132         }
1133     }
1134 
1135     @Override
1136     public void onHistoryUpdateNote(String content) {
1137         mContentEditText.setText(content);
1138     }
1139 
1140     protected void saveNote() {
1141         try {
1142             if (mNote == null || mNotesBucket == null || mContentEditText == null || mIsLoadingNote ||
<abbr title="1143                 (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing())) {">1143                 (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomðŸ”µ</abbr>
1144                 return;
1145             } else {
1146                 mNote = mNotesBucket.get(mNote.getSimperiumKey());
1147                 mIsPreviewEnabled = mNote.isPreviewEnabled();
1148             }
1149 
1150             String content = mContentEditText.getPlainTextContent();
1151             String tagString = getNoteTagsString();
1152 
<abbr title="1153             if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnabled)) {">1153             if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPrevðŸ”µ</abbr>
1154                 mNote.setContent(content);
1155                 mNote.setTagString(tagString);
1156                 mNote.setModificationDate(Calendar.getInstance());
1157                 mNote.setMarkdownEnabled(mIsMarkdownEnabled);
1158                 mNote.setPreviewEnabled(mIsPreviewEnabled);
1159                 mNote.save();
1160 
1161                 AnalyticsTracker.track(
1162                     EDITOR_NOTE_EDITED,
1163                     CATEGORY_NOTE,
1164                     &quot;editor_save&quot;
1165                 );
1166             }
1167         } catch (BucketObjectMissingException exception) {
1168             exception.printStackTrace();
1169         }
1170     }
1171 
1172     // Checks if cursor is at a URL when the selection changes
1173     // If it is a URL, show the contextual action bar
1174     @Override
1175     public void onSelectionChanged(int selStart, int selEnd) {
1176         mCurrentCursorPosition = selEnd;
1177         if (selStart == selEnd) {
1178             Editable noteContent = mContentEditText.getText();
1179             if (noteContent == null)
1180                 return;
1181 
1182             URLSpan[] urlSpans = noteContent.getSpans(selStart, selStart, URLSpan.class);
1183             if (urlSpans.length &gt; 0) {
1184                 URLSpan urlSpan = urlSpans[0];
1185                 mLinkUrl = urlSpan.getURL();
<abbr title="1186                 mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSpan)).toString();">1186                 mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpaðŸ”µ</abbr>
1187                 if (mActionMode != null) {
1188                     mActionMode.setSubtitle(mLinkText);
1189                     updateMenuItems();
1190                     return;
1191                 }
1192 
1193                 // Show the Contextual Action Bar
1194                 if (getActivity() != null) {
<abbr title="1195                     mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCallback);">1195                     mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCðŸ”µ</abbr>
1196                     if (mActionMode != null) {
1197                         mActionMode.setSubtitle(mLinkText);
1198                     }
1199 
1200                     updateMenuItems();
1201                 }
1202             } else if (mActionMode != null) {
1203                 mActionMode.finish();
1204                 mActionMode = null;
1205             }
1206         } else if (mActionMode != null) {
1207             mActionMode.finish();
1208             mActionMode = null;
1209         }
1210     }
1211 
1212     private void updateMenuItems() {
1213         mCopyMenuItem.setIcon(mCopyIcon);
1214         mShareMenuItem.setIcon(mShareIcon);
1215 
1216         if (mViewLinkMenuItem != null &amp;&amp; mLinkUrl != null) {
1217             if (mLinkUrl.startsWith(&quot;tel:&quot;)) {
1218                 mViewLinkMenuItem.setIcon(mCallIcon);
1219                 mViewLinkMenuItem.setTitle(getString(R.string.call));
1220             } else if (mLinkUrl.startsWith(&quot;mailto:&quot;)) {
1221                 mViewLinkMenuItem.setIcon(mEmailIcon);
1222                 mViewLinkMenuItem.setTitle(getString(R.string.email));
1223             } else if (mLinkUrl.startsWith(&quot;geo:&quot;)) {
1224                 mViewLinkMenuItem.setIcon(mMapIcon);
1225                 mViewLinkMenuItem.setTitle(getString(R.string.view_map));
1226             } else {
1227                 mViewLinkMenuItem.setIcon(mBrowserIcon);
1228                 mViewLinkMenuItem.setTitle(getString(R.string.view_in_browser));
1229             }
1230         }
1231     }
1232 
1233     private void setPublishedNote(boolean isPublished) {
1234         if (mNote != null) {
1235             mNote.setPublished(isPublished);
1236             mNote.save();
1237 
1238             // reset publish status in 20 seconds if we don&#x27;t hear back from Simperium
1239             mPublishTimeoutHandler.postDelayed(mPublishTimeoutRunnable, PUBLISH_TIMEOUT);
1240 
1241             AnalyticsTracker.track(
1242                 isPublished ? EDITOR_NOTE_PUBLISHED : EDITOR_NOTE_UNPUBLISHED,
1243                 CATEGORY_NOTE,
1244                 &quot;publish_note_button&quot;
1245             );
1246         }
1247     }
1248 
1249     private void updatePublishedState(boolean isSuccess) {
1250         if (mPublishingSnackbar == null) {
1251             return;
1252         }
1253         mPublishingSnackbar.dismiss();
1254         mPublishingSnackbar = null;
1255         if (isSuccess &amp;&amp; isAdded()) {
1256             if (mNote.isPublished()) {
1257                 if (mHideActionOnSuccess) {
1258                     Snackbar.make(mRootView, R.string.publish_successful, Snackbar.LENGTH_LONG).show();
1259                 } else {
<abbr title="1260                     Snackbar.make(mRootView, R.string.publish_successful, Snackbar.LENGTH_LONG).setAction(R.string.undo, new View.OnClickListener() {">1260                     Snackbar.make(mRootView, R.string.publish_successful, Snackbar.LENGTH_LONG).setActionðŸ”µ</abbr>
1261                         @Override
1262                         public void onClick(View v) {
1263                             mHideActionOnSuccess = true;
1264                             unpublishNote();
1265                         }
1266                     }).show();
1267                 }
1268                 BrowserUtils.copyToClipboard(requireContext(), mNote.getPublishedUrl());
1269             } else if (mHideActionOnSuccess) {
1270                 Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG).show();
1271             } else {
<abbr title="1272                 Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG).setAction(R.string.undo, new View.OnClickListener() {">1272                 Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG).setAction(RðŸ”µ</abbr>
1273                     @Override
1274                     public void onClick(View v) {
1275                         mHideActionOnSuccess = true;
1276                         publishNote();
1277                     }
1278                 }).show();
1279             }
1280         } else if (mNote.isPublished()) {
<abbr title="1281             Snackbar.make(mRootView, R.string.unpublish_error, Snackbar.LENGTH_LONG).setAction(R.string.retry, new View.OnClickListener() {">1281             Snackbar.make(mRootView, R.string.unpublish_error, Snackbar.LENGTH_LONG).setAction(R.string.rðŸ”µ</abbr>
1282                 @Override
1283                 public void onClick(View v) {
1284                     mHideActionOnSuccess = true;
1285                     unpublishNote();
1286                 }
1287             }).show();
1288         } else {
<abbr title="1289             Snackbar.make(mRootView, R.string.publish_error, Snackbar.LENGTH_LONG).setAction(R.string.retry, new View.OnClickListener() {">1289             Snackbar.make(mRootView, R.string.publish_error, Snackbar.LENGTH_LONG).setAction(R.string.retðŸ”µ</abbr>
1290                 @Override
1291                 public void onClick(View v) {
1292                     mHideActionOnSuccess = true;
1293                     publishNote();
1294                 }
1295             }).show();
1296         }
1297         mHideActionOnSuccess = false;
1298         requireActivity().invalidateOptionsMenu();
1299     }
1300 
1301     private void publishNote() {
1302         if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1303             Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1304             return;
1305         }
1306 
1307         if (isAdded()) {
<abbr title="1308             mPublishingSnackbar = Snackbar.make(mRootView, R.string.publishing, Snackbar.LENGTH_INDEFINITE);">1308             mPublishingSnackbar = Snackbar.make(mRootView, R.string.publishing, Snackbar.LENGTH_INDEFINITðŸ”µ</abbr>
1309             mPublishingSnackbar.show();
1310         }
1311 
1312         setPublishedNote(true);
1313     }
1314 
1315     private void unpublishNote() {
1316         if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1317             Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1318             return;
1319         }
1320 
1321         if (isAdded()) {
<abbr title="1322             mPublishingSnackbar = Snackbar.make(mRootView, R.string.unpublishing, Snackbar.LENGTH_INDEFINITE);">1322             mPublishingSnackbar = Snackbar.make(mRootView, R.string.unpublishing, Snackbar.LENGTH_INDEFINðŸ”µ</abbr>
1323             mPublishingSnackbar.show();
1324         }
1325 
1326         setPublishedNote(false);
1327     }
1328 
1329     private void showShareSheet() {
1330         if (isAdded() &amp;&amp; mShareBottomSheet != null &amp;&amp; !mShareBottomSheet.isAdded()) {
1331             mShareBottomSheet.show(requireFragmentManager(), mNote);
1332         }
1333     }
1334 
1335     private void showInfoSheet() {
1336         if (isAdded() &amp;&amp; mInfoBottomSheet != null &amp;&amp; !mInfoBottomSheet.isAdded()) {
1337             mInfoBottomSheet.show(requireFragmentManager(), mNote);
1338         }
1339     }
1340 
1341     private void showHistorySheet() {
1342         if (isAdded() &amp;&amp; mHistoryBottomSheet != null &amp;&amp; !mHistoryBottomSheet.isAdded()) {
1343             // Request revisions for the current note
<abbr title="1344             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbacks());">1344             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbaðŸ”µ</abbr>
1345             saveNote();
1346 
1347             mHistoryBottomSheet.show(requireFragmentManager(), mNote);
1348         }
1349     }
1350 
1351     /**
1352      * Simperium listeners
1353      */
1354 
1355     @Override
1356     public void onDeleteObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1357 
1358     }
1359 
1360     @Override
<abbr title="1361     public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) {">1361     public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) ðŸ”µ</abbr>
1362         if (changeType == Bucket.ChangeType.MODIFY) {
1363             if (getNote() != null &amp;&amp; getNote().getSimperiumKey().equals(key)) {
1364                 try {
1365                     final Note updatedNote = mNotesBucket.get(key);
1366                     if (getActivity() != null) {
1367                         getActivity().runOnUiThread(new Runnable() {
1368                             @Override
1369                             public void run() {
1370                                 if (mPublishTimeoutHandler != null) {
1371                                     mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
1372                                 }
1373 
1374                                 updateNote(updatedNote);
1375                                 updatePublishedState(true);
1376                             }
1377                         });
1378                     }
1379                 } catch (BucketObjectMissingException e) {
1380                     e.printStackTrace();
1381                 }
1382             }
1383         }
1384     }
1385 
1386     @Override
1387     public void onSaveObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1388         if (mIsPaused) {
1389             mNotesBucket.removeListener(this);
1390             mNotesBucket.stop();
1391         }
1392     }
1393 
1394     @Override
1395     public void onBeforeUpdateObject(Bucket&lt;Note&gt; bucket, Note note) {
1396         // Don&#x27;t apply updates if we haven&#x27;t loaded the note yet
1397         if (mIsLoadingNote)
1398             return;
1399 
1400         Note openNote = getNote();
1401         if (openNote == null || !openNote.getSimperiumKey().equals(note.getSimperiumKey()))
1402             return;
1403 
1404         note.setContent(mContentEditText.getPlainTextContent());
1405     }
1406 
1407     private static class LoadNoteTask extends AsyncTask&lt;String, Void, Void&gt; {
1408         WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1409 
1410         LoadNoteTask(NoteEditorFragment fragment) {
1411             mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1412         }
1413 
1414         @Override
1415         protected void onPreExecute() {
1416             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1417             if (fragment != null) {
1418                 fragment.mContentEditText.removeTextChangedListener(fragment);
1419                 fragment.mIsLoadingNote = true;
1420             }
1421         }
1422 
1423         @Override
1424         protected Void doInBackground(String... args) {
1425             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1426             if ((fragment == null) || (fragment.getActivity() == null)) {
1427                 return null;
1428             }
1429             String noteID = args[0];
1430             Simplenote application = ((Simplenote) (fragment.getActivity().getApplication()));
1431             Bucket&lt;Note&gt; notesBucket = application.getNotesBucket();
1432             try {
1433                 fragment.mNote = notesBucket.get(noteID);
1434                 // Set the current note in NotesActivity when on a tablet
1435                 if (fragment.getActivity() instanceof NotesActivity) {
1436                     ((NotesActivity) (fragment.getActivity())).setCurrentNote(fragment.mNote);
1437                 }
1438                 // Set markdown and preview flags for current note
1439                 if (fragment.mNote != null) {
1440                     fragment.mIsMarkdownEnabled = fragment.mNote.isMarkdownEnabled();
1441                     fragment.mIsPreviewEnabled = fragment.mNote.isPreviewEnabled();
1442                 }
1443             } catch (BucketObjectMissingException e) {
1444                 // See if the note is in the object store
1445                 Bucket.ObjectCursor&lt;Note&gt; notesCursor = notesBucket.allObjects();
1446                 while (notesCursor.moveToNext()) {
1447                     Note currentNote = notesCursor.getObject();
1448                     if ((currentNote != null) &amp;&amp; currentNote.getSimperiumKey().equals(noteID)) {
1449                         fragment.mNote = currentNote;
1450                         return null;
1451                     }
1452                 }
1453             }
1454             return null;
1455         }
1456 
1457         @Override
1458         protected void onPostExecute(Void nada) {
1459             final NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
<abbr title="1460             if (((fragment == null) || (fragment.getActivity() == null)) || fragment.getActivity().isFinishing()) {">1460             if (((fragment == null) || (fragment.getActivity() == null)) || fragment.getActivity().isFiniðŸ”µ</abbr>
1461                 return;
1462             }
1463             fragment.refreshContent(false);
1464             if (fragment.mMatchOffsets != null) {
<abbr title="1465                 int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.CONTENT_PROPERTY);">1465                 int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndeðŸ”µ</abbr>
1466                 fragment.mHighlighter.highlightMatches(fragment.mMatchOffsets, columnIndex);
1467                 fragment.mShouldScrollToSearchMatch = true;
1468             }
1469             fragment.mContentEditText.addTextChangedListener(fragment);
1470             if ((fragment.mNote != null) &amp;&amp; fragment.mNote.getContent().isEmpty()) {
1471                 // Show soft keyboard
1472                 fragment.mContentEditText.requestFocus();
1473                 new Handler().postDelayed(new Runnable() {
1474                     @Override
1475                     public void run() {
1476                         if (fragment.getActivity() == null) {
1477                             return;
1478                         }
<abbr title="1479                         InputMethodManager inputMethodManager = ((InputMethodManager) (fragment.getActivity().getSystemService(Context.INPUT_METHOD_SERVICE)));">1479                         InputMethodManager inputMethodManager = ((InputMethodManager) (fragment.getActiviðŸ”µ</abbr>
1480                         if (inputMethodManager != null) {
1481                             inputMethodManager.showSoftInput(fragment.mContentEditText, 0);
1482                         }
1483                     }
1484                 }, 100);
1485             } else if (fragment.mNote != null) {
1486                 // If we have a valid note, hide the placeholder
1487                 fragment.setPlaceholderVisible(false);
1488             }
1489             fragment.updateMarkdownView();
1490             fragment.requireActivity().invalidateOptionsMenu();
1491             fragment.linkifyEditorContent();
1492             fragment.mIsLoadingNote = false;
1493         }
1494     }
1495 
1496     private static class SaveNoteTask extends AsyncTask&lt;Void, Void, Void&gt; {
1497         WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1498 
1499         SaveNoteTask(NoteEditorFragment fragment) {
1500             mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1501         }
1502 
1503         @Override
1504         protected Void doInBackground(Void... args) {
1505             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1506             if (fragment != null) {
1507                 fragment.saveNote();
1508             }
1509             return null;
1510         }
1511 
1512         @Override
1513         protected void onPostExecute(Void nada) {
1514             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
<abbr title="1515             if (((fragment != null) &amp;&amp; (fragment.getActivity() != null)) &amp;&amp; (!fragment.getActivity().isFinishing())) {">1515             if (((fragment != null) &amp;&amp; (fragment.getActivity() != null)) &amp;&amp; (!fragment.getActivity().isFiðŸ”µ</abbr>
1516                 // Update links
1517                 fragment.linkifyEditorContent();
1518                 fragment.updateMarkdownView();
1519             }
1520         }
1521     }
1522 
1523     private void linkifyEditorContent() {
1524         if (getActivity() == null || getActivity().isFinishing()) {
1525             return;
1526         }
1527 
1528         if (PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_DETECT_LINKS)) {
1529             SimplenoteLinkify.addLinks(mContentEditText, Linkify.ALL);
1530         }
1531     }
1532 
1533     // Show tabs if markdown is enabled globally, for current note, and not tablet landscape
1534     private void updateMarkdownView() {
1535         if (!mIsMarkdownEnabled) {
1536             return;
1537         }
1538 
1539         Activity activity = getActivity();
1540         if (activity instanceof NotesActivity) {
1541             // This fragment lives in NotesActivity, so load markdown in this fragment&#x27;s WebView.
1542             loadMarkdownData();
1543         } else {
1544             // This fragment lives in the NoteEditorActivity&#x27;s ViewPager.
1545             if (mNoteMarkdownFragment == null) {
1546                 mNoteMarkdownFragment = ((NoteEditorActivity) requireActivity())
1547                         .getNoteMarkdownFragment();
1548                 ((NoteEditorActivity) requireActivity()).showTabs();
1549             }
1550             // Load markdown in the sibling NoteMarkdownFragment&#x27;s WebView.
1551             mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPlainTextContent());
1552         }
1553     }
1554 
1555     private ColorStateList getChipBackgroundColor() {
1556         int[][] states = new int[][] {
1557             new int[] { android.R.attr.state_checked}, // checked
1558             new int[] {-android.R.attr.state_checked}  // unchecked
1559         };
1560 
1561         int[] colors = new int[] {
1562             ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOnBackgroundColor),
1563             ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOffBackgroundColor)
1564         };
1565 
1566         return new ColorStateList(states, colors);
1567     }
1568 
1569     private void setChips(CharSequence text) {
1570         mTagPadding.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1571         mTagChips.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1572         mTagChips.setSingleSelection(true);
1573         mTagChips.removeAllViews();
1574         SimpleStringSplitter tags = new SimpleStringSplitter(SPACE);
1575         tags.setString(text.toString());
1576 
1577         for (String tag : tags) {
1578             final Chip chip = new Chip(requireContext());
1579             chip.setText(tag);
1580             chip.setCheckable(true);
1581             chip.setCheckedIcon(null);
1582             chip.setChipBackgroundColor(getChipBackgroundColor());
1583             chip.setTextColor(ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipTextColor));
1584             chip.setStateListAnimator(null);
1585             chip.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
1586                 @Override
1587                 public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
1588                     chip.setCloseIconVisible(isChecked);
1589                 }
1590             });
1591             chip.setOnCloseIconClickListener(new View.OnClickListener() {
1592                 @Override
1593                 public void onClick(View view) {
1594                     mTagChips.removeView(view);
1595                     updateTags();
1596                     AnalyticsTracker.track(
1597                         EDITOR_TAG_REMOVED,
1598                         CATEGORY_NOTE,
1599                         &quot;tag_removed_from_note&quot;
1600                     );
1601                 }
1602             });
1603             mTagChips.addView(chip);
1604         }
1605     }
1606 
1607     private void updateTags() {
1608         if (mNote == null) {
1609             return;
1610         }
1611 
1612         mNote.setTagString(getNoteTagsString());
1613         mNote.setModificationDate(Calendar.getInstance());
1614         updateTagList();
1615         mNote.save();
1616     }
1617 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  package com.automattic.simplenote;
   2  
   3  import android.app.Activity;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">   4 -import android.content.ClipData;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">   5 -import android.content.ClipboardManager;</span>
   6  import android.content.Context;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">   7 -import android.content.Intent;</span>
   8  import android.content.SharedPreferences;
   9  import android.content.res.ColorStateList;
  10  import android.database.Cursor;
  11  import android.graphics.Typeface;
  12  import android.graphics.drawable.Drawable;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  13 -import android.net.Uri;</span>
  14  import android.os.AsyncTask;
  15  import android.os.Bundle;
  16  import android.os.Handler;
  17  import android.text.Editable;
  18  import android.text.Layout;
  19  import android.text.Spanned;
  20  import android.text.TextUtils.SimpleStringSplitter;
  21  import android.text.TextWatcher;
  22  import android.text.style.MetricAffectingSpan;
  23  import android.text.style.RelativeSizeSpan;
  24  import android.text.style.StyleSpan;
  25  import android.text.style.URLSpan;
  26  import android.text.util.Linkify;
  27  import android.util.TypedValue;
  28  import android.view.LayoutInflater;
  29  import android.view.Menu;
  30  import android.view.MenuInflater;
  31  import android.view.MenuItem;
  32  import android.view.View;
  33  import android.view.ViewGroup;
  34  import android.view.ViewTreeObserver;
  35  import android.view.inputmethod.InputMethodManager;
  36  import android.webkit.WebView;
  37  import android.widget.CompoundButton;
  38  import android.widget.CursorAdapter;
  39  import android.widget.LinearLayout;
  40  import android.widget.TextView;
  41  import android.widget.Toast;
  42  
  43  import androidx.annotation.NonNull;
  44  import androidx.appcompat.app.AppCompatActivity;
  45  import androidx.appcompat.view.ActionMode;

  46  import androidx.core.view.MenuCompat;
  47  import androidx.core.widget.NestedScrollView;
  48  import androidx.fragment.app.Fragment;
  49  import androidx.fragment.app.FragmentTransaction;
  50  import androidx.preference.PreferenceManager;
  51  
  52  import com.automattic.simplenote.analytics.AnalyticsTracker;
  53  import com.automattic.simplenote.models.Note;
  54  import com.automattic.simplenote.models.Tag;
  55  import com.automattic.simplenote.utils.AutoBullet;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  56 +import com.automattic.simplenote.utils.BrowserUtils;</span>
  57  import com.automattic.simplenote.utils.ContextUtils;
  58  import com.automattic.simplenote.utils.DisplayUtils;
  59  import com.automattic.simplenote.utils.DrawableUtils;
  60  import com.automattic.simplenote.utils.MatchOffsetHighlighter;
  61  import com.automattic.simplenote.utils.NetworkUtils;
  62  import com.automattic.simplenote.utils.NoteUtils;
  63  import com.automattic.simplenote.utils.PrefUtils;
  64  import com.automattic.simplenote.utils.SimplenoteLinkify;
  65  import com.automattic.simplenote.utils.SimplenoteMovementMethod;
  66  import com.automattic.simplenote.utils.SpaceTokenizer;
  67  import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;
  68  import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;
  69  import com.automattic.simplenote.utils.TextHighlighter;
  70  import com.automattic.simplenote.utils.ThemeUtils;
  71  import com.automattic.simplenote.utils.WidgetUtils;
  72  import com.automattic.simplenote.widgets.SimplenoteEditText;
  73  import com.google.android.material.chip.Chip;
  74  import com.google.android.material.chip.ChipGroup;
  75  import com.google.android.material.snackbar.Snackbar;
  76  import com.simperium.client.Bucket;
  77  import com.simperium.client.BucketObjectMissingException;
  78  import com.simperium.client.Query;
  79  
  80  import java.lang.ref.WeakReference;
  81  import java.util.Calendar;
  82  
  83  import static com.automattic.simplenote.analytics.AnalyticsTracker.CATEGORY_NOTE;
  84  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_CHECKLIST_INSERTED;
  85  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_CONTENT_SHARED;
  86  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_EDITED;
  87  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_PUBLISHED;
  88  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_UNPUBLISHED;
  89  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_ADDED;
  90  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_REMOVED;
  91  import static com.automattic.simplenote.utils.SearchTokenizer.SPACE;
  92  
  93  public class NoteEditorFragment extends Fragment implements Bucket.Listener&lt;Note&gt;,
  94          TextWatcher, OnTagAddedListener, View.OnFocusChangeListener,
  95          SimplenoteEditText.OnSelectionChangedListener,
  96          ShareBottomSheetDialog.ShareSheetListener,
  97          HistoryBottomSheetDialog.HistorySheetListener,
  98          SimplenoteEditText.OnCheckboxToggledListener {
  99  
 100      public static final String ARG_IS_FROM_WIDGET = &quot;is_from_widget&quot;;
 101      public static final String ARG_ITEM_ID = &quot;item_id&quot;;
 102      public static final String ARG_NEW_NOTE = &quot;new_note&quot;;
 103      public static final String ARG_MATCH_OFFSETS = &quot;match_offsets&quot;;
 104      public static final String ARG_MARKDOWN_ENABLED = &quot;markdown_enabled&quot;;
 105      public static final String ARG_PREVIEW_ENABLED = &quot;preview_enabled&quot;;
 106      private static final String STATE_NOTE_ID = &quot;state_note_id&quot;;
 107      private static final int AUTOSAVE_DELAY_MILLIS = 2000;
 108      private static final int MAX_REVISIONS = 30;
 109      private static final int PUBLISH_TIMEOUT = 20000;
 110      private static final int HISTORY_TIMEOUT = 10000;
 111      private Note mNote;
 112      private final Runnable mAutoSaveRunnable = new Runnable() {
 113          @Override
 114          public void run() {
 115              saveAndSyncNote();
 116          }
 117      };
 118      private Bucket&lt;Note&gt; mNotesBucket;
 119      private View mRootView;
 120      private View mTagPadding;
 121      private SimplenoteEditText mContentEditText;
 122      private ChipGroup mTagChips;
 123      private TagsMultiAutoCompleteTextView mTagInput;
 124      private Handler mAutoSaveHandler;
 125      private Handler mPublishTimeoutHandler;
 126      private Handler mHistoryTimeoutHandler;
 127      private LinearLayout mPlaceholderView;
 128      private CursorAdapter mAutocompleteAdapter;
 129      private boolean mIsLoadingNote;
 130      private boolean mIsMarkdownEnabled;
 131      private boolean mIsPreviewEnabled;
 132      private boolean mShouldScrollToSearchMatch;
 133      private ActionMode mActionMode;

 134      private MenuItem mCopyMenuItem;

 135      private MenuItem mShareMenuItem;
 136      private MenuItem mViewLinkMenuItem;
 137      private String mLinkUrl;
 138      private String mLinkText;
 139      private MatchOffsetHighlighter mHighlighter;
 140      private Drawable mCallIcon;
 141      private Drawable mCopyIcon;
 142      private Drawable mEmailIcon;
 143      private Drawable mMapIcon;
 144      private Drawable mShareIcon;
 145      private Drawable mBrowserIcon;
 146      private MatchOffsetHighlighter.SpanFactory mMatchHighlighter;
 147      private String mMatchOffsets;
 148      private int mCurrentCursorPosition;
 149      private HistoryBottomSheetDialog mHistoryBottomSheet;
 150      private boolean mIsPaused;
 151      private boolean mIsFromWidget;
 152  
 153      // Hides the history bottom sheet if no revisions are loaded
 154      private final Runnable mHistoryTimeoutRunnable = new Runnable() {
 155          @Override
 156          public void run() {
 157              if (!isAdded()) {
 158                  return;
 159              }
 160  
 161              requireActivity().runOnUiThread(new Runnable() {
 162                  @Override
 163                  public void run() {
<abbr title=" 164                      if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; !mHistoryBottomSheet.isHistoryLoaded()) {"> 164                      if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; ðŸ”µ</abbr>
 165                          mHistoryBottomSheet.dismiss();
 166                          Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 167                      }
 168                  }
 169              });
 170          }
 171      };
 172      private InfoBottomSheetDialog mInfoBottomSheet;
 173      private ShareBottomSheetDialog mShareBottomSheet;
 174      // Contextual action bar for dealing with links
 175      private final ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
 176          // Called when the action mode is created; startActionMode() was called
 177          @Override
 178          public boolean onCreateActionMode(ActionMode mode, Menu menu) {
 179              // Inflate a menu resource providing context menu items
 180              MenuInflater inflater = mode.getMenuInflater();
 181  
 182              if (inflater != null) {
 183                  inflater.inflate(R.menu.view_link, menu);
 184                  mCopyMenuItem = menu.findItem(R.id.menu_copy);
 185                  mShareMenuItem = menu.findItem(R.id.menu_share);
 186                  mViewLinkMenuItem = menu.findItem(R.id.menu_view_link);
 187                  mode.setTitle(getString(R.string.link));
 188                  mode.setTitleOptionalHint(false);
 189  
 190                  DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 191              }
 192  
<abbr title=" 193              int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.background_dark;"> 193              int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.backgrðŸ”µ</abbr>
<abbr title=" 194              requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().getTheme()));"> 194              requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().ðŸ”µ</abbr>
 195              return true;
 196          }
 197  
 198          // Called each time the action mode is shown. Always called after onCreateActionMode, but
 199          // may be called multiple times if the mode is invalidated.
 200          @Override
 201          public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 202              return false; // Return false if nothing is done
 203          }
 204  
 205          // Called when the user selects a contextual menu item
 206          @Override
 207          public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 208              switch (item.getItemId()) {
 209                  case R.id.menu_view_link:
 210                      if (mLinkUrl != null) {
 211                          try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 212 -                            Uri uri = Uri.parse(mLinkUrl);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 213 -                            Intent i = new Intent(Intent.ACTION_VIEW);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 214 -                            i.setData(uri);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 215 -                            startActivity(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 216 +                            BrowserUtils.launchBrowserOrShowError(requireContext(), mLinkUrl);</span>
 217                          } catch (Exception e) {
 218                              e.printStackTrace();
 219                          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 220 +</span>
 221                          mode.finish(); // Action picked, so close the CAB
 222                      }
 223                      return true;
 224                  case R.id.menu_copy:
 225                      if (mLinkText != null &amp;&amp; getActivity() != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 226 -                        copyToClipboard(mLinkText);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 227 +                        BrowserUtils.copyToClipboard(requireContext(), mLinkText);</span>
 228                          Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 229                          mode.finish();
 230                      }
 231                      return true;
 232                  case R.id.menu_share:
 233                      if (mLinkText != null) {
 234                          showShareSheet();

 235                          mode.finish();
 236                      }
 237                      return true;
 238                  default:
 239                      return false;
 240              }
 241          }
 242  
 243          // Called when the user exits the action mode
 244          @Override
 245          public void onDestroyActionMode(ActionMode mode) {
 246              mActionMode = null;
 247              new Handler().postDelayed(
 248                  new Runnable() {
 249                      @Override
 250                      public void run() {
<abbr title=" 251                          requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 251                          requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.trðŸ”µ</abbr>
 252                      }
 253                  },
 254                  requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime)
 255              );
 256          }
 257      };
 258      private Snackbar mPublishingSnackbar;
 259      private boolean mHideActionOnSuccess;
 260      // Resets note publish status if Simperium never returned the new publish status
 261      private final Runnable mPublishTimeoutRunnable = new Runnable() {
 262          @Override
 263          public void run() {
 264              if (!isAdded()) return;
 265  
 266              requireActivity().runOnUiThread(new Runnable() {
 267                  @Override
 268                  public void run() {
 269  
 270                      mNote.setPublished(!mNote.isPublished());
 271                      mNote.save();
 272  
 273                      updatePublishedState(false);
 274                  }
 275              });
 276          }
 277      };
 278      private NoteMarkdownFragment mNoteMarkdownFragment;
 279      private String mCss;
 280      private WebView mMarkdown;
 281  
 282      /**
 283       * Mandatory empty constructor for the fragment manager to instantiate the
 284       * fragment (e.g. upon screen orientation changes).
 285       */
 286      public NoteEditorFragment() {
 287      }
 288  
 289      @Override
 290      public void onCreate(Bundle savedInstanceState) {
 291          super.onCreate(savedInstanceState);
 292          mInfoBottomSheet = new InfoBottomSheetDialog(this);
 293          mShareBottomSheet = new ShareBottomSheetDialog(this, this);
 294          mHistoryBottomSheet = new HistoryBottomSheetDialog(this, this);
 295  
 296          Simplenote currentApp = (Simplenote) requireActivity().getApplication();
 297          mNotesBucket = currentApp.getNotesBucket();
 298  
<abbr title=" 299          mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.actionModeTextColor);"> 299          mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.aðŸ”µ</abbr>
<abbr title=" 300          mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.attr.actionModeTextColor);"> 300          mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.attr.actioðŸ”µ</abbr>
<abbr title=" 301          mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.actionModeTextColor);"> 301          mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.actionModðŸ”µ</abbr>
<abbr title=" 302          mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp, R.attr.actionModeTextColor);"> 302          mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp, R.attr.aðŸ”µ</abbr>
<abbr title=" 303          mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attr.actionModeTextColor);"> 303          mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attr.actionMðŸ”µ</abbr>
<abbr title=" 304          mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.attr.actionModeTextColor);"> 304          mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.attr.actioðŸ”µ</abbr>
 305  
 306          mAutoSaveHandler = new Handler();
 307          mPublishTimeoutHandler = new Handler();
 308          mHistoryTimeoutHandler = new Handler();
 309  
 310          mMatchHighlighter = new TextHighlighter(requireActivity(),
 311                  R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor);
 312          mAutocompleteAdapter = new CursorAdapter(getActivity(), null, 0x0) {
 313              @Override
 314              public View newView(Context context, Cursor cursor, ViewGroup parent) {
 315                  Activity activity = (Activity) context;
 316                  if (activity == null) return null;
 317                  return activity.getLayoutInflater().inflate(R.layout.tag_autocomplete_list_item, null);
 318              }
 319  
 320              @Override
 321              public void bindView(View view, Context context, Cursor cursor) {
 322                  TextView textView = (TextView) view;
 323                  textView.setText(convertToString(cursor));
 324              }
 325  
 326              @Override
 327              public CharSequence convertToString(Cursor cursor) {
 328                  return cursor.getString(cursor.getColumnIndex(Tag.NAME_PROPERTY));
 329              }
 330  
 331              @Override
 332              public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 333                  Activity activity = getActivity();
 334                  if (activity == null) return null;
 335                  Simplenote application = (Simplenote) activity.getApplication();
 336                  Query&lt;Tag&gt; query = application.getTagsBucket().query();
 337                  // make the tag name available to the cursor
 338                  query.include(Tag.NAME_PROPERTY);
 339                  // sort the tags by their names
 340                  query.order(Tag.NAME_PROPERTY);
 341                  // if there&#x27;s a filter string find only matching tag names
 342                  if (filter != null)
 343                      query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filter));
 344                  return query.execute();
 345              }
 346          };
 347  
 348          WidgetUtils.updateNoteWidgets(requireActivity().getApplicationContext());
 349      }
 350  
 351      @Override
 352      public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
 353          mRootView = inflater.inflate(R.layout.fragment_note_editor, container, false);
 354          mContentEditText = mRootView.findViewById(R.id.note_content);
 355          mContentEditText.addOnSelectionChangedListener(this);
 356          mContentEditText.setOnCheckboxToggledListener(this);
 357          mContentEditText.setMovementMethod(SimplenoteMovementMethod.getInstance());
 358          mContentEditText.setOnFocusChangeListener(this);
 359          mTagInput = mRootView.findViewById(R.id.tag_input);
 360          mTagInput.setDropDownBackgroundResource(R.drawable.bg_list_popup);
 361          mTagInput.setTokenizer(new SpaceTokenizer());
 362          mTagInput.setOnFocusChangeListener(this);
 363          mTagChips = mRootView.findViewById(R.id.tag_chips);
 364          mTagPadding = mRootView.findViewById(R.id.tag_padding);
 365          mHighlighter = new MatchOffsetHighlighter(mMatchHighlighter, mContentEditText);
 366          mPlaceholderView = mRootView.findViewById(R.id.placeholder);
 367  
 368          if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote == null) {
 369              mPlaceholderView.setVisibility(View.VISIBLE);
 370              requireActivity().invalidateOptionsMenu();
 371              mMarkdown = mRootView.findViewById(R.id.markdown);
 372              mCss = ThemeUtils.isLightTheme(requireContext())
 373                      ? ContextUtils.readCssFile(requireContext(), &quot;light.css&quot;)
 374                      : ContextUtils.readCssFile(requireContext(), &quot;dark.css&quot;);
 375          }
 376  
 377          mTagInput.setAdapter(mAutocompleteAdapter);
 378          Bundle arguments = getArguments();
 379  
 380          if (arguments != null &amp;&amp; arguments.containsKey(ARG_ITEM_ID)) {
 381              // Load note if we were passed a note Id
 382              String key = arguments.getString(ARG_ITEM_ID);
 383  
 384              if (arguments.containsKey(ARG_MATCH_OFFSETS)) {
 385                  mMatchOffsets = arguments.getString(ARG_MATCH_OFFSETS);
 386              }
 387  
 388              mIsFromWidget = arguments.getBoolean(ARG_IS_FROM_WIDGET);
 389              new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, key);
 390          } else if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; savedInstanceState != null) {
 391              // Restore selected note when in dual pane mode
 392              String noteId = savedInstanceState.getString(STATE_NOTE_ID);
 393  
 394              if (noteId != null) {
 395                  setNote(noteId);
 396              }
 397          }
 398  
 399          ViewTreeObserver viewTreeObserver = mContentEditText.getViewTreeObserver();
 400          viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
 401              @Override
 402              public void onGlobalLayout() {
 403                  // If a note was loaded with search matches, scroll to the first match in the editor
 404                  if (mShouldScrollToSearchMatch &amp;&amp; mMatchOffsets != null) {
 405                      if (!isAdded()) {
 406                          return;
 407                      }
 408  
 409                      // Get the character location of the first search match
 410                      int matchLocation = MatchOffsetHighlighter.getFirstMatchLocation(
 411                              mContentEditText.getText(),
 412                              mMatchOffsets
 413                      );
 414                      if (matchLocation == 0) {
 415                          return;
 416                      }
 417  
 418                      // Calculate how far to scroll to bring the match into view
 419                      Layout layout = mContentEditText.getLayout();
 420                      int lineTop = layout.getLineTop(layout.getLineForOffset(matchLocation));
 421                      ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 422                      mShouldScrollToSearchMatch = false;
 423                  }
 424              }
 425          });
 426          setHasOptionsMenu(true);
 427          return mRootView;
 428      }
 429  
 430      public void scrollToMatch(int location) {
 431          if (isAdded()) {
 432              // Calculate how far to scroll to bring the match into view
 433              Layout layout = mContentEditText.getLayout();
 434              int lineTop = layout.getLineTop(layout.getLineForOffset(location));
 435              ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 436          }
 437      }
 438  
 439      @Override
 440      public void onResume() {
 441          super.onResume();
 442          mNotesBucket.start();
 443          mNotesBucket.addListener(this);
 444          mTagInput.setOnTagAddedListener(this);
 445  
 446          if (mContentEditText != null) {
 447              mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(getActivity()));
 448  
 449              if (mContentEditText.hasFocus()) {
 450                  showSoftKeyboard();
 451              }
 452          }
 453      }
 454  
 455      private void showSoftKeyboard() {
 456          new Handler().postDelayed(new Runnable() {
 457              @Override
 458              public void run() {
 459                  if (getActivity() == null) {
 460                      return;
 461                  }
 462  
<abbr title=" 463                  InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);"> 463                  InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(ContexðŸ”µ</abbr>
 464                  if (inputMethodManager != null) {
 465                      inputMethodManager.showSoftInput(mContentEditText, 0);
 466                  }
 467              }
 468          }, 100);
 469      }
 470  
 471      @Override
 472      public void onPause() {
 473          super.onPause();  // Always call the superclass method first
 474          mIsPaused = true;
 475  
 476          // Hide soft keyboard if it is showing...
 477          DisplayUtils.hideKeyboard(mContentEditText);
 478  
 479          mTagInput.setOnTagAddedListener(null);
 480  
 481          if (mAutoSaveHandler != null) {
 482              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 483          }
 484  
 485          if (mPublishTimeoutHandler != null) {
 486              mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
 487          }
 488  
 489          if (mHistoryTimeoutHandler != null) {
 490              mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 491          }
 492  
 493          mHighlighter.stop();
 494          saveNote();
 495      }
 496  
 497      @Override
 498      public void onDestroy() {
 499          super.onDestroy();
 500          mNotesBucket.removeListener(this);
 501          mNotesBucket.stop();
 502      }
 503  
 504      @Override
 505      public void onSaveInstanceState(@NonNull Bundle outState) {
 506          super.onSaveInstanceState(outState);
 507  
 508          if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote != null) {
 509              outState.putString(STATE_NOTE_ID, mNote.getSimperiumKey());
 510          }
 511      }
 512  
 513      @Override
 514      public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
 515          super.onCreateOptionsMenu(menu, inflater);
 516  
<abbr title=" 517          if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFragment == null)) {"> 517          if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFrðŸ”µ</abbr>
 518              return;
 519          }
 520  
 521          inflater.inflate(R.menu.note_editor, menu);
 522          MenuCompat.setGroupDividerEnabled(menu, true);
 523      }
 524  
 525      @Override
 526      public boolean onOptionsItemSelected(@NonNull MenuItem item) {
 527          switch (item.getItemId()) {
 528              case R.id.menu_checklist:
 529                  DrawableUtils.startAnimatedVectorDrawable(item.getIcon());
 530                  insertChecklist();
 531                  return true;
 532              case R.id.menu_copy:
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 533 -                copyToClipboard(mNote.getPublishedUrl());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 534 +                BrowserUtils.copyToClipboard(requireContext(), mNote.getPublishedUrl());</span>
 535                  Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 536                  return true;
 537              case R.id.menu_history:
 538                  showHistory();
 539                  return true;
 540              case R.id.menu_info:
 541                  DrawableUtils.startAnimatedVectorDrawable(item.getIcon());
 542                  showInfo();
 543                  return true;
 544              case R.id.menu_markdown:
 545                  setMarkdown(!item.isChecked());
 546                  return true;
 547              case R.id.menu_pin:
 548                  NoteUtils.setNotePin(mNote, !item.isChecked());
 549                  requireActivity().invalidateOptionsMenu();
 550                  return true;
 551              case R.id.menu_publish:
 552                  if (item.isChecked()) {
 553                      unpublishNote();
 554                  } else {
 555                      publishNote();
 556                  }
 557  
 558                  return true;
 559              case R.id.menu_share:
 560                  shareNote();
 561                  return true;
 562              case R.id.menu_trash:
 563                  if (!isAdded()) {
 564                      return false;
 565                  }
 566  
 567                  deleteNote();
 568                  return true;
 569              case android.R.id.home:
 570                  if (!isAdded()) {
 571                      return false;
 572                  }
 573  
 574                  requireActivity().finish();
 575                  return true;
 576              default:
 577                  return super.onOptionsItemSelected(item);
 578          }
 579      }
 580  
 581      @Override
 582      public void onPrepareOptionsMenu(@NonNull Menu menu) {
 583          if (mNote != null) {
 584              menu.findItem(R.id.menu_info).setVisible(true);
 585              MenuItem pinItem = menu.findItem(R.id.menu_pin);
 586              MenuItem shareItem = menu.findItem(R.id.menu_share);
 587              MenuItem historyItem = menu.findItem(R.id.menu_history);
 588              MenuItem publishItem = menu.findItem(R.id.menu_publish);
 589              MenuItem copyLinkItem = menu.findItem(R.id.menu_copy);
 590              MenuItem markdownItem = menu.findItem(R.id.menu_markdown);
 591              MenuItem trashItem = menu.findItem(R.id.menu_trash);
 592              MenuItem checklistItem = menu.findItem(R.id.menu_checklist);


 593  
 594              pinItem.setChecked(mNote.isPinned());
 595              publishItem.setChecked(mNote.isPublished());
 596              markdownItem.setChecked(mNote.isMarkdownEnabled());
 597  
 598              // Disable actions when note is in Trash or markdown view is shown on large device.
 599              if (mNote.isDeleted() || (mMarkdown != null &amp;&amp; mMarkdown.getVisibility() == View.VISIBLE)) {
 600                  pinItem.setEnabled(false);
 601                  shareItem.setEnabled(false);
 602                  historyItem.setEnabled(false);
 603                  publishItem.setEnabled(false);
 604                  copyLinkItem.setEnabled(false);
 605                  markdownItem.setEnabled(false);
 606                  checklistItem.setEnabled(false);
 607                  DrawableUtils.setMenuItemAlpha(checklistItem, 0.3);  // 0.3 is 30% opacity.


 608              } else {
 609                  pinItem.setEnabled(true);
 610                  shareItem.setEnabled(true);
 611                  historyItem.setEnabled(true);
 612                  publishItem.setEnabled(true);
 613                  copyLinkItem.setEnabled(mNote.isPublished());
 614                  markdownItem.setEnabled(true);
 615                  checklistItem.setEnabled(true);
 616                  DrawableUtils.setMenuItemAlpha(checklistItem, 1.0);  // 1.0 is 100% opacity.


 617              }
 618  
 619              if (mNote.isDeleted()) {
 620                  trashItem.setTitle(R.string.restore);
 621              } else {
 622                  trashItem.setTitle(R.string.trash);
 623              }
 624          }
 625  
 626          DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 627          super.onPrepareOptionsMenu(menu);
 628      }
 629  
 630      private void insertChecklist() {



 631          try {
 632              mContentEditText.insertChecklist();
 633          } catch (Exception e) {
 634              e.printStackTrace();
 635              return;
 636          }
 637  
 638          AnalyticsTracker.track(
 639              EDITOR_CHECKLIST_INSERTED,
 640              CATEGORY_NOTE,
 641              &quot;toolbar_button&quot;
 642          );
 643      }
 644  
 645      @Override
 646      public void onCheckboxToggled() {
 647          // Save note (using delay) after toggling a checkbox
 648          if (mAutoSaveHandler != null) {
 649              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 650              mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 651          }
 652      }
 653  
 654      private void deleteNote() {
 655          NoteUtils.deleteNote(mNote, getActivity());
 656          requireActivity().finish();
 657      }
 658  
 659      protected void clearMarkdown() {
 660          mMarkdown.loadDataWithBaseURL(&quot;file:///android_asset/&quot;, mCss + &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 661      }
 662  
 663      protected void hideMarkdown() {
 664          mMarkdown.setVisibility(View.INVISIBLE);
 665      }
 666  
 667      protected void showMarkdown() {
 668          loadMarkdownData();
 669          mMarkdown.setVisibility(View.VISIBLE);
 670  
 671          new Handler().postDelayed(
 672              new Runnable() {
 673                  @Override
 674                  public void run() {
 675                      requireActivity().invalidateOptionsMenu();
 676                  }
 677              },
 678              getResources().getInteger(R.integer.time_animation)
 679          );
 680      }
 681  
 682      private void shareNote() {

 683          if (mNote != null) {
 684              mContentEditText.clearFocus();
 685              showShareSheet();
 686              AnalyticsTracker.track(
 687                  EDITOR_NOTE_CONTENT_SHARED,
 688                  CATEGORY_NOTE,
 689                  &quot;action_bar_share_button&quot;
 690              );
 691          }
 692      }
 693  
 694      private void showHistory() {

 695          if (mNote != null &amp;&amp; mNote.getVersion() &gt; 1) {
 696              mContentEditText.clearFocus();
 697              mHistoryTimeoutHandler.postDelayed(mHistoryTimeoutRunnable, HISTORY_TIMEOUT);
 698              showHistorySheet();
 699          } else {
 700              Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 701          }
 702      }
 703  
 704      private void showInfo() {



 705          if (mNote != null) {
 706              mContentEditText.clearFocus();
 707              saveNote();
 708              showInfoSheet();
 709          }
 710      }
 711  
 712      private void setMarkdown(boolean isChecked) {
 713          mIsMarkdownEnabled = isChecked;
 714          Activity activity = getActivity();
 715  
 716          if (activity instanceof NoteEditorActivity) {
 717              NoteEditorActivity editorActivity = (NoteEditorActivity) activity;
 718  
 719              if (mIsMarkdownEnabled) {
 720                  editorActivity.showTabs();
 721  
 722                  if (mNoteMarkdownFragment == null) {
 723                      // Get markdown fragment and update content
 724                      mNoteMarkdownFragment = editorActivity.getNoteMarkdownFragment();
 725                      mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPlainTextContent());
 726                  }
 727              } else {
 728                  editorActivity.hideTabs();
 729              }
 730          } else if (activity instanceof NotesActivity) {
 731              setMarkdownEnabled(mIsMarkdownEnabled);
 732              ((NotesActivity) getActivity()).setMarkdownShowing(false);
 733          }
 734  
 735          saveNote();
 736  
 737          // Set preference so that next new note will have markdown enabled.
 738          SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(requireContext());
 739          SharedPreferences.Editor editor = prefs.edit();
 740          editor.putBoolean(PrefUtils.PREF_MARKDOWN_ENABLED, isChecked);
 741          editor.apply();
 742      }
 743  
 744      protected void setMarkdownEnabled(boolean enabled) {
 745          mIsMarkdownEnabled = enabled;
 746  
 747          if (mIsMarkdownEnabled) {
 748              loadMarkdownData();
 749          }
 750      }
 751  
 752      private void loadMarkdownData() {
 753          String formattedContent = NoteMarkdownFragment.getMarkdownFormattedContent(
 754                  mCss,
 755                  mContentEditText.getPlainTextContent()
 756          );
 757  
 758          mMarkdown.loadDataWithBaseURL(null, formattedContent, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 759      }
 760  
 761      public void setNote(String noteID, String matchOffsets) {
 762          if (mAutoSaveHandler != null)
 763              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 764  
 765          mPlaceholderView.setVisibility(View.GONE);
 766  
 767          if (matchOffsets != null) {
 768              mMatchOffsets = matchOffsets;
 769          } else {
 770              mMatchOffsets = null;
 771          }
 772  
 773  
 774          saveNote();
 775  
 776          new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteID);
 777      }
 778  
 779      private void updateNote(Note updatedNote) {
 780          // update note if network change arrived
 781          mNote = updatedNote;
 782          refreshContent(true);
 783      }
 784  
 785      private void refreshContent(boolean isNoteUpdate) {
 786          if (mNote != null) {
 787              // Restore the cursor position if possible.
<abbr title=" 788              int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.getSelectionEnd());"> 788              int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.geðŸ”µ</abbr>
 789              mContentEditText.setText(mNote.getContent());
 790  
 791              if (isNoteUpdate) {
 792                  // Update markdown and preview flags from updated note.
 793                  mIsMarkdownEnabled = mNote.isMarkdownEnabled();
 794                  mIsPreviewEnabled = mNote.isPreviewEnabled();
 795  
 796                  // Show/Hide tabs based on markdown flag.
 797                  setMarkdown(mIsMarkdownEnabled);
 798  
 799                  // Save note so any local changes get synced.
 800                  mNote.save();
 801  
 802                  // Update current note object on large screen devices in landscape orientation.
 803                  if (DisplayUtils.isLargeScreenLandscape(requireContext())) {
 804                      ((NotesActivity) requireActivity()).setCurrentNote(mNote);
 805                  }
 806  
 807                  // Update overflow popup menu.
 808                  requireActivity().invalidateOptionsMenu();
 809  
 810                  if (mContentEditText.hasFocus()
 811                          &amp;&amp; cursorPosition != mContentEditText.getSelectionEnd()
 812                          &amp;&amp; cursorPosition &lt; mContentEditText.getText().length()) {
 813                      mContentEditText.setSelection(cursorPosition);
 814                  }
 815              }
 816  
 817              afterTextChanged(mContentEditText.getText());
 818              mContentEditText.processChecklists();
 819              updateTagList();
 820          }
 821      }
 822  
 823      private void updateTagList() {
 824          setChips(mNote.getTagString());
 825          mTagInput.setText(&quot;&quot;);
 826      }
 827  
 828      private int newCursorLocation(String newText, String oldText, int cursorLocation) {
 829          // Ported from the iOS app :)
 830          // Cases:
 831          // 0. All text after cursor (and possibly more) was removed ==&gt; put cursor at end
 832          // 1. Text was added after the cursor ==&gt; no change
 833          // 2. Text was added before the cursor ==&gt; location advances
 834          // 3. Text was removed after the cursor ==&gt; no change
 835          // 4. Text was removed before the cursor ==&gt; location retreats
 836          // 5. Text was added/removed on both sides of the cursor ==&gt; not handled
 837  
 838          cursorLocation = Math.max(cursorLocation, 0);
 839  
 840          int newCursorLocation = cursorLocation;
 841  
 842          int deltaLength = newText.length() - oldText.length();
 843  
 844          // Case 0
 845          if (newText.length() &lt; cursorLocation)
 846              return newText.length();
 847  
 848          boolean beforeCursorMatches = false;
 849          boolean afterCursorMatches = false;
 850  
 851          try {
<abbr title=" 852              beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation));"> 852              beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation)ðŸ”µ</abbr>
<abbr title=" 853              afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaLength));"> 853              afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaðŸ”µ</abbr>
 854          } catch (Exception e) {
 855              e.printStackTrace();
 856          }
 857  
 858          // Cases 2 and 4
 859          if (!beforeCursorMatches &amp;&amp; afterCursorMatches)
 860              newCursorLocation += deltaLength;
 861  
 862          // Cases 1, 3 and 5 have no change
 863          return newCursorLocation;
 864      }
 865  
 866      @Override
 867      public void onTagAdded(String tag) {
 868          if (mNote == null || !isAdded()) {
 869              return;
 870          }
 871  
 872          if (mNote.getTagString() != null &amp;&amp; tag.length() &gt; mNote.getTagString().length()) {
 873              AnalyticsTracker.track(
 874                  EDITOR_TAG_ADDED,
 875                  CATEGORY_NOTE,
 876                  &quot;tag_added_to_note&quot;
 877              );
 878          }
 879  
 880          mNote.setTagString(mNote.getTagString() + String.valueOf(SPACE) + tag);
 881          mNote.setModificationDate(Calendar.getInstance());
 882          updateTagList();
 883          mNote.save();
 884      }
 885  
 886      @Override
 887      public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
 888          // Unused
 889      }
 890  
 891      @Override
 892      public void afterTextChanged(Editable editable) {
 893          attemptAutoList(editable);
 894          setTitleSpan(editable);
 895          mContentEditText.fixLineSpacing();
 896      }
 897  
 898      @Override
 899      public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
 900          // When text changes, start timer that will fire after AUTOSAVE_DELAY_MILLIS passes
 901          if (mAutoSaveHandler != null) {
 902              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 903              mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 904          }
 905  
 906          // Remove search highlight spans when note content changes
 907          if (mMatchOffsets != null) {
 908              mMatchOffsets = null;
 909              mHighlighter.removeMatches();
 910          }
 911  
 912          if (!DisplayUtils.isLargeScreenLandscape(requireContext())) {
 913              ((NoteEditorActivity) requireActivity()).setSearchMatchBarVisible(false);
 914          }
 915  
 916          // Temporarily remove the text watcher as we process checklists to prevent callback looping
 917          mContentEditText.removeTextChangedListener(this);
 918          mContentEditText.processChecklists();
 919          mContentEditText.addTextChangedListener(this);
 920      }
 921  
 922      /**
 923       * Set the note title to be a larger size and bold style.
 924       *
 925       * Remove all existing spans before applying spans or performance issues will occur.  Since both
 926       * {@link RelativeSizeSpan} and {@link StyleSpan} inherit from {@link MetricAffectingSpan}, all
 927       * spans are removed when {@link MetricAffectingSpan} is removed.
 928       */
 929      private void setTitleSpan(Editable editable) {
 930          for (MetricAffectingSpan span : editable.getSpans(0, editable.length(), MetricAffectingSpan.class)) {
 931              if (span instanceof RelativeSizeSpan || span instanceof StyleSpan) {
 932                  editable.removeSpan(span);
 933              }
 934          }
 935  
 936          int newLinePosition = getNoteContentString().indexOf(&quot;\n&quot;);
 937  
 938          if (newLinePosition == 0) {
 939              return;
 940          }
 941  
 942          int titleEndPosition = (newLinePosition &gt; 0) ? newLinePosition : editable.length();
 943          editable.setSpan(new RelativeSizeSpan(1.3f), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
 944          editable.setSpan(new StyleSpan(Typeface.BOLD), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
 945      }
 946  
 947      private void attemptAutoList(Editable editable) {
 948          int oldCursorPosition = mCurrentCursorPosition;
 949          mCurrentCursorPosition = mContentEditText.getSelectionStart();
 950          AutoBullet.apply(editable, oldCursorPosition, mCurrentCursorPosition);
 951          mCurrentCursorPosition = mContentEditText.getSelectionStart();
 952      }
 953  
 954      private void saveAndSyncNote() {
 955          if (mNote == null) {
 956              return;
 957          }
 958  
 959          new SaveNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);








 960      }
 961  
 962      public void setPlaceholderVisible(boolean isVisible) {
 963          if (isVisible) {
 964              mNote = null;
 965              mContentEditText.setText(&quot;&quot;);
 966          }
 967  
 968          if (mPlaceholderView != null) {
 969              mPlaceholderView.setVisibility(isVisible ? View.VISIBLE : View.GONE);
 970          }
 971      }
 972  
 973      @Override
 974      public void onFocusChange(View v, boolean hasFocus) {
 975          if (!hasFocus) {
 976              String tags = getNoteTagsString().trim();
 977  
 978              if (mTagInput.getText().toString().trim().length() &gt; 0) {
 979                  onTagAdded(mTagInput.getText().toString());
 980              } else if (tags.length() &gt; 0) {
 981                  setChips(tags);
 982              }
 983          }
 984      }
 985  
 986      private Note getNote() {
 987          return mNote;
 988      }
 989  
 990      public void setNote(String noteID) {
 991          setNote(noteID, null);
 992      }
 993  
 994      private String getNoteContentString() {
 995          if (mContentEditText == null || mContentEditText.getText() == null) {
 996              return &quot;&quot;;
 997          } else {
 998              return mContentEditText.getText().toString();
 999          }
1000      }
1001  
1002      private String getNoteTagsString() {
1003          StringBuilder tags = new StringBuilder();
1004  
1005          for (int i= 0; i &lt; mTagChips.getChildCount(); i++) {
1006              tags.append(((Chip) mTagChips.getChildAt(i)).getText()).append(&quot; &quot;);
1007          }
1008  
1009          return tags.toString();
1010      }
1011  
1012      /**
1013       * Share bottom sheet callbacks
1014       */
1015  
1016      @Override
1017      public void onSharePublishClicked() {
1018          publishNote();
1019          if (mShareBottomSheet != null) {
1020              mShareBottomSheet.dismiss();
1021          }
1022      }
1023  
1024      @Override
1025      public void onShareUnpublishClicked() {
1026          unpublishNote();
1027          if (mShareBottomSheet != null) {
1028              mShareBottomSheet.dismiss();
1029          }
1030      }
1031  
1032      @Override
1033      public void onWordPressPostClicked() {
1034          if (mShareBottomSheet != null) {
1035              mShareBottomSheet.dismiss();
1036          }
1037  
1038          if (getFragmentManager() == null) {
1039              return;
1040          }
1041  
1042          FragmentTransaction ft = getFragmentManager().beginTransaction();
1043          Fragment prev = getFragmentManager().findFragmentByTag(WordPressDialogFragment.DIALOG_TAG);
1044          if (prev != null) {
1045              ft.remove(prev);
1046          }
1047          ft.addToBackStack(null);
1048  
1049          // Create and show the dialog.
1050          WordPressDialogFragment wpDialogFragment = new WordPressDialogFragment();
1051          wpDialogFragment.setNote(mNote);
1052          wpDialogFragment.show(ft, WordPressDialogFragment.DIALOG_TAG);
1053      }
1054  
1055      @Override
1056      public void onShareCollaborateClicked() {
1057          Toast.makeText(getActivity(), R.string.collaborate_message, Toast.LENGTH_LONG).show();
1058      }
1059  
1060      @Override
1061      public void onShareDismissed() {
1062  
1063      }
1064  
1065      /**
1066       * History bottom sheet listeners
1067       */
1068  
1069      @Override
1070      public void onHistoryCancelClicked() {
1071          mContentEditText.setText(mNote.getContent());
1072          if (mHistoryBottomSheet != null) {
1073              mHistoryBottomSheet.dismiss();
1074          }
1075      }
1076  
1077      @Override
1078      public void onHistoryRestoreClicked() {
1079          if (mHistoryBottomSheet != null) {
1080              mHistoryBottomSheet.dismiss();
1081          }
1082          saveAndSyncNote();
1083      }
1084  
1085      @Override
1086      public void onHistoryDismissed() {
1087          if (!mHistoryBottomSheet.didTapOnButton()) {
1088              mContentEditText.setText(mNote.getContent());
1089          }
1090  
1091          if (mHistoryTimeoutHandler != null) {
1092              mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
1093          }
1094      }
1095  
1096      @Override
1097      public void onHistoryUpdateNote(String content) {
1098          mContentEditText.setText(content);
1099      }
1100  
1101      protected void saveNote() {
1102          try {
1103              if (mNote == null || mNotesBucket == null || mContentEditText == null || mIsLoadingNote ||
<abbr title="1104                  (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing())) {">1104                  (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getðŸ”µ</abbr>
1105                  return;
1106              } else {
1107                  mNote = mNotesBucket.get(mNote.getSimperiumKey());
1108                  mIsPreviewEnabled = mNote.isPreviewEnabled();
1109              }
1110  
1111              String content = mContentEditText.getPlainTextContent();
1112              String tagString = getNoteTagsString();
1113  
<abbr title="1114              if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnabled)) {">1114              if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnableðŸ”µ</abbr>
1115                  mNote.setContent(content);
1116                  mNote.setTagString(tagString);
1117                  mNote.setModificationDate(Calendar.getInstance());
1118                  mNote.setMarkdownEnabled(mIsMarkdownEnabled);
1119                  mNote.setPreviewEnabled(mIsPreviewEnabled);
1120                  mNote.save();
1121  
1122                  AnalyticsTracker.track(
1123                      EDITOR_NOTE_EDITED,
1124                      CATEGORY_NOTE,
1125                      &quot;editor_save&quot;
1126                  );
1127              }
1128          } catch (BucketObjectMissingException exception) {
1129              exception.printStackTrace();
1130          }
1131      }
1132  
1133      // Checks if cursor is at a URL when the selection changes
1134      // If it is a URL, show the contextual action bar
1135      @Override
1136      public void onSelectionChanged(int selStart, int selEnd) {
1137          mCurrentCursorPosition = selEnd;
1138          if (selStart == selEnd) {
1139              Editable noteContent = mContentEditText.getText();
1140              if (noteContent == null)
1141                  return;
1142  
1143              URLSpan[] urlSpans = noteContent.getSpans(selStart, selStart, URLSpan.class);
1144              if (urlSpans.length &gt; 0) {
1145                  URLSpan urlSpan = urlSpans[0];
1146                  mLinkUrl = urlSpan.getURL();
<abbr title="1147                  mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSpan)).toString();">1147                  mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSðŸ”µ</abbr>
1148                  if (mActionMode != null) {
1149                      mActionMode.setSubtitle(mLinkText);
1150                      updateMenuItems();
1151                      return;
1152                  }
1153  
1154                  // Show the Contextual Action Bar
1155                  if (getActivity() != null) {
1156                      mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCallback);
1157                      if (mActionMode != null) {
1158                          mActionMode.setSubtitle(mLinkText);
1159                      }
1160  
1161                      updateMenuItems();
1162                  }
1163              } else if (mActionMode != null) {
1164                  mActionMode.finish();
1165                  mActionMode = null;
1166              }
1167          } else if (mActionMode != null) {
1168              mActionMode.finish();
1169              mActionMode = null;
1170          }
1171      }
1172  
1173      private void updateMenuItems() {
1174          mCopyMenuItem.setIcon(mCopyIcon);
1175          mShareMenuItem.setIcon(mShareIcon);
1176  
1177          if (mViewLinkMenuItem != null &amp;&amp; mLinkUrl != null) {
1178              if (mLinkUrl.startsWith(&quot;tel:&quot;)) {
1179                  mViewLinkMenuItem.setIcon(mCallIcon);
1180                  mViewLinkMenuItem.setTitle(getString(R.string.call));
1181              } else if (mLinkUrl.startsWith(&quot;mailto:&quot;)) {
1182                  mViewLinkMenuItem.setIcon(mEmailIcon);
1183                  mViewLinkMenuItem.setTitle(getString(R.string.email));
1184              } else if (mLinkUrl.startsWith(&quot;geo:&quot;)) {
1185                  mViewLinkMenuItem.setIcon(mMapIcon);
1186                  mViewLinkMenuItem.setTitle(getString(R.string.view_map));
1187              } else {
1188                  mViewLinkMenuItem.setIcon(mBrowserIcon);
1189                  mViewLinkMenuItem.setTitle(getString(R.string.view_in_browser));
1190              }
1191          }
1192      }
1193  
1194      private void setPublishedNote(boolean isPublished) {
1195          if (mNote != null) {
1196              mNote.setPublished(isPublished);
1197              mNote.save();
1198  
1199              // reset publish status in 20 seconds if we don&#x27;t hear back from Simperium
1200              mPublishTimeoutHandler.postDelayed(mPublishTimeoutRunnable, PUBLISH_TIMEOUT);
1201  
1202              AnalyticsTracker.track(
1203                  isPublished ? EDITOR_NOTE_PUBLISHED : EDITOR_NOTE_UNPUBLISHED,
1204                  CATEGORY_NOTE,
1205                  &quot;publish_note_button&quot;
1206              );
1207          }
1208      }
1209  
1210      private void updatePublishedState(boolean isSuccess) {
1211          if (mPublishingSnackbar == null) {
1212              return;
1213          }
1214  
1215          mPublishingSnackbar.dismiss();
1216          mPublishingSnackbar = null;
1217  
1218          if (isSuccess &amp;&amp; isAdded()) {
1219              if (mNote.isPublished()) {
1220                  if (mHideActionOnSuccess) {
1221                      Snackbar.make(mRootView, R.string.publish_successful, Snackbar.LENGTH_LONG)
1222                              .show();
1223                  } else {
1224                      Snackbar.make(mRootView, R.string.publish_successful, Snackbar.LENGTH_LONG)
1225                              .setAction(
1226                                  R.string.undo,
1227                                  new View.OnClickListener() {
1228                                      @Override
1229                                      public void onClick(View v) {
1230                                          mHideActionOnSuccess = true;
1231                                          unpublishNote();
1232                                      }
1233                                  }
1234                              )
1235                              .show();
1236                  }
1237  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1238 -                copyToClipboard(mNote.getPublishedUrl());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1239 +                BrowserUtils.copyToClipboard(requireContext(), mNote.getPublishedUrl());</span>
1240              } else {
1241                  if (mHideActionOnSuccess) {
1242                      Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG)
1243                              .show();
1244                  } else {
1245                      Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG)
1246                              .setAction(
1247                                  R.string.undo,
1248                                  new View.OnClickListener() {
1249                                      @Override
1250                                      public void onClick(View v) {
1251                                          mHideActionOnSuccess = true;
1252                                          publishNote();
1253                                      }
1254                                  }
1255                              )
1256                              .show();
1257                  }
1258              }
1259          } else {
1260              if (mNote.isPublished()) {
1261                  Snackbar.make(mRootView, R.string.unpublish_error, Snackbar.LENGTH_LONG)
1262                          .setAction(
1263                              R.string.retry,
1264                              new View.OnClickListener() {
1265                                  @Override
1266                                  public void onClick(View v) {
1267                                      mHideActionOnSuccess = true;
1268                                      unpublishNote();
1269                                  }
1270                              }
1271                          ).show();
1272              } else {
1273                  Snackbar.make(mRootView, R.string.publish_error, Snackbar.LENGTH_LONG)
1274                          .setAction(
1275                              R.string.retry,
1276                              new View.OnClickListener() {
1277                                  @Override
1278                                  public void onClick(View v) {
1279                                      mHideActionOnSuccess = true;
1280                                      publishNote();
1281                                  }
1282                              }
1283                          ).show();
1284              }
1285          }
1286  
1287          mHideActionOnSuccess = false;
1288          requireActivity().invalidateOptionsMenu();
1289      }
1290  
1291      private void publishNote() {
1292          if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1293              Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1294              return;
1295          }
1296  
1297          if (isAdded()) {
1298              mPublishingSnackbar = Snackbar.make(mRootView, R.string.publishing, Snackbar.LENGTH_INDEFINITE);
1299              mPublishingSnackbar.show();
1300          }
1301  
1302          setPublishedNote(true);
1303      }
1304  
1305      private void unpublishNote() {
1306          if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1307              Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1308              return;
1309          }
1310  
1311          if (isAdded()) {
1312              mPublishingSnackbar = Snackbar.make(mRootView, R.string.unpublishing, Snackbar.LENGTH_INDEFINITE);
1313              mPublishingSnackbar.show();
1314          }
1315  
1316          setPublishedNote(false);
1317      }
1318  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1319 -    private void copyToClipboard(String text) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1320 -        ClipboardManager clipboard = (ClipboardManager) requireActivity()</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1321 -                .getSystemService(Context.CLIPBOARD_SERVICE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1322 -        ClipData clip = ClipData.newPlainText(getString(R.string.app_name), text);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1323 -        if (clipboard != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1324 -            clipboard.setPrimaryClip(clip);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1325 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1326 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1327 -</span>









1328      private void showShareSheet() {
1329          if (isAdded() &amp;&amp; mShareBottomSheet != null &amp;&amp; !mShareBottomSheet.isAdded()) {
1330              mShareBottomSheet.show(requireFragmentManager(), mNote);
1331          }
1332      }
1333  
1334      private void showInfoSheet() {
1335          if (isAdded() &amp;&amp; mInfoBottomSheet != null &amp;&amp; !mInfoBottomSheet.isAdded()) {
1336              mInfoBottomSheet.show(requireFragmentManager(), mNote);
1337          }
1338      }
1339  
1340      private void showHistorySheet() {
1341          if (isAdded() &amp;&amp; mHistoryBottomSheet != null &amp;&amp; !mHistoryBottomSheet.isAdded()) {
1342              // Request revisions for the current note
1343              mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbacks());
1344              saveNote();
1345  
1346              mHistoryBottomSheet.show(requireFragmentManager(), mNote);
1347          }
1348      }
1349  
1350      /**
1351       * Simperium listeners
1352       */
1353  
1354      @Override
1355      public void onDeleteObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1356  
1357      }
1358  
1359      @Override
1360      public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) {
1361          if (changeType == Bucket.ChangeType.MODIFY) {
1362              if (getNote() != null &amp;&amp; getNote().getSimperiumKey().equals(key)) {
1363                  try {
1364                      final Note updatedNote = mNotesBucket.get(key);
1365                      if (getActivity() != null) {
1366                          getActivity().runOnUiThread(new Runnable() {
1367                              @Override
1368                              public void run() {
1369                                  if (mPublishTimeoutHandler != null) {
1370                                      mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
1371                                  }
1372  
1373                                  updateNote(updatedNote);
1374                                  updatePublishedState(true);
1375                              }
1376                          });
1377                      }
1378                  } catch (BucketObjectMissingException e) {
1379                      e.printStackTrace();
1380                  }
1381              }
1382          }
1383      }
1384  
1385      @Override
1386      public void onSaveObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1387          if (mIsPaused) {
1388              mNotesBucket.removeListener(this);
1389              mNotesBucket.stop();
1390          }
1391      }
1392  
1393      @Override
1394      public void onBeforeUpdateObject(Bucket&lt;Note&gt; bucket, Note note) {
1395          // Don&#x27;t apply updates if we haven&#x27;t loaded the note yet
1396          if (mIsLoadingNote)
1397              return;
1398  
1399          Note openNote = getNote();
1400          if (openNote == null || !openNote.getSimperiumKey().equals(note.getSimperiumKey()))
1401              return;
1402  
1403          note.setContent(mContentEditText.getPlainTextContent());
1404      }
1405  
1406      private static class LoadNoteTask extends AsyncTask&lt;String, Void, Void&gt; {
1407          WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1408  
1409          LoadNoteTask(NoteEditorFragment fragment) {
1410              mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1411          }
1412  
1413          @Override
1414          protected void onPreExecute() {
1415              NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1416  
1417              if (fragment != null) {
1418                  fragment.mContentEditText.removeTextChangedListener(fragment);
1419                  fragment.mIsLoadingNote = true;
1420              }
1421          }
1422  
1423          @Override
1424          protected Void doInBackground(String... args) {
1425              NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1426  
1427              if (fragment == null || fragment.getActivity() == null) {
1428                  return null;
1429              }
1430  
1431              String noteID = args[0];
1432              Simplenote application = (Simplenote) fragment.getActivity().getApplication();
1433              Bucket&lt;Note&gt; notesBucket = application.getNotesBucket();
1434  
1435              try {
1436                  fragment.mNote = notesBucket.get(noteID);
1437  
1438                  // Set the current note in NotesActivity when on a tablet
1439                  if (fragment.getActivity() instanceof NotesActivity) {
1440                      ((NotesActivity) fragment.getActivity()).setCurrentNote(fragment.mNote);
1441                  }
1442  
1443                  // Set markdown and preview flags for current note
1444                  if (fragment.mNote != null) {
1445                      fragment.mIsMarkdownEnabled = fragment.mNote.isMarkdownEnabled();
1446                      fragment.mIsPreviewEnabled = fragment.mNote.isPreviewEnabled();
1447                  }
1448              } catch (BucketObjectMissingException e) {
1449                  // See if the note is in the object store
1450                  Bucket.ObjectCursor&lt;Note&gt; notesCursor = notesBucket.allObjects();
1451  
1452                  while (notesCursor.moveToNext()) {
1453                      Note currentNote = notesCursor.getObject();
1454  
1455                      if (currentNote != null &amp;&amp; currentNote.getSimperiumKey().equals(noteID)) {
1456                          fragment.mNote = currentNote;
1457                          return null;
1458                      }
1459                  }
1460              }
1461  
1462              return null;
1463          }
1464  
1465          @Override
1466          protected void onPostExecute(Void nada) {
1467              final NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1468              if (fragment == null || fragment.getActivity() == null || fragment.getActivity().isFinishing()) {
1469                  return;
1470              }
1471  
1472              fragment.refreshContent(false);
1473  
1474              if (fragment.mMatchOffsets != null) {
<abbr title="1475                  int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.CONTENT_PROPERTY);">1475                  int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.COðŸ”µ</abbr>
1476                  fragment.mHighlighter.highlightMatches(fragment.mMatchOffsets, columnIndex);
1477                  fragment.mShouldScrollToSearchMatch = true;
1478              }
1479  
1480              fragment.mContentEditText.addTextChangedListener(fragment);
1481  
1482              if (fragment.mNote != null &amp;&amp; fragment.mNote.getContent().isEmpty()) {
1483                  // Show soft keyboard
1484                  fragment.mContentEditText.requestFocus();
1485  
1486                  new Handler().postDelayed(new Runnable() {
1487                      @Override
1488                      public void run() {
1489                          if (fragment.getActivity() == null) {
1490                              return;
1491                          }
1492  
<abbr title="1493                          InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);">1493                          InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivity().getSysðŸ”µ</abbr>
1494  
1495                          if (inputMethodManager != null) {
1496                              inputMethodManager.showSoftInput(fragment.mContentEditText, 0);
1497                          }
1498                      }
1499                  }, 100);
1500              } else if (fragment.mNote != null) {
1501                  // If we have a valid note, hide the placeholder
1502                  fragment.setPlaceholderVisible(false);
1503              }
1504  
1505              fragment.updateMarkdownView();
1506              fragment.requireActivity().invalidateOptionsMenu();
1507              fragment.linkifyEditorContent();
1508              fragment.mIsLoadingNote = false;
1509          }
1510      }
1511  
1512      private static class SaveNoteTask extends AsyncTask&lt;Void, Void, Void&gt; {
1513          WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1514  
1515          SaveNoteTask(NoteEditorFragment fragment) {
1516              mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1517          }
1518  
1519          @Override
1520          protected Void doInBackground(Void... args) {
1521              NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1522  
1523              if (fragment != null) {
1524                  fragment.saveNote();
1525              }
1526  
1527              return null;
1528          }
1529  
1530          @Override
1531          protected void onPostExecute(Void nada) {
1532              NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1533  
1534              if (fragment != null &amp;&amp; fragment.getActivity() != null &amp;&amp; !fragment.getActivity().isFinishing()) {
1535                  // Update links
1536                  fragment.linkifyEditorContent();
1537                  fragment.updateMarkdownView();
1538              }
1539          }
1540      }
1541  
1542      private void linkifyEditorContent() {
1543          if (getActivity() == null || getActivity().isFinishing()) {
1544              return;
1545          }
1546  
1547          if (PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_DETECT_LINKS)) {
1548              SimplenoteLinkify.addLinks(mContentEditText, Linkify.ALL);
1549          }
1550      }
1551  
1552      // Show tabs if markdown is enabled globally, for current note, and not tablet landscape
1553      private void updateMarkdownView() {
1554          if (!mIsMarkdownEnabled) {
1555              return;
1556          }
1557  
1558          Activity activity = getActivity();
1559          if (activity instanceof NotesActivity) {
1560              // This fragment lives in NotesActivity, so load markdown in this fragment&#x27;s WebView.
1561              loadMarkdownData();
1562          } else {
1563              // This fragment lives in the NoteEditorActivity&#x27;s ViewPager.
1564              if (mNoteMarkdownFragment == null) {
1565                  mNoteMarkdownFragment = ((NoteEditorActivity) requireActivity())
1566                          .getNoteMarkdownFragment();
1567                  ((NoteEditorActivity) requireActivity()).showTabs();
1568              }
1569              // Load markdown in the sibling NoteMarkdownFragment&#x27;s WebView.
1570              mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPlainTextContent());
1571          }
1572      }
1573  
1574      private ColorStateList getChipBackgroundColor() {
1575          int[][] states = new int[][] {
1576              new int[] { android.R.attr.state_checked}, // checked
1577              new int[] {-android.R.attr.state_checked}  // unchecked
1578          };
1579  
1580          int[] colors = new int[] {
1581              ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOnBackgroundColor),
1582              ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOffBackgroundColor)
1583          };
1584  
1585          return new ColorStateList(states, colors);
1586      }
1587  
1588      private void setChips(CharSequence text) {
1589          mTagPadding.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1590          mTagChips.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1591          mTagChips.setSingleSelection(true);
1592          mTagChips.removeAllViews();
1593          SimpleStringSplitter tags = new SimpleStringSplitter(SPACE);
1594          tags.setString(text.toString());
1595  
1596          for (String tag : tags) {
1597              final Chip chip = new Chip(requireContext());
1598              chip.setText(tag);
1599              chip.setCheckable(true);
1600              chip.setCheckedIcon(null);
1601              chip.setChipBackgroundColor(getChipBackgroundColor());
1602              chip.setTextColor(ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipTextColor));
1603              chip.setStateListAnimator(null);
1604              chip.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
1605                  @Override
1606                  public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
1607                      chip.setCloseIconVisible(isChecked);
1608                  }
1609              });
1610              chip.setOnCloseIconClickListener(new View.OnClickListener() {
1611                  @Override
1612                  public void onClick(View view) {
1613                      mTagChips.removeView(view);
1614                      updateTags();
1615                      AnalyticsTracker.track(
1616                          EDITOR_TAG_REMOVED,
1617                          CATEGORY_NOTE,
1618                          &quot;tag_removed_from_note&quot;
1619                      );
1620                  }
1621              });
1622              mTagChips.addView(chip);
1623          }
1624      }
1625  
1626      private void updateTags() {
1627          if (mNote == null) {
1628              return;
1629          }
1630  
1631          mNote.setTagString(getNoteTagsString());
1632          mNote.setModificationDate(Calendar.getInstance());
1633          updateTagList();
1634          mNote.save();
1635      }
1636  }</pre></td>
                            <td><pre>   1  package com.automattic.simplenote;
   2  
   3  import android.app.Activity;
   4  import android.content.ClipData;
   5  import android.content.ClipboardManager;
   6  import android.content.Context;
   7  import android.content.Intent;
   8  import android.content.SharedPreferences;
   9  import android.content.res.ColorStateList;
  10  import android.database.Cursor;
  11  import android.graphics.Typeface;
  12  import android.graphics.drawable.Drawable;
  13  import android.net.Uri;
  14  import android.os.AsyncTask;
  15  import android.os.Bundle;
  16  import android.os.Handler;
  17  import android.text.Editable;
  18  import android.text.Layout;
  19  import android.text.Spanned;
  20  import android.text.TextUtils.SimpleStringSplitter;
  21  import android.text.TextWatcher;
  22  import android.text.style.MetricAffectingSpan;
  23  import android.text.style.RelativeSizeSpan;
  24  import android.text.style.StyleSpan;
  25  import android.text.style.URLSpan;
  26  import android.text.util.Linkify;
  27  import android.util.TypedValue;
  28  import android.view.LayoutInflater;
  29  import android.view.Menu;
  30  import android.view.MenuInflater;
  31  import android.view.MenuItem;
  32  import android.view.View;
  33  import android.view.ViewGroup;
  34  import android.view.ViewTreeObserver;
  35  import android.view.inputmethod.InputMethodManager;
  36  import android.webkit.WebView;
  37  import android.widget.CompoundButton;
  38  import android.widget.CursorAdapter;
  39  import android.widget.LinearLayout;
  40  import android.widget.TextView;
  41  import android.widget.Toast;
  42  
  43  import androidx.annotation.NonNull;
  44  import androidx.appcompat.app.AppCompatActivity;
  45  import androidx.appcompat.view.ActionMode;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  46 +import androidx.core.app.ShareCompat;</span>
  47  import androidx.core.view.MenuCompat;
  48  import androidx.core.widget.NestedScrollView;
  49  import androidx.fragment.app.Fragment;
  50  import androidx.fragment.app.FragmentTransaction;
  51  import androidx.preference.PreferenceManager;
  52  
  53  import com.automattic.simplenote.analytics.AnalyticsTracker;
  54  import com.automattic.simplenote.models.Note;
  55  import com.automattic.simplenote.models.Tag;
  56  import com.automattic.simplenote.utils.AutoBullet;

  57  import com.automattic.simplenote.utils.ContextUtils;
  58  import com.automattic.simplenote.utils.DisplayUtils;
  59  import com.automattic.simplenote.utils.DrawableUtils;
  60  import com.automattic.simplenote.utils.MatchOffsetHighlighter;
  61  import com.automattic.simplenote.utils.NetworkUtils;
  62  import com.automattic.simplenote.utils.NoteUtils;
  63  import com.automattic.simplenote.utils.PrefUtils;
  64  import com.automattic.simplenote.utils.SimplenoteLinkify;
  65  import com.automattic.simplenote.utils.SimplenoteMovementMethod;
  66  import com.automattic.simplenote.utils.SpaceTokenizer;
  67  import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;
  68  import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;
  69  import com.automattic.simplenote.utils.TextHighlighter;
  70  import com.automattic.simplenote.utils.ThemeUtils;
  71  import com.automattic.simplenote.utils.WidgetUtils;
  72  import com.automattic.simplenote.widgets.SimplenoteEditText;
  73  import com.google.android.material.chip.Chip;
  74  import com.google.android.material.chip.ChipGroup;
  75  import com.google.android.material.snackbar.Snackbar;
  76  import com.simperium.client.Bucket;
  77  import com.simperium.client.BucketObjectMissingException;
  78  import com.simperium.client.Query;
  79  
  80  import java.lang.ref.WeakReference;
  81  import java.util.Calendar;
  82  
  83  import static com.automattic.simplenote.analytics.AnalyticsTracker.CATEGORY_NOTE;
  84  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_CHECKLIST_INSERTED;
  85  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_CONTENT_SHARED;
  86  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_EDITED;
  87  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_PUBLISHED;
  88  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_UNPUBLISHED;
  89  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_ADDED;
  90  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_REMOVED;
  91  import static com.automattic.simplenote.utils.SearchTokenizer.SPACE;
  92  
  93  public class NoteEditorFragment extends Fragment implements Bucket.Listener&lt;Note&gt;,
  94          TextWatcher, OnTagAddedListener, View.OnFocusChangeListener,
  95          SimplenoteEditText.OnSelectionChangedListener,
  96          ShareBottomSheetDialog.ShareSheetListener,
  97          HistoryBottomSheetDialog.HistorySheetListener,
  98          SimplenoteEditText.OnCheckboxToggledListener {
  99  
 100      public static final String ARG_IS_FROM_WIDGET = &quot;is_from_widget&quot;;
 101      public static final String ARG_ITEM_ID = &quot;item_id&quot;;
 102      public static final String ARG_NEW_NOTE = &quot;new_note&quot;;
 103      public static final String ARG_MATCH_OFFSETS = &quot;match_offsets&quot;;
 104      public static final String ARG_MARKDOWN_ENABLED = &quot;markdown_enabled&quot;;
 105      public static final String ARG_PREVIEW_ENABLED = &quot;preview_enabled&quot;;
 106      private static final String STATE_NOTE_ID = &quot;state_note_id&quot;;
 107      private static final int AUTOSAVE_DELAY_MILLIS = 2000;
 108      private static final int MAX_REVISIONS = 30;
 109      private static final int PUBLISH_TIMEOUT = 20000;
 110      private static final int HISTORY_TIMEOUT = 10000;
 111      private Note mNote;
 112      private final Runnable mAutoSaveRunnable = new Runnable() {
 113          @Override
 114          public void run() {
 115              saveAndSyncNote();
 116          }
 117      };
 118      private Bucket&lt;Note&gt; mNotesBucket;
 119      private View mRootView;
 120      private View mTagPadding;
 121      private SimplenoteEditText mContentEditText;
 122      private ChipGroup mTagChips;
 123      private TagsMultiAutoCompleteTextView mTagInput;
 124      private Handler mAutoSaveHandler;
 125      private Handler mPublishTimeoutHandler;
 126      private Handler mHistoryTimeoutHandler;
 127      private LinearLayout mPlaceholderView;
 128      private CursorAdapter mAutocompleteAdapter;
 129      private boolean mIsLoadingNote;
 130      private boolean mIsMarkdownEnabled;
 131      private boolean mIsPreviewEnabled;
 132      private boolean mShouldScrollToSearchMatch;
 133      private ActionMode mActionMode;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 134 +    private MenuItem mChecklistMenuItem;</span>
 135      private MenuItem mCopyMenuItem;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 136 +    private MenuItem mInformationMenuItem;</span>
 137      private MenuItem mShareMenuItem;
 138      private MenuItem mViewLinkMenuItem;
 139      private String mLinkUrl;
 140      private String mLinkText;
 141      private MatchOffsetHighlighter mHighlighter;
 142      private Drawable mCallIcon;
 143      private Drawable mCopyIcon;
 144      private Drawable mEmailIcon;
 145      private Drawable mMapIcon;
 146      private Drawable mShareIcon;
 147      private Drawable mBrowserIcon;
 148      private MatchOffsetHighlighter.SpanFactory mMatchHighlighter;
 149      private String mMatchOffsets;
 150      private int mCurrentCursorPosition;
 151      private HistoryBottomSheetDialog mHistoryBottomSheet;
 152      private boolean mIsPaused;
 153      private boolean mIsFromWidget;
 154  
 155      // Hides the history bottom sheet if no revisions are loaded
 156      private final Runnable mHistoryTimeoutRunnable = new Runnable() {
 157          @Override
 158          public void run() {
 159              if (!isAdded()) {
 160                  return;
 161              }
 162  
 163              requireActivity().runOnUiThread(new Runnable() {
 164                  @Override
 165                  public void run() {
<abbr title=" 166                      if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; !mHistoryBottomSheet.isHistoryLoaded()) {"> 166                      if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; ðŸ”µ</abbr>
 167                          mHistoryBottomSheet.dismiss();
 168                          Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 169                      }
 170                  }
 171              });
 172          }
 173      };
 174      private InfoBottomSheetDialog mInfoBottomSheet;
 175      private ShareBottomSheetDialog mShareBottomSheet;
 176      // Contextual action bar for dealing with links
 177      private final ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
 178          // Called when the action mode is created; startActionMode() was called
 179          @Override
 180          public boolean onCreateActionMode(ActionMode mode, Menu menu) {
 181              // Inflate a menu resource providing context menu items
 182              MenuInflater inflater = mode.getMenuInflater();
 183  
 184              if (inflater != null) {
 185                  inflater.inflate(R.menu.view_link, menu);
 186                  mCopyMenuItem = menu.findItem(R.id.menu_copy);
 187                  mShareMenuItem = menu.findItem(R.id.menu_share);
 188                  mViewLinkMenuItem = menu.findItem(R.id.menu_view_link);
 189                  mode.setTitle(getString(R.string.link));
 190                  mode.setTitleOptionalHint(false);
 191  
 192                  DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 193              }
 194  
<abbr title=" 195              int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.background_dark;"> 195              int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.backgrðŸ”µ</abbr>
<abbr title=" 196              requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().getTheme()));"> 196              requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().ðŸ”µ</abbr>
 197              return true;
 198          }
 199  
 200          // Called each time the action mode is shown. Always called after onCreateActionMode, but
 201          // may be called multiple times if the mode is invalidated.
 202          @Override
 203          public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 204              return false; // Return false if nothing is done
 205          }
 206  
 207          // Called when the user selects a contextual menu item
 208          @Override
 209          public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 210              switch (item.getItemId()) {
 211                  case R.id.menu_view_link:
 212                      if (mLinkUrl != null) {
 213                          try {
 214                              Uri uri = Uri.parse(mLinkUrl);
 215                              Intent i = new Intent(Intent.ACTION_VIEW);
 216                              i.setData(uri);
 217                              startActivity(i);

 218                          } catch (Exception e) {
 219                              e.printStackTrace();
 220                          }

 221                          mode.finish(); // Action picked, so close the CAB
 222                      }
 223                      return true;
 224                  case R.id.menu_copy:
 225                      if (mLinkText != null &amp;&amp; getActivity() != null) {
 226                          copyToClipboard(mLinkText);

 227                          Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 228                          mode.finish();
 229                      }
 230                      return true;
 231                  case R.id.menu_share:
 232                      if (mLinkText != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 233 -                        showShareSheet();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 234 +                        showShare(mLinkText);</span>
 235                          mode.finish();
 236                      }
 237                      return true;
 238                  default:
 239                      return false;
 240              }
 241          }
 242  
 243          // Called when the user exits the action mode
 244          @Override
 245          public void onDestroyActionMode(ActionMode mode) {
 246              mActionMode = null;
 247              new Handler().postDelayed(
 248                  new Runnable() {
 249                      @Override
 250                      public void run() {
<abbr title=" 251                          requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 251                          requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.trðŸ”µ</abbr>
 252                      }
 253                  },
 254                  requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime)
 255              );
 256          }
 257      };
 258      private Snackbar mPublishingSnackbar;
 259      private boolean mHideActionOnSuccess;
 260      // Resets note publish status if Simperium never returned the new publish status
 261      private final Runnable mPublishTimeoutRunnable = new Runnable() {
 262          @Override
 263          public void run() {
 264              if (!isAdded()) return;
 265  
 266              requireActivity().runOnUiThread(new Runnable() {
 267                  @Override
 268                  public void run() {
 269  
 270                      mNote.setPublished(!mNote.isPublished());
 271                      mNote.save();
 272  
 273                      updatePublishedState(false);
 274                  }
 275              });
 276          }
 277      };
 278      private NoteMarkdownFragment mNoteMarkdownFragment;
 279      private String mCss;
 280      private WebView mMarkdown;
 281  
 282      /**
 283       * Mandatory empty constructor for the fragment manager to instantiate the
 284       * fragment (e.g. upon screen orientation changes).
 285       */
 286      public NoteEditorFragment() {
 287      }
 288  
 289      @Override
 290      public void onCreate(Bundle savedInstanceState) {
 291          super.onCreate(savedInstanceState);
 292          mInfoBottomSheet = new InfoBottomSheetDialog(this);
 293          mShareBottomSheet = new ShareBottomSheetDialog(this, this);
 294          mHistoryBottomSheet = new HistoryBottomSheetDialog(this, this);
 295  
 296          Simplenote currentApp = (Simplenote) requireActivity().getApplication();
 297          mNotesBucket = currentApp.getNotesBucket();
 298  
<abbr title=" 299          mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.actionModeTextColor);"> 299          mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.aðŸ”µ</abbr>
<abbr title=" 300          mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.attr.actionModeTextColor);"> 300          mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.attr.actioðŸ”µ</abbr>
<abbr title=" 301          mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.actionModeTextColor);"> 301          mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.actionModðŸ”µ</abbr>
<abbr title=" 302          mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp, R.attr.actionModeTextColor);"> 302          mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp, R.attr.aðŸ”µ</abbr>
<abbr title=" 303          mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attr.actionModeTextColor);"> 303          mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attr.actionMðŸ”µ</abbr>
<abbr title=" 304          mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.attr.actionModeTextColor);"> 304          mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.attr.actioðŸ”µ</abbr>
 305  
 306          mAutoSaveHandler = new Handler();
 307          mPublishTimeoutHandler = new Handler();
 308          mHistoryTimeoutHandler = new Handler();
 309  
 310          mMatchHighlighter = new TextHighlighter(requireActivity(),
 311                  R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor);
 312          mAutocompleteAdapter = new CursorAdapter(getActivity(), null, 0x0) {
 313              @Override
 314              public View newView(Context context, Cursor cursor, ViewGroup parent) {
 315                  Activity activity = (Activity) context;
 316                  if (activity == null) return null;
 317                  return activity.getLayoutInflater().inflate(R.layout.tag_autocomplete_list_item, null);
 318              }
 319  
 320              @Override
 321              public void bindView(View view, Context context, Cursor cursor) {
 322                  TextView textView = (TextView) view;
 323                  textView.setText(convertToString(cursor));
 324              }
 325  
 326              @Override
 327              public CharSequence convertToString(Cursor cursor) {
 328                  return cursor.getString(cursor.getColumnIndex(Tag.NAME_PROPERTY));
 329              }
 330  
 331              @Override
 332              public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 333                  Activity activity = getActivity();
 334                  if (activity == null) return null;
 335                  Simplenote application = (Simplenote) activity.getApplication();
 336                  Query&lt;Tag&gt; query = application.getTagsBucket().query();
 337                  // make the tag name available to the cursor
 338                  query.include(Tag.NAME_PROPERTY);
 339                  // sort the tags by their names
 340                  query.order(Tag.NAME_PROPERTY);
 341                  // if there&#x27;s a filter string find only matching tag names
 342                  if (filter != null)
 343                      query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filter));
 344                  return query.execute();
 345              }
 346          };
 347  
 348          WidgetUtils.updateNoteWidgets(requireActivity().getApplicationContext());
 349      }
 350  
 351      @Override
 352      public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
 353          mRootView = inflater.inflate(R.layout.fragment_note_editor, container, false);
 354          mContentEditText = mRootView.findViewById(R.id.note_content);
 355          mContentEditText.addOnSelectionChangedListener(this);
 356          mContentEditText.setOnCheckboxToggledListener(this);
 357          mContentEditText.setMovementMethod(SimplenoteMovementMethod.getInstance());
 358          mContentEditText.setOnFocusChangeListener(this);
 359          mTagInput = mRootView.findViewById(R.id.tag_input);
 360          mTagInput.setDropDownBackgroundResource(R.drawable.bg_list_popup);
 361          mTagInput.setTokenizer(new SpaceTokenizer());
 362          mTagInput.setOnFocusChangeListener(this);
 363          mTagChips = mRootView.findViewById(R.id.tag_chips);
 364          mTagPadding = mRootView.findViewById(R.id.tag_padding);
 365          mHighlighter = new MatchOffsetHighlighter(mMatchHighlighter, mContentEditText);
 366          mPlaceholderView = mRootView.findViewById(R.id.placeholder);
 367  
 368          if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote == null) {
 369              mPlaceholderView.setVisibility(View.VISIBLE);
 370              requireActivity().invalidateOptionsMenu();
 371              mMarkdown = mRootView.findViewById(R.id.markdown);
 372              mCss = ThemeUtils.isLightTheme(requireContext())
 373                      ? ContextUtils.readCssFile(requireContext(), &quot;light.css&quot;)
 374                      : ContextUtils.readCssFile(requireContext(), &quot;dark.css&quot;);
 375          }
 376  
 377          mTagInput.setAdapter(mAutocompleteAdapter);
 378          Bundle arguments = getArguments();
 379  
 380          if (arguments != null &amp;&amp; arguments.containsKey(ARG_ITEM_ID)) {
 381              // Load note if we were passed a note Id
 382              String key = arguments.getString(ARG_ITEM_ID);
 383  
 384              if (arguments.containsKey(ARG_MATCH_OFFSETS)) {
 385                  mMatchOffsets = arguments.getString(ARG_MATCH_OFFSETS);
 386              }
 387  
 388              mIsFromWidget = arguments.getBoolean(ARG_IS_FROM_WIDGET);
 389              new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, key);
 390          } else if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; savedInstanceState != null) {
 391              // Restore selected note when in dual pane mode
 392              String noteId = savedInstanceState.getString(STATE_NOTE_ID);
 393  
 394              if (noteId != null) {
 395                  setNote(noteId);
 396              }
 397          }
 398  
 399          ViewTreeObserver viewTreeObserver = mContentEditText.getViewTreeObserver();
 400          viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
 401              @Override
 402              public void onGlobalLayout() {
 403                  // If a note was loaded with search matches, scroll to the first match in the editor
 404                  if (mShouldScrollToSearchMatch &amp;&amp; mMatchOffsets != null) {
 405                      if (!isAdded()) {
 406                          return;
 407                      }
 408  
 409                      // Get the character location of the first search match
 410                      int matchLocation = MatchOffsetHighlighter.getFirstMatchLocation(
 411                              mContentEditText.getText(),
 412                              mMatchOffsets
 413                      );
 414                      if (matchLocation == 0) {
 415                          return;
 416                      }
 417  
 418                      // Calculate how far to scroll to bring the match into view
 419                      Layout layout = mContentEditText.getLayout();
 420                      int lineTop = layout.getLineTop(layout.getLineForOffset(matchLocation));
 421                      ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 422                      mShouldScrollToSearchMatch = false;
 423                  }
 424              }
 425          });
 426          setHasOptionsMenu(true);
 427          return mRootView;
 428      }
 429  
 430      public void scrollToMatch(int location) {
 431          if (isAdded()) {
 432              // Calculate how far to scroll to bring the match into view
 433              Layout layout = mContentEditText.getLayout();
 434              int lineTop = layout.getLineTop(layout.getLineForOffset(location));
 435              ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 436          }
 437      }
 438  
 439      @Override
 440      public void onResume() {
 441          super.onResume();
 442          mNotesBucket.start();
 443          mNotesBucket.addListener(this);
 444          mTagInput.setOnTagAddedListener(this);
 445  
 446          if (mContentEditText != null) {
 447              mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(getActivity()));
 448  
 449              if (mContentEditText.hasFocus()) {
 450                  showSoftKeyboard();
 451              }
 452          }
 453      }
 454  
 455      private void showSoftKeyboard() {
 456          new Handler().postDelayed(new Runnable() {
 457              @Override
 458              public void run() {
 459                  if (getActivity() == null) {
 460                      return;
 461                  }
 462  
<abbr title=" 463                  InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);"> 463                  InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(ContexðŸ”µ</abbr>
 464                  if (inputMethodManager != null) {
 465                      inputMethodManager.showSoftInput(mContentEditText, 0);
 466                  }
 467              }
 468          }, 100);
 469      }
 470  
 471      @Override
 472      public void onPause() {
 473          super.onPause();  // Always call the superclass method first
 474          mIsPaused = true;
 475  
 476          // Hide soft keyboard if it is showing...
 477          DisplayUtils.hideKeyboard(mContentEditText);
 478  
 479          mTagInput.setOnTagAddedListener(null);
 480  
 481          if (mAutoSaveHandler != null) {
 482              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 483          }
 484  
 485          if (mPublishTimeoutHandler != null) {
 486              mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
 487          }
 488  
 489          if (mHistoryTimeoutHandler != null) {
 490              mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 491          }
 492  
 493          mHighlighter.stop();
 494          saveNote();
 495      }
 496  
 497      @Override
 498      public void onDestroy() {
 499          super.onDestroy();
 500          mNotesBucket.removeListener(this);
 501          mNotesBucket.stop();
 502      }
 503  
 504      @Override
 505      public void onSaveInstanceState(@NonNull Bundle outState) {
 506          super.onSaveInstanceState(outState);
 507  
 508          if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote != null) {
 509              outState.putString(STATE_NOTE_ID, mNote.getSimperiumKey());
 510          }
 511      }
 512  
 513      @Override
 514      public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
 515          super.onCreateOptionsMenu(menu, inflater);
 516  
<abbr title=" 517          if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFragment == null)) {"> 517          if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFrðŸ”µ</abbr>
 518              return;
 519          }
 520  
 521          inflater.inflate(R.menu.note_editor, menu);
 522          MenuCompat.setGroupDividerEnabled(menu, true);
 523      }
 524  
 525      @Override
 526      public boolean onOptionsItemSelected(@NonNull MenuItem item) {
 527          switch (item.getItemId()) {
 528              case R.id.menu_checklist:
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 529 -                DrawableUtils.startAnimatedVectorDrawable(item.getIcon());</span>
 530                  insertChecklist();
 531                  return true;
 532              case R.id.menu_copy:
 533                  copyToClipboard(mNote.getPublishedUrl());

 534                  Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 535                  return true;
 536              case R.id.menu_history:
 537                  showHistory();
 538                  return true;
 539              case R.id.menu_info:
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 540 -                DrawableUtils.startAnimatedVectorDrawable(item.getIcon());</span>
 541                  showInfo();
 542                  return true;
 543              case R.id.menu_markdown:
 544                  setMarkdown(!item.isChecked());
 545                  return true;
 546              case R.id.menu_pin:
 547                  NoteUtils.setNotePin(mNote, !item.isChecked());
 548                  requireActivity().invalidateOptionsMenu();
 549                  return true;
 550              case R.id.menu_publish:
 551                  if (item.isChecked()) {
 552                      unpublishNote();
 553                  } else {
 554                      publishNote();
 555                  }
 556  
 557                  return true;
 558              case R.id.menu_share:
 559                  shareNote();
 560                  return true;
 561              case R.id.menu_trash:
 562                  if (!isAdded()) {
 563                      return false;
 564                  }
 565  
 566                  deleteNote();
 567                  return true;
 568              case android.R.id.home:
 569                  if (!isAdded()) {
 570                      return false;
 571                  }
 572  
 573                  requireActivity().finish();
 574                  return true;
 575              default:
 576                  return super.onOptionsItemSelected(item);
 577          }
 578      }
 579  
 580      @Override
 581      public void onPrepareOptionsMenu(@NonNull Menu menu) {
 582          if (mNote != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 583 -            menu.findItem(R.id.menu_info).setVisible(true);</span>
 584              MenuItem pinItem = menu.findItem(R.id.menu_pin);
 585              MenuItem shareItem = menu.findItem(R.id.menu_share);
 586              MenuItem historyItem = menu.findItem(R.id.menu_history);
 587              MenuItem publishItem = menu.findItem(R.id.menu_publish);
 588              MenuItem copyLinkItem = menu.findItem(R.id.menu_copy);
 589              MenuItem markdownItem = menu.findItem(R.id.menu_markdown);
 590              MenuItem trashItem = menu.findItem(R.id.menu_trash);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 591 -            MenuItem checklistItem = menu.findItem(R.id.menu_checklist);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 592 +            mChecklistMenuItem = menu.findItem(R.id.menu_checklist);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 593 +            mInformationMenuItem = menu.findItem(R.id.menu_info).setVisible(true);</span>
 594  
 595              pinItem.setChecked(mNote.isPinned());
 596              publishItem.setChecked(mNote.isPublished());
 597              markdownItem.setChecked(mNote.isMarkdownEnabled());
 598  
 599              // Disable actions when note is in Trash or markdown view is shown on large device.
 600              if (mNote.isDeleted() || (mMarkdown != null &amp;&amp; mMarkdown.getVisibility() == View.VISIBLE)) {
 601                  pinItem.setEnabled(false);
 602                  shareItem.setEnabled(false);
 603                  historyItem.setEnabled(false);
 604                  publishItem.setEnabled(false);
 605                  copyLinkItem.setEnabled(false);
 606                  markdownItem.setEnabled(false);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 607 -                checklistItem.setEnabled(false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 608 -                DrawableUtils.setMenuItemAlpha(checklistItem, 0.3);  // 0.3 is 30% opacity.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 609 +                mChecklistMenuItem.setEnabled(false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 610 +                DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 0.3);  // 0.3 is 30% opacity.</span>
 611              } else {
 612                  pinItem.setEnabled(true);
 613                  shareItem.setEnabled(true);
 614                  historyItem.setEnabled(true);
 615                  publishItem.setEnabled(true);
 616                  copyLinkItem.setEnabled(mNote.isPublished());
 617                  markdownItem.setEnabled(true);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 618 -                checklistItem.setEnabled(true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 619 -                DrawableUtils.setMenuItemAlpha(checklistItem, 1.0);  // 1.0 is 100% opacity.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 620 +                mChecklistMenuItem.setEnabled(true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 621 +                DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 1.0);  // 1.0 is 100% opacity.</span>
 622              }
 623  
 624              if (mNote.isDeleted()) {
 625                  trashItem.setTitle(R.string.restore);
 626              } else {
 627                  trashItem.setTitle(R.string.trash);
 628              }
 629          }
 630  
 631          DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 632          super.onPrepareOptionsMenu(menu);
 633      }
 634  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 635 -    private void insertChecklist() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 636 +    public void insertChecklist() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 637 +        DrawableUtils.startAnimatedVectorDrawable(mChecklistMenuItem.getIcon());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 638 +</span>
 639          try {
 640              mContentEditText.insertChecklist();
 641          } catch (Exception e) {
 642              e.printStackTrace();
 643              return;
 644          }
 645  
 646          AnalyticsTracker.track(
 647              EDITOR_CHECKLIST_INSERTED,
 648              CATEGORY_NOTE,
 649              &quot;toolbar_button&quot;
 650          );
 651      }
 652  
 653      @Override
 654      public void onCheckboxToggled() {
 655          // Save note (using delay) after toggling a checkbox
 656          if (mAutoSaveHandler != null) {
 657              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 658              mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 659          }
 660      }
 661  
 662      private void deleteNote() {
 663          NoteUtils.deleteNote(mNote, getActivity());
 664          requireActivity().finish();
 665      }
 666  
 667      protected void clearMarkdown() {
 668          mMarkdown.loadDataWithBaseURL(&quot;file:///android_asset/&quot;, mCss + &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 669      }
 670  
 671      protected void hideMarkdown() {
 672          mMarkdown.setVisibility(View.INVISIBLE);
 673      }
 674  
 675      protected void showMarkdown() {
 676          loadMarkdownData();
 677          mMarkdown.setVisibility(View.VISIBLE);
 678  
 679          new Handler().postDelayed(
 680              new Runnable() {
 681                  @Override
 682                  public void run() {
 683                      requireActivity().invalidateOptionsMenu();
 684                  }
 685              },
 686              getResources().getInteger(R.integer.time_animation)
 687          );
 688      }
 689  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 690 -    private void shareNote() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 691 +    public void shareNote() {</span>
 692          if (mNote != null) {
 693              mContentEditText.clearFocus();
 694              showShareSheet();
 695              AnalyticsTracker.track(
 696                  EDITOR_NOTE_CONTENT_SHARED,
 697                  CATEGORY_NOTE,
 698                  &quot;action_bar_share_button&quot;
 699              );
 700          }
 701      }
 702  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 703 -    private void showHistory() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 704 +    public void showHistory() {</span>
 705          if (mNote != null &amp;&amp; mNote.getVersion() &gt; 1) {
 706              mContentEditText.clearFocus();
 707              mHistoryTimeoutHandler.postDelayed(mHistoryTimeoutRunnable, HISTORY_TIMEOUT);
 708              showHistorySheet();
 709          } else {
 710              Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 711          }
 712      }
 713  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 714 -    private void showInfo() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 715 +    public void showInfo() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 716 +        DrawableUtils.startAnimatedVectorDrawable(mInformationMenuItem.getIcon());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 717 +</span>
 718          if (mNote != null) {
 719              mContentEditText.clearFocus();
 720              saveNote();
 721              showInfoSheet();
 722          }
 723      }
 724  
 725      private void setMarkdown(boolean isChecked) {
 726          mIsMarkdownEnabled = isChecked;
 727          Activity activity = getActivity();
 728  
 729          if (activity instanceof NoteEditorActivity) {
 730              NoteEditorActivity editorActivity = (NoteEditorActivity) activity;
 731  
 732              if (mIsMarkdownEnabled) {
 733                  editorActivity.showTabs();
 734  
 735                  if (mNoteMarkdownFragment == null) {
 736                      // Get markdown fragment and update content
 737                      mNoteMarkdownFragment = editorActivity.getNoteMarkdownFragment();
 738                      mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPlainTextContent());
 739                  }
 740              } else {
 741                  editorActivity.hideTabs();
 742              }
 743          } else if (activity instanceof NotesActivity) {
 744              setMarkdownEnabled(mIsMarkdownEnabled);
 745              ((NotesActivity) getActivity()).setMarkdownShowing(false);
 746          }
 747  
 748          saveNote();
 749  
 750          // Set preference so that next new note will have markdown enabled.
 751          SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(requireContext());
 752          SharedPreferences.Editor editor = prefs.edit();
 753          editor.putBoolean(PrefUtils.PREF_MARKDOWN_ENABLED, isChecked);
 754          editor.apply();
 755      }
 756  
 757      protected void setMarkdownEnabled(boolean enabled) {
 758          mIsMarkdownEnabled = enabled;
 759  
 760          if (mIsMarkdownEnabled) {
 761              loadMarkdownData();
 762          }
 763      }
 764  
 765      private void loadMarkdownData() {
 766          String formattedContent = NoteMarkdownFragment.getMarkdownFormattedContent(
 767                  mCss,
 768                  mContentEditText.getPlainTextContent()
 769          );
 770  
 771          mMarkdown.loadDataWithBaseURL(null, formattedContent, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 772      }
 773  
 774      public void setNote(String noteID, String matchOffsets) {
 775          if (mAutoSaveHandler != null)
 776              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 777  
 778          mPlaceholderView.setVisibility(View.GONE);
 779  
 780          if (matchOffsets != null) {
 781              mMatchOffsets = matchOffsets;
 782          } else {
 783              mMatchOffsets = null;
 784          }
 785  
 786  
 787          saveNote();
 788  
 789          new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteID);
 790      }
 791  
 792      private void updateNote(Note updatedNote) {
 793          // update note if network change arrived
 794          mNote = updatedNote;
 795          refreshContent(true);
 796      }
 797  
 798      private void refreshContent(boolean isNoteUpdate) {
 799          if (mNote != null) {
 800              // Restore the cursor position if possible.
<abbr title=" 801              int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.getSelectionEnd());"> 801              int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.geðŸ”µ</abbr>
 802              mContentEditText.setText(mNote.getContent());
 803  
 804              if (isNoteUpdate) {
 805                  // Update markdown and preview flags from updated note.
 806                  mIsMarkdownEnabled = mNote.isMarkdownEnabled();
 807                  mIsPreviewEnabled = mNote.isPreviewEnabled();
 808  
 809                  // Show/Hide tabs based on markdown flag.
 810                  setMarkdown(mIsMarkdownEnabled);
 811  
 812                  // Save note so any local changes get synced.
 813                  mNote.save();
 814  
 815                  // Update current note object on large screen devices in landscape orientation.
 816                  if (DisplayUtils.isLargeScreenLandscape(requireContext())) {
 817                      ((NotesActivity) requireActivity()).setCurrentNote(mNote);
 818                  }
 819  
 820                  // Update overflow popup menu.
 821                  requireActivity().invalidateOptionsMenu();
 822  
 823                  if (mContentEditText.hasFocus()
 824                          &amp;&amp; cursorPosition != mContentEditText.getSelectionEnd()
 825                          &amp;&amp; cursorPosition &lt; mContentEditText.getText().length()) {
 826                      mContentEditText.setSelection(cursorPosition);
 827                  }
 828              }
 829  
 830              afterTextChanged(mContentEditText.getText());
 831              mContentEditText.processChecklists();
 832              updateTagList();
 833          }
 834      }
 835  
 836      private void updateTagList() {
 837          setChips(mNote.getTagString());
 838          mTagInput.setText(&quot;&quot;);
 839      }
 840  
 841      private int newCursorLocation(String newText, String oldText, int cursorLocation) {
 842          // Ported from the iOS app :)
 843          // Cases:
 844          // 0. All text after cursor (and possibly more) was removed ==&gt; put cursor at end
 845          // 1. Text was added after the cursor ==&gt; no change
 846          // 2. Text was added before the cursor ==&gt; location advances
 847          // 3. Text was removed after the cursor ==&gt; no change
 848          // 4. Text was removed before the cursor ==&gt; location retreats
 849          // 5. Text was added/removed on both sides of the cursor ==&gt; not handled
 850  
 851          cursorLocation = Math.max(cursorLocation, 0);
 852  
 853          int newCursorLocation = cursorLocation;
 854  
 855          int deltaLength = newText.length() - oldText.length();
 856  
 857          // Case 0
 858          if (newText.length() &lt; cursorLocation)
 859              return newText.length();
 860  
 861          boolean beforeCursorMatches = false;
 862          boolean afterCursorMatches = false;
 863  
 864          try {
<abbr title=" 865              beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation));"> 865              beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation)ðŸ”µ</abbr>
<abbr title=" 866              afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaLength));"> 866              afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaðŸ”µ</abbr>
 867          } catch (Exception e) {
 868              e.printStackTrace();
 869          }
 870  
 871          // Cases 2 and 4
 872          if (!beforeCursorMatches &amp;&amp; afterCursorMatches)
 873              newCursorLocation += deltaLength;
 874  
 875          // Cases 1, 3 and 5 have no change
 876          return newCursorLocation;
 877      }
 878  
 879      @Override
 880      public void onTagAdded(String tag) {
 881          if (mNote == null || !isAdded()) {
 882              return;
 883          }
 884  
 885          if (mNote.getTagString() != null &amp;&amp; tag.length() &gt; mNote.getTagString().length()) {
 886              AnalyticsTracker.track(
 887                  EDITOR_TAG_ADDED,
 888                  CATEGORY_NOTE,
 889                  &quot;tag_added_to_note&quot;
 890              );
 891          }
 892  
 893          mNote.setTagString(mNote.getTagString() + String.valueOf(SPACE) + tag);
 894          mNote.setModificationDate(Calendar.getInstance());
 895          updateTagList();
 896          mNote.save();
 897      }
 898  
 899      @Override
 900      public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
 901          // Unused
 902      }
 903  
 904      @Override
 905      public void afterTextChanged(Editable editable) {
 906          attemptAutoList(editable);
 907          setTitleSpan(editable);
 908          mContentEditText.fixLineSpacing();
 909      }
 910  
 911      @Override
 912      public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
 913          // When text changes, start timer that will fire after AUTOSAVE_DELAY_MILLIS passes
 914          if (mAutoSaveHandler != null) {
 915              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 916              mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 917          }
 918  
 919          // Remove search highlight spans when note content changes
 920          if (mMatchOffsets != null) {
 921              mMatchOffsets = null;
 922              mHighlighter.removeMatches();
 923          }
 924  
 925          if (!DisplayUtils.isLargeScreenLandscape(requireContext())) {
 926              ((NoteEditorActivity) requireActivity()).setSearchMatchBarVisible(false);
 927          }
 928  
 929          // Temporarily remove the text watcher as we process checklists to prevent callback looping
 930          mContentEditText.removeTextChangedListener(this);
 931          mContentEditText.processChecklists();
 932          mContentEditText.addTextChangedListener(this);
 933      }
 934  
 935      /**
 936       * Set the note title to be a larger size and bold style.
 937       *
 938       * Remove all existing spans before applying spans or performance issues will occur.  Since both
 939       * {@link RelativeSizeSpan} and {@link StyleSpan} inherit from {@link MetricAffectingSpan}, all
 940       * spans are removed when {@link MetricAffectingSpan} is removed.
 941       */
 942      private void setTitleSpan(Editable editable) {
 943          for (MetricAffectingSpan span : editable.getSpans(0, editable.length(), MetricAffectingSpan.class)) {
 944              if (span instanceof RelativeSizeSpan || span instanceof StyleSpan) {
 945                  editable.removeSpan(span);
 946              }
 947          }
 948  
 949          int newLinePosition = getNoteContentString().indexOf(&quot;\n&quot;);
 950  
 951          if (newLinePosition == 0) {
 952              return;
 953          }
 954  
 955          int titleEndPosition = (newLinePosition &gt; 0) ? newLinePosition : editable.length();
 956          editable.setSpan(new RelativeSizeSpan(1.3f), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
 957          editable.setSpan(new StyleSpan(Typeface.BOLD), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
 958      }
 959  
 960      private void attemptAutoList(Editable editable) {
 961          int oldCursorPosition = mCurrentCursorPosition;
 962          mCurrentCursorPosition = mContentEditText.getSelectionStart();
 963          AutoBullet.apply(editable, oldCursorPosition, mCurrentCursorPosition);
 964          mCurrentCursorPosition = mContentEditText.getSelectionStart();
 965      }
 966  
 967      private void saveAndSyncNote() {
 968          if (mNote == null) {
 969              return;
 970          }
 971  
 972          new SaveNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 973 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 974 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 975 +    public boolean isPlaceholderVisible() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 976 +        if (mPlaceholderView != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 977 +            return mPlaceholderView.getVisibility() == View.VISIBLE;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 978 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 979 +            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 980 +        }</span>
 981      }
 982  
 983      public void setPlaceholderVisible(boolean isVisible) {
 984          if (isVisible) {
 985              mNote = null;
 986              mContentEditText.setText(&quot;&quot;);
 987          }
 988  
 989          if (mPlaceholderView != null) {
 990              mPlaceholderView.setVisibility(isVisible ? View.VISIBLE : View.GONE);
 991          }
 992      }
 993  
 994      @Override
 995      public void onFocusChange(View v, boolean hasFocus) {
 996          if (!hasFocus) {
 997              String tags = getNoteTagsString().trim();
 998  
 999              if (mTagInput.getText().toString().trim().length() &gt; 0) {
1000                  onTagAdded(mTagInput.getText().toString());
1001              } else if (tags.length() &gt; 0) {
1002                  setChips(tags);
1003              }
1004          }
1005      }
1006  
1007      private Note getNote() {
1008          return mNote;
1009      }
1010  
1011      public void setNote(String noteID) {
1012          setNote(noteID, null);
1013      }
1014  
1015      private String getNoteContentString() {
1016          if (mContentEditText == null || mContentEditText.getText() == null) {
1017              return &quot;&quot;;
1018          } else {
1019              return mContentEditText.getText().toString();
1020          }
1021      }
1022  
1023      private String getNoteTagsString() {
1024          StringBuilder tags = new StringBuilder();
1025  
1026          for (int i= 0; i &lt; mTagChips.getChildCount(); i++) {
1027              tags.append(((Chip) mTagChips.getChildAt(i)).getText()).append(&quot; &quot;);
1028          }
1029  
1030          return tags.toString();
1031      }
1032  
1033      /**
1034       * Share bottom sheet callbacks
1035       */
1036  
1037      @Override
1038      public void onSharePublishClicked() {
1039          publishNote();
1040          if (mShareBottomSheet != null) {
1041              mShareBottomSheet.dismiss();
1042          }
1043      }
1044  
1045      @Override
1046      public void onShareUnpublishClicked() {
1047          unpublishNote();
1048          if (mShareBottomSheet != null) {
1049              mShareBottomSheet.dismiss();
1050          }
1051      }
1052  
1053      @Override
1054      public void onWordPressPostClicked() {
1055          if (mShareBottomSheet != null) {
1056              mShareBottomSheet.dismiss();
1057          }
1058  
1059          if (getFragmentManager() == null) {
1060              return;
1061          }
1062  
1063          FragmentTransaction ft = getFragmentManager().beginTransaction();
1064          Fragment prev = getFragmentManager().findFragmentByTag(WordPressDialogFragment.DIALOG_TAG);
1065          if (prev != null) {
1066              ft.remove(prev);
1067          }
1068          ft.addToBackStack(null);
1069  
1070          // Create and show the dialog.
1071          WordPressDialogFragment wpDialogFragment = new WordPressDialogFragment();
1072          wpDialogFragment.setNote(mNote);
1073          wpDialogFragment.show(ft, WordPressDialogFragment.DIALOG_TAG);
1074      }
1075  
1076      @Override
1077      public void onShareCollaborateClicked() {
1078          Toast.makeText(getActivity(), R.string.collaborate_message, Toast.LENGTH_LONG).show();
1079      }
1080  
1081      @Override
1082      public void onShareDismissed() {
1083  
1084      }
1085  
1086      /**
1087       * History bottom sheet listeners
1088       */
1089  
1090      @Override
1091      public void onHistoryCancelClicked() {
1092          mContentEditText.setText(mNote.getContent());
1093          if (mHistoryBottomSheet != null) {
1094              mHistoryBottomSheet.dismiss();
1095          }
1096      }
1097  
1098      @Override
1099      public void onHistoryRestoreClicked() {
1100          if (mHistoryBottomSheet != null) {
1101              mHistoryBottomSheet.dismiss();
1102          }
1103          saveAndSyncNote();
1104      }
1105  
1106      @Override
1107      public void onHistoryDismissed() {
1108          if (!mHistoryBottomSheet.didTapOnButton()) {
1109              mContentEditText.setText(mNote.getContent());
1110          }
1111  
1112          if (mHistoryTimeoutHandler != null) {
1113              mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
1114          }
1115      }
1116  
1117      @Override
1118      public void onHistoryUpdateNote(String content) {
1119          mContentEditText.setText(content);
1120      }
1121  
1122      protected void saveNote() {
1123          try {
1124              if (mNote == null || mNotesBucket == null || mContentEditText == null || mIsLoadingNote ||
<abbr title="1125                  (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing())) {">1125                  (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getðŸ”µ</abbr>
1126                  return;
1127              } else {
1128                  mNote = mNotesBucket.get(mNote.getSimperiumKey());
1129                  mIsPreviewEnabled = mNote.isPreviewEnabled();
1130              }
1131  
1132              String content = mContentEditText.getPlainTextContent();
1133              String tagString = getNoteTagsString();
1134  
<abbr title="1135              if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnabled)) {">1135              if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnableðŸ”µ</abbr>
1136                  mNote.setContent(content);
1137                  mNote.setTagString(tagString);
1138                  mNote.setModificationDate(Calendar.getInstance());
1139                  mNote.setMarkdownEnabled(mIsMarkdownEnabled);
1140                  mNote.setPreviewEnabled(mIsPreviewEnabled);
1141                  mNote.save();
1142  
1143                  AnalyticsTracker.track(
1144                      EDITOR_NOTE_EDITED,
1145                      CATEGORY_NOTE,
1146                      &quot;editor_save&quot;
1147                  );
1148              }
1149          } catch (BucketObjectMissingException exception) {
1150              exception.printStackTrace();
1151          }
1152      }
1153  
1154      // Checks if cursor is at a URL when the selection changes
1155      // If it is a URL, show the contextual action bar
1156      @Override
1157      public void onSelectionChanged(int selStart, int selEnd) {
1158          mCurrentCursorPosition = selEnd;
1159          if (selStart == selEnd) {
1160              Editable noteContent = mContentEditText.getText();
1161              if (noteContent == null)
1162                  return;
1163  
1164              URLSpan[] urlSpans = noteContent.getSpans(selStart, selStart, URLSpan.class);
1165              if (urlSpans.length &gt; 0) {
1166                  URLSpan urlSpan = urlSpans[0];
1167                  mLinkUrl = urlSpan.getURL();
<abbr title="1168                  mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSpan)).toString();">1168                  mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSðŸ”µ</abbr>
1169                  if (mActionMode != null) {
1170                      mActionMode.setSubtitle(mLinkText);
1171                      updateMenuItems();
1172                      return;
1173                  }
1174  
1175                  // Show the Contextual Action Bar
1176                  if (getActivity() != null) {
1177                      mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCallback);
1178                      if (mActionMode != null) {
1179                          mActionMode.setSubtitle(mLinkText);
1180                      }
1181  
1182                      updateMenuItems();
1183                  }
1184              } else if (mActionMode != null) {
1185                  mActionMode.finish();
1186                  mActionMode = null;
1187              }
1188          } else if (mActionMode != null) {
1189              mActionMode.finish();
1190              mActionMode = null;
1191          }
1192      }
1193  
1194      private void updateMenuItems() {
1195          mCopyMenuItem.setIcon(mCopyIcon);
1196          mShareMenuItem.setIcon(mShareIcon);
1197  
1198          if (mViewLinkMenuItem != null &amp;&amp; mLinkUrl != null) {
1199              if (mLinkUrl.startsWith(&quot;tel:&quot;)) {
1200                  mViewLinkMenuItem.setIcon(mCallIcon);
1201                  mViewLinkMenuItem.setTitle(getString(R.string.call));
1202              } else if (mLinkUrl.startsWith(&quot;mailto:&quot;)) {
1203                  mViewLinkMenuItem.setIcon(mEmailIcon);
1204                  mViewLinkMenuItem.setTitle(getString(R.string.email));
1205              } else if (mLinkUrl.startsWith(&quot;geo:&quot;)) {
1206                  mViewLinkMenuItem.setIcon(mMapIcon);
1207                  mViewLinkMenuItem.setTitle(getString(R.string.view_map));
1208              } else {
1209                  mViewLinkMenuItem.setIcon(mBrowserIcon);
1210                  mViewLinkMenuItem.setTitle(getString(R.string.view_in_browser));
1211              }
1212          }
1213      }
1214  
1215      private void setPublishedNote(boolean isPublished) {
1216          if (mNote != null) {
1217              mNote.setPublished(isPublished);
1218              mNote.save();
1219  
1220              // reset publish status in 20 seconds if we don&#x27;t hear back from Simperium
1221              mPublishTimeoutHandler.postDelayed(mPublishTimeoutRunnable, PUBLISH_TIMEOUT);
1222  
1223              AnalyticsTracker.track(
1224                  isPublished ? EDITOR_NOTE_PUBLISHED : EDITOR_NOTE_UNPUBLISHED,
1225                  CATEGORY_NOTE,
1226                  &quot;publish_note_button&quot;
1227              );
1228          }
1229      }
1230  
1231      private void updatePublishedState(boolean isSuccess) {
1232          if (mPublishingSnackbar == null) {
1233              return;
1234          }
1235  
1236          mPublishingSnackbar.dismiss();
1237          mPublishingSnackbar = null;
1238  
1239          if (isSuccess &amp;&amp; isAdded()) {
1240              if (mNote.isPublished()) {
1241                  if (mHideActionOnSuccess) {
1242                      Snackbar.make(mRootView, R.string.publish_successful, Snackbar.LENGTH_LONG)
1243                              .show();
1244                  } else {
1245                      Snackbar.make(mRootView, R.string.publish_successful, Snackbar.LENGTH_LONG)
1246                              .setAction(
1247                                  R.string.undo,
1248                                  new View.OnClickListener() {
1249                                      @Override
1250                                      public void onClick(View v) {
1251                                          mHideActionOnSuccess = true;
1252                                          unpublishNote();
1253                                      }
1254                                  }
1255                              )
1256                              .show();
1257                  }
1258  
1259                  copyToClipboard(mNote.getPublishedUrl());

1260              } else {
1261                  if (mHideActionOnSuccess) {
1262                      Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG)
1263                              .show();
1264                  } else {
1265                      Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG)
1266                              .setAction(
1267                                  R.string.undo,
1268                                  new View.OnClickListener() {
1269                                      @Override
1270                                      public void onClick(View v) {
1271                                          mHideActionOnSuccess = true;
1272                                          publishNote();
1273                                      }
1274                                  }
1275                              )
1276                              .show();
1277                  }
1278              }
1279          } else {
1280              if (mNote.isPublished()) {
1281                  Snackbar.make(mRootView, R.string.unpublish_error, Snackbar.LENGTH_LONG)
1282                          .setAction(
1283                              R.string.retry,
1284                              new View.OnClickListener() {
1285                                  @Override
1286                                  public void onClick(View v) {
1287                                      mHideActionOnSuccess = true;
1288                                      unpublishNote();
1289                                  }
1290                              }
1291                          ).show();
1292              } else {
1293                  Snackbar.make(mRootView, R.string.publish_error, Snackbar.LENGTH_LONG)
1294                          .setAction(
1295                              R.string.retry,
1296                              new View.OnClickListener() {
1297                                  @Override
1298                                  public void onClick(View v) {
1299                                      mHideActionOnSuccess = true;
1300                                      publishNote();
1301                                  }
1302                              }
1303                          ).show();
1304              }
1305          }
1306  
1307          mHideActionOnSuccess = false;
1308          requireActivity().invalidateOptionsMenu();
1309      }
1310  
1311      private void publishNote() {
1312          if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1313              Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1314              return;
1315          }
1316  
1317          if (isAdded()) {
1318              mPublishingSnackbar = Snackbar.make(mRootView, R.string.publishing, Snackbar.LENGTH_INDEFINITE);
1319              mPublishingSnackbar.show();
1320          }
1321  
1322          setPublishedNote(true);
1323      }
1324  
1325      private void unpublishNote() {
1326          if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1327              Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1328              return;
1329          }
1330  
1331          if (isAdded()) {
1332              mPublishingSnackbar = Snackbar.make(mRootView, R.string.unpublishing, Snackbar.LENGTH_INDEFINITE);
1333              mPublishingSnackbar.show();
1334          }
1335  
1336          setPublishedNote(false);
1337      }
1338  
1339      private void copyToClipboard(String text) {
1340          ClipboardManager clipboard = (ClipboardManager) requireActivity()
1341                  .getSystemService(Context.CLIPBOARD_SERVICE);
1342          ClipData clip = ClipData.newPlainText(getString(R.string.app_name), text);
1343          if (clipboard != null) {
1344              clipboard.setPrimaryClip(clip);
1345          }
1346      }
1347  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1348 +    private void showShare(String text) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1349 +        startActivity(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1350 +            ShareCompat.IntentBuilder.from(requireActivity())</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1351 +                .setText(text)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1352 +                .setType(&quot;text/plain&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1353 +                .createChooserIntent()</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1354 +        );</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1355 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1356 +</span>
1357      private void showShareSheet() {
1358          if (isAdded() &amp;&amp; mShareBottomSheet != null &amp;&amp; !mShareBottomSheet.isAdded()) {
1359              mShareBottomSheet.show(requireFragmentManager(), mNote);
1360          }
1361      }
1362  
1363      private void showInfoSheet() {
1364          if (isAdded() &amp;&amp; mInfoBottomSheet != null &amp;&amp; !mInfoBottomSheet.isAdded()) {
1365              mInfoBottomSheet.show(requireFragmentManager(), mNote);
1366          }
1367      }
1368  
1369      private void showHistorySheet() {
1370          if (isAdded() &amp;&amp; mHistoryBottomSheet != null &amp;&amp; !mHistoryBottomSheet.isAdded()) {
1371              // Request revisions for the current note
1372              mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbacks());
1373              saveNote();
1374  
1375              mHistoryBottomSheet.show(requireFragmentManager(), mNote);
1376          }
1377      }
1378  
1379      /**
1380       * Simperium listeners
1381       */
1382  
1383      @Override
1384      public void onDeleteObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1385  
1386      }
1387  
1388      @Override
1389      public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) {
1390          if (changeType == Bucket.ChangeType.MODIFY) {
1391              if (getNote() != null &amp;&amp; getNote().getSimperiumKey().equals(key)) {
1392                  try {
1393                      final Note updatedNote = mNotesBucket.get(key);
1394                      if (getActivity() != null) {
1395                          getActivity().runOnUiThread(new Runnable() {
1396                              @Override
1397                              public void run() {
1398                                  if (mPublishTimeoutHandler != null) {
1399                                      mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
1400                                  }
1401  
1402                                  updateNote(updatedNote);
1403                                  updatePublishedState(true);
1404                              }
1405                          });
1406                      }
1407                  } catch (BucketObjectMissingException e) {
1408                      e.printStackTrace();
1409                  }
1410              }
1411          }
1412      }
1413  
1414      @Override
1415      public void onSaveObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1416          if (mIsPaused) {
1417              mNotesBucket.removeListener(this);
1418              mNotesBucket.stop();
1419          }
1420      }
1421  
1422      @Override
1423      public void onBeforeUpdateObject(Bucket&lt;Note&gt; bucket, Note note) {
1424          // Don&#x27;t apply updates if we haven&#x27;t loaded the note yet
1425          if (mIsLoadingNote)
1426              return;
1427  
1428          Note openNote = getNote();
1429          if (openNote == null || !openNote.getSimperiumKey().equals(note.getSimperiumKey()))
1430              return;
1431  
1432          note.setContent(mContentEditText.getPlainTextContent());
1433      }
1434  
1435      private static class LoadNoteTask extends AsyncTask&lt;String, Void, Void&gt; {
1436          WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1437  
1438          LoadNoteTask(NoteEditorFragment fragment) {
1439              mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1440          }
1441  
1442          @Override
1443          protected void onPreExecute() {
1444              NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1445  
1446              if (fragment != null) {
1447                  fragment.mContentEditText.removeTextChangedListener(fragment);
1448                  fragment.mIsLoadingNote = true;
1449              }
1450          }
1451  
1452          @Override
1453          protected Void doInBackground(String... args) {
1454              NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1455  
1456              if (fragment == null || fragment.getActivity() == null) {
1457                  return null;
1458              }
1459  
1460              String noteID = args[0];
1461              Simplenote application = (Simplenote) fragment.getActivity().getApplication();
1462              Bucket&lt;Note&gt; notesBucket = application.getNotesBucket();
1463  
1464              try {
1465                  fragment.mNote = notesBucket.get(noteID);
1466  
1467                  // Set the current note in NotesActivity when on a tablet
1468                  if (fragment.getActivity() instanceof NotesActivity) {
1469                      ((NotesActivity) fragment.getActivity()).setCurrentNote(fragment.mNote);
1470                  }
1471  
1472                  // Set markdown and preview flags for current note
1473                  if (fragment.mNote != null) {
1474                      fragment.mIsMarkdownEnabled = fragment.mNote.isMarkdownEnabled();
1475                      fragment.mIsPreviewEnabled = fragment.mNote.isPreviewEnabled();
1476                  }
1477              } catch (BucketObjectMissingException e) {
1478                  // See if the note is in the object store
1479                  Bucket.ObjectCursor&lt;Note&gt; notesCursor = notesBucket.allObjects();
1480  
1481                  while (notesCursor.moveToNext()) {
1482                      Note currentNote = notesCursor.getObject();
1483  
1484                      if (currentNote != null &amp;&amp; currentNote.getSimperiumKey().equals(noteID)) {
1485                          fragment.mNote = currentNote;
1486                          return null;
1487                      }
1488                  }
1489              }
1490  
1491              return null;
1492          }
1493  
1494          @Override
1495          protected void onPostExecute(Void nada) {
1496              final NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1497              if (fragment == null || fragment.getActivity() == null || fragment.getActivity().isFinishing()) {
1498                  return;
1499              }
1500  
1501              fragment.refreshContent(false);
1502  
1503              if (fragment.mMatchOffsets != null) {
<abbr title="1504                  int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.CONTENT_PROPERTY);">1504                  int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.COðŸ”µ</abbr>
1505                  fragment.mHighlighter.highlightMatches(fragment.mMatchOffsets, columnIndex);
1506                  fragment.mShouldScrollToSearchMatch = true;
1507              }
1508  
1509              fragment.mContentEditText.addTextChangedListener(fragment);
1510  
1511              if (fragment.mNote != null &amp;&amp; fragment.mNote.getContent().isEmpty()) {
1512                  // Show soft keyboard
1513                  fragment.mContentEditText.requestFocus();
1514  
1515                  new Handler().postDelayed(new Runnable() {
1516                      @Override
1517                      public void run() {
1518                          if (fragment.getActivity() == null) {
1519                              return;
1520                          }
1521  
<abbr title="1522                          InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);">1522                          InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivity().getSysðŸ”µ</abbr>
1523  
1524                          if (inputMethodManager != null) {
1525                              inputMethodManager.showSoftInput(fragment.mContentEditText, 0);
1526                          }
1527                      }
1528                  }, 100);
1529              } else if (fragment.mNote != null) {
1530                  // If we have a valid note, hide the placeholder
1531                  fragment.setPlaceholderVisible(false);
1532              }
1533  
1534              fragment.updateMarkdownView();
1535              fragment.requireActivity().invalidateOptionsMenu();
1536              fragment.linkifyEditorContent();
1537              fragment.mIsLoadingNote = false;
1538          }
1539      }
1540  
1541      private static class SaveNoteTask extends AsyncTask&lt;Void, Void, Void&gt; {
1542          WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1543  
1544          SaveNoteTask(NoteEditorFragment fragment) {
1545              mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1546          }
1547  
1548          @Override
1549          protected Void doInBackground(Void... args) {
1550              NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1551  
1552              if (fragment != null) {
1553                  fragment.saveNote();
1554              }
1555  
1556              return null;
1557          }
1558  
1559          @Override
1560          protected void onPostExecute(Void nada) {
1561              NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1562  
1563              if (fragment != null &amp;&amp; fragment.getActivity() != null &amp;&amp; !fragment.getActivity().isFinishing()) {
1564                  // Update links
1565                  fragment.linkifyEditorContent();
1566                  fragment.updateMarkdownView();
1567              }
1568          }
1569      }
1570  
1571      private void linkifyEditorContent() {
1572          if (getActivity() == null || getActivity().isFinishing()) {
1573              return;
1574          }
1575  
1576          if (PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_DETECT_LINKS)) {
1577              SimplenoteLinkify.addLinks(mContentEditText, Linkify.ALL);
1578          }
1579      }
1580  
1581      // Show tabs if markdown is enabled globally, for current note, and not tablet landscape
1582      private void updateMarkdownView() {
1583          if (!mIsMarkdownEnabled) {
1584              return;
1585          }
1586  
1587          Activity activity = getActivity();
1588          if (activity instanceof NotesActivity) {
1589              // This fragment lives in NotesActivity, so load markdown in this fragment&#x27;s WebView.
1590              loadMarkdownData();
1591          } else {
1592              // This fragment lives in the NoteEditorActivity&#x27;s ViewPager.
1593              if (mNoteMarkdownFragment == null) {
1594                  mNoteMarkdownFragment = ((NoteEditorActivity) requireActivity())
1595                          .getNoteMarkdownFragment();
1596                  ((NoteEditorActivity) requireActivity()).showTabs();
1597              }
1598              // Load markdown in the sibling NoteMarkdownFragment&#x27;s WebView.
1599              mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPlainTextContent());
1600          }
1601      }
1602  
1603      private ColorStateList getChipBackgroundColor() {
1604          int[][] states = new int[][] {
1605              new int[] { android.R.attr.state_checked}, // checked
1606              new int[] {-android.R.attr.state_checked}  // unchecked
1607          };
1608  
1609          int[] colors = new int[] {
1610              ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOnBackgroundColor),
1611              ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOffBackgroundColor)
1612          };
1613  
1614          return new ColorStateList(states, colors);
1615      }
1616  
1617      private void setChips(CharSequence text) {
1618          mTagPadding.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1619          mTagChips.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1620          mTagChips.setSingleSelection(true);
1621          mTagChips.removeAllViews();
1622          SimpleStringSplitter tags = new SimpleStringSplitter(SPACE);
1623          tags.setString(text.toString());
1624  
1625          for (String tag : tags) {
1626              final Chip chip = new Chip(requireContext());
1627              chip.setText(tag);
1628              chip.setCheckable(true);
1629              chip.setCheckedIcon(null);
1630              chip.setChipBackgroundColor(getChipBackgroundColor());
1631              chip.setTextColor(ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipTextColor));
1632              chip.setStateListAnimator(null);
1633              chip.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
1634                  @Override
1635                  public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
1636                      chip.setCloseIconVisible(isChecked);
1637                  }
1638              });
1639              chip.setOnCloseIconClickListener(new View.OnClickListener() {
1640                  @Override
1641                  public void onClick(View view) {
1642                      mTagChips.removeView(view);
1643                      updateTags();
1644                      AnalyticsTracker.track(
1645                          EDITOR_TAG_REMOVED,
1646                          CATEGORY_NOTE,
1647                          &quot;tag_removed_from_note&quot;
1648                      );
1649                  }
1650              });
1651              mTagChips.addView(chip);
1652          }
1653      }
1654  
1655      private void updateTags() {
1656          if (mNote == null) {
1657              return;
1658          }
1659  
1660          mNote.setTagString(getNoteTagsString());
1661          mNote.setModificationDate(Calendar.getInstance());
1662          updateTagList();
1663          mNote.save();
1664      }
1665  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            