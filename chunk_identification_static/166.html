<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>166</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    166
                    <a href="165.html">prev</a>
                    <a href="167.html">next</a>
                    <a href="166_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    BroadleafCommerce/BroadleafCommerce_6e41116e816ffe5b940f6df83fbbf5a28e8c88bb_admin/broadleaf-contentmanagement-module/src/main/java/org/broadleafcommerce/cms/file/service/StaticAssetServiceImpl.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;6e41116e816ffe5b940f6df83fbbf5a28e8c88bb:admin/broadleaf-contentmanagement-module/src/main/java/org/broadleafcommerce/cms/file/service/StaticAssetServiceImpl.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;6e41116e816ffe5b940f6df83fbbf5a28e8c88bb^1:admin/broadleaf-contentmanagement-module/src/main/java/org/broadleafcommerce/cms/file/service/StaticAssetServiceImpl.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;6e41116e816ffe5b940f6df83fbbf5a28e8c88bb^2:admin/broadleaf-contentmanagement-module/src/main/java/org/broadleafcommerce/cms/file/service/StaticAssetServiceImpl.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;7aa99231e33d2cad425553c3c1de5a674270c4e1:admin/broadleaf-contentmanagement-module/src/main/java/org/broadleafcommerce/cms/file/service/StaticAssetServiceImpl.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*-
   2  * #%L
   3  * BroadleafCommerce CMS Module
   4  * %%
   5  * Copyright (C) 2009 - 2022 Broadleaf Commerce
   6 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">   7  * %%</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">   8  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">   9  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  10  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  11  * the Broadleaf End User License Agreement (EULA), Version 1.1</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  12  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  13  * shall apply.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  14  * </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title="  15  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  15  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title="  16  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  16  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  17  * #L%</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  18  */</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  19 /*</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  20  * BroadleafCommerce CMS Module</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  21  * %%</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  22  * Copyright (C) 2009 - 2016 Broadleaf Commerce</span>
  23 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  24  * %%</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  25  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  26  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  27  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  28  * the Broadleaf End User License Agreement (EULA), Version 1.1</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  29  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  30  * shall apply.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  31  * </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="  32  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  32  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="  33  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  33  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  34  * #L%</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  35  */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  36 /*</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  37  * BroadleafCommerce CMS Module</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  38  * %%</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  39  * Copyright (C) 2009 - 2016 Broadleaf Commerce</span>
  40 =======
  41 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  42  * %%
  43  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
  44  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
  45  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  46  * the Broadleaf End User License Agreement (EULA), Version 1.1
  47  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  48  * shall apply.
  49  *
<abbr title="  50  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  50  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  51  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  51  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  52  * #L%
  53  */
  54 package org.broadleafcommerce.cms.file.service;
  55 
  56 import org.apache.commons.io.FilenameUtils;
  57 import org.apache.commons.lang3.StringUtils;
  58 import org.apache.commons.logging.Log;
  59 import org.apache.commons.logging.LogFactory;
  60 import org.apache.tika.Tika;
  61 import org.apache.tika.mime.MimeType;
  62 import org.apache.tika.mime.MimeTypeException;
  63 import org.apache.tika.mime.MimeTypes;
  64 import org.broadleafcommerce.cms.field.type.StorageType;
  65 import org.broadleafcommerce.cms.file.StaticAssetMultiTenantExtensionManager;
  66 import org.broadleafcommerce.cms.file.dao.StaticAssetDao;
  67 import org.broadleafcommerce.cms.file.domain.ImageStaticAsset;
  68 import org.broadleafcommerce.cms.file.domain.ImageStaticAssetImpl;
  69 import org.broadleafcommerce.cms.file.domain.StaticAsset;
  70 import org.broadleafcommerce.cms.file.domain.StaticAssetImpl;
  71 import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  72 import org.broadleafcommerce.common.file.service.StaticAssetPathService;
  73 import org.broadleafcommerce.common.util.StringUtil;
  74 import org.broadleafcommerce.common.util.TransactionUtils;
  75 import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageArtifactProcessor;
  76 import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageMetadata;
  77 import org.springframework.beans.factory.annotation.Value;
  78 import org.springframework.stereotype.Service;
  79 import org.springframework.transaction.annotation.Transactional;
  80 import org.springframework.web.multipart.MultipartFile;
  81 
  82 import java.io.IOException;
  83 import java.io.InputStream;
  84 import java.io.UnsupportedEncodingException;
  85 import java.net.URLDecoder;
  86 import java.util.Arrays;
  87 import java.util.HashMap;
  88 import java.util.List;
  89 import java.util.Map;
  90 import java.util.Random;
  91 
  92 import javax.annotation.Resource;
  93 
  94 /**
  95  * Created by bpolster.
  96  */
  97 @Service(&quot;blStaticAssetService&quot;)
  98 public class StaticAssetServiceImpl implements StaticAssetService {
  99 
 100     private static final Log LOG = LogFactory.getLog(StaticAssetServiceImpl.class);
<abbr title=" 101     private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extension type of file.&quot;;"> 101     private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extensionðŸ”µ</abbr>
 102 
 103     @Resource(name = &quot;blImageArtifactProcessor&quot;)
 104     protected ImageArtifactProcessor imageArtifactProcessor;
 105 
 106     @Value(&quot;${asset.use.filesystem.storage}&quot;)
 107     protected boolean storeAssetsOnFileSystem = false;
 108 
 109     @Resource(name = &quot;blStaticAssetDao&quot;)
 110     protected StaticAssetDao staticAssetDao;
 111 
 112     @Resource(name = &quot;blStaticAssetStorageService&quot;)
 113     protected StaticAssetStorageService staticAssetStorageService;
 114 
 115     @Resource(name = &quot;blStaticAssetPathService&quot;)
 116     protected StaticAssetPathService staticAssetPathService;
 117 
 118     @Resource(name = &quot;blStaticAssetMultiTenantExtensionManager&quot;)
 119     protected StaticAssetMultiTenantExtensionManager staticAssetExtensionManager;
 120 
 121     @Value(&quot;${should.accept.non.image.asset:true}&quot;)
 122     protected boolean shouldAcceptNonImageAsset;
 123 
 124     @Value(&quot;${disabled.file.extensions}&quot;)
 125     protected String disabledFileExtensions;
 126 
 127     private final Random random = new Random();
 128     private final String FILE_NAME_CHARS = &quot;0123456789abcdef&quot;;
 129 
 130     @Value(&quot;${static.asset.invalid.chars.in.filename}&quot;)
 131     protected char[] notAllowedCharsInFileName;
 132 
 133     @Value(&quot;${static.asset.exception.on.invalid.char.in.filename:false}&quot;)
 134     protected boolean exceptionOnInvalidChar = false;
 135 
 136     @Value(&quot;${static.asset.invalid.chars.replacement}&quot;)
 137     protected String replacementString;
 138 
 139     @Override
 140     public StaticAsset findStaticAssetById(Long id) {
 141         return staticAssetDao.readStaticAssetById(id);
 142     }
 143 
 144     @Override
 145     public List&lt;StaticAsset&gt; readAllStaticAssets() {
 146         return staticAssetDao.readAllStaticAssets();
 147     }
 148 
 149     @Override
 150     public Long findTotalStaticAssetCount() {
 151         return staticAssetDao.readTotalStaticAssetCount();
 152     }
 153 
 154     protected String getFileExtension(String fileName) {
 155         int pos = fileName.lastIndexOf(&quot;.&quot;);
 156         if (pos &gt; 0) {
 157             return fileName.substring(pos + 1, fileName.length()).toLowerCase();
 158         } else {
 159             LOG.warn(&quot;No extension provided for asset : &quot; + StringUtil.sanitize(fileName));
 160             return null;
 161         }
 162     }
 163 
 164     /**
 165      * Generates a filename as a set of Hex digits.
 166      *
 167      * @param size
 168      * @return
 169      */
 170     protected String generateFileName(int size) {
 171         StringBuilder sb = new StringBuilder();
 172         for (int i = 0; i &lt; size; i++) {
 173             int pos = random.nextInt(FILE_NAME_CHARS.length());
 174             sb = sb.append(FILE_NAME_CHARS.charAt(pos));
 175         }
 176         return sb.toString();
 177     }
 178 
 179     /**
 180      * Will assemble the url from the passed in properties as
 181      * /{entityType}/{fileName}
 182      * /product/7001-ab12
 183      * &lt;p&gt;
 184      * If the properties above are not set, it will generate the fileName randomly.
 185      *
 186      * @param url
 187      * @param asset
 188      * @param assetProperties
 189      * @return
 190      */
 191     protected String buildAssetURL(Map&lt;String, String&gt; assetProperties, String originalFilename) {
 192         StringBuilder path = new StringBuilder(&quot;/&quot;);
 193 
 194         String entityType = assetProperties.get(&quot;entityType&quot;);
 195         String entityId = assetProperties.get(&quot;entityId&quot;);
 196         String fileName = assetProperties.get(&quot;fileName&quot;);
 197 
 198         if (entityType != null &amp;&amp; !&quot;null&quot;.equals(entityType)) {
 199             path = path.append(entityType).append(&quot;/&quot;);
 200         }
 201 
 202         if (entityId != null &amp;&amp; !&quot;null&quot;.equals(entityId)) {
 203             path = path.append(entityId).append(&quot;/&quot;);
 204         }
 205 
 206         if (fileName != null) {
 207             int pos = fileName.indexOf(&quot;:&quot;);
 208             if (pos &gt; 0) {
 209                 if (LOG.isTraceEnabled()) {
 210                     LOG.trace(&quot;Removing protocol from URL name&quot; + StringUtil.sanitize(fileName));
 211                 }
 212                 fileName = fileName.substring(pos + 1);
 213             }
 214         } else {
 215             fileName = originalFilename;
 216         }
 217 
 218         return path.append(fileName).toString();
 219     }
 220 
 221     private static String normalizeFileExtension(MultipartFile file) {
 222         int index = file.getOriginalFilename().lastIndexOf(&quot;.&quot;);
<abbr title=" 223         return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(index + 1, file.getOriginalFilename().length()).toLowerCase();"> 223         return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(ðŸ”µ</abbr>
 224     }
 225 
 226     private static String getFileExtension(MultipartFile file) {
 227         String tikaExtension = null;
 228         try {
 229             final Tika tika = new Tika();
 230             final MimeTypes allTypes = MimeTypes.getDefaultMimeTypes();
 231             final String detectedType;
 232             detectedType = tika.detect(file.getBytes());
 233             if (detectedType != null &amp;&amp; !detectedType.isEmpty()) {
 234                 final MimeType mimeType = allTypes.forName(detectedType);
 235                 tikaExtension = mimeType.getExtension().replace(&quot;.&quot;, &quot;&quot;).toLowerCase();
 236             }
 237         } catch (IOException | MimeTypeException ignored) {
 238         }
<abbr title=" 239         return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtension(file.getOriginalFilename());"> 239         return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtðŸ”µ</abbr>
 240     }
 241 
 242     public void validateFileExtension(MultipartFile file) throws IOException {
 243         final String extension = getFileExtension(file);
 244         if (disabledFileExtensions != null &amp;&amp; !disabledFileExtensions.isEmpty()) {
<abbr title=" 245             final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\s*,\\s*&quot;));"> 245             final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\sðŸ”µ</abbr>
 246             LOG.info(&quot;Disabled file extensions:&quot; + disabledFileExtensions);
 247             if (extensions.contains(extension)) {
 248                 LOG.error(&quot;Invalid extension type of file &quot; + file.getName());
 249                 throw new IOException(&quot;Invalid extension type of file.&quot;);
 250             }
 251         }
 252     }
 253 
 254     @Override
 255     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 256     public StaticAsset createStaticAssetFromFile(MultipartFile file, Map&lt;String, String&gt; properties) {
 257         try {
 258             validateFileExtension(file);
 259             staticAssetStorageService.validateFileSize(file);
 260             String fileName = normalizeFileExtension(file);
 261             boolean b = validateFileName(fileName);
 262             if(b){
<abbr title=" 263                 fileName = fileName.replaceAll(&quot;[&quot; + String.valueOf(notAllowedCharsInFileName) + &quot;]&quot;, replacementString);"> 263                 fileName = fileName.replaceAll(&quot;[&quot; + String.valueOf(notAllowedCharsInFileName) + &quot;]&quot;, repðŸ”µ</abbr>
 264             }
 265             return createStaticAsset(file.getInputStream(), fileName, file.getSize(), properties);
 266         } catch (IOException e) {
 267             throw new RuntimeException(e);
 268         }
 269     }
 270 
 271     protected boolean validateFileName(String fileName) {
 272         boolean result = StringUtils.containsAny(fileName, notAllowedCharsInFileName);
 273         if(exceptionOnInvalidChar &amp;&amp; result){
<abbr title=" 274             throw new RuntimeException(&quot;File contains illegal chars. Illegal chars are:[&quot; + String.valueOf(notAllowedCharsInFileName)+&quot;]&quot;);"> 274             throw new RuntimeException(&quot;File contains illegal chars. Illegal chars are:[&quot; + String.valueOðŸ”µ</abbr>
 275         }
 276         return result;
 277     }
 278 
 279     @Override
 280     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
<abbr title=" 281     public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;String, String&gt; properties) {"> 281     public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;StrðŸ”µ</abbr>
 282         if (properties == null) {
 283             properties = new HashMap&lt;String, String&gt;();
 284         }
 285 
 286         String fullUrl = buildAssetURL(properties, fileName);
 287         StringBuilder urlBuilder = new StringBuilder();
 288         urlBuilder.append(fullUrl);
<abbr title=" 289         ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicateAssetURL(urlBuilder);"> 289         ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicaðŸ”µ</abbr>
 290         fullUrl = urlBuilder.toString();
 291         StaticAsset newAsset = staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 292         // If no ExtensionManager modified the URL to handle duplicates, then go ahead and run default
 293         // logic for handling duplicate files.
 294         if (resultStatusType != ExtensionResultStatusType.HANDLED) {
 295             int count = 0;
 296             while (newAsset != null) {
 297                 count++;
 298                 //try the new format first, then the old
 299                 newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, false));
 300                 if (newAsset == null) {
<abbr title=" 301                     newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, true));"> 301                     newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, true))ðŸ”µ</abbr>
 302                 }
 303             }
 304 
 305             if (count &gt; 0) {
 306                 fullUrl = getCountUrl(fullUrl, count, false);
 307             }
 308         }
 309 
 310         try {
 311             ImageMetadata metadata = imageArtifactProcessor.getImageMetadata(inputStream);
 312             newAsset = new ImageStaticAssetImpl();
 313             ((ImageStaticAsset) newAsset).setWidth(metadata.getWidth());
 314             ((ImageStaticAsset) newAsset).setHeight(metadata.getHeight());
 315         } catch (Exception e) {
 316             //must not be an image stream
 317             LOG.warn(&quot;unable to convert asset:&quot; + fileName + &quot; into Image&quot;);
 318             LOG.debug(e);
 319 
 320             if (getShouldAcceptNonImageAsset()) {
 321                 newAsset = createNonImageAsset(inputStream, fileName, properties);
 322             } else {
 323                 throw new RuntimeException(&quot;Selected Asset/File was not valid image.&quot;);
 324             }
 325         }
 326         if (storeAssetsOnFileSystem) {
 327             newAsset.setStorageType(StorageType.FILESYSTEM);
 328         } else {
 329             newAsset.setStorageType(StorageType.DATABASE);
 330         }
 331 
 332         newAsset.setName(fileName);
 333         getMimeType(inputStream, fileName, newAsset);
 334         newAsset.setFileExtension(getFileExtension(fileName));
 335         newAsset.setFileSize(fileSize);
 336         newAsset.setFullUrl(fullUrl);
 337 
 338         return staticAssetDao.addOrUpdateStaticAsset(newAsset, false);
 339     }
 340 
 341     /**
 342      * Hook-point for implementors to add custom business logic for handling files that are non-images
 343      *
 344      * @param inputStream
 345      * @param fileName
 346      * @param properties
 347      * @return
 348      */
<abbr title=" 349     protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, String&gt; properties) {"> 349     protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, StrinðŸ”µ</abbr>
 350         return new StaticAssetImpl();
 351     }
 352 
 353     /**
<abbr title=" 354      * Gets the count URL based on the original fullUrl. If requested in legacy format this will return URLs like:"> 354      * Gets the count URL based on the original fullUrl. If requested in legacy format this will return UðŸ”µ</abbr>
 355      * &lt;p&gt;
 356      * /path/to/image.jpg-1
 357      * /path/to/image.jpg-2
 358      * &lt;p&gt;
 359      * Whereas if this is in non-legacy format (&lt;b&gt;legacy&lt;/b&gt; == false):
 360      * &lt;p&gt;
 361      * /path/to/image-1.jpg
 362      * /path/to/image-2.jpg
 363      * &lt;p&gt;
 364      * Used to deal with duplicate URLs of uploaded assets
 365      */
 366     protected String getCountUrl(String fullUrl, int count, boolean legacyFormat) {
 367         String countUrl = fullUrl + &#x27;-&#x27; + count;
 368         int dotIndex = fullUrl.lastIndexOf(&#x27;.&#x27;);
 369         if (dotIndex != -1 &amp;&amp; !legacyFormat) {
<abbr title=" 370             countUrl = fullUrl.substring(0, dotIndex) + &#x27;-&#x27; + count + &#x27;.&#x27; + fullUrl.substring(dotIndex + 1);"> 370             countUrl = fullUrl.substring(0, dotIndex) + &#x27;-&#x27; + count + &#x27;.&#x27; + fullUrl.substring(dotIndex + ðŸ”µ</abbr>
 371         }
 372 
 373         return countUrl;
 374     }
 375 
 376     protected void getMimeType(InputStream inputStream, String fileName, StaticAsset newAsset) {
 377         Tika tika = new Tika();
 378         String tikaMimeType = tika.detect(fileName);
 379         if (tikaMimeType == null) {
 380             try {
 381                 tikaMimeType = tika.detect(inputStream);
 382             } catch (IOException e) {
 383                 //if tika can&#x27;t resolve, don&#x27;t throw exception
 384             }
 385         }
 386         if (tikaMimeType != null) {
 387             newAsset.setMimeType(tikaMimeType);
 388         }
 389     }
 390 
 391     @Override
 392     public StaticAsset findStaticAssetByFullUrl(String fullUrl) {
 393         try {
 394             fullUrl = URLDecoder.decode(fullUrl, &quot;UTF-8&quot;);
 395             //strip out the jsessionid if it&#x27;s there
 396             fullUrl = fullUrl.replaceAll(&quot;(?i);jsessionid.*?=.*?(?=\\?|$)&quot;, &quot;&quot;);
 397         } catch (UnsupportedEncodingException e) {
 398             throw new RuntimeException(&quot;Unsupported encoding to decode fullUrl&quot;, e);
 399         }
 400         return staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 401     }
 402 
 403     @Override
 404     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 405     public StaticAsset addStaticAsset(StaticAsset staticAsset) {
 406         StaticAsset newAsset = staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 407         return newAsset;
 408     }
 409 
 410     @Override
 411     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 412     public StaticAsset updateStaticAsset(StaticAsset staticAsset) {
 413         return staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 414     }
 415 
 416     @Override
 417     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 418     public void deleteStaticAsset(StaticAsset staticAsset) {
 419         staticAssetDao.delete(staticAsset);
 420     }
 421 
 422     @Override
 423     public String getStaticAssetUrlPrefix() {
 424         return staticAssetPathService.getStaticAssetUrlPrefix();
 425     }
 426 
 427     @Override
 428     public String getPrefixedStaticAssetUrl(String assetUrl) {
 429         String staticAssetUrlPrefix = getStaticAssetUrlPrefix();
 430         if (staticAssetUrlPrefix != null &amp;&amp; !staticAssetUrlPrefix.startsWith(&quot;/&quot;)) {
 431             staticAssetUrlPrefix = &quot;/&quot; + staticAssetUrlPrefix;
 432         }
 433         if (staticAssetUrlPrefix != null) {
 434             return staticAssetUrlPrefix + assetUrl;
 435         }
 436         return assetUrl;
 437     }
 438 
 439     @Override
 440     public String getStaticAssetEnvironmentUrlPrefix() {
 441         return staticAssetPathService.getStaticAssetEnvironmentUrlPrefix();
 442     }
 443 
 444     @Override
 445     public String getStaticAssetEnvironmentSecureUrlPrefix() {
 446         return staticAssetPathService.getStaticAssetEnvironmentSecureUrlPrefix();
 447     }
 448 
 449     @Override
 450     public String convertAssetPath(String assetPath, String contextPath, boolean secureRequest) {
 451         return staticAssetPathService.convertAssetPath(assetPath, contextPath, secureRequest);
 452     }
 453 
 454     public boolean getShouldAcceptNonImageAsset() {
 455         return shouldAcceptNonImageAsset;
 456     }
 457 
 458     public void setShouldAcceptNonImageAsset(boolean accept) {
 459         shouldAcceptNonImageAsset = accept;
 460     }
 461 }</pre></td>
                            <td><pre>   1 /*-
   2  * #%L
   3  * BroadleafCommerce CMS Module
   4  * %%
   5  * Copyright (C) 2009 - 2022 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 /*
  19  * BroadleafCommerce CMS Module
  20  * %%
  21  * Copyright (C) 2009 - 2016 Broadleaf Commerce
  22  * %%
  23  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
  24  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
  25  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  26  * the Broadleaf End User License Agreement (EULA), Version 1.1
  27  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  28  * shall apply.
  29  *
<abbr title="  30  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  30  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  31  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  31  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  32  * #L%
  33  */
  34 package org.broadleafcommerce.cms.file.service;
  35 
  36 import org.apache.commons.io.FilenameUtils;
  37 import org.apache.commons.lang3.StringUtils;
  38 import org.apache.commons.logging.Log;
  39 import org.apache.commons.logging.LogFactory;
  40 import org.apache.tika.Tika;
  41 import org.apache.tika.mime.MimeType;
  42 import org.apache.tika.mime.MimeTypeException;
  43 import org.apache.tika.mime.MimeTypes;
  44 import org.broadleafcommerce.cms.field.type.StorageType;
  45 import org.broadleafcommerce.cms.file.StaticAssetMultiTenantExtensionManager;
  46 import org.broadleafcommerce.cms.file.dao.StaticAssetDao;
  47 import org.broadleafcommerce.cms.file.domain.ImageStaticAsset;
  48 import org.broadleafcommerce.cms.file.domain.ImageStaticAssetImpl;
  49 import org.broadleafcommerce.cms.file.domain.StaticAsset;
  50 import org.broadleafcommerce.cms.file.domain.StaticAssetImpl;
  51 import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  52 import org.broadleafcommerce.common.file.service.StaticAssetPathService;
  53 import org.broadleafcommerce.common.util.StringUtil;
  54 import org.broadleafcommerce.common.util.TransactionUtils;
  55 import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageArtifactProcessor;
  56 import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageMetadata;
  57 import org.springframework.beans.factory.annotation.Value;
  58 import org.springframework.stereotype.Service;
  59 import org.springframework.transaction.annotation.Transactional;
  60 import org.springframework.web.multipart.MultipartFile;
  61 
  62 import java.io.IOException;
  63 import java.io.InputStream;
  64 import java.io.UnsupportedEncodingException;
  65 import java.net.URLDecoder;
  66 import java.util.Arrays;
  67 import java.util.HashMap;
  68 import java.util.List;
  69 import java.util.Map;
  70 import java.util.Random;
  71 
  72 import javax.annotation.Resource;
  73 
  74 /**
  75  * Created by bpolster.
  76  */
  77 @Service(&quot;blStaticAssetService&quot;)
  78 public class StaticAssetServiceImpl implements StaticAssetService {
  79 
  80     private static final Log LOG = LogFactory.getLog(StaticAssetServiceImpl.class);
<abbr title="  81     private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extension type of file.&quot;;">  81     private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extensionðŸ”µ</abbr>
  82 
  83     @Resource(name = &quot;blImageArtifactProcessor&quot;)
  84     protected ImageArtifactProcessor imageArtifactProcessor;
  85 
  86     @Value(&quot;${asset.use.filesystem.storage}&quot;)
  87     protected boolean storeAssetsOnFileSystem = false;
  88 
  89     @Resource(name = &quot;blStaticAssetDao&quot;)
  90     protected StaticAssetDao staticAssetDao;
  91 
  92     @Resource(name = &quot;blStaticAssetStorageService&quot;)
  93     protected StaticAssetStorageService staticAssetStorageService;
  94 
  95     @Resource(name = &quot;blStaticAssetPathService&quot;)
  96     protected StaticAssetPathService staticAssetPathService;
  97 
  98     @Resource(name = &quot;blStaticAssetMultiTenantExtensionManager&quot;)
  99     protected StaticAssetMultiTenantExtensionManager staticAssetExtensionManager;
 100 
 101     @Value(&quot;${should.accept.non.image.asset:true}&quot;)
 102     protected boolean shouldAcceptNonImageAsset;
 103 
 104     @Value(&quot;${disabled.file.extensions}&quot;)
 105     protected String disabledFileExtensions;
 106 
 107     private final Random random = new Random();
 108     private final String FILE_NAME_CHARS = &quot;0123456789abcdef&quot;;
 109 
 110     @Value(&quot;${static.asset.invalid.chars.in.filename}&quot;)
 111     protected char[] notAllowedCharsInFileName;
 112 
 113     @Value(&quot;${static.asset.exception.on.invalid.char.in.filename:false}&quot;)
 114     protected boolean exceptionOnInvalidChar = false;
 115 
 116     @Value(&quot;${static.asset.invalid.chars.replacement}&quot;)
 117     protected String replacementString;
 118 
 119     @Override
 120     public StaticAsset findStaticAssetById(Long id) {
 121         return staticAssetDao.readStaticAssetById(id);
 122     }
 123 
 124     @Override
 125     public List&lt;StaticAsset&gt; readAllStaticAssets() {
 126         return staticAssetDao.readAllStaticAssets();
 127     }
 128 
 129     @Override
 130     public Long findTotalStaticAssetCount() {
 131         return staticAssetDao.readTotalStaticAssetCount();
 132     }
 133 
 134     protected String getFileExtension(String fileName) {
 135         int pos = fileName.lastIndexOf(&quot;.&quot;);
 136         if (pos &gt; 0) {
 137             return fileName.substring(pos + 1, fileName.length()).toLowerCase();
 138         } else {
 139             LOG.warn(&quot;No extension provided for asset : &quot; + StringUtil.sanitize(fileName));
 140             return null;
 141         }
 142     }
 143 
 144     /**
 145      * Generates a filename as a set of Hex digits.
 146      *
 147      * @param size
 148      * @return
 149      */
 150     protected String generateFileName(int size) {
 151         StringBuilder sb = new StringBuilder();
 152         for (int i = 0; i &lt; size; i++) {
 153             int pos = random.nextInt(FILE_NAME_CHARS.length());
 154             sb = sb.append(FILE_NAME_CHARS.charAt(pos));
 155         }
 156         return sb.toString();
 157     }
 158 
 159     /**
 160      * Will assemble the url from the passed in properties as
 161      * /{entityType}/{fileName}
 162      * /product/7001-ab12
 163      * &lt;p&gt;
 164      * If the properties above are not set, it will generate the fileName randomly.
 165      *
 166      * @param url
 167      * @param asset
 168      * @param assetProperties
 169      * @return
 170      */
 171     protected String buildAssetURL(Map&lt;String, String&gt; assetProperties, String originalFilename) {
 172         StringBuilder path = new StringBuilder(&quot;/&quot;);
 173 
 174         String entityType = assetProperties.get(&quot;entityType&quot;);
 175         String entityId = assetProperties.get(&quot;entityId&quot;);
 176         String fileName = assetProperties.get(&quot;fileName&quot;);
 177 
 178         if (entityType != null &amp;&amp; !&quot;null&quot;.equals(entityType)) {
 179             path = path.append(entityType).append(&quot;/&quot;);
 180         }
 181 
 182         if (entityId != null &amp;&amp; !&quot;null&quot;.equals(entityId)) {
 183             path = path.append(entityId).append(&quot;/&quot;);
 184         }
 185 
 186         if (fileName != null) {
 187             int pos = fileName.indexOf(&quot;:&quot;);
 188             if (pos &gt; 0) {
 189                 if (LOG.isTraceEnabled()) {
 190                     LOG.trace(&quot;Removing protocol from URL name&quot; + StringUtil.sanitize(fileName));
 191                 }
 192                 fileName = fileName.substring(pos + 1);
 193             }
 194         } else {
 195             fileName = originalFilename;
 196         }
 197 
 198         return path.append(fileName).toString();
 199     }
 200 
 201     private static String normalizeFileExtension(MultipartFile file) {
 202         int index = file.getOriginalFilename().lastIndexOf(&quot;.&quot;);
<abbr title=" 203         return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(index + 1, file.getOriginalFilename().length()).toLowerCase();"> 203         return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(ðŸ”µ</abbr>
 204     }
 205 
 206     private static String getFileExtension(MultipartFile file) {
 207         String tikaExtension = null;
 208         try {
 209             final Tika tika = new Tika();
 210             final MimeTypes allTypes = MimeTypes.getDefaultMimeTypes();
 211             final String detectedType;
 212             detectedType = tika.detect(file.getBytes());
 213             if (detectedType != null &amp;&amp; !detectedType.isEmpty()) {
 214                 final MimeType mimeType = allTypes.forName(detectedType);
 215                 tikaExtension = mimeType.getExtension().replace(&quot;.&quot;, &quot;&quot;).toLowerCase();
 216             }
 217         } catch (IOException | MimeTypeException ignored) {
 218         }
<abbr title=" 219         return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtension(file.getOriginalFilename());"> 219         return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtðŸ”µ</abbr>
 220     }
 221 
 222     public void validateFileExtension(MultipartFile file) throws IOException {
 223         final String extension = getFileExtension(file);
 224         if (disabledFileExtensions != null &amp;&amp; !disabledFileExtensions.isEmpty()) {
<abbr title=" 225             final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\s*,\\s*&quot;));"> 225             final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\sðŸ”µ</abbr>
 226             LOG.info(&quot;Disabled file extensions:&quot; + disabledFileExtensions);
 227             if (extensions.contains(extension)) {
 228                 LOG.error(&quot;Invalid extension type of file &quot; + file.getName());
 229                 throw new IOException(&quot;Invalid extension type of file.&quot;);
 230             }
 231         }
 232     }
 233 
 234     @Override
 235     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 236     public StaticAsset createStaticAssetFromFile(MultipartFile file, Map&lt;String, String&gt; properties) {
 237         try {
 238             validateFileExtension(file);
 239             staticAssetStorageService.validateFileSize(file);
 240             String fileName = normalizeFileExtension(file);
 241             boolean b = validateFileName(fileName);
 242             if(b){
<abbr title=" 243                 fileName = fileName.replaceAll(&quot;[&quot; + String.valueOf(notAllowedCharsInFileName) + &quot;]&quot;, replacementString);"> 243                 fileName = fileName.replaceAll(&quot;[&quot; + String.valueOf(notAllowedCharsInFileName) + &quot;]&quot;, repðŸ”µ</abbr>
 244             }
 245             return createStaticAsset(file.getInputStream(), fileName, file.getSize(), properties);
 246         } catch (IOException e) {
 247             throw new RuntimeException(e);
 248         }
 249     }
 250 
 251     protected boolean validateFileName(String fileName) {
 252         boolean result = StringUtils.containsAny(fileName, notAllowedCharsInFileName);
 253         if(exceptionOnInvalidChar &amp;&amp; result){
<abbr title=" 254             throw new RuntimeException(&quot;File contains illegal chars. Illegal chars are:[&quot; + String.valueOf(notAllowedCharsInFileName)+&quot;]&quot;);"> 254             throw new RuntimeException(&quot;File contains illegal chars. Illegal chars are:[&quot; + String.valueOðŸ”µ</abbr>
 255         }
 256         return result;
 257     }
 258 
 259     @Override
 260     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
<abbr title=" 261     public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;String, String&gt; properties) {"> 261     public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;StrðŸ”µ</abbr>
 262         if (properties == null) {
 263             properties = new HashMap&lt;String, String&gt;();
 264         }
 265 
 266         String fullUrl = buildAssetURL(properties, fileName);
 267         StringBuilder urlBuilder = new StringBuilder();
 268         urlBuilder.append(fullUrl);
<abbr title=" 269         ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicateAssetURL(urlBuilder);"> 269         ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicaðŸ”µ</abbr>
 270         fullUrl = urlBuilder.toString();
 271         StaticAsset newAsset = staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 272         // If no ExtensionManager modified the URL to handle duplicates, then go ahead and run default
 273         // logic for handling duplicate files.
 274         if (resultStatusType != ExtensionResultStatusType.HANDLED) {
 275             int count = 0;
 276             while (newAsset != null) {
 277                 count++;
 278                 //try the new format first, then the old
 279                 newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, false));
 280                 if (newAsset == null) {
<abbr title=" 281                     newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, true));"> 281                     newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, true))ðŸ”µ</abbr>
 282                 }
 283             }
 284 
 285             if (count &gt; 0) {
 286                 fullUrl = getCountUrl(fullUrl, count, false);
 287             }
 288         }
 289 
 290         try {
 291             ImageMetadata metadata = imageArtifactProcessor.getImageMetadata(inputStream);
 292             newAsset = new ImageStaticAssetImpl();
 293             ((ImageStaticAsset) newAsset).setWidth(metadata.getWidth());
 294             ((ImageStaticAsset) newAsset).setHeight(metadata.getHeight());
 295         } catch (Exception e) {
 296             //must not be an image stream
 297             LOG.warn(&quot;unable to convert asset:&quot; + fileName + &quot; into Image&quot;);
 298             LOG.debug(e);
 299 
 300             if (getShouldAcceptNonImageAsset()) {
 301                 newAsset = createNonImageAsset(inputStream, fileName, properties);
 302             } else {
 303                 throw new RuntimeException(&quot;Selected Asset/File was not valid image.&quot;);
 304             }
 305         }
 306         if (storeAssetsOnFileSystem) {
 307             newAsset.setStorageType(StorageType.FILESYSTEM);
 308         } else {
 309             newAsset.setStorageType(StorageType.DATABASE);
 310         }
 311 
 312         newAsset.setName(fileName);
 313         getMimeType(inputStream, fileName, newAsset);
 314         newAsset.setFileExtension(getFileExtension(fileName));
 315         newAsset.setFileSize(fileSize);
 316         newAsset.setFullUrl(fullUrl);
 317 
 318         return staticAssetDao.addOrUpdateStaticAsset(newAsset, false);
 319     }
 320 
 321     /**
 322      * Hook-point for implementors to add custom business logic for handling files that are non-images
 323      *
 324      * @param inputStream
 325      * @param fileName
 326      * @param properties
 327      * @return
 328      */
<abbr title=" 329     protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, String&gt; properties) {"> 329     protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, StrinðŸ”µ</abbr>
 330         return new StaticAssetImpl();
 331     }
 332 
 333     /**
<abbr title=" 334      * Gets the count URL based on the original fullUrl. If requested in legacy format this will return URLs like:"> 334      * Gets the count URL based on the original fullUrl. If requested in legacy format this will return UðŸ”µ</abbr>
 335      * &lt;p&gt;
 336      * /path/to/image.jpg-1
 337      * /path/to/image.jpg-2
 338      * &lt;p&gt;
 339      * Whereas if this is in non-legacy format (&lt;b&gt;legacy&lt;/b&gt; == false):
 340      * &lt;p&gt;
 341      * /path/to/image-1.jpg
 342      * /path/to/image-2.jpg
 343      * &lt;p&gt;
 344      * Used to deal with duplicate URLs of uploaded assets
 345      */
 346     protected String getCountUrl(String fullUrl, int count, boolean legacyFormat) {
 347         String countUrl = fullUrl + &#x27;-&#x27; + count;
 348         int dotIndex = fullUrl.lastIndexOf(&#x27;.&#x27;);
 349         if (dotIndex != -1 &amp;&amp; !legacyFormat) {
<abbr title=" 350             countUrl = fullUrl.substring(0, dotIndex) + &#x27;-&#x27; + count + &#x27;.&#x27; + fullUrl.substring(dotIndex + 1);"> 350             countUrl = fullUrl.substring(0, dotIndex) + &#x27;-&#x27; + count + &#x27;.&#x27; + fullUrl.substring(dotIndex + ðŸ”µ</abbr>
 351         }
 352 
 353         return countUrl;
 354     }
 355 
 356     protected void getMimeType(InputStream inputStream, String fileName, StaticAsset newAsset) {
 357         Tika tika = new Tika();
 358         String tikaMimeType = tika.detect(fileName);
 359         if (tikaMimeType == null) {
 360             try {
 361                 tikaMimeType = tika.detect(inputStream);
 362             } catch (IOException e) {
 363                 //if tika can&#x27;t resolve, don&#x27;t throw exception
 364             }
 365         }
 366         if (tikaMimeType != null) {
 367             newAsset.setMimeType(tikaMimeType);
 368         }
 369     }
 370 
 371     @Override
 372     public StaticAsset findStaticAssetByFullUrl(String fullUrl) {
 373         try {
 374             fullUrl = URLDecoder.decode(fullUrl, &quot;UTF-8&quot;);
 375             //strip out the jsessionid if it&#x27;s there
 376             fullUrl = fullUrl.replaceAll(&quot;(?i);jsessionid.*?=.*?(?=\\?|$)&quot;, &quot;&quot;);
 377         } catch (UnsupportedEncodingException e) {
 378             throw new RuntimeException(&quot;Unsupported encoding to decode fullUrl&quot;, e);
 379         }
 380         return staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 381     }
 382 
 383     @Override
 384     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 385     public StaticAsset addStaticAsset(StaticAsset staticAsset) {
 386         StaticAsset newAsset = staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 387         return newAsset;
 388     }
 389 
 390     @Override
 391     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 392     public StaticAsset updateStaticAsset(StaticAsset staticAsset) {
 393         return staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 394     }
 395 
 396     @Override
 397     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 398     public void deleteStaticAsset(StaticAsset staticAsset) {
 399         staticAssetDao.delete(staticAsset);
 400     }
 401 
 402     @Override
 403     public String getStaticAssetUrlPrefix() {
 404         return staticAssetPathService.getStaticAssetUrlPrefix();
 405     }
 406 
 407     @Override
 408     public String getPrefixedStaticAssetUrl(String assetUrl) {
 409         String staticAssetUrlPrefix = getStaticAssetUrlPrefix();
 410         if (staticAssetUrlPrefix != null &amp;&amp; !staticAssetUrlPrefix.startsWith(&quot;/&quot;)) {
 411             staticAssetUrlPrefix = &quot;/&quot; + staticAssetUrlPrefix;
 412         }
 413         if (staticAssetUrlPrefix != null) {
 414             return staticAssetUrlPrefix + assetUrl;
 415         }
 416         return assetUrl;
 417     }
 418 
 419     @Override
 420     public String getStaticAssetEnvironmentUrlPrefix() {
 421         return staticAssetPathService.getStaticAssetEnvironmentUrlPrefix();
 422     }
 423 
 424     @Override
 425     public String getStaticAssetEnvironmentSecureUrlPrefix() {
 426         return staticAssetPathService.getStaticAssetEnvironmentSecureUrlPrefix();
 427     }
 428 
 429     @Override
 430     public String convertAssetPath(String assetPath, String contextPath, boolean secureRequest) {
 431         return staticAssetPathService.convertAssetPath(assetPath, contextPath, secureRequest);
 432     }
 433 
 434     public boolean getShouldAcceptNonImageAsset() {
 435         return shouldAcceptNonImageAsset;
 436     }
 437 
 438     public void setShouldAcceptNonImageAsset(boolean accept) {
 439         shouldAcceptNonImageAsset = accept;
 440     }
 441 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*-
   2  * #%L
   3  * BroadleafCommerce CMS Module
   4  * %%
   5  * Copyright (C) 2009 - 2022 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.cms.file.service;
  19 
  20 import java.io.IOException;
  21 import java.io.InputStream;
  22 import java.io.UnsupportedEncodingException;
  23 import java.net.URLDecoder;
  24 import java.util.Arrays;
  25 import java.util.HashMap;
  26 import java.util.List;
  27 import java.util.Map;
  28 import java.util.Random;
  29 import javax.annotation.Resource;
  30 import org.apache.commons.io.FilenameUtils;
  31 import org.apache.commons.lang3.StringUtils;
  32 import org.apache.commons.logging.Log;
  33 import org.apache.commons.logging.LogFactory;
  34 import org.apache.tika.Tika;
  35 import org.apache.tika.mime.MimeType;
  36 import org.apache.tika.mime.MimeTypeException;
  37 import org.apache.tika.mime.MimeTypes;
  38 import org.broadleafcommerce.cms.field.type.StorageType;
  39 import org.broadleafcommerce.cms.file.StaticAssetMultiTenantExtensionManager;
  40 import org.broadleafcommerce.cms.file.dao.StaticAssetDao;
  41 import org.broadleafcommerce.cms.file.domain.ImageStaticAsset;
  42 import org.broadleafcommerce.cms.file.domain.ImageStaticAssetImpl;
  43 import org.broadleafcommerce.cms.file.domain.StaticAsset;
  44 import org.broadleafcommerce.cms.file.domain.StaticAssetImpl;
  45 import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  46 import org.broadleafcommerce.common.file.service.StaticAssetPathService;
  47 import org.broadleafcommerce.common.util.StringUtil;
  48 import org.broadleafcommerce.common.util.TransactionUtils;
  49 import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageArtifactProcessor;
  50 import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageMetadata;
  51 import org.springframework.beans.factory.annotation.Value;
  52 import org.springframework.stereotype.Service;
  53 import org.springframework.transaction.annotation.Transactional;
  54 import org.springframework.web.multipart.MultipartFile;
  55 
  56 
  57 /**
  58  * Created by bpolster.
  59  */
  60 @Service(&quot;blStaticAssetService&quot;)
  61 public class StaticAssetServiceImpl implements StaticAssetService {
  62     private static final Log LOG = LogFactory.getLog(StaticAssetServiceImpl.class);
  63 
<abbr title="  64     private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extension type of file.&quot;;">  64     private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extensionðŸ”µ</abbr>
  65 
  66     @Resource(name = &quot;blImageArtifactProcessor&quot;)
  67     protected ImageArtifactProcessor imageArtifactProcessor;
  68 
  69     @Value(&quot;${asset.use.filesystem.storage}&quot;)
  70     protected boolean storeAssetsOnFileSystem = false;
  71 
  72     @Resource(name = &quot;blStaticAssetDao&quot;)
  73     protected StaticAssetDao staticAssetDao;
  74 
  75     @Resource(name = &quot;blStaticAssetStorageService&quot;)
  76     protected StaticAssetStorageService staticAssetStorageService;
  77 
  78     @Resource(name = &quot;blStaticAssetPathService&quot;)
  79     protected StaticAssetPathService staticAssetPathService;
  80 
  81     @Resource(name = &quot;blStaticAssetMultiTenantExtensionManager&quot;)
  82     protected StaticAssetMultiTenantExtensionManager staticAssetExtensionManager;
  83 
  84     @Value(&quot;${should.accept.non.image.asset:true}&quot;)
  85     protected boolean shouldAcceptNonImageAsset;
  86 
  87     @Value(&quot;${disabled.file.extensions}&quot;)
  88     protected String disabledFileExtensions;
  89 
  90     private final Random random = new Random();
  91 
  92     private final String FILE_NAME_CHARS = &quot;0123456789abcdef&quot;;
  93 
  94     @Value(&quot;${static.asset.invalid.chars.in.filename}&quot;)
  95     protected char[] notAllowedCharsInFileName;
  96 
  97     @Value(&quot;${static.asset.exception.on.invalid.char.in.filename:false}&quot;)
  98     protected boolean exceptionOnInvalidChar = false;
  99 
 100     @Value(&quot;${static.asset.invalid.chars.replacement}&quot;)
 101     protected String replacementString;
 102 
 103     @Override
 104     public StaticAsset findStaticAssetById(Long id) {
 105         return staticAssetDao.readStaticAssetById(id);
 106     }
 107 
 108     @Override
 109     public List&lt;StaticAsset&gt; readAllStaticAssets() {
 110         return staticAssetDao.readAllStaticAssets();
 111     }
 112 
 113     @Override
 114     public Long findTotalStaticAssetCount() {
 115         return staticAssetDao.readTotalStaticAssetCount();
 116     }
 117 
 118     protected String getFileExtension(String fileName) {
 119         int pos = fileName.lastIndexOf(&quot;.&quot;);
 120         if (pos &gt; 0) {
 121             return fileName.substring(pos + 1, fileName.length()).toLowerCase();
 122         } else {
 123             LOG.warn(&quot;No extension provided for asset : &quot; + StringUtil.sanitize(fileName));
 124             return null;
 125         }
 126     }
 127 
 128     /**
 129      * Generates a filename as a set of Hex digits.
 130      *
 131      * @param size
 132      *
 133      * @return
 134      */
 135     protected String generateFileName(int size) {
 136         StringBuilder sb = new StringBuilder();
 137         for (int i = 0; i &lt; size; i++) {
 138             int pos = random.nextInt(FILE_NAME_CHARS.length());
 139             sb = sb.append(FILE_NAME_CHARS.charAt(pos));
 140         }
 141         return sb.toString();
 142     }
 143 
 144     /**
 145      * Will assemble the url from the passed in properties as
 146      * /{entityType}/{fileName}
 147      * /product/7001-ab12
 148      * &lt;p&gt;
 149      * If the properties above are not set, it will generate the fileName randomly.
 150      *
 151      * @param url
 152      *
 153      * @param asset
 154      *
 155      * @param assetProperties
 156      *
 157      * @return
 158      */
 159     protected String buildAssetURL(Map&lt;String, String&gt; assetProperties, String originalFilename) {
 160         StringBuilder path = new StringBuilder(&quot;/&quot;);
 161         String entityType = assetProperties.get(&quot;entityType&quot;);
 162         String entityId = assetProperties.get(&quot;entityId&quot;);
 163         String fileName = assetProperties.get(&quot;fileName&quot;);
 164         if ((entityType != null) &amp;&amp; (!&quot;null&quot;.equals(entityType))) {
 165             path = path.append(entityType).append(&quot;/&quot;);
 166         }
 167         if ((entityId != null) &amp;&amp; (!&quot;null&quot;.equals(entityId))) {
 168             path = path.append(entityId).append(&quot;/&quot;);
 169         }
 170         if (fileName != null) {
 171             int pos = fileName.indexOf(&quot;:&quot;);
 172             if (pos &gt; 0) {
 173                 if (LOG.isTraceEnabled()) {
 174                     LOG.trace(&quot;Removing protocol from URL name&quot; + StringUtil.sanitize(fileName));
 175                 }
 176                 fileName = fileName.substring(pos + 1);
 177             }
 178         } else {
 179             fileName = originalFilename;
 180         }
 181         return path.append(fileName).toString();
 182     }
 183 
 184     private static String normalizeFileExtension(MultipartFile file) {
 185         int index = file.getOriginalFilename().lastIndexOf(&quot;.&quot;);
<abbr title=" 186         return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(index + 1, file.getOriginalFilename().length()).toLowerCase();"> 186         return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(ðŸ”µ</abbr>
 187     }
 188 
 189     private static String getFileExtension(MultipartFile file) {
 190         String tikaExtension = null;
 191         try {
 192             final Tika tika = new Tika();
 193             final MimeTypes allTypes = MimeTypes.getDefaultMimeTypes();
 194             final String detectedType;
 195             detectedType = tika.detect(file.getBytes());
 196             if ((detectedType != null) &amp;&amp; (!detectedType.isEmpty())) {
 197                 final MimeType mimeType = allTypes.forName(detectedType);
 198                 tikaExtension = mimeType.getExtension().replace(&quot;.&quot;, &quot;&quot;).toLowerCase();
 199             }
 200         } catch (IOException | MimeTypeException ignored) {
 201         }
<abbr title=" 202         return (tikaExtension != null) &amp;&amp; (!tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtension(file.getOriginalFilename());"> 202         return (tikaExtension != null) &amp;&amp; (!tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getEðŸ”µ</abbr>
 203     }
 204 
 205     public void validateFileExtension(MultipartFile file) throws IOException {
 206         final String extension = getFileExtension(file);
 207         if ((disabledFileExtensions != null) &amp;&amp; (!disabledFileExtensions.isEmpty())) {
<abbr title=" 208             final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\s*,\\s*&quot;));"> 208             final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\sðŸ”µ</abbr>
 209             LOG.info(&quot;Disabled file extensions:&quot; + disabledFileExtensions);
 210             if (extensions.contains(extension)) {
 211                 LOG.error(&quot;Invalid extension type of file &quot; + file.getName());
 212                 throw new IOException(&quot;Invalid extension type of file.&quot;);
 213             }
 214         }
 215     }
 216 
 217     @Override
 218     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 219     public StaticAsset createStaticAssetFromFile(MultipartFile file, Map&lt;String, String&gt; properties) {
 220         try {
 221             validateFileExtension(file);
 222             staticAssetStorageService.validateFileSize(file);
 223             String fileName = normalizeFileExtension(file);
 224             boolean b = validateFileName(fileName);
 225             if (b) {
<abbr title=" 226                 fileName = fileName.replaceAll((&quot;[&quot; + String.valueOf(notAllowedCharsInFileName)) + &quot;]&quot;, replacementString);"> 226                 fileName = fileName.replaceAll((&quot;[&quot; + String.valueOf(notAllowedCharsInFileName)) + &quot;]&quot;, rðŸ”µ</abbr>
 227             }
 228             return createStaticAsset(file.getInputStream(), fileName, file.getSize(), properties);
 229         } catch (IOException e) {
 230             throw new RuntimeException(e);
 231         }
 232     }
 233 
 234     protected boolean validateFileName(String fileName) {
 235         boolean result = StringUtils.containsAny(fileName, notAllowedCharsInFileName);
 236         if (exceptionOnInvalidChar &amp;&amp; result) {
<abbr title=" 237             throw new RuntimeException((&quot;File contains illegal chars. Illegal chars are:[&quot; + String.valueOf(notAllowedCharsInFileName)) + &quot;]&quot;);"> 237             throw new RuntimeException((&quot;File contains illegal chars. Illegal chars are:[&quot; + String.valueðŸ”µ</abbr>
 238         }
 239         return result;
 240     }
 241 
 242     @Override
 243     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
<abbr title=" 244     public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;String, String&gt; properties) {"> 244     public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;StrðŸ”µ</abbr>
 245         if (properties == null) {
 246             properties = new HashMap&lt;String, String&gt;();
 247         }
 248         String fullUrl = buildAssetURL(properties, fileName);
 249         StringBuilder urlBuilder = new StringBuilder();
 250         urlBuilder.append(fullUrl);
<abbr title=" 251         ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicateAssetURL(urlBuilder);"> 251         ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicaðŸ”µ</abbr>
 252         fullUrl = urlBuilder.toString();
 253         StaticAsset newAsset = staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 254         // If no ExtensionManager modified the URL to handle duplicates, then go ahead and run default
 255         // logic for handling duplicate files.
 256         if (resultStatusType != ExtensionResultStatusType.HANDLED) {
 257             int count = 0;
 258             while (newAsset != null) {
 259                 count++;
 260                 // try the new format first, then the old
 261                 newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, false));
 262                 if (newAsset == null) {
<abbr title=" 263                     newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, true));"> 263                     newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, true))ðŸ”µ</abbr>
 264                 }
 265             }
 266             if (count &gt; 0) {
 267                 fullUrl = getCountUrl(fullUrl, count, false);
 268             }
 269         }
 270         try {
 271             ImageMetadata metadata = imageArtifactProcessor.getImageMetadata(inputStream);
 272             newAsset = new ImageStaticAssetImpl();
 273             ((ImageStaticAsset) (newAsset)).setWidth(metadata.getWidth());
 274             ((ImageStaticAsset) (newAsset)).setHeight(metadata.getHeight());
 275         } catch (java.lang.Exception e) {
 276             // must not be an image stream
 277             LOG.warn((&quot;unable to convert asset:&quot; + fileName) + &quot; into Image&quot;);
 278             LOG.debug(e);
 279             if (getShouldAcceptNonImageAsset()) {
 280                 newAsset = createNonImageAsset(inputStream, fileName, properties);
 281             } else {
 282                 throw new RuntimeException(&quot;Selected Asset/File was not valid image.&quot;);
 283             }
 284         }
 285         if (storeAssetsOnFileSystem) {
 286             newAsset.setStorageType(StorageType.FILESYSTEM);
 287         } else {
 288             newAsset.setStorageType(StorageType.DATABASE);
 289         }
 290         newAsset.setName(fileName);
 291         getMimeType(inputStream, fileName, newAsset);
 292         newAsset.setFileExtension(getFileExtension(fileName));
 293         newAsset.setFileSize(fileSize);
 294         newAsset.setFullUrl(fullUrl);
 295         return staticAssetDao.addOrUpdateStaticAsset(newAsset, false);
 296     }
 297 
 298     /**
 299      * Hook-point for implementors to add custom business logic for handling files that are non-images
 300      *
 301      * @param inputStream
 302      *
 303      * @param fileName
 304      *
 305      * @param properties
 306      *
 307      * @return
 308      */
<abbr title=" 309     protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, String&gt; properties) {"> 309     protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, StrinðŸ”µ</abbr>
 310         return new StaticAssetImpl();
 311     }
 312 
 313     /**
<abbr title=" 314      * Gets the count URL based on the original fullUrl. If requested in legacy format this will return URLs like:"> 314      * Gets the count URL based on the original fullUrl. If requested in legacy format this will return UðŸ”µ</abbr>
 315      * &lt;p&gt;
 316      * /path/to/image.jpg-1
 317      * /path/to/image.jpg-2
 318      * &lt;p&gt;
 319      * Whereas if this is in non-legacy format (&lt;b&gt;legacy&lt;/b&gt; == false):
 320      * &lt;p&gt;
 321      * /path/to/image-1.jpg
 322      * /path/to/image-2.jpg
 323      * &lt;p&gt;
 324      * Used to deal with duplicate URLs of uploaded assets
 325      */
 326     protected String getCountUrl(String fullUrl, int count, boolean legacyFormat) {
 327         String countUrl = (fullUrl + &#x27;-&#x27;) + count;
 328         int dotIndex = fullUrl.lastIndexOf(&#x27;.&#x27;);
 329         if ((dotIndex != (-1)) &amp;&amp; (!legacyFormat)) {
<abbr title=" 330             countUrl = (((fullUrl.substring(0, dotIndex) + &#x27;-&#x27;) + count) + &#x27;.&#x27;) + fullUrl.substring(dotIndex + 1);"> 330             countUrl = (((fullUrl.substring(0, dotIndex) + &#x27;-&#x27;) + count) + &#x27;.&#x27;) + fullUrl.substring(dotInðŸ”µ</abbr>
 331         }
 332         return countUrl;
 333     }
 334 
 335     protected void getMimeType(InputStream inputStream, String fileName, StaticAsset newAsset) {
 336         Tika tika = new Tika();
 337         String tikaMimeType = tika.detect(fileName);
 338         if (tikaMimeType == null) {
 339             try {
 340                 tikaMimeType = tika.detect(inputStream);
 341             } catch (IOException e) {
 342                 // if tika can&#x27;t resolve, don&#x27;t throw exception
 343             }
 344         }
 345         if (tikaMimeType != null) {
 346             newAsset.setMimeType(tikaMimeType);
 347         }
 348     }
 349 
 350     @Override
 351     public StaticAsset findStaticAssetByFullUrl(String fullUrl) {
 352         try {
 353             fullUrl = URLDecoder.decode(fullUrl, &quot;UTF-8&quot;);
 354             // strip out the jsessionid if it&#x27;s there
 355             fullUrl = fullUrl.replaceAll(&quot;(?i);jsessionid.*?=.*?(?=\\?|$)&quot;, &quot;&quot;);
 356         } catch (UnsupportedEncodingException e) {
 357             throw new RuntimeException(&quot;Unsupported encoding to decode fullUrl&quot;, e);
 358         }
 359         return staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 360     }
 361 
 362     @Override
 363     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 364     public StaticAsset addStaticAsset(StaticAsset staticAsset) {
 365         StaticAsset newAsset = staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 366         return newAsset;
 367     }
 368 
 369     @Override
 370     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 371     public StaticAsset updateStaticAsset(StaticAsset staticAsset) {
 372         return staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 373     }
 374 
 375     @Override
 376     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 377     public void deleteStaticAsset(StaticAsset staticAsset) {
 378         staticAssetDao.delete(staticAsset);
 379     }
 380 
 381     @Override
 382     public String getStaticAssetUrlPrefix() {
 383         return staticAssetPathService.getStaticAssetUrlPrefix();
 384     }
 385 
 386     @Override
 387     public String getPrefixedStaticAssetUrl(String assetUrl) {
 388         String staticAssetUrlPrefix = getStaticAssetUrlPrefix();
 389         if ((staticAssetUrlPrefix != null) &amp;&amp; (!staticAssetUrlPrefix.startsWith(&quot;/&quot;))) {
 390             staticAssetUrlPrefix = &quot;/&quot; + staticAssetUrlPrefix;
 391         }
 392         if (staticAssetUrlPrefix != null) {
 393             return staticAssetUrlPrefix + assetUrl;
 394         }
 395         return assetUrl;
 396     }
 397 
 398     @Override
 399     public String getStaticAssetEnvironmentUrlPrefix() {
 400         return staticAssetPathService.getStaticAssetEnvironmentUrlPrefix();
 401     }
 402 
 403     @Override
 404     public String getStaticAssetEnvironmentSecureUrlPrefix() {
 405         return staticAssetPathService.getStaticAssetEnvironmentSecureUrlPrefix();
 406     }
 407 
 408     @Override
 409     public String convertAssetPath(String assetPath, String contextPath, boolean secureRequest) {
 410         return staticAssetPathService.convertAssetPath(assetPath, contextPath, secureRequest);
 411     }
 412 
 413     public boolean getShouldAcceptNonImageAsset() {
 414         return shouldAcceptNonImageAsset;
 415     }
 416 
 417     public void setShouldAcceptNonImageAsset(boolean accept) {
 418         shouldAcceptNonImageAsset = accept;
 419     }
 420 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre><span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">   1 -/*</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   2 +/*-</span>
   3   * #%L
   4   * BroadleafCommerce CMS Module
   5   * %%
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">   6 - * Copyright (C) 2009 - 2018 Broadleaf Commerce</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   7 + * Copyright (C) 2009 - 2022 Broadleaf Commerce</span>
   8   * %%
   9   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
  10   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
  11   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  12   * the Broadleaf End User License Agreement (EULA), Version 1.1
  13   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  14   * shall apply.
  15   *
<abbr title="  16   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  16   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  17   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  18   * #L%
  19   */
  20  /*
  21   * BroadleafCommerce CMS Module
  22   * %%
  23   * Copyright (C) 2009 - 2016 Broadleaf Commerce

  24   * %%
  25   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
  26   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
  27   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  28   * the Broadleaf End User License Agreement (EULA), Version 1.1
  29   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  30   * shall apply.
  31   *
<abbr title="  32   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  32   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  33   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  34   * #L%
  35   */
  36  package org.broadleafcommerce.cms.file.service;
  37  
  38  import org.apache.commons.io.FilenameUtils;
  39  import org.apache.commons.lang3.StringUtils;
  40  import org.apache.commons.logging.Log;
  41  import org.apache.commons.logging.LogFactory;
  42  import org.apache.tika.Tika;
  43  import org.apache.tika.mime.MimeType;
  44  import org.apache.tika.mime.MimeTypeException;
  45  import org.apache.tika.mime.MimeTypes;
  46  import org.broadleafcommerce.cms.field.type.StorageType;
  47  import org.broadleafcommerce.cms.file.StaticAssetMultiTenantExtensionManager;
  48  import org.broadleafcommerce.cms.file.dao.StaticAssetDao;
  49  import org.broadleafcommerce.cms.file.domain.ImageStaticAsset;
  50  import org.broadleafcommerce.cms.file.domain.ImageStaticAssetImpl;
  51  import org.broadleafcommerce.cms.file.domain.StaticAsset;
  52  import org.broadleafcommerce.cms.file.domain.StaticAssetImpl;
  53  import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  54  import org.broadleafcommerce.common.file.service.StaticAssetPathService;
  55  import org.broadleafcommerce.common.util.StringUtil;
  56  import org.broadleafcommerce.common.util.TransactionUtils;
  57  import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageArtifactProcessor;
  58  import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageMetadata;
  59  import org.springframework.beans.factory.annotation.Value;
  60  import org.springframework.stereotype.Service;
  61  import org.springframework.transaction.annotation.Transactional;
  62  import org.springframework.web.multipart.MultipartFile;
  63  
  64  import java.io.IOException;
  65  import java.io.InputStream;
  66  import java.io.UnsupportedEncodingException;
  67  import java.net.URLDecoder;
  68  import java.util.Arrays;
  69  import java.util.HashMap;
  70  import java.util.List;
  71  import java.util.Map;
  72  import java.util.Random;
  73  
  74  import javax.annotation.Resource;
  75  
  76  /**
  77   * Created by bpolster.
  78   */
  79  @Service(&quot;blStaticAssetService&quot;)
  80  public class StaticAssetServiceImpl implements StaticAssetService {
  81  
  82      private static final Log LOG = LogFactory.getLog(StaticAssetServiceImpl.class);
<abbr title="  83      private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extension type of file.&quot;;">  83      private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extension type of ðŸ”µ</abbr>
  84  
  85      @Resource(name = &quot;blImageArtifactProcessor&quot;)
  86      protected ImageArtifactProcessor imageArtifactProcessor;
  87  
  88      @Value(&quot;${asset.use.filesystem.storage}&quot;)
  89      protected boolean storeAssetsOnFileSystem = false;
  90  
  91      @Resource(name = &quot;blStaticAssetDao&quot;)
  92      protected StaticAssetDao staticAssetDao;
  93  
  94      @Resource(name = &quot;blStaticAssetStorageService&quot;)
  95      protected StaticAssetStorageService staticAssetStorageService;
  96  
  97      @Resource(name = &quot;blStaticAssetPathService&quot;)
  98      protected StaticAssetPathService staticAssetPathService;
  99  
 100      @Resource(name = &quot;blStaticAssetMultiTenantExtensionManager&quot;)
 101      protected StaticAssetMultiTenantExtensionManager staticAssetExtensionManager;
 102  
 103      @Value(&quot;${should.accept.non.image.asset:true}&quot;)
 104      protected boolean shouldAcceptNonImageAsset;
 105  
 106      @Value(&quot;${disabled.file.extensions}&quot;)
 107      protected String disabledFileExtensions;
 108  
 109      private final Random random = new Random();
 110      private final String FILE_NAME_CHARS = &quot;0123456789abcdef&quot;;
 111  
 112      @Value(&quot;${static.asset.invalid.chars.in.filename}&quot;)
 113      protected char[] notAllowedCharsInFileName;
 114  
 115      @Value(&quot;${static.asset.exception.on.invalid.char.in.filename:false}&quot;)
 116      protected boolean exceptionOnInvalidChar = false;
 117  
 118      @Value(&quot;${static.asset.invalid.chars.replacement}&quot;)
 119      protected String replacementString;
 120  
 121      @Override
 122      public StaticAsset findStaticAssetById(Long id) {
 123          return staticAssetDao.readStaticAssetById(id);
 124      }
 125  
 126      @Override
 127      public List&lt;StaticAsset&gt; readAllStaticAssets() {
 128          return staticAssetDao.readAllStaticAssets();
 129      }
 130  
 131      @Override
 132      public Long findTotalStaticAssetCount() {
 133          return staticAssetDao.readTotalStaticAssetCount();
 134      }
 135  
 136      protected String getFileExtension(String fileName) {
 137          int pos = fileName.lastIndexOf(&quot;.&quot;);
 138          if (pos &gt; 0) {
 139              return fileName.substring(pos + 1, fileName.length()).toLowerCase();
 140          } else {
 141              LOG.warn(&quot;No extension provided for asset : &quot; + StringUtil.sanitize(fileName));
 142              return null;
 143          }
 144      }
 145  
 146      /**
 147       * Generates a filename as a set of Hex digits.
 148       *
 149       * @param size
 150       * @return
 151       */
 152      protected String generateFileName(int size) {
 153          StringBuilder sb = new StringBuilder();
 154          for (int i = 0; i &lt; size; i++) {
 155              int pos = random.nextInt(FILE_NAME_CHARS.length());
 156              sb = sb.append(FILE_NAME_CHARS.charAt(pos));
 157          }
 158          return sb.toString();
 159      }
 160  
 161      /**
 162       * Will assemble the url from the passed in properties as
 163       * /{entityType}/{fileName}
 164       * /product/7001-ab12
 165       * &lt;p&gt;
 166       * If the properties above are not set, it will generate the fileName randomly.
 167       *
 168       * @param url
 169       * @param asset
 170       * @param assetProperties
 171       * @return
 172       */
 173      protected String buildAssetURL(Map&lt;String, String&gt; assetProperties, String originalFilename) {
 174          StringBuilder path = new StringBuilder(&quot;/&quot;);
 175  
 176          String entityType = assetProperties.get(&quot;entityType&quot;);
 177          String entityId = assetProperties.get(&quot;entityId&quot;);
 178          String fileName = assetProperties.get(&quot;fileName&quot;);
 179  
 180          if (entityType != null &amp;&amp; !&quot;null&quot;.equals(entityType)) {
 181              path = path.append(entityType).append(&quot;/&quot;);
 182          }
 183  
 184          if (entityId != null &amp;&amp; !&quot;null&quot;.equals(entityId)) {
 185              path = path.append(entityId).append(&quot;/&quot;);
 186          }
 187  
 188          if (fileName != null) {
 189              int pos = fileName.indexOf(&quot;:&quot;);
 190              if (pos &gt; 0) {
 191                  if (LOG.isTraceEnabled()) {
 192                      LOG.trace(&quot;Removing protocol from URL name&quot; + StringUtil.sanitize(fileName));
 193                  }
 194                  fileName = fileName.substring(pos + 1);
 195              }
 196          } else {
 197              fileName = originalFilename;
 198          }
 199  
 200          return path.append(fileName).toString();
 201      }
 202  
 203      private static String normalizeFileExtension(MultipartFile file) {
 204          int index = file.getOriginalFilename().lastIndexOf(&quot;.&quot;);
<abbr title=" 205          return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(index + 1, file.getOriginalFilename().length()).toLowerCase();"> 205          return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(index + 1ðŸ”µ</abbr>
 206      }
 207  
 208      private static String getFileExtension(MultipartFile file) {
 209          String tikaExtension = null;
 210          try {
 211              final Tika tika = new Tika();
 212              final MimeTypes allTypes = MimeTypes.getDefaultMimeTypes();
 213              final String detectedType;
 214              detectedType = tika.detect(file.getBytes());
 215              if (detectedType != null &amp;&amp; !detectedType.isEmpty()) {
 216                  final MimeType mimeType = allTypes.forName(detectedType);
 217                  tikaExtension = mimeType.getExtension().replace(&quot;.&quot;, &quot;&quot;).toLowerCase();
 218              }
 219          } catch (IOException | MimeTypeException ignored) {
 220          }
<abbr title=" 221          return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtension(file.getOriginalFilename());"> 221          return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtension(fiðŸ”µ</abbr>
 222      }
 223  
 224      public void validateFileExtension(MultipartFile file) throws IOException {
 225          final String extension = getFileExtension(file);
 226          if (disabledFileExtensions != null &amp;&amp; !disabledFileExtensions.isEmpty()) {
<abbr title=" 227              final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\s*,\\s*&quot;));"> 227              final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\s*,\\s*&quot;))ðŸ”µ</abbr>
 228              LOG.info(&quot;Disabled file extensions:&quot; + disabledFileExtensions);
 229              if (extensions.contains(extension)) {
 230                  LOG.error(&quot;Invalid extension type of file &quot; + file.getName());
 231                  throw new IOException(&quot;Invalid extension type of file.&quot;);
 232              }
 233          }
 234      }
 235  
 236      @Override
 237      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 238      public StaticAsset createStaticAssetFromFile(MultipartFile file, Map&lt;String, String&gt; properties) {
 239          try {
 240              validateFileExtension(file);
 241              staticAssetStorageService.validateFileSize(file);
 242              String fileName = normalizeFileExtension(file);
 243              boolean b = validateFileName(fileName);
 244              if(b){
<abbr title=" 245                  fileName = fileName.replaceAll(&quot;[&quot; + String.valueOf(notAllowedCharsInFileName) + &quot;]&quot;, replacementString);"> 245                  fileName = fileName.replaceAll(&quot;[&quot; + String.valueOf(notAllowedCharsInFileName) + &quot;]&quot;, replacementSðŸ”µ</abbr>
 246              }
 247              return createStaticAsset(file.getInputStream(), fileName, file.getSize(), properties);
 248          } catch (IOException e) {
 249              throw new RuntimeException(e);
 250          }
 251      }
 252  
 253      protected boolean validateFileName(String fileName) {
 254          boolean result = StringUtils.containsAny(fileName, notAllowedCharsInFileName);
 255          if(exceptionOnInvalidChar &amp;&amp; result){
<abbr title=" 256              throw new RuntimeException(&quot;File contains illegal chars. Illegal chars are:[&quot; + String.valueOf(notAllowedCharsInFileName)+&quot;]&quot;);"> 256              throw new RuntimeException(&quot;File contains illegal chars. Illegal chars are:[&quot; + String.valueOf(notAlloðŸ”µ</abbr>
 257          }
 258          return result;
 259      }
 260  
 261      @Override
 262      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
<abbr title=" 263      public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;String, String&gt; properties) {"> 263      public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;String, StriðŸ”µ</abbr>
 264          if (properties == null) {
 265              properties = new HashMap&lt;String, String&gt;();
 266          }
 267  
 268          String fullUrl = buildAssetURL(properties, fileName);
 269          StringBuilder urlBuilder = new StringBuilder();
 270          urlBuilder.append(fullUrl);
<abbr title=" 271          ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicateAssetURL(urlBuilder);"> 271          ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicateAssetURðŸ”µ</abbr>
 272          fullUrl = urlBuilder.toString();
 273          StaticAsset newAsset = staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 274          // If no ExtensionManager modified the URL to handle duplicates, then go ahead and run default
 275          // logic for handling duplicate files.
 276          if (resultStatusType != ExtensionResultStatusType.HANDLED) {
 277              int count = 0;
 278              while (newAsset != null) {
 279                  count++;
 280                  //try the new format first, then the old
 281                  newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, false));
 282                  if (newAsset == null) {
 283                      newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, true));
 284                  }
 285              }
 286  
 287              if (count &gt; 0) {
 288                  fullUrl = getCountUrl(fullUrl, count, false);
 289              }
 290          }
 291  
 292          try {
 293              ImageMetadata metadata = imageArtifactProcessor.getImageMetadata(inputStream);
 294              newAsset = new ImageStaticAssetImpl();
 295              ((ImageStaticAsset) newAsset).setWidth(metadata.getWidth());
 296              ((ImageStaticAsset) newAsset).setHeight(metadata.getHeight());
 297          } catch (Exception e) {
 298              //must not be an image stream
 299              LOG.warn(&quot;unable to convert asset:&quot; + fileName + &quot; into Image&quot;);
 300              LOG.debug(e);
 301  
 302              if (getShouldAcceptNonImageAsset()) {
 303                  newAsset = createNonImageAsset(inputStream, fileName, properties);
 304              } else {
 305                  throw new RuntimeException(&quot;Selected Asset/File was not valid image.&quot;);
 306              }
 307          }
 308          if (storeAssetsOnFileSystem) {
 309              newAsset.setStorageType(StorageType.FILESYSTEM);
 310          } else {
 311              newAsset.setStorageType(StorageType.DATABASE);
 312          }
 313  
 314          newAsset.setName(fileName);
 315          getMimeType(inputStream, fileName, newAsset);
 316          newAsset.setFileExtension(getFileExtension(fileName));
 317          newAsset.setFileSize(fileSize);
 318          newAsset.setFullUrl(fullUrl);
 319  
 320          return staticAssetDao.addOrUpdateStaticAsset(newAsset, false);
 321      }
 322  
 323      /**
 324       * Hook-point for implementors to add custom business logic for handling files that are non-images
 325       *
 326       * @param inputStream
 327       * @param fileName
 328       * @param properties
 329       * @return
 330       */
<abbr title=" 331      protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, String&gt; properties) {"> 331      protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, String&gt; properðŸ”µ</abbr>
 332          return new StaticAssetImpl();
 333      }
 334  
 335      /**
 336       * Gets the count URL based on the original fullUrl. If requested in legacy format this will return URLs like:
 337       * &lt;p&gt;
 338       * /path/to/image.jpg-1
 339       * /path/to/image.jpg-2
 340       * &lt;p&gt;
 341       * Whereas if this is in non-legacy format (&lt;b&gt;legacy&lt;/b&gt; == false):
 342       * &lt;p&gt;
 343       * /path/to/image-1.jpg
 344       * /path/to/image-2.jpg
 345       * &lt;p&gt;
 346       * Used to deal with duplicate URLs of uploaded assets
 347       */
 348      protected String getCountUrl(String fullUrl, int count, boolean legacyFormat) {
 349          String countUrl = fullUrl + &#x27;-&#x27; + count;
 350          int dotIndex = fullUrl.lastIndexOf(&#x27;.&#x27;);
 351          if (dotIndex != -1 &amp;&amp; !legacyFormat) {
 352              countUrl = fullUrl.substring(0, dotIndex) + &#x27;-&#x27; + count + &#x27;.&#x27; + fullUrl.substring(dotIndex + 1);
 353          }
 354  
 355          return countUrl;
 356      }
 357  
 358      protected void getMimeType(InputStream inputStream, String fileName, StaticAsset newAsset) {
 359          Tika tika = new Tika();
 360          String tikaMimeType = tika.detect(fileName);
 361          if (tikaMimeType == null) {
 362              try {
 363                  tikaMimeType = tika.detect(inputStream);
 364              } catch (IOException e) {
 365                  //if tika can&#x27;t resolve, don&#x27;t throw exception
 366              }
 367          }
 368          if (tikaMimeType != null) {
 369              newAsset.setMimeType(tikaMimeType);
 370          }
 371      }
 372  
 373      @Override
 374      public StaticAsset findStaticAssetByFullUrl(String fullUrl) {
 375          try {
 376              fullUrl = URLDecoder.decode(fullUrl, &quot;UTF-8&quot;);
 377              //strip out the jsessionid if it&#x27;s there
 378              fullUrl = fullUrl.replaceAll(&quot;(?i);jsessionid.*?=.*?(?=\\?|$)&quot;, &quot;&quot;);
 379          } catch (UnsupportedEncodingException e) {
 380              throw new RuntimeException(&quot;Unsupported encoding to decode fullUrl&quot;, e);
 381          }
 382          return staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 383      }
 384  
 385      @Override
 386      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 387      public StaticAsset addStaticAsset(StaticAsset staticAsset) {
 388          StaticAsset newAsset = staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 389          return newAsset;
 390      }
 391  
 392      @Override
 393      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 394      public StaticAsset updateStaticAsset(StaticAsset staticAsset) {
 395          return staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 396      }
 397  
 398      @Override
 399      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 400      public void deleteStaticAsset(StaticAsset staticAsset) {
 401          staticAssetDao.delete(staticAsset);
 402      }
 403  
 404      @Override
 405      public String getStaticAssetUrlPrefix() {
 406          return staticAssetPathService.getStaticAssetUrlPrefix();
 407      }
 408  
 409      @Override
 410      public String getPrefixedStaticAssetUrl(String assetUrl) {
 411          String staticAssetUrlPrefix = getStaticAssetUrlPrefix();
 412          if (staticAssetUrlPrefix != null &amp;&amp; !staticAssetUrlPrefix.startsWith(&quot;/&quot;)) {
 413              staticAssetUrlPrefix = &quot;/&quot; + staticAssetUrlPrefix;
 414          }
 415          if (staticAssetUrlPrefix != null) {
 416              return staticAssetUrlPrefix + assetUrl;
 417          }
 418          return assetUrl;
 419      }
 420  
 421      @Override
 422      public String getStaticAssetEnvironmentUrlPrefix() {
 423          return staticAssetPathService.getStaticAssetEnvironmentUrlPrefix();
 424      }
 425  
 426      @Override
 427      public String getStaticAssetEnvironmentSecureUrlPrefix() {
 428          return staticAssetPathService.getStaticAssetEnvironmentSecureUrlPrefix();
 429      }
 430  
 431      @Override
 432      public String convertAssetPath(String assetPath, String contextPath, boolean secureRequest) {
 433          return staticAssetPathService.convertAssetPath(assetPath, contextPath, secureRequest);
 434      }
 435  
 436      public boolean getShouldAcceptNonImageAsset() {
 437          return shouldAcceptNonImageAsset;
 438      }
 439  
 440      public void setShouldAcceptNonImageAsset(boolean accept) {
 441          shouldAcceptNonImageAsset = accept;
 442      }
 443  }</pre></td>
                            <td><pre><span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">   1 -/*</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   2 +/*-</span>
   3   * #%L
   4   * BroadleafCommerce CMS Module
   5   * %%
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">   6 - * Copyright (C) 2009 - 2018 Broadleaf Commerce</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">   7 - * %%</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">   8 - * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">   9 - * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  10 - * unless the restrictions on use therein are violated and require payment to Broadleaf in which case</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  11 - * the Broadleaf End User License Agreement (EULA), Version 1.1</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  12 - * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  13 - * shall apply.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  14 - *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  15 - * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  15 - * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  16 - * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  17 - * #L%</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  18 - */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  19 -/*</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  20 - * BroadleafCommerce CMS Module</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  21 - * %%</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  22 - * Copyright (C) 2009 - 2016 Broadleaf Commerce</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  23 + * Copyright (C) 2009 - 2022 Broadleaf Commerce</span>
  24   * %%
  25   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
  26   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
  27   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  28   * the Broadleaf End User License Agreement (EULA), Version 1.1
  29   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  30   * shall apply.
  31   *
<abbr title="  32   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  32   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  33   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  34   * #L%
  35   */
  36  package org.broadleafcommerce.cms.file.service;
  37  
  38  import org.apache.commons.io.FilenameUtils;
  39  import org.apache.commons.lang3.StringUtils;
  40  import org.apache.commons.logging.Log;
  41  import org.apache.commons.logging.LogFactory;
  42  import org.apache.tika.Tika;
  43  import org.apache.tika.mime.MimeType;
  44  import org.apache.tika.mime.MimeTypeException;
  45  import org.apache.tika.mime.MimeTypes;
  46  import org.broadleafcommerce.cms.field.type.StorageType;
  47  import org.broadleafcommerce.cms.file.StaticAssetMultiTenantExtensionManager;
  48  import org.broadleafcommerce.cms.file.dao.StaticAssetDao;
  49  import org.broadleafcommerce.cms.file.domain.ImageStaticAsset;
  50  import org.broadleafcommerce.cms.file.domain.ImageStaticAssetImpl;
  51  import org.broadleafcommerce.cms.file.domain.StaticAsset;
  52  import org.broadleafcommerce.cms.file.domain.StaticAssetImpl;
  53  import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  54  import org.broadleafcommerce.common.file.service.StaticAssetPathService;
  55  import org.broadleafcommerce.common.util.StringUtil;
  56  import org.broadleafcommerce.common.util.TransactionUtils;
  57  import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageArtifactProcessor;
  58  import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageMetadata;
  59  import org.springframework.beans.factory.annotation.Value;
  60  import org.springframework.stereotype.Service;
  61  import org.springframework.transaction.annotation.Transactional;
  62  import org.springframework.web.multipart.MultipartFile;
  63  
  64  import java.io.IOException;
  65  import java.io.InputStream;
  66  import java.io.UnsupportedEncodingException;
  67  import java.net.URLDecoder;
  68  import java.util.Arrays;
  69  import java.util.HashMap;
  70  import java.util.List;
  71  import java.util.Map;
  72  import java.util.Random;
  73  
  74  import javax.annotation.Resource;
  75  
  76  /**
  77   * Created by bpolster.
  78   */
  79  @Service(&quot;blStaticAssetService&quot;)
  80  public class StaticAssetServiceImpl implements StaticAssetService {
  81  
  82      private static final Log LOG = LogFactory.getLog(StaticAssetServiceImpl.class);
<abbr title="  83      private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extension type of file.&quot;;">  83      private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extension type of ðŸ”µ</abbr>
  84  
  85      @Resource(name = &quot;blImageArtifactProcessor&quot;)
  86      protected ImageArtifactProcessor imageArtifactProcessor;
  87  
  88      @Value(&quot;${asset.use.filesystem.storage}&quot;)
  89      protected boolean storeAssetsOnFileSystem = false;
  90  
  91      @Resource(name = &quot;blStaticAssetDao&quot;)
  92      protected StaticAssetDao staticAssetDao;
  93  
  94      @Resource(name = &quot;blStaticAssetStorageService&quot;)
  95      protected StaticAssetStorageService staticAssetStorageService;
  96  
  97      @Resource(name = &quot;blStaticAssetPathService&quot;)
  98      protected StaticAssetPathService staticAssetPathService;
  99  
 100      @Resource(name = &quot;blStaticAssetMultiTenantExtensionManager&quot;)
 101      protected StaticAssetMultiTenantExtensionManager staticAssetExtensionManager;
 102  
 103      @Value(&quot;${should.accept.non.image.asset:true}&quot;)
 104      protected boolean shouldAcceptNonImageAsset;
 105  
 106      @Value(&quot;${disabled.file.extensions}&quot;)
 107      protected String disabledFileExtensions;
 108  
 109      private final Random random = new Random();
 110      private final String FILE_NAME_CHARS = &quot;0123456789abcdef&quot;;
 111  
 112      @Value(&quot;${static.asset.invalid.chars.in.filename}&quot;)
 113      protected char[] notAllowedCharsInFileName;
 114  
 115      @Value(&quot;${static.asset.exception.on.invalid.char.in.filename:false}&quot;)
 116      protected boolean exceptionOnInvalidChar = false;
 117  
 118      @Value(&quot;${static.asset.invalid.chars.replacement}&quot;)
 119      protected String replacementString;
 120  
 121      @Override
 122      public StaticAsset findStaticAssetById(Long id) {
 123          return staticAssetDao.readStaticAssetById(id);
 124      }
 125  
 126      @Override
 127      public List&lt;StaticAsset&gt; readAllStaticAssets() {
 128          return staticAssetDao.readAllStaticAssets();
 129      }
 130  
 131      @Override
 132      public Long findTotalStaticAssetCount() {
 133          return staticAssetDao.readTotalStaticAssetCount();
 134      }
 135  
 136      protected String getFileExtension(String fileName) {
 137          int pos = fileName.lastIndexOf(&quot;.&quot;);
 138          if (pos &gt; 0) {
 139              return fileName.substring(pos + 1, fileName.length()).toLowerCase();
 140          } else {
 141              LOG.warn(&quot;No extension provided for asset : &quot; + StringUtil.sanitize(fileName));
 142              return null;
 143          }
 144      }
 145  
 146      /**
 147       * Generates a filename as a set of Hex digits.
 148       *
 149       * @param size
 150       * @return
 151       */
 152      protected String generateFileName(int size) {
 153          StringBuilder sb = new StringBuilder();
 154          for (int i = 0; i &lt; size; i++) {
 155              int pos = random.nextInt(FILE_NAME_CHARS.length());
 156              sb = sb.append(FILE_NAME_CHARS.charAt(pos));
 157          }
 158          return sb.toString();
 159      }
 160  
 161      /**
 162       * Will assemble the url from the passed in properties as
 163       * /{entityType}/{fileName}
 164       * /product/7001-ab12
 165       * &lt;p&gt;
 166       * If the properties above are not set, it will generate the fileName randomly.
 167       *
 168       * @param url
 169       * @param asset
 170       * @param assetProperties
 171       * @return
 172       */
 173      protected String buildAssetURL(Map&lt;String, String&gt; assetProperties, String originalFilename) {
 174          StringBuilder path = new StringBuilder(&quot;/&quot;);
 175  
 176          String entityType = assetProperties.get(&quot;entityType&quot;);
 177          String entityId = assetProperties.get(&quot;entityId&quot;);
 178          String fileName = assetProperties.get(&quot;fileName&quot;);
 179  
 180          if (entityType != null &amp;&amp; !&quot;null&quot;.equals(entityType)) {
 181              path = path.append(entityType).append(&quot;/&quot;);
 182          }
 183  
 184          if (entityId != null &amp;&amp; !&quot;null&quot;.equals(entityId)) {
 185              path = path.append(entityId).append(&quot;/&quot;);
 186          }
 187  
 188          if (fileName != null) {
 189              int pos = fileName.indexOf(&quot;:&quot;);
 190              if (pos &gt; 0) {
 191                  if (LOG.isTraceEnabled()) {
 192                      LOG.trace(&quot;Removing protocol from URL name&quot; + StringUtil.sanitize(fileName));
 193                  }
 194                  fileName = fileName.substring(pos + 1);
 195              }
 196          } else {
 197              fileName = originalFilename;
 198          }
 199  
 200          return path.append(fileName).toString();
 201      }
 202  
 203      private static String normalizeFileExtension(MultipartFile file) {
 204          int index = file.getOriginalFilename().lastIndexOf(&quot;.&quot;);
<abbr title=" 205          return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(index + 1, file.getOriginalFilename().length()).toLowerCase();"> 205          return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(index + 1ðŸ”µ</abbr>
 206      }
 207  
 208      private static String getFileExtension(MultipartFile file) {
 209          String tikaExtension = null;
 210          try {
 211              final Tika tika = new Tika();
 212              final MimeTypes allTypes = MimeTypes.getDefaultMimeTypes();
 213              final String detectedType;
 214              detectedType = tika.detect(file.getBytes());
 215              if (detectedType != null &amp;&amp; !detectedType.isEmpty()) {
 216                  final MimeType mimeType = allTypes.forName(detectedType);
 217                  tikaExtension = mimeType.getExtension().replace(&quot;.&quot;, &quot;&quot;).toLowerCase();
 218              }
 219          } catch (IOException | MimeTypeException ignored) {
 220          }
<abbr title=" 221          return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtension(file.getOriginalFilename());"> 221          return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtension(fiðŸ”µ</abbr>
 222      }
 223  
 224      public void validateFileExtension(MultipartFile file) throws IOException {
 225          final String extension = getFileExtension(file);
 226          if (disabledFileExtensions != null &amp;&amp; !disabledFileExtensions.isEmpty()) {
<abbr title=" 227              final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\s*,\\s*&quot;));"> 227              final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\s*,\\s*&quot;))ðŸ”µ</abbr>
 228              LOG.info(&quot;Disabled file extensions:&quot; + disabledFileExtensions);
 229              if (extensions.contains(extension)) {
 230                  LOG.error(&quot;Invalid extension type of file &quot; + file.getName());
 231                  throw new IOException(&quot;Invalid extension type of file.&quot;);
 232              }
 233          }
 234      }
 235  
 236      @Override
 237      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 238      public StaticAsset createStaticAssetFromFile(MultipartFile file, Map&lt;String, String&gt; properties) {
 239          try {
 240              validateFileExtension(file);
 241              staticAssetStorageService.validateFileSize(file);
 242              String fileName = normalizeFileExtension(file);
 243              boolean b = validateFileName(fileName);
 244              if(b){
<abbr title=" 245                  fileName = fileName.replaceAll(&quot;[&quot; + String.valueOf(notAllowedCharsInFileName) + &quot;]&quot;, replacementString);"> 245                  fileName = fileName.replaceAll(&quot;[&quot; + String.valueOf(notAllowedCharsInFileName) + &quot;]&quot;, replacementSðŸ”µ</abbr>
 246              }
 247              return createStaticAsset(file.getInputStream(), fileName, file.getSize(), properties);
 248          } catch (IOException e) {
 249              throw new RuntimeException(e);
 250          }
 251      }
 252  
 253      protected boolean validateFileName(String fileName) {
 254          boolean result = StringUtils.containsAny(fileName, notAllowedCharsInFileName);
 255          if(exceptionOnInvalidChar &amp;&amp; result){
<abbr title=" 256              throw new RuntimeException(&quot;File contains illegal chars. Illegal chars are:[&quot; + String.valueOf(notAllowedCharsInFileName)+&quot;]&quot;);"> 256              throw new RuntimeException(&quot;File contains illegal chars. Illegal chars are:[&quot; + String.valueOf(notAlloðŸ”µ</abbr>
 257          }
 258          return result;
 259      }
 260  
 261      @Override
 262      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
<abbr title=" 263      public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;String, String&gt; properties) {"> 263      public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;String, StriðŸ”µ</abbr>
 264          if (properties == null) {
 265              properties = new HashMap&lt;String, String&gt;();
 266          }
 267  
 268          String fullUrl = buildAssetURL(properties, fileName);
 269          StringBuilder urlBuilder = new StringBuilder();
 270          urlBuilder.append(fullUrl);
<abbr title=" 271          ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicateAssetURL(urlBuilder);"> 271          ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicateAssetURðŸ”µ</abbr>
 272          fullUrl = urlBuilder.toString();
 273          StaticAsset newAsset = staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 274          // If no ExtensionManager modified the URL to handle duplicates, then go ahead and run default
 275          // logic for handling duplicate files.
 276          if (resultStatusType != ExtensionResultStatusType.HANDLED) {
 277              int count = 0;
 278              while (newAsset != null) {
 279                  count++;
 280                  //try the new format first, then the old
 281                  newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, false));
 282                  if (newAsset == null) {
 283                      newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, true));
 284                  }
 285              }
 286  
 287              if (count &gt; 0) {
 288                  fullUrl = getCountUrl(fullUrl, count, false);
 289              }
 290          }
 291  
 292          try {
 293              ImageMetadata metadata = imageArtifactProcessor.getImageMetadata(inputStream);
 294              newAsset = new ImageStaticAssetImpl();
 295              ((ImageStaticAsset) newAsset).setWidth(metadata.getWidth());
 296              ((ImageStaticAsset) newAsset).setHeight(metadata.getHeight());
 297          } catch (Exception e) {
 298              //must not be an image stream
 299              LOG.warn(&quot;unable to convert asset:&quot; + fileName + &quot; into Image&quot;);
 300              LOG.debug(e);
 301  
 302              if (getShouldAcceptNonImageAsset()) {
 303                  newAsset = createNonImageAsset(inputStream, fileName, properties);
 304              } else {
 305                  throw new RuntimeException(&quot;Selected Asset/File was not valid image.&quot;);
 306              }
 307          }
 308          if (storeAssetsOnFileSystem) {
 309              newAsset.setStorageType(StorageType.FILESYSTEM);
 310          } else {
 311              newAsset.setStorageType(StorageType.DATABASE);
 312          }
 313  
 314          newAsset.setName(fileName);
 315          getMimeType(inputStream, fileName, newAsset);
 316          newAsset.setFileExtension(getFileExtension(fileName));
 317          newAsset.setFileSize(fileSize);
 318          newAsset.setFullUrl(fullUrl);
 319  
 320          return staticAssetDao.addOrUpdateStaticAsset(newAsset, false);
 321      }
 322  
 323      /**
 324       * Hook-point for implementors to add custom business logic for handling files that are non-images
 325       *
 326       * @param inputStream
 327       * @param fileName
 328       * @param properties
 329       * @return
 330       */
<abbr title=" 331      protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, String&gt; properties) {"> 331      protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, String&gt; properðŸ”µ</abbr>
 332          return new StaticAssetImpl();
 333      }
 334  
 335      /**
 336       * Gets the count URL based on the original fullUrl. If requested in legacy format this will return URLs like:
 337       * &lt;p&gt;
 338       * /path/to/image.jpg-1
 339       * /path/to/image.jpg-2
 340       * &lt;p&gt;
 341       * Whereas if this is in non-legacy format (&lt;b&gt;legacy&lt;/b&gt; == false):
 342       * &lt;p&gt;
 343       * /path/to/image-1.jpg
 344       * /path/to/image-2.jpg
 345       * &lt;p&gt;
 346       * Used to deal with duplicate URLs of uploaded assets
 347       */
 348      protected String getCountUrl(String fullUrl, int count, boolean legacyFormat) {
 349          String countUrl = fullUrl + &#x27;-&#x27; + count;
 350          int dotIndex = fullUrl.lastIndexOf(&#x27;.&#x27;);
 351          if (dotIndex != -1 &amp;&amp; !legacyFormat) {
 352              countUrl = fullUrl.substring(0, dotIndex) + &#x27;-&#x27; + count + &#x27;.&#x27; + fullUrl.substring(dotIndex + 1);
 353          }
 354  
 355          return countUrl;
 356      }
 357  
 358      protected void getMimeType(InputStream inputStream, String fileName, StaticAsset newAsset) {
 359          Tika tika = new Tika();
 360          String tikaMimeType = tika.detect(fileName);
 361          if (tikaMimeType == null) {
 362              try {
 363                  tikaMimeType = tika.detect(inputStream);
 364              } catch (IOException e) {
 365                  //if tika can&#x27;t resolve, don&#x27;t throw exception
 366              }
 367          }
 368          if (tikaMimeType != null) {
 369              newAsset.setMimeType(tikaMimeType);
 370          }
 371      }
 372  
 373      @Override
 374      public StaticAsset findStaticAssetByFullUrl(String fullUrl) {
 375          try {
 376              fullUrl = URLDecoder.decode(fullUrl, &quot;UTF-8&quot;);
 377              //strip out the jsessionid if it&#x27;s there
 378              fullUrl = fullUrl.replaceAll(&quot;(?i);jsessionid.*?=.*?(?=\\?|$)&quot;, &quot;&quot;);
 379          } catch (UnsupportedEncodingException e) {
 380              throw new RuntimeException(&quot;Unsupported encoding to decode fullUrl&quot;, e);
 381          }
 382          return staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 383      }
 384  
 385      @Override
 386      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 387      public StaticAsset addStaticAsset(StaticAsset staticAsset) {
 388          StaticAsset newAsset = staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 389          return newAsset;
 390      }
 391  
 392      @Override
 393      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 394      public StaticAsset updateStaticAsset(StaticAsset staticAsset) {
 395          return staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 396      }
 397  
 398      @Override
 399      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 400      public void deleteStaticAsset(StaticAsset staticAsset) {
 401          staticAssetDao.delete(staticAsset);
 402      }
 403  
 404      @Override
 405      public String getStaticAssetUrlPrefix() {
 406          return staticAssetPathService.getStaticAssetUrlPrefix();
 407      }
 408  
 409      @Override
 410      public String getPrefixedStaticAssetUrl(String assetUrl) {
 411          String staticAssetUrlPrefix = getStaticAssetUrlPrefix();
 412          if (staticAssetUrlPrefix != null &amp;&amp; !staticAssetUrlPrefix.startsWith(&quot;/&quot;)) {
 413              staticAssetUrlPrefix = &quot;/&quot; + staticAssetUrlPrefix;
 414          }
 415          if (staticAssetUrlPrefix != null) {
 416              return staticAssetUrlPrefix + assetUrl;
 417          }
 418          return assetUrl;
 419      }
 420  
 421      @Override
 422      public String getStaticAssetEnvironmentUrlPrefix() {
 423          return staticAssetPathService.getStaticAssetEnvironmentUrlPrefix();
 424      }
 425  
 426      @Override
 427      public String getStaticAssetEnvironmentSecureUrlPrefix() {
 428          return staticAssetPathService.getStaticAssetEnvironmentSecureUrlPrefix();
 429      }
 430  
 431      @Override
 432      public String convertAssetPath(String assetPath, String contextPath, boolean secureRequest) {
 433          return staticAssetPathService.convertAssetPath(assetPath, contextPath, secureRequest);
 434      }
 435  
 436      public boolean getShouldAcceptNonImageAsset() {
 437          return shouldAcceptNonImageAsset;
 438      }
 439  
 440      public void setShouldAcceptNonImageAsset(boolean accept) {
 441          shouldAcceptNonImageAsset = accept;
 442      }
 443  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            